begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2014, Juniper Networks, Inc.  * All rights reserved.  * This SOFTWARE is licensed under the LICENSE provided in the  * ../Copyright file. By downloading, installing, copying, or otherwise  * using the SOFTWARE, you agree to be bound by the terms of that  * LICENSE.  * Phil Shafer, July 2014  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<wctype.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|"xoconfig.h"
end_include

begin_include
include|#
directive|include
file|"xo.h"
end_include

begin_include
include|#
directive|include
file|"xoversion.h"
end_include

begin_decl_stmt
specifier|const
name|char
name|xo_version
index|[]
init|=
name|LIBXO_VERSION
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|xo_version_extra
index|[]
init|=
name|LIBXO_VERSION_EXTRA
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|UNUSED
end_ifndef

begin_define
define|#
directive|define
name|UNUSED
value|__attribute__ ((__unused__))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNUSED */
end_comment

begin_define
define|#
directive|define
name|XO_INDENT_BY
value|2
end_define

begin_comment
comment|/* Amount to indent when pretty printing */
end_comment

begin_define
define|#
directive|define
name|XO_BUFSIZ
value|(8*1024)
end_define

begin_comment
comment|/* Initial buffer size */
end_comment

begin_define
define|#
directive|define
name|XO_DEPTH
value|512
end_define

begin_comment
comment|/* Default stack depth */
end_comment

begin_define
define|#
directive|define
name|XO_MAX_ANCHOR_WIDTH
value|(8*1024)
end_define

begin_comment
comment|/* Anything wider is just sillyb */
end_comment

begin_define
define|#
directive|define
name|XO_FAILURE_NAME
value|"failure"
end_define

begin_comment
comment|/*  * xo_buffer_t: a memory buffer that can be grown as needed.  We  * use them for building format strings and output data.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|xo_buffer_s
block|{
name|char
modifier|*
name|xb_bufp
decl_stmt|;
comment|/* Buffer memory */
name|char
modifier|*
name|xb_curp
decl_stmt|;
comment|/* Current insertion point */
name|int
name|xb_size
decl_stmt|;
comment|/* Size of buffer */
block|}
name|xo_buffer_t
typedef|;
end_typedef

begin_comment
comment|/* Flags for the stack frame */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|xo_xsf_flags_t
typedef|;
end_typedef

begin_comment
comment|/* XSF_* flags */
end_comment

begin_define
define|#
directive|define
name|XSF_NOT_FIRST
value|(1<<0)
end_define

begin_comment
comment|/* Not the first element */
end_comment

begin_define
define|#
directive|define
name|XSF_LIST
value|(1<<1)
end_define

begin_comment
comment|/* Frame is a list */
end_comment

begin_define
define|#
directive|define
name|XSF_INSTANCE
value|(1<<2)
end_define

begin_comment
comment|/* Frame is an instance */
end_comment

begin_define
define|#
directive|define
name|XSF_DTRT
value|(1<<3)
end_define

begin_comment
comment|/* Save the name for DTRT mode */
end_comment

begin_comment
comment|/*  * xo_stack_t: As we open and close containers and levels, we  * create a stack of frames to track them.  This is needed for  * XOF_WARN and XOF_XPATH.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|xo_stack_s
block|{
name|xo_xsf_flags_t
name|xs_flags
decl_stmt|;
comment|/* Flags for this frame */
name|char
modifier|*
name|xs_name
decl_stmt|;
comment|/* Name (for XPath value) */
name|char
modifier|*
name|xs_keys
decl_stmt|;
comment|/* XPath predicate for any key fields */
block|}
name|xo_stack_t
typedef|;
end_typedef

begin_comment
comment|/*  * xo_handle_t: this is the principle data structure for libxo.  * It's used as a store for state, options, and content.  */
end_comment

begin_struct
struct|struct
name|xo_handle_s
block|{
name|unsigned
name|long
name|xo_flags
decl_stmt|;
comment|/* Flags */
name|unsigned
name|short
name|xo_style
decl_stmt|;
comment|/* XO_STYLE_* value */
name|unsigned
name|short
name|xo_indent
decl_stmt|;
comment|/* Indent level (if pretty) */
name|unsigned
name|short
name|xo_indent_by
decl_stmt|;
comment|/* Indent amount (tab stop) */
name|xo_write_func_t
name|xo_write
decl_stmt|;
comment|/* Write callback */
name|xo_close_func_t
name|xo_close
decl_stmt|;
comment|/* Clo;se callback */
name|xo_formatter_t
name|xo_formatter
decl_stmt|;
comment|/* Custom formating function */
name|xo_checkpointer_t
name|xo_checkpointer
decl_stmt|;
comment|/* Custom formating support function */
name|void
modifier|*
name|xo_opaque
decl_stmt|;
comment|/* Opaque data for write function */
name|FILE
modifier|*
name|xo_fp
decl_stmt|;
comment|/* XXX File pointer */
name|xo_buffer_t
name|xo_data
decl_stmt|;
comment|/* Output data */
name|xo_buffer_t
name|xo_fmt
decl_stmt|;
comment|/* Work area for building format strings */
name|xo_buffer_t
name|xo_attrs
decl_stmt|;
comment|/* Work area for building XML attributes */
name|xo_buffer_t
name|xo_predicate
decl_stmt|;
comment|/* Work area for building XPath predicates */
name|xo_stack_t
modifier|*
name|xo_stack
decl_stmt|;
comment|/* Stack pointer */
name|int
name|xo_depth
decl_stmt|;
comment|/* Depth of stack */
name|int
name|xo_stack_size
decl_stmt|;
comment|/* Size of the stack */
name|xo_info_t
modifier|*
name|xo_info
decl_stmt|;
comment|/* Info fields for all elements */
name|int
name|xo_info_count
decl_stmt|;
comment|/* Number of info entries */
name|va_list
name|xo_vap
decl_stmt|;
comment|/* Variable arguments (stdargs) */
name|char
modifier|*
name|xo_leading_xpath
decl_stmt|;
comment|/* A leading XPath expression */
name|mbstate_t
name|xo_mbstate
decl_stmt|;
comment|/* Multi-byte character conversion state */
name|unsigned
name|xo_anchor_offset
decl_stmt|;
comment|/* Start of anchored text */
name|unsigned
name|xo_anchor_columns
decl_stmt|;
comment|/* Number of columns since the start anchor */
name|int
name|xo_anchor_min_width
decl_stmt|;
comment|/* Desired width of anchored text */
name|unsigned
name|xo_units_offset
decl_stmt|;
comment|/* Start of units insertion point */
name|unsigned
name|xo_columns
decl_stmt|;
comment|/* Columns emitted during this xo_emit call */
block|}
struct|;
end_struct

begin_comment
comment|/* Flags for formatting functions */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|long
name|xo_xff_flags_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|XFF_COLON
value|(1<<0)
end_define

begin_comment
comment|/* Append a ":" */
end_comment

begin_define
define|#
directive|define
name|XFF_COMMA
value|(1<<1)
end_define

begin_comment
comment|/* Append a "," iff there's more output */
end_comment

begin_define
define|#
directive|define
name|XFF_WS
value|(1<<2)
end_define

begin_comment
comment|/* Append a blank */
end_comment

begin_define
define|#
directive|define
name|XFF_ENCODE_ONLY
value|(1<<3)
end_define

begin_comment
comment|/* Only emit for encoding formats (xml and json) */
end_comment

begin_define
define|#
directive|define
name|XFF_QUOTE
value|(1<<4)
end_define

begin_comment
comment|/* Force quotes */
end_comment

begin_define
define|#
directive|define
name|XFF_NOQUOTE
value|(1<<5)
end_define

begin_comment
comment|/* Force no quotes */
end_comment

begin_define
define|#
directive|define
name|XFF_DISPLAY_ONLY
value|(1<<6)
end_define

begin_comment
comment|/* Only emit for display formats (text and html) */
end_comment

begin_define
define|#
directive|define
name|XFF_KEY
value|(1<<7)
end_define

begin_comment
comment|/* Field is a key (for XPath) */
end_comment

begin_define
define|#
directive|define
name|XFF_XML
value|(1<<8)
end_define

begin_comment
comment|/* Force XML encoding style (for XPath) */
end_comment

begin_define
define|#
directive|define
name|XFF_ATTR
value|(1<<9)
end_define

begin_comment
comment|/* Escape value using attribute rules (XML) */
end_comment

begin_define
define|#
directive|define
name|XFF_BLANK_LINE
value|(1<<10)
end_define

begin_comment
comment|/* Emit a blank line */
end_comment

begin_define
define|#
directive|define
name|XFF_NO_OUTPUT
value|(1<<11)
end_define

begin_comment
comment|/* Do not make any output */
end_comment

begin_define
define|#
directive|define
name|XFF_TRIM_WS
value|(1<<12)
end_define

begin_comment
comment|/* Trim whitespace off encoded values */
end_comment

begin_define
define|#
directive|define
name|XFF_LEAF_LIST
value|(1<<13)
end_define

begin_comment
comment|/* A leaf-list (list of values) */
end_comment

begin_define
define|#
directive|define
name|XFF_UNESCAPE
value|(1<<14)
end_define

begin_comment
comment|/* Need to printf-style unescape the value */
end_comment

begin_comment
comment|/*  * Normal printf has width and precision, which for strings operate as  * min and max number of columns.  But this depends on the idea that  * one byte means one column, which UTF-8 and multi-byte characters  * pitches on its ear.  It may take 40 bytes of data to populate 14  * columns, but we can't go off looking at 40 bytes of data without the  * caller's permission for fear/knowledge that we'll generate core files.  *   * So we make three values, distinguishing between "max column" and  * "number of bytes that we will inspect inspect safely" We call the  * later "size", and make the format "%[[<min>].[[<size>].<max>]]s".  *  * Under the "first do no harm" theory, we default "max" to "size".  * This is a reasonable assumption for folks that don't grok the  * MBS/WCS/UTF-8 world, and while it will be annoying, it will never  * be evil.  *  * For example, xo_emit("{:tag/%-14.14s}", buf) will make 14  * columns of output, but will never look at more than 14 bytes of the  * input buffer.  This is mostly compatible with printf and caller's  * expectations.  *  * In contrast xo_emit("{:tag/%-14..14s}", buf) will look at however  * many bytes (or until a NUL is seen) are needed to fill 14 columns  * of output.  xo_emit("{:tag/%-14.*.14s}", xx, buf) will look at up  * to xx bytes (or until a NUL is seen) in order to fill 14 columns  * of output.  *  * It's fairly amazing how a good idea (handle all languages of the  * world) blows such a big hole in the bottom of the fairly weak boat  * that is C string handling.  The simplicity and completenesss are  * sunk in ways we haven't even begun to understand.  */
end_comment

begin_define
define|#
directive|define
name|XF_WIDTH_MIN
value|0
end_define

begin_comment
comment|/* Minimal width */
end_comment

begin_define
define|#
directive|define
name|XF_WIDTH_SIZE
value|1
end_define

begin_comment
comment|/* Maximum number of bytes to examine */
end_comment

begin_define
define|#
directive|define
name|XF_WIDTH_MAX
value|2
end_define

begin_comment
comment|/* Maximum width */
end_comment

begin_define
define|#
directive|define
name|XF_WIDTH_NUM
value|3
end_define

begin_comment
comment|/* Numeric fields in printf (min.size.max) */
end_comment

begin_comment
comment|/* Input and output string encodings */
end_comment

begin_define
define|#
directive|define
name|XF_ENC_WIDE
value|1
end_define

begin_comment
comment|/* Wide characters (wchar_t) */
end_comment

begin_define
define|#
directive|define
name|XF_ENC_UTF8
value|2
end_define

begin_comment
comment|/* UTF-8 */
end_comment

begin_define
define|#
directive|define
name|XF_ENC_LOCALE
value|3
end_define

begin_comment
comment|/* Current locale */
end_comment

begin_comment
comment|/*  * A place to parse printf-style format flags for each field  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|xo_format_s
block|{
name|unsigned
name|char
name|xf_fc
decl_stmt|;
comment|/* Format character */
name|unsigned
name|char
name|xf_enc
decl_stmt|;
comment|/* Encoding of the string (XF_ENC_*) */
name|unsigned
name|char
name|xf_skip
decl_stmt|;
comment|/* Skip this field */
name|unsigned
name|char
name|xf_lflag
decl_stmt|;
comment|/* 'l' (long) */
name|unsigned
name|char
name|xf_hflag
decl_stmt|;
empty_stmt|;
comment|/* 'h' (half) */
name|unsigned
name|char
name|xf_jflag
decl_stmt|;
comment|/* 'j' (intmax_t) */
name|unsigned
name|char
name|xf_tflag
decl_stmt|;
comment|/* 't' (ptrdiff_t) */
name|unsigned
name|char
name|xf_zflag
decl_stmt|;
comment|/* 'z' (size_t) */
name|unsigned
name|char
name|xf_qflag
decl_stmt|;
comment|/* 'q' (quad_t) */
name|unsigned
name|char
name|xf_seen_minus
decl_stmt|;
comment|/* Seen a minus */
name|int
name|xf_leading_zero
decl_stmt|;
comment|/* Seen a leading zero (zero fill)  */
name|unsigned
name|xf_dots
decl_stmt|;
comment|/* Seen one or more '.'s */
name|int
name|xf_width
index|[
name|XF_WIDTH_NUM
index|]
decl_stmt|;
comment|/* Width/precision/size numeric fields */
name|unsigned
name|xf_stars
decl_stmt|;
comment|/* Seen one or more '*'s */
name|unsigned
name|char
name|xf_star
index|[
name|XF_WIDTH_NUM
index|]
decl_stmt|;
comment|/* Seen one or more '*'s */
block|}
name|xo_format_t
typedef|;
end_typedef

begin_comment
comment|/*  * We keep a default handle to allow callers to avoid having to  * allocate one.  Passing NULL to any of our functions will use  * this default handle.  */
end_comment

begin_decl_stmt
specifier|static
name|xo_handle_t
name|xo_default_handle
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xo_default_inited
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xo_locale_inited
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|xo_program
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * To allow libxo to be used in diverse environment, we allow the  * caller to give callbacks for memory allocation.  */
end_comment

begin_decl_stmt
specifier|static
name|xo_realloc_func_t
name|xo_realloc
init|=
name|realloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xo_free_func_t
name|xo_free
init|=
name|free
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations */
end_comment

begin_function_decl
specifier|static
name|void
name|xo_failure
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xo_buf_append_div
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|class
parameter_list|,
name|xo_xff_flags_t
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|nlen
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|int
name|vlen
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
name|int
name|elen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xo_anchor_clear
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Callback to write data to a FILE pointer  */
end_comment

begin_function
specifier|static
name|int
name|xo_write_to_file
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
operator|(
name|FILE
operator|*
operator|)
name|opaque
decl_stmt|;
return|return
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Callback to close a file  */
end_comment

begin_function
specifier|static
name|void
name|xo_close_file
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
operator|(
name|FILE
operator|*
operator|)
name|opaque
decl_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the contents of an xo_buffer_t.  */
end_comment

begin_function
specifier|static
name|void
name|xo_buf_init
parameter_list|(
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|)
block|{
name|xbp
operator|->
name|xb_size
operator|=
name|XO_BUFSIZ
expr_stmt|;
name|xbp
operator|->
name|xb_bufp
operator|=
name|xo_realloc
argument_list|(
name|NULL
argument_list|,
name|xbp
operator|->
name|xb_size
argument_list|)
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|=
name|xbp
operator|->
name|xb_bufp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the contents of an xo_buffer_t.  */
end_comment

begin_function
specifier|static
name|void
name|xo_buf_cleanup
parameter_list|(
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|)
block|{
if|if
condition|(
name|xbp
operator|->
name|xb_bufp
condition|)
name|xo_free
argument_list|(
name|xbp
operator|->
name|xb_bufp
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|xbp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|xbp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_depth_check
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|xo_stack_t
modifier|*
name|xsp
decl_stmt|;
if|if
condition|(
name|depth
operator|>=
name|xop
operator|->
name|xo_stack_size
condition|)
block|{
name|depth
operator|+=
literal|16
expr_stmt|;
name|xsp
operator|=
name|xo_realloc
argument_list|(
name|xop
operator|->
name|xo_stack
argument_list|,
sizeof|sizeof
argument_list|(
name|xop
operator|->
name|xo_stack
index|[
literal|0
index|]
argument_list|)
operator|*
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|xsp
operator|==
name|NULL
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"xo_depth_check: out of memory (%d)"
argument_list|,
name|depth
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|int
name|count
init|=
name|depth
operator|-
name|xop
operator|->
name|xo_stack_size
decl_stmt|;
name|bzero
argument_list|(
name|xsp
operator|+
name|xop
operator|->
name|xo_stack_size
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|xsp
argument_list|)
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_stack_size
operator|=
name|depth
expr_stmt|;
name|xop
operator|->
name|xo_stack
operator|=
name|xsp
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|xo_no_setlocale
parameter_list|(
name|void
parameter_list|)
block|{
name|xo_locale_inited
operator|=
literal|1
expr_stmt|;
comment|/* Skip initialization */
block|}
end_function

begin_comment
comment|/*  * Initialize an xo_handle_t, using both static defaults and  * the global settings from the LIBXO_OPTIONS environment  * variable.  */
end_comment

begin_function
specifier|static
name|void
name|xo_init_handle
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
name|xop
operator|->
name|xo_opaque
operator|=
name|stdout
expr_stmt|;
name|xop
operator|->
name|xo_write
operator|=
name|xo_write_to_file
expr_stmt|;
comment|/*      * We need to initialize the locale, which isn't really pretty.      * Libraries should depend on their caller to set up the      * environment.  But we really can't count on the caller to do      * this, because well, they won't.  Trust me.      */
if|if
condition|(
operator|!
name|xo_locale_inited
condition|)
block|{
name|xo_locale_inited
operator|=
literal|1
expr_stmt|;
comment|/* Only do this once */
specifier|const
name|char
modifier|*
name|cp
init|=
name|getenv
argument_list|(
literal|"LC_CTYPE"
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|getenv
argument_list|(
literal|"LANG"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|getenv
argument_list|(
literal|"LC_ALL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
literal|"UTF-8"
expr_stmt|;
comment|/* Optimistic? */
name|cp
operator|=
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/*      * Initialize only the xo_buffers we know we'll need; the others      * can be allocated as needed.      */
name|xo_buf_init
argument_list|(
operator|&
name|xop
operator|->
name|xo_data
argument_list|)
expr_stmt|;
name|xo_buf_init
argument_list|(
operator|&
name|xop
operator|->
name|xo_fmt
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_indent_by
operator|=
name|XO_INDENT_BY
expr_stmt|;
name|xo_depth_check
argument_list|(
name|xop
argument_list|,
name|XO_DEPTH
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_LIBXO_OPTIONS
argument_list|)
if|if
condition|(
operator|!
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_NO_ENV
operator|)
condition|)
block|{
name|char
modifier|*
name|env
init|=
name|getenv
argument_list|(
literal|"LIBXO_OPTIONS"
argument_list|)
decl_stmt|;
if|if
condition|(
name|env
condition|)
name|xo_set_options
argument_list|(
name|xop
argument_list|,
name|env
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NO_GETENV */
block|}
end_function

begin_comment
comment|/*  * Initialize the default handle.  */
end_comment

begin_function
specifier|static
name|void
name|xo_default_init
parameter_list|(
name|void
parameter_list|)
block|{
name|xo_handle_t
modifier|*
name|xop
init|=
operator|&
name|xo_default_handle
decl_stmt|;
name|xo_init_handle
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|xo_default_inited
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Does the buffer have room for the given number of bytes of data?  * If not, realloc the buffer to make room.  If that fails, we  * return 0 to tell the caller they are in trouble.  */
end_comment

begin_function
specifier|static
name|int
name|xo_buf_has_room
parameter_list|(
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|xbp
operator|->
name|xb_curp
operator|+
name|len
operator|>=
name|xbp
operator|->
name|xb_bufp
operator|+
name|xbp
operator|->
name|xb_size
condition|)
block|{
name|int
name|sz
init|=
name|xbp
operator|->
name|xb_size
operator|+
name|XO_BUFSIZ
decl_stmt|;
name|char
modifier|*
name|bp
init|=
name|xo_realloc
argument_list|(
name|xbp
operator|->
name|xb_bufp
argument_list|,
name|sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
comment|/* 	     * XXX If we wanted to put a stick XOF_ENOMEM on xop, 	     * this would be the place to do it.  But we'd need 	     * to churn the code to pass xop in here.... 	     */
return|return
literal|0
return|;
block|}
name|xbp
operator|->
name|xb_curp
operator|=
name|bp
operator|+
operator|(
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
operator|)
expr_stmt|;
name|xbp
operator|->
name|xb_bufp
operator|=
name|bp
expr_stmt|;
name|xbp
operator|->
name|xb_size
operator|=
name|sz
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Cheap convenience function to return either the argument, or  * the internal handle, after it has been initialized.  The usage  * is:  *    xop = xo_default(xop);  */
end_comment

begin_function
specifier|static
name|xo_handle_t
modifier|*
name|xo_default
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
if|if
condition|(
name|xop
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|xo_default_inited
operator|==
literal|0
condition|)
name|xo_default_init
argument_list|()
expr_stmt|;
name|xop
operator|=
operator|&
name|xo_default_handle
expr_stmt|;
block|}
return|return
name|xop
return|;
block|}
end_function

begin_comment
comment|/*  * Return the number of spaces we should be indenting.  If  * we are pretty-printing, theis is indent * indent_by.  */
end_comment

begin_function
specifier|static
name|int
name|xo_indent
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_PRETTY
condition|)
block|{
name|rc
operator|=
name|xop
operator|->
name|xo_indent
operator|*
name|xop
operator|->
name|xo_indent_by
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_TOP_EMITTED
condition|)
name|rc
operator|+=
name|xop
operator|->
name|xo_indent_by
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_buf_indent
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|xo_buffer_t
modifier|*
name|xbp
init|=
operator|&
name|xop
operator|->
name|xo_data
decl_stmt|;
if|if
condition|(
name|indent
operator|<=
literal|0
condition|)
name|indent
operator|=
name|xo_indent
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|indent
argument_list|)
condition|)
return|return;
name|memset
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
literal|' '
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|+=
name|indent
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|xo_xml_amp
index|[]
init|=
literal|"&amp;"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|xo_xml_lt
index|[]
init|=
literal|"&lt;"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|xo_xml_gt
index|[]
init|=
literal|"&gt;"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|xo_xml_quot
index|[]
init|=
literal|"&quot;"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|xo_escape_xml
parameter_list|(
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|attr
parameter_list|)
block|{
name|int
name|slen
decl_stmt|;
name|unsigned
name|delta
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|ip
decl_stmt|;
specifier|const
name|char
modifier|*
name|sp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|xbp
operator|->
name|xb_curp
operator|,
name|ep
operator|=
name|cp
operator|+
name|len
init|;
name|cp
operator|<
name|ep
condition|;
name|cp
operator|++
control|)
block|{
comment|/* We're subtracting 2: 1 for the NUL, 1 for the char we replace */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'<'
condition|)
name|delta
operator|+=
sizeof|sizeof
argument_list|(
name|xo_xml_lt
argument_list|)
operator|-
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'>'
condition|)
name|delta
operator|+=
sizeof|sizeof
argument_list|(
name|xo_xml_gt
argument_list|)
operator|-
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'&'
condition|)
name|delta
operator|+=
sizeof|sizeof
argument_list|(
name|xo_xml_amp
argument_list|)
operator|-
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|attr
operator|&&
operator|*
name|cp
operator|==
literal|'"'
condition|)
name|delta
operator|+=
sizeof|sizeof
argument_list|(
name|xo_xml_quot
argument_list|)
operator|-
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
comment|/* Nothing to escape; bail */
return|return
name|len
return|;
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|delta
argument_list|)
condition|)
comment|/* No room; bail, but don't append */
return|return
literal|0
return|;
name|ep
operator|=
name|xbp
operator|->
name|xb_curp
expr_stmt|;
name|cp
operator|=
name|ep
operator|+
name|len
expr_stmt|;
name|ip
operator|=
name|cp
operator|+
name|delta
expr_stmt|;
do|do
block|{
name|cp
operator|-=
literal|1
expr_stmt|;
name|ip
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'<'
condition|)
name|sp
operator|=
name|xo_xml_lt
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'>'
condition|)
name|sp
operator|=
name|xo_xml_gt
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'&'
condition|)
name|sp
operator|=
name|xo_xml_amp
expr_stmt|;
elseif|else
if|if
condition|(
name|attr
operator|&&
operator|*
name|cp
operator|==
literal|'"'
condition|)
name|sp
operator|=
name|xo_xml_quot
expr_stmt|;
else|else
block|{
operator|*
name|ip
operator|=
operator|*
name|cp
expr_stmt|;
continue|continue;
block|}
name|slen
operator|=
name|strlen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|ip
operator|-=
name|slen
operator|-
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|ip
argument_list|,
name|sp
argument_list|,
name|slen
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cp
operator|>
name|ep
operator|&&
name|cp
operator|!=
name|ip
condition|)
do|;
return|return
name|len
operator|+
name|delta
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_escape_json
parameter_list|(
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|unsigned
name|delta
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|ip
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|xbp
operator|->
name|xb_curp
operator|,
name|ep
operator|=
name|cp
operator|+
name|len
init|;
name|cp
operator|<
name|ep
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\\'
condition|)
name|delta
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'"'
condition|)
name|delta
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
comment|/* Nothing to escape; bail */
return|return
name|len
return|;
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|delta
argument_list|)
condition|)
comment|/* No room; bail, but don't append */
return|return
literal|0
return|;
name|ep
operator|=
name|xbp
operator|->
name|xb_curp
expr_stmt|;
name|cp
operator|=
name|ep
operator|+
name|len
expr_stmt|;
name|ip
operator|=
name|cp
operator|+
name|delta
expr_stmt|;
do|do
block|{
name|cp
operator|-=
literal|1
expr_stmt|;
name|ip
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\\'
operator|&&
operator|*
name|cp
operator|!=
literal|'"'
condition|)
block|{
operator|*
name|ip
operator|=
operator|*
name|cp
expr_stmt|;
continue|continue;
block|}
operator|*
name|ip
operator|--
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|ip
operator|=
literal|'\\'
expr_stmt|;
block|}
do|while
condition|(
name|cp
operator|>
name|ep
operator|&&
name|cp
operator|!=
name|ip
condition|)
do|;
return|return
name|len
operator|+
name|delta
return|;
block|}
end_function

begin_comment
comment|/*  * Append the given string to the given buffer  */
end_comment

begin_function
specifier|static
name|void
name|xo_buf_append
parameter_list|(
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|len
argument_list|)
condition|)
return|return;
name|memcpy
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|+=
name|len
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_buf_escape
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|,
name|xo_xff_flags_t
name|flags
parameter_list|)
block|{
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|len
argument_list|)
condition|)
return|return;
name|memcpy
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|xop
operator|->
name|xo_style
condition|)
block|{
case|case
name|XO_STYLE_XML
case|:
case|case
name|XO_STYLE_HTML
case|:
name|len
operator|=
name|xo_escape_xml
argument_list|(
name|xbp
argument_list|,
name|len
argument_list|,
operator|(
name|flags
operator|&
name|XFF_ATTR
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_JSON
case|:
name|len
operator|=
name|xo_escape_json
argument_list|(
name|xbp
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
block|}
name|xbp
operator|->
name|xb_curp
operator|+=
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write the current contents of the data buffer using the handle's  * xo_write function.  */
end_comment

begin_function
specifier|static
name|void
name|xo_write
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
name|xo_buffer_t
modifier|*
name|xbp
init|=
operator|&
name|xop
operator|->
name|xo_data
decl_stmt|;
if|if
condition|(
name|xbp
operator|->
name|xb_curp
operator|!=
name|xbp
operator|->
name|xb_bufp
condition|)
block|{
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Append ending NUL */
name|xo_anchor_clear
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_write
argument_list|(
name|xop
operator|->
name|xo_opaque
argument_list|,
name|xbp
operator|->
name|xb_bufp
argument_list|)
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|=
name|xbp
operator|->
name|xb_bufp
expr_stmt|;
block|}
comment|/* Turn off the flags that don't survive across writes */
name|xop
operator|->
name|xo_flags
operator|&=
operator|~
operator|(
name|XOF_UNITS_PENDING
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Format arguments into our buffer.  If a custom formatter has been set,  * we use that to do the work; otherwise we vsnprintf().  */
end_comment

begin_function
specifier|static
name|int
name|xo_vsnprintf
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|vap
parameter_list|)
block|{
name|va_list
name|va_local
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|int
name|left
init|=
name|xbp
operator|->
name|xb_size
operator|-
operator|(
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
operator|)
decl_stmt|;
name|va_copy
argument_list|(
name|va_local
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_formatter
condition|)
name|rc
operator|=
name|xop
operator|->
name|xo_formatter
argument_list|(
name|xop
argument_list|,
name|xbp
operator|->
name|xb_curp
argument_list|,
name|left
argument_list|,
name|fmt
argument_list|,
name|va_local
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|vsnprintf
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|left
argument_list|,
name|fmt
argument_list|,
name|va_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>
name|xbp
operator|->
name|xb_size
condition|)
block|{
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* 	 * After we call vsnprintf(), the stage of vap is not defined. 	 * We need to copy it before we pass.  Then we have to do our 	 * own logic below to move it along.  This is because the 	 * implementation can have va_list be a point (bsd) or a 	 * structure (macosx) or anything in between. 	 */
name|va_end
argument_list|(
name|va_local
argument_list|)
expr_stmt|;
comment|/* Reset vap to the start */
name|va_copy
argument_list|(
name|va_local
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|left
operator|=
name|xbp
operator|->
name|xb_size
operator|-
operator|(
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
operator|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_formatter
condition|)
name|xop
operator|->
name|xo_formatter
argument_list|(
name|xop
argument_list|,
name|xbp
operator|->
name|xb_curp
argument_list|,
name|left
argument_list|,
name|fmt
argument_list|,
name|va_local
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|vsnprintf
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|left
argument_list|,
name|fmt
argument_list|,
name|va_local
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|va_local
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/*  * Print some data thru the handle.  */
end_comment

begin_function
specifier|static
name|int
name|xo_printf_v
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|vap
parameter_list|)
block|{
name|xo_buffer_t
modifier|*
name|xbp
init|=
operator|&
name|xop
operator|->
name|xo_data
decl_stmt|;
name|int
name|left
init|=
name|xbp
operator|->
name|xb_size
operator|-
operator|(
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
operator|)
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|va_list
name|va_local
decl_stmt|;
name|va_copy
argument_list|(
name|va_local
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|rc
operator|=
name|vsnprintf
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|left
argument_list|,
name|fmt
argument_list|,
name|va_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>
name|xbp
operator|->
name|xb_size
condition|)
block|{
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|va_end
argument_list|(
name|va_local
argument_list|)
expr_stmt|;
comment|/* Reset vap to the start */
name|va_copy
argument_list|(
name|va_local
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|left
operator|=
name|xbp
operator|->
name|xb_size
operator|-
operator|(
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
operator|)
expr_stmt|;
name|rc
operator|=
name|vsnprintf
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|left
argument_list|,
name|fmt
argument_list|,
name|va_local
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|va_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
name|xbp
operator|->
name|xb_curp
operator|+=
name|rc
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_printf
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_printf_v
argument_list|(
name|xop
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/*  * These next few function are make The Essential UTF-8 Ginsu Knife.  * Identify an input and output character, and convert it.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|xo_utf8_bits
index|[
literal|7
index|]
init|=
block|{
literal|0
block|,
literal|0x7f
block|,
literal|0x1f
block|,
literal|0x0f
block|,
literal|0x07
block|,
literal|0x03
block|,
literal|0x01
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|xo_is_utf8
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
operator|(
name|ch
operator|&
literal|0x80
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_utf8_to_wc_len
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|unsigned
name|b
init|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|b
operator|&
literal|0x80
operator|)
operator|==
literal|0x0
condition|)
name|len
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|b
operator|&
literal|0xe0
operator|)
operator|==
literal|0xc0
condition|)
name|len
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|b
operator|&
literal|0xf0
operator|)
operator|==
literal|0xe0
condition|)
name|len
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|b
operator|&
literal|0xf8
operator|)
operator|==
literal|0xf0
condition|)
name|len
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|b
operator|&
literal|0xfc
operator|)
operator|==
literal|0xf8
condition|)
name|len
operator|=
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|b
operator|&
literal|0xfe
operator|)
operator|==
literal|0xfc
condition|)
name|len
operator|=
literal|6
expr_stmt|;
else|else
name|len
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_buf_utf8_len
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|bufsiz
parameter_list|)
block|{
name|unsigned
name|b
init|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|len
operator|=
name|xo_utf8_to_wc_len
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"invalid UTF-8 data: %02hhx"
argument_list|,
name|b
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|len
operator|>
name|bufsiz
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"invalid UTF-8 data (short): %02hhx (%d/%d)"
argument_list|,
name|b
argument_list|,
name|len
argument_list|,
name|bufsiz
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
operator|(
name|unsigned
name|char
operator|)
name|buf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|b
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"invalid UTF-8 data (byte %d): %x"
argument_list|,
name|i
argument_list|,
name|b
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/*  * Build a wide character from the input buffer; the number of  * bits we pull off the first character is dependent on the length,  * but we put 6 bits off all other bytes.  */
end_comment

begin_function
specifier|static
name|wchar_t
name|xo_utf8_char
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|wchar_t
name|wc
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|cp
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|buf
decl_stmt|;
name|wc
operator|=
operator|*
name|cp
operator|&
name|xo_utf8_bits
index|[
name|len
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|wc
operator|<<=
literal|6
expr_stmt|;
name|wc
operator||=
name|cp
index|[
name|i
index|]
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
operator|(
name|cp
index|[
name|i
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
return|return
operator|(
name|wchar_t
operator|)
operator|-
literal|1
return|;
block|}
return|return
name|wc
return|;
block|}
end_function

begin_comment
comment|/*  * Determine the number of bytes needed to encode a wide character.  */
end_comment

begin_function
specifier|static
name|int
name|xo_utf8_emit_len
parameter_list|(
name|wchar_t
name|wc
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|wc
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
name|wc
condition|)
comment|/* Simple case */
name|len
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|wc
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|11
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
name|wc
condition|)
name|len
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|wc
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
name|wc
condition|)
name|len
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|wc
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|21
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
name|wc
condition|)
name|len
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|wc
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|26
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
name|wc
condition|)
name|len
operator|=
literal|5
expr_stmt|;
else|else
name|len
operator|=
literal|6
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_utf8_emit_char
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|wchar_t
name|wc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
comment|/* Simple case */
name|buf
index|[
literal|0
index|]
operator|=
name|wc
operator|&
literal|0x7f
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|buf
index|[
name|i
index|]
operator|=
literal|0x80
operator||
operator|(
name|wc
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|wc
operator|>>=
literal|6
expr_stmt|;
block|}
name|buf
index|[
literal|0
index|]
operator|&=
name|xo_utf8_bits
index|[
name|len
index|]
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator||=
operator|~
name|xo_utf8_bits
index|[
name|len
index|]
operator|<<
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_buf_append_locale_from_utf8
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
specifier|const
name|char
modifier|*
name|ibuf
parameter_list|,
name|int
name|ilen
parameter_list|)
block|{
name|wchar_t
name|wc
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/*      * Build our wide character from the input buffer; the number of      * bits we pull off the first character is dependent on the length,      * but we put 6 bits off all other bytes.      */
name|wc
operator|=
name|xo_utf8_char
argument_list|(
name|ibuf
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc
operator|==
operator|(
name|wchar_t
operator|)
operator|-
literal|1
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"invalid utf-8 byte sequence"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_NO_LOCALE
condition|)
block|{
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|ilen
argument_list|)
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|ibuf
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|+=
name|ilen
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|MB_LEN_MAX
operator|+
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
name|bzero
argument_list|(
operator|&
name|xop
operator|->
name|xo_mbstate
argument_list|,
sizeof|sizeof
argument_list|(
name|xop
operator|->
name|xo_mbstate
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|wcrtomb
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|wc
argument_list|,
operator|&
name|xop
operator|->
name|xo_mbstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"could not convert wide char: %lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|wc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|xbp
operator|->
name|xb_curp
operator|+=
name|len
expr_stmt|;
block|}
return|return
name|wcwidth
argument_list|(
name|wc
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_buf_append_locale
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
specifier|const
name|char
modifier|*
name|cp
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|sp
init|=
name|cp
decl_stmt|,
modifier|*
name|ep
init|=
name|cp
operator|+
name|len
decl_stmt|;
name|unsigned
name|save_off
init|=
name|xbp
operator|->
name|xb_bufp
operator|-
name|xbp
operator|->
name|xb_curp
decl_stmt|;
name|int
name|slen
decl_stmt|;
name|int
name|cols
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|cp
operator|<
name|ep
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|xo_is_utf8
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cols
operator|+=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* 	 * We're looking at a non-ascii UTF-8 character. 	 * First we copy the previous data. 	 * Then we need find the length and validate it. 	 * Then we turn it into a wide string. 	 * Then we turn it into a localized string. 	 * Then we repeat.  Isn't i18n fun? 	 */
if|if
condition|(
name|sp
operator|!=
name|cp
condition|)
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|sp
argument_list|,
name|cp
operator|-
name|sp
argument_list|)
expr_stmt|;
comment|/* Append previous data */
name|slen
operator|=
name|xo_buf_utf8_len
argument_list|(
name|xop
argument_list|,
name|cp
argument_list|,
name|ep
operator|-
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|slen
operator|<=
literal|0
condition|)
block|{
comment|/* Bad data; back it all out */
name|xbp
operator|->
name|xb_curp
operator|=
name|xbp
operator|->
name|xb_bufp
operator|+
name|save_off
expr_stmt|;
return|return;
block|}
name|cols
operator|+=
name|xo_buf_append_locale_from_utf8
argument_list|(
name|xop
argument_list|,
name|xbp
argument_list|,
name|cp
argument_list|,
name|slen
argument_list|)
expr_stmt|;
comment|/* Next time thru, we'll start at the next character */
name|cp
operator|+=
name|slen
operator|-
literal|1
expr_stmt|;
name|sp
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Update column values */
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_COLUMNS
condition|)
name|xop
operator|->
name|xo_columns
operator|+=
name|cols
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_ANCHOR
condition|)
name|xop
operator|->
name|xo_anchor_columns
operator|+=
name|cols
expr_stmt|;
comment|/* Before we fall into the basic logic below, we need reset len */
name|len
operator|=
name|ep
operator|-
name|sp
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
comment|/* Append trailing data */
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|sp
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Append the given string to the given buffer  */
end_comment

begin_function
specifier|static
name|void
name|xo_data_append
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|xo_buf_append
argument_list|(
operator|&
name|xop
operator|->
name|xo_data
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Append the given string to the given buffer  */
end_comment

begin_function
specifier|static
name|void
name|xo_data_escape
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|xo_buf_escape
argument_list|(
name|xop
argument_list|,
operator|&
name|xop
operator|->
name|xo_data
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate a warning.  Normally, this is a text message written to  * standard error.  If the XOF_WARN_XML flag is set, then we generate  * XMLified content on standard output.  */
end_comment

begin_function
specifier|static
name|void
name|xo_warn_hcv
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|check_warn
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|vap
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_warn
operator|&&
operator|!
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_WARN
operator|)
condition|)
return|return;
if|if
condition|(
name|fmt
operator|==
name|NULL
condition|)
return|return;
name|int
name|len
init|=
name|strlen
argument_list|(
name|fmt
argument_list|)
decl_stmt|;
name|int
name|plen
init|=
name|xo_program
condition|?
name|strlen
argument_list|(
name|xo_program
argument_list|)
else|:
literal|0
decl_stmt|;
name|char
modifier|*
name|newfmt
init|=
name|alloca
argument_list|(
name|len
operator|+
literal|2
operator|+
name|plen
operator|+
literal|2
argument_list|)
decl_stmt|;
comment|/* newline, NUL, and ": " */
if|if
condition|(
name|plen
condition|)
block|{
name|memcpy
argument_list|(
name|newfmt
argument_list|,
name|xo_program
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|newfmt
index|[
name|plen
operator|++
index|]
operator|=
literal|':'
expr_stmt|;
name|newfmt
index|[
name|plen
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|newfmt
operator|+
name|plen
argument_list|,
name|fmt
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Add a newline to the fmt string */
if|if
condition|(
operator|!
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_WARN_XML
operator|)
condition|)
name|newfmt
index|[
name|len
operator|++
operator|+
name|plen
index|]
operator|=
literal|'\n'
expr_stmt|;
name|newfmt
index|[
name|len
operator|+
name|plen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_WARN_XML
condition|)
block|{
specifier|static
name|char
name|err_open
index|[]
init|=
literal|"<error>"
decl_stmt|;
specifier|static
name|char
name|err_close
index|[]
init|=
literal|"</error>"
decl_stmt|;
specifier|static
name|char
name|msg_open
index|[]
init|=
literal|"<message>"
decl_stmt|;
specifier|static
name|char
name|msg_close
index|[]
init|=
literal|"</message>"
decl_stmt|;
name|xo_buffer_t
modifier|*
name|xbp
init|=
operator|&
name|xop
operator|->
name|xo_data
decl_stmt|;
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|err_open
argument_list|,
sizeof|sizeof
argument_list|(
name|err_open
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|msg_open
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_open
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|va_list
name|va_local
decl_stmt|;
name|va_copy
argument_list|(
name|va_local
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|int
name|left
init|=
name|xbp
operator|->
name|xb_size
operator|-
operator|(
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
operator|)
decl_stmt|;
name|int
name|rc
init|=
name|vsnprintf
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|left
argument_list|,
name|newfmt
argument_list|,
name|vap
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|>
name|xbp
operator|->
name|xb_size
condition|)
block|{
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|)
condition|)
return|return;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
comment|/* Reset vap to the start */
name|va_copy
argument_list|(
name|vap
argument_list|,
name|va_local
argument_list|)
expr_stmt|;
name|left
operator|=
name|xbp
operator|->
name|xb_size
operator|-
operator|(
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
operator|)
expr_stmt|;
name|rc
operator|=
name|vsnprintf
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|left
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|va_local
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_escape_xml
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|+=
name|rc
expr_stmt|;
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|msg_close
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_close
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|err_close
argument_list|,
sizeof|sizeof
argument_list|(
name|err_close
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|strerror
argument_list|(
name|code
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg
condition|)
block|{
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
literal|": "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|msg
argument_list|,
name|strlen
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
literal|"\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Append newline and NUL to string */
name|xo_write
argument_list|(
name|xop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|newfmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|xo_warn_hc
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_warn_hcv
argument_list|(
name|xop
argument_list|,
name|code
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_warn_c
parameter_list|(
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_warn_hcv
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|code
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_warn
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|code
init|=
name|errno
decl_stmt|;
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_warn_hcv
argument_list|(
name|NULL
argument_list|,
name|code
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_warnx
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_warn_hcv
argument_list|(
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_err
parameter_list|(
name|int
name|eval
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|code
init|=
name|errno
decl_stmt|;
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_warn_hcv
argument_list|(
name|NULL
argument_list|,
name|code
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|xo_finish
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|eval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_errx
parameter_list|(
name|int
name|eval
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_warn_hcv
argument_list|(
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|xo_finish
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|eval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_errc
parameter_list|(
name|int
name|eval
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_warn_hcv
argument_list|(
name|NULL
argument_list|,
name|code
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|xo_finish
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|eval
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate a warning.  Normally, this is a text message written to  * standard error.  If the XOF_WARN_XML flag is set, then we generate  * XMLified content on standard output.  */
end_comment

begin_function
name|void
name|xo_message_hcv
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|vap
parameter_list|)
block|{
specifier|static
name|char
name|msg_open
index|[]
init|=
literal|"<message>"
decl_stmt|;
specifier|static
name|char
name|msg_close
index|[]
init|=
literal|"</message>"
decl_stmt|;
name|xo_buffer_t
modifier|*
name|xbp
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|va_list
name|va_local
decl_stmt|;
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|NULL
operator|||
operator|*
name|fmt
operator|==
literal|'\0'
condition|)
return|return;
name|int
name|need_nl
init|=
operator|(
name|fmt
index|[
name|strlen
argument_list|(
name|fmt
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'\n'
operator|)
decl_stmt|;
switch|switch
condition|(
name|xop
operator|->
name|xo_style
condition|)
block|{
case|case
name|XO_STYLE_XML
case|:
name|xbp
operator|=
operator|&
name|xop
operator|->
name|xo_data
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_PRETTY
condition|)
name|xo_buf_indent
argument_list|(
name|xop
argument_list|,
name|xop
operator|->
name|xo_indent_by
argument_list|)
expr_stmt|;
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|msg_open
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_open
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|va_copy
argument_list|(
name|va_local
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|int
name|left
init|=
name|xbp
operator|->
name|xb_size
operator|-
operator|(
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
operator|)
decl_stmt|;
name|rc
operator|=
name|vsnprintf
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|left
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>
name|xbp
operator|->
name|xb_size
condition|)
block|{
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|)
condition|)
return|return;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
comment|/* Reset vap to the start */
name|va_copy
argument_list|(
name|vap
argument_list|,
name|va_local
argument_list|)
expr_stmt|;
name|left
operator|=
name|xbp
operator|->
name|xb_size
operator|-
operator|(
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
operator|)
expr_stmt|;
name|rc
operator|=
name|vsnprintf
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|left
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|va_local
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_escape_xml
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|+=
name|rc
expr_stmt|;
if|if
condition|(
name|need_nl
operator|&&
name|code
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|strerror
argument_list|(
name|code
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg
condition|)
block|{
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
literal|": "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|msg
argument_list|,
name|strlen
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|msg_close
argument_list|,
sizeof|sizeof
argument_list|(
name|msg_close
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_nl
condition|)
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
literal|"\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Append newline and NUL to string */
name|xo_write
argument_list|(
name|xop
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_HTML
case|:
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|bp
init|=
name|buf
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|bufsiz
init|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|int
name|rc2
decl_stmt|;
name|va_copy
argument_list|(
name|va_local
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|rc
operator|=
name|vsnprintf
argument_list|(
name|buf
argument_list|,
name|bufsiz
argument_list|,
name|fmt
argument_list|,
name|va_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>
name|bufsiz
condition|)
block|{
name|bufsiz
operator|=
name|rc
operator|+
name|BUFSIZ
expr_stmt|;
name|bp
operator|=
name|alloca
argument_list|(
name|bufsiz
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|va_local
argument_list|)
expr_stmt|;
name|va_copy
argument_list|(
name|va_local
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|rc
operator|=
name|vsnprintf
argument_list|(
name|buf
argument_list|,
name|bufsiz
argument_list|,
name|fmt
argument_list|,
name|va_local
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|bp
operator|+
name|rc
expr_stmt|;
if|if
condition|(
name|need_nl
condition|)
block|{
name|rc2
operator|=
name|snprintf
argument_list|(
name|cp
argument_list|,
name|bufsiz
operator|-
name|rc
argument_list|,
literal|"%s%s\n"
argument_list|,
operator|(
name|code
operator|>
literal|0
operator|)
condition|?
literal|": "
else|:
literal|""
argument_list|,
operator|(
name|code
operator|>
literal|0
operator|)
condition|?
name|strerror
argument_list|(
name|code
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc2
operator|>
literal|0
condition|)
name|rc
operator|+=
name|rc2
expr_stmt|;
block|}
name|xo_buf_append_div
argument_list|(
name|xop
argument_list|,
literal|"message"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|bp
argument_list|,
name|rc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XO_STYLE_JSON
case|:
comment|/* No meanings of representing messages in JSON */
break|break;
case|case
name|XO_STYLE_TEXT
case|:
name|rc
operator|=
name|xo_printf_v
argument_list|(
name|xop
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
comment|/* 	 * XXX need to handle UTF-8 widths 	 */
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_COLUMNS
condition|)
name|xop
operator|->
name|xo_columns
operator|+=
name|rc
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_ANCHOR
condition|)
name|xop
operator|->
name|xo_anchor_columns
operator|+=
name|rc
expr_stmt|;
block|}
if|if
condition|(
name|need_nl
operator|&&
name|code
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|strerror
argument_list|(
name|code
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg
condition|)
block|{
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|": %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|need_nl
condition|)
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|xo_flush_h
argument_list|(
name|xop
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_message_hc
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_message_hcv
argument_list|(
name|xop
argument_list|,
name|code
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_message_c
parameter_list|(
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_message_hcv
argument_list|(
name|NULL
argument_list|,
name|code
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_message
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|code
init|=
name|errno
decl_stmt|;
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_message_hcv
argument_list|(
name|NULL
argument_list|,
name|code
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_failure
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_WARN
operator|)
condition|)
return|return;
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_warn_hcv
argument_list|(
name|xop
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Create a handle for use by later libxo functions.  *  * Note: normal use of libxo does not require a distinct handle, since  * the default handle (used when NULL is passed) generates text on stdout.  *  * @style Style of output desired (XO_STYLE_* value)  * @flags Set of XOF_* flags in use with this handle  */
end_comment

begin_function
name|xo_handle_t
modifier|*
name|xo_create
parameter_list|(
name|xo_style_t
name|style
parameter_list|,
name|xo_xof_flags_t
name|flags
parameter_list|)
block|{
name|xo_handle_t
modifier|*
name|xop
init|=
name|xo_realloc
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|xop
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|xop
condition|)
block|{
name|bzero
argument_list|(
name|xop
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|xop
argument_list|)
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_style
operator|=
name|style
expr_stmt|;
name|xop
operator|->
name|xo_flags
operator|=
name|flags
expr_stmt|;
name|xo_init_handle
argument_list|(
name|xop
argument_list|)
expr_stmt|;
block|}
return|return
name|xop
return|;
block|}
end_function

begin_comment
comment|/**  * Create a handle that will write to the given file.  Use  * the XOF_CLOSE_FP flag to have the file closed on xo_destroy().  * @fp FILE pointer to use  * @style Style of output desired (XO_STYLE_* value)  * @flags Set of XOF_* flags to use with this handle  */
end_comment

begin_function
name|xo_handle_t
modifier|*
name|xo_create_to_file
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|xo_style_t
name|style
parameter_list|,
name|xo_xof_flags_t
name|flags
parameter_list|)
block|{
name|xo_handle_t
modifier|*
name|xop
init|=
name|xo_create
argument_list|(
name|style
argument_list|,
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|xop
condition|)
block|{
name|xop
operator|->
name|xo_opaque
operator|=
name|fp
expr_stmt|;
name|xop
operator|->
name|xo_write
operator|=
name|xo_write_to_file
expr_stmt|;
name|xop
operator|->
name|xo_close
operator|=
name|xo_close_file
expr_stmt|;
block|}
return|return
name|xop
return|;
block|}
end_function

begin_comment
comment|/**  * Release any resources held by the handle.  * @xop XO handle to alter (or NULL for default handle)  */
end_comment

begin_function
name|void
name|xo_destroy
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_close
operator|&&
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_CLOSE_FP
operator|)
condition|)
name|xop
operator|->
name|xo_close
argument_list|(
name|xop
operator|->
name|xo_opaque
argument_list|)
expr_stmt|;
name|xo_free
argument_list|(
name|xop
operator|->
name|xo_stack
argument_list|)
expr_stmt|;
name|xo_buf_cleanup
argument_list|(
operator|&
name|xop
operator|->
name|xo_data
argument_list|)
expr_stmt|;
name|xo_buf_cleanup
argument_list|(
operator|&
name|xop
operator|->
name|xo_fmt
argument_list|)
expr_stmt|;
name|xo_buf_cleanup
argument_list|(
operator|&
name|xop
operator|->
name|xo_predicate
argument_list|)
expr_stmt|;
name|xo_buf_cleanup
argument_list|(
operator|&
name|xop
operator|->
name|xo_attrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|==
operator|&
name|xo_default_handle
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|xo_default_handle
argument_list|,
sizeof|sizeof
argument_list|(
operator|&
name|xo_default_handle
argument_list|)
argument_list|)
expr_stmt|;
name|xo_default_inited
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|xo_free
argument_list|(
name|xop
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Record a new output style to use for the given handle (or default if  * handle is NULL).  This output style will be used for any future output.  *  * @xop XO handle to alter (or NULL for default handle)  * @style new output style (XO_STYLE_*)  */
end_comment

begin_function
name|void
name|xo_set_style
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_style_t
name|style
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_style
operator|=
name|style
expr_stmt|;
block|}
end_function

begin_function
name|xo_style_t
name|xo_get_style
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
return|return
name|xop
operator|->
name|xo_style
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_name_to_style
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"xml"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|XO_STYLE_XML
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"json"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|XO_STYLE_JSON
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"text"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|XO_STYLE_TEXT
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"html"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|XO_STYLE_HTML
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Convert string name to XOF_* flag value.  * Not all are useful.  Or safe.  Or sane.  */
end_comment

begin_function
specifier|static
name|unsigned
name|xo_name_to_flag
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"pretty"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|XOF_PRETTY
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"warn"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|XOF_WARN
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"xpath"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|XOF_XPATH
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"info"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|XOF_INFO
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"warn-xml"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|XOF_WARN_XML
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"columns"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|XOF_COLUMNS
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"dtrt"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|XOF_DTRT
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"flush"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|XOF_FLUSH
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"keys"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|XOF_KEYS
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"ignore-close"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|XOF_IGNORE_CLOSE
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"not-first"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|XOF_NOT_FIRST
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"no-locale"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|XOF_NO_LOCALE
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"no-top"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|XOF_NO_TOP
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"units"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|XOF_UNITS
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"underscores"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|XOF_UNDERSCORES
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|xo_set_style_name
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|int
name|style
init|=
name|xo_name_to_style
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|style
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|xo_set_style
argument_list|(
name|xop
argument_list|,
name|style
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Set the options for a handle using a string of options  * passed in.  The input is a comma-separated set of names  * and optional values: "xml,pretty,indent=4"  */
end_comment

begin_function
name|int
name|xo_set_options
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|input
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|vp
decl_stmt|,
modifier|*
name|np
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|int
name|style
init|=
operator|-
literal|1
decl_stmt|,
name|new_style
decl_stmt|,
name|len
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|xo_xof_flags_t
name|new_flag
decl_stmt|;
if|if
condition|(
name|input
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
comment|/*      * We support a simpler, old-school style of giving option      * also, using a single character for each option.  It's      * ideal for lazy people, such as myself.      */
if|if
condition|(
operator|*
name|input
operator|==
literal|':'
condition|)
block|{
name|int
name|sz
decl_stmt|;
for|for
control|(
name|input
operator|++
init|;
operator|*
name|input
condition|;
name|input
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|input
condition|)
block|{
case|case
literal|'f'
case|:
name|xop
operator|->
name|xo_flags
operator||=
name|XOF_FLUSH
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|xop
operator|->
name|xo_style
operator|=
name|XO_STYLE_HTML
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|xop
operator|->
name|xo_flags
operator||=
name|XOF_INFO
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|sz
operator|=
name|strspn
argument_list|(
name|input
operator|+
literal|1
argument_list|,
literal|"0123456789"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|>
literal|0
condition|)
block|{
name|xop
operator|->
name|xo_indent_by
operator|=
name|atoi
argument_list|(
name|input
operator|+
literal|1
argument_list|)
expr_stmt|;
name|input
operator|+=
name|sz
operator|-
literal|1
expr_stmt|;
comment|/* Skip value */
block|}
break|break;
case|case
literal|'k'
case|:
name|xop
operator|->
name|xo_flags
operator||=
name|XOF_KEYS
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
name|xop
operator|->
name|xo_style
operator|=
name|XO_STYLE_JSON
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|xop
operator|->
name|xo_flags
operator||=
name|XOF_PRETTY
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|xop
operator|->
name|xo_style
operator|=
name|XO_STYLE_TEXT
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|xop
operator|->
name|xo_flags
operator||=
name|XOF_UNITS
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|xop
operator|->
name|xo_flags
operator||=
name|XOF_UNDERSCORES
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|xop
operator|->
name|xo_flags
operator||=
name|XOF_WARN
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|xop
operator|->
name|xo_style
operator|=
name|XO_STYLE_XML
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|xop
operator|->
name|xo_flags
operator||=
name|XOF_XPATH
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|input
argument_list|)
operator|+
literal|1
expr_stmt|;
name|bp
operator|=
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bp
argument_list|,
name|input
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|bp
operator|,
name|ep
operator|=
name|cp
operator|+
name|len
operator|-
literal|1
init|;
name|cp
operator|&&
name|cp
operator|<
name|ep
condition|;
name|cp
operator|=
name|np
control|)
block|{
name|np
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
condition|)
operator|*
name|np
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|vp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
condition|)
operator|*
name|vp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|new_style
operator|=
name|xo_name_to_style
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_style
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|style
operator|>=
literal|0
condition|)
name|xo_warnx
argument_list|(
literal|"ignoring multiple styles: '%s'"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
name|style
operator|=
name|new_style
expr_stmt|;
block|}
else|else
block|{
name|new_flag
operator|=
name|xo_name_to_flag
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_flag
operator|!=
literal|0
condition|)
name|xop
operator|->
name|xo_flags
operator||=
name|new_flag
expr_stmt|;
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"indent"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xop
operator|->
name|xo_indent_by
operator|=
name|atoi
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xo_warnx
argument_list|(
literal|"unknown option: '%s'"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|style
operator|>
literal|0
condition|)
name|xop
operator|->
name|xo_style
operator|=
name|style
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/**  * Set one or more flags for a given handle (or default if handle is NULL).  * These flags will affect future output.  *  * @xop XO handle to alter (or NULL for default handle)  * @flags Flags to be set (XOF_*)  */
end_comment

begin_function
name|void
name|xo_set_flags
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_xof_flags_t
name|flags
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_flags
operator||=
name|flags
expr_stmt|;
block|}
end_function

begin_function
name|xo_xof_flags_t
name|xo_get_flags
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
return|return
name|xop
operator|->
name|xo_flags
return|;
block|}
end_function

begin_comment
comment|/**  * Record a leading prefix for the XPath we generate.  This allows the  * generated data to be placed within an XML hierarchy but still have  * accurate XPath expressions.  *  * @xop XO handle to alter (or NULL for default handle)  * @path The XPath expression  */
end_comment

begin_function
name|void
name|xo_set_leading_xpath
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_leading_xpath
condition|)
block|{
name|xo_free
argument_list|(
name|xop
operator|->
name|xo_leading_xpath
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_leading_xpath
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
return|return;
name|int
name|len
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|xop
operator|->
name|xo_leading_xpath
operator|=
name|xo_realloc
argument_list|(
name|NULL
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_leading_xpath
condition|)
block|{
name|memcpy
argument_list|(
name|xop
operator|->
name|xo_leading_xpath
argument_list|,
name|path
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Record the info data for a set of tags  *  * @xop XO handle to alter (or NULL for default handle)  * @info Info data (xo_info_t) to be recorded (or NULL) (MUST BE SORTED)  * @count Number of entries in info (or -1 to count them ourselves)  */
end_comment

begin_function
name|void
name|xo_set_info
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_info_t
modifier|*
name|infop
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
operator|&&
name|infop
condition|)
block|{
name|xo_info_t
modifier|*
name|xip
decl_stmt|;
for|for
control|(
name|xip
operator|=
name|infop
operator|,
name|count
operator|=
literal|0
init|;
name|xip
operator|->
name|xi_name
condition|;
name|xip
operator|++
operator|,
name|count
operator|++
control|)
continue|continue;
block|}
name|xop
operator|->
name|xo_info
operator|=
name|infop
expr_stmt|;
name|xop
operator|->
name|xo_info_count
operator|=
name|count
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Set the formatter callback for a handle.  The callback should  * return a newly formatting contents of a formatting instruction,  * meaning the bits inside the braces.  */
end_comment

begin_function
name|void
name|xo_set_formatter
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_formatter_t
name|func
parameter_list|,
name|xo_checkpointer_t
name|cfunc
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_formatter
operator|=
name|func
expr_stmt|;
name|xop
operator|->
name|xo_checkpointer
operator|=
name|cfunc
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Clear one or more flags for a given handle (or default if handle is NULL).  * These flags will affect future output.  *  * @xop XO handle to alter (or NULL for default handle)  * @flags Flags to be cleared (XOF_*)  */
end_comment

begin_function
name|void
name|xo_clear_flags
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_xof_flags_t
name|flags
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_flags
operator|&=
operator|~
name|flags
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_line_ensure_open
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_xff_flags_t
name|flags
name|UNUSED
parameter_list|)
block|{
specifier|static
name|char
name|div_open
index|[]
init|=
literal|"<div class=\"line\">"
decl_stmt|;
specifier|static
name|char
name|div_open_blank
index|[]
init|=
literal|"<div class=\"blank-line\">"
decl_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_DIV_OPEN
condition|)
return|return;
if|if
condition|(
name|xop
operator|->
name|xo_style
operator|!=
name|XO_STYLE_HTML
condition|)
return|return;
name|xop
operator|->
name|xo_flags
operator||=
name|XOF_DIV_OPEN
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XFF_BLANK_LINE
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|div_open_blank
argument_list|,
sizeof|sizeof
argument_list|(
name|div_open_blank
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|div_open
argument_list|,
sizeof|sizeof
argument_list|(
name|div_open
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_PRETTY
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_line_close
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
specifier|static
name|char
name|div_close
index|[]
init|=
literal|"</div>"
decl_stmt|;
switch|switch
condition|(
name|xop
operator|->
name|xo_style
condition|)
block|{
case|case
name|XO_STYLE_HTML
case|:
if|if
condition|(
operator|!
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_DIV_OPEN
operator|)
condition|)
name|xo_line_ensure_open
argument_list|(
name|xop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_flags
operator|&=
operator|~
name|XOF_DIV_OPEN
expr_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|div_close
argument_list|,
sizeof|sizeof
argument_list|(
name|div_close
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_PRETTY
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_TEXT
case|:
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|xo_info_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|key
decl_stmt|;
specifier|const
name|xo_info_t
modifier|*
name|xip
init|=
name|data
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|name
argument_list|,
name|xip
operator|->
name|xi_name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|xo_info_t
modifier|*
name|xo_info_find
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|nlen
parameter_list|)
block|{
name|xo_info_t
modifier|*
name|xip
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|alloca
argument_list|(
name|nlen
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* Need local copy for NUL termination */
name|memcpy
argument_list|(
name|cp
argument_list|,
name|name
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|cp
index|[
name|nlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|xip
operator|=
name|bsearch
argument_list|(
name|cp
argument_list|,
name|xop
operator|->
name|xo_info
argument_list|,
name|xop
operator|->
name|xo_info_count
argument_list|,
sizeof|sizeof
argument_list|(
name|xop
operator|->
name|xo_info
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|xo_info_compare
argument_list|)
expr_stmt|;
return|return
name|xip
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CONVERT
parameter_list|(
name|_have
parameter_list|,
name|_need
parameter_list|)
value|(((_have)<< 8) | (_need))
end_define

begin_comment
comment|/*  * Check to see that the conversion is safe and sane.  */
end_comment

begin_function
specifier|static
name|int
name|xo_check_conversion
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|int
name|have_enc
parameter_list|,
name|int
name|need_enc
parameter_list|)
block|{
switch|switch
condition|(
name|CONVERT
argument_list|(
name|have_enc
argument_list|,
name|need_enc
argument_list|)
condition|)
block|{
case|case
name|CONVERT
argument_list|(
name|XF_ENC_UTF8
argument_list|,
name|XF_ENC_UTF8
argument_list|)
case|:
case|case
name|CONVERT
argument_list|(
name|XF_ENC_UTF8
argument_list|,
name|XF_ENC_LOCALE
argument_list|)
case|:
case|case
name|CONVERT
argument_list|(
name|XF_ENC_WIDE
argument_list|,
name|XF_ENC_UTF8
argument_list|)
case|:
case|case
name|CONVERT
argument_list|(
name|XF_ENC_WIDE
argument_list|,
name|XF_ENC_LOCALE
argument_list|)
case|:
case|case
name|CONVERT
argument_list|(
name|XF_ENC_LOCALE
argument_list|,
name|XF_ENC_LOCALE
argument_list|)
case|:
case|case
name|CONVERT
argument_list|(
name|XF_ENC_LOCALE
argument_list|,
name|XF_ENC_UTF8
argument_list|)
case|:
return|return
literal|0
return|;
default|default:
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"invalid conversion (%c:%c)"
argument_list|,
name|have_enc
argument_list|,
name|need_enc
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|xo_format_string_direct
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
name|xo_xff_flags_t
name|flags
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|wcp
parameter_list|,
specifier|const
name|char
modifier|*
name|cp
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|need_enc
parameter_list|,
name|int
name|have_enc
parameter_list|)
block|{
name|int
name|cols
init|=
literal|0
decl_stmt|;
name|wchar_t
name|wc
decl_stmt|;
name|int
name|ilen
decl_stmt|,
name|olen
decl_stmt|,
name|width
decl_stmt|;
name|int
name|attr
init|=
operator|(
name|flags
operator|&
name|XFF_ATTR
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|cp
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
operator|(
name|flags
operator|&
name|XFF_UNESCAPE
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|==
literal|'\\'
operator|||
operator|*
name|cp
operator|==
literal|'%'
operator|)
condition|)
block|{
name|cp
operator|+=
literal|1
expr_stmt|;
name|len
operator|-=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wcp
operator|&&
operator|*
name|wcp
operator|==
literal|L'
expr|\0'
condition|)
break|break;
name|ilen
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|have_enc
condition|)
block|{
case|case
name|XF_ENC_WIDE
case|:
comment|/* Wide character */
name|wc
operator|=
operator|*
name|wcp
operator|++
expr_stmt|;
name|ilen
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|XF_ENC_UTF8
case|:
comment|/* UTF-8 */
name|ilen
operator|=
name|xo_utf8_to_wc_len
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ilen
operator|<
literal|0
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"invalid UTF-8 character: %02hhx"
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|len
operator|<
name|ilen
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
comment|/* Break out of the loop */
continue|continue;
block|}
name|wc
operator|=
name|xo_utf8_char
argument_list|(
name|cp
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc
operator|==
operator|(
name|wchar_t
operator|)
operator|-
literal|1
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"invalid UTF-8 character: %02hhx/%d"
argument_list|,
operator|*
name|cp
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|cp
operator|+=
name|ilen
expr_stmt|;
break|break;
case|case
name|XF_ENC_LOCALE
case|:
comment|/* Native locale */
name|ilen
operator|=
operator|(
name|len
operator|>
literal|0
operator|)
condition|?
name|len
else|:
name|MB_LEN_MAX
expr_stmt|;
name|ilen
operator|=
name|mbrtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|cp
argument_list|,
name|ilen
argument_list|,
operator|&
name|xop
operator|->
name|xo_mbstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|ilen
operator|<
literal|0
condition|)
block|{
comment|/* Invalid data; skip */
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"invalid mbs char: %02hhx"
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ilen
operator|==
literal|0
condition|)
block|{
comment|/* Hit a wide NUL character */
name|len
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|cp
operator|+=
name|ilen
expr_stmt|;
break|break;
block|}
comment|/* Reduce len, but not below zero */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|len
operator|-=
name|ilen
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|len
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Find the width-in-columns of this character, which must be done 	 * in wide characters, since we lack a mbswidth() function.  If 	 * it doesn't fit 	 */
name|width
operator|=
name|wcwidth
argument_list|(
name|wc
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|<
literal|0
condition|)
name|width
operator|=
name|iswcntrl
argument_list|(
name|wc
argument_list|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_style
operator|==
name|XO_STYLE_TEXT
operator|||
name|xop
operator|->
name|xo_style
operator|==
name|XO_STYLE_HTML
condition|)
block|{
if|if
condition|(
name|max
operator|>
literal|0
operator|&&
name|cols
operator|+
name|width
operator|>
name|max
condition|)
break|break;
block|}
switch|switch
condition|(
name|need_enc
condition|)
block|{
case|case
name|XF_ENC_UTF8
case|:
comment|/* Output in UTF-8 needs to be escaped, based on the style */
switch|switch
condition|(
name|xop
operator|->
name|xo_style
condition|)
block|{
case|case
name|XO_STYLE_XML
case|:
case|case
name|XO_STYLE_HTML
case|:
if|if
condition|(
name|wc
operator|==
literal|'<'
condition|)
name|sp
operator|=
name|xo_xml_lt
expr_stmt|;
elseif|else
if|if
condition|(
name|wc
operator|==
literal|'>'
condition|)
name|sp
operator|=
name|xo_xml_gt
expr_stmt|;
elseif|else
if|if
condition|(
name|wc
operator|==
literal|'&'
condition|)
name|sp
operator|=
name|xo_xml_amp
expr_stmt|;
elseif|else
if|if
condition|(
name|attr
operator|&&
name|wc
operator|==
literal|'"'
condition|)
name|sp
operator|=
name|xo_xml_quot
expr_stmt|;
else|else
break|break;
name|int
name|slen
init|=
name|strlen
argument_list|(
name|sp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|slen
operator|-
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|memcpy
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|sp
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|+=
name|slen
expr_stmt|;
goto|goto
name|done_with_encoding
goto|;
comment|/* Need multi-level 'break' */
case|case
name|XO_STYLE_JSON
case|:
if|if
condition|(
name|wc
operator|!=
literal|'\\'
operator|&&
name|wc
operator|!=
literal|'"'
condition|)
break|break;
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
literal|2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|xbp
operator|->
name|xb_curp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|xbp
operator|->
name|xb_curp
operator|++
operator|=
name|wc
operator|&
literal|0x7f
expr_stmt|;
goto|goto
name|done_with_encoding
goto|;
block|}
name|olen
operator|=
name|xo_utf8_emit_len
argument_list|(
name|wc
argument_list|)
expr_stmt|;
if|if
condition|(
name|olen
operator|<
literal|0
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"ignoring bad length"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|olen
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|xo_utf8_emit_char
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|olen
argument_list|,
name|wc
argument_list|)
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|+=
name|olen
expr_stmt|;
break|break;
case|case
name|XF_ENC_LOCALE
case|:
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|MB_LEN_MAX
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|olen
operator|=
name|wcrtomb
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|wc
argument_list|,
operator|&
name|xop
operator|->
name|xo_mbstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|olen
operator|<=
literal|0
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"could not convert wide char: %lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|wc
argument_list|)
expr_stmt|;
name|olen
operator|=
literal|1
expr_stmt|;
name|width
operator|=
literal|1
expr_stmt|;
operator|*
name|xbp
operator|->
name|xb_curp
operator|++
operator|=
literal|'?'
expr_stmt|;
block|}
else|else
name|xbp
operator|->
name|xb_curp
operator|+=
name|olen
expr_stmt|;
break|break;
block|}
name|done_with_encoding
label|:
name|cols
operator|+=
name|width
expr_stmt|;
block|}
return|return
name|cols
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_format_string
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
name|xo_xff_flags_t
name|flags
parameter_list|,
name|xo_format_t
modifier|*
name|xfp
parameter_list|)
block|{
specifier|static
name|char
name|null
index|[]
init|=
literal|"(null)"
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|NULL
decl_stmt|;
name|wchar_t
modifier|*
name|wcp
init|=
name|NULL
decl_stmt|;
name|int
name|len
decl_stmt|,
name|cols
init|=
literal|0
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|int
name|off
init|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
decl_stmt|,
name|off2
decl_stmt|;
name|int
name|need_enc
init|=
operator|(
name|xop
operator|->
name|xo_style
operator|==
name|XO_STYLE_TEXT
operator|)
condition|?
name|XF_ENC_LOCALE
else|:
name|XF_ENC_UTF8
decl_stmt|;
if|if
condition|(
name|xo_check_conversion
argument_list|(
name|xop
argument_list|,
name|xfp
operator|->
name|xf_enc
argument_list|,
name|need_enc
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|xfp
operator|->
name|xf_enc
operator|==
name|XF_ENC_WIDE
condition|)
block|{
name|wcp
operator|=
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|wchar_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfp
operator|->
name|xf_skip
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
name|cp
operator|=
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
comment|/* UTF-8 or native */
if|if
condition|(
name|xfp
operator|->
name|xf_skip
condition|)
return|return
literal|0
return|;
comment|/* 	 * Optimize the most common case, which is "%s".  We just 	 * need to copy the complete string to the output buffer. 	 */
if|if
condition|(
name|xfp
operator|->
name|xf_enc
operator|==
name|need_enc
operator|&&
name|xfp
operator|->
name|xf_width
index|[
name|XF_WIDTH_MIN
index|]
operator|<
literal|0
operator|&&
name|xfp
operator|->
name|xf_width
index|[
name|XF_WIDTH_SIZE
index|]
operator|<
literal|0
operator|&&
name|xfp
operator|->
name|xf_width
index|[
name|XF_WIDTH_MAX
index|]
operator|<
literal|0
operator|&&
operator|!
operator|(
name|xop
operator|->
name|xo_flags
operator|&
operator|(
name|XOF_ANCHOR
operator||
name|XOF_COLUMNS
operator|)
operator|)
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|xo_buf_escape
argument_list|(
name|xop
argument_list|,
name|xbp
argument_list|,
name|cp
argument_list|,
name|len
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 	     * Our caller expects xb_curp left untouched, so we have 	     * to reset it and return the number of bytes written to 	     * the buffer. 	     */
name|off2
operator|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
expr_stmt|;
name|rc
operator|=
name|off2
operator|-
name|off
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|=
name|xbp
operator|->
name|xb_bufp
operator|+
name|off
expr_stmt|;
return|return
name|rc
return|;
block|}
block|}
name|len
operator|=
name|xfp
operator|->
name|xf_width
index|[
name|XF_WIDTH_SIZE
index|]
expr_stmt|;
comment|/*      * Dont' deref NULL; use the traditional "(null)" instead      * of the more accurate "who's been a naughty boy, then?".      */
if|if
condition|(
name|cp
operator|==
name|NULL
operator|&&
name|wcp
operator|==
name|NULL
condition|)
block|{
name|cp
operator|=
name|null
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|null
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
name|cols
operator|=
name|xo_format_string_direct
argument_list|(
name|xop
argument_list|,
name|xbp
argument_list|,
name|flags
argument_list|,
name|wcp
argument_list|,
name|cp
argument_list|,
name|len
argument_list|,
name|xfp
operator|->
name|xf_width
index|[
name|XF_WIDTH_MAX
index|]
argument_list|,
name|need_enc
argument_list|,
name|xfp
operator|->
name|xf_enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cols
operator|<
literal|0
condition|)
goto|goto
name|bail
goto|;
comment|/*      * xo_buf_append* will move xb_curp, so we save/restore it.      */
name|off2
operator|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
expr_stmt|;
name|rc
operator|=
name|off2
operator|-
name|off
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|=
name|xbp
operator|->
name|xb_bufp
operator|+
name|off
expr_stmt|;
if|if
condition|(
name|cols
operator|<
name|xfp
operator|->
name|xf_width
index|[
name|XF_WIDTH_MIN
index|]
condition|)
block|{
comment|/* 	 * Find the number of columns needed to display the string. 	 * If we have the original wide string, we just call wcswidth, 	 * but if we did the work ourselves, then we need to do it. 	 */
name|int
name|delta
init|=
name|xfp
operator|->
name|xf_width
index|[
name|XF_WIDTH_MIN
index|]
operator|-
name|cols
decl_stmt|;
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|delta
argument_list|)
condition|)
goto|goto
name|bail
goto|;
comment|/* 	 * If seen_minus, then pad on the right; otherwise move it so 	 * we can pad on the left. 	 */
if|if
condition|(
name|xfp
operator|->
name|xf_seen_minus
condition|)
block|{
name|cp
operator|=
name|xbp
operator|->
name|xb_curp
operator|+
name|rc
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|xbp
operator|->
name|xb_curp
expr_stmt|;
name|memmove
argument_list|(
name|xbp
operator|->
name|xb_curp
operator|+
name|delta
argument_list|,
name|xbp
operator|->
name|xb_curp
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
comment|/* Set the padding */
name|memset
argument_list|(
name|cp
argument_list|,
operator|(
name|xfp
operator|->
name|xf_leading_zero
operator|>
literal|0
operator|)
condition|?
literal|'0'
else|:
literal|' '
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|rc
operator|+=
name|delta
expr_stmt|;
name|cols
operator|+=
name|delta
expr_stmt|;
block|}
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_COLUMNS
condition|)
name|xop
operator|->
name|xo_columns
operator|+=
name|cols
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_ANCHOR
condition|)
name|xop
operator|->
name|xo_anchor_columns
operator|+=
name|cols
expr_stmt|;
return|return
name|rc
return|;
name|bail
label|:
name|xbp
operator|->
name|xb_curp
operator|=
name|xbp
operator|->
name|xb_bufp
operator|+
name|off
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_data_append_content
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|cols
decl_stmt|;
name|int
name|need_enc
init|=
operator|(
name|xop
operator|->
name|xo_style
operator|==
name|XO_STYLE_TEXT
operator|)
condition|?
name|XF_ENC_LOCALE
else|:
name|XF_ENC_UTF8
decl_stmt|;
name|cols
operator|=
name|xo_format_string_direct
argument_list|(
name|xop
argument_list|,
operator|&
name|xop
operator|->
name|xo_data
argument_list|,
name|XFF_UNESCAPE
argument_list|,
name|NULL
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
operator|-
literal|1
argument_list|,
name|need_enc
argument_list|,
name|XF_ENC_UTF8
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_COLUMNS
condition|)
name|xop
operator|->
name|xo_columns
operator|+=
name|cols
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_ANCHOR
condition|)
name|xop
operator|->
name|xo_anchor_columns
operator|+=
name|cols
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_bump_width
parameter_list|(
name|xo_format_t
modifier|*
name|xfp
parameter_list|,
name|int
name|digit
parameter_list|)
block|{
name|int
modifier|*
name|ip
init|=
operator|&
name|xfp
operator|->
name|xf_width
index|[
name|xfp
operator|->
name|xf_dots
index|]
decl_stmt|;
operator|*
name|ip
operator|=
operator|(
operator|(
operator|*
name|ip
operator|>
literal|0
operator|)
condition|?
operator|*
name|ip
else|:
literal|0
operator|)
operator|*
literal|10
operator|+
name|digit
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_trim_ws
parameter_list|(
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|int
name|delta
decl_stmt|;
comment|/* First trim leading space */
for|for
control|(
name|cp
operator|=
name|sp
operator|=
name|xbp
operator|->
name|xb_curp
operator|,
name|ep
operator|=
name|cp
operator|+
name|len
init|;
name|cp
operator|<
name|ep
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|!=
literal|' '
condition|)
break|break;
block|}
name|delta
operator|=
name|cp
operator|-
name|sp
expr_stmt|;
if|if
condition|(
name|delta
condition|)
block|{
name|len
operator|-=
name|delta
expr_stmt|;
name|memmove
argument_list|(
name|sp
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* Then trim off the end */
for|for
control|(
name|cp
operator|=
name|xbp
operator|->
name|xb_curp
operator|,
name|sp
operator|=
name|ep
operator|=
name|cp
operator|+
name|len
init|;
name|cp
operator|<
name|ep
condition|;
name|ep
operator|--
control|)
block|{
if|if
condition|(
name|ep
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
condition|)
break|break;
block|}
name|delta
operator|=
name|sp
operator|-
name|ep
expr_stmt|;
if|if
condition|(
name|delta
condition|)
block|{
name|len
operator|-=
name|delta
expr_stmt|;
name|cp
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_format_data
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_buffer_t
modifier|*
name|xbp
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|int
name|flen
parameter_list|,
name|xo_xff_flags_t
name|flags
parameter_list|)
block|{
name|xo_format_t
name|xf
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
modifier|*
name|xp
init|=
name|NULL
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|cols
decl_stmt|;
name|int
name|style
init|=
operator|(
name|flags
operator|&
name|XFF_XML
operator|)
condition|?
name|XO_STYLE_XML
else|:
name|xop
operator|->
name|xo_style
decl_stmt|;
name|unsigned
name|make_output
init|=
operator|!
operator|(
name|flags
operator|&
name|XFF_NO_OUTPUT
operator|)
decl_stmt|;
name|int
name|need_enc
init|=
operator|(
name|xop
operator|->
name|xo_style
operator|==
name|XO_STYLE_TEXT
operator|)
condition|?
name|XF_ENC_LOCALE
else|:
name|XF_ENC_UTF8
decl_stmt|;
if|if
condition|(
name|xbp
operator|==
name|NULL
condition|)
name|xbp
operator|=
operator|&
name|xop
operator|->
name|xo_data
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|fmt
operator|,
name|ep
operator|=
name|fmt
operator|+
name|flen
init|;
name|cp
operator|<
name|ep
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'%'
condition|)
block|{
name|add_one
label|:
if|if
condition|(
name|xp
operator|==
name|NULL
condition|)
name|xp
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\\'
operator|&&
name|cp
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|cp
operator|+=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|cp
operator|+
literal|1
operator|<
name|ep
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'%'
condition|)
block|{
name|cp
operator|+=
literal|1
expr_stmt|;
goto|goto
name|add_one
goto|;
block|}
if|if
condition|(
name|xp
condition|)
block|{
if|if
condition|(
name|make_output
condition|)
block|{
name|cols
operator|=
name|xo_format_string_direct
argument_list|(
name|xop
argument_list|,
name|xbp
argument_list|,
name|flags
operator||
name|XFF_UNESCAPE
argument_list|,
name|NULL
argument_list|,
name|xp
argument_list|,
name|cp
operator|-
name|xp
argument_list|,
operator|-
literal|1
argument_list|,
name|need_enc
argument_list|,
name|XF_ENC_UTF8
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_COLUMNS
condition|)
name|xop
operator|->
name|xo_columns
operator|+=
name|cols
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_ANCHOR
condition|)
name|xop
operator|->
name|xo_anchor_columns
operator|+=
name|cols
expr_stmt|;
block|}
name|xp
operator|=
name|NULL
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|xf
argument_list|,
sizeof|sizeof
argument_list|(
name|xf
argument_list|)
argument_list|)
expr_stmt|;
name|xf
operator|.
name|xf_leading_zero
operator|=
operator|-
literal|1
expr_stmt|;
name|xf
operator|.
name|xf_width
index|[
literal|0
index|]
operator|=
name|xf
operator|.
name|xf_width
index|[
literal|1
index|]
operator|=
name|xf
operator|.
name|xf_width
index|[
literal|2
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * "%@" starts an XO-specific set of flags: 	 *   @X@ - XML-only field; ignored if style isn't XML 	 */
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'@'
condition|)
block|{
for|for
control|(
name|cp
operator|+=
literal|2
init|;
name|cp
operator|<
name|ep
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'@'
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'*'
condition|)
block|{
comment|/* 		     * '*' means there's a "%*.*s" value in vap that 		     * we want to ignore 		     */
if|if
condition|(
operator|!
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_NO_VA_ARG
operator|)
condition|)
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|int
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Hidden fields are only visible to JSON and XML */
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XFF_ENCODE_ONLY
condition|)
block|{
if|if
condition|(
name|style
operator|!=
name|XO_STYLE_XML
operator|&&
name|xop
operator|->
name|xo_style
operator|!=
name|XO_STYLE_JSON
condition|)
name|xf
operator|.
name|xf_skip
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XFF_DISPLAY_ONLY
condition|)
block|{
if|if
condition|(
name|style
operator|!=
name|XO_STYLE_TEXT
operator|&&
name|xop
operator|->
name|xo_style
operator|!=
name|XO_STYLE_HTML
condition|)
name|xf
operator|.
name|xf_skip
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|make_output
condition|)
name|xf
operator|.
name|xf_skip
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Looking at one piece of a format; find the end and 	 * call snprintf.  Then advance xo_vap on our own. 	 * 	 * Note that 'n', 'v', and '$' are not supported. 	 */
name|sp
operator|=
name|cp
expr_stmt|;
comment|/* Save start pointer */
for|for
control|(
name|cp
operator|+=
literal|1
init|;
name|cp
operator|<
name|ep
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'l'
condition|)
name|xf
operator|.
name|xf_lflag
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'h'
condition|)
name|xf
operator|.
name|xf_hflag
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'j'
condition|)
name|xf
operator|.
name|xf_jflag
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'t'
condition|)
name|xf
operator|.
name|xf_tflag
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'z'
condition|)
name|xf
operator|.
name|xf_zflag
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'q'
condition|)
name|xf
operator|.
name|xf_qflag
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
operator|++
name|xf
operator|.
name|xf_dots
operator|>=
name|XF_WIDTH_NUM
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"Too many dots in format: '%s'"
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
name|xf
operator|.
name|xf_seen_minus
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
if|if
condition|(
name|xf
operator|.
name|xf_leading_zero
operator|<
literal|0
condition|)
name|xf
operator|.
name|xf_leading_zero
operator|=
operator|(
operator|*
name|cp
operator|==
literal|'0'
operator|)
expr_stmt|;
name|xo_bump_width
argument_list|(
operator|&
name|xf
argument_list|,
operator|*
name|cp
operator|-
literal|'0'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'*'
condition|)
block|{
name|xf
operator|.
name|xf_stars
operator|+=
literal|1
expr_stmt|;
name|xf
operator|.
name|xf_star
index|[
name|xf
operator|.
name|xf_dots
index|]
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"diouxXDOUeEfFgGaAcCsSp"
argument_list|,
operator|*
name|cp
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'n'
operator|||
operator|*
name|cp
operator|==
literal|'v'
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"unsupported format: '%s'"
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|cp
operator|==
name|ep
condition|)
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"field format missing format character: %s"
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xf
operator|.
name|xf_fc
operator|=
operator|*
name|cp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_NO_VA_ARG
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'s'
operator|||
operator|*
name|cp
operator|==
literal|'S'
condition|)
block|{
comment|/* Handle "%*.*.*s" */
name|int
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|XF_WIDTH_NUM
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|xf
operator|.
name|xf_star
index|[
name|s
index|]
condition|)
block|{
name|xf
operator|.
name|xf_width
index|[
name|s
index|]
operator|=
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|int
argument_list|)
expr_stmt|;
comment|/* Normalize a negative width value */
if|if
condition|(
name|xf
operator|.
name|xf_width
index|[
name|s
index|]
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
name|xf
operator|.
name|xf_width
index|[
literal|0
index|]
operator|=
operator|-
name|xf
operator|.
name|xf_width
index|[
literal|0
index|]
expr_stmt|;
name|xf
operator|.
name|xf_seen_minus
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|xf
operator|.
name|xf_width
index|[
name|s
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Ignore negative values */
block|}
block|}
block|}
block|}
block|}
comment|/* If no max is given, it defaults to size */
if|if
condition|(
name|xf
operator|.
name|xf_width
index|[
name|XF_WIDTH_MAX
index|]
operator|<
literal|0
operator|&&
name|xf
operator|.
name|xf_width
index|[
name|XF_WIDTH_SIZE
index|]
operator|>=
literal|0
condition|)
name|xf
operator|.
name|xf_width
index|[
name|XF_WIDTH_MAX
index|]
operator|=
name|xf
operator|.
name|xf_width
index|[
name|XF_WIDTH_SIZE
index|]
expr_stmt|;
if|if
condition|(
name|xf
operator|.
name|xf_fc
operator|==
literal|'D'
operator|||
name|xf
operator|.
name|xf_fc
operator|==
literal|'O'
operator|||
name|xf
operator|.
name|xf_fc
operator|==
literal|'U'
condition|)
name|xf
operator|.
name|xf_lflag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|xf
operator|.
name|xf_skip
condition|)
block|{
name|xo_buffer_t
modifier|*
name|fbp
init|=
operator|&
name|xop
operator|->
name|xo_fmt
decl_stmt|;
name|int
name|len
init|=
name|cp
operator|-
name|sp
operator|+
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|fbp
argument_list|,
name|len
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|char
modifier|*
name|newfmt
init|=
name|fbp
operator|->
name|xb_curp
decl_stmt|;
name|memcpy
argument_list|(
name|newfmt
argument_list|,
name|sp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|newfmt
index|[
literal|0
index|]
operator|=
literal|'%'
expr_stmt|;
comment|/* If we skipped over a "%@...@s" format */
name|newfmt
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	     * Bad news: our strings are UTF-8, but the stock printf 	     * functions won't handle field widths for wide characters 	     * correctly.  So we have to handle this ourselves. 	     */
if|if
condition|(
name|xop
operator|->
name|xo_formatter
operator|==
name|NULL
operator|&&
operator|(
name|xf
operator|.
name|xf_fc
operator|==
literal|'s'
operator|||
name|xf
operator|.
name|xf_fc
operator|==
literal|'S'
operator|)
condition|)
block|{
name|xf
operator|.
name|xf_enc
operator|=
operator|(
name|xf
operator|.
name|xf_lflag
operator|||
operator|(
name|xf
operator|.
name|xf_fc
operator|==
literal|'S'
operator|)
operator|)
condition|?
name|XF_ENC_WIDE
else|:
name|xf
operator|.
name|xf_hflag
condition|?
name|XF_ENC_LOCALE
else|:
name|XF_ENC_UTF8
expr_stmt|;
name|rc
operator|=
name|xo_format_string
argument_list|(
name|xop
argument_list|,
name|xbp
argument_list|,
name|flags
argument_list|,
operator|&
name|xf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|XFF_TRIM_WS
operator|)
operator|&&
operator|(
name|xop
operator|->
name|xo_style
operator|==
name|XO_STYLE_XML
operator|||
name|xop
operator|->
name|xo_style
operator|==
name|XO_STYLE_JSON
operator|)
condition|)
name|rc
operator|=
name|xo_trim_ws
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|columns
init|=
name|rc
operator|=
name|xo_vsnprintf
argument_list|(
name|xop
argument_list|,
name|xbp
argument_list|,
name|newfmt
argument_list|,
name|xop
operator|->
name|xo_vap
argument_list|)
decl_stmt|;
comment|/* 		 * For XML and HTML, we need "&<>" processing; for JSON, 		 * it's quotes.  Text gets nothing. 		 */
switch|switch
condition|(
name|style
condition|)
block|{
case|case
name|XO_STYLE_XML
case|:
if|if
condition|(
name|flags
operator|&
name|XFF_TRIM_WS
condition|)
name|columns
operator|=
name|rc
operator|=
name|xo_trim_ws
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|)
expr_stmt|;
comment|/* fall thru */
case|case
name|XO_STYLE_HTML
case|:
name|rc
operator|=
name|xo_escape_xml
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|,
operator|(
name|flags
operator|&
name|XFF_ATTR
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_JSON
case|:
if|if
condition|(
name|flags
operator|&
name|XFF_TRIM_WS
condition|)
name|columns
operator|=
name|rc
operator|=
name|xo_trim_ws
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_escape_json
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * We can assume all the data we've added is ASCII, so 		 * the columns and bytes are the same.  xo_format_string 		 * handles all the fancy string conversions and updates 		 * xo_anchor_columns accordingly. 		 */
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_COLUMNS
condition|)
name|xop
operator|->
name|xo_columns
operator|+=
name|columns
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_ANCHOR
condition|)
name|xop
operator|->
name|xo_anchor_columns
operator|+=
name|columns
expr_stmt|;
block|}
name|xbp
operator|->
name|xb_curp
operator|+=
name|rc
expr_stmt|;
block|}
comment|/* 	 * Now for the tricky part: we need to move the argument pointer 	 * along by the amount needed. 	 */
if|if
condition|(
operator|!
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_NO_VA_ARG
operator|)
condition|)
block|{
if|if
condition|(
name|xf
operator|.
name|xf_fc
operator|==
literal|'s'
operator|||
name|xf
operator|.
name|xf_fc
operator|==
literal|'S'
condition|)
block|{
comment|/* 		 * The 'S' and 's' formats are normally handled in 		 * xo_format_string, but if we skipped it, then we 		 * need to pop it. 		 */
if|if
condition|(
name|xf
operator|.
name|xf_skip
condition|)
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|XF_WIDTH_NUM
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|xf
operator|.
name|xf_star
index|[
name|s
index|]
condition|)
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|int
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strchr
argument_list|(
literal|"diouxXDOU"
argument_list|,
name|xf
operator|.
name|xf_fc
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|xf
operator|.
name|xf_hflag
operator|>
literal|1
condition|)
block|{
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|int
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xf
operator|.
name|xf_hflag
operator|>
literal|0
condition|)
block|{
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|int
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xf
operator|.
name|xf_lflag
operator|>
literal|1
condition|)
block|{
name|va_arg
argument_list|(
argument|xop->xo_vap
argument_list|,
argument|unsigned long long
argument_list|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|xf
operator|.
name|xf_lflag
operator|>
literal|0
condition|)
block|{
name|va_arg
argument_list|(
argument|xop->xo_vap
argument_list|,
argument|unsigned long
argument_list|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|xf
operator|.
name|xf_jflag
operator|>
literal|0
condition|)
block|{
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|intmax_t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xf
operator|.
name|xf_tflag
operator|>
literal|0
condition|)
block|{
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|ptrdiff_t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xf
operator|.
name|xf_zflag
operator|>
literal|0
condition|)
block|{
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|size_t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xf
operator|.
name|xf_qflag
operator|>
literal|0
condition|)
block|{
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|quad_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|int
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"eEfFgGaA"
argument_list|,
name|xf
operator|.
name|xf_fc
argument_list|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|xf
operator|.
name|xf_lflag
condition|)
name|va_arg
argument_list|(
argument|xop->xo_vap
argument_list|,
argument|long double
argument_list|)
empty_stmt|;
else|else
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|double
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xf
operator|.
name|xf_fc
operator|==
literal|'C'
operator|||
operator|(
name|xf
operator|.
name|xf_fc
operator|==
literal|'c'
operator|&&
name|xf
operator|.
name|xf_lflag
operator|)
condition|)
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|wint_t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xf
operator|.
name|xf_fc
operator|==
literal|'c'
condition|)
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|int
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xf
operator|.
name|xf_fc
operator|==
literal|'p'
condition|)
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|xp
condition|)
block|{
if|if
condition|(
name|make_output
condition|)
block|{
name|cols
operator|=
name|xo_format_string_direct
argument_list|(
name|xop
argument_list|,
name|xbp
argument_list|,
name|flags
operator||
name|XFF_UNESCAPE
argument_list|,
name|NULL
argument_list|,
name|xp
argument_list|,
name|cp
operator|-
name|xp
argument_list|,
operator|-
literal|1
argument_list|,
name|need_enc
argument_list|,
name|XF_ENC_UTF8
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_COLUMNS
condition|)
name|xop
operator|->
name|xo_columns
operator|+=
name|cols
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_ANCHOR
condition|)
name|xop
operator|->
name|xo_anchor_columns
operator|+=
name|cols
expr_stmt|;
block|}
name|xp
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|xo_fix_encoding
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
name|UNUSED
parameter_list|,
name|char
modifier|*
name|encoding
parameter_list|)
block|{
name|char
modifier|*
name|cp
init|=
name|encoding
decl_stmt|;
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|!=
literal|'%'
operator|||
operator|!
name|isdigit
argument_list|(
operator|(
name|int
operator|)
name|cp
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
name|encoding
return|;
for|for
control|(
name|cp
operator|+=
literal|2
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|cp
argument_list|)
condition|)
break|break;
block|}
name|cp
operator|-=
literal|1
expr_stmt|;
operator|*
name|cp
operator|=
literal|'%'
expr_stmt|;
return|return
name|cp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_buf_append_div
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|class
parameter_list|,
name|xo_xff_flags_t
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|nlen
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|int
name|vlen
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
name|int
name|elen
parameter_list|)
block|{
specifier|static
name|char
name|div_start
index|[]
init|=
literal|"<div class=\""
decl_stmt|;
specifier|static
name|char
name|div_tag
index|[]
init|=
literal|"\" data-tag=\""
decl_stmt|;
specifier|static
name|char
name|div_xpath
index|[]
init|=
literal|"\" data-xpath=\""
decl_stmt|;
specifier|static
name|char
name|div_key
index|[]
init|=
literal|"\" data-key=\"key"
decl_stmt|;
specifier|static
name|char
name|div_end
index|[]
init|=
literal|"\">"
decl_stmt|;
specifier|static
name|char
name|div_close
index|[]
init|=
literal|"</div>"
decl_stmt|;
comment|/*      * To build our XPath predicate, we need to save the va_list before      * we format our data, and then restore it before we format the      * xpath expression.      * Display-only keys implies that we've got an encode-only key      * elsewhere, so we don't use them from making predicates.      */
name|int
name|need_predidate
init|=
operator|(
name|name
operator|&&
operator|(
name|flags
operator|&
name|XFF_KEY
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|XFF_DISPLAY_ONLY
operator|)
operator|&&
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_XPATH
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|need_predidate
condition|)
block|{
name|va_list
name|va_local
decl_stmt|;
name|va_copy
argument_list|(
name|va_local
argument_list|,
name|xop
operator|->
name|xo_vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_checkpointer
condition|)
name|xop
operator|->
name|xo_checkpointer
argument_list|(
name|xop
argument_list|,
name|xop
operator|->
name|xo_vap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Build an XPath predicate expression to match this key. 	 * We use the format buffer. 	 */
name|xo_buffer_t
modifier|*
name|pbp
init|=
operator|&
name|xop
operator|->
name|xo_predicate
decl_stmt|;
name|pbp
operator|->
name|xb_curp
operator|=
name|pbp
operator|->
name|xb_bufp
expr_stmt|;
comment|/* Restart buffer */
name|xo_buf_append
argument_list|(
name|pbp
argument_list|,
literal|"["
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xo_buf_escape
argument_list|(
name|xop
argument_list|,
name|pbp
argument_list|,
name|name
argument_list|,
name|nlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_PRETTY
condition|)
name|xo_buf_append
argument_list|(
name|pbp
argument_list|,
literal|" = '"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|xo_buf_append
argument_list|(
name|pbp
argument_list|,
literal|"='"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* The encoding format defaults to the normal format */
if|if
condition|(
name|encoding
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|enc
init|=
name|alloca
argument_list|(
name|vlen
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|enc
argument_list|,
name|value
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
name|enc
index|[
name|vlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|encoding
operator|=
name|xo_fix_encoding
argument_list|(
name|xop
argument_list|,
name|enc
argument_list|)
expr_stmt|;
name|elen
operator|=
name|strlen
argument_list|(
name|encoding
argument_list|)
expr_stmt|;
block|}
name|xo_format_data
argument_list|(
name|xop
argument_list|,
name|pbp
argument_list|,
name|encoding
argument_list|,
name|elen
argument_list|,
name|XFF_XML
operator||
name|XFF_ATTR
argument_list|)
expr_stmt|;
name|xo_buf_append
argument_list|(
name|pbp
argument_list|,
literal|"']"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Now we record this predicate expression in the stack */
name|xo_stack_t
modifier|*
name|xsp
init|=
operator|&
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
decl_stmt|;
name|int
name|olen
init|=
name|xsp
operator|->
name|xs_keys
condition|?
name|strlen
argument_list|(
name|xsp
operator|->
name|xs_keys
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|dlen
init|=
name|pbp
operator|->
name|xb_curp
operator|-
name|pbp
operator|->
name|xb_bufp
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|xo_realloc
argument_list|(
name|xsp
operator|->
name|xs_keys
argument_list|,
name|olen
operator|+
name|dlen
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
name|memcpy
argument_list|(
name|cp
operator|+
name|olen
argument_list|,
name|pbp
operator|->
name|xb_bufp
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
name|cp
index|[
name|olen
operator|+
name|dlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|xsp
operator|->
name|xs_keys
operator|=
name|cp
expr_stmt|;
block|}
comment|/* Now we reset the xo_vap as if we were never here */
name|va_end
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
expr_stmt|;
name|va_copy
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|va_local
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|va_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_checkpointer
condition|)
name|xop
operator|->
name|xo_checkpointer
argument_list|(
name|xop
argument_list|,
name|xop
operator|->
name|xo_vap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|XFF_ENCODE_ONLY
condition|)
block|{
comment|/* 	 * Even if this is encode-only, we need to go thru the 	 * work of formatting it to make sure the args are cleared 	 * from xo_vap. 	 */
name|xo_format_data
argument_list|(
name|xop
argument_list|,
operator|&
name|xop
operator|->
name|xo_data
argument_list|,
name|encoding
argument_list|,
name|elen
argument_list|,
name|flags
operator||
name|XFF_NO_OUTPUT
argument_list|)
expr_stmt|;
return|return;
block|}
name|xo_line_ensure_open
argument_list|(
name|xop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_PRETTY
condition|)
name|xo_buf_indent
argument_list|(
name|xop
argument_list|,
name|xop
operator|->
name|xo_indent_by
argument_list|)
expr_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|div_start
argument_list|,
sizeof|sizeof
argument_list|(
name|div_start
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|class
argument_list|,
name|strlen
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|div_tag
argument_list|,
sizeof|sizeof
argument_list|(
name|div_tag
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xo_data_escape
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
comment|/* 	 * Save the offset at which we'd place units.  See xo_format_units. 	 */
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_UNITS
condition|)
block|{
name|xop
operator|->
name|xo_flags
operator||=
name|XOF_UNITS_PENDING
expr_stmt|;
comment|/* 	     * Note: We need the '+1' here because we know we've not 	     * added the closing quote.  We add one, knowing the quote 	     * will be added shortly. 	     */
name|xop
operator|->
name|xo_units_offset
operator|=
name|xop
operator|->
name|xo_data
operator|.
name|xb_curp
operator|-
name|xop
operator|->
name|xo_data
operator|.
name|xb_bufp
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|name
condition|)
block|{
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_XPATH
condition|)
block|{
name|int
name|i
decl_stmt|;
name|xo_stack_t
modifier|*
name|xsp
decl_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|div_xpath
argument_list|,
sizeof|sizeof
argument_list|(
name|div_xpath
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_leading_xpath
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|xop
operator|->
name|xo_leading_xpath
argument_list|,
name|strlen
argument_list|(
name|xop
operator|->
name|xo_leading_xpath
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|xop
operator|->
name|xo_depth
condition|;
name|i
operator|++
control|)
block|{
name|xsp
operator|=
operator|&
name|xop
operator|->
name|xo_stack
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|xsp
operator|->
name|xs_name
operator|==
name|NULL
condition|)
continue|continue;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xo_data_escape
argument_list|(
name|xop
argument_list|,
name|xsp
operator|->
name|xs_name
argument_list|,
name|strlen
argument_list|(
name|xsp
operator|->
name|xs_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xsp
operator|->
name|xs_keys
condition|)
block|{
comment|/* Don't show keys for the key field */
if|if
condition|(
name|i
operator|!=
name|xop
operator|->
name|xo_depth
operator|||
operator|!
operator|(
name|flags
operator|&
name|XFF_KEY
operator|)
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|xsp
operator|->
name|xs_keys
argument_list|,
name|strlen
argument_list|(
name|xsp
operator|->
name|xs_keys
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xo_data_escape
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_INFO
operator|)
operator|&&
name|xop
operator|->
name|xo_info
condition|)
block|{
specifier|static
name|char
name|in_type
index|[]
init|=
literal|"\" data-type=\""
decl_stmt|;
specifier|static
name|char
name|in_help
index|[]
init|=
literal|"\" data-help=\""
decl_stmt|;
name|xo_info_t
modifier|*
name|xip
init|=
name|xo_info_find
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
name|nlen
argument_list|)
decl_stmt|;
if|if
condition|(
name|xip
condition|)
block|{
if|if
condition|(
name|xip
operator|->
name|xi_type
condition|)
block|{
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|in_type
argument_list|,
sizeof|sizeof
argument_list|(
name|in_type
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xo_data_escape
argument_list|(
name|xop
argument_list|,
name|xip
operator|->
name|xi_type
argument_list|,
name|strlen
argument_list|(
name|xip
operator|->
name|xi_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xip
operator|->
name|xi_help
condition|)
block|{
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|in_help
argument_list|,
sizeof|sizeof
argument_list|(
name|in_help
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xo_data_escape
argument_list|(
name|xop
argument_list|,
name|xip
operator|->
name|xi_help
argument_list|,
name|strlen
argument_list|(
name|xip
operator|->
name|xi_help
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|XFF_KEY
operator|)
operator|&&
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_KEYS
operator|)
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|div_key
argument_list|,
sizeof|sizeof
argument_list|(
name|div_key
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|div_end
argument_list|,
sizeof|sizeof
argument_list|(
name|div_end
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xo_format_data
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|value
argument_list|,
name|vlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|div_close
argument_list|,
sizeof|sizeof
argument_list|(
name|div_close
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_PRETTY
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_format_text
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
switch|switch
condition|(
name|xop
operator|->
name|xo_style
condition|)
block|{
case|case
name|XO_STYLE_TEXT
case|:
name|xo_buf_append_locale
argument_list|(
name|xop
argument_list|,
operator|&
name|xop
operator|->
name|xo_data
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_HTML
case|:
name|xo_buf_append_div
argument_list|(
name|xop
argument_list|,
literal|"text"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xo_format_title
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|int
name|flen
parameter_list|)
block|{
specifier|static
name|char
name|div_open
index|[]
init|=
literal|"<div class=\"title\">"
decl_stmt|;
specifier|static
name|char
name|div_close
index|[]
init|=
literal|"</div>"
decl_stmt|;
switch|switch
condition|(
name|xop
operator|->
name|xo_style
condition|)
block|{
case|case
name|XO_STYLE_XML
case|:
case|case
name|XO_STYLE_JSON
case|:
comment|/* 	 * Even though we don't care about text, we need to do 	 * enough parsing work to skip over the right bits of xo_vap. 	 */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|xo_format_data
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|fmt
argument_list|,
name|flen
argument_list|,
name|XFF_NO_OUTPUT
argument_list|)
expr_stmt|;
return|return;
block|}
name|xo_buffer_t
modifier|*
name|xbp
init|=
operator|&
name|xop
operator|->
name|xo_data
decl_stmt|;
name|int
name|start
init|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
decl_stmt|;
name|int
name|left
init|=
name|xbp
operator|->
name|xb_size
operator|-
name|start
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|int
name|need_enc
init|=
name|XF_ENC_LOCALE
decl_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_style
operator|==
name|XO_STYLE_HTML
condition|)
block|{
name|need_enc
operator|=
name|XF_ENC_UTF8
expr_stmt|;
name|xo_line_ensure_open
argument_list|(
name|xop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_PRETTY
condition|)
name|xo_buf_indent
argument_list|(
name|xop
argument_list|,
name|xop
operator|->
name|xo_indent_by
argument_list|)
expr_stmt|;
name|xo_buf_append
argument_list|(
operator|&
name|xop
operator|->
name|xo_data
argument_list|,
name|div_open
argument_list|,
sizeof|sizeof
argument_list|(
name|div_open
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|start
operator|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
expr_stmt|;
comment|/* Reset start */
if|if
condition|(
name|len
condition|)
block|{
name|char
modifier|*
name|newfmt
init|=
name|alloca
argument_list|(
name|flen
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|newfmt
argument_list|,
name|fmt
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|newfmt
index|[
name|flen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* If len is non-zero, the format string apply to the name */
name|char
modifier|*
name|newstr
init|=
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|newstr
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|newstr
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|newstr
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'s'
condition|)
block|{
name|int
name|cols
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
name|rc
operator|=
name|snprintf
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|newfmt
argument_list|,
name|newstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
block|{
comment|/* 		 * We have to do this the hard way, since we might need 		 * the columns. 		 */
name|bp
operator|=
name|alloca
argument_list|(
name|rc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|rc
operator|=
name|snprintf
argument_list|(
name|bp
argument_list|,
name|rc
operator|+
literal|1
argument_list|,
name|newfmt
argument_list|,
name|newstr
argument_list|)
expr_stmt|;
name|cols
operator|=
name|xo_format_string_direct
argument_list|(
name|xop
argument_list|,
name|xbp
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|bp
argument_list|,
name|rc
argument_list|,
operator|-
literal|1
argument_list|,
name|need_enc
argument_list|,
name|XF_ENC_UTF8
argument_list|)
expr_stmt|;
if|if
condition|(
name|cols
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_COLUMNS
condition|)
name|xop
operator|->
name|xo_columns
operator|+=
name|cols
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_ANCHOR
condition|)
name|xop
operator|->
name|xo_anchor_columns
operator|+=
name|cols
expr_stmt|;
block|}
block|}
goto|goto
name|move_along
goto|;
block|}
else|else
block|{
name|rc
operator|=
name|snprintf
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|left
argument_list|,
name|newfmt
argument_list|,
name|newstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>
name|left
condition|)
block|{
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|)
condition|)
return|return;
name|left
operator|=
name|xbp
operator|->
name|xb_size
operator|-
operator|(
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
operator|)
expr_stmt|;
name|rc
operator|=
name|snprintf
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|left
argument_list|,
name|newfmt
argument_list|,
name|newstr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_COLUMNS
condition|)
name|xop
operator|->
name|xo_columns
operator|+=
name|rc
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_ANCHOR
condition|)
name|xop
operator|->
name|xo_anchor_columns
operator|+=
name|rc
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|xo_format_data
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|fmt
argument_list|,
name|flen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* xo_format_data moved curp, so we need to reset it */
name|rc
operator|=
name|xbp
operator|->
name|xb_curp
operator|-
operator|(
name|xbp
operator|->
name|xb_bufp
operator|+
name|start
operator|)
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|=
name|xbp
operator|->
name|xb_bufp
operator|+
name|start
expr_stmt|;
block|}
comment|/* If we're styling HTML, then we need to escape it */
if|if
condition|(
name|xop
operator|->
name|xo_style
operator|==
name|XO_STYLE_HTML
condition|)
block|{
name|rc
operator|=
name|xo_escape_xml
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
name|xbp
operator|->
name|xb_curp
operator|+=
name|rc
expr_stmt|;
name|move_along
label|:
if|if
condition|(
name|xop
operator|->
name|xo_style
operator|==
name|XO_STYLE_HTML
condition|)
block|{
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|div_close
argument_list|,
sizeof|sizeof
argument_list|(
name|div_close
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_PRETTY
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xo_format_prep
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_xff_flags_t
name|flags
parameter_list|)
block|{
if|if
condition|(
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator|&
name|XSF_NOT_FIRST
condition|)
block|{
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|","
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|XFF_LEAF_LIST
operator|)
operator|&&
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_PRETTY
operator|)
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator||=
name|XSF_NOT_FIRST
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Useful debugging function */
end_comment

begin_endif
unit|void xo_arg (xo_handle_t *xop); void xo_arg (xo_handle_t *xop) {     xop = xo_default(xop);     fprintf(stderr, "0x%x", va_arg(xop->xo_vap, unsigned)); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_function
specifier|static
name|void
name|xo_format_value
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|nlen
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|int
name|flen
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
name|int
name|elen
parameter_list|,
name|xo_xff_flags_t
name|flags
parameter_list|)
block|{
name|int
name|pretty
init|=
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_PRETTY
operator|)
decl_stmt|;
name|int
name|quote
decl_stmt|;
name|xo_buffer_t
modifier|*
name|xbp
decl_stmt|;
switch|switch
condition|(
name|xop
operator|->
name|xo_style
condition|)
block|{
case|case
name|XO_STYLE_TEXT
case|:
if|if
condition|(
name|flags
operator|&
name|XFF_ENCODE_ONLY
condition|)
name|flags
operator||=
name|XFF_NO_OUTPUT
expr_stmt|;
name|xo_format_data
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|format
argument_list|,
name|flen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_HTML
case|:
if|if
condition|(
name|flags
operator|&
name|XFF_ENCODE_ONLY
condition|)
name|flags
operator||=
name|XFF_NO_OUTPUT
expr_stmt|;
name|xo_buf_append_div
argument_list|(
name|xop
argument_list|,
literal|"data"
argument_list|,
name|flags
argument_list|,
name|name
argument_list|,
name|nlen
argument_list|,
name|format
argument_list|,
name|flen
argument_list|,
name|encoding
argument_list|,
name|elen
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_XML
case|:
comment|/* 	 * Even though we're not making output, we still need to 	 * let the formatting code handle the va_arg popping. 	 */
if|if
condition|(
name|flags
operator|&
name|XFF_DISPLAY_ONLY
condition|)
block|{
name|flags
operator||=
name|XFF_NO_OUTPUT
expr_stmt|;
name|xo_format_data
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|format
argument_list|,
name|flen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|encoding
condition|)
block|{
name|format
operator|=
name|encoding
expr_stmt|;
name|flen
operator|=
name|elen
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|enc
init|=
name|alloca
argument_list|(
name|flen
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|enc
argument_list|,
name|format
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|enc
index|[
name|flen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|format
operator|=
name|xo_fix_encoding
argument_list|(
name|xop
argument_list|,
name|enc
argument_list|)
expr_stmt|;
name|flen
operator|=
name|strlen
argument_list|(
name|format
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nlen
operator|==
literal|0
condition|)
block|{
specifier|static
name|char
name|missing
index|[]
init|=
literal|"missing-field-name"
decl_stmt|;
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"missing field name: %s"
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|name
operator|=
name|missing
expr_stmt|;
name|nlen
operator|=
sizeof|sizeof
argument_list|(
name|missing
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pretty
condition|)
name|xo_buf_indent
argument_list|(
name|xop
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"<"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xo_data_escape
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_curp
operator|!=
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_bufp
condition|)
block|{
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_bufp
argument_list|,
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_curp
operator|-
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_bufp
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_curp
operator|=
name|xop
operator|->
name|xo_attrs
operator|.
name|xb_bufp
expr_stmt|;
block|}
comment|/* 	 * We indicate 'key' fields using the 'key' attribute.  While 	 * this is really committing the crime of mixing meta-data with 	 * data, it's often useful.  Especially when format meta-data is 	 * difficult to come by. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|XFF_KEY
operator|)
operator|&&
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_KEYS
operator|)
condition|)
block|{
specifier|static
name|char
name|attr
index|[]
init|=
literal|" key=\"key\""
decl_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|attr
argument_list|,
sizeof|sizeof
argument_list|(
name|attr
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Save the offset at which we'd place units.  See xo_format_units. 	 */
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_UNITS
condition|)
block|{
name|xop
operator|->
name|xo_flags
operator||=
name|XOF_UNITS_PENDING
expr_stmt|;
name|xop
operator|->
name|xo_units_offset
operator|=
name|xop
operator|->
name|xo_data
operator|.
name|xb_curp
operator|-
name|xop
operator|->
name|xo_data
operator|.
name|xb_bufp
expr_stmt|;
block|}
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|">"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xo_format_data
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|format
argument_list|,
name|flen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"</"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|xo_data_escape
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|">"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pretty
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_JSON
case|:
if|if
condition|(
name|flags
operator|&
name|XFF_DISPLAY_ONLY
condition|)
block|{
name|flags
operator||=
name|XFF_NO_OUTPUT
expr_stmt|;
name|xo_format_data
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|format
argument_list|,
name|flen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|encoding
condition|)
block|{
name|format
operator|=
name|encoding
expr_stmt|;
name|flen
operator|=
name|elen
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|enc
init|=
name|alloca
argument_list|(
name|flen
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|enc
argument_list|,
name|format
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|enc
index|[
name|flen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|format
operator|=
name|xo_fix_encoding
argument_list|(
name|xop
argument_list|,
name|enc
argument_list|)
expr_stmt|;
name|flen
operator|=
name|strlen
argument_list|(
name|format
argument_list|)
expr_stmt|;
block|}
name|int
name|first
init|=
operator|!
operator|(
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator|&
name|XSF_NOT_FIRST
operator|)
decl_stmt|;
name|xo_format_prep
argument_list|(
name|xop
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XFF_QUOTE
condition|)
name|quote
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|XFF_NOQUOTE
condition|)
name|quote
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|flen
operator|==
literal|0
condition|)
block|{
name|quote
operator|=
literal|0
expr_stmt|;
name|format
operator|=
literal|"true"
expr_stmt|;
comment|/* JSON encodes empty tags as a boolean true */
name|flen
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"diouxXDOUeEfFgGaAcCp"
argument_list|,
name|format
index|[
name|flen
operator|-
literal|1
index|]
argument_list|)
operator|==
name|NULL
condition|)
name|quote
operator|=
literal|1
expr_stmt|;
else|else
name|quote
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nlen
operator|==
literal|0
condition|)
block|{
specifier|static
name|char
name|missing
index|[]
init|=
literal|"missing-field-name"
decl_stmt|;
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"missing field name: %s"
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|name
operator|=
name|missing
expr_stmt|;
name|nlen
operator|=
sizeof|sizeof
argument_list|(
name|missing
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|XFF_LEAF_LIST
condition|)
block|{
if|if
condition|(
name|first
operator|&&
name|pretty
condition|)
name|xo_buf_indent
argument_list|(
name|xop
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pretty
condition|)
name|xo_buf_indent
argument_list|(
name|xop
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xbp
operator|=
operator|&
name|xop
operator|->
name|xo_data
expr_stmt|;
name|int
name|off
init|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
decl_stmt|;
name|xo_data_escape
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_UNDERSCORES
condition|)
block|{
name|int
name|now
init|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
decl_stmt|;
for|for
control|(
init|;
name|off
operator|<
name|now
condition|;
name|off
operator|++
control|)
if|if
condition|(
name|xbp
operator|->
name|xb_bufp
index|[
name|off
index|]
operator|==
literal|'-'
condition|)
name|xbp
operator|->
name|xb_bufp
index|[
name|off
index|]
operator|=
literal|'_'
expr_stmt|;
block|}
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"\":"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pretty
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|quote
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xo_format_data
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|format
argument_list|,
name|flen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|quote
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xo_format_content
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|class_name
parameter_list|,
specifier|const
name|char
modifier|*
name|xml_tag
parameter_list|,
name|int
name|display_only
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|int
name|flen
parameter_list|)
block|{
switch|switch
condition|(
name|xop
operator|->
name|xo_style
condition|)
block|{
case|case
name|XO_STYLE_TEXT
case|:
if|if
condition|(
name|len
condition|)
block|{
name|xo_data_append_content
argument_list|(
name|xop
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
name|xo_format_data
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|fmt
argument_list|,
name|flen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_HTML
case|:
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|str
operator|=
name|fmt
expr_stmt|;
name|len
operator|=
name|flen
expr_stmt|;
block|}
name|xo_buf_append_div
argument_list|(
name|xop
argument_list|,
name|class_name
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_XML
case|:
if|if
condition|(
name|xml_tag
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|str
operator|=
name|fmt
expr_stmt|;
name|len
operator|=
name|flen
expr_stmt|;
block|}
name|xo_open_container_h
argument_list|(
name|xop
argument_list|,
name|xml_tag
argument_list|)
expr_stmt|;
name|xo_format_value
argument_list|(
name|xop
argument_list|,
literal|"message"
argument_list|,
literal|7
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xo_close_container_h
argument_list|(
name|xop
argument_list|,
name|xml_tag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * Even though we don't care about labels, we need to do 	     * enough parsing work to skip over the right bits of xo_vap. 	     */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|xo_format_data
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|fmt
argument_list|,
name|flen
argument_list|,
name|XFF_NO_OUTPUT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XO_STYLE_JSON
case|:
comment|/* 	 * Even though we don't care about labels, we need to do 	 * enough parsing work to skip over the right bits of xo_vap. 	 */
if|if
condition|(
name|display_only
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|xo_format_data
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|fmt
argument_list|,
name|flen
argument_list|,
name|XFF_NO_OUTPUT
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* XXX need schem for representing errors in JSON */
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xo_format_units
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|int
name|flen
parameter_list|)
block|{
specifier|static
name|char
name|units_start_xml
index|[]
init|=
literal|" units=\""
decl_stmt|;
specifier|static
name|char
name|units_start_html
index|[]
init|=
literal|" data-units=\""
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_UNITS_PENDING
operator|)
condition|)
block|{
name|xo_format_content
argument_list|(
name|xop
argument_list|,
literal|"units"
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
name|fmt
argument_list|,
name|flen
argument_list|)
expr_stmt|;
return|return;
block|}
name|xo_buffer_t
modifier|*
name|xbp
init|=
operator|&
name|xop
operator|->
name|xo_data
decl_stmt|;
name|int
name|start
init|=
name|xop
operator|->
name|xo_units_offset
decl_stmt|;
name|int
name|stop
init|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
decl_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_style
operator|==
name|XO_STYLE_XML
condition|)
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|units_start_xml
argument_list|,
sizeof|sizeof
argument_list|(
name|units_start_xml
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xop
operator|->
name|xo_style
operator|==
name|XO_STYLE_HTML
condition|)
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
name|units_start_html
argument_list|,
sizeof|sizeof
argument_list|(
name|units_start_html
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
return|return;
if|if
condition|(
name|len
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|xo_format_data
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|,
name|fmt
argument_list|,
name|flen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xo_buf_append
argument_list|(
name|xbp
argument_list|,
literal|"\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|int
name|now
init|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
decl_stmt|;
name|int
name|delta
init|=
name|now
operator|-
name|stop
decl_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
block|{
comment|/* Strange; no output to move */
name|xbp
operator|->
name|xb_curp
operator|=
name|xbp
operator|->
name|xb_bufp
operator|+
name|stop
expr_stmt|;
comment|/* Reset buffer to prior state */
return|return;
block|}
comment|/*      * Now we're in it alright.  We've need to insert the unit value      * we just created into the right spot.  We make a local copy,      * move it and then insert our copy.  We know there's room in the      * buffer, since we're just moving this around.      */
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|delta
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|xbp
operator|->
name|xb_bufp
operator|+
name|stop
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|xbp
operator|->
name|xb_bufp
operator|+
name|start
operator|+
name|delta
argument_list|,
name|xbp
operator|->
name|xb_bufp
operator|+
name|start
argument_list|,
name|stop
operator|-
name|start
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|xbp
operator|->
name|xb_bufp
operator|+
name|start
argument_list|,
name|buf
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_find_width
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|int
name|flen
parameter_list|)
block|{
name|long
name|width
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|bp
operator|=
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Make local NUL-terminated copy of str */
name|memcpy
argument_list|(
name|bp
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bp
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|width
operator|=
name|strtol
argument_list|(
name|bp
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|==
name|LONG_MIN
operator|||
name|width
operator|==
name|LONG_MAX
operator|||
name|bp
operator|==
name|cp
operator|||
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
name|width
operator|=
literal|0
expr_stmt|;
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"invalid width for anchor: '%s'"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flen
condition|)
block|{
if|if
condition|(
name|flen
operator|!=
literal|2
operator|||
name|strncmp
argument_list|(
literal|"%d"
argument_list|,
name|fmt
argument_list|,
name|flen
argument_list|)
operator|!=
literal|0
condition|)
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"invalid width format: '%*.*s'"
argument_list|,
name|flen
argument_list|,
name|flen
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_NO_VA_ARG
operator|)
condition|)
name|width
operator|=
name|va_arg
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|int
argument_list|)
expr_stmt|;
block|}
return|return
name|width
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_anchor_clear
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
name|xop
operator|->
name|xo_flags
operator|&=
operator|~
name|XOF_ANCHOR
expr_stmt|;
name|xop
operator|->
name|xo_anchor_offset
operator|=
literal|0
expr_stmt|;
name|xop
operator|->
name|xo_anchor_columns
operator|=
literal|0
expr_stmt|;
name|xop
operator|->
name|xo_anchor_min_width
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * An anchor is a marker used to delay field width implications.  * Imagine the format string "{[:10}{min:%d}/{cur:%d}/{max:%d}{:]}".  * We are looking for output like "     1/4/5"  *  * To make this work, we record the anchor and then return to  * format it when the end anchor tag is seen.  */
end_comment

begin_function
specifier|static
name|void
name|xo_anchor_start
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|int
name|flen
parameter_list|)
block|{
if|if
condition|(
name|xop
operator|->
name|xo_style
operator|!=
name|XO_STYLE_TEXT
operator|&&
name|xop
operator|->
name|xo_style
operator|!=
name|XO_STYLE_HTML
condition|)
return|return;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_ANCHOR
condition|)
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"the anchor already recording is discarded"
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_flags
operator||=
name|XOF_ANCHOR
expr_stmt|;
name|xo_buffer_t
modifier|*
name|xbp
init|=
operator|&
name|xop
operator|->
name|xo_data
decl_stmt|;
name|xop
operator|->
name|xo_anchor_offset
operator|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
expr_stmt|;
name|xop
operator|->
name|xo_anchor_columns
operator|=
literal|0
expr_stmt|;
comment|/*      * Now we find the width, if possible.  If it's not there,      * we'll get it on the end anchor.      */
name|xop
operator|->
name|xo_anchor_min_width
operator|=
name|xo_find_width
argument_list|(
name|xop
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
name|fmt
argument_list|,
name|flen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_anchor_stop
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|int
name|flen
parameter_list|)
block|{
if|if
condition|(
name|xop
operator|->
name|xo_style
operator|!=
name|XO_STYLE_TEXT
operator|&&
name|xop
operator|->
name|xo_style
operator|!=
name|XO_STYLE_HTML
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_ANCHOR
operator|)
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"no start anchor"
argument_list|)
expr_stmt|;
return|return;
block|}
name|xop
operator|->
name|xo_flags
operator|&=
operator|~
name|XOF_UNITS_PENDING
expr_stmt|;
name|int
name|width
init|=
name|xo_find_width
argument_list|(
name|xop
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
name|fmt
argument_list|,
name|flen
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|==
literal|0
condition|)
name|width
operator|=
name|xop
operator|->
name|xo_anchor_min_width
expr_stmt|;
if|if
condition|(
name|width
operator|==
literal|0
condition|)
comment|/* No width given; nothing to do */
goto|goto
name|done
goto|;
name|xo_buffer_t
modifier|*
name|xbp
init|=
operator|&
name|xop
operator|->
name|xo_data
decl_stmt|;
name|int
name|start
init|=
name|xop
operator|->
name|xo_anchor_offset
decl_stmt|;
name|int
name|stop
init|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
decl_stmt|;
name|int
name|abswidth
init|=
operator|(
name|width
operator|>
literal|0
operator|)
condition|?
name|width
else|:
operator|-
name|width
decl_stmt|;
name|int
name|blen
init|=
name|abswidth
operator|-
name|xop
operator|->
name|xo_anchor_columns
decl_stmt|;
if|if
condition|(
name|blen
operator|<=
literal|0
condition|)
comment|/* Already over width */
goto|goto
name|done
goto|;
if|if
condition|(
name|abswidth
operator|>
name|XO_MAX_ANCHOR_WIDTH
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"width over %u are not supported"
argument_list|,
name|XO_MAX_ANCHOR_WIDTH
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Make a suitable padding field and emit it */
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|blen
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|' '
argument_list|,
name|blen
argument_list|)
expr_stmt|;
name|xo_format_content
argument_list|(
name|xop
argument_list|,
literal|"padding"
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|buf
argument_list|,
name|blen
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|<
literal|0
condition|)
comment|/* Already left justified */
goto|goto
name|done
goto|;
name|int
name|now
init|=
name|xbp
operator|->
name|xb_curp
operator|-
name|xbp
operator|->
name|xb_bufp
decl_stmt|;
name|int
name|delta
init|=
name|now
operator|-
name|stop
decl_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
comment|/* Strange; no output to move */
goto|goto
name|done
goto|;
comment|/*      * Now we're in it alright.  We've need to insert the padding data      * we just created (which might be an HTML<div> or text) before      * the formatted data.  We make a local copy, move it and then      * insert our copy.  We know there's room in the buffer, since      * we're just moving this around.      */
if|if
condition|(
name|delta
operator|>
name|blen
condition|)
name|buf
operator|=
name|alloca
argument_list|(
name|delta
argument_list|)
expr_stmt|;
comment|/* Expand buffer if needed */
name|memcpy
argument_list|(
name|buf
argument_list|,
name|xbp
operator|->
name|xb_bufp
operator|+
name|stop
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|xbp
operator|->
name|xb_bufp
operator|+
name|start
operator|+
name|delta
argument_list|,
name|xbp
operator|->
name|xb_bufp
operator|+
name|start
argument_list|,
name|stop
operator|-
name|start
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|xbp
operator|->
name|xb_bufp
operator|+
name|start
argument_list|,
name|buf
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|done
label|:
name|xo_anchor_clear
argument_list|(
name|xop
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_do_emit
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|basep
decl_stmt|;
name|char
modifier|*
name|newp
init|=
name|NULL
decl_stmt|;
name|int
name|flush
init|=
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_FLUSH
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|xop
operator|->
name|xo_columns
operator|=
literal|0
expr_stmt|;
comment|/* Always reset it */
for|for
control|(
name|cp
operator|=
name|fmt
init|;
operator|*
name|cp
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
name|xo_line_close
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|xo_flush_h
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'{'
condition|)
block|{
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'{'
condition|)
block|{
comment|/* Start of {{escaped braces}} */
name|cp
operator|+=
literal|2
expr_stmt|;
comment|/* Skip over _both_ characters */
for|for
control|(
name|sp
operator|=
name|cp
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|'}'
operator|&&
name|sp
index|[
literal|1
index|]
operator|==
literal|'}'
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|sp
operator|==
literal|'\0'
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"missing closing '}}': %s"
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|xo_format_text
argument_list|(
name|xop
argument_list|,
name|cp
argument_list|,
name|sp
operator|-
name|cp
argument_list|)
expr_stmt|;
comment|/* Move along the string, but don't run off the end */
if|if
condition|(
operator|*
name|sp
operator|==
literal|'}'
operator|&&
name|sp
index|[
literal|1
index|]
operator|==
literal|'}'
condition|)
name|sp
operator|+=
literal|2
expr_stmt|;
name|cp
operator|=
operator|*
name|sp
condition|?
name|sp
operator|+
literal|1
else|:
name|sp
expr_stmt|;
continue|continue;
block|}
comment|/* Else fall thru to the code below */
block|}
else|else
block|{
comment|/* Normal text */
for|for
control|(
name|sp
operator|=
name|cp
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|'{'
operator|||
operator|*
name|sp
operator|==
literal|'\n'
condition|)
break|break;
block|}
name|xo_format_text
argument_list|(
name|xop
argument_list|,
name|cp
argument_list|,
name|sp
operator|-
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|sp
expr_stmt|;
continue|continue;
block|}
name|basep
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
comment|/* 	 * We are looking at the start of a field definition.  The format is: 	 *  '{' modifiers ':' content [ '/' print-fmt [ '/' encode-fmt ]] '}' 	 * Modifiers are optional and include the following field types: 	 *   'D': decoration; something non-text and non-data (colons, commmas) 	 *   'E': error message 	 *   'L': label; text preceding data 	 *   'N': note; text following data 	 *   'P': padding; whitespace 	 *   'T': Title, where 'content' is a column title 	 *   'U': Units, where 'content' is the unit label 	 *   'V': value, where 'content' is the name of the field (the default) 	 *   'W': warning message 	 *   '[': start a section of anchored text 	 *   ']': end a section of anchored text          * The following flags are also supported: 	 *   'c': flag: emit a colon after the label 	 *   'd': field is only emitted for display formats (text and html) 	 *   'e': field is only emitted for encoding formats (xml and json) 	 *   'k': this field is a key, suitable for XPath predicates 	 *   'l': a leaf-list, a simple list of values 	 *   'n': no quotes around this field 	 *   'q': add quotes around this field 	 *   't': trim whitespace around the value 	 *   'w': emit a blank after the label 	 * The print-fmt and encode-fmt strings is the printf-style formating 	 * for this data.  JSON and XML will use the encoding-fmt, if present. 	 * If the encode-fmt is not provided, it defaults to the print-fmt. 	 * If the print-fmt is not provided, it defaults to 's'. 	 */
name|unsigned
name|ftype
init|=
literal|0
decl_stmt|,
name|flags
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|content
init|=
name|NULL
decl_stmt|,
modifier|*
name|format
init|=
name|NULL
decl_stmt|,
modifier|*
name|encoding
init|=
name|NULL
decl_stmt|;
name|int
name|clen
init|=
literal|0
decl_stmt|,
name|flen
init|=
literal|0
decl_stmt|,
name|elen
init|=
literal|0
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|basep
init|;
name|sp
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|':'
operator|||
operator|*
name|sp
operator|==
literal|'/'
operator|||
operator|*
name|sp
operator|==
literal|'}'
condition|)
break|break;
if|if
condition|(
operator|*
name|sp
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|sp
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"backslash at the end of string"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|sp
operator|+=
literal|1
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
operator|*
name|sp
condition|)
block|{
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'L'
case|:
case|case
literal|'N'
case|:
case|case
literal|'P'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'['
case|:
case|case
literal|']'
case|:
if|if
condition|(
name|ftype
operator|!=
literal|0
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"field descriptor uses multiple types: %s"
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ftype
operator|=
operator|*
name|sp
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|flags
operator||=
name|XFF_COLON
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|flags
operator||=
name|XFF_DISPLAY_ONLY
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|flags
operator||=
name|XFF_ENCODE_ONLY
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|flags
operator||=
name|XFF_KEY
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|flags
operator||=
name|XFF_LEAF_LIST
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|flags
operator||=
name|XFF_NOQUOTE
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|flags
operator||=
name|XFF_QUOTE
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|flags
operator||=
name|XFF_TRIM_WS
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|flags
operator||=
name|XFF_WS
expr_stmt|;
break|break;
default|default:
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"field descriptor uses unknown modifier: %s"
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
comment|/* 		 * No good answer here; a bad format will likely 		 * mean a core file.  We just return and hope 		 * the caller notices there's no output, and while 		 * that seems, well, bad.  There's nothing better. 		 */
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
operator|*
name|sp
operator|==
literal|':'
condition|)
block|{
for|for
control|(
name|ep
operator|=
operator|++
name|sp
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|'}'
operator|||
operator|*
name|sp
operator|==
literal|'/'
condition|)
break|break;
if|if
condition|(
operator|*
name|sp
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|sp
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"backslash at the end of string"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|sp
operator|+=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|ep
operator|!=
name|sp
condition|)
block|{
name|clen
operator|=
name|sp
operator|-
name|ep
expr_stmt|;
name|content
operator|=
name|ep
expr_stmt|;
block|}
block|}
else|else
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"missing content (':'): %s"
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|sp
operator|==
literal|'/'
condition|)
block|{
for|for
control|(
name|ep
operator|=
operator|++
name|sp
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|'}'
operator|||
operator|*
name|sp
operator|==
literal|'/'
condition|)
break|break;
if|if
condition|(
operator|*
name|sp
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|sp
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"backslash at the end of string"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|sp
operator|+=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
name|flen
operator|=
name|sp
operator|-
name|ep
expr_stmt|;
name|format
operator|=
name|ep
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|sp
operator|==
literal|'/'
condition|)
block|{
for|for
control|(
name|ep
operator|=
operator|++
name|sp
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|'}'
condition|)
break|break;
block|}
name|elen
operator|=
name|sp
operator|-
name|ep
expr_stmt|;
name|encoding
operator|=
name|ep
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|sp
operator|==
literal|'}'
condition|)
block|{
name|sp
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"missing closing '}': %s"
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|format
operator|==
name|NULL
operator|&&
name|ftype
operator|!=
literal|'['
operator|&&
name|ftype
operator|!=
literal|']'
condition|)
block|{
name|format
operator|=
literal|"%s"
expr_stmt|;
name|flen
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|ftype
operator|==
literal|0
operator|||
name|ftype
operator|==
literal|'V'
condition|)
name|xo_format_value
argument_list|(
name|xop
argument_list|,
name|content
argument_list|,
name|clen
argument_list|,
name|format
argument_list|,
name|flen
argument_list|,
name|encoding
argument_list|,
name|elen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ftype
operator|==
literal|'D'
condition|)
name|xo_format_content
argument_list|(
name|xop
argument_list|,
literal|"decoration"
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|content
argument_list|,
name|clen
argument_list|,
name|format
argument_list|,
name|flen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ftype
operator|==
literal|'E'
condition|)
name|xo_format_content
argument_list|(
name|xop
argument_list|,
literal|"error"
argument_list|,
literal|"error"
argument_list|,
literal|0
argument_list|,
name|content
argument_list|,
name|clen
argument_list|,
name|format
argument_list|,
name|flen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ftype
operator|==
literal|'L'
condition|)
name|xo_format_content
argument_list|(
name|xop
argument_list|,
literal|"label"
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|content
argument_list|,
name|clen
argument_list|,
name|format
argument_list|,
name|flen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ftype
operator|==
literal|'N'
condition|)
name|xo_format_content
argument_list|(
name|xop
argument_list|,
literal|"note"
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|content
argument_list|,
name|clen
argument_list|,
name|format
argument_list|,
name|flen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ftype
operator|==
literal|'P'
condition|)
name|xo_format_content
argument_list|(
name|xop
argument_list|,
literal|"padding"
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|content
argument_list|,
name|clen
argument_list|,
name|format
argument_list|,
name|flen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ftype
operator|==
literal|'T'
condition|)
name|xo_format_title
argument_list|(
name|xop
argument_list|,
name|content
argument_list|,
name|clen
argument_list|,
name|format
argument_list|,
name|flen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ftype
operator|==
literal|'U'
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|XFF_WS
condition|)
name|xo_format_content
argument_list|(
name|xop
argument_list|,
literal|"padding"
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xo_format_units
argument_list|(
name|xop
argument_list|,
name|content
argument_list|,
name|clen
argument_list|,
name|format
argument_list|,
name|flen
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ftype
operator|==
literal|'W'
condition|)
name|xo_format_content
argument_list|(
name|xop
argument_list|,
literal|"warning"
argument_list|,
literal|"warning"
argument_list|,
literal|0
argument_list|,
name|content
argument_list|,
name|clen
argument_list|,
name|format
argument_list|,
name|flen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ftype
operator|==
literal|'['
condition|)
name|xo_anchor_start
argument_list|(
name|xop
argument_list|,
name|content
argument_list|,
name|clen
argument_list|,
name|format
argument_list|,
name|flen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ftype
operator|==
literal|']'
condition|)
name|xo_anchor_stop
argument_list|(
name|xop
argument_list|,
name|content
argument_list|,
name|clen
argument_list|,
name|format
argument_list|,
name|flen
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XFF_COLON
condition|)
name|xo_format_content
argument_list|(
name|xop
argument_list|,
literal|"decoration"
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|":"
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftype
operator|!=
literal|'U'
operator|&&
operator|(
name|flags
operator|&
name|XFF_WS
operator|)
condition|)
name|xo_format_content
argument_list|(
name|xop
argument_list|,
literal|"padding"
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|sp
operator|-
name|basep
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|newp
condition|)
block|{
name|xo_free
argument_list|(
name|newp
argument_list|)
expr_stmt|;
name|newp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* If we don't have an anchor, write the text out */
if|if
condition|(
name|flush
operator|&&
operator|!
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_ANCHOR
operator|)
condition|)
name|xo_write
argument_list|(
name|xop
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|<
literal|0
operator|)
condition|?
name|rc
else|:
operator|(
name|int
operator|)
name|xop
operator|->
name|xo_columns
return|;
block|}
end_function

begin_function
name|int
name|xo_emit_hv
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|vap
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|va_copy
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_do_emit
argument_list|(
name|xop
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|xop
operator|->
name|xo_vap
argument_list|,
sizeof|sizeof
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|int
name|xo_emit_h
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_do_emit
argument_list|(
name|xop
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|xop
operator|->
name|xo_vap
argument_list|,
sizeof|sizeof
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|int
name|xo_emit
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|xo_handle_t
modifier|*
name|xop
init|=
name|xo_default
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|va_start
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_do_emit
argument_list|(
name|xop
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|xop
operator|->
name|xo_vap
argument_list|,
sizeof|sizeof
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|int
name|xo_attr_hv
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|vap
parameter_list|)
block|{
specifier|const
name|int
name|extra
init|=
literal|5
decl_stmt|;
comment|/* space, equals, quote, quote, and nul */
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_style
operator|!=
name|XO_STYLE_XML
condition|)
return|return
literal|0
return|;
name|int
name|nlen
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|xo_buffer_t
modifier|*
name|xbp
init|=
operator|&
name|xop
operator|->
name|xo_attrs
decl_stmt|;
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
name|nlen
operator|+
name|extra
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|xbp
operator|->
name|xb_curp
operator|++
operator|=
literal|' '
expr_stmt|;
name|memcpy
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|name
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|+=
name|nlen
expr_stmt|;
operator|*
name|xbp
operator|->
name|xb_curp
operator|++
operator|=
literal|'='
expr_stmt|;
operator|*
name|xbp
operator|->
name|xb_curp
operator|++
operator|=
literal|'"'
expr_stmt|;
name|int
name|rc
init|=
name|xo_vsnprintf
argument_list|(
name|xop
argument_list|,
name|xbp
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
block|{
name|rc
operator|=
name|xo_escape_xml
argument_list|(
name|xbp
argument_list|,
name|rc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|+=
name|rc
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|xo_buf_has_room
argument_list|(
name|xbp
argument_list|,
literal|2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|xbp
operator|->
name|xb_curp
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|*
name|xbp
operator|->
name|xb_curp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|rc
operator|+
name|nlen
operator|+
name|extra
return|;
block|}
end_function

begin_function
name|int
name|xo_attr_h
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_attr_hv
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|int
name|xo_attr
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_attr_hv
argument_list|(
name|NULL
argument_list|,
name|name
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_stack_set_flags
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_NOT_FIRST
condition|)
block|{
name|xo_stack_t
modifier|*
name|xsp
init|=
operator|&
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
decl_stmt|;
name|xsp
operator|->
name|xs_flags
operator||=
name|XSF_NOT_FIRST
expr_stmt|;
name|xop
operator|->
name|xo_flags
operator|&=
operator|~
name|XOF_NOT_FIRST
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xo_depth_change
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|delta
parameter_list|,
name|int
name|indent
parameter_list|,
name|xo_xsf_flags_t
name|flags
parameter_list|)
block|{
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_DTRT
condition|)
name|flags
operator||=
name|XSF_DTRT
expr_stmt|;
if|if
condition|(
name|delta
operator|>=
literal|0
condition|)
block|{
comment|/* Push operation */
if|if
condition|(
name|xo_depth_check
argument_list|(
name|xop
argument_list|,
name|xop
operator|->
name|xo_depth
operator|+
name|delta
argument_list|)
condition|)
return|return;
name|xo_stack_t
modifier|*
name|xsp
init|=
operator|&
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
operator|+
name|delta
index|]
decl_stmt|;
name|xsp
operator|->
name|xs_flags
operator|=
name|flags
expr_stmt|;
name|xo_stack_set_flags
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|unsigned
name|save
init|=
operator|(
name|xop
operator|->
name|xo_flags
operator|&
operator|(
name|XOF_XPATH
operator||
name|XOF_WARN
operator||
name|XOF_DTRT
operator|)
operator|)
decl_stmt|;
name|save
operator||=
operator|(
name|flags
operator|&
name|XSF_DTRT
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|&&
name|save
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|xo_realloc
argument_list|(
name|NULL
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
name|memcpy
argument_list|(
name|cp
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|xsp
operator|->
name|xs_name
operator|=
name|cp
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Pop operation */
if|if
condition|(
name|xop
operator|->
name|xo_depth
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_IGNORE_CLOSE
operator|)
condition|)
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"close with empty stack: '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|xo_stack_t
modifier|*
name|xsp
init|=
operator|&
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
decl_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_WARN
condition|)
block|{
specifier|const
name|char
modifier|*
name|top
init|=
name|xsp
operator|->
name|xs_name
decl_stmt|;
if|if
condition|(
name|top
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|top
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"incorrect close: '%s' .vs. '%s'"
argument_list|,
name|name
argument_list|,
name|top
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|xsp
operator|->
name|xs_flags
operator|&
name|XSF_LIST
operator|)
operator|!=
operator|(
name|flags
operator|&
name|XSF_LIST
operator|)
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"list close on list confict: '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|xsp
operator|->
name|xs_flags
operator|&
name|XSF_INSTANCE
operator|)
operator|!=
operator|(
name|flags
operator|&
name|XSF_INSTANCE
operator|)
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"list close on instance confict: '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|xsp
operator|->
name|xs_name
condition|)
block|{
name|xo_free
argument_list|(
name|xsp
operator|->
name|xs_name
argument_list|)
expr_stmt|;
name|xsp
operator|->
name|xs_name
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|xsp
operator|->
name|xs_keys
condition|)
block|{
name|xo_free
argument_list|(
name|xsp
operator|->
name|xs_keys
argument_list|)
expr_stmt|;
name|xsp
operator|->
name|xs_keys
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|xop
operator|->
name|xo_depth
operator|+=
name|delta
expr_stmt|;
comment|/* Record new depth */
name|xop
operator|->
name|xo_indent
operator|+=
name|indent
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_set_depth
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|xo_depth_check
argument_list|(
name|xop
argument_list|,
name|depth
argument_list|)
condition|)
return|return;
name|xop
operator|->
name|xo_depth
operator|+=
name|depth
expr_stmt|;
name|xop
operator|->
name|xo_indent
operator|+=
name|depth
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|xo_xsf_flags_t
name|xo_stack_flags
parameter_list|(
name|unsigned
name|xflags
parameter_list|)
block|{
if|if
condition|(
name|xflags
operator|&
name|XOF_DTRT
condition|)
return|return
name|XSF_DTRT
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_open_container_hf
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_xof_flags_t
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|ppn
init|=
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_PRETTY
operator|)
condition|?
literal|"\n"
else|:
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|pre_nl
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"NULL passed for container name"
argument_list|)
expr_stmt|;
name|name
operator|=
name|XO_FAILURE_NAME
expr_stmt|;
block|}
name|flags
operator||=
name|xop
operator|->
name|xo_flags
expr_stmt|;
comment|/* Pick up handle flags */
switch|switch
condition|(
name|xop
operator|->
name|xo_style
condition|)
block|{
case|case
name|XO_STYLE_XML
case|:
name|rc
operator|=
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%*s<%s>%s"
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|,
name|name
argument_list|,
name|ppn
argument_list|)
expr_stmt|;
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|xo_stack_flags
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_JSON
case|:
name|xo_stack_set_flags
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_NO_TOP
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_TOP_EMITTED
operator|)
condition|)
block|{
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%*s{%s"
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|,
name|ppn
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_flags
operator||=
name|XOF_TOP_EMITTED
expr_stmt|;
block|}
block|}
if|if
condition|(
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator|&
name|XSF_NOT_FIRST
condition|)
name|pre_nl
operator|=
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_PRETTY
operator|)
condition|?
literal|",\n"
else|:
literal|", "
expr_stmt|;
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator||=
name|XSF_NOT_FIRST
expr_stmt|;
name|rc
operator|=
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%s%*s\"%s\": {%s"
argument_list|,
name|pre_nl
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|,
name|name
argument_list|,
name|ppn
argument_list|)
expr_stmt|;
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|xo_stack_flags
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_HTML
case|:
case|case
name|XO_STYLE_TEXT
case|:
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|xo_stack_flags
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
name|int
name|xo_open_container_h
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_open_container_hf
argument_list|(
name|xop
argument_list|,
literal|0
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|xo_open_container
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_open_container_hf
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|xo_open_container_hd
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_open_container_hf
argument_list|(
name|xop
argument_list|,
name|XOF_DTRT
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|xo_open_container_d
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_open_container_hf
argument_list|(
name|NULL
argument_list|,
name|XOF_DTRT
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|xo_close_container_h
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|ppn
init|=
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_PRETTY
operator|)
condition|?
literal|"\n"
else|:
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|pre_nl
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|xo_stack_t
modifier|*
name|xsp
init|=
operator|&
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|xsp
operator|->
name|xs_flags
operator|&
name|XSF_DTRT
operator|)
condition|)
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"missing name without 'dtrt' mode"
argument_list|)
expr_stmt|;
name|name
operator|=
name|xsp
operator|->
name|xs_name
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|/* We need to make a local copy; xo_depth_change will free it */
name|char
modifier|*
name|cp
init|=
name|alloca
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
operator|=
name|cp
expr_stmt|;
block|}
else|else
name|name
operator|=
name|XO_FAILURE_NAME
expr_stmt|;
block|}
switch|switch
condition|(
name|xop
operator|->
name|xo_style
condition|)
block|{
case|case
name|XO_STYLE_XML
case|:
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%*s</%s>%s"
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|,
name|name
argument_list|,
name|ppn
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_JSON
case|:
name|pre_nl
operator|=
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_PRETTY
operator|)
condition|?
literal|"\n"
else|:
literal|""
expr_stmt|;
name|ppn
operator|=
operator|(
name|xop
operator|->
name|xo_depth
operator|<=
literal|1
operator|)
condition|?
literal|"\n"
else|:
literal|""
expr_stmt|;
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%s%*s}%s"
argument_list|,
name|pre_nl
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|,
name|ppn
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator||=
name|XSF_NOT_FIRST
expr_stmt|;
break|break;
case|case
name|XO_STYLE_HTML
case|:
case|case
name|XO_STYLE_TEXT
case|:
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
name|int
name|xo_close_container
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_close_container_h
argument_list|(
name|NULL
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|xo_close_container_hd
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
return|return
name|xo_close_container_h
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|xo_close_container_d
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|xo_close_container_h
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_open_list_hf
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_xsf_flags_t
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_style
operator|!=
name|XO_STYLE_JSON
condition|)
return|return
literal|0
return|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|ppn
init|=
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_PRETTY
operator|)
condition|?
literal|"\n"
else|:
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|pre_nl
init|=
literal|""
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_NO_TOP
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_TOP_EMITTED
operator|)
condition|)
block|{
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%*s{%s"
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|,
name|ppn
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_flags
operator||=
name|XOF_TOP_EMITTED
expr_stmt|;
block|}
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"NULL passed for list name"
argument_list|)
expr_stmt|;
name|name
operator|=
name|XO_FAILURE_NAME
expr_stmt|;
block|}
name|xo_stack_set_flags
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator|&
name|XSF_NOT_FIRST
condition|)
name|pre_nl
operator|=
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_PRETTY
operator|)
condition|?
literal|",\n"
else|:
literal|", "
expr_stmt|;
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator||=
name|XSF_NOT_FIRST
expr_stmt|;
name|rc
operator|=
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%s%*s\"%s\": [%s"
argument_list|,
name|pre_nl
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|,
name|name
argument_list|,
name|ppn
argument_list|)
expr_stmt|;
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|XSF_LIST
operator||
name|xo_stack_flags
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|int
name|xo_open_list_h
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
name|UNUSED
parameter_list|)
block|{
return|return
name|xo_open_list_hf
argument_list|(
name|xop
argument_list|,
literal|0
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|xo_open_list
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_open_list_hf
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|xo_open_list_hd
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
name|UNUSED
parameter_list|)
block|{
return|return
name|xo_open_list_hf
argument_list|(
name|xop
argument_list|,
name|XOF_DTRT
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|xo_open_list_d
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_open_list_hf
argument_list|(
name|NULL
argument_list|,
name|XOF_DTRT
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|xo_close_list_h
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|pre_nl
init|=
literal|""
decl_stmt|;
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_style
operator|!=
name|XO_STYLE_JSON
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|xo_stack_t
modifier|*
name|xsp
init|=
operator|&
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|xsp
operator|->
name|xs_flags
operator|&
name|XSF_DTRT
operator|)
condition|)
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"missing name without 'dtrt' mode"
argument_list|)
expr_stmt|;
name|name
operator|=
name|xsp
operator|->
name|xs_name
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|/* We need to make a local copy; xo_depth_change will free it */
name|char
modifier|*
name|cp
init|=
name|alloca
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
operator|=
name|cp
expr_stmt|;
block|}
else|else
name|name
operator|=
name|XO_FAILURE_NAME
expr_stmt|;
block|}
if|if
condition|(
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator|&
name|XSF_NOT_FIRST
condition|)
name|pre_nl
operator|=
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_PRETTY
operator|)
condition|?
literal|"\n"
else|:
literal|""
expr_stmt|;
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator||=
name|XSF_NOT_FIRST
expr_stmt|;
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|XSF_LIST
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%s%*s]"
argument_list|,
name|pre_nl
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator||=
name|XSF_NOT_FIRST
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|xo_close_list
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_close_list_h
argument_list|(
name|NULL
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|xo_close_list_hd
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
return|return
name|xo_close_list_h
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|xo_close_list_d
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|xo_close_list_h
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xo_open_instance_hf
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_xsf_flags_t
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|ppn
init|=
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_PRETTY
operator|)
condition|?
literal|"\n"
else|:
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|pre_nl
init|=
literal|""
decl_stmt|;
name|flags
operator||=
name|xop
operator|->
name|xo_flags
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"NULL passed for instance name"
argument_list|)
expr_stmt|;
name|name
operator|=
name|XO_FAILURE_NAME
expr_stmt|;
block|}
switch|switch
condition|(
name|xop
operator|->
name|xo_style
condition|)
block|{
case|case
name|XO_STYLE_XML
case|:
name|rc
operator|=
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%*s<%s>%s"
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|,
name|name
argument_list|,
name|ppn
argument_list|)
expr_stmt|;
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|xo_stack_flags
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_JSON
case|:
name|xo_stack_set_flags
argument_list|(
name|xop
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator|&
name|XSF_NOT_FIRST
condition|)
name|pre_nl
operator|=
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_PRETTY
operator|)
condition|?
literal|",\n"
else|:
literal|", "
expr_stmt|;
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator||=
name|XSF_NOT_FIRST
expr_stmt|;
name|rc
operator|=
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%s%*s{%s"
argument_list|,
name|pre_nl
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|,
name|ppn
argument_list|)
expr_stmt|;
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|xo_stack_flags
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_HTML
case|:
case|case
name|XO_STYLE_TEXT
case|:
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|xo_stack_flags
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
name|int
name|xo_open_instance_h
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_open_instance_hf
argument_list|(
name|xop
argument_list|,
literal|0
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|xo_open_instance
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_open_instance_hf
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|xo_open_instance_hd
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_open_instance_hf
argument_list|(
name|xop
argument_list|,
name|XOF_DTRT
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|xo_open_instance_d
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_open_instance_hf
argument_list|(
name|NULL
argument_list|,
name|XOF_DTRT
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|xo_close_instance_h
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|ppn
init|=
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_PRETTY
operator|)
condition|?
literal|"\n"
else|:
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|pre_nl
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|xo_stack_t
modifier|*
name|xsp
init|=
operator|&
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|xsp
operator|->
name|xs_flags
operator|&
name|XSF_DTRT
operator|)
condition|)
name|xo_failure
argument_list|(
name|xop
argument_list|,
literal|"missing name without 'dtrt' mode"
argument_list|)
expr_stmt|;
name|name
operator|=
name|xsp
operator|->
name|xs_name
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|/* We need to make a local copy; xo_depth_change will free it */
name|char
modifier|*
name|cp
init|=
name|alloca
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
operator|=
name|cp
expr_stmt|;
block|}
else|else
name|name
operator|=
name|XO_FAILURE_NAME
expr_stmt|;
block|}
switch|switch
condition|(
name|xop
operator|->
name|xo_style
condition|)
block|{
case|case
name|XO_STYLE_XML
case|:
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%*s</%s>%s"
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|,
name|name
argument_list|,
name|ppn
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_JSON
case|:
name|pre_nl
operator|=
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_PRETTY
operator|)
condition|?
literal|"\n"
else|:
literal|""
expr_stmt|;
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%s%*s}"
argument_list|,
name|pre_nl
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_stack
index|[
name|xop
operator|->
name|xo_depth
index|]
operator|.
name|xs_flags
operator||=
name|XSF_NOT_FIRST
expr_stmt|;
break|break;
case|case
name|XO_STYLE_HTML
case|:
case|case
name|XO_STYLE_TEXT
case|:
name|xo_depth_change
argument_list|(
name|xop
argument_list|,
name|name
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
name|int
name|xo_close_instance
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|xo_close_instance_h
argument_list|(
name|NULL
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|xo_close_instance_hd
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
return|return
name|xo_close_instance_h
argument_list|(
name|xop
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|xo_close_instance_d
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|xo_close_instance_h
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|xo_set_writer
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|void
modifier|*
name|opaque
parameter_list|,
name|xo_write_func_t
name|write_func
parameter_list|,
name|xo_close_func_t
name|close_func
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|xop
operator|->
name|xo_opaque
operator|=
name|opaque
expr_stmt|;
name|xop
operator|->
name|xo_write
operator|=
name|write_func
expr_stmt|;
name|xop
operator|->
name|xo_close
operator|=
name|close_func
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_set_allocator
parameter_list|(
name|xo_realloc_func_t
name|realloc_func
parameter_list|,
name|xo_free_func_t
name|free_func
parameter_list|)
block|{
name|xo_realloc
operator|=
name|realloc_func
expr_stmt|;
name|xo_free
operator|=
name|free_func
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_flush_h
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
specifier|static
name|char
name|div_close
index|[]
init|=
literal|"</div>"
decl_stmt|;
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|xop
operator|->
name|xo_style
condition|)
block|{
case|case
name|XO_STYLE_HTML
case|:
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_DIV_OPEN
condition|)
block|{
name|xop
operator|->
name|xo_flags
operator|&=
operator|~
name|XOF_DIV_OPEN
expr_stmt|;
name|xo_data_append
argument_list|(
name|xop
argument_list|,
name|div_close
argument_list|,
sizeof|sizeof
argument_list|(
name|div_close
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_PRETTY
condition|)
name|xo_data_append
argument_list|(
name|xop
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|xo_write
argument_list|(
name|xop
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_flush
parameter_list|(
name|void
parameter_list|)
block|{
name|xo_flush_h
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_finish_h
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
init|=
literal|""
decl_stmt|;
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|xop
operator|->
name|xo_style
condition|)
block|{
case|case
name|XO_STYLE_JSON
case|:
if|if
condition|(
operator|!
operator|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_NO_TOP
operator|)
condition|)
block|{
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_TOP_EMITTED
condition|)
name|xop
operator|->
name|xo_flags
operator|&=
operator|~
name|XOF_TOP_EMITTED
expr_stmt|;
comment|/* Turn off before output */
else|else
name|cp
operator|=
literal|"{ "
expr_stmt|;
name|xo_printf
argument_list|(
name|xop
argument_list|,
literal|"%*s%s}\n"
argument_list|,
name|xo_indent
argument_list|(
name|xop
argument_list|)
argument_list|,
literal|""
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|xo_flush_h
argument_list|(
name|xop
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_finish
parameter_list|(
name|void
parameter_list|)
block|{
name|xo_finish_h
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate an error message, such as would be displayed on stderr  */
end_comment

begin_function
name|void
name|xo_error_hv
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|vap
parameter_list|)
block|{
name|xop
operator|=
name|xo_default
argument_list|(
name|xop
argument_list|)
expr_stmt|;
comment|/*      * If the format string doesn't end with a newline, we pop      * one on ourselves.      */
name|int
name|len
init|=
name|strlen
argument_list|(
name|fmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|fmt
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|char
modifier|*
name|newfmt
init|=
name|alloca
argument_list|(
name|len
operator|+
literal|2
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|newfmt
argument_list|,
name|fmt
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|newfmt
index|[
name|len
index|]
operator|=
literal|'\n'
expr_stmt|;
name|newfmt
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fmt
operator|=
name|newfmt
expr_stmt|;
block|}
switch|switch
condition|(
name|xop
operator|->
name|xo_style
condition|)
block|{
case|case
name|XO_STYLE_TEXT
case|:
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_HTML
case|:
name|va_copy
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|xo_buf_append_div
argument_list|(
name|xop
argument_list|,
literal|"error"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|,
name|strlen
argument_list|(
name|fmt
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
operator|->
name|xo_flags
operator|&
name|XOF_DIV_OPEN
condition|)
name|xo_line_close
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|xo_write
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|xop
operator|->
name|xo_vap
argument_list|,
sizeof|sizeof
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|XO_STYLE_XML
case|:
name|va_copy
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|xo_open_container_h
argument_list|(
name|xop
argument_list|,
literal|"error"
argument_list|)
expr_stmt|;
name|xo_format_value
argument_list|(
name|xop
argument_list|,
literal|"message"
argument_list|,
literal|7
argument_list|,
name|fmt
argument_list|,
name|strlen
argument_list|(
name|fmt
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xo_close_container_h
argument_list|(
name|xop
argument_list|,
literal|"error"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|xop
operator|->
name|xo_vap
argument_list|,
sizeof|sizeof
argument_list|(
name|xop
operator|->
name|xo_vap
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|xo_error_h
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_error_hv
argument_list|(
name|xop
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate an error message, such as would be displayed on stderr  */
end_comment

begin_function
name|void
name|xo_error
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|vap
decl_stmt|;
name|va_start
argument_list|(
name|vap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_error_hv
argument_list|(
name|NULL
argument_list|,
name|fmt
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|xo_parse_args
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|static
name|char
name|libxo_opt
index|[]
init|=
literal|"--libxo"
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|save
decl_stmt|;
comment|/* Save our program name for xo_err and friends */
name|xo_program
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|xo_program
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|xo_program
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|save
operator|=
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
operator|==
name|NULL
operator|||
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|libxo_opt
argument_list|,
sizeof|sizeof
argument_list|(
name|libxo_opt
argument_list|)
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|save
operator|!=
name|i
condition|)
name|argv
index|[
name|save
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|save
operator|+=
literal|1
expr_stmt|;
continue|continue;
block|}
name|cp
operator|=
name|argv
index|[
name|i
index|]
operator|+
sizeof|sizeof
argument_list|(
name|libxo_opt
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
block|{
name|cp
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
block|{
name|xo_warnx
argument_list|(
literal|"missing libxo option"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|xo_set_options
argument_list|(
name|NULL
argument_list|,
name|cp
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|xo_set_options
argument_list|(
name|NULL
argument_list|,
name|cp
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'='
condition|)
block|{
if|if
condition|(
name|xo_set_options
argument_list|(
name|NULL
argument_list|,
operator|++
name|cp
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
block|{
name|cp
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"check"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|exit
argument_list|(
name|XO_HAS_LIBXO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xo_warnx
argument_list|(
literal|"unknown libxo option: '%s'"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
name|xo_warnx
argument_list|(
literal|"unknown libxo option: '%s'"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|argv
index|[
name|save
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|save
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|UNIT_TEST
end_ifdef

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|static
name|char
name|base_grocery
index|[]
init|=
literal|"GRO"
decl_stmt|;
specifier|static
name|char
name|base_hardware
index|[]
init|=
literal|"HRD"
decl_stmt|;
struct|struct
name|item
block|{
specifier|const
name|char
modifier|*
name|i_title
decl_stmt|;
name|int
name|i_sold
decl_stmt|;
name|int
name|i_instock
decl_stmt|;
name|int
name|i_onorder
decl_stmt|;
specifier|const
name|char
modifier|*
name|i_sku_base
decl_stmt|;
name|int
name|i_sku_num
decl_stmt|;
block|}
struct|;
name|struct
name|item
name|list
index|[]
init|=
block|{
block|{
literal|"gum&this&that"
block|,
literal|1412
block|,
literal|54
block|,
literal|10
block|,
name|base_grocery
block|,
literal|415
block|}
block|,
block|{
literal|"<rope>"
block|,
literal|85
block|,
literal|4
block|,
literal|2
block|,
name|base_hardware
block|,
literal|212
block|}
block|,
block|{
literal|"ladder"
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|,
name|base_hardware
block|,
literal|517
block|}
block|,
block|{
literal|"\"bolt\""
block|,
literal|4123
block|,
literal|144
block|,
literal|42
block|,
name|base_hardware
block|,
literal|632
block|}
block|,
block|{
literal|"water\\blue"
block|,
literal|17
block|,
literal|14
block|,
literal|2
block|,
name|base_grocery
block|,
literal|2331
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
name|struct
name|item
name|list2
index|[]
init|=
block|{
block|{
literal|"fish"
block|,
literal|1321
block|,
literal|45
block|,
literal|1
block|,
name|base_grocery
block|,
literal|533
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
name|struct
name|item
modifier|*
name|ip
decl_stmt|;
name|xo_info_t
name|info
index|[]
init|=
block|{
block|{
literal|"in-stock"
block|,
literal|"number"
block|,
literal|"Number of items in stock"
block|}
block|,
block|{
literal|"name"
block|,
literal|"string"
block|,
literal|"Name of the item"
block|}
block|,
block|{
literal|"on-order"
block|,
literal|"number"
block|,
literal|"Number of items on order"
block|}
block|,
block|{
literal|"sku"
block|,
literal|"string"
block|,
literal|"Stock Keeping Unit"
block|}
block|,
block|{
literal|"sold"
block|,
literal|"number"
block|,
literal|"Number of items sold"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,     }
decl_stmt|;
name|int
name|info_count
init|=
operator|(
sizeof|sizeof
argument_list|(
name|info
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|info
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
literal|1
decl_stmt|;
name|argc
operator|=
name|xo_parse_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|xo_set_info
argument_list|(
name|NULL
argument_list|,
name|info
argument_list|,
name|info_count
argument_list|)
expr_stmt|;
name|xo_open_container_h
argument_list|(
name|NULL
argument_list|,
literal|"top"
argument_list|)
expr_stmt|;
name|xo_open_container
argument_list|(
literal|"data"
argument_list|)
expr_stmt|;
name|xo_open_list
argument_list|(
literal|"item"
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{T:Item/%-15s}{T:Total Sold/%12s}{T:In Stock/%12s}"
literal|"{T:On Order/%12s}{T:SKU/%5s}\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|list
init|;
name|ip
operator|->
name|i_title
condition|;
name|ip
operator|++
control|)
block|{
name|xo_open_instance
argument_list|(
literal|"item"
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{k:name/%-15s/%s}{n:sold/%12u/%u}{:in-stock/%12u/%u}"
literal|"{:on-order/%12u/%u} {q:sku/%5s-000-%u/%s-000-%u}\n"
argument_list|,
name|ip
operator|->
name|i_title
argument_list|,
name|ip
operator|->
name|i_sold
argument_list|,
name|ip
operator|->
name|i_instock
argument_list|,
name|ip
operator|->
name|i_onorder
argument_list|,
name|ip
operator|->
name|i_sku_base
argument_list|,
name|ip
operator|->
name|i_sku_num
argument_list|)
expr_stmt|;
name|xo_close_instance
argument_list|(
literal|"item"
argument_list|)
expr_stmt|;
block|}
name|xo_close_list
argument_list|(
literal|"item"
argument_list|)
expr_stmt|;
name|xo_close_container
argument_list|(
literal|"data"
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
name|xo_open_container
argument_list|(
literal|"data"
argument_list|)
expr_stmt|;
name|xo_open_list
argument_list|(
literal|"item"
argument_list|)
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|list
init|;
name|ip
operator|->
name|i_title
condition|;
name|ip
operator|++
control|)
block|{
name|xo_open_instance
argument_list|(
literal|"item"
argument_list|)
expr_stmt|;
name|xo_attr
argument_list|(
literal|"fancy"
argument_list|,
literal|"%s%d"
argument_list|,
literal|"item"
argument_list|,
name|ip
operator|-
name|list
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{L:Item} '{k:name/%s}':\n"
argument_list|,
name|ip
operator|->
name|i_title
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{P:   }{L:Total sold}: {n:sold/%u%s}{e:percent/%u}\n"
argument_list|,
name|ip
operator|->
name|i_sold
argument_list|,
name|ip
operator|->
name|i_sold
condition|?
literal|".0"
else|:
literal|""
argument_list|,
literal|44
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{P:   }{Lcw:In stock}{:in-stock/%u}\n"
argument_list|,
name|ip
operator|->
name|i_instock
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{P:   }{Lcw:On order}{:on-order/%u}\n"
argument_list|,
name|ip
operator|->
name|i_onorder
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{P:   }{L:SKU}: {q:sku/%s-000-%u}\n"
argument_list|,
name|ip
operator|->
name|i_sku_base
argument_list|,
name|ip
operator|->
name|i_sku_num
argument_list|)
expr_stmt|;
name|xo_close_instance
argument_list|(
literal|"item"
argument_list|)
expr_stmt|;
block|}
name|xo_close_list
argument_list|(
literal|"item"
argument_list|)
expr_stmt|;
name|xo_close_container
argument_list|(
literal|"data"
argument_list|)
expr_stmt|;
name|xo_open_container
argument_list|(
literal|"data"
argument_list|)
expr_stmt|;
name|xo_open_list
argument_list|(
literal|"item"
argument_list|)
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|list2
init|;
name|ip
operator|->
name|i_title
condition|;
name|ip
operator|++
control|)
block|{
name|xo_open_instance
argument_list|(
literal|"item"
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{L:Item} '{k:name/%s}':\n"
argument_list|,
name|ip
operator|->
name|i_title
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{P:   }{L:Total sold}: {n:sold/%u%s}\n"
argument_list|,
name|ip
operator|->
name|i_sold
argument_list|,
name|ip
operator|->
name|i_sold
condition|?
literal|".0"
else|:
literal|""
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{P:   }{Lcw:In stock}{:in-stock/%u}\n"
argument_list|,
name|ip
operator|->
name|i_instock
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{P:   }{Lcw:On order}{:on-order/%u}\n"
argument_list|,
name|ip
operator|->
name|i_onorder
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{P:   }{L:SKU}: {q:sku/%s-000-%u}\n"
argument_list|,
name|ip
operator|->
name|i_sku_base
argument_list|,
name|ip
operator|->
name|i_sku_num
argument_list|)
expr_stmt|;
name|xo_open_list
argument_list|(
literal|"month"
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|months
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
name|NULL
block|}
decl_stmt|;
name|int
name|discounts
index|[]
init|=
block|{
literal|10
block|,
literal|20
block|,
literal|25
block|,
literal|0
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|months
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|xo_open_instance
argument_list|(
literal|"month"
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{P:       }"
literal|"{Lwc:Month}{k:month}, {Lwc:Special}{:discount/%d}\n"
argument_list|,
name|months
index|[
name|i
index|]
argument_list|,
name|discounts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xo_close_instance
argument_list|(
literal|"month"
argument_list|)
expr_stmt|;
block|}
name|xo_close_list
argument_list|(
literal|"month"
argument_list|)
expr_stmt|;
name|xo_close_instance
argument_list|(
literal|"item"
argument_list|)
expr_stmt|;
block|}
name|xo_close_list
argument_list|(
literal|"item"
argument_list|)
expr_stmt|;
name|xo_close_container
argument_list|(
literal|"data"
argument_list|)
expr_stmt|;
name|xo_close_container_h
argument_list|(
name|NULL
argument_list|,
literal|"top"
argument_list|)
expr_stmt|;
name|xo_finish
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNIT_TEST */
end_comment

end_unit

