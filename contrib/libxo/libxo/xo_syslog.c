begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2015, Juniper Networks, Inc.  * All rights reserved.  * This SOFTWARE is licensed under the LICENSE provided in the  * ../Copyright file. By downloading, installing, copying, or otherwise  * using the SOFTWARE, you agree to be bound by the terms of that  * LICENSE.  * Phil Shafer, June 2015  */
end_comment

begin_comment
comment|/*  * Portions of this file are:  *   Copyright (c) 1983, 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|"xo_config.h"
end_include

begin_include
include|#
directive|include
file|"xo.h"
end_include

begin_include
include|#
directive|include
file|"xo_encoder.h"
end_include

begin_comment
comment|/* For xo_realloc */
end_comment

begin_include
include|#
directive|include
file|"xo_buf.h"
end_include

begin_comment
comment|/*  * SYSLOG (RFC 5424) requires an enterprise identifier.  This turns  * out to be a fickle little issue.  For a single-vendor box, the  * system should have a single EID that all software can use.  When  * VendorX turns FreeBSD into a product, all software (kernel and  * utilities) should report VendorX's EID.  But when software is  * installed on top of an external operating system, the application  * should report it's own EID, distinct from the base OS.  *  * To make this happen, the kernel should support a sysctl to assign a  * custom enterprise-id ("kern.syslog.enterprise_id").  libxo then  * allows an application to set a custom EID to override that system  * wide value, if needed.  *  * We try to set the stock IANA assigned Enterprise ID value for the  * vendors we know about (FreeBSD, macosx), but fallback to the  * "example" EID defined by IANA.  See:  * https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers  */
end_comment

begin_define
define|#
directive|define
name|XO_SYSLOG_ENTERPRISE_ID
value|"kern.syslog.enterprise_id"
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_define
define|#
directive|define
name|XO_DEFAULT_EID
value|2238
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__macosx__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|XO_DEFAULT_EID
value|63
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|XO_DEFAULT_EID
value|32473
end_define

begin_comment
comment|/* Fallback to the "example" number */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HOST_NAME_MAX
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|_SC_HOST_NAME_MAX
end_ifdef

begin_define
define|#
directive|define
name|HOST_NAME_MAX
value|_SC_HOST_NAME_MAX
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|HOST_NAME_MAX
value|255
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _SC_HOST_NAME_MAX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HOST_NAME_MAX */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|UNUSED
end_ifndef

begin_define
define|#
directive|define
name|UNUSED
value|__attribute__ ((__unused__))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNUSED */
end_comment

begin_decl_stmt
specifier|static
name|int
name|xo_logfile
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fd for log */
end_comment

begin_decl_stmt
specifier|static
name|int
name|xo_status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* connection xo_status */
end_comment

begin_decl_stmt
specifier|static
name|int
name|xo_opened
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* have done openlog() */
end_comment

begin_decl_stmt
specifier|static
name|int
name|xo_logstat
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* xo_status bits, set by openlog() */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|xo_logtag
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* string to tag the entry with */
end_comment

begin_decl_stmt
specifier|static
name|int
name|xo_logfacility
init|=
name|LOG_USER
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default facility code */
end_comment

begin_decl_stmt
specifier|static
name|int
name|xo_logmask
init|=
literal|0xff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mask of priorities to be logged */
end_comment

begin_decl_stmt
specifier|static
name|pthread_mutex_t
name|xo_syslog_mutex
name|UNUSED
init|=
name|PTHREAD_MUTEX_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xo_unit_test
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fake data for unit test */
end_comment

begin_define
define|#
directive|define
name|REAL_VOID
parameter_list|(
name|_x
parameter_list|)
define|\
value|do { int really_ignored = _x; if (really_ignored) { }} while (0)
end_define

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_DECL___ISTHREADED
argument_list|)
operator|||
operator|!
name|HAVE_DECL___ISTHREADED
end_if

begin_define
define|#
directive|define
name|__isthreaded
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|THREAD_LOCK
parameter_list|()
define|\
value|do {								\         if (__isthreaded) pthread_mutex_lock(&xo_syslog_mutex);		\     } while(0)
end_define

begin_define
define|#
directive|define
name|THREAD_UNLOCK
parameter_list|()
define|\
value|do {								\         if (__isthreaded) pthread_mutex_unlock(&xo_syslog_mutex);       \     } while(0)
end_define

begin_function_decl
specifier|static
name|void
name|xo_disconnect_log
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* disconnect from syslogd */
end_comment

begin_function_decl
specifier|static
name|void
name|xo_connect_log
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* (re)connect to syslogd */
end_comment

begin_function_decl
specifier|static
name|void
name|xo_open_log_unlocked
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_enum
enum|enum
block|{
name|NOCONN
init|=
literal|0
block|,
name|CONNDEF
block|,
name|CONNPRIV
block|, }
enum|;
end_enum

begin_decl_stmt
specifier|static
name|xo_syslog_open_t
name|xo_syslog_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xo_syslog_send_t
name|xo_syslog_send
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xo_syslog_close_t
name|xo_syslog_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|xo_syslog_enterprise_id
index|[
literal|12
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Record an enterprise ID, which functions as a namespace for syslog  * messages.  The value is pre-formatted into a string.  This allows  * applications to customize their syslog message set, when needed.   */
end_comment

begin_function
name|void
name|xo_set_syslog_enterprise_id
parameter_list|(
name|unsigned
name|short
name|eid
parameter_list|)
block|{
name|snprintf
argument_list|(
name|xo_syslog_enterprise_id
argument_list|,
sizeof|sizeof
argument_list|(
name|xo_syslog_enterprise_id
argument_list|)
argument_list|,
literal|"%u"
argument_list|,
name|eid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle the work of transmitting the syslog message  */
end_comment

begin_function
specifier|static
name|void
name|xo_send_syslog
parameter_list|(
name|char
modifier|*
name|full_msg
parameter_list|,
name|char
modifier|*
name|v0_hdr
parameter_list|,
name|char
modifier|*
name|text_only
parameter_list|)
block|{
if|if
condition|(
name|xo_syslog_send
condition|)
block|{
name|xo_syslog_send
argument_list|(
name|full_msg
argument_list|,
name|v0_hdr
argument_list|,
name|text_only
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|fd
decl_stmt|;
name|int
name|full_len
init|=
name|strlen
argument_list|(
name|full_msg
argument_list|)
decl_stmt|;
comment|/* Output to stderr if requested, then we've been passed a v0 header */
if|if
condition|(
name|v0_hdr
condition|)
block|{
name|struct
name|iovec
name|iov
index|[
literal|3
index|]
decl_stmt|;
name|struct
name|iovec
modifier|*
name|v
init|=
name|iov
decl_stmt|;
name|char
name|newline
index|[]
init|=
literal|"\n"
decl_stmt|;
name|v
operator|->
name|iov_base
operator|=
name|v0_hdr
expr_stmt|;
name|v
operator|->
name|iov_len
operator|=
name|strlen
argument_list|(
name|v0_hdr
argument_list|)
expr_stmt|;
name|v
operator|+=
literal|1
expr_stmt|;
name|v
operator|->
name|iov_base
operator|=
name|text_only
expr_stmt|;
name|v
operator|->
name|iov_len
operator|=
name|strlen
argument_list|(
name|text_only
argument_list|)
expr_stmt|;
name|v
operator|+=
literal|1
expr_stmt|;
name|v
operator|->
name|iov_base
operator|=
name|newline
expr_stmt|;
name|v
operator|->
name|iov_len
operator|=
literal|1
expr_stmt|;
name|v
operator|+=
literal|1
expr_stmt|;
name|REAL_VOID
argument_list|(
name|writev
argument_list|(
name|STDERR_FILENO
argument_list|,
name|iov
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Get connected, output the message to the local logger. */
if|if
condition|(
operator|!
name|xo_opened
condition|)
name|xo_open_log_unlocked
argument_list|(
name|xo_logtag
argument_list|,
name|xo_logstat
operator||
name|LOG_NDELAY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xo_connect_log
argument_list|()
expr_stmt|;
comment|/*      * If the send() fails, there are two likely scenarios:       *  1) syslogd was restarted      *  2) /var/run/log is out of socket buffer space, which      *     in most cases means local DoS.      * If the error does not indicate a full buffer, we address      * case #1 by attempting to reconnect to /var/run/log[priv]      * and resending the message once.      *      * If we are working with a privileged socket, the retry      * attempts end there, because we don't want to freeze a      * critical application like su(1) or sshd(8).      *      * Otherwise, we address case #2 by repeatedly retrying the      * send() to give syslogd a chance to empty its socket buffer.      */
if|if
condition|(
name|send
argument_list|(
name|xo_logfile
argument_list|,
name|full_msg
argument_list|,
name|full_len
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOBUFS
condition|)
block|{
comment|/*              * Scenario 1: syslogd was restarted              * reconnect and resend once              */
name|xo_disconnect_log
argument_list|()
expr_stmt|;
name|xo_connect_log
argument_list|()
expr_stmt|;
if|if
condition|(
name|send
argument_list|(
name|xo_logfile
argument_list|,
name|full_msg
argument_list|,
name|full_len
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
block|{
return|return;
block|}
comment|/*              * if the resend failed, fall through to              * possible scenario 2              */
block|}
while|while
condition|(
name|errno
operator|==
name|ENOBUFS
condition|)
block|{
comment|/*              * Scenario 2: out of socket buffer space              * possible DoS, fail fast on a privileged              * socket              */
if|if
condition|(
name|xo_status
operator|==
name|CONNPRIV
condition|)
break|break;
name|usleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|send
argument_list|(
name|xo_logfile
argument_list|,
name|full_msg
argument_list|,
name|full_len
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
block|{
return|return;
block|}
block|}
block|}
else|else
block|{
return|return;
block|}
comment|/*      * Output the message to the console; try not to block      * as a blocking console should not stop other processes.      * Make sure the error reported is the one from the syslogd failure.      */
name|int
name|flags
init|=
name|O_WRONLY
operator||
name|O_NONBLOCK
decl_stmt|;
ifdef|#
directive|ifdef
name|O_CLOEXEC
name|flags
operator||=
name|O_CLOEXEC
expr_stmt|;
endif|#
directive|endif
comment|/* O_CLOEXEC */
if|if
condition|(
name|xo_logstat
operator|&
name|LOG_CONS
operator|&&
operator|(
name|fd
operator|=
name|open
argument_list|(
name|_PATH_CONSOLE
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|struct
name|iovec
name|iov
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|iovec
modifier|*
name|v
init|=
name|iov
decl_stmt|;
name|char
name|crnl
index|[]
init|=
literal|"\r\n"
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|full_msg
argument_list|,
literal|'>'
argument_list|)
operator|+
literal|1
expr_stmt|;
name|v
operator|->
name|iov_base
operator|=
name|p
expr_stmt|;
name|v
operator|->
name|iov_len
operator|=
name|full_len
operator|-
operator|(
name|p
operator|-
name|full_msg
operator|)
expr_stmt|;
operator|++
name|v
expr_stmt|;
name|v
operator|->
name|iov_base
operator|=
name|crnl
expr_stmt|;
name|v
operator|->
name|iov_len
operator|=
literal|2
expr_stmt|;
name|REAL_VOID
argument_list|(
name|writev
argument_list|(
name|fd
argument_list|,
name|iov
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Should be called with mutex acquired */
end_comment

begin_function
specifier|static
name|void
name|xo_disconnect_log
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|xo_syslog_close
condition|)
block|{
name|xo_syslog_close
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/*      * If the user closed the FD and opened another in the same slot,      * that's their problem.  They should close it before calling on      * system services.      */
if|if
condition|(
name|xo_logfile
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|xo_logfile
argument_list|)
expr_stmt|;
name|xo_logfile
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|xo_status
operator|=
name|NOCONN
expr_stmt|;
comment|/* retry connect */
block|}
end_function

begin_comment
comment|/* Should be called with mutex acquired */
end_comment

begin_function
specifier|static
name|void
name|xo_connect_log
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|xo_syslog_open
condition|)
block|{
name|xo_syslog_open
argument_list|()
expr_stmt|;
return|return;
block|}
name|struct
name|sockaddr_un
name|saddr
decl_stmt|;
comment|/* AF_UNIX address of local logger */
if|if
condition|(
name|xo_logfile
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|flags
init|=
name|SOCK_DGRAM
decl_stmt|;
ifdef|#
directive|ifdef
name|SOCK_CLOEXEC
name|flags
operator||=
name|SOCK_CLOEXEC
expr_stmt|;
endif|#
directive|endif
comment|/* SOCK_CLOEXEC */
if|if
condition|(
operator|(
name|xo_logfile
operator|=
name|socket
argument_list|(
name|AF_UNIX
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return;
block|}
if|if
condition|(
name|xo_logfile
operator|!=
operator|-
literal|1
operator|&&
name|xo_status
operator|==
name|NOCONN
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SUN_LEN
name|saddr
operator|.
name|sun_len
operator|=
sizeof|sizeof
argument_list|(
name|saddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SUN_LEN */
name|saddr
operator|.
name|sun_family
operator|=
name|AF_UNIX
expr_stmt|;
comment|/*          * First try privileged socket. If no success,          * then try default socket.          */
ifdef|#
directive|ifdef
name|_PATH_LOG_PRIV
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|saddr
operator|.
name|sun_path
argument_list|,
name|_PATH_LOG_PRIV
argument_list|,
sizeof|sizeof
name|saddr
operator|.
name|sun_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|xo_logfile
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr
argument_list|,
sizeof|sizeof
argument_list|(
name|saddr
argument_list|)
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|xo_status
operator|=
name|CONNPRIV
expr_stmt|;
endif|#
directive|endif
comment|/* _PATH_LOG_PRIV */
ifdef|#
directive|ifdef
name|_PATH_LOG
if|if
condition|(
name|xo_status
operator|==
name|NOCONN
condition|)
block|{
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|saddr
operator|.
name|sun_path
argument_list|,
name|_PATH_LOG
argument_list|,
sizeof|sizeof
name|saddr
operator|.
name|sun_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|xo_logfile
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr
argument_list|,
sizeof|sizeof
argument_list|(
name|saddr
argument_list|)
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|xo_status
operator|=
name|CONNDEF
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _PATH_LOG */
ifdef|#
directive|ifdef
name|_PATH_OLDLOG
if|if
condition|(
name|xo_status
operator|==
name|NOCONN
condition|)
block|{
comment|/*              * Try the old "/dev/log" path, for backward              * compatibility.              */
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|saddr
operator|.
name|sun_path
argument_list|,
name|_PATH_OLDLOG
argument_list|,
sizeof|sizeof
name|saddr
operator|.
name|sun_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|xo_logfile
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr
argument_list|,
sizeof|sizeof
argument_list|(
name|saddr
argument_list|)
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|xo_status
operator|=
name|CONNDEF
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _PATH_OLDLOG */
if|if
condition|(
name|xo_status
operator|==
name|NOCONN
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|xo_logfile
argument_list|)
expr_stmt|;
name|xo_logfile
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xo_open_log_unlocked
parameter_list|(
specifier|const
name|char
modifier|*
name|ident
parameter_list|,
name|int
name|logstat
parameter_list|,
name|int
name|logfac
parameter_list|)
block|{
if|if
condition|(
name|ident
operator|!=
name|NULL
condition|)
name|xo_logtag
operator|=
name|ident
expr_stmt|;
name|xo_logstat
operator|=
name|logstat
expr_stmt|;
if|if
condition|(
name|logfac
operator|!=
literal|0
operator|&&
operator|(
name|logfac
operator|&
operator|~
name|LOG_FACMASK
operator|)
operator|==
literal|0
condition|)
name|xo_logfacility
operator|=
name|logfac
expr_stmt|;
if|if
condition|(
name|xo_logstat
operator|&
name|LOG_NDELAY
condition|)
comment|/* open immediately */
name|xo_connect_log
argument_list|()
expr_stmt|;
name|xo_opened
operator|=
literal|1
expr_stmt|;
comment|/* ident and facility has been set */
block|}
end_function

begin_function
name|void
name|xo_open_log
parameter_list|(
specifier|const
name|char
modifier|*
name|ident
parameter_list|,
name|int
name|logstat
parameter_list|,
name|int
name|logfac
parameter_list|)
block|{
name|THREAD_LOCK
argument_list|()
expr_stmt|;
name|xo_open_log_unlocked
argument_list|(
name|ident
argument_list|,
name|logstat
argument_list|,
name|logfac
argument_list|)
expr_stmt|;
name|THREAD_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_close_log
parameter_list|(
name|void
parameter_list|)
block|{
name|THREAD_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|xo_logfile
operator|!=
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|xo_logfile
argument_list|)
expr_stmt|;
name|xo_logfile
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|xo_logtag
operator|=
name|NULL
expr_stmt|;
name|xo_status
operator|=
name|NOCONN
expr_stmt|;
name|THREAD_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* xo_set_logmask -- set the log mask level */
end_comment

begin_function
name|int
name|xo_set_logmask
parameter_list|(
name|int
name|pmask
parameter_list|)
block|{
name|int
name|omask
decl_stmt|;
name|THREAD_LOCK
argument_list|()
expr_stmt|;
name|omask
operator|=
name|xo_logmask
expr_stmt|;
if|if
condition|(
name|pmask
operator|!=
literal|0
condition|)
name|xo_logmask
operator|=
name|pmask
expr_stmt|;
name|THREAD_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|omask
operator|)
return|;
block|}
end_function

begin_function
name|void
name|xo_set_syslog_handler
parameter_list|(
name|xo_syslog_open_t
name|open_func
parameter_list|,
name|xo_syslog_send_t
name|send_func
parameter_list|,
name|xo_syslog_close_t
name|close_func
parameter_list|)
block|{
name|xo_syslog_open
operator|=
name|open_func
expr_stmt|;
name|xo_syslog_send
operator|=
name|send_func
expr_stmt|;
name|xo_syslog_close
operator|=
name|close_func
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|xo_snprintf
parameter_list|(
name|char
modifier|*
name|out
parameter_list|,
name|ssize_t
name|outsize
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|ssize_t
name|status
decl_stmt|;
name|ssize_t
name|retval
init|=
literal|0
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|out
operator|&&
name|outsize
condition|)
block|{
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|status
operator|=
name|vsnprintf
argument_list|(
name|out
argument_list|,
name|outsize
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
comment|/* this should never happen, */
operator|*
name|out
operator|=
literal|0
expr_stmt|;
comment|/* handle it in the safest way possible if it does */
name|retval
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|status
expr_stmt|;
name|retval
operator|=
name|retval
operator|>
name|outsize
condition|?
name|outsize
else|:
name|retval
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|xo_ssize_t
name|xo_syslog_handle_write
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|)
block|{
name|xo_buffer_t
modifier|*
name|xbp
init|=
name|opaque
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|int
name|left
init|=
name|xo_buf_left
argument_list|(
name|xbp
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|left
operator|-
literal|1
condition|)
name|len
operator|=
name|left
operator|-
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|xbp
operator|->
name|xb_curp
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|xbp
operator|->
name|xb_curp
operator|+=
name|len
expr_stmt|;
operator|*
name|xbp
operator|->
name|xb_curp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_syslog_handle_close
parameter_list|(
name|void
modifier|*
name|opaque
name|UNUSED
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|int
name|xo_syslog_handle_flush
parameter_list|(
name|void
modifier|*
name|opaque
name|UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|xo_set_unit_test_mode
parameter_list|(
name|int
name|value
parameter_list|)
block|{
name|xo_unit_test
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_vsyslog
parameter_list|(
name|int
name|pri
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|vap
parameter_list|)
block|{
name|int
name|saved_errno
init|=
name|errno
decl_stmt|;
name|char
name|tbuf
index|[
literal|2048
index|]
decl_stmt|;
name|char
modifier|*
name|tp
init|=
name|NULL
decl_stmt|,
modifier|*
name|ep
init|=
name|NULL
decl_stmt|;
name|unsigned
name|start_of_msg
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|v0_hdr
init|=
name|NULL
decl_stmt|;
name|xo_buffer_t
name|xb
decl_stmt|;
specifier|static
name|pid_t
name|my_pid
decl_stmt|;
name|unsigned
name|log_offset
decl_stmt|;
if|if
condition|(
name|my_pid
operator|==
literal|0
condition|)
name|my_pid
operator|=
name|xo_unit_test
condition|?
literal|222
else|:
name|getpid
argument_list|()
expr_stmt|;
comment|/* Check for invalid bits */
if|if
condition|(
name|pri
operator|&
operator|~
operator|(
name|LOG_PRIMASK
operator||
name|LOG_FACMASK
operator|)
condition|)
block|{
name|xo_syslog
argument_list|(
name|LOG_ERR
operator||
name|LOG_CONS
operator||
name|LOG_PERROR
operator||
name|LOG_PID
argument_list|,
literal|"syslog-unknown-priority"
argument_list|,
literal|"syslog: unknown facility/priority: %#x"
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|pri
operator|&=
name|LOG_PRIMASK
operator||
name|LOG_FACMASK
expr_stmt|;
block|}
name|THREAD_LOCK
argument_list|()
expr_stmt|;
comment|/* Check priority against setlogmask values. */
if|if
condition|(
operator|!
operator|(
name|LOG_MASK
argument_list|(
name|LOG_PRI
argument_list|(
name|pri
argument_list|)
argument_list|)
operator|&
name|xo_logmask
operator|)
condition|)
block|{
name|THREAD_UNLOCK
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Set default facility if none specified. */
if|if
condition|(
operator|(
name|pri
operator|&
name|LOG_FACMASK
operator|)
operator|==
literal|0
condition|)
name|pri
operator||=
name|xo_logfacility
expr_stmt|;
comment|/* Create the primary stdio hook */
name|xb
operator|.
name|xb_bufp
operator|=
name|tbuf
expr_stmt|;
name|xb
operator|.
name|xb_curp
operator|=
name|tbuf
expr_stmt|;
name|xb
operator|.
name|xb_size
operator|=
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
name|xo_handle_t
modifier|*
name|xop
init|=
name|xo_create
argument_list|(
name|XO_STYLE_SDPARAMS
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|xop
operator|==
name|NULL
condition|)
block|{
name|THREAD_UNLOCK
argument_list|()
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|HAVE_GETPROGNAME
if|if
condition|(
name|xo_logtag
operator|==
name|NULL
condition|)
name|xo_logtag
operator|=
name|getprogname
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_GETPROGNAME */
name|xo_set_writer
argument_list|(
name|xop
argument_list|,
operator|&
name|xb
argument_list|,
name|xo_syslog_handle_write
argument_list|,
name|xo_syslog_handle_close
argument_list|,
name|xo_syslog_handle_flush
argument_list|)
expr_stmt|;
comment|/* Build the message; start by getting the time */
name|struct
name|tm
name|tm
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
comment|/* Unit test hack: fake a fixed time */
if|if
condition|(
name|xo_unit_test
condition|)
block|{
name|tv
operator|.
name|tv_sec
operator|=
literal|1435085229
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|123456
expr_stmt|;
block|}
else|else
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|localtime_r
argument_list|(
operator|&
name|tv
operator|.
name|tv_sec
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|xo_logstat
operator|&
name|LOG_PERROR
condition|)
block|{
comment|/* 	 * For backwards compatibility, we need to make the old-style 	 * message.  This message can be emitted to the console/tty. 	 */
name|v0_hdr
operator|=
name|alloca
argument_list|(
literal|2048
argument_list|)
expr_stmt|;
name|tp
operator|=
name|v0_hdr
expr_stmt|;
name|ep
operator|=
name|v0_hdr
operator|+
literal|2048
expr_stmt|;
if|if
condition|(
name|xo_logtag
operator|!=
name|NULL
condition|)
name|tp
operator|+=
name|xo_snprintf
argument_list|(
name|tp
argument_list|,
name|ep
operator|-
name|tp
argument_list|,
literal|"%s"
argument_list|,
name|xo_logtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|xo_logstat
operator|&
name|LOG_PID
condition|)
name|tp
operator|+=
name|xo_snprintf
argument_list|(
name|tp
argument_list|,
name|ep
operator|-
name|tp
argument_list|,
literal|"[%d]"
argument_list|,
name|my_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|xo_logtag
condition|)
name|tp
operator|+=
name|xo_snprintf
argument_list|(
name|tp
argument_list|,
name|ep
operator|-
name|tp
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
block|}
name|log_offset
operator|=
name|xb
operator|.
name|xb_curp
operator|-
name|xb
operator|.
name|xb_bufp
expr_stmt|;
comment|/* Add PRI, PRIVAL, and VERSION */
name|xb
operator|.
name|xb_curp
operator|+=
name|xo_snprintf
argument_list|(
name|xb
operator|.
name|xb_curp
argument_list|,
name|xo_buf_left
argument_list|(
operator|&
name|xb
argument_list|)
argument_list|,
literal|"<%d>1 "
argument_list|,
name|pri
argument_list|)
expr_stmt|;
comment|/* Add TIMESTAMP with milliseconds and TZOFFSET */
name|xb
operator|.
name|xb_curp
operator|+=
name|strftime
argument_list|(
name|xb
operator|.
name|xb_curp
argument_list|,
name|xo_buf_left
argument_list|(
operator|&
name|xb
argument_list|)
argument_list|,
literal|"%FT%T"
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
name|xb
operator|.
name|xb_curp
operator|+=
name|xo_snprintf
argument_list|(
name|xb
operator|.
name|xb_curp
argument_list|,
name|xo_buf_left
argument_list|(
operator|&
name|xb
argument_list|)
argument_list|,
literal|".%03.3u"
argument_list|,
name|tv
operator|.
name|tv_usec
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|xb
operator|.
name|xb_curp
operator|+=
name|strftime
argument_list|(
name|xb
operator|.
name|xb_curp
argument_list|,
name|xo_buf_left
argument_list|(
operator|&
name|xb
argument_list|)
argument_list|,
literal|"%z "
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
comment|/*      * Add HOSTNAME; we rely on gethostname and don't fluff with      * ip addresses.  Might need to revisit.....      */
name|char
name|hostname
index|[
name|HOST_NAME_MAX
index|]
decl_stmt|;
name|hostname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|xo_unit_test
condition|)
name|strcpy
argument_list|(
name|hostname
argument_list|,
literal|"worker-host"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
name|xb
operator|.
name|xb_curp
operator|+=
name|xo_snprintf
argument_list|(
name|xb
operator|.
name|xb_curp
argument_list|,
name|xo_buf_left
argument_list|(
operator|&
name|xb
argument_list|)
argument_list|,
literal|"%s "
argument_list|,
name|hostname
index|[
literal|0
index|]
condition|?
name|hostname
else|:
literal|"-"
argument_list|)
expr_stmt|;
comment|/* Add APP-NAME */
name|xb
operator|.
name|xb_curp
operator|+=
name|xo_snprintf
argument_list|(
name|xb
operator|.
name|xb_curp
argument_list|,
name|xo_buf_left
argument_list|(
operator|&
name|xb
argument_list|)
argument_list|,
literal|"%s "
argument_list|,
name|xo_logtag
condition|?
else|:
literal|"-"
argument_list|)
expr_stmt|;
comment|/* Add PROCID */
name|xb
operator|.
name|xb_curp
operator|+=
name|xo_snprintf
argument_list|(
name|xb
operator|.
name|xb_curp
argument_list|,
name|xo_buf_left
argument_list|(
operator|&
name|xb
argument_list|)
argument_list|,
literal|"%d "
argument_list|,
name|my_pid
argument_list|)
expr_stmt|;
comment|/*      * Add MSGID.  The user should provide us with a name, which we      * prefix with the current enterprise ID, as learned from the kernel.      * If the kernel won't tell us, we use the stock/builtin number.      */
name|char
modifier|*
name|buf
name|UNUSED
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|eid
init|=
name|xo_syslog_enterprise_id
decl_stmt|;
specifier|const
name|char
modifier|*
name|at_sign
init|=
literal|"@"
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|name
operator|=
literal|"-"
expr_stmt|;
name|eid
operator|=
name|at_sign
operator|=
literal|""
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'@'
condition|)
block|{
comment|/* Our convention is to prefix IANA-defined names with an "@" */
name|name
operator|+=
literal|1
expr_stmt|;
name|eid
operator|=
name|at_sign
operator|=
literal|""
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eid
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SYSCTLBYNAME
comment|/* 	 * See if the kernel knows the sysctl for the enterprise ID 	 */
name|size_t
name|size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sysctlbyname
argument_list|(
name|XO_SYSLOG_ENTERPRISE_ID
argument_list|,
name|NULL
argument_list|,
operator|&
name|size
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|&&
name|size
operator|>
literal|0
condition|)
block|{
name|buf
operator|=
name|alloca
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctlbyname
argument_list|(
name|XO_SYSLOG_ENTERPRISE_ID
argument_list|,
name|buf
argument_list|,
operator|&
name|size
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|&&
name|size
operator|>
literal|0
condition|)
name|eid
operator|=
name|buf
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_SYSCTLBYNAME */
if|if
condition|(
name|eid
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Fallback to our base default */
name|xo_set_syslog_enterprise_id
argument_list|(
name|XO_DEFAULT_EID
argument_list|)
expr_stmt|;
name|eid
operator|=
name|xo_syslog_enterprise_id
expr_stmt|;
block|}
block|}
name|xb
operator|.
name|xb_curp
operator|+=
name|xo_snprintf
argument_list|(
name|xb
operator|.
name|xb_curp
argument_list|,
name|xo_buf_left
argument_list|(
operator|&
name|xb
argument_list|)
argument_list|,
literal|"%s [%s%s%s "
argument_list|,
name|name
argument_list|,
name|name
argument_list|,
name|at_sign
argument_list|,
name|eid
argument_list|)
expr_stmt|;
comment|/*      * Now for the real content.  We make two distinct passes thru the      * xo_emit engine, first for the SD-PARAMS and then for the text      * message.      */
name|va_list
name|ap
decl_stmt|;
name|va_copy
argument_list|(
name|ap
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|errno
operator|=
name|saved_errno
expr_stmt|;
comment|/* Restore saved error value */
name|xo_emit_hv
argument_list|(
name|xop
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|xo_flush_h
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
comment|/* Trim trailing space */
if|if
condition|(
name|xb
operator|.
name|xb_curp
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|xb
operator|.
name|xb_curp
operator|-=
literal|1
expr_stmt|;
comment|/* Close the structured data (SD-ELEMENT) */
name|xb
operator|.
name|xb_curp
operator|+=
name|xo_snprintf
argument_list|(
name|xb
operator|.
name|xb_curp
argument_list|,
name|xo_buf_left
argument_list|(
operator|&
name|xb
argument_list|)
argument_list|,
literal|"] "
argument_list|)
expr_stmt|;
comment|/*      * Since our MSG is known to be UTF-8, we MUST prefix it with      * that most-annoying-of-all-UTF-8 features, the BOM (0xEF.BB.BF).      */
name|xb
operator|.
name|xb_curp
operator|+=
name|xo_snprintf
argument_list|(
name|xb
operator|.
name|xb_curp
argument_list|,
name|xo_buf_left
argument_list|(
operator|&
name|xb
argument_list|)
argument_list|,
literal|"%c%c%c"
argument_list|,
literal|0xEF
argument_list|,
literal|0xBB
argument_list|,
literal|0xBF
argument_list|)
expr_stmt|;
comment|/* Save the start of the message */
if|if
condition|(
name|xo_logstat
operator|&
name|LOG_PERROR
condition|)
name|start_of_msg
operator|=
name|xb
operator|.
name|xb_curp
operator|-
name|xb
operator|.
name|xb_bufp
expr_stmt|;
name|xo_set_style
argument_list|(
name|xop
argument_list|,
name|XO_STYLE_TEXT
argument_list|)
expr_stmt|;
name|xo_set_flags
argument_list|(
name|xop
argument_list|,
name|XOF_UTF8
argument_list|)
expr_stmt|;
name|errno
operator|=
name|saved_errno
expr_stmt|;
comment|/* Restore saved error value */
name|xo_emit_hv
argument_list|(
name|xop
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|xo_flush_h
argument_list|(
name|xop
argument_list|)
expr_stmt|;
comment|/* Remove a trailing newline */
if|if
condition|(
name|xb
operator|.
name|xb_curp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
operator|*
operator|--
name|xb
operator|.
name|xb_curp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|xo_get_flags
argument_list|(
name|xop
argument_list|)
operator|&
name|XOF_LOG_SYSLOG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"xo: syslog: %s\n"
argument_list|,
name|xb
operator|.
name|xb_bufp
operator|+
name|log_offset
argument_list|)
expr_stmt|;
name|xo_send_syslog
argument_list|(
name|xb
operator|.
name|xb_bufp
argument_list|,
name|v0_hdr
argument_list|,
name|xb
operator|.
name|xb_bufp
operator|+
name|start_of_msg
argument_list|)
expr_stmt|;
name|xo_destroy
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|THREAD_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * syslog - print message on log file; output is intended for syslogd(8).  */
end_comment

begin_function
name|void
name|xo_syslog
parameter_list|(
name|int
name|pri
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xo_vsyslog
argument_list|(
name|pri
argument_list|,
name|name
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

