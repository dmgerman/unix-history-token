begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2015, Juniper Networks, Inc.  * All rights reserved.  * This SOFTWARE is licensed under the LICENSE provided in the  * ../Copyright file. By downloading, installing, copying, or otherwise  * using the SOFTWARE, you agree to be bound by the terms of that  * LICENSE.  * Phil Shafer, August 2015  */
end_comment

begin_comment
comment|/**  * libxo includes a number of fixed encoding styles.  But other  * external encoders are need to deal with new encoders.  Rather  * than expose a swarm of libxo internals, we create a distinct  * API, with a simpler API than we use internally.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_include
include|#
directive|include
file|"xo_config.h"
end_include

begin_include
include|#
directive|include
file|"xo.h"
end_include

begin_include
include|#
directive|include
file|"xo_encoder.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DLFCN_H
end_ifdef

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_DLFUNC
argument_list|)
end_if

begin_define
define|#
directive|define
name|dlfunc
parameter_list|(
name|_p
parameter_list|,
name|_n
parameter_list|)
value|dlsym(_p, _n)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* HAVE_DLFCN_H */
end_comment

begin_define
define|#
directive|define
name|dlopen
parameter_list|(
name|_n
parameter_list|,
name|_f
parameter_list|)
value|NULL
end_define

begin_comment
comment|/* Fail */
end_comment

begin_define
define|#
directive|define
name|dlsym
parameter_list|(
name|_p
parameter_list|,
name|_n
parameter_list|)
value|NULL
end_define

begin_comment
comment|/* Fail */
end_comment

begin_define
define|#
directive|define
name|dlfunc
parameter_list|(
name|_p
parameter_list|,
name|_n
parameter_list|)
value|NULL
end_define

begin_comment
comment|/* Fail */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_DLFCN_H */
end_comment

begin_function_decl
specifier|static
name|void
name|xo_encoder_setup
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Forward decl */
end_comment

begin_comment
comment|/*  * Need a simple string collection  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|xo_string_node_s
block|{
name|TAILQ_ENTRY
argument_list|(
argument|xo_string_node_s
argument_list|)
name|xs_link
expr_stmt|;
comment|/* Next string */
name|char
name|xs_data
index|[
literal|0
index|]
decl_stmt|;
comment|/* String data */
block|}
name|xo_string_node_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|TAILQ_HEAD
argument_list|(
argument|xo_string_list_s
argument_list|,
argument|xo_string_node_s
argument_list|)
name|xo_string_list_t
expr_stmt|;
end_typedef

begin_function
specifier|static
specifier|inline
name|void
name|xo_string_list_init
parameter_list|(
name|xo_string_list_t
modifier|*
name|listp
parameter_list|)
block|{
if|if
condition|(
name|listp
operator|->
name|tqh_last
operator|==
name|NULL
condition|)
name|TAILQ_INIT
argument_list|(
name|listp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|xo_string_node_t
modifier|*
name|xo_string_add
parameter_list|(
name|xo_string_list_t
modifier|*
name|listp
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
name|listp
operator|==
name|NULL
operator|||
name|str
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|xo_string_list_init
argument_list|(
name|listp
argument_list|)
expr_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|xo_string_node_t
modifier|*
name|xsp
decl_stmt|;
name|xsp
operator|=
name|xo_realloc
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|xsp
argument_list|)
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xsp
condition|)
block|{
name|memcpy
argument_list|(
name|xsp
operator|->
name|xs_data
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|xsp
operator|->
name|xs_data
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|listp
argument_list|,
name|xsp
argument_list|,
name|xs_link
argument_list|)
expr_stmt|;
block|}
return|return
name|xsp
return|;
block|}
end_function

begin_define
define|#
directive|define
name|XO_STRING_LIST_FOREACH
parameter_list|(
name|_xsp
parameter_list|,
name|_listp
parameter_list|)
define|\
value|xo_string_list_init(_listp); \     TAILQ_FOREACH(_xsp, _listp, xs_link)
end_define

begin_function
specifier|static
specifier|inline
name|void
name|xo_string_list_clean
parameter_list|(
name|xo_string_list_t
modifier|*
name|listp
parameter_list|)
block|{
name|xo_string_node_t
modifier|*
name|xsp
decl_stmt|;
name|xo_string_list_init
argument_list|(
name|listp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|xsp
operator|=
name|TAILQ_FIRST
argument_list|(
name|listp
argument_list|)
expr_stmt|;
if|if
condition|(
name|xsp
operator|==
name|NULL
condition|)
break|break;
name|TAILQ_REMOVE
argument_list|(
name|listp
argument_list|,
name|xsp
argument_list|,
name|xs_link
argument_list|)
expr_stmt|;
name|xo_free
argument_list|(
name|xsp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|xo_string_list_t
name|xo_encoder_path
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|xo_encoder_path_add
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|xo_encoder_setup
argument_list|()
expr_stmt|;
if|if
condition|(
name|path
condition|)
name|xo_string_add
argument_list|(
operator|&
name|xo_encoder_path
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|xo_encoder_node_s
block|{
name|TAILQ_ENTRY
argument_list|(
argument|xo_encoder_node_s
argument_list|)
name|xe_link
expr_stmt|;
comment|/* Next session */
name|char
modifier|*
name|xe_name
decl_stmt|;
comment|/* Name for this encoder */
name|xo_encoder_func_t
name|xe_handler
decl_stmt|;
comment|/* Callback function */
name|void
modifier|*
name|xe_dlhandle
decl_stmt|;
comment|/* dlopen handle */
block|}
name|xo_encoder_node_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|TAILQ_HEAD
argument_list|(
argument|xo_encoder_list_s
argument_list|,
argument|xo_encoder_node_s
argument_list|)
name|xo_encoder_list_t
expr_stmt|;
end_typedef

begin_define
define|#
directive|define
name|XO_ENCODER_LIST_FOREACH
parameter_list|(
name|_xep
parameter_list|,
name|_listp
parameter_list|)
define|\
value|xo_encoder_list_init(_listp); \     TAILQ_FOREACH(_xep, _listp, xe_link)
end_define

begin_decl_stmt
specifier|static
name|xo_encoder_list_t
name|xo_encoders
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|xo_encoder_list_init
parameter_list|(
name|xo_encoder_list_t
modifier|*
name|listp
parameter_list|)
block|{
if|if
condition|(
name|listp
operator|->
name|tqh_last
operator|==
name|NULL
condition|)
name|TAILQ_INIT
argument_list|(
name|listp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|xo_encoder_node_t
modifier|*
name|xo_encoder_list_add
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|xo_encoder_node_t
modifier|*
name|xep
init|=
name|xo_realloc
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|xep
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|xep
condition|)
block|{
name|ssize_t
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
name|xep
operator|->
name|xe_name
operator|=
name|xo_realloc
argument_list|(
name|NULL
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|xep
operator|->
name|xe_name
operator|==
name|NULL
condition|)
block|{
name|xo_free
argument_list|(
name|xep
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memcpy
argument_list|(
name|xep
operator|->
name|xe_name
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|xo_encoders
argument_list|,
name|xep
argument_list|,
name|xe_link
argument_list|)
expr_stmt|;
block|}
return|return
name|xep
return|;
block|}
end_function

begin_function
name|void
name|xo_encoders_clean
parameter_list|(
name|void
parameter_list|)
block|{
name|xo_encoder_node_t
modifier|*
name|xep
decl_stmt|;
name|xo_encoder_setup
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|xep
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|xo_encoders
argument_list|)
expr_stmt|;
if|if
condition|(
name|xep
operator|==
name|NULL
condition|)
break|break;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|xo_encoders
argument_list|,
name|xep
argument_list|,
name|xe_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|xep
operator|->
name|xe_dlhandle
condition|)
name|dlclose
argument_list|(
name|xep
operator|->
name|xe_dlhandle
argument_list|)
expr_stmt|;
name|xo_free
argument_list|(
name|xep
argument_list|)
expr_stmt|;
block|}
name|xo_string_list_clean
argument_list|(
operator|&
name|xo_encoder_path
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xo_encoder_setup
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|initted
decl_stmt|;
if|if
condition|(
operator|!
name|initted
condition|)
block|{
name|initted
operator|=
literal|1
expr_stmt|;
name|xo_string_list_init
argument_list|(
operator|&
name|xo_encoder_path
argument_list|)
expr_stmt|;
name|xo_encoder_list_init
argument_list|(
operator|&
name|xo_encoders
argument_list|)
expr_stmt|;
name|xo_encoder_path_add
argument_list|(
name|XO_ENCODERDIR
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|xo_encoder_node_t
modifier|*
name|xo_encoder_find
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|xo_encoder_node_t
modifier|*
name|xep
decl_stmt|;
name|xo_encoder_list_init
argument_list|(
operator|&
name|xo_encoders
argument_list|)
expr_stmt|;
name|XO_ENCODER_LIST_FOREACH
argument_list|(
argument|xep
argument_list|,
argument|&xo_encoders
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|xep
operator|->
name|xe_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|xep
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|xo_encoder_node_t
modifier|*
name|xo_encoder_discover
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|void
modifier|*
name|dlp
init|=
name|NULL
decl_stmt|;
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|xo_string_node_t
modifier|*
name|xsp
decl_stmt|;
name|xo_encoder_node_t
modifier|*
name|xep
init|=
name|NULL
decl_stmt|;
name|XO_STRING_LIST_FOREACH
argument_list|(
argument|xsp
argument_list|,
argument|&xo_encoder_path
argument_list|)
block|{
specifier|static
specifier|const
name|char
name|fmt
index|[]
init|=
literal|"%s/%s.enc"
decl_stmt|;
name|char
modifier|*
name|dir
init|=
name|xsp
operator|->
name|xs_data
decl_stmt|;
name|size_t
name|len
init|=
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|dir
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
comment|/* Should not occur */
continue|continue;
name|dlp
operator|=
name|dlopen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|buf
argument_list|,
name|RTLD_NOW
argument_list|)
expr_stmt|;
if|if
condition|(
name|dlp
condition|)
break|break;
block|}
if|if
condition|(
name|dlp
condition|)
block|{
comment|/* 	 * If the library exists, find the initializer function and 	 * call it. 	 */
name|xo_encoder_init_func_t
name|func
decl_stmt|;
name|func
operator|=
operator|(
name|xo_encoder_init_func_t
operator|)
name|dlfunc
argument_list|(
name|dlp
argument_list|,
name|XO_ENCODER_INIT_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
condition|)
block|{
name|xo_encoder_init_args_t
name|xei
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|xei
argument_list|,
sizeof|sizeof
argument_list|(
name|xei
argument_list|)
argument_list|)
expr_stmt|;
name|xei
operator|.
name|xei_version
operator|=
name|XO_ENCODER_VERSION
expr_stmt|;
name|ssize_t
name|rc
init|=
name|func
argument_list|(
operator|&
name|xei
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
operator|&&
name|xei
operator|.
name|xei_handler
condition|)
block|{
name|xep
operator|=
name|xo_encoder_list_add
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|xep
condition|)
block|{
name|xep
operator|->
name|xe_handler
operator|=
name|xei
operator|.
name|xei_handler
expr_stmt|;
name|xep
operator|->
name|xe_dlhandle
operator|=
name|dlp
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|xep
operator|==
name|NULL
condition|)
name|dlclose
argument_list|(
name|dlp
argument_list|)
expr_stmt|;
block|}
return|return
name|xep
return|;
block|}
end_function

begin_function
name|void
name|xo_encoder_register
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|xo_encoder_func_t
name|func
parameter_list|)
block|{
name|xo_encoder_setup
argument_list|()
expr_stmt|;
name|xo_encoder_node_t
modifier|*
name|xep
init|=
name|xo_encoder_find
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|xep
condition|)
comment|/* "We alla-ready got one" */
return|return;
name|xep
operator|=
name|xo_encoder_list_add
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|xep
condition|)
name|xep
operator|->
name|xe_handler
operator|=
name|func
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xo_encoder_unregister
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|xo_encoder_setup
argument_list|()
expr_stmt|;
name|xo_encoder_node_t
modifier|*
name|xep
init|=
name|xo_encoder_find
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|xep
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|xo_encoders
argument_list|,
name|xep
argument_list|,
name|xe_link
argument_list|)
expr_stmt|;
name|xo_free
argument_list|(
name|xep
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|xo_encoder_init
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|xo_encoder_setup
argument_list|()
expr_stmt|;
comment|/* Can't have names containing '/' or ':' */
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
operator|||
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/*      * First we look on the list of known (registered) encoders.      * If we don't find it, we follow the set of paths to find      * the encoding library.      */
name|xo_encoder_node_t
modifier|*
name|xep
init|=
name|xo_encoder_find
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|xep
operator|==
name|NULL
condition|)
block|{
name|xep
operator|=
name|xo_encoder_discover
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|xep
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|xo_set_encoder
argument_list|(
name|xop
argument_list|,
name|xep
operator|->
name|xe_handler
argument_list|)
expr_stmt|;
return|return
name|xo_encoder_handle
argument_list|(
name|xop
argument_list|,
name|XO_OP_CREATE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * A couple of function varieties here, to allow for multiple  * use cases.  This variant is for when the main program knows  * its own encoder needs.  */
end_comment

begin_function
name|xo_handle_t
modifier|*
name|xo_encoder_create
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|xo_xof_flags_t
name|flags
parameter_list|)
block|{
name|xo_handle_t
modifier|*
name|xop
decl_stmt|;
name|xop
operator|=
name|xo_create
argument_list|(
name|XO_STYLE_ENCODER
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop
condition|)
block|{
if|if
condition|(
name|xo_encoder_init
argument_list|(
name|xop
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|xo_destroy
argument_list|(
name|xop
argument_list|)
expr_stmt|;
name|xop
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|xop
return|;
block|}
end_function

begin_function
name|int
name|xo_encoder_handle
parameter_list|(
name|xo_handle_t
modifier|*
name|xop
parameter_list|,
name|xo_encoder_op_t
name|op
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|xo_xof_flags_t
name|flags
parameter_list|)
block|{
name|void
modifier|*
name|private
init|=
name|xo_get_private
argument_list|(
name|xop
argument_list|)
decl_stmt|;
name|xo_encoder_func_t
name|func
init|=
name|xo_get_encoder
argument_list|(
name|xop
argument_list|)
decl_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|func
argument_list|(
name|xop
argument_list|,
name|op
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|private
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|xo_encoder_op_name
parameter_list|(
name|xo_encoder_op_t
name|op
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|names
index|[]
init|=
block|{
comment|/*  0 */
literal|"unknown"
block|,
comment|/*  1 */
literal|"create"
block|,
comment|/*  2 */
literal|"open_container"
block|,
comment|/*  3 */
literal|"close_container"
block|,
comment|/*  4 */
literal|"open_list"
block|,
comment|/*  5 */
literal|"close_list"
block|,
comment|/*  6 */
literal|"open_leaf_list"
block|,
comment|/*  7 */
literal|"close_leaf_list"
block|,
comment|/*  8 */
literal|"open_instance"
block|,
comment|/*  9 */
literal|"close_instance"
block|,
comment|/* 10 */
literal|"string"
block|,
comment|/* 11 */
literal|"content"
block|,
comment|/* 12 */
literal|"finish"
block|,
comment|/* 13 */
literal|"flush"
block|,
comment|/* 14 */
literal|"destroy"
block|,
comment|/* 15 */
literal|"attr"
block|,
comment|/* 16 */
literal|"version"
block|,     }
decl_stmt|;
if|if
condition|(
name|op
operator|>
sizeof|sizeof
argument_list|(
name|names
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|names
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
literal|"unknown"
return|;
return|return
name|names
index|[
name|op
index|]
return|;
block|}
end_function

end_unit

