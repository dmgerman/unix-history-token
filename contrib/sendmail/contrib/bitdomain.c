begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * By John G. Myers, jgm+@cmu.edu  * Version 1.2  *  * Process a BITNET "internet.listing" file, producing output  * suitable for input to makemap.  *  * The input file can be obtained via anonymous FTP to bitnic.educom.edu.  * Change directory to "netinfo" and get the file internet.listing  * The file is updated monthly.  *  * Feed the output of this program to "makemap hash /etc/mail/bitdomain.db"  * to create the table used by the "FEATURE(bitdomain)" config file macro.  * If your sendmail does not have the db library compiled in, you can instead  * use "makemap dbm /etc/mail/bitdomain" and  * "FEATURE(bitdomain,`dbm -o /etc/mail/bitdomain')"  *  * The bitdomain table should be rebuilt monthly.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* don't use sizeof because sizeof(long) is different on 64-bit machines */
end_comment

begin_define
define|#
directive|define
name|SHORTSIZE
value|2
end_define

begin_comment
comment|/* size of a short (really, must be 2) */
end_comment

begin_define
define|#
directive|define
name|LONGSIZE
value|4
end_define

begin_comment
comment|/* size of a long (really, must be 4) */
end_comment

begin_typedef
typedef|typedef
union|union
block|{
name|HEADER
name|qb1
decl_stmt|;
name|char
name|qb2
index|[
name|PACKETSZ
index|]
decl_stmt|;
block|}
name|querybuf
typedef|;
end_typedef

begin_decl_stmt
specifier|extern
name|int
name|h_errno
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|optind
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|lookup
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|opt
decl_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"o:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'o'
case|:
if|if
condition|(
operator|!
name|freopen
argument_list|(
name|optarg
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-o outfile] [internet.listing]\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
if|if
condition|(
operator|!
name|freopen
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|readfile
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|finish
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse and process an input file  */
end_comment

begin_macro
name|readfile
argument_list|(
argument|infile
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|infile
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|skippingheader
init|=
literal|1
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|,
modifier|*
name|node
decl_stmt|,
modifier|*
name|hostname
decl_stmt|,
modifier|*
name|p
decl_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|infile
argument_list|)
condition|)
block|{
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
block|{
name|skippingheader
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|skippingheader
condition|)
continue|continue;
name|node
operator|=
name|p
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|p
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-8s: no domain name in input file\n"
argument_list|,
name|node
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-8s no domain name in input file\n"
argument_list|,
name|node
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|hostname
operator|=
name|p
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Chop off any trailing .bitnet */
if|if
condition|(
name|strlen
argument_list|(
name|hostname
argument_list|)
operator|>
literal|7
operator|&&
operator|!
name|strcmp
argument_list|(
name|hostname
operator|+
name|strlen
argument_list|(
name|hostname
argument_list|)
operator|-
literal|7
argument_list|,
literal|".bitnet"
argument_list|)
condition|)
block|{
name|hostname
index|[
name|strlen
argument_list|(
name|hostname
argument_list|)
operator|-
literal|7
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|entry
argument_list|(
name|node
argument_list|,
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
operator|(
name|hostname
operator|-
name|buf
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Process a single entry in the input file.  * The entry tells us that "node" expands to "domain".  * "domain" can either be a domain name or a bitnet node name  * The buffer pointed to by "domain" may be overwritten--it  * is of size "domainlen".  */
end_comment

begin_macro
name|entry
argument_list|(
argument|node
argument_list|,
argument|domain
argument_list|,
argument|domainlen
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|domain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|domainlen
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|otherdomain
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|err
decl_stmt|;
comment|/* See if we have any remembered information about this node */
name|otherdomain
operator|=
name|lookup
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|otherdomain
operator|&&
name|strchr
argument_list|(
name|otherdomain
argument_list|,
literal|'.'
argument_list|)
condition|)
block|{
comment|/* We already have a domain for this node */
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|domain
argument_list|,
literal|'.'
argument_list|)
condition|)
block|{
comment|/* 	     * This entry is an Eric Thomas FOO.BITNET kludge. 	     * He doesn't want LISTSERV to do transitive closures, so we 	     * do them instead.  Give the the domain expansion for "node" 	     * (which is in "otherdomian") to FOO (which is in "domain") 	     * if "domain" doesn't have a domain expansion already. 	     */
name|p
operator|=
name|lookup
argument_list|(
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|strchr
argument_list|(
name|p
argument_list|,
literal|'.'
argument_list|)
condition|)
name|remember
argument_list|(
name|domain
argument_list|,
name|otherdomain
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|domain
argument_list|,
literal|'.'
argument_list|)
operator|||
name|valhost
argument_list|(
name|domain
argument_list|,
name|domainlen
argument_list|)
condition|)
block|{
name|remember
argument_list|(
name|node
argument_list|,
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|otherdomain
condition|)
block|{
comment|/* 		 * We previously mapped the node "node" to the node 		 * "otherdomain".  If "otherdomain" doesn't already 		 * have a domain expansion, give it the expansion "domain". 		 */
name|p
operator|=
name|lookup
argument_list|(
name|otherdomain
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|strchr
argument_list|(
name|p
argument_list|,
literal|'.'
argument_list|)
condition|)
name|remember
argument_list|(
name|otherdomain
argument_list|,
name|domain
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|h_errno
condition|)
block|{
case|case
name|HOST_NOT_FOUND
case|:
name|err
operator|=
literal|"not registered in DNS"
expr_stmt|;
break|break;
case|case
name|TRY_AGAIN
case|:
name|err
operator|=
literal|"temporary DNS lookup failure"
expr_stmt|;
break|break;
case|case
name|NO_RECOVERY
case|:
name|err
operator|=
literal|"non-recoverable nameserver error"
expr_stmt|;
break|break;
case|case
name|NO_DATA
case|:
name|err
operator|=
literal|"registered in DNS, but not mailable"
expr_stmt|;
break|break;
default|default:
name|err
operator|=
literal|"unknown nameserver error"
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-8s %s %s\n"
argument_list|,
name|node
argument_list|,
name|domain
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Validate whether the mail domain "host" is registered in the DNS.  * If "host" is a CNAME, it is expanded in-place if the expansion fits  * into the buffer of size "hbsize".  Returns nonzero if it is, zero  * if it is not.  A BIND error code is left in h_errno.  */
end_comment

begin_function
name|int
name|valhost
parameter_list|(
name|host
parameter_list|,
name|hbsize
parameter_list|)
name|char
modifier|*
name|host
decl_stmt|;
name|int
name|hbsize
decl_stmt|;
block|{
specifier|register
name|u_char
modifier|*
name|eom
decl_stmt|,
modifier|*
name|ap
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|querybuf
name|answer
decl_stmt|;
name|int
name|ancount
decl_stmt|,
name|qdcount
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|qtype
decl_stmt|;
name|char
name|nbuf
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_INIT
operator|)
operator|==
literal|0
operator|&&
name|res_init
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|_res
operator|.
name|options
operator|&=
operator|~
operator|(
name|RES_DNSRCH
operator||
name|RES_DEFNAMES
operator|)
expr_stmt|;
name|_res
operator|.
name|retrans
operator|=
literal|30
expr_stmt|;
name|_res
operator|.
name|retry
operator|=
literal|10
expr_stmt|;
name|qtype
operator|=
name|T_ANY
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|h_errno
operator|=
name|NO_DATA
expr_stmt|;
name|ret
operator|=
name|res_querydomain
argument_list|(
name|host
argument_list|,
literal|""
argument_list|,
name|C_IN
argument_list|,
name|qtype
argument_list|,
operator|&
name|answer
argument_list|,
sizeof|sizeof
argument_list|(
name|answer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ECONNREFUSED
operator|||
name|h_errno
operator|==
name|TRY_AGAIN
condition|)
block|{
comment|/* the name server seems to be down */
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|h_errno
operator|!=
name|HOST_NOT_FOUND
condition|)
block|{
comment|/* might have another type of interest */
if|if
condition|(
name|qtype
operator|==
name|T_ANY
condition|)
block|{
name|qtype
operator|=
name|T_A
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|qtype
operator|==
name|T_A
condition|)
block|{
name|qtype
operator|=
name|T_MX
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* otherwise, no record */
return|return
literal|0
return|;
block|}
comment|/* 		**  This might be a bogus match.  Search for A, MX, or 		**  CNAME records. 		*/
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
operator|&
name|answer
expr_stmt|;
name|ap
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|answer
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
expr_stmt|;
name|eom
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|answer
operator|+
name|ret
expr_stmt|;
comment|/* skip question part of response -- we know what we asked */
for|for
control|(
name|qdcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
init|;
name|qdcount
operator|--
condition|;
name|ap
operator|+=
name|ret
operator|+
name|QFIXEDSZ
control|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|dn_skipname
argument_list|(
name|ap
argument_list|,
name|eom
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
return|return
literal|0
return|;
comment|/* ???XXX??? */
block|}
block|}
for|for
control|(
name|ancount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
init|;
operator|--
name|ancount
operator|>=
literal|0
operator|&&
name|ap
operator|<
name|eom
condition|;
name|ap
operator|+=
name|n
control|)
block|{
name|n
operator|=
name|dn_expand
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|answer
argument_list|,
name|eom
argument_list|,
name|ap
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|nbuf
argument_list|,
sizeof|sizeof
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|ap
operator|+=
name|n
expr_stmt|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|ap
operator|+=
name|SHORTSIZE
operator|+
name|LONGSIZE
expr_stmt|;
name|GETSHORT
argument_list|(
name|n
argument_list|,
name|ap
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_MX
case|:
case|case
name|T_A
case|:
return|return
literal|1
return|;
case|case
name|T_CNAME
case|:
comment|/* value points at name */
if|if
condition|(
operator|(
name|ret
operator|=
name|dn_expand
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|answer
argument_list|,
name|eom
argument_list|,
name|ap
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|nbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|nbuf
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|strlen
argument_list|(
name|nbuf
argument_list|)
operator|<
name|hbsize
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|host
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
default|default:
comment|/* not a record of interest */
continue|continue;
block|}
block|}
comment|/* 		**  If this was a T_ANY query, we may have the info but 		**  need an explicit query.  Try T_A, then T_MX. 		*/
if|if
condition|(
name|qtype
operator|==
name|T_ANY
condition|)
name|qtype
operator|=
name|T_A
expr_stmt|;
elseif|else
if|if
condition|(
name|qtype
operator|==
name|T_A
condition|)
name|qtype
operator|=
name|T_MX
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
block|}
end_function

begin_struct
struct|struct
name|entry
block|{
name|struct
name|entry
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|node
decl_stmt|;
name|char
modifier|*
name|domain
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|entry
modifier|*
name|firstentry
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Find any remembered information about "node"  */
end_comment

begin_function
name|char
modifier|*
name|lookup
parameter_list|(
name|node
parameter_list|)
name|char
modifier|*
name|node
decl_stmt|;
block|{
name|struct
name|entry
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|firstentry
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|node
argument_list|,
name|p
operator|->
name|node
argument_list|)
condition|)
block|{
return|return
name|p
operator|->
name|domain
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Mark the node "node" as equivalent to "domain".  "domain" can either  * be a bitnet node or a domain name--if it is the latter, the mapping  * will be written to stdout.  */
end_comment

begin_macro
name|remember
argument_list|(
argument|node
argument_list|,
argument|domain
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|domain
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|entry
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|domain
argument_list|,
literal|'.'
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%-8s %s\n"
argument_list|,
name|node
argument_list|,
name|domain
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|firstentry
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|node
argument_list|,
name|p
operator|->
name|node
argument_list|)
condition|)
block|{
name|p
operator|->
name|domain
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|domain
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|domain
condition|)
block|{
goto|goto
name|outofmemory
goto|;
block|}
name|strcpy
argument_list|(
name|p
operator|->
name|domain
argument_list|,
name|domain
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|p
operator|=
operator|(
expr|struct
name|entry
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
goto|goto
name|outofmemory
goto|;
name|p
operator|->
name|next
operator|=
name|firstentry
expr_stmt|;
name|firstentry
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|node
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|node
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|domain
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|domain
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|node
operator|||
operator|!
name|p
operator|->
name|domain
condition|)
goto|goto
name|outofmemory
goto|;
name|strcpy
argument_list|(
name|p
operator|->
name|node
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
operator|->
name|domain
argument_list|,
name|domain
argument_list|)
expr_stmt|;
return|return;
name|outofmemory
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Walk through the database, looking for any cases where we know  * node FOO is equivalent to node BAR and node BAR has a domain name.  * For those cases, give FOO the same domain name as BAR.  */
end_comment

begin_macro
name|finish
argument_list|()
end_macro

begin_block
block|{
name|struct
name|entry
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|domain
decl_stmt|;
for|for
control|(
name|p
operator|=
name|firstentry
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|p
operator|->
name|domain
argument_list|,
literal|'.'
argument_list|)
operator|&&
operator|(
name|domain
operator|=
name|lookup
argument_list|(
name|p
operator|->
name|domain
argument_list|)
operator|)
condition|)
block|{
name|remember
argument_list|(
name|p
operator|->
name|node
argument_list|,
name|domain
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

end_unit

