begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2001 Sendmail, Inc. and its suppliers.  *	All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  */
end_comment

begin_include
include|#
directive|include
file|<sm/gen.h>
end_include

begin_macro
name|SM_IDSTR
argument_list|(
argument|id
argument_list|,
literal|"@(#)$Id: t-types.c,v 1.16 2001/09/11 04:04:49 gshapiro Exp $"
argument_list|)
end_macro

begin_include
include|#
directive|include
file|<sm/limits.h>
end_include

begin_include
include|#
directive|include
file|<sm/io.h>
end_include

begin_include
include|#
directive|include
file|<sm/string.h>
end_include

begin_include
include|#
directive|include
file|<sm/test.h>
end_include

begin_include
include|#
directive|include
file|<sm/types.h>
end_include

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|LONGLONG_T
name|ll
decl_stmt|;
name|LONGLONG_T
specifier|volatile
name|lt
decl_stmt|;
name|ULONGLONG_T
name|ull
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|r
decl_stmt|;
name|sm_test_begin
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"test standard integral types"
argument_list|)
expr_stmt|;
name|SM_TEST
argument_list|(
sizeof|sizeof
argument_list|(
name|LONGLONG_T
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|ULONGLONG_T
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	**  sendmail assumes that ino_t, off_t and void* can be cast 	**  to ULONGLONG_T without losing information. 	*/
if|if
condition|(
operator|!
name|SM_TEST
argument_list|(
sizeof|sizeof
argument_list|(
name|ino_t
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|ULONGLONG_T
argument_list|)
argument_list|)
operator|||
operator|!
name|SM_TEST
argument_list|(
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|ULONGLONG_T
argument_list|)
argument_list|)
operator|||
operator|!
name|SM_TEST
argument_list|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|ULONGLONG_T
argument_list|)
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioerr
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\ Your C compiler appears to support a 64 bit integral type,\n\ but libsm is not configured to use it.  You will need to set\n\ either SM_CONF_LONGLONG or SM_CONF_QUAD_T to 1.  See libsm/README\n\ for more details.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Most compilers notice that LLONG_MIN - 1 generate an underflow. 	**  Some compiler generate code that will use the 'X' status bit 	**  in a CPU and hence (LLONG_MIN - 1> LLONG_MIN) will be false. 	**  So we have to decide whether we want compiler warnings or 	**  a wrong test... 	**  Question: where do we really need what this test tests? 	*/
if|#
directive|if
name|SM_CONF_TEST_LLONG
name|ll
operator|=
name|LLONG_MIN
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioerr
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\ Your C compiler maybe issued a warning during compilation,\n\ please IGNORE the compiler warning!.\n"
argument_list|)
expr_stmt|;
name|lt
operator|=
name|LLONG_MIN
operator|-
literal|1
expr_stmt|;
name|SM_TEST
argument_list|(
name|lt
operator|>
name|ll
argument_list|)
expr_stmt|;
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%llx"
argument_list|,
name|ll
argument_list|)
expr_stmt|;
name|r
operator|=
literal|"0"
expr_stmt|;
if|if
condition|(
operator|!
name|SM_TEST
argument_list|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'8'
argument_list|)
operator|||
operator|!
name|SM_TEST
argument_list|(
name|strspn
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
name|r
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|ll
argument_list|)
operator|*
literal|2
operator|-
literal|1
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioerr
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"oops: LLONG_MIN=%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|ll
operator|=
name|LLONG_MAX
expr_stmt|;
name|lt
operator|=
name|ll
operator|+
literal|1
expr_stmt|;
name|SM_TEST
argument_list|(
name|lt
operator|<
name|ll
argument_list|)
expr_stmt|;
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%llx"
argument_list|,
name|ll
argument_list|)
expr_stmt|;
name|r
operator|=
literal|"f"
expr_stmt|;
if|if
condition|(
operator|!
name|SM_TEST
argument_list|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'7'
argument_list|)
operator|||
operator|!
name|SM_TEST
argument_list|(
name|strspn
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
name|r
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|ll
argument_list|)
operator|*
literal|2
operator|-
literal|1
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioerr
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"oops: LLONG_MAX=%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SM_CONF_TEST_LLONG */
name|ull
operator|=
name|ULLONG_MAX
expr_stmt|;
name|SM_TEST
argument_list|(
name|ull
operator|+
literal|1
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%llx"
argument_list|,
name|ull
argument_list|)
expr_stmt|;
name|r
operator|=
literal|"f"
expr_stmt|;
name|SM_TEST
argument_list|(
name|strspn
argument_list|(
name|buf
argument_list|,
name|r
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|ll
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* 	**  If QUAD_MAX is defined by<limits.h> then quad_t is defined. 	**  Make sure LONGLONG_T is at least as big as quad_t. 	*/
ifdef|#
directive|ifdef
name|QUAD_MAX
name|SM_TEST
argument_list|(
name|QUAD_MAX
operator|<=
name|LLONG_MAX
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|sm_test_end
argument_list|()
return|;
block|}
end_function

end_unit

