begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2002 Sendmail, Inc. and its suppliers.  *	All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  */
end_comment

begin_include
include|#
directive|include
file|<sm/gen.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: rpool.c,v 1.24 2002/01/11 21:54:43 ca Exp $"
argument_list|)
end_macro

begin_comment
comment|/* **  resource pools **  For documentation, see rpool.html */
end_comment

begin_include
include|#
directive|include
file|<sm/exc.h>
end_include

begin_include
include|#
directive|include
file|<sm/heap.h>
end_include

begin_include
include|#
directive|include
file|<sm/rpool.h>
end_include

begin_include
include|#
directive|include
file|<sm/varargs.h>
end_include

begin_include
include|#
directive|include
file|<sm/conf.h>
end_include

begin_if
if|#
directive|if
name|_FFR_PERF_RPOOL
end_if

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_PERF_RPOOL */
end_comment

begin_decl_stmt
specifier|const
name|char
name|SmRpoolMagic
index|[]
init|=
literal|"sm_rpool"
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
union|union
block|{
name|SM_POOLLINK_T
name|link
decl_stmt|;
name|char
name|align
index|[
name|SM_ALIGN_SIZE
index|]
decl_stmt|;
block|}
name|SM_POOLHDR_T
typedef|;
end_typedef

begin_comment
comment|/* **  Tune this later */
end_comment

begin_define
define|#
directive|define
name|POOLSIZE
value|4096
end_define

begin_define
define|#
directive|define
name|BIG_OBJECT_RATIO
value|10
end_define

begin_comment
comment|/* **  SM_RPOOL_ALLOCBLOCK_X -- allocate a new block for an rpool. ** **	Parameters: **		rpool -- rpool to which the block should be added. **		size -- size of block. ** **	Returns: **		Pointer to block. ** **	Exceptions: **		F:sm_heap -- out of memory */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|sm_rpool_allocblock_x
parameter_list|(
name|rpool
parameter_list|,
name|size
parameter_list|)
name|SM_RPOOL_T
modifier|*
name|rpool
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|SM_POOLLINK_T
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|sm_malloc_x
argument_list|(
sizeof|sizeof
argument_list|(
name|SM_POOLHDR_T
argument_list|)
operator|+
name|size
argument_list|)
expr_stmt|;
name|p
operator|->
name|sm_pnext
operator|=
name|rpool
operator|->
name|sm_pools
expr_stmt|;
name|rpool
operator|->
name|sm_pools
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|p
operator|+
sizeof|sizeof
argument_list|(
name|SM_POOLHDR_T
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  SM_RPOOL_ALLOCBLOCK -- allocate a new block for an rpool. ** **	Parameters: **		rpool -- rpool to which the block should be added. **		size -- size of block. ** **	Returns: **		Pointer to block, NULL on failure. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|sm_rpool_allocblock
parameter_list|(
name|rpool
parameter_list|,
name|size
parameter_list|)
name|SM_RPOOL_T
modifier|*
name|rpool
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|SM_POOLLINK_T
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|sm_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SM_POOLHDR_T
argument_list|)
operator|+
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|p
operator|->
name|sm_pnext
operator|=
name|rpool
operator|->
name|sm_pools
expr_stmt|;
name|rpool
operator|->
name|sm_pools
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|p
operator|+
sizeof|sizeof
argument_list|(
name|SM_POOLHDR_T
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  SM_RPOOL_MALLOC_TAGGED_X -- allocate memory from rpool ** **	Parameters: **		rpool -- rpool from which memory should be allocated; **			can be NULL, use sm_malloc() then. **		size -- size of block. **		file -- filename. **		line -- line number in file. **		group -- heap group for debugging. ** **	Returns: **		Pointer to block. ** **	Exceptions: **		F:sm_heap -- out of memory ** **	Notice: XXX **		if size == 0 and the rpool is new (no memory **		allocated yet) NULL is returned! **		We could solve this by **		- wasting 1 byte (size< avail) **		- checking for rpool->sm_poolptr != NULL **		- not asking for 0 sized buffer */
end_comment

begin_function
name|void
modifier|*
if|#
directive|if
name|SM_HEAP_CHECK
name|sm_rpool_malloc_tagged_x
parameter_list|(
name|rpool
parameter_list|,
name|size
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|,
name|group
parameter_list|)
name|SM_RPOOL_T
modifier|*
name|rpool
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
name|int
name|group
decl_stmt|;
else|#
directive|else
comment|/* SM_HEAP_CHECK */
function|sm_rpool_malloc_x
parameter_list|(
name|rpool
parameter_list|,
name|size
parameter_list|)
name|SM_RPOOL_T
modifier|*
name|rpool
decl_stmt|;
name|size_t
name|size
decl_stmt|;
endif|#
directive|endif
comment|/* SM_HEAP_CHECK */
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|rpool
operator|==
name|NULL
condition|)
return|return
name|sm_malloc_tagged_x
argument_list|(
name|size
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|group
argument_list|)
return|;
comment|/* Ensure that size is properly aligned. */
if|if
condition|(
name|size
operator|&
name|SM_ALIGN_BITS
condition|)
name|size
operator|=
operator|(
name|size
operator|&
operator|~
name|SM_ALIGN_BITS
operator|)
operator|+
name|SM_ALIGN_SIZE
expr_stmt|;
comment|/* The common case.  This is optimized for speed. */
if|if
condition|(
name|size
operator|<=
name|rpool
operator|->
name|sm_poolavail
condition|)
block|{
name|ptr
operator|=
name|rpool
operator|->
name|sm_poolptr
expr_stmt|;
name|rpool
operator|->
name|sm_poolptr
operator|+=
name|size
expr_stmt|;
name|rpool
operator|->
name|sm_poolavail
operator|-=
name|size
expr_stmt|;
return|return
name|ptr
return|;
block|}
comment|/* 	**  The slow case: we need to call malloc. 	**  The SM_REQUIRE assertion is deferred until now, for speed. 	**  That's okay: we set rpool->sm_poolavail to 0 when we free an rpool, 	**  so the common case code won't be triggered on a dangling pointer. 	*/
name|SM_REQUIRE
argument_list|(
name|rpool
operator|->
name|sm_magic
operator|==
name|SmRpoolMagic
argument_list|)
expr_stmt|;
comment|/* 	**  If size> sm_poolsize, then malloc a new block especially for 	**  this request.  Future requests will be allocated from the 	**  current pool. 	** 	**  What if the current pool is mostly unallocated, and the current 	**  request is larger than the available space, but< sm_poolsize? 	**  If we discard the current pool, and start allocating from a new 	**  pool, then we will be wasting a lot of space.  For this reason, 	**  we malloc a block just for the current request if size> 	**  sm_bigobjectsize, where sm_bigobjectsize<= sm_poolsize. 	**  Thus, the most space that we will waste at the end of a pool 	**  is sm_bigobjectsize - 1. 	*/
if|if
condition|(
name|size
operator|>
name|rpool
operator|->
name|sm_bigobjectsize
condition|)
block|{
if|#
directive|if
name|_FFR_PERF_RPOOL
operator|++
name|rpool
operator|->
name|sm_nbigblocks
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_PERF_RPOOL */
return|return
name|sm_rpool_allocblock_x
argument_list|(
name|rpool
argument_list|,
name|size
argument_list|)
return|;
block|}
name|SM_ASSERT
argument_list|(
name|rpool
operator|->
name|sm_bigobjectsize
operator|<=
name|rpool
operator|->
name|sm_poolsize
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|sm_rpool_allocblock_x
argument_list|(
name|rpool
argument_list|,
name|rpool
operator|->
name|sm_poolsize
argument_list|)
expr_stmt|;
name|rpool
operator|->
name|sm_poolptr
operator|=
name|ptr
operator|+
name|size
expr_stmt|;
name|rpool
operator|->
name|sm_poolavail
operator|=
name|rpool
operator|->
name|sm_poolsize
operator|-
name|size
expr_stmt|;
if|#
directive|if
name|_FFR_PERF_RPOOL
operator|++
name|rpool
operator|->
name|sm_npools
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_PERF_RPOOL */
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* **  SM_RPOOL_MALLOC_TAGGED -- allocate memory from rpool ** **	Parameters: **		rpool -- rpool from which memory should be allocated; **			can be NULL, use sm_malloc() then. **		size -- size of block. **		file -- filename. **		line -- line number in file. **		group -- heap group for debugging. ** **	Returns: **		Pointer to block, NULL on failure. ** **	Notice: XXX **		if size == 0 and the rpool is new (no memory **		allocated yet) NULL is returned! **		We could solve this by **		- wasting 1 byte (size< avail) **		- checking for rpool->sm_poolptr != NULL **		- not asking for 0 sized buffer */
end_comment

begin_function
name|void
modifier|*
if|#
directive|if
name|SM_HEAP_CHECK
name|sm_rpool_malloc_tagged
parameter_list|(
name|rpool
parameter_list|,
name|size
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|,
name|group
parameter_list|)
name|SM_RPOOL_T
modifier|*
name|rpool
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
name|int
name|group
decl_stmt|;
else|#
directive|else
comment|/* SM_HEAP_CHECK */
function|sm_rpool_malloc
parameter_list|(
name|rpool
parameter_list|,
name|size
parameter_list|)
name|SM_RPOOL_T
modifier|*
name|rpool
decl_stmt|;
name|size_t
name|size
decl_stmt|;
endif|#
directive|endif
comment|/* SM_HEAP_CHECK */
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|rpool
operator|==
name|NULL
condition|)
return|return
name|sm_malloc_tagged
argument_list|(
name|size
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|group
argument_list|)
return|;
comment|/* Ensure that size is properly aligned. */
if|if
condition|(
name|size
operator|&
name|SM_ALIGN_BITS
condition|)
name|size
operator|=
operator|(
name|size
operator|&
operator|~
name|SM_ALIGN_BITS
operator|)
operator|+
name|SM_ALIGN_SIZE
expr_stmt|;
comment|/* The common case.  This is optimized for speed. */
if|if
condition|(
name|size
operator|<=
name|rpool
operator|->
name|sm_poolavail
condition|)
block|{
name|ptr
operator|=
name|rpool
operator|->
name|sm_poolptr
expr_stmt|;
name|rpool
operator|->
name|sm_poolptr
operator|+=
name|size
expr_stmt|;
name|rpool
operator|->
name|sm_poolavail
operator|-=
name|size
expr_stmt|;
return|return
name|ptr
return|;
block|}
comment|/* 	**  The slow case: we need to call malloc. 	**  The SM_REQUIRE assertion is deferred until now, for speed. 	**  That's okay: we set rpool->sm_poolavail to 0 when we free an rpool, 	**  so the common case code won't be triggered on a dangling pointer. 	*/
name|SM_REQUIRE
argument_list|(
name|rpool
operator|->
name|sm_magic
operator|==
name|SmRpoolMagic
argument_list|)
expr_stmt|;
comment|/* 	**  If size> sm_poolsize, then malloc a new block especially for 	**  this request.  Future requests will be allocated from the 	**  current pool. 	** 	**  What if the current pool is mostly unallocated, and the current 	**  request is larger than the available space, but< sm_poolsize? 	**  If we discard the current pool, and start allocating from a new 	**  pool, then we will be wasting a lot of space.  For this reason, 	**  we malloc a block just for the current request if size> 	**  sm_bigobjectsize, where sm_bigobjectsize<= sm_poolsize. 	**  Thus, the most space that we will waste at the end of a pool 	**  is sm_bigobjectsize - 1. 	*/
if|if
condition|(
name|size
operator|>
name|rpool
operator|->
name|sm_bigobjectsize
condition|)
block|{
if|#
directive|if
name|_FFR_PERF_RPOOL
operator|++
name|rpool
operator|->
name|sm_nbigblocks
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_PERF_RPOOL */
return|return
name|sm_rpool_allocblock
argument_list|(
name|rpool
argument_list|,
name|size
argument_list|)
return|;
block|}
name|SM_ASSERT
argument_list|(
name|rpool
operator|->
name|sm_bigobjectsize
operator|<=
name|rpool
operator|->
name|sm_poolsize
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|sm_rpool_allocblock
argument_list|(
name|rpool
argument_list|,
name|rpool
operator|->
name|sm_poolsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|rpool
operator|->
name|sm_poolptr
operator|=
name|ptr
operator|+
name|size
expr_stmt|;
name|rpool
operator|->
name|sm_poolavail
operator|=
name|rpool
operator|->
name|sm_poolsize
operator|-
name|size
expr_stmt|;
if|#
directive|if
name|_FFR_PERF_RPOOL
operator|++
name|rpool
operator|->
name|sm_npools
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_PERF_RPOOL */
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* **  SM_RPOOL_NEW_X -- create a new rpool. ** **	Parameters: **		parent -- pointer to parent rpool, can be NULL. ** **	Returns: **		Pointer to new rpool. */
end_comment

begin_function
name|SM_RPOOL_T
modifier|*
name|sm_rpool_new_x
parameter_list|(
name|parent
parameter_list|)
name|SM_RPOOL_T
modifier|*
name|parent
decl_stmt|;
block|{
name|SM_RPOOL_T
modifier|*
name|rpool
decl_stmt|;
name|rpool
operator|=
name|sm_malloc_x
argument_list|(
sizeof|sizeof
argument_list|(
name|SM_RPOOL_T
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|==
name|NULL
condition|)
name|rpool
operator|->
name|sm_parentlink
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|SM_TRY
name|rpool
operator|->
name|sm_parentlink
init|=
name|sm_rpool_attach_x
argument_list|(
name|parent
argument_list|,
operator|(
name|SM_RPOOL_RFREE_T
operator|)
name|sm_rpool_free
argument_list|,
operator|(
name|void
operator|*
operator|)
name|rpool
argument_list|)
decl_stmt|;
name|SM_EXCEPT
argument_list|(
argument|exc
argument_list|,
literal|"*"
argument_list|)
name|sm_free
argument_list|(
name|rpool
argument_list|)
expr_stmt|;
name|sm_exc_raise_x
argument_list|(
name|exc
argument_list|)
expr_stmt|;
name|SM_END_TRY
block|}
name|rpool
operator|->
name|sm_magic
operator|=
name|SmRpoolMagic
expr_stmt|;
name|rpool
operator|->
name|sm_poolsize
operator|=
name|POOLSIZE
operator|-
sizeof|sizeof
argument_list|(
name|SM_POOLHDR_T
argument_list|)
expr_stmt|;
name|rpool
operator|->
name|sm_bigobjectsize
operator|=
name|rpool
operator|->
name|sm_poolsize
operator|/
name|BIG_OBJECT_RATIO
expr_stmt|;
name|rpool
operator|->
name|sm_poolptr
operator|=
name|NULL
expr_stmt|;
name|rpool
operator|->
name|sm_poolavail
operator|=
literal|0
expr_stmt|;
name|rpool
operator|->
name|sm_pools
operator|=
name|NULL
expr_stmt|;
name|rpool
operator|->
name|sm_rptr
operator|=
name|NULL
expr_stmt|;
name|rpool
operator|->
name|sm_ravail
operator|=
literal|0
expr_stmt|;
name|rpool
operator|->
name|sm_rlists
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|_FFR_PERF_RPOOL
name|rpool
operator|->
name|sm_nbigblocks
operator|=
literal|0
expr_stmt|;
name|rpool
operator|->
name|sm_npools
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_PERF_RPOOL */
return|return
name|rpool
return|;
block|}
end_function

begin_comment
comment|/* **  SM_RPOOL_SETSIZES -- set sizes for rpool. ** **	Parameters: **		poolsize -- size of a single rpool block. **		bigobjectsize -- if this size is exceeded, an individual **			block is allocated (must be less or equal poolsize). ** **	Returns: **		none. */
end_comment

begin_function
name|void
name|sm_rpool_setsizes
parameter_list|(
name|rpool
parameter_list|,
name|poolsize
parameter_list|,
name|bigobjectsize
parameter_list|)
name|SM_RPOOL_T
modifier|*
name|rpool
decl_stmt|;
name|size_t
name|poolsize
decl_stmt|;
name|size_t
name|bigobjectsize
decl_stmt|;
block|{
name|SM_REQUIRE
argument_list|(
name|poolsize
operator|>=
name|bigobjectsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|poolsize
operator|==
literal|0
condition|)
name|poolsize
operator|=
name|POOLSIZE
operator|-
sizeof|sizeof
argument_list|(
name|SM_POOLHDR_T
argument_list|)
expr_stmt|;
if|if
condition|(
name|bigobjectsize
operator|==
literal|0
condition|)
name|bigobjectsize
operator|=
name|poolsize
operator|/
name|BIG_OBJECT_RATIO
expr_stmt|;
name|rpool
operator|->
name|sm_poolsize
operator|=
name|poolsize
expr_stmt|;
name|rpool
operator|->
name|sm_bigobjectsize
operator|=
name|bigobjectsize
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  SM_RPOOL_FREE -- free an rpool and release all of its resources. ** **	Parameters: **		rpool -- rpool to free. ** **	Returns: **		none. */
end_comment

begin_function
name|void
name|sm_rpool_free
parameter_list|(
name|rpool
parameter_list|)
name|SM_RPOOL_T
modifier|*
name|rpool
decl_stmt|;
block|{
name|SM_RLIST_T
modifier|*
name|rl
decl_stmt|,
modifier|*
name|rnext
decl_stmt|;
name|SM_RESOURCE_T
modifier|*
name|r
decl_stmt|,
modifier|*
name|rmax
decl_stmt|;
name|SM_POOLLINK_T
modifier|*
name|pp
decl_stmt|,
modifier|*
name|pnext
decl_stmt|;
if|if
condition|(
name|rpool
operator|==
name|NULL
condition|)
return|return;
comment|/* 	**  It's important to free the resources before the memory pools, 	**  because the resource free functions might modify the contents 	**  of the memory pools. 	*/
name|rl
operator|=
name|rpool
operator|->
name|sm_rlists
expr_stmt|;
if|if
condition|(
name|rl
operator|!=
name|NULL
condition|)
block|{
name|rmax
operator|=
name|rpool
operator|->
name|sm_rptr
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
name|r
operator|=
name|rl
operator|->
name|sm_rvec
init|;
name|r
operator|<
name|rmax
condition|;
operator|++
name|r
control|)
block|{
if|if
condition|(
name|r
operator|->
name|sm_rfree
operator|!=
name|NULL
condition|)
name|r
operator|->
name|sm_rfree
argument_list|(
name|r
operator|->
name|sm_rcontext
argument_list|)
expr_stmt|;
block|}
name|rnext
operator|=
name|rl
operator|->
name|sm_rnext
expr_stmt|;
name|sm_free
argument_list|(
name|rl
argument_list|)
expr_stmt|;
if|if
condition|(
name|rnext
operator|==
name|NULL
condition|)
break|break;
name|rl
operator|=
name|rnext
expr_stmt|;
name|rmax
operator|=
operator|&
name|rl
operator|->
name|sm_rvec
index|[
name|SM_RLIST_MAX
index|]
expr_stmt|;
block|}
block|}
comment|/* 	**  Now free the memory pools. 	*/
for|for
control|(
name|pp
operator|=
name|rpool
operator|->
name|sm_pools
init|;
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
name|pnext
control|)
block|{
name|pnext
operator|=
name|pp
operator|->
name|sm_pnext
expr_stmt|;
name|sm_free
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Disconnect rpool from its parent. 	*/
if|if
condition|(
name|rpool
operator|->
name|sm_parentlink
operator|!=
name|NULL
condition|)
operator|*
name|rpool
operator|->
name|sm_parentlink
operator|=
name|NULL
expr_stmt|;
comment|/* 	**  Setting these fields to zero means that any future to attempt 	**  to use the rpool after it is freed will cause an assertion failure. 	*/
name|rpool
operator|->
name|sm_magic
operator|=
name|NULL
expr_stmt|;
name|rpool
operator|->
name|sm_poolavail
operator|=
literal|0
expr_stmt|;
name|rpool
operator|->
name|sm_ravail
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|_FFR_PERF_RPOOL
if|if
condition|(
name|rpool
operator|->
name|sm_nbigblocks
operator|>
literal|0
operator|||
name|rpool
operator|->
name|sm_npools
operator|>
literal|1
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"perf: rpool=%lx, sm_nbigblocks=%d, sm_npools=%d"
argument_list|,
operator|(
name|long
operator|)
name|rpool
argument_list|,
name|rpool
operator|->
name|sm_nbigblocks
argument_list|,
name|rpool
operator|->
name|sm_npools
argument_list|)
expr_stmt|;
name|rpool
operator|->
name|sm_nbigblocks
operator|=
literal|0
expr_stmt|;
name|rpool
operator|->
name|sm_npools
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_PERF_RPOOL */
name|sm_free
argument_list|(
name|rpool
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  SM_RPOOL_ATTACH_X -- attach a resource to an rpool. ** **	Parameters: **		rpool -- rpool to which resource should be attached. **		rfree -- function to call when rpool is freed. **		rcontext -- argument for function to call when rpool is freed. ** **	Returns: **		Pointer to allocated function. ** **	Exceptions: **		F:sm_heap -- out of memory */
end_comment

begin_function
name|SM_RPOOL_ATTACH_T
name|sm_rpool_attach_x
parameter_list|(
name|rpool
parameter_list|,
name|rfree
parameter_list|,
name|rcontext
parameter_list|)
name|SM_RPOOL_T
modifier|*
name|rpool
decl_stmt|;
name|SM_RPOOL_RFREE_T
name|rfree
decl_stmt|;
name|void
modifier|*
name|rcontext
decl_stmt|;
block|{
name|SM_RLIST_T
modifier|*
name|rl
decl_stmt|;
name|SM_RPOOL_ATTACH_T
name|a
decl_stmt|;
name|SM_REQUIRE_ISA
argument_list|(
name|rpool
argument_list|,
name|SmRpoolMagic
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpool
operator|->
name|sm_ravail
operator|==
literal|0
condition|)
block|{
name|rl
operator|=
name|sm_malloc_x
argument_list|(
sizeof|sizeof
argument_list|(
name|SM_RLIST_T
argument_list|)
argument_list|)
expr_stmt|;
name|rl
operator|->
name|sm_rnext
operator|=
name|rpool
operator|->
name|sm_rlists
expr_stmt|;
name|rpool
operator|->
name|sm_rlists
operator|=
name|rl
expr_stmt|;
name|rpool
operator|->
name|sm_rptr
operator|=
name|rl
operator|->
name|sm_rvec
expr_stmt|;
name|rpool
operator|->
name|sm_ravail
operator|=
name|SM_RLIST_MAX
expr_stmt|;
block|}
name|a
operator|=
operator|&
name|rpool
operator|->
name|sm_rptr
operator|->
name|sm_rfree
expr_stmt|;
name|rpool
operator|->
name|sm_rptr
operator|->
name|sm_rfree
operator|=
name|rfree
expr_stmt|;
name|rpool
operator|->
name|sm_rptr
operator|->
name|sm_rcontext
operator|=
name|rcontext
expr_stmt|;
operator|++
name|rpool
operator|->
name|sm_rptr
expr_stmt|;
operator|--
name|rpool
operator|->
name|sm_ravail
expr_stmt|;
return|return
name|a
return|;
block|}
end_function

end_unit

