begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2001 Sendmail, Inc. and its suppliers.  *      All rights reserved.  * Copyright (c) 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Chris Torek.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  */
end_comment

begin_include
include|#
directive|include
file|<sm/gen.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: fseek.c,v 1.45 2001/09/11 04:04:48 gshapiro Exp $"
argument_list|)
end_macro

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sm/signal.h>
end_include

begin_include
include|#
directive|include
file|<sm/io.h>
end_include

begin_include
include|#
directive|include
file|<sm/assert.h>
end_include

begin_include
include|#
directive|include
file|<sm/clock.h>
end_include

begin_include
include|#
directive|include
file|"local.h"
end_include

begin_define
define|#
directive|define
name|POS_ERR
value|(-(off_t)1)
end_define

begin_decl_stmt
specifier|static
name|jmp_buf
name|SeekTimeOut
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  SEEKALRM -- handler when timeout activated for sm_io_seek() ** **  Returns flow of control to where setjmp(SeekTimeOut) was set. ** **	Parameters: **		sig -- unused ** **	Returns: **		does not return ** **	Side Effects: **		returns flow of control to setjmp(SeekTimeOut). ** **	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD **		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE **		DOING. */
end_comment

begin_comment
comment|/* ARGSUSED0 */
end_comment

begin_function
specifier|static
name|void
name|seekalrm
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|longjmp
argument_list|(
name|SeekTimeOut
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  SM_IO_SEEK -- position the file pointer ** **	Parameters: **		fp -- the file pointer to be seek'd **		timeout -- time to complete seek (milliseconds) **		offset -- seek offset based on 'whence' **		whence -- indicates where seek is relative from. **			One of SM_IO_SEEK_{CUR,SET,END}. **	Returns: **		Failure: returns -1 (minus 1) and sets errno **		Success: returns 0 (zero) */
end_comment

begin_function
name|int
name|sm_io_seek
parameter_list|(
name|fp
parameter_list|,
name|timeout
parameter_list|,
name|offset
parameter_list|,
name|whence
parameter_list|)
specifier|register
name|SM_FILE_T
modifier|*
name|fp
decl_stmt|;
name|int
name|SM_NONVOLATILE
name|timeout
decl_stmt|;
name|long
name|SM_NONVOLATILE
name|offset
decl_stmt|;
name|int
name|SM_NONVOLATILE
name|whence
decl_stmt|;
block|{
name|bool
name|havepos
decl_stmt|;
name|off_t
name|target
decl_stmt|,
name|curoff
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|SM_EVENT
modifier|*
name|evt
init|=
name|NULL
decl_stmt|;
specifier|register
name|off_t
argument_list|(
argument|*seekfn
argument_list|)
name|__P
argument_list|(
operator|(
name|SM_FILE_T
operator|*
operator|,
name|off_t
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
name|SM_REQUIRE_ISA
argument_list|(
name|fp
argument_list|,
name|SmFileMagic
argument_list|)
expr_stmt|;
comment|/* make sure stdio is set up */
if|if
condition|(
operator|!
name|Sm_IO_DidInit
condition|)
name|sm_init
argument_list|()
expr_stmt|;
comment|/* Have to be able to seek. */
if|if
condition|(
operator|(
name|seekfn
operator|=
name|fp
operator|->
name|f_seek
operator|)
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ESPIPE
expr_stmt|;
comment|/* historic practice */
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|timeout
operator|==
name|SM_TIME_DEFAULT
condition|)
name|timeout
operator|=
name|fp
operator|->
name|f_timeout
expr_stmt|;
if|if
condition|(
name|timeout
operator|==
name|SM_TIME_IMMEDIATE
condition|)
block|{
comment|/* 		**  Filling the buffer will take time and we are wanted to 		**  return immediately. So... 		*/
name|errno
operator|=
name|EAGAIN
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
define|#
directive|define
name|SM_SET_ALARM
parameter_list|()
define|\
value|if (timeout != SM_TIME_FOREVER)				\ 	{							\ 		if (setjmp(SeekTimeOut) != 0)			\ 		{						\ 			errno = EAGAIN;				\ 			return -1;				\ 		}						\ 		evt = sm_seteventm(timeout, seekalrm, 0);	\ 	}
comment|/* 	**  Change any SM_IO_SEEK_CUR to SM_IO_SEEK_SET, and check `whence' 	**  argument. After this, whence is either SM_IO_SEEK_SET or 	**  SM_IO_SEEK_END. 	*/
switch|switch
condition|(
name|whence
condition|)
block|{
case|case
name|SM_IO_SEEK_CUR
case|:
comment|/* 		**  In order to seek relative to the current stream offset, 		**  we have to first find the current stream offset a la 		**  ftell (see ftell for details). 		*/
comment|/* may adjust seek offset on append stream */
name|sm_flush
argument_list|(
name|fp
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|timeout
argument_list|)
expr_stmt|;
name|SM_SET_ALARM
argument_list|()
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
name|SMOFF
condition|)
name|curoff
operator|=
name|fp
operator|->
name|f_lseekoff
expr_stmt|;
else|else
block|{
name|curoff
operator|=
call|(
modifier|*
name|seekfn
call|)
argument_list|(
name|fp
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SM_IO_SEEK_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|curoff
operator|==
operator|-
literal|1L
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|clean
goto|;
block|}
block|}
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
name|SMRD
condition|)
block|{
name|curoff
operator|-=
name|fp
operator|->
name|f_r
expr_stmt|;
if|if
condition|(
name|HASUB
argument_list|(
name|fp
argument_list|)
condition|)
name|curoff
operator|-=
name|fp
operator|->
name|f_ur
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
name|SMWR
operator|&&
name|fp
operator|->
name|f_p
operator|!=
name|NULL
condition|)
name|curoff
operator|+=
name|fp
operator|->
name|f_p
operator|-
name|fp
operator|->
name|f_bf
operator|.
name|smb_base
expr_stmt|;
name|offset
operator|+=
name|curoff
expr_stmt|;
name|whence
operator|=
name|SM_IO_SEEK_SET
expr_stmt|;
name|havepos
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|SM_IO_SEEK_SET
case|:
case|case
name|SM_IO_SEEK_END
case|:
name|SM_SET_ALARM
argument_list|()
expr_stmt|;
name|curoff
operator|=
literal|0
expr_stmt|;
comment|/* XXX just to keep gcc quiet */
name|havepos
operator|=
name|false
expr_stmt|;
break|break;
default|default:
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	**  Can only optimise if: 	**	reading (and not reading-and-writing); 	**	not unbuffered; and 	**	this is a `regular' Unix file (and hence seekfn==sm_stdseek). 	**  We must check SMNBF first, because it is possible to have SMNBF 	**  and SMSOPT both set. 	*/
if|if
condition|(
name|fp
operator|->
name|f_bf
operator|.
name|smb_base
operator|==
name|NULL
condition|)
name|sm_makebuf
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
operator|(
name|SMWR
operator||
name|SMRW
operator||
name|SMNBF
operator||
name|SMNPT
operator|)
condition|)
goto|goto
name|dumb
goto|;
if|if
condition|(
operator|(
name|fp
operator|->
name|f_flags
operator|&
name|SMOPT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|seekfn
operator|!=
name|sm_stdseek
operator|||
name|fp
operator|->
name|f_file
operator|<
literal|0
operator|||
name|fstat
argument_list|(
name|fp
operator|->
name|f_file
argument_list|,
operator|&
name|st
argument_list|)
operator|||
operator|(
name|st
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFREG
condition|)
block|{
name|fp
operator|->
name|f_flags
operator||=
name|SMNPT
expr_stmt|;
goto|goto
name|dumb
goto|;
block|}
name|fp
operator|->
name|f_blksize
operator|=
name|st
operator|.
name|st_blksize
expr_stmt|;
name|fp
operator|->
name|f_flags
operator||=
name|SMOPT
expr_stmt|;
block|}
comment|/* 	**  We are reading; we can try to optimise. 	**  Figure out where we are going and where we are now. 	*/
if|if
condition|(
name|whence
operator|==
name|SM_IO_SEEK_SET
condition|)
name|target
operator|=
name|offset
expr_stmt|;
else|else
block|{
if|if
condition|(
name|fstat
argument_list|(
name|fp
operator|->
name|f_file
argument_list|,
operator|&
name|st
argument_list|)
condition|)
goto|goto
name|dumb
goto|;
name|target
operator|=
name|st
operator|.
name|st_size
operator|+
name|offset
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|havepos
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
name|SMOFF
condition|)
name|curoff
operator|=
name|fp
operator|->
name|f_lseekoff
expr_stmt|;
else|else
block|{
name|curoff
operator|=
call|(
modifier|*
name|seekfn
call|)
argument_list|(
name|fp
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SM_IO_SEEK_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|curoff
operator|==
name|POS_ERR
condition|)
goto|goto
name|dumb
goto|;
block|}
name|curoff
operator|-=
name|fp
operator|->
name|f_r
expr_stmt|;
if|if
condition|(
name|HASUB
argument_list|(
name|fp
argument_list|)
condition|)
name|curoff
operator|-=
name|fp
operator|->
name|f_ur
expr_stmt|;
block|}
comment|/* 	**  Compute the number of bytes in the input buffer (pretending 	**  that any ungetc() input has been discarded).  Adjust current 	**  offset backwards by this count so that it represents the 	**  file offset for the first byte in the current input buffer. 	*/
if|if
condition|(
name|HASUB
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|curoff
operator|+=
name|fp
operator|->
name|f_r
expr_stmt|;
comment|/* kill off ungetc */
name|n
operator|=
name|fp
operator|->
name|f_up
operator|-
name|fp
operator|->
name|f_bf
operator|.
name|smb_base
expr_stmt|;
name|curoff
operator|-=
name|n
expr_stmt|;
name|n
operator|+=
name|fp
operator|->
name|f_ur
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|fp
operator|->
name|f_p
operator|-
name|fp
operator|->
name|f_bf
operator|.
name|smb_base
expr_stmt|;
name|curoff
operator|-=
name|n
expr_stmt|;
name|n
operator|+=
name|fp
operator|->
name|f_r
expr_stmt|;
block|}
comment|/* 	**  If the target offset is within the current buffer, 	**  simply adjust the pointers, clear SMFEOF, undo ungetc(), 	**  and return.  (If the buffer was modified, we have to 	**  skip this; see getln in fget.c.) 	*/
if|if
condition|(
name|target
operator|>=
name|curoff
operator|&&
name|target
operator|<
name|curoff
operator|+
operator|(
name|off_t
operator|)
name|n
condition|)
block|{
specifier|register
name|int
name|o
init|=
name|target
operator|-
name|curoff
decl_stmt|;
name|fp
operator|->
name|f_p
operator|=
name|fp
operator|->
name|f_bf
operator|.
name|smb_base
operator|+
name|o
expr_stmt|;
name|fp
operator|->
name|f_r
operator|=
name|n
operator|-
name|o
expr_stmt|;
if|if
condition|(
name|HASUB
argument_list|(
name|fp
argument_list|)
condition|)
name|FREEUB
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_flags
operator|&=
operator|~
name|SMFEOF
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
goto|goto
name|clean
goto|;
block|}
comment|/* 	**  The place we want to get to is not within the current buffer, 	**  but we can still be kind to the kernel copyout mechanism. 	**  By aligning the file offset to a block boundary, we can let 	**  the kernel use the VM hardware to map pages instead of 	**  copying bytes laboriously.  Using a block boundary also 	**  ensures that we only read one block, rather than two. 	*/
name|curoff
operator|=
name|target
operator|&
operator|~
operator|(
name|fp
operator|->
name|f_blksize
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|seekfn
call|)
argument_list|(
name|fp
argument_list|,
name|curoff
argument_list|,
name|SM_IO_SEEK_SET
argument_list|)
operator|==
name|POS_ERR
condition|)
goto|goto
name|dumb
goto|;
name|fp
operator|->
name|f_r
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|f_p
operator|=
name|fp
operator|->
name|f_bf
operator|.
name|smb_base
expr_stmt|;
if|if
condition|(
name|HASUB
argument_list|(
name|fp
argument_list|)
condition|)
name|FREEUB
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_flags
operator|&=
operator|~
name|SMFEOF
expr_stmt|;
name|n
operator|=
name|target
operator|-
name|curoff
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
comment|/* Note: SM_TIME_FOREVER since fn timeout already set */
if|if
condition|(
name|sm_refill
argument_list|(
name|fp
argument_list|,
name|SM_TIME_FOREVER
argument_list|)
operator|||
name|fp
operator|->
name|f_r
operator|<
operator|(
name|int
operator|)
name|n
condition|)
goto|goto
name|dumb
goto|;
name|fp
operator|->
name|f_p
operator|+=
name|n
expr_stmt|;
name|fp
operator|->
name|f_r
operator|-=
name|n
expr_stmt|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
name|clean
label|:
comment|/*  We're back. So undo our timeout and handler */
if|if
condition|(
name|evt
operator|!=
name|NULL
condition|)
name|sm_clrevent
argument_list|(
name|evt
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
name|dumb
label|:
comment|/* 	**  We get here if we cannot optimise the seek ... just 	**  do it.  Allow the seek function to change fp->f_bf.smb_base. 	*/
comment|/* Note: SM_TIME_FOREVER since fn timeout already set */
name|ret
operator|=
name|SM_TIME_FOREVER
expr_stmt|;
if|if
condition|(
name|sm_flush
argument_list|(
name|fp
argument_list|,
operator|&
name|ret
argument_list|)
operator|!=
literal|0
operator|||
call|(
modifier|*
name|seekfn
call|)
argument_list|(
name|fp
argument_list|,
operator|(
name|off_t
operator|)
name|offset
argument_list|,
name|whence
argument_list|)
operator|==
name|POS_ERR
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|clean
goto|;
block|}
comment|/* success: clear SMFEOF indicator and discard ungetc() data */
if|if
condition|(
name|HASUB
argument_list|(
name|fp
argument_list|)
condition|)
name|FREEUB
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_p
operator|=
name|fp
operator|->
name|f_bf
operator|.
name|smb_base
expr_stmt|;
name|fp
operator|->
name|f_r
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|f_flags
operator|&=
operator|~
name|SMFEOF
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
goto|goto
name|clean
goto|;
block|}
end_function

end_unit

