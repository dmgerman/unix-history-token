begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2001 Proofpoint, Inc. and its suppliers.  *      All rights reserved.  * Copyright (c) 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Chris Torek.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  */
end_comment

begin_include
include|#
directive|include
file|<sm/gen.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: wbuf.c,v 1.22 2013/11/22 20:51:44 ca Exp $"
argument_list|)
end_macro

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sm/io.h>
end_include

begin_include
include|#
directive|include
file|"local.h"
end_include

begin_comment
comment|/* Note: This function is called from a macro located in<sm/io.h> */
end_comment

begin_comment
comment|/* **  SM_WBUF -- write character to and flush (likely now full) buffer ** **  Write the given character into the (probably full) buffer for **  the given file.  Flush the buffer out if it is or becomes full, **  or if c=='\n' and the file is line buffered. ** **	Parameters: **		fp -- the file pointer **		timeout -- time to complete operation (milliseconds) **		c -- int representation of the character to add ** **	Results: **		Failure: -1 and sets errno **		Success: int value of 'c' */
end_comment

begin_function
name|int
name|sm_wbuf
parameter_list|(
name|fp
parameter_list|,
name|timeout
parameter_list|,
name|c
parameter_list|)
specifier|register
name|SM_FILE_T
modifier|*
name|fp
decl_stmt|;
name|int
name|timeout
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
comment|/* 	**  In case we cannot write, or longjmp takes us out early, 	**  make sure w is 0 (if fully- or un-buffered) or -bf.smb_size 	**  (if line buffered) so that we will get called again. 	**  If we did not do this, a sufficient number of sm_io_putc() 	**  calls might wrap w from negative to positive. 	*/
name|fp
operator|->
name|f_w
operator|=
name|fp
operator|->
name|f_lbfsize
expr_stmt|;
if|if
condition|(
name|cantwrite
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
name|SM_IO_EOF
return|;
block|}
name|c
operator|=
operator|(
name|unsigned
name|char
operator|)
name|c
expr_stmt|;
comment|/* 	**  If it is completely full, flush it out.  Then, in any case, 	**  stuff c into the buffer.  If this causes the buffer to fill 	**  completely, or if c is '\n' and the file is line buffered, 	**  flush it (perhaps a second time).  The second flush will always 	**  happen on unbuffered streams, where bf.smb_size==1; sm_io_flush() 	**  guarantees that sm_io_putc() will always call sm_wbuf() by setting 	**  w to 0, so we need not do anything else. 	**  Note for the timeout, only one of the sm_io_flush's will get called. 	*/
name|n
operator|=
name|fp
operator|->
name|f_p
operator|-
name|fp
operator|->
name|f_bf
operator|.
name|smb_base
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|fp
operator|->
name|f_bf
operator|.
name|smb_size
condition|)
block|{
if|if
condition|(
name|sm_io_flush
argument_list|(
name|fp
argument_list|,
name|timeout
argument_list|)
condition|)
return|return
name|SM_IO_EOF
return|;
comment|/* sm_io_flush() sets errno */
name|n
operator|=
literal|0
expr_stmt|;
block|}
name|fp
operator|->
name|f_w
operator|--
expr_stmt|;
operator|*
name|fp
operator|->
name|f_p
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|++
name|n
operator|==
name|fp
operator|->
name|f_bf
operator|.
name|smb_size
operator|||
operator|(
name|fp
operator|->
name|f_flags
operator|&
name|SMLBF
operator|&&
name|c
operator|==
literal|'\n'
operator|)
condition|)
if|if
condition|(
name|sm_io_flush
argument_list|(
name|fp
argument_list|,
name|timeout
argument_list|)
condition|)
return|return
name|SM_IO_EOF
return|;
comment|/* sm_io_flush() sets errno */
return|return
name|c
return|;
block|}
end_function

end_unit

