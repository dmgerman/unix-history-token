begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2001-2002 Sendmail, Inc. and its suppliers.  *      All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  */
end_comment

begin_include
include|#
directive|include
file|<sm/gen.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: ldap.c,v 1.1.1.2 2002/04/10 03:04:55 gshapiro Exp $"
argument_list|)
end_macro

begin_if
if|#
directive|if
name|LDAPMAP
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sm/bitops.h>
end_include

begin_include
include|#
directive|include
file|<sm/clock.h>
end_include

begin_include
include|#
directive|include
file|<sm/conf.h>
end_include

begin_include
include|#
directive|include
file|<sm/debug.h>
end_include

begin_include
include|#
directive|include
file|<sm/errstring.h>
end_include

begin_include
include|#
directive|include
file|<sm/ldap.h>
end_include

begin_include
include|#
directive|include
file|<sm/string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EX_OK
end_ifdef

begin_undef
undef|#
directive|undef
name|EX_OK
end_undef

begin_comment
comment|/* for SVr4.2 SMP */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EX_OK */
end_comment

begin_include
include|#
directive|include
file|<sm/sysexits.h>
end_include

begin_decl_stmt
name|SM_DEBUG_T
name|SmLDAPTrace
init|=
name|SM_DEBUG_INITIALIZER
argument_list|(
literal|"sm_trace_ldap"
argument_list|,
literal|"@(#)$Debug: sm_trace_ldap - trace LDAP operations $"
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ldaptimeout
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  SM_LDAP_CLEAR -- set default values for SM_LDAP_STRUCT ** **	Parameters: **		lmap -- pointer to SM_LDAP_STRUCT to clear ** **	Returns: **		None. ** */
end_comment

begin_function
name|void
name|sm_ldap_clear
parameter_list|(
name|lmap
parameter_list|)
name|SM_LDAP_STRUCT
modifier|*
name|lmap
decl_stmt|;
block|{
if|if
condition|(
name|lmap
operator|==
name|NULL
condition|)
return|return;
name|lmap
operator|->
name|ldap_target
operator|=
name|NULL
expr_stmt|;
name|lmap
operator|->
name|ldap_port
operator|=
name|LDAP_PORT
expr_stmt|;
if|#
directive|if
name|_FFR_LDAP_URI
name|lmap
operator|->
name|ldap_uri
operator|=
name|false
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_LDAP_URI */
if|#
directive|if
name|_FFR_LDAP_SETVERSION
name|lmap
operator|->
name|ldap_version
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_LDAP_SETVERSION */
name|lmap
operator|->
name|ldap_deref
operator|=
name|LDAP_DEREF_NEVER
expr_stmt|;
name|lmap
operator|->
name|ldap_timelimit
operator|=
name|LDAP_NO_LIMIT
expr_stmt|;
name|lmap
operator|->
name|ldap_sizelimit
operator|=
name|LDAP_NO_LIMIT
expr_stmt|;
ifdef|#
directive|ifdef
name|LDAP_REFERRALS
name|lmap
operator|->
name|ldap_options
operator|=
name|LDAP_OPT_REFERRALS
expr_stmt|;
else|#
directive|else
comment|/* LDAP_REFERRALS */
name|lmap
operator|->
name|ldap_options
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* LDAP_REFERRALS */
name|lmap
operator|->
name|ldap_attrsep
operator|=
literal|'\0'
expr_stmt|;
name|lmap
operator|->
name|ldap_binddn
operator|=
name|NULL
expr_stmt|;
name|lmap
operator|->
name|ldap_secret
operator|=
name|NULL
expr_stmt|;
name|lmap
operator|->
name|ldap_method
operator|=
name|LDAP_AUTH_SIMPLE
expr_stmt|;
name|lmap
operator|->
name|ldap_base
operator|=
name|NULL
expr_stmt|;
name|lmap
operator|->
name|ldap_scope
operator|=
name|LDAP_SCOPE_SUBTREE
expr_stmt|;
name|lmap
operator|->
name|ldap_attrsonly
operator|=
name|LDAPMAP_FALSE
expr_stmt|;
name|lmap
operator|->
name|ldap_timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|lmap
operator|->
name|ldap_timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|lmap
operator|->
name|ldap_ld
operator|=
name|NULL
expr_stmt|;
name|lmap
operator|->
name|ldap_filter
operator|=
name|NULL
expr_stmt|;
name|lmap
operator|->
name|ldap_attr
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|_FFR_LDAP_RECURSION
name|lmap
operator|->
name|ldap_attr_type
index|[
literal|0
index|]
operator|=
name|SM_LDAP_ATTR_NONE
expr_stmt|;
name|lmap
operator|->
name|ldap_attr_needobjclass
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_LDAP_RECURSION */
name|lmap
operator|->
name|ldap_res
operator|=
name|NULL
expr_stmt|;
name|lmap
operator|->
name|ldap_next
operator|=
name|NULL
expr_stmt|;
name|lmap
operator|->
name|ldap_pid
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  SM_LDAP_START -- actually connect to an LDAP server ** **	Parameters: **		name -- name of map for debug output. **		lmap -- the LDAP map being opened. ** **	Returns: **		true if connection is successful, false otherwise. ** **	Side Effects: **		Populates lmap->ldap_ld. */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|LDAPTimeout
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SM_LDAP_SETTIMEOUT
parameter_list|(
name|to
parameter_list|)
define|\
value|do									\ {									\ 	if (to != 0)							\ 	{								\ 		if (setjmp(LDAPTimeout) != 0)				\ 		{							\ 			errno = ETIMEDOUT;				\ 			return false;					\ 		}							\ 		ev = sm_setevent(to, ldaptimeout, 0);			\ 	}								\ } while (0)
end_define

begin_define
define|#
directive|define
name|SM_LDAP_CLEARTIMEOUT
parameter_list|()
define|\
value|do									\ {									\ 	if (ev != NULL)							\ 		sm_clrevent(ev);					\ } while (0)
end_define

begin_function
name|bool
name|sm_ldap_start
parameter_list|(
name|name
parameter_list|,
name|lmap
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|SM_LDAP_STRUCT
modifier|*
name|lmap
decl_stmt|;
block|{
name|int
name|bind_result
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
name|SM_EVENT
modifier|*
name|ev
init|=
name|NULL
decl_stmt|;
name|LDAP
modifier|*
name|ld
decl_stmt|;
if|if
condition|(
name|sm_debug_active
argument_list|(
operator|&
name|SmLDAPTrace
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"ldapmap_start(%s)\n"
argument_list|,
name|name
operator|==
name|NULL
condition|?
literal|""
else|:
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm_debug_active
argument_list|(
operator|&
name|SmLDAPTrace
argument_list|,
literal|9
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"ldapmap_start(%s, %d)\n"
argument_list|,
name|lmap
operator|->
name|ldap_target
operator|==
name|NULL
condition|?
literal|"localhost"
else|:
name|lmap
operator|->
name|ldap_target
argument_list|,
name|lmap
operator|->
name|ldap_port
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_LDAP_INIT
if|#
directive|if
name|_FFR_LDAP_URI
if|if
condition|(
name|lmap
operator|->
name|ldap_uri
condition|)
name|errno
operator|=
name|ldap_initialize
argument_list|(
operator|&
name|ld
argument_list|,
name|lmap
operator|->
name|ldap_target
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* _FFR_LDAP_URI */
name|ld
operator|=
name|ldap_init
argument_list|(
name|lmap
operator|->
name|ldap_target
argument_list|,
name|lmap
operator|->
name|ldap_port
argument_list|)
expr_stmt|;
name|save_errno
operator|=
name|errno
expr_stmt|;
else|#
directive|else
comment|/* USE_LDAP_INIT */
comment|/* 	**  If using ldap_open(), the actual connection to the server 	**  happens now so we need the timeout here.  For ldap_init(), 	**  the connection happens at bind time. 	*/
name|SM_LDAP_SETTIMEOUT
argument_list|(
name|lmap
operator|->
name|ldap_timeout
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|ld
operator|=
name|ldap_open
argument_list|(
name|lmap
operator|->
name|ldap_target
argument_list|,
name|lmap
operator|->
name|ldap_port
argument_list|)
expr_stmt|;
name|save_errno
operator|=
name|errno
expr_stmt|;
comment|/* clear the event if it has not sprung */
name|SM_LDAP_CLEARTIMEOUT
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LDAP_INIT */
name|errno
operator|=
name|save_errno
expr_stmt|;
if|if
condition|(
name|ld
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|sm_ldap_setopts
argument_list|(
name|ld
argument_list|,
name|lmap
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_LDAP_INIT
comment|/* 	**  If using ldap_init(), the actual connection to the server 	**  happens at ldap_bind_s() so we need the timeout here. 	*/
name|SM_LDAP_SETTIMEOUT
argument_list|(
name|lmap
operator|->
name|ldap_timeout
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LDAP_INIT */
ifdef|#
directive|ifdef
name|LDAP_AUTH_KRBV4
if|if
condition|(
name|lmap
operator|->
name|ldap_method
operator|==
name|LDAP_AUTH_KRBV4
operator|&&
name|lmap
operator|->
name|ldap_secret
operator|!=
name|NULL
condition|)
block|{
comment|/* 		**  Need to put ticket in environment here instead of 		**  during parseargs as there may be different tickets 		**  for different LDAP connections. 		*/
operator|(
name|void
operator|)
name|putenv
argument_list|(
name|lmap
operator|->
name|ldap_secret
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* LDAP_AUTH_KRBV4 */
name|bind_result
operator|=
name|ldap_bind_s
argument_list|(
name|ld
argument_list|,
name|lmap
operator|->
name|ldap_binddn
argument_list|,
name|lmap
operator|->
name|ldap_secret
argument_list|,
name|lmap
operator|->
name|ldap_method
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_LDAP_INIT
comment|/* clear the event if it has not sprung */
name|SM_LDAP_CLEARTIMEOUT
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LDAP_INIT */
if|if
condition|(
name|bind_result
operator|!=
name|LDAP_SUCCESS
condition|)
block|{
name|errno
operator|=
name|bind_result
operator|+
name|E_LDAPBASE
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Save PID to make sure only this PID closes the LDAP connection */
name|lmap
operator|->
name|ldap_pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|lmap
operator|->
name|ldap_ld
operator|=
name|ld
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|ldaptimeout
parameter_list|(
name|unused
parameter_list|)
name|int
name|unused
decl_stmt|;
block|{
comment|/* 	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD 	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE 	**	DOING. 	*/
name|errno
operator|=
name|ETIMEDOUT
expr_stmt|;
name|longjmp
argument_list|(
name|LDAPTimeout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  SM_LDAP_SEARCH -- iniate LDAP search ** **	Initiate an LDAP search, return the msgid. **	The calling function must collect the results. ** **	Parameters: **		lmap -- LDAP map information **		key -- key to substitute in LDAP filter ** **	Returns: **		-1 on failure, msgid on success ** */
end_comment

begin_function
name|int
name|sm_ldap_search
parameter_list|(
name|lmap
parameter_list|,
name|key
parameter_list|)
name|SM_LDAP_STRUCT
modifier|*
name|lmap
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
block|{
name|int
name|msgid
decl_stmt|;
name|char
modifier|*
name|fp
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
name|filter
index|[
name|LDAPMAP_MAX_FILTER
operator|+
literal|1
index|]
decl_stmt|;
comment|/* substitute key into filter, perhaps multiple times */
name|memset
argument_list|(
name|filter
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|filter
argument_list|)
expr_stmt|;
name|fp
operator|=
name|filter
expr_stmt|;
name|p
operator|=
name|lmap
operator|->
name|ldap_filter
expr_stmt|;
while|while
condition|(
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'%'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|q
index|[
literal|1
index|]
operator|==
literal|'s'
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|fp
argument_list|,
name|SPACELEFT
argument_list|(
name|filter
argument_list|,
name|fp
argument_list|)
argument_list|,
literal|"%.*s%s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|q
operator|-
name|p
argument_list|)
argument_list|,
name|p
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|fp
operator|+=
name|strlen
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
operator|+
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
index|[
literal|1
index|]
operator|==
literal|'0'
condition|)
block|{
name|char
modifier|*
name|k
init|=
name|key
decl_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|fp
argument_list|,
name|SPACELEFT
argument_list|(
name|filter
argument_list|,
name|fp
argument_list|)
argument_list|,
literal|"%.*s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|q
operator|-
name|p
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|fp
operator|+=
name|strlen
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
operator|+
literal|2
expr_stmt|;
comment|/* Properly escape LDAP special characters */
while|while
condition|(
name|SPACELEFT
argument_list|(
name|filter
argument_list|,
name|fp
argument_list|)
operator|>
literal|0
operator|&&
operator|*
name|k
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|k
operator|==
literal|'*'
operator|||
operator|*
name|k
operator|==
literal|'('
operator|||
operator|*
name|k
operator|==
literal|')'
operator|||
operator|*
name|k
operator|==
literal|'\\'
condition|)
block|{
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|fp
argument_list|,
operator|(
operator|*
name|k
operator|==
literal|'*'
condition|?
literal|"\\2A"
else|:
operator|(
operator|*
name|k
operator|==
literal|'('
condition|?
literal|"\\28"
else|:
operator|(
operator|*
name|k
operator|==
literal|')'
condition|?
literal|"\\29"
else|:
operator|(
operator|*
name|k
operator|==
literal|'\\'
condition|?
literal|"\\5C"
else|:
literal|"\00"
operator|)
operator|)
operator|)
operator|)
argument_list|,
name|SPACELEFT
argument_list|(
name|filter
argument_list|,
name|fp
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|+=
name|strlen
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|fp
operator|++
operator|=
operator|*
name|k
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|fp
argument_list|,
name|SPACELEFT
argument_list|(
name|filter
argument_list|,
name|fp
argument_list|)
argument_list|,
literal|"%.*s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|q
operator|-
name|p
operator|+
literal|1
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
operator|+
operator|(
name|q
index|[
literal|1
index|]
operator|==
literal|'%'
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
name|fp
operator|+=
name|strlen
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|fp
argument_list|,
name|p
argument_list|,
name|SPACELEFT
argument_list|(
name|filter
argument_list|,
name|fp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm_debug_active
argument_list|(
operator|&
name|SmLDAPTrace
argument_list|,
literal|20
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"ldap search filter=%s\n"
argument_list|,
name|filter
argument_list|)
expr_stmt|;
name|lmap
operator|->
name|ldap_res
operator|=
name|NULL
expr_stmt|;
name|msgid
operator|=
name|ldap_search
argument_list|(
name|lmap
operator|->
name|ldap_ld
argument_list|,
name|lmap
operator|->
name|ldap_base
argument_list|,
name|lmap
operator|->
name|ldap_scope
argument_list|,
name|filter
argument_list|,
operator|(
name|lmap
operator|->
name|ldap_attr
index|[
literal|0
index|]
operator|==
name|NULL
condition|?
name|NULL
else|:
name|lmap
operator|->
name|ldap_attr
operator|)
argument_list|,
name|lmap
operator|->
name|ldap_attrsonly
argument_list|)
expr_stmt|;
return|return
name|msgid
return|;
block|}
end_function

begin_if
if|#
directive|if
name|_FFR_LDAP_RECURSION
end_if

begin_comment
comment|/* **  SM_LDAP_HAS_OBJECTCLASS -- determine if an LDAP entry is part of a **			       particular objectClass ** **	Parameters: **		lmap -- pointer to SM_LDAP_STRUCT in use **		entry -- current LDAP entry struct **		ocvalue -- particular objectclass in question. **			   may be of form (fee|foo|fum) meaning **			   any entry can be part of either fee, **			   foo or fum objectclass ** **	Returns: **		true if item has that objectClass */
end_comment

begin_function
specifier|static
name|bool
name|sm_ldap_has_objectclass
parameter_list|(
name|lmap
parameter_list|,
name|entry
parameter_list|,
name|ocvalue
parameter_list|)
name|SM_LDAP_STRUCT
modifier|*
name|lmap
decl_stmt|;
name|LDAPMessage
modifier|*
name|entry
decl_stmt|;
name|char
modifier|*
name|ocvalue
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|vals
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ocvalue
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|vals
operator|=
name|ldap_get_values
argument_list|(
name|lmap
operator|->
name|ldap_ld
argument_list|,
name|entry
argument_list|,
literal|"objectClass"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vals
operator|==
name|NULL
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|vals
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|q
operator|=
name|ocvalue
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|'|'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|-
name|q
operator|)
operator|==
name|strlen
argument_list|(
name|vals
index|[
name|i
index|]
argument_list|)
operator|&&
name|sm_strncasecmp
argument_list|(
name|vals
index|[
name|i
index|]
argument_list|,
name|q
argument_list|,
name|p
operator|-
name|q
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ldap_value_free
argument_list|(
name|vals
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
while|while
condition|(
operator|*
name|p
operator|==
literal|'|'
condition|)
name|p
operator|++
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
block|}
block|}
name|ldap_value_free
argument_list|(
name|vals
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* **  SM_LDAP_RESULTS -- return results from an LDAP lookup in result ** **	Parameters: **		lmap -- pointer to SM_LDAP_STRUCT in use **		msgid -- msgid returned by sm_ldap_search() **		flags -- flags for the lookup **		delim -- delimiter for result concatenation **		rpool -- memory pool for storage **		result -- return string **		recurse -- recursion list ** **	Returns: **		status (sysexit) */
end_comment

begin_define
define|#
directive|define
name|SM_LDAP_ERROR_CLEANUP
parameter_list|()
define|\
value|{								\ 	if (lmap->ldap_res != NULL)				\ 	{							\ 		ldap_msgfree(lmap->ldap_res);			\ 		lmap->ldap_res = NULL;				\ 	}							\ 	(void) ldap_abandon(lmap->ldap_ld, msgid);		\ }
end_define

begin_function
specifier|static
name|SM_LDAP_RECURSE_ENTRY
modifier|*
name|sm_ldap_add_recurse
parameter_list|(
name|top
parameter_list|,
name|item
parameter_list|,
name|type
parameter_list|,
name|rpool
parameter_list|)
name|SM_LDAP_RECURSE_LIST
modifier|*
modifier|*
name|top
decl_stmt|;
name|char
modifier|*
name|item
decl_stmt|;
name|int
name|type
decl_stmt|;
name|SM_RPOOL_T
modifier|*
name|rpool
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|int
name|m
decl_stmt|;
name|int
name|p
decl_stmt|;
name|int
name|insertat
decl_stmt|;
name|int
name|moveb
decl_stmt|;
name|int
name|oldsizeb
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|SM_LDAP_RECURSE_ENTRY
modifier|*
name|newe
decl_stmt|;
name|SM_LDAP_RECURSE_ENTRY
modifier|*
modifier|*
name|olddata
decl_stmt|;
comment|/* 	**  This code will maintain a list of 	**  SM_LDAP_RECURSE_ENTRY structures 	**  in ascending order. 	*/
if|if
condition|(
operator|*
name|top
operator|==
name|NULL
condition|)
block|{
comment|/* Allocate an initial SM_LDAP_RECURSE_LIST struct */
operator|*
name|top
operator|=
name|sm_rpool_malloc_x
argument_list|(
name|rpool
argument_list|,
sizeof|sizeof
expr|*
operator|*
name|top
argument_list|)
expr_stmt|;
operator|(
operator|*
name|top
operator|)
operator|->
name|lr_cnt
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|top
operator|)
operator|->
name|lr_size
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|top
operator|)
operator|->
name|lr_data
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|top
operator|)
operator|->
name|lr_cnt
operator|>=
operator|(
operator|*
name|top
operator|)
operator|->
name|lr_size
condition|)
block|{
comment|/* Grow the list of SM_LDAP_RECURSE_ENTRY ptrs */
name|olddata
operator|=
operator|(
operator|*
name|top
operator|)
operator|->
name|lr_data
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|top
operator|)
operator|->
name|lr_size
operator|==
literal|0
condition|)
block|{
name|oldsizeb
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|top
operator|)
operator|->
name|lr_size
operator|=
literal|256
expr_stmt|;
block|}
else|else
block|{
name|oldsizeb
operator|=
operator|(
operator|*
name|top
operator|)
operator|->
name|lr_size
operator|*
sizeof|sizeof
expr|*
operator|(
operator|(
operator|*
name|top
operator|)
operator|->
name|lr_data
operator|)
expr_stmt|;
operator|(
operator|*
name|top
operator|)
operator|->
name|lr_size
operator|*=
literal|2
expr_stmt|;
block|}
operator|(
operator|*
name|top
operator|)
operator|->
name|lr_data
operator|=
name|sm_rpool_malloc_x
argument_list|(
name|rpool
argument_list|,
operator|(
operator|*
name|top
operator|)
operator|->
name|lr_size
operator|*
sizeof|sizeof
expr|*
operator|(
operator|(
operator|*
name|top
operator|)
operator|->
name|lr_data
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldsizeb
operator|>
literal|0
condition|)
name|memcpy
argument_list|(
operator|(
operator|*
name|top
operator|)
operator|->
name|lr_data
argument_list|,
name|olddata
argument_list|,
name|oldsizeb
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Binary search/insert item:type into list. 	**  Return current entry pointer if already exists. 	*/
name|n
operator|=
literal|0
expr_stmt|;
name|m
operator|=
operator|(
operator|*
name|top
operator|)
operator|->
name|lr_cnt
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|m
operator|<
literal|0
condition|)
name|insertat
operator|=
literal|0
expr_stmt|;
else|else
name|insertat
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|insertat
operator|==
operator|-
literal|1
condition|)
block|{
name|p
operator|=
operator|(
name|m
operator|+
name|n
operator|)
operator|/
literal|2
expr_stmt|;
name|rc
operator|=
name|sm_strcasecmp
argument_list|(
name|item
argument_list|,
operator|(
operator|*
name|top
operator|)
operator|->
name|lr_data
index|[
name|p
index|]
operator|->
name|lr_search
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|rc
operator|=
name|type
operator|-
operator|(
operator|*
name|top
operator|)
operator|->
name|lr_data
index|[
name|p
index|]
operator|->
name|lr_type
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
name|m
operator|=
name|p
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
name|n
operator|=
name|p
operator|+
literal|1
expr_stmt|;
else|else
return|return
operator|(
operator|*
name|top
operator|)
operator|->
name|lr_data
index|[
name|p
index|]
return|;
if|if
condition|(
name|m
operator|==
operator|-
literal|1
condition|)
name|insertat
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|>=
operator|(
operator|*
name|top
operator|)
operator|->
name|lr_cnt
condition|)
name|insertat
operator|=
operator|(
operator|*
name|top
operator|)
operator|->
name|lr_cnt
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|<
name|n
condition|)
name|insertat
operator|=
name|m
operator|+
literal|1
expr_stmt|;
block|}
comment|/* 	** Not found in list, make room 	** at insert point and add it. 	*/
name|newe
operator|=
name|sm_rpool_malloc_x
argument_list|(
name|rpool
argument_list|,
sizeof|sizeof
expr|*
name|newe
argument_list|)
expr_stmt|;
if|if
condition|(
name|newe
operator|!=
name|NULL
condition|)
block|{
name|moveb
operator|=
operator|(
operator|(
operator|*
name|top
operator|)
operator|->
name|lr_cnt
operator|-
name|insertat
operator|)
operator|*
sizeof|sizeof
expr|*
operator|(
operator|(
operator|*
name|top
operator|)
operator|->
name|lr_data
operator|)
expr_stmt|;
if|if
condition|(
name|moveb
operator|>
literal|0
condition|)
name|memmove
argument_list|(
operator|&
operator|(
operator|(
operator|*
name|top
operator|)
operator|->
name|lr_data
index|[
name|insertat
operator|+
literal|1
index|]
operator|)
argument_list|,
operator|&
operator|(
operator|(
operator|*
name|top
operator|)
operator|->
name|lr_data
index|[
name|insertat
index|]
operator|)
argument_list|,
name|moveb
argument_list|)
expr_stmt|;
name|newe
operator|->
name|lr_search
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|rpool
argument_list|,
name|item
argument_list|)
expr_stmt|;
name|newe
operator|->
name|lr_type
operator|=
name|type
expr_stmt|;
name|newe
operator|->
name|lr_done
operator|=
name|false
expr_stmt|;
operator|(
operator|(
operator|*
name|top
operator|)
operator|->
name|lr_data
operator|)
index|[
name|insertat
index|]
operator|=
name|newe
expr_stmt|;
operator|(
operator|*
name|top
operator|)
operator|->
name|lr_cnt
operator|++
expr_stmt|;
block|}
return|return
name|newe
return|;
block|}
end_function

begin_function
name|int
name|sm_ldap_results
parameter_list|(
name|lmap
parameter_list|,
name|msgid
parameter_list|,
name|flags
parameter_list|,
name|delim
parameter_list|,
name|rpool
parameter_list|,
name|result
parameter_list|,
name|resultln
parameter_list|,
name|resultsz
parameter_list|,
name|recurse
parameter_list|)
name|SM_LDAP_STRUCT
modifier|*
name|lmap
decl_stmt|;
name|int
name|msgid
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|delim
decl_stmt|;
name|SM_RPOOL_T
modifier|*
name|rpool
decl_stmt|;
name|char
modifier|*
modifier|*
name|result
decl_stmt|;
name|int
modifier|*
name|resultln
decl_stmt|;
name|int
modifier|*
name|resultsz
decl_stmt|;
name|SM_LDAP_RECURSE_LIST
modifier|*
name|recurse
decl_stmt|;
block|{
name|bool
name|toplevel
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|statp
decl_stmt|;
name|int
name|vsize
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|SM_LDAP_RECURSE_ENTRY
modifier|*
name|rl
decl_stmt|;
comment|/* Are we the top top level of the search? */
name|toplevel
operator|=
operator|(
name|recurse
operator|==
name|NULL
operator|)
expr_stmt|;
comment|/* Get results */
name|statp
operator|=
name|EX_NOTFOUND
expr_stmt|;
while|while
condition|(
operator|(
name|ret
operator|=
name|ldap_result
argument_list|(
name|lmap
operator|->
name|ldap_ld
argument_list|,
name|msgid
argument_list|,
literal|0
argument_list|,
operator|(
name|lmap
operator|->
name|ldap_timeout
operator|.
name|tv_sec
operator|==
literal|0
condition|?
name|NULL
else|:
operator|&
operator|(
name|lmap
operator|->
name|ldap_timeout
operator|)
operator|)
argument_list|,
operator|&
operator|(
name|lmap
operator|->
name|ldap_res
operator|)
argument_list|)
operator|)
operator|==
name|LDAP_RES_SEARCH_ENTRY
condition|)
block|{
name|LDAPMessage
modifier|*
name|entry
decl_stmt|;
comment|/* If we don't want multiple values and we have one, break */
if|if
condition|(
operator|(
name|char
operator|)
name|delim
operator|==
literal|'\0'
operator|&&
operator|*
name|result
operator|!=
name|NULL
condition|)
break|break;
comment|/* Cycle through all entries */
for|for
control|(
name|entry
operator|=
name|ldap_first_entry
argument_list|(
name|lmap
operator|->
name|ldap_ld
argument_list|,
name|lmap
operator|->
name|ldap_res
argument_list|)
init|;
name|entry
operator|!=
name|NULL
condition|;
name|entry
operator|=
name|ldap_next_entry
argument_list|(
name|lmap
operator|->
name|ldap_ld
argument_list|,
name|lmap
operator|->
name|ldap_res
argument_list|)
control|)
block|{
name|BerElement
modifier|*
name|ber
decl_stmt|;
name|char
modifier|*
name|attr
decl_stmt|;
name|char
modifier|*
modifier|*
name|vals
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|dn
decl_stmt|;
comment|/* 			**  If matching only and found an entry, 			**  no need to spin through attributes 			*/
if|if
condition|(
name|statp
operator|==
name|EX_OK
operator|&&
name|bitset
argument_list|(
name|SM_LDAP_MATCHONLY
argument_list|,
name|flags
argument_list|)
condition|)
continue|continue;
comment|/* record completed DN's to prevent loops */
name|dn
operator|=
name|ldap_get_dn
argument_list|(
name|lmap
operator|->
name|ldap_ld
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|==
name|NULL
condition|)
block|{
name|save_errno
operator|=
name|sm_ldap_geterrno
argument_list|(
name|lmap
operator|->
name|ldap_ld
argument_list|)
expr_stmt|;
name|save_errno
operator|+=
name|E_LDAPBASE
expr_stmt|;
name|SM_LDAP_ERROR_CLEANUP
argument_list|()
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
name|EX_OSERR
return|;
block|}
name|rl
operator|=
name|sm_ldap_add_recurse
argument_list|(
operator|&
name|recurse
argument_list|,
name|dn
argument_list|,
name|SM_LDAP_ATTR_DN
argument_list|,
name|rpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|==
name|NULL
condition|)
block|{
name|ldap_memfree
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|SM_LDAP_ERROR_CLEANUP
argument_list|()
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|EX_OSERR
return|;
block|}
elseif|else
if|if
condition|(
name|rl
operator|->
name|lr_done
condition|)
block|{
comment|/* already on list, skip it */
name|ldap_memfree
argument_list|(
name|dn
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ldap_memfree
argument_list|(
name|dn
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LDAP_VERSION_MAX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|LDAP_OPT_SIZELIMIT
argument_list|)
comment|/* 			**  Reset value to prevent lingering 			**  LDAP_DECODING_ERROR due to 			**  OpenLDAP 1.X's hack (see below) 			*/
name|lmap
operator|->
name|ldap_ld
operator|->
name|ld_errno
operator|=
name|LDAP_SUCCESS
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(LDAP_VERSION_MAX) !defined(LDAP_OPT_SIZELIMIT) */
for|for
control|(
name|attr
operator|=
name|ldap_first_attribute
argument_list|(
name|lmap
operator|->
name|ldap_ld
argument_list|,
name|entry
argument_list|,
operator|&
name|ber
argument_list|)
init|;
name|attr
operator|!=
name|NULL
condition|;
name|attr
operator|=
name|ldap_next_attribute
argument_list|(
name|lmap
operator|->
name|ldap_ld
argument_list|,
name|entry
argument_list|,
name|ber
argument_list|)
control|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|vp_tmp
decl_stmt|;
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|needobjclass
init|=
name|NULL
decl_stmt|;
name|type
operator|=
name|SM_LDAP_ATTR_NONE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|lmap
operator|->
name|ldap_attr
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|lmap
operator|->
name|ldap_attr
index|[
name|i
index|]
argument_list|,
name|attr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|type
operator|=
name|lmap
operator|->
name|ldap_attr_type
index|[
name|i
index|]
expr_stmt|;
name|needobjclass
operator|=
name|lmap
operator|->
name|ldap_attr_needobjclass
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|bitset
argument_list|(
name|SM_LDAP_USE_ALLATTR
argument_list|,
name|flags
argument_list|)
operator|&&
name|type
operator|==
name|SM_LDAP_ATTR_NONE
condition|)
block|{
comment|/* URL lookups specify attrs to use */
name|type
operator|=
name|SM_LDAP_ATTR_NORMAL
expr_stmt|;
name|needobjclass
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|SM_LDAP_ATTR_NONE
condition|)
block|{
comment|/* attribute not requested */
name|ldap_memfree
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|SM_LDAP_ERROR_CLEANUP
argument_list|()
expr_stmt|;
name|errno
operator|=
name|EFAULT
expr_stmt|;
return|return
name|EX_SOFTWARE
return|;
block|}
comment|/* 				**  For recursion on a particular attribute, 				**  we may need to see if this entry is 				**  part of a particular objectclass. 				**  Also, ignore objectClass attribute. 				**  Otherwise we just ignore this attribute. 				*/
if|if
condition|(
name|type
operator|==
name|SM_LDAP_ATTR_OBJCLASS
operator|||
operator|(
name|needobjclass
operator|!=
name|NULL
operator|&&
operator|!
name|sm_ldap_has_objectclass
argument_list|(
name|lmap
argument_list|,
name|entry
argument_list|,
name|needobjclass
argument_list|)
operator|)
condition|)
block|{
name|ldap_memfree
argument_list|(
name|attr
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|lmap
operator|->
name|ldap_attrsonly
operator|==
name|LDAPMAP_FALSE
condition|)
block|{
name|vals
operator|=
name|ldap_get_values
argument_list|(
name|lmap
operator|->
name|ldap_ld
argument_list|,
name|entry
argument_list|,
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|vals
operator|==
name|NULL
condition|)
block|{
name|save_errno
operator|=
name|sm_ldap_geterrno
argument_list|(
name|lmap
operator|->
name|ldap_ld
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_errno
operator|==
name|LDAP_SUCCESS
condition|)
block|{
name|ldap_memfree
argument_list|(
name|attr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Must be an error */
name|save_errno
operator|+=
name|E_LDAPBASE
expr_stmt|;
name|ldap_memfree
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|SM_LDAP_ERROR_CLEANUP
argument_list|()
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
block|}
name|statp
operator|=
name|EX_OK
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LDAP_VERSION_MAX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|LDAP_OPT_SIZELIMIT
argument_list|)
comment|/* 				**  Reset value to prevent lingering 				**  LDAP_DECODING_ERROR due to 				**  OpenLDAP 1.X's hack (see below) 				*/
name|lmap
operator|->
name|ldap_ld
operator|->
name|ld_errno
operator|=
name|LDAP_SUCCESS
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(LDAP_VERSION_MAX) !defined(LDAP_OPT_SIZELIMIT) */
comment|/* 				**  If matching only, 				**  no need to spin through entries 				*/
if|if
condition|(
name|bitset
argument_list|(
name|SM_LDAP_MATCHONLY
argument_list|,
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|lmap
operator|->
name|ldap_attrsonly
operator|==
name|LDAPMAP_FALSE
condition|)
name|ldap_value_free
argument_list|(
name|vals
argument_list|)
expr_stmt|;
name|ldap_memfree
argument_list|(
name|attr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 				**  If we don't want multiple values, 				**  return first found. 				*/
if|if
condition|(
operator|(
name|char
operator|)
name|delim
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|result
operator|!=
name|NULL
condition|)
block|{
comment|/* already have a value */
break|break;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|SM_LDAP_SINGLEMATCH
argument_list|,
name|flags
argument_list|)
operator|&&
operator|*
name|result
operator|!=
name|NULL
condition|)
block|{
comment|/* only wanted one match */
name|SM_LDAP_ERROR_CLEANUP
argument_list|()
expr_stmt|;
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
name|EX_NOTFOUND
return|;
block|}
if|if
condition|(
name|lmap
operator|->
name|ldap_attrsonly
operator|==
name|LDAPMAP_TRUE
condition|)
block|{
operator|*
name|result
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|rpool
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|ldap_memfree
argument_list|(
name|attr
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vals
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
name|ldap_value_free
argument_list|(
name|vals
argument_list|)
expr_stmt|;
name|ldap_memfree
argument_list|(
name|attr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|vsize
operator|=
name|strlen
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|lmap
operator|->
name|ldap_attrsep
operator|!=
literal|'\0'
condition|)
name|vsize
operator|+=
name|strlen
argument_list|(
name|attr
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|*
name|result
operator|=
name|sm_rpool_malloc_x
argument_list|(
name|rpool
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|lmap
operator|->
name|ldap_attrsep
operator|!=
literal|'\0'
condition|)
name|sm_snprintf
argument_list|(
operator|*
name|result
argument_list|,
name|vsize
argument_list|,
literal|"%s%c%s"
argument_list|,
name|attr
argument_list|,
name|lmap
operator|->
name|ldap_attrsep
argument_list|,
name|vals
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|sm_strlcpy
argument_list|(
operator|*
name|result
argument_list|,
name|vals
index|[
literal|0
index|]
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
name|ldap_value_free
argument_list|(
name|vals
argument_list|)
expr_stmt|;
name|ldap_memfree
argument_list|(
name|attr
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* attributes only */
if|if
condition|(
name|lmap
operator|->
name|ldap_attrsonly
operator|==
name|LDAPMAP_TRUE
condition|)
block|{
if|if
condition|(
operator|*
name|result
operator|==
name|NULL
condition|)
operator|*
name|result
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|rpool
argument_list|,
name|attr
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|bitset
argument_list|(
name|SM_LDAP_SINGLEMATCH
argument_list|,
name|flags
argument_list|)
operator|&&
operator|*
name|result
operator|!=
name|NULL
condition|)
block|{
comment|/* only wanted one match */
name|SM_LDAP_ERROR_CLEANUP
argument_list|()
expr_stmt|;
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
name|EX_NOTFOUND
return|;
block|}
name|vsize
operator|=
name|strlen
argument_list|(
operator|*
name|result
argument_list|)
operator|+
name|strlen
argument_list|(
name|attr
argument_list|)
operator|+
literal|2
expr_stmt|;
name|tmp
operator|=
name|sm_rpool_malloc_x
argument_list|(
name|rpool
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|tmp
argument_list|,
name|vsize
argument_list|,
literal|"%s%c%s"
argument_list|,
operator|*
name|result
argument_list|,
operator|(
name|char
operator|)
name|delim
argument_list|,
name|attr
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|tmp
expr_stmt|;
block|}
name|ldap_memfree
argument_list|(
name|attr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 				**  If there is more than one, munge then 				**  into a map_coldelim separated string. 				**  If we are recursing we may have an entry 				**  with no 'normal' values to put in the 				**  string. 				**  This is not an error. 				*/
if|if
condition|(
name|type
operator|==
name|SM_LDAP_ATTR_NORMAL
operator|&&
name|bitset
argument_list|(
name|SM_LDAP_SINGLEMATCH
argument_list|,
name|flags
argument_list|)
operator|&&
operator|*
name|result
operator|!=
name|NULL
condition|)
block|{
comment|/* only wanted one match */
name|SM_LDAP_ERROR_CLEANUP
argument_list|()
expr_stmt|;
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
name|EX_NOTFOUND
return|;
block|}
name|vsize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|vals
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|type
operator|==
name|SM_LDAP_ATTR_DN
operator|||
name|type
operator|==
name|SM_LDAP_ATTR_FILTER
operator|||
name|type
operator|==
name|SM_LDAP_ATTR_URL
condition|)
block|{
comment|/* add to recursion */
if|if
condition|(
name|sm_ldap_add_recurse
argument_list|(
operator|&
name|recurse
argument_list|,
name|vals
index|[
name|i
index|]
argument_list|,
name|type
argument_list|,
name|rpool
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|SM_LDAP_ERROR_CLEANUP
argument_list|()
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|EX_OSERR
return|;
block|}
continue|continue;
block|}
name|vsize
operator|+=
name|strlen
argument_list|(
name|vals
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|lmap
operator|->
name|ldap_attrsep
operator|!=
literal|'\0'
condition|)
name|vsize
operator|+=
name|strlen
argument_list|(
name|attr
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
comment|/* 				**  Create/Append to string any normal 				**  attribute values.  Otherwise, just free 				**  memory and move on to the next 				**  attribute in this entry. 				*/
if|if
condition|(
name|type
operator|==
name|SM_LDAP_ATTR_NORMAL
operator|&&
name|vsize
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|pe
decl_stmt|;
comment|/* Grow result string if needed */
if|if
condition|(
operator|(
operator|*
name|resultln
operator|+
name|vsize
operator|)
operator|>=
operator|*
name|resultsz
condition|)
block|{
while|while
condition|(
operator|(
operator|*
name|resultln
operator|+
name|vsize
operator|)
operator|>=
operator|*
name|resultsz
condition|)
block|{
if|if
condition|(
operator|*
name|resultsz
operator|==
literal|0
condition|)
operator|*
name|resultsz
operator|=
literal|1024
expr_stmt|;
else|else
operator|*
name|resultsz
operator|*=
literal|2
expr_stmt|;
block|}
name|vp_tmp
operator|=
name|sm_rpool_malloc_x
argument_list|(
name|rpool
argument_list|,
operator|*
name|resultsz
argument_list|)
expr_stmt|;
operator|*
name|vp_tmp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|result
operator|!=
name|NULL
condition|)
name|sm_strlcpy
argument_list|(
name|vp_tmp
argument_list|,
operator|*
name|result
argument_list|,
operator|*
name|resultsz
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|vp_tmp
expr_stmt|;
block|}
name|p
operator|=
operator|*
name|result
operator|+
operator|*
name|resultln
expr_stmt|;
name|pe
operator|=
operator|*
name|result
operator|+
operator|*
name|resultsz
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|vals
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|resultln
operator|>
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
operator|(
name|char
operator|)
name|delim
expr_stmt|;
if|if
condition|(
name|lmap
operator|->
name|ldap_attrsep
operator|!=
literal|'\0'
condition|)
block|{
name|p
operator|+=
name|sm_strlcpy
argument_list|(
name|p
argument_list|,
name|attr
argument_list|,
name|pe
operator|-
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|<
name|pe
condition|)
operator|*
name|p
operator|++
operator|=
name|lmap
operator|->
name|ldap_attrsep
expr_stmt|;
block|}
name|p
operator|+=
name|sm_strlcpy
argument_list|(
name|p
argument_list|,
name|vals
index|[
name|i
index|]
argument_list|,
name|pe
operator|-
name|p
argument_list|)
expr_stmt|;
operator|*
name|resultln
operator|=
name|p
operator|-
operator|(
operator|*
name|result
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|pe
condition|)
block|{
comment|/* Internal error: buffer too small for LDAP values */
name|SM_LDAP_ERROR_CLEANUP
argument_list|()
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|EX_OSERR
return|;
block|}
block|}
block|}
name|ldap_value_free
argument_list|(
name|vals
argument_list|)
expr_stmt|;
name|ldap_memfree
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
name|save_errno
operator|=
name|sm_ldap_geterrno
argument_list|(
name|lmap
operator|->
name|ldap_ld
argument_list|)
expr_stmt|;
comment|/* 			**  We check save_errno != LDAP_DECODING_ERROR since 			**  OpenLDAP 1.X has a very ugly *undocumented* 			**  hack of returning this error code from 			**  ldap_next_attribute() if the library freed the 			**  ber attribute.  See: 			**  http://www.openldap.org/lists/openldap-devel/9901/msg00064.html 			*/
if|if
condition|(
name|save_errno
operator|!=
name|LDAP_SUCCESS
operator|&&
name|save_errno
operator|!=
name|LDAP_DECODING_ERROR
condition|)
block|{
comment|/* Must be an error */
name|save_errno
operator|+=
name|E_LDAPBASE
expr_stmt|;
name|SM_LDAP_ERROR_CLEANUP
argument_list|()
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
comment|/* mark this DN as done */
name|rl
operator|->
name|lr_done
operator|=
name|true
expr_stmt|;
comment|/* We don't want multiple values and we have one */
if|if
condition|(
operator|(
name|char
operator|)
name|delim
operator|==
literal|'\0'
operator|&&
operator|*
name|result
operator|!=
name|NULL
condition|)
break|break;
block|}
name|save_errno
operator|=
name|sm_ldap_geterrno
argument_list|(
name|lmap
operator|->
name|ldap_ld
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_errno
operator|!=
name|LDAP_SUCCESS
operator|&&
name|save_errno
operator|!=
name|LDAP_DECODING_ERROR
condition|)
block|{
comment|/* Must be an error */
name|save_errno
operator|+=
name|E_LDAPBASE
expr_stmt|;
name|SM_LDAP_ERROR_CLEANUP
argument_list|()
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
name|ldap_msgfree
argument_list|(
name|lmap
operator|->
name|ldap_res
argument_list|)
expr_stmt|;
name|lmap
operator|->
name|ldap_res
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|save_errno
operator|=
name|ETIMEDOUT
expr_stmt|;
else|else
name|save_errno
operator|=
name|sm_ldap_geterrno
argument_list|(
name|lmap
operator|->
name|ldap_ld
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_errno
operator|!=
name|LDAP_SUCCESS
condition|)
block|{
name|statp
operator|=
name|EX_TEMPFAIL
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|save_errno
condition|)
block|{
ifdef|#
directive|ifdef
name|LDAP_SERVER_DOWN
case|case
name|LDAP_SERVER_DOWN
case|:
endif|#
directive|endif
comment|/* LDAP_SERVER_DOWN */
case|case
name|LDAP_TIMEOUT
case|:
case|case
name|LDAP_UNAVAILABLE
case|:
comment|/* 				**  server disappeared, 				**  try reopen on next search 				*/
name|statp
operator|=
name|EX_RESTART
expr_stmt|;
break|break;
block|}
name|save_errno
operator|+=
name|E_LDAPBASE
expr_stmt|;
block|}
name|SM_LDAP_ERROR_CLEANUP
argument_list|()
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
name|statp
return|;
block|}
if|if
condition|(
name|lmap
operator|->
name|ldap_res
operator|!=
name|NULL
condition|)
block|{
name|ldap_msgfree
argument_list|(
name|lmap
operator|->
name|ldap_res
argument_list|)
expr_stmt|;
name|lmap
operator|->
name|ldap_res
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|toplevel
condition|)
block|{
name|int
name|rlidx
decl_stmt|;
comment|/* 		**  Spin through the built-up recurse list at the top 		**  of the recursion.  Since new items are added at the 		**  end of the shared list, we actually only ever get 		**  one level of recursion before things pop back to the 		**  top.  Any items added to the list during that recursion 		**  will be expanded by the top level. 		*/
for|for
control|(
name|rlidx
operator|=
literal|0
init|;
name|recurse
operator|!=
name|NULL
operator|&&
name|rlidx
operator|<
name|recurse
operator|->
name|lr_cnt
condition|;
name|rlidx
operator|++
control|)
block|{
name|int
name|newflags
decl_stmt|;
name|int
name|sid
decl_stmt|;
name|int
name|status
decl_stmt|;
name|rl
operator|=
name|recurse
operator|->
name|lr_data
index|[
name|rlidx
index|]
expr_stmt|;
name|newflags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|rl
operator|->
name|lr_done
condition|)
block|{
comment|/* already expanded */
continue|continue;
block|}
if|if
condition|(
name|rl
operator|->
name|lr_type
operator|==
name|SM_LDAP_ATTR_DN
condition|)
block|{
comment|/* do DN search */
name|sid
operator|=
name|ldap_search
argument_list|(
name|lmap
operator|->
name|ldap_ld
argument_list|,
name|rl
operator|->
name|lr_search
argument_list|,
name|lmap
operator|->
name|ldap_scope
argument_list|,
literal|"(objectClass=*)"
argument_list|,
operator|(
name|lmap
operator|->
name|ldap_attr
index|[
literal|0
index|]
operator|==
name|NULL
condition|?
name|NULL
else|:
name|lmap
operator|->
name|ldap_attr
operator|)
argument_list|,
name|lmap
operator|->
name|ldap_attrsonly
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rl
operator|->
name|lr_type
operator|==
name|SM_LDAP_ATTR_FILTER
condition|)
block|{
comment|/* do new search */
name|sid
operator|=
name|ldap_search
argument_list|(
name|lmap
operator|->
name|ldap_ld
argument_list|,
name|lmap
operator|->
name|ldap_base
argument_list|,
name|lmap
operator|->
name|ldap_scope
argument_list|,
name|rl
operator|->
name|lr_search
argument_list|,
operator|(
name|lmap
operator|->
name|ldap_attr
index|[
literal|0
index|]
operator|==
name|NULL
condition|?
name|NULL
else|:
name|lmap
operator|->
name|ldap_attr
operator|)
argument_list|,
name|lmap
operator|->
name|ldap_attrsonly
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rl
operator|->
name|lr_type
operator|==
name|SM_LDAP_ATTR_URL
condition|)
block|{
comment|/* do new URL search */
name|sid
operator|=
name|ldap_url_search
argument_list|(
name|lmap
operator|->
name|ldap_ld
argument_list|,
name|rl
operator|->
name|lr_search
argument_list|,
name|lmap
operator|->
name|ldap_attrsonly
argument_list|)
expr_stmt|;
name|newflags
operator||=
name|SM_LDAP_USE_ALLATTR
expr_stmt|;
block|}
else|else
block|{
comment|/* unknown or illegal attribute type */
name|errno
operator|=
name|EFAULT
expr_stmt|;
return|return
name|EX_SOFTWARE
return|;
block|}
comment|/* Collect results */
if|if
condition|(
name|sid
operator|==
operator|-
literal|1
condition|)
block|{
name|save_errno
operator|=
name|sm_ldap_geterrno
argument_list|(
name|lmap
operator|->
name|ldap_ld
argument_list|)
expr_stmt|;
name|statp
operator|=
name|EX_TEMPFAIL
expr_stmt|;
switch|switch
condition|(
name|save_errno
condition|)
block|{
ifdef|#
directive|ifdef
name|LDAP_SERVER_DOWN
case|case
name|LDAP_SERVER_DOWN
case|:
endif|#
directive|endif
comment|/* LDAP_SERVER_DOWN */
case|case
name|LDAP_TIMEOUT
case|:
case|case
name|LDAP_UNAVAILABLE
case|:
comment|/* 					**  server disappeared, 					**  try reopen on next search 					*/
name|statp
operator|=
name|EX_RESTART
expr_stmt|;
break|break;
block|}
name|errno
operator|=
name|save_errno
operator|+
name|E_LDAPBASE
expr_stmt|;
return|return
name|statp
return|;
block|}
name|status
operator|=
name|sm_ldap_results
argument_list|(
name|lmap
argument_list|,
name|sid
argument_list|,
name|newflags
argument_list|,
name|delim
argument_list|,
name|rpool
argument_list|,
name|result
argument_list|,
name|resultln
argument_list|,
name|resultsz
argument_list|,
name|recurse
argument_list|)
expr_stmt|;
name|save_errno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|EX_OK
operator|&&
name|status
operator|!=
name|EX_NOTFOUND
condition|)
block|{
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
name|status
return|;
block|}
comment|/* Mark as done */
name|rl
operator|->
name|lr_done
operator|=
name|true
expr_stmt|;
comment|/* Reset rlidx as new items may have been added */
name|rlidx
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
name|statp
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_LDAP_RECURSION */
end_comment

begin_comment
comment|/* **  SM_LDAP_CLOSE -- close LDAP connection ** **	Parameters: **		lmap -- LDAP map information ** **	Returns: **		None. ** */
end_comment

begin_function
name|void
name|sm_ldap_close
parameter_list|(
name|lmap
parameter_list|)
name|SM_LDAP_STRUCT
modifier|*
name|lmap
decl_stmt|;
block|{
if|if
condition|(
name|lmap
operator|->
name|ldap_ld
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|lmap
operator|->
name|ldap_pid
operator|==
name|getpid
argument_list|()
condition|)
name|ldap_unbind
argument_list|(
name|lmap
operator|->
name|ldap_ld
argument_list|)
expr_stmt|;
name|lmap
operator|->
name|ldap_ld
operator|=
name|NULL
expr_stmt|;
name|lmap
operator|->
name|ldap_pid
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  SM_LDAP_SETOPTS -- set LDAP options ** **	Parameters: **		ld -- LDAP session handle **		lmap -- LDAP map information ** **	Returns: **		None. ** */
end_comment

begin_function
name|void
name|sm_ldap_setopts
parameter_list|(
name|ld
parameter_list|,
name|lmap
parameter_list|)
name|LDAP
modifier|*
name|ld
decl_stmt|;
name|SM_LDAP_STRUCT
modifier|*
name|lmap
decl_stmt|;
block|{
if|#
directive|if
name|USE_LDAP_SET_OPTION
if|#
directive|if
name|_FFR_LDAP_SETVERSION
if|if
condition|(
name|lmap
operator|->
name|ldap_version
operator|!=
literal|0
condition|)
block|{
name|ldap_set_option
argument_list|(
name|ld
argument_list|,
name|LDAP_OPT_PROTOCOL_VERSION
argument_list|,
operator|&
name|lmap
operator|->
name|ldap_version
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _FFR_LDAP_SETVERSION */
name|ldap_set_option
argument_list|(
name|ld
argument_list|,
name|LDAP_OPT_DEREF
argument_list|,
operator|&
name|lmap
operator|->
name|ldap_deref
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|LDAP_OPT_REFERRALS
argument_list|,
name|lmap
operator|->
name|ldap_options
argument_list|)
condition|)
name|ldap_set_option
argument_list|(
name|ld
argument_list|,
name|LDAP_OPT_REFERRALS
argument_list|,
name|LDAP_OPT_ON
argument_list|)
expr_stmt|;
else|else
name|ldap_set_option
argument_list|(
name|ld
argument_list|,
name|LDAP_OPT_REFERRALS
argument_list|,
name|LDAP_OPT_OFF
argument_list|)
expr_stmt|;
name|ldap_set_option
argument_list|(
name|ld
argument_list|,
name|LDAP_OPT_SIZELIMIT
argument_list|,
operator|&
name|lmap
operator|->
name|ldap_sizelimit
argument_list|)
expr_stmt|;
name|ldap_set_option
argument_list|(
name|ld
argument_list|,
name|LDAP_OPT_TIMELIMIT
argument_list|,
operator|&
name|lmap
operator|->
name|ldap_timelimit
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* USE_LDAP_SET_OPTION */
comment|/* From here on in we can use ldap internal timelimits */
name|ld
operator|->
name|ld_deref
operator|=
name|lmap
operator|->
name|ldap_deref
expr_stmt|;
name|ld
operator|->
name|ld_options
operator|=
name|lmap
operator|->
name|ldap_options
expr_stmt|;
name|ld
operator|->
name|ld_sizelimit
operator|=
name|lmap
operator|->
name|ldap_sizelimit
expr_stmt|;
name|ld
operator|->
name|ld_timelimit
operator|=
name|lmap
operator|->
name|ldap_timelimit
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LDAP_SET_OPTION */
block|}
end_function

begin_comment
comment|/* **  SM_LDAP_GETERRNO -- get ldap errno value ** **	Parameters: **		ld -- LDAP session handle ** **	Returns: **		LDAP errno. ** */
end_comment

begin_function
name|int
name|sm_ldap_geterrno
parameter_list|(
name|ld
parameter_list|)
name|LDAP
modifier|*
name|ld
decl_stmt|;
block|{
name|int
name|err
init|=
name|LDAP_SUCCESS
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LDAP_VERSION_MAX
argument_list|)
operator|&&
name|LDAP_VERSION_MAX
operator|>=
literal|3
operator|(
name|void
operator|)
name|ldap_get_option
argument_list|(
name|ld
argument_list|,
name|LDAP_OPT_ERROR_NUMBER
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* defined(LDAP_VERSION_MAX)&& LDAP_VERSION_MAX>= 3 */
ifdef|#
directive|ifdef
name|LDAP_OPT_SIZELIMIT
name|err
operator|=
name|ldap_get_lderrno
argument_list|(
name|ld
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* LDAP_OPT_SIZELIMIT */
name|err
operator|=
name|ld
operator|->
name|ld_errno
expr_stmt|;
comment|/* 	**  Reset value to prevent lingering LDAP_DECODING_ERROR due to 	**  OpenLDAP 1.X's hack (see above) 	*/
name|ld
operator|->
name|ld_errno
operator|=
name|LDAP_SUCCESS
expr_stmt|;
endif|#
directive|endif
comment|/* LDAP_OPT_SIZELIMIT */
endif|#
directive|endif
comment|/* defined(LDAP_VERSION_MAX)&& LDAP_VERSION_MAX>= 3 */
return|return
name|err
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LDAPMAP */
end_comment

end_unit

