begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2001 Sendmail, Inc. and its suppliers.  *	All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_include
include|#
directive|include
file|<sm/gen.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: mpeix.c,v 1.4 2001/12/14 23:54:18 gshapiro Exp $"
argument_list|)
end_macro

begin_ifdef
ifdef|#
directive|ifdef
name|MPE
end_ifdef

begin_comment
comment|/* **	MPE lacks many common functions required across all sendmail programs **	so we define implementations for these functions here. */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<mpe.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sm/conf.h>
end_include

begin_comment
comment|/* **  CHROOT -- dummy chroot() function ** **	The MPE documentation for sendmail says that chroot-based **	functionality is not implemented because MPE lacks chroot.  But **	rather than mucking around with all the sendmail calls to chroot, **	we define this dummy function to return an ENOSYS failure just in **	case a sendmail user attempts to enable chroot-based functionality. ** **	Parameters: **		path -- pathname of new root (ignored). ** **	Returns: **		-1 and errno == ENOSYS (function not implemented) */
end_comment

begin_function
name|int
name|chroot
parameter_list|(
name|path
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
block|{
name|errno
operator|=
name|ENOSYS
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* **  ENDPWENT -- dummy endpwent() function ** **	Parameters: **		none ** **	Returns: **		none */
end_comment

begin_function
name|void
name|endpwent
parameter_list|()
block|{
return|return;
block|}
end_function

begin_comment
comment|/* **  In addition to missing functions, certain existing MPE functions have **  slightly different semantics (or bugs) compared to normal Unix OSes. ** **  Here we define wrappers for these functions to make them behave in the **  manner expected by sendmail. */
end_comment

begin_comment
comment|/* **  SENDMAIL_MPE_BIND -- shadow function for the standard socket bind() ** **	MPE requires GETPRIVMODE() for AF_INET sockets less than port 1024. ** **	Parameters: **		sd -- socket descriptor. **		addr -- socket address. **		addrlen -- length of socket address. ** **	Results: **		0 -- success **		!= 0 -- failure */
end_comment

begin_undef
undef|#
directive|undef
name|bind
end_undef

begin_function
name|int
name|sendmail_mpe_bind
parameter_list|(
name|sd
parameter_list|,
name|addr
parameter_list|,
name|addrlen
parameter_list|)
name|int
name|sd
decl_stmt|;
name|void
modifier|*
name|addr
decl_stmt|;
name|int
name|addrlen
decl_stmt|;
block|{
name|bool
name|priv
init|=
name|false
decl_stmt|;
name|int
name|result
decl_stmt|;
specifier|extern
name|void
name|GETPRIVMODE
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|GETUSERMODE
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|addrlen
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
operator|&&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin_family
operator|==
name|AF_INET
condition|)
block|{
comment|/* AF_INET */
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin_port
operator|>
literal|0
operator|&&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin_port
operator|<
literal|1024
condition|)
block|{
name|priv
operator|=
name|true
expr_stmt|;
name|GETPRIVMODE
argument_list|()
expr_stmt|;
block|}
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|bind
argument_list|(
name|sd
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
condition|)
name|GETUSERMODE
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/* AF_UNIX */
return|return
name|bind
argument_list|(
name|sd
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  SENDMAIL_MPE__EXIT -- wait for children to terminate, then _exit() ** **	Child processes cannot survive the death of their parent on MPE, so **	we must call wait() before _exit() in order to prevent this **	infanticide. ** **	Parameters: **		status -- _exit status value. ** **	Returns: **		none. */
end_comment

begin_undef
undef|#
directive|undef
name|_exit
end_undef

begin_function
name|void
name|sendmail_mpe__exit
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
comment|/* Wait for all children to terminate. */
do|do
block|{
name|result
operator|=
name|wait
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|result
operator|>
literal|0
operator|||
name|errno
operator|==
name|EINTR
condition|)
do|;
name|_exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  SENDMAIL_MPE_EXIT -- wait for children to terminate, then exit() ** **	Child processes cannot survive the death of their parent on MPE, so **	we must call wait() before exit() in order to prevent this **	infanticide. ** **	Parameters: **		status -- exit status value. ** **	Returns: **		none. */
end_comment

begin_undef
undef|#
directive|undef
name|exit
end_undef

begin_function
name|void
name|sendmail_mpe_exit
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
comment|/* Wait for all children to terminate. */
do|do
block|{
name|result
operator|=
name|wait
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|result
operator|>
literal|0
operator|||
name|errno
operator|==
name|EINTR
condition|)
do|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  SENDMAIL_MPE_FCNTL -- shadow function for fcntl() ** **	MPE requires sfcntl() for sockets, and fcntl() for everything **	else.  This shadow routine determines the descriptor type and **	makes the appropriate call. ** **	Parameters: **		same as fcntl(). ** **	Returns: **		same as fcntl(). */
end_comment

begin_undef
undef|#
directive|undef
name|fcntl
end_undef

begin_function
name|int
name|sendmail_mpe_fcntl
parameter_list|(
name|int
name|fildes
parameter_list|,
name|int
name|cmd
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|result
decl_stmt|;
name|struct
name|sockaddr
name|sa
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|arg
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|sa
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|fildes
argument_list|,
operator|&
name|sa
argument_list|,
operator|&
name|len
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EAFNOSUPPORT
condition|)
block|{
comment|/* AF_UNIX socket */
return|return
name|sfcntl
argument_list|(
name|fildes
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|ENOTSOCK
condition|)
block|{
comment|/* file or pipe */
return|return
name|fcntl
argument_list|(
name|fildes
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
block|}
comment|/* unknown getsockname() failure */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* AF_INET socket */
if|if
condition|(
operator|(
name|result
operator|=
name|sfcntl
argument_list|(
name|fildes
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
operator|)
operator|!=
operator|-
literal|1
operator|&&
name|cmd
operator|==
name|F_GETFL
condition|)
name|result
operator||=
name|O_RDWR
expr_stmt|;
comment|/* fill in some missing flags */
return|return
name|result
return|;
block|}
block|}
end_function

begin_comment
comment|/* **  SENDMAIL_MPE_GETPWNAM - shadow function for getpwnam() ** **	Several issues apply here: ** **	- MPE user names MUST have one '.' separator character **	- MPE user names MUST be in upper case **	- MPE does not initialize all fields in the passwd struct ** **	Parameters: **		name -- username string. ** **	Returns: **		pointer to struct passwd if found else NULL */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sendmail_mpe_nullstr
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|getpwnam
end_undef

begin_function_decl
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|struct
name|passwd
modifier|*
name|sendmail_mpe_getpwnam
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|dots
init|=
literal|0
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|i
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|upper
decl_stmt|;
name|struct
name|passwd
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
operator|(
name|upper
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* upshift the username parameter and count the dots */
while|while
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|name
index|[
name|i
index|]
operator|==
literal|'.'
condition|)
block|{
name|dots
operator|++
expr_stmt|;
name|upper
index|[
name|i
index|]
operator|=
literal|'.'
expr_stmt|;
block|}
else|else
name|upper
index|[
name|i
index|]
operator|=
name|toupper
argument_list|(
name|name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|dots
operator|!=
literal|1
condition|)
block|{
comment|/* prevent bug when dots == 0 */
name|err
operator|=
name|EINVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|result
operator|=
name|getpwnam
argument_list|(
name|upper
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* init the uninitialized fields */
name|result
operator|->
name|pw_gecos
operator|=
name|sendmail_mpe_nullstr
expr_stmt|;
name|result
operator|->
name|pw_passwd
operator|=
name|sendmail_mpe_nullstr
expr_stmt|;
name|result
operator|->
name|pw_age
operator|=
name|sendmail_mpe_nullstr
expr_stmt|;
name|result
operator|->
name|pw_comment
operator|=
name|sendmail_mpe_nullstr
expr_stmt|;
name|result
operator|->
name|pw_audid
operator|=
literal|0
expr_stmt|;
name|result
operator|->
name|pw_audflg
operator|=
literal|0
expr_stmt|;
block|}
name|err
operator|=
name|errno
expr_stmt|;
name|free
argument_list|(
name|upper
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
name|err
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* **  SENDMAIL_MPE_GETPWUID -- shadow function for getpwuid() ** **	Initializes the uninitalized fields in the passwd struct. ** **	Parameters: **		uid -- uid to obtain passwd data for ** **	Returns: **		pointer to struct passwd or NULL if not found */
end_comment

begin_undef
undef|#
directive|undef
name|getpwuid
end_undef

begin_decl_stmt
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwuid
name|__P
argument_list|(
operator|(
name|uid_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|passwd
modifier|*
name|sendmail_mpe_getpwuid
parameter_list|(
name|uid
parameter_list|)
name|uid_t
name|uid
decl_stmt|;
block|{
name|struct
name|passwd
modifier|*
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|result
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* initialize the uninitialized fields */
name|result
operator|->
name|pw_gecos
operator|=
name|sendmail_mpe_nullstr
expr_stmt|;
name|result
operator|->
name|pw_passwd
operator|=
name|sendmail_mpe_nullstr
expr_stmt|;
name|result
operator|->
name|pw_age
operator|=
name|sendmail_mpe_nullstr
expr_stmt|;
name|result
operator|->
name|pw_comment
operator|=
name|sendmail_mpe_nullstr
expr_stmt|;
name|result
operator|->
name|pw_audid
operator|=
literal|0
expr_stmt|;
name|result
operator|->
name|pw_audflg
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* **  OK boys and girls, time for some serious voodoo! ** **  MPE does not have a complete implementation of POSIX users and groups: ** **  - there is no uid 0 superuser **  - setuid/setgid file permission bits exist but have no-op functionality **  - setgid() exists, but only supports new gid == current gid (boring!) **  - setuid() forces a gid change to the new uid's primary (and only) gid ** **  ...all of which thoroughly annoys sendmail. ** **  So what to do?  We can't go on an #ifdef MPE rampage throughout **  sendmail, because there are only about a zillion references to uid 0 **  and so success (and security) would probably be rather dubious by the **  time we finished. ** **  Instead we take the approach of defining wrapper functions for the **  gid/uid management functions getegid(), geteuid(), setgid(), and **  setuid() in order to implement the following model: ** **  - the sendmail program thinks it is a setuid-root (uid 0) program **  - uid 0 is recognized as being valid, but does not grant extra powers **	- MPE priv mode allows sendmail to call setuid(), not uid 0 **	- file access is still controlled by the real non-zero uid **  - the other programs (vacation, etc) have standard MPE POSIX behavior ** **  This emulation model is activated by use of the program file setgid and **  setuid mode bits which exist but are unused by MPE.  If the setgid mode **  bit is on, then gid emulation will be enabled.  If the setuid mode bit is **  on, then uid emulation will be enabled.  So for the mail daemon, we need **  to do chmod u+s,g+s /SENDMAIL/CURRENT/SENDMAIL. ** **  The following flags determine the current emulation state: ** **  true == emulation enabled **  false == emulation disabled, use unmodified MPE semantics */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|sendmail_mpe_flaginit
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|sendmail_mpe_gidflag
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|sendmail_mpe_uidflag
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  SENDMAIL_MPE_GETMODE -- return the mode bits for the current process ** **	Parameters: **		none. ** **	Returns: **		file mode bits for the current process program file. */
end_comment

begin_function
name|mode_t
name|sendmail_mpe_getmode
parameter_list|()
block|{
name|int
name|status
init|=
literal|666
decl_stmt|;
name|int
name|myprogram_length
decl_stmt|;
name|int
name|myprogram_syntax
init|=
literal|2
decl_stmt|;
name|char
name|formaldesig
index|[
literal|28
index|]
decl_stmt|;
name|char
name|myprogram
index|[
name|PATH_MAX
operator|+
literal|2
index|]
decl_stmt|;
name|char
name|path
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
specifier|extern
name|HPMYPROGRAM
name|__P
argument_list|(
operator|(
name|int
name|parms
operator|,
name|char
operator|*
name|formaldesig
operator|,
name|int
operator|*
name|status
operator|,
name|int
operator|*
name|length
operator|,
name|char
operator|*
name|myprogram
operator|,
name|int
operator|*
name|myprogram_length
operator|,
name|int
operator|*
name|myprogram_syntax
operator|)
argument_list|)
decl_stmt|;
name|myprogram_length
operator|=
sizeof|sizeof
argument_list|(
name|myprogram
argument_list|)
expr_stmt|;
name|HPMYPROGRAM
argument_list|(
literal|6
argument_list|,
name|formaldesig
argument_list|,
operator|&
name|status
argument_list|,
name|NULL
argument_list|,
name|myprogram
argument_list|,
operator|&
name|myprogram_length
argument_list|,
operator|&
name|myprogram_syntax
argument_list|)
expr_stmt|;
comment|/* should not occur, do not attempt emulation */
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
operator|&
name|path
argument_list|,
operator|&
name|myprogram
index|[
literal|1
index|]
argument_list|,
name|myprogram_length
operator|-
literal|2
argument_list|)
expr_stmt|;
name|path
index|[
name|myprogram_length
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* should not occur, do not attempt emulation */
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|st
operator|.
name|st_mode
return|;
block|}
end_function

begin_comment
comment|/* **  SENDMAIL_MPE_EMULGID -- should we perform gid emulation? ** **	If !sendmail_mpe_flaginit then obtain the mode bits to determine **	if the setgid bit is on, we want gid emulation and so set **	sendmail_mpe_gidflag to true.  Otherwise we do not want gid emulation **	and so set sendmail_mpe_gidflag to false. ** **	Parameters: **		none. ** **	Returns: **		true -- perform gid emulation **		false -- do not perform gid emulation */
end_comment

begin_function
name|bool
name|sendmail_mpe_emulgid
parameter_list|()
block|{
if|if
condition|(
operator|!
name|sendmail_mpe_flaginit
condition|)
block|{
name|mode_t
name|mode
decl_stmt|;
name|mode
operator|=
name|sendmail_mpe_getmode
argument_list|()
expr_stmt|;
name|sendmail_mpe_gidflag
operator|=
operator|(
operator|(
name|mode
operator|&
name|S_ISGID
operator|)
operator|==
name|S_ISGID
operator|)
expr_stmt|;
name|sendmail_mpe_uidflag
operator|=
operator|(
operator|(
name|mode
operator|&
name|S_ISUID
operator|)
operator|==
name|S_ISUID
operator|)
expr_stmt|;
name|sendmail_mpe_flaginit
operator|=
name|true
expr_stmt|;
block|}
return|return
name|sendmail_mpe_gidflag
return|;
block|}
end_function

begin_comment
comment|/* **  SENDMAIL_MPE_EMULUID -- should we perform uid emulation? ** **	If sendmail_mpe_uidflag == -1 then obtain the mode bits to determine **	if the setuid bit is on, we want uid emulation and so set **	sendmail_mpe_uidflag to true.  Otherwise we do not want uid emulation **	and so set sendmail_mpe_uidflag to false. ** **	Parameters: **		none. ** **	Returns: **		true -- perform uid emulation **		false -- do not perform uid emulation */
end_comment

begin_function
name|bool
name|sendmail_mpe_emuluid
parameter_list|()
block|{
if|if
condition|(
operator|!
name|sendmail_mpe_flaginit
condition|)
block|{
name|mode_t
name|mode
decl_stmt|;
name|mode
operator|=
name|sendmail_mpe_getmode
argument_list|()
expr_stmt|;
name|sendmail_mpe_gidflag
operator|=
operator|(
operator|(
name|mode
operator|&
name|S_ISGID
operator|)
operator|==
name|S_ISGID
operator|)
expr_stmt|;
name|sendmail_mpe_uidflag
operator|=
operator|(
operator|(
name|mode
operator|&
name|S_ISUID
operator|)
operator|==
name|S_ISUID
operator|)
expr_stmt|;
name|sendmail_mpe_flaginit
operator|=
name|true
expr_stmt|;
block|}
return|return
name|sendmail_mpe_uidflag
return|;
block|}
end_function

begin_comment
comment|/* **  SENDMAIL_MPE_GETEGID -- shadow function for getegid() ** **	If emulation mode is in effect and the saved egid has been **	initialized, return the saved egid; otherwise return the value of the **	real getegid() function. ** **	Parameters: **		none. ** **	Returns: **		emulated egid if present, else true egid. */
end_comment

begin_decl_stmt
specifier|static
name|uid_t
name|sendmail_mpe_egid
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|getegid
end_undef

begin_function
name|gid_t
name|sendmail_mpe_getegid
parameter_list|()
block|{
if|if
condition|(
name|sendmail_mpe_emulgid
argument_list|()
operator|&&
name|sendmail_mpe_egid
operator|!=
operator|-
literal|1
condition|)
return|return
name|sendmail_mpe_egid
return|;
return|return
name|getegid
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* **  SENDMAIL_MPE_GETEUID -- shadow function for geteuid() ** **	If emulation mode is in effect, return the saved euid; otherwise **	return the value of the real geteuid() function. ** **	Note that the initial value of the saved euid is zero, to simulate **	a setuid-root program. ** **	Parameters: **		none ** **	Returns: **		emulated euid if in emulation mode, else true euid. */
end_comment

begin_decl_stmt
specifier|static
name|uid_t
name|sendmail_mpe_euid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|geteuid
end_undef

begin_function
name|uid_t
name|sendmail_mpe_geteuid
parameter_list|()
block|{
if|if
condition|(
name|sendmail_mpe_emuluid
argument_list|()
condition|)
return|return
name|sendmail_mpe_euid
return|;
return|return
name|geteuid
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* **  SENDMAIL_MPE_SETGID -- shadow function for setgid() ** **	Simulate a call to setgid() without actually calling the real **	function.  Implement the expected uid 0 semantics. ** **	Note that sendmail will also be calling setuid() which will force an **	implicit real setgid() to the proper primary gid.  So it doesn't matter **	that we don't actually alter the real gid in this shadow function. ** **	Parameters: **		gid -- desired gid. ** **	Returns: **		0 -- emulated success **		-1 -- emulated failure */
end_comment

begin_undef
undef|#
directive|undef
name|setgid
end_undef

begin_function
name|int
name|sendmail_mpe_setgid
parameter_list|(
name|gid
parameter_list|)
name|gid_t
name|gid
decl_stmt|;
block|{
if|if
condition|(
name|sendmail_mpe_emulgid
argument_list|()
condition|)
block|{
if|if
condition|(
name|gid
operator|==
name|getgid
argument_list|()
operator|||
name|sendmail_mpe_euid
operator|==
literal|0
condition|)
block|{
name|sendmail_mpe_egid
operator|=
name|gid
expr_stmt|;
return|return
literal|0
return|;
block|}
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|setgid
argument_list|(
name|gid
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  SENDMAIL_MPE_SETUID -- shadow function for setuid() ** **	setuid() is broken as of MPE 7.0 in that it changes the current **	working directory to be the home directory of the new uid.  Thus **	we must obtain the cwd and restore it after the setuid(). ** **	Note that expected uid 0 semantics have been added, as well as **	remembering the new uid for later use by the other shadow functions. ** **	Parameters: **		uid -- desired uid. ** **	Returns: **		0 -- success **		-1 -- failure ** **	Globals: **		sendmail_mpe_euid */
end_comment

begin_undef
undef|#
directive|undef
name|setuid
end_undef

begin_function
name|int
name|sendmail_mpe_setuid
parameter_list|(
name|uid
parameter_list|)
name|uid_t
name|uid
decl_stmt|;
block|{
name|char
modifier|*
name|cwd
decl_stmt|;
name|char
name|cwd_buf
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|result
decl_stmt|;
specifier|extern
name|void
name|GETPRIVMODE
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|GETUSERMODE
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|sendmail_mpe_emuluid
argument_list|()
condition|)
block|{
if|if
condition|(
name|uid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sendmail_mpe_euid
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|sendmail_mpe_euid
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Preserve the current working directory */
if|if
condition|(
operator|(
name|cwd
operator|=
name|getcwd
argument_list|(
name|cwd_buf
argument_list|,
name|PATH_MAX
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|GETPRIVMODE
argument_list|()
expr_stmt|;
name|result
operator|=
name|setuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
name|GETUSERMODE
argument_list|()
expr_stmt|;
comment|/* Restore the current working directory */
name|chdir
argument_list|(
name|cwd_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|sendmail_mpe_euid
operator|=
name|uid
expr_stmt|;
return|return
name|result
return|;
block|}
return|return
name|setuid
argument_list|(
name|uid
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MPE */
end_comment

end_unit

