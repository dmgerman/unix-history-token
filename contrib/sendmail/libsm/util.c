begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2006 Sendmail, Inc. and its suppliers.  *	All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_include
include|#
directive|include
file|<sm/gen.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: util.c,v 1.9 2006/08/30 18:35:51 ca Exp $"
argument_list|)
end_macro

begin_include
include|#
directive|include
file|<sm/setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sm/conf.h>
end_include

begin_include
include|#
directive|include
file|<sm/assert.h>
end_include

begin_include
include|#
directive|include
file|<sm/heap.h>
end_include

begin_include
include|#
directive|include
file|<sm/string.h>
end_include

begin_include
include|#
directive|include
file|<sm/sendmail.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* **  STR2PRT -- convert "unprintable" characters in a string to \oct ** **	Parameters: **		s -- string to convert ** **	Returns: **		converted string. **		This is a static local buffer, string must be copied **		before this function is called again! */
end_comment

begin_function
name|char
modifier|*
name|str2prt
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|l
decl_stmt|;
name|char
name|c
decl_stmt|,
modifier|*
name|h
decl_stmt|;
name|bool
name|ok
decl_stmt|;
specifier|static
name|int
name|len
init|=
literal|0
decl_stmt|;
specifier|static
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|ok
operator|=
name|true
expr_stmt|;
for|for
control|(
name|h
operator|=
name|s
operator|,
name|l
operator|=
literal|1
init|;
operator|*
name|h
operator|!=
literal|'\0'
condition|;
name|h
operator|++
operator|,
name|l
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|h
operator|==
literal|'\\'
condition|)
block|{
operator|++
name|l
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|h
argument_list|)
operator|&&
name|isprint
argument_list|(
operator|*
name|h
argument_list|)
operator|)
condition|)
block|{
name|l
operator|+=
literal|3
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ok
condition|)
return|return
name|s
return|;
if|if
condition|(
name|l
operator|>
name|len
condition|)
block|{
name|char
modifier|*
name|nbuf
init|=
name|sm_pmalloc_x
argument_list|(
name|l
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|len
operator|=
name|l
expr_stmt|;
name|buf
operator|=
name|nbuf
expr_stmt|;
block|}
for|for
control|(
name|h
operator|=
name|buf
init|;
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
name|l
operator|>
literal|0
condition|;
name|s
operator|++
operator|,
name|l
operator|--
control|)
block|{
name|c
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|isascii
argument_list|(
name|c
argument_list|)
operator|&&
name|isprint
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'\\'
condition|)
block|{
operator|*
name|h
operator|++
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
operator|*
name|h
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|--
name|l
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
operator|*
name|h
operator|++
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
operator|*
name|h
operator|++
operator|=
literal|'t'
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
operator|*
name|h
operator|++
operator|=
literal|'n'
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
operator|*
name|h
operator|++
operator|=
literal|'r'
expr_stmt|;
break|break;
default|default:
name|SM_ASSERT
argument_list|(
name|l
operator|>=
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|h
argument_list|,
name|l
argument_list|,
literal|"%03o"
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 				**  XXX since l is unsigned this may 				**  wrap around if the calculation is screwed 				**  up... 				*/
name|l
operator|-=
literal|2
expr_stmt|;
name|h
operator|+=
literal|3
expr_stmt|;
break|break;
block|}
block|}
block|}
operator|*
name|h
operator|=
literal|'\0'
expr_stmt|;
name|buf
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* **  QUOTE_INTERNAL_CHARS -- do quoting of internal characters ** **	Necessary to make sure that we don't have metacharacters such **	as the internal versions of "$*" or "$&" in a string. **	The input and output pointers can be the same. ** **	Parameters: **		ibp -- a pointer to the string to translate **		obp -- a pointer to an output buffer **		bsp -- pointer to the length of the output buffer ** **	Returns: **		A possibly new bp (if the buffer needed to grow); if **		it is different, *bsp will updated to the size of **		the new buffer and the caller is responsible for **		freeing the memory. */
end_comment

begin_define
define|#
directive|define
name|SM_MM_QUOTE
parameter_list|(
name|ch
parameter_list|)
value|(((ch)& 0377) == METAQUOTE || (((ch)& 0340) == 0200))
end_define

begin_function
name|char
modifier|*
name|quote_internal_chars
parameter_list|(
name|ibp
parameter_list|,
name|obp
parameter_list|,
name|bsp
parameter_list|)
name|char
modifier|*
name|ibp
decl_stmt|;
name|char
modifier|*
name|obp
decl_stmt|;
name|int
modifier|*
name|bsp
decl_stmt|;
block|{
name|char
modifier|*
name|ip
decl_stmt|,
modifier|*
name|op
decl_stmt|;
name|int
name|bufused
decl_stmt|,
name|olen
decl_stmt|;
name|bool
name|buffer_same
decl_stmt|,
name|needs_quoting
decl_stmt|;
name|buffer_same
operator|=
name|ibp
operator|==
name|obp
expr_stmt|;
name|needs_quoting
operator|=
name|false
expr_stmt|;
comment|/* determine length of output string (starts at 1 for trailing '\0') */
for|for
control|(
name|ip
operator|=
name|ibp
operator|,
name|olen
operator|=
literal|1
init|;
operator|*
name|ip
operator|!=
literal|'\0'
condition|;
name|ip
operator|++
operator|,
name|olen
operator|++
control|)
block|{
if|if
condition|(
name|SM_MM_QUOTE
argument_list|(
operator|*
name|ip
argument_list|)
condition|)
block|{
name|olen
operator|++
expr_stmt|;
name|needs_quoting
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* is the output buffer big enough? */
if|if
condition|(
name|olen
operator|>
operator|*
name|bsp
condition|)
block|{
name|obp
operator|=
name|sm_malloc_x
argument_list|(
name|olen
argument_list|)
expr_stmt|;
name|buffer_same
operator|=
name|false
expr_stmt|;
operator|*
name|bsp
operator|=
name|olen
expr_stmt|;
block|}
comment|/* 	**  shortcut: no change needed? 	**  Note: we don't check this first as some bozo may use the same 	**  buffers but restrict the size of the output buffer to less 	**  than the length of the input buffer in which case we need to 	**  allocate a new buffer. 	*/
if|if
condition|(
operator|!
name|needs_quoting
condition|)
block|{
if|if
condition|(
operator|!
name|buffer_same
condition|)
block|{
name|bufused
operator|=
name|sm_strlcpy
argument_list|(
name|obp
argument_list|,
name|ibp
argument_list|,
operator|*
name|bsp
argument_list|)
expr_stmt|;
name|SM_ASSERT
argument_list|(
name|bufused
operator|<=
name|olen
argument_list|)
expr_stmt|;
block|}
return|return
name|obp
return|;
block|}
if|if
condition|(
name|buffer_same
condition|)
block|{
name|obp
operator|=
name|sm_malloc_x
argument_list|(
name|olen
argument_list|)
expr_stmt|;
name|buffer_same
operator|=
name|false
expr_stmt|;
operator|*
name|bsp
operator|=
name|olen
expr_stmt|;
block|}
for|for
control|(
name|ip
operator|=
name|ibp
operator|,
name|op
operator|=
name|obp
operator|,
name|bufused
operator|=
literal|0
init|;
operator|*
name|ip
operator|!=
literal|'\0'
condition|;
name|ip
operator|++
control|)
block|{
if|if
condition|(
name|SM_MM_QUOTE
argument_list|(
operator|*
name|ip
argument_list|)
condition|)
block|{
name|SM_ASSERT
argument_list|(
name|bufused
operator|<
name|olen
argument_list|)
expr_stmt|;
name|op
index|[
name|bufused
operator|++
index|]
operator|=
name|METAQUOTE
expr_stmt|;
block|}
name|SM_ASSERT
argument_list|(
name|bufused
operator|<
name|olen
argument_list|)
expr_stmt|;
name|op
index|[
name|bufused
operator|++
index|]
operator|=
operator|*
name|ip
expr_stmt|;
block|}
name|op
index|[
name|bufused
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|obp
return|;
block|}
end_function

begin_comment
comment|/* **  DEQUOTE_INTERNAL_CHARS -- undo the effect of quote_internal_chars ** **	Parameters: **		ibp -- a pointer to the string to be translated. **		obp -- a pointer to the output buffer.  Can be the **			same as ibp. **		obs -- the size of the output buffer. ** **	Returns: **		number of character added to obp */
end_comment

begin_function
name|int
name|dequote_internal_chars
parameter_list|(
name|ibp
parameter_list|,
name|obp
parameter_list|,
name|obs
parameter_list|)
name|char
modifier|*
name|ibp
decl_stmt|;
name|char
modifier|*
name|obp
decl_stmt|;
name|int
name|obs
decl_stmt|;
block|{
name|char
modifier|*
name|ip
decl_stmt|,
modifier|*
name|op
decl_stmt|;
name|int
name|len
decl_stmt|;
name|bool
name|quoted
decl_stmt|;
name|quoted
operator|=
name|false
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|ibp
operator|,
name|op
operator|=
name|obp
init|;
operator|*
name|ip
operator|!=
literal|'\0'
condition|;
name|ip
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|ip
operator|&
literal|0377
operator|)
operator|==
name|METAQUOTE
operator|&&
operator|!
name|quoted
condition|)
block|{
name|quoted
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|op
operator|<
operator|&
name|obp
index|[
name|obs
operator|-
literal|1
index|]
condition|)
block|{
operator|*
name|op
operator|++
operator|=
operator|*
name|ip
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|quoted
operator|=
name|false
expr_stmt|;
block|}
operator|*
name|op
operator|=
literal|'\0'
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

end_unit

