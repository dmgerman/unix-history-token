begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2001-2002 Sendmail, Inc. and its suppliers.  *      All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  */
end_comment

begin_include
include|#
directive|include
file|<sm/gen.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: mbdb.c,v 1.38 2002/04/05 22:59:56 gshapiro Exp $"
argument_list|)
end_macro

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sm/limits.h>
end_include

begin_include
include|#
directive|include
file|<sm/conf.h>
end_include

begin_include
include|#
directive|include
file|<sm/assert.h>
end_include

begin_include
include|#
directive|include
file|<sm/bitops.h>
end_include

begin_include
include|#
directive|include
file|<sm/errstring.h>
end_include

begin_include
include|#
directive|include
file|<sm/heap.h>
end_include

begin_include
include|#
directive|include
file|<sm/mbdb.h>
end_include

begin_include
include|#
directive|include
file|<sm/string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EX_OK
end_ifdef

begin_undef
undef|#
directive|undef
name|EX_OK
end_undef

begin_comment
comment|/* for SVr4.2 SMP */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EX_OK */
end_comment

begin_include
include|#
directive|include
file|<sm/sysexits.h>
end_include

begin_if
if|#
directive|if
name|LDAPMAP
end_if

begin_if
if|#
directive|if
name|_LDAP_EXAMPLE_
end_if

begin_include
include|#
directive|include
file|<sm/ldap.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _LDAP_EXAMPLE_ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LDAPMAP */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|mbdb_typename
decl_stmt|;
name|int
argument_list|(
argument|*mbdb_initialize
argument_list|)
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
name|int
argument_list|(
argument|*mbdb_lookup
argument_list|)
name|__P
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
name|SM_MBDB_T
operator|*
name|user
operator|)
argument_list|)
expr_stmt|;
name|void
argument_list|(
argument|*mbdb_terminate
argument_list|)
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
block|}
name|SM_MBDB_TYPE_T
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|int
name|mbdb_pw_initialize
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mbdb_pw_lookup
name|__P
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
name|SM_MBDB_T
operator|*
name|user
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mbdb_pw_terminate
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|LDAPMAP
end_if

begin_if
if|#
directive|if
name|_LDAP_EXAMPLE_
end_if

begin_decl_stmt
specifier|static
name|struct
name|sm_ldap_struct
name|LDAPLMAP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mbdb_ldap_initialize
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mbdb_ldap_lookup
name|__P
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
name|SM_MBDB_T
operator|*
name|user
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mbdb_ldap_terminate
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _LDAP_EXAMPLE_ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LDAPMAP */
end_comment

begin_decl_stmt
specifier|static
name|SM_MBDB_TYPE_T
name|SmMbdbTypes
index|[]
init|=
block|{
block|{
literal|"pw"
block|,
name|mbdb_pw_initialize
block|,
name|mbdb_pw_lookup
block|,
name|mbdb_pw_terminate
block|}
block|,
if|#
directive|if
name|LDAPMAP
if|#
directive|if
name|_LDAP_EXAMPLE_
block|{
literal|"ldap"
block|,
name|mbdb_ldap_initialize
block|,
name|mbdb_ldap_lookup
block|,
name|mbdb_ldap_terminate
block|}
block|,
endif|#
directive|endif
comment|/* _LDAP_EXAMPLE_ */
endif|#
directive|endif
comment|/* LDAPMAP */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SM_MBDB_TYPE_T
modifier|*
name|SmMbdbType
init|=
operator|&
name|SmMbdbTypes
index|[
literal|0
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  SM_MBDB_INITIALIZE -- specify which mailbox database to use ** **	If this function is not called, then the "pw" implementation **	is used by default; this implementation uses getpwnam(). ** **	Parameters: **		mbdb -- Which mailbox database to use. **			The argument has the form "name" or "name.arg". **			"pw" means use getpwnam(). ** **	Results: **		EX_OK on success, or an EX_* code on failure. */
end_comment

begin_function
name|int
name|sm_mbdb_initialize
parameter_list|(
name|mbdb
parameter_list|)
name|char
modifier|*
name|mbdb
decl_stmt|;
block|{
name|size_t
name|namelen
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
name|SM_MBDB_TYPE_T
modifier|*
name|t
decl_stmt|;
name|SM_REQUIRE
argument_list|(
name|mbdb
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|name
operator|=
name|mbdb
expr_stmt|;
name|arg
operator|=
name|strchr
argument_list|(
name|mbdb
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
name|namelen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|namelen
operator|=
name|arg
operator|-
name|name
expr_stmt|;
operator|++
name|arg
expr_stmt|;
block|}
for|for
control|(
name|t
operator|=
name|SmMbdbTypes
init|;
name|t
operator|->
name|mbdb_typename
operator|!=
name|NULL
condition|;
operator|++
name|t
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|t
operator|->
name|mbdb_typename
argument_list|)
operator|==
name|namelen
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
name|t
operator|->
name|mbdb_typename
argument_list|,
name|namelen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|EX_OK
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|mbdb_initialize
operator|!=
name|NULL
condition|)
name|err
operator|=
name|t
operator|->
name|mbdb_initialize
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EX_OK
condition|)
name|SmMbdbType
operator|=
name|t
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
return|return
name|EX_UNAVAILABLE
return|;
block|}
end_function

begin_comment
comment|/* **  SM_MBDB_TERMINATE -- terminate connection to the mailbox database ** **	Because this function closes any cached file descriptors that **	are being held open for the connection to the mailbox database, **	it should be called for security reasons prior to dropping privileges **	and execing another process. ** **	Parameters: **		none. ** **	Results: **		none. */
end_comment

begin_function
name|void
name|sm_mbdb_terminate
parameter_list|()
block|{
if|if
condition|(
name|SmMbdbType
operator|->
name|mbdb_terminate
operator|!=
name|NULL
condition|)
name|SmMbdbType
operator|->
name|mbdb_terminate
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  SM_MBDB_LOOKUP -- look up a local mail recipient, given name ** **	Parameters: **		name -- name of local mail recipient **		user -- pointer to structure to fill in on success ** **	Results: **		On success, fill in *user and return EX_OK. **		If the user does not exist, return EX_NOUSER. **		If a temporary failure (eg, a network failure) occurred, **		return EX_TEMPFAIL.  Otherwise return EX_OSERR. */
end_comment

begin_function
name|int
name|sm_mbdb_lookup
parameter_list|(
name|name
parameter_list|,
name|user
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|SM_MBDB_T
modifier|*
name|user
decl_stmt|;
block|{
name|int
name|ret
init|=
name|EX_NOUSER
decl_stmt|;
if|if
condition|(
name|SmMbdbType
operator|->
name|mbdb_lookup
operator|!=
name|NULL
condition|)
name|ret
operator|=
name|SmMbdbType
operator|->
name|mbdb_lookup
argument_list|(
name|name
argument_list|,
name|user
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* **  SM_MBDB_FROMPW -- copy from struct pw to SM_MBDB_T ** **	Parameters: **		user -- destination user information structure **		pw -- source passwd structure ** **	Results: **		none. */
end_comment

begin_function
name|void
name|sm_mbdb_frompw
parameter_list|(
name|user
parameter_list|,
name|pw
parameter_list|)
name|SM_MBDB_T
modifier|*
name|user
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
block|{
name|SM_REQUIRE
argument_list|(
name|user
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|user
operator|->
name|mbdb_name
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
sizeof|sizeof
argument_list|(
name|user
operator|->
name|mbdb_name
argument_list|)
argument_list|)
expr_stmt|;
name|user
operator|->
name|mbdb_uid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
name|user
operator|->
name|mbdb_gid
operator|=
name|pw
operator|->
name|pw_gid
expr_stmt|;
name|sm_pwfullname
argument_list|(
name|pw
operator|->
name|pw_gecos
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
name|user
operator|->
name|mbdb_fullname
argument_list|,
sizeof|sizeof
argument_list|(
name|user
operator|->
name|mbdb_fullname
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|user
operator|->
name|mbdb_homedir
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|,
sizeof|sizeof
argument_list|(
name|user
operator|->
name|mbdb_homedir
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|user
operator|->
name|mbdb_shell
argument_list|,
name|pw
operator|->
name|pw_shell
argument_list|,
sizeof|sizeof
argument_list|(
name|user
operator|->
name|mbdb_shell
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  SM_PWFULLNAME -- build full name of user from pw_gecos field. ** **	This routine interprets the strange entry that would appear **	in the GECOS field of the password file. ** **	Parameters: **		gecos -- name to build. **		user -- the login name of this user (for&). **		buf -- place to put the result. **		buflen -- length of buf. ** **	Returns: **		none. */
end_comment

begin_if
if|#
directive|if
name|_FFR_HANDLE_ISO8859_GECOS
end_if

begin_decl_stmt
specifier|static
name|char
name|Latin1ToASCII
index|[
literal|128
index|]
init|=
block|{
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|32
block|,
literal|33
block|,
literal|99
block|,
literal|80
block|,
literal|36
block|,
literal|89
block|,
literal|124
block|,
literal|36
block|,
literal|34
block|,
literal|99
block|,
literal|97
block|,
literal|60
block|,
literal|45
block|,
literal|45
block|,
literal|114
block|,
literal|45
block|,
literal|111
block|,
literal|42
block|,
literal|50
block|,
literal|51
block|,
literal|39
block|,
literal|117
block|,
literal|80
block|,
literal|46
block|,
literal|44
block|,
literal|49
block|,
literal|111
block|,
literal|62
block|,
literal|42
block|,
literal|42
block|,
literal|42
block|,
literal|63
block|,
literal|65
block|,
literal|65
block|,
literal|65
block|,
literal|65
block|,
literal|65
block|,
literal|65
block|,
literal|65
block|,
literal|67
block|,
literal|69
block|,
literal|69
block|,
literal|69
block|,
literal|69
block|,
literal|73
block|,
literal|73
block|,
literal|73
block|,
literal|73
block|,
literal|68
block|,
literal|78
block|,
literal|79
block|,
literal|79
block|,
literal|79
block|,
literal|79
block|,
literal|79
block|,
literal|88
block|,
literal|79
block|,
literal|85
block|,
literal|85
block|,
literal|85
block|,
literal|85
block|,
literal|89
block|,
literal|80
block|,
literal|66
block|,
literal|97
block|,
literal|97
block|,
literal|97
block|,
literal|97
block|,
literal|97
block|,
literal|97
block|,
literal|97
block|,
literal|99
block|,
literal|101
block|,
literal|101
block|,
literal|101
block|,
literal|101
block|,
literal|105
block|,
literal|105
block|,
literal|105
block|,
literal|105
block|,
literal|100
block|,
literal|110
block|,
literal|111
block|,
literal|111
block|,
literal|111
block|,
literal|111
block|,
literal|111
block|,
literal|47
block|,
literal|111
block|,
literal|117
block|,
literal|117
block|,
literal|117
block|,
literal|117
block|,
literal|121
block|,
literal|112
block|,
literal|121
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_HANDLE_ISO8859_GECOS */
end_comment

begin_function
name|void
name|sm_pwfullname
parameter_list|(
name|gecos
parameter_list|,
name|user
parameter_list|,
name|buf
parameter_list|,
name|buflen
parameter_list|)
specifier|register
name|char
modifier|*
name|gecos
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|buflen
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
init|=
name|buf
decl_stmt|;
if|if
condition|(
operator|*
name|gecos
operator|==
literal|'*'
condition|)
name|gecos
operator|++
expr_stmt|;
comment|/* copy gecos, interpolating& to be full name */
for|for
control|(
name|p
operator|=
name|gecos
init|;
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|','
operator|&&
operator|*
name|p
operator|!=
literal|';'
operator|&&
operator|*
name|p
operator|!=
literal|'%'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|bp
operator|>=
operator|&
name|buf
index|[
name|buflen
operator|-
literal|1
index|]
condition|)
block|{
comment|/* buffer overflow -- just use login name */
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|buf
argument_list|,
name|user
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'&'
condition|)
block|{
comment|/* interpolate full name */
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|bp
argument_list|,
name|user
argument_list|,
name|buflen
operator|-
operator|(
name|bp
operator|-
name|buf
operator|)
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
name|toupper
argument_list|(
operator|*
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|_FFR_HANDLE_ISO8859_GECOS
if|if
condition|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
operator|>=
literal|128
condition|)
operator|*
name|bp
operator|++
operator|=
name|Latin1ToASCII
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
operator|-
literal|128
index|]
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* _FFR_HANDLE_ISO8859_GECOS */
operator|*
name|bp
operator|++
operator|=
operator|*
name|p
expr_stmt|;
block|}
block|}
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  /etc/passwd implementation. */
end_comment

begin_comment
comment|/* **  MBDB_PW_INITIALIZE -- initialize getpwnam() version ** **	Parameters: **		arg -- unused. ** **	Results: **		EX_OK. */
end_comment

begin_comment
comment|/* ARGSUSED0 */
end_comment

begin_function
specifier|static
name|int
name|mbdb_pw_initialize
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
return|return
name|EX_OK
return|;
block|}
end_function

begin_comment
comment|/* **  MBDB_PW_LOOKUP -- look up a local mail recipient, given name ** **	Parameters: **		name -- name of local mail recipient **		user -- pointer to structure to fill in on success ** **	Results: **		On success, fill in *user and return EX_OK. **		Failure: EX_NOUSER. */
end_comment

begin_function
specifier|static
name|int
name|mbdb_pw_lookup
parameter_list|(
name|name
parameter_list|,
name|user
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|SM_MBDB_T
modifier|*
name|user
decl_stmt|;
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
ifdef|#
directive|ifdef
name|HESIOD
comment|/* DEC Hesiod getpwnam accepts numeric strings -- short circuit it */
block|{
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
name|EX_NOUSER
return|;
block|}
endif|#
directive|endif
comment|/* HESIOD */
name|errno
operator|=
literal|0
expr_stmt|;
name|pw
operator|=
name|getpwnam
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
literal|0
comment|/* 		**  getpwnam() isn't advertised as setting errno. 		**  In fact, under FreeBSD, non-root getpwnam() on 		**  non-existant users returns NULL with errno = EPERM. 		**  This test won't work. 		*/
block|switch (errno) 		{ 		  case 0: 			return EX_NOUSER; 		  case EIO: 			return EX_OSERR; 		  default: 			return EX_TEMPFAIL; 		}
endif|#
directive|endif
comment|/* 0 */
return|return
name|EX_NOUSER
return|;
block|}
name|sm_mbdb_frompw
argument_list|(
name|user
argument_list|,
name|pw
argument_list|)
expr_stmt|;
return|return
name|EX_OK
return|;
block|}
end_function

begin_comment
comment|/* **  MBDB_PW_TERMINATE -- terminate connection to the mailbox database ** **	Parameters: **		none. ** **	Results: **		none. */
end_comment

begin_function
specifier|static
name|void
name|mbdb_pw_terminate
parameter_list|()
block|{
name|endpwent
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|LDAPMAP
end_if

begin_if
if|#
directive|if
name|_LDAP_EXAMPLE_
end_if

begin_comment
comment|/* **  LDAP example implementation based on RFC 2307, "An Approach for Using **  LDAP as a Network Information Service": ** **	( nisSchema.1.0 NAME 'uidNumber' **	  DESC 'An integer uniquely identifying a user in an **		administrative domain' **	  EQUALITY integerMatch SYNTAX 'INTEGER' SINGLE-VALUE ) ** **	( nisSchema.1.1 NAME 'gidNumber' **	  DESC 'An integer uniquely identifying a group in an **		administrative domain' **	  EQUALITY integerMatch SYNTAX 'INTEGER' SINGLE-VALUE ) ** **	( nisSchema.1.2 NAME 'gecos' **	  DESC 'The GECOS field; the common name' **	  EQUALITY caseIgnoreIA5Match **	  SUBSTRINGS caseIgnoreIA5SubstringsMatch **	  SYNTAX 'IA5String' SINGLE-VALUE ) ** **	( nisSchema.1.3 NAME 'homeDirectory' **	  DESC 'The absolute path to the home directory' **	  EQUALITY caseExactIA5Match **	  SYNTAX 'IA5String' SINGLE-VALUE ) ** **	( nisSchema.1.4 NAME 'loginShell' **	  DESC 'The path to the login shell' **	  EQUALITY caseExactIA5Match **	  SYNTAX 'IA5String' SINGLE-VALUE ) ** **	( nisSchema.2.0 NAME 'posixAccount' SUP top AUXILIARY **	  DESC 'Abstraction of an account with POSIX attributes' **	  MUST ( cn $ uid $ uidNumber $ gidNumber $ homeDirectory ) **	  MAY ( userPassword $ loginShell $ gecos $ description ) ) ** */
end_comment

begin_define
define|#
directive|define
name|MBDB_LDAP_LABEL
value|"MailboxDatabase"
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|MBDB_LDAP_FILTER
end_ifndef

begin_define
define|#
directive|define
name|MBDB_LDAP_FILTER
value|"(&(objectClass=posixAccount)(uid=%0))"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MBDB_LDAP_FILTER */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MBDB_DEFAULT_LDAP_BASEDN
end_ifndef

begin_define
define|#
directive|define
name|MBDB_DEFAULT_LDAP_BASEDN
value|NULL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MBDB_DEFAULT_LDAP_BASEDN */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MBDB_DEFAULT_LDAP_SERVER
end_ifndef

begin_define
define|#
directive|define
name|MBDB_DEFAULT_LDAP_SERVER
value|NULL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MBDB_DEFAULT_LDAP_SERVER */
end_comment

begin_comment
comment|/* **  MBDB_LDAP_INITIALIZE -- initialize LDAP version ** **	Parameters: **		arg -- LDAP specification ** **	Results: **		EX_OK on success, or an EX_* code on failure. */
end_comment

begin_function
specifier|static
name|int
name|mbdb_ldap_initialize
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|sm_ldap_clear
argument_list|(
operator|&
name|LDAPLMAP
argument_list|)
expr_stmt|;
name|LDAPLMAP
operator|.
name|ldap_base
operator|=
name|MBDB_DEFAULT_LDAP_BASEDN
expr_stmt|;
name|LDAPLMAP
operator|.
name|ldap_target
operator|=
name|MBDB_DEFAULT_LDAP_SERVER
expr_stmt|;
name|LDAPLMAP
operator|.
name|ldap_filter
operator|=
name|MBDB_LDAP_FILTER
expr_stmt|;
comment|/* Only want one match */
name|LDAPLMAP
operator|.
name|ldap_sizelimit
operator|=
literal|1
expr_stmt|;
comment|/* interpolate new ldap_base and ldap_target from arg if given */
if|if
condition|(
name|arg
operator|!=
name|NULL
operator|&&
operator|*
name|arg
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|new
decl_stmt|;
name|char
modifier|*
name|sep
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
expr_stmt|;
name|new
operator|=
name|sm_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
return|return
name|EX_TEMPFAIL
return|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|new
argument_list|,
name|arg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sep
operator|=
name|strrchr
argument_list|(
name|new
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|!=
name|NULL
condition|)
block|{
operator|*
name|sep
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|LDAPLMAP
operator|.
name|ldap_target
operator|=
name|sep
expr_stmt|;
block|}
name|LDAPLMAP
operator|.
name|ldap_base
operator|=
name|new
expr_stmt|;
block|}
comment|/* No connection yet, connect */
if|if
condition|(
operator|!
name|sm_ldap_start
argument_list|(
name|MBDB_LDAP_LABEL
argument_list|,
operator|&
name|LDAPLMAP
argument_list|)
condition|)
return|return
name|EX_UNAVAILABLE
return|;
return|return
name|EX_OK
return|;
block|}
end_function

begin_comment
comment|/* **  MBDB_LDAP_LOOKUP -- look up a local mail recipient, given name ** **	Parameters: **		name -- name of local mail recipient **		user -- pointer to structure to fill in on success ** **	Results: **		On success, fill in *user and return EX_OK. **		Failure: EX_NOUSER. */
end_comment

begin_define
define|#
directive|define
name|NEED_FULLNAME
value|0x01
end_define

begin_define
define|#
directive|define
name|NEED_HOMEDIR
value|0x02
end_define

begin_define
define|#
directive|define
name|NEED_SHELL
value|0x04
end_define

begin_define
define|#
directive|define
name|NEED_UID
value|0x08
end_define

begin_define
define|#
directive|define
name|NEED_GID
value|0x10
end_define

begin_function
specifier|static
name|int
name|mbdb_ldap_lookup
parameter_list|(
name|name
parameter_list|,
name|user
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|SM_MBDB_T
modifier|*
name|user
decl_stmt|;
block|{
name|int
name|msgid
decl_stmt|;
name|int
name|need
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
name|LDAPMessage
modifier|*
name|entry
decl_stmt|;
name|BerElement
modifier|*
name|ber
decl_stmt|;
name|char
modifier|*
name|attr
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|user
operator|->
name|mbdb_name
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|EX_NOUSER
return|;
block|}
if|if
condition|(
name|LDAPLMAP
operator|.
name|ldap_filter
operator|==
name|NULL
condition|)
block|{
comment|/* map not initialized, but don't have arg here */
name|errno
operator|=
name|EFAULT
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
if|if
condition|(
name|LDAPLMAP
operator|.
name|ldap_ld
operator|==
name|NULL
condition|)
block|{
comment|/* map not open, try to open now */
if|if
condition|(
operator|!
name|sm_ldap_start
argument_list|(
name|MBDB_LDAP_LABEL
argument_list|,
operator|&
name|LDAPLMAP
argument_list|)
condition|)
return|return
name|EX_TEMPFAIL
return|;
block|}
name|sm_ldap_setopts
argument_list|(
name|LDAPLMAP
operator|.
name|ldap_ld
argument_list|,
operator|&
name|LDAPLMAP
argument_list|)
expr_stmt|;
name|msgid
operator|=
name|sm_ldap_search
argument_list|(
operator|&
name|LDAPLMAP
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgid
operator|==
operator|-
literal|1
condition|)
block|{
name|save_errno
operator|=
name|sm_ldap_geterrno
argument_list|(
name|LDAPLMAP
operator|.
name|ldap_ld
argument_list|)
operator|+
name|E_LDAPBASE
expr_stmt|;
ifdef|#
directive|ifdef
name|LDAP_SERVER_DOWN
if|if
condition|(
name|errno
operator|==
name|LDAP_SERVER_DOWN
condition|)
block|{
comment|/* server disappeared, try reopen on next search */
name|sm_ldap_close
argument_list|(
operator|&
name|LDAPLMAP
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* LDAP_SERVER_DOWN */
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
comment|/* Get results */
name|ret
operator|=
name|ldap_result
argument_list|(
name|LDAPLMAP
operator|.
name|ldap_ld
argument_list|,
name|msgid
argument_list|,
literal|1
argument_list|,
operator|(
name|LDAPLMAP
operator|.
name|ldap_timeout
operator|.
name|tv_sec
operator|==
literal|0
condition|?
name|NULL
else|:
operator|&
operator|(
name|LDAPLMAP
operator|.
name|ldap_timeout
operator|)
operator|)
argument_list|,
operator|&
operator|(
name|LDAPLMAP
operator|.
name|ldap_res
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LDAP_RES_SEARCH_RESULT
operator|&&
name|ret
operator|!=
name|LDAP_RES_SEARCH_ENTRY
condition|)
block|{
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|errno
operator|=
name|ETIMEDOUT
expr_stmt|;
else|else
name|errno
operator|=
name|sm_ldap_geterrno
argument_list|(
name|LDAPLMAP
operator|.
name|ldap_ld
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EX_TEMPFAIL
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
name|entry
operator|=
name|ldap_first_entry
argument_list|(
name|LDAPLMAP
operator|.
name|ldap_ld
argument_list|,
name|LDAPLMAP
operator|.
name|ldap_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|save_errno
operator|=
name|sm_ldap_geterrno
argument_list|(
name|LDAPLMAP
operator|.
name|ldap_ld
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_errno
operator|==
name|LDAP_SUCCESS
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
name|ret
operator|=
name|EX_NOUSER
expr_stmt|;
block|}
else|else
block|{
name|errno
operator|=
name|save_errno
expr_stmt|;
name|ret
operator|=
name|EX_TEMPFAIL
expr_stmt|;
block|}
goto|goto
name|abort
goto|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LDAP_VERSION_MAX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|LDAP_OPT_SIZELIMIT
argument_list|)
comment|/* 	**  Reset value to prevent lingering 	**  LDAP_DECODING_ERROR due to 	**  OpenLDAP 1.X's hack (see below) 	*/
name|LDAPLMAP
operator|.
name|ldap_ld
operator|->
name|ld_errno
operator|=
name|LDAP_SUCCESS
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(LDAP_VERSION_MAX) !defined(LDAP_OPT_SIZELIMIT) */
name|ret
operator|=
name|EX_OK
expr_stmt|;
name|need
operator|=
name|NEED_FULLNAME
operator||
name|NEED_HOMEDIR
operator||
name|NEED_SHELL
operator||
name|NEED_UID
operator||
name|NEED_GID
expr_stmt|;
for|for
control|(
name|attr
operator|=
name|ldap_first_attribute
argument_list|(
name|LDAPLMAP
operator|.
name|ldap_ld
argument_list|,
name|entry
argument_list|,
operator|&
name|ber
argument_list|)
init|;
name|attr
operator|!=
name|NULL
condition|;
name|attr
operator|=
name|ldap_next_attribute
argument_list|(
name|LDAPLMAP
operator|.
name|ldap_ld
argument_list|,
name|entry
argument_list|,
name|ber
argument_list|)
control|)
block|{
name|char
modifier|*
modifier|*
name|vals
decl_stmt|;
name|vals
operator|=
name|ldap_get_values
argument_list|(
name|LDAPLMAP
operator|.
name|ldap_ld
argument_list|,
name|entry
argument_list|,
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|vals
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|sm_ldap_geterrno
argument_list|(
name|LDAPLMAP
operator|.
name|ldap_ld
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|LDAP_SUCCESS
condition|)
block|{
name|ldap_memfree
argument_list|(
name|attr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Must be an error */
name|errno
operator|+=
name|E_LDAPBASE
expr_stmt|;
name|ret
operator|=
name|EX_TEMPFAIL
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LDAP_VERSION_MAX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|LDAP_OPT_SIZELIMIT
argument_list|)
comment|/* 		**  Reset value to prevent lingering 		**  LDAP_DECODING_ERROR due to 		**  OpenLDAP 1.X's hack (see below) 		*/
name|LDAPLMAP
operator|.
name|ldap_ld
operator|->
name|ld_errno
operator|=
name|LDAP_SUCCESS
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(LDAP_VERSION_MAX) !defined(LDAP_OPT_SIZELIMIT) */
if|if
condition|(
name|vals
index|[
literal|0
index|]
operator|==
name|NULL
operator|||
name|vals
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
goto|goto
name|skip
goto|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|attr
argument_list|,
literal|"gecos"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|NEED_FULLNAME
argument_list|,
name|need
argument_list|)
operator|||
name|strlen
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|user
operator|->
name|mbdb_fullname
argument_list|)
condition|)
goto|goto
name|skip
goto|;
name|sm_pwfullname
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|,
name|name
argument_list|,
name|user
operator|->
name|mbdb_fullname
argument_list|,
sizeof|sizeof
argument_list|(
name|user
operator|->
name|mbdb_fullname
argument_list|)
argument_list|)
expr_stmt|;
name|need
operator|&=
operator|~
name|NEED_FULLNAME
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|attr
argument_list|,
literal|"homeDirectory"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|NEED_HOMEDIR
argument_list|,
name|need
argument_list|)
operator|||
name|strlen
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|user
operator|->
name|mbdb_homedir
argument_list|)
condition|)
goto|goto
name|skip
goto|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|user
operator|->
name|mbdb_homedir
argument_list|,
name|vals
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|user
operator|->
name|mbdb_homedir
argument_list|)
argument_list|)
expr_stmt|;
name|need
operator|&=
operator|~
name|NEED_HOMEDIR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|attr
argument_list|,
literal|"loginShell"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|NEED_SHELL
argument_list|,
name|need
argument_list|)
operator|||
name|strlen
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|user
operator|->
name|mbdb_shell
argument_list|)
condition|)
goto|goto
name|skip
goto|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|user
operator|->
name|mbdb_shell
argument_list|,
name|vals
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|user
operator|->
name|mbdb_shell
argument_list|)
argument_list|)
expr_stmt|;
name|need
operator|&=
operator|~
name|NEED_SHELL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|attr
argument_list|,
literal|"uidNumber"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|NEED_UID
argument_list|,
name|need
argument_list|)
condition|)
goto|goto
name|skip
goto|;
for|for
control|(
name|p
operator|=
name|vals
index|[
literal|0
index|]
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
comment|/* allow negative numbers */
if|if
condition|(
name|p
operator|==
name|vals
index|[
literal|0
index|]
operator|&&
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
comment|/* but not simply '-' */
if|if
condition|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'\0'
condition|)
goto|goto
name|skip
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|skip
goto|;
block|}
name|user
operator|->
name|mbdb_uid
operator|=
name|atoi
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|need
operator|&=
operator|~
name|NEED_UID
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|attr
argument_list|,
literal|"gidNumber"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|NEED_GID
argument_list|,
name|need
argument_list|)
condition|)
goto|goto
name|skip
goto|;
for|for
control|(
name|p
operator|=
name|vals
index|[
literal|0
index|]
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
comment|/* allow negative numbers */
if|if
condition|(
name|p
operator|==
name|vals
index|[
literal|0
index|]
operator|&&
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
comment|/* but not simply '-' */
if|if
condition|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'\0'
condition|)
goto|goto
name|skip
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|skip
goto|;
block|}
name|user
operator|->
name|mbdb_gid
operator|=
name|atoi
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|need
operator|&=
operator|~
name|NEED_GID
expr_stmt|;
block|}
name|skip
label|:
name|ldap_value_free
argument_list|(
name|vals
argument_list|)
expr_stmt|;
name|ldap_memfree
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
name|sm_ldap_geterrno
argument_list|(
name|LDAPLMAP
operator|.
name|ldap_ld
argument_list|)
expr_stmt|;
comment|/* 	**  We check errno != LDAP_DECODING_ERROR since 	**  OpenLDAP 1.X has a very ugly *undocumented* 	**  hack of returning this error code from 	**  ldap_next_attribute() if the library freed the 	**  ber attribute.  See: 	**  http://www.openldap.org/lists/openldap-devel/9901/msg00064.html 	*/
if|if
condition|(
name|errno
operator|!=
name|LDAP_SUCCESS
operator|&&
name|errno
operator|!=
name|LDAP_DECODING_ERROR
condition|)
block|{
comment|/* Must be an error */
name|errno
operator|+=
name|E_LDAPBASE
expr_stmt|;
name|ret
operator|=
name|EX_TEMPFAIL
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
name|abort
label|:
name|save_errno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|attr
operator|!=
name|NULL
condition|)
block|{
name|ldap_memfree
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|attr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|LDAPLMAP
operator|.
name|ldap_res
operator|!=
name|NULL
condition|)
block|{
name|ldap_msgfree
argument_list|(
name|LDAPLMAP
operator|.
name|ldap_res
argument_list|)
expr_stmt|;
name|LDAPLMAP
operator|.
name|ldap_res
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|EX_OK
condition|)
block|{
if|if
condition|(
name|need
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|user
operator|->
name|mbdb_name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|user
operator|->
name|mbdb_name
argument_list|)
argument_list|)
expr_stmt|;
name|save_errno
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|EX_NOUSER
expr_stmt|;
name|save_errno
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* **  MBDB_LDAP_TERMINATE -- terminate connection to the mailbox database ** **	Parameters: **		none. ** **	Results: **		none. */
end_comment

begin_function
specifier|static
name|void
name|mbdb_ldap_terminate
parameter_list|()
block|{
name|sm_ldap_close
argument_list|(
operator|&
name|LDAPLMAP
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _LDAP_EXAMPLE_ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LDAPMAP */
end_comment

end_unit

