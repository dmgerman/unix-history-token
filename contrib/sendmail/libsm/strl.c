begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1999-2002 Sendmail, Inc. and its suppliers.  *	All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_include
include|#
directive|include
file|<sm/gen.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: strl.c,v 1.31 2002/01/20 01:41:25 gshapiro Exp $"
argument_list|)
end_macro

begin_include
include|#
directive|include
file|<sm/config.h>
end_include

begin_include
include|#
directive|include
file|<sm/string.h>
end_include

begin_comment
comment|/* **  Notice: this file is used by libmilter. Please try to avoid **	using libsm specific functions. */
end_comment

begin_comment
comment|/* **  XXX the type of the length parameter has been changed **  from size_t to ssize_t to avoid theoretical problems with negative **  numbers passed into these functions. **  The real solution to this problem is to make sure that this doesn't **  happen, but for now we'll use this workaround. */
end_comment

begin_comment
comment|/* **  SM_STRLCPY -- size bounded string copy ** **	This is a bounds-checking variant of strcpy. **	If size> 0, copy up to size-1 characters from the nul terminated **	string src to dst, nul terminating the result.  If size == 0, **	the dst buffer is not modified. **	Additional note: this function has been "tuned" to run fast and tested **	as such (versus versions in some OS's libc). ** **	The result is strlen(src).  You can detect truncation (not all **	of the characters in the source string were copied) using the **	following idiom: ** **		char *s, buf[BUFSIZ]; **		... **		if (sm_strlcpy(buf, s, sizeof(buf))>= sizeof(buf)) **			goto overflow; ** **	Parameters: **		dst -- destination buffer **		src -- source string **		size -- size of destination buffer ** **	Returns: **		strlen(src) */
end_comment

begin_function
name|size_t
name|sm_strlcpy
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|size
parameter_list|)
specifier|register
name|char
modifier|*
name|dst
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
name|ssize_t
name|size
decl_stmt|;
block|{
specifier|register
name|ssize_t
name|i
decl_stmt|;
if|if
condition|(
name|size
operator|--
operator|<=
literal|0
condition|)
return|return
name|strlen
argument_list|(
name|src
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|&&
operator|(
name|dst
index|[
name|i
index|]
operator|=
name|src
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
continue|continue;
name|dst
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|src
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
return|return
name|i
return|;
else|else
return|return
name|i
operator|+
name|strlen
argument_list|(
name|src
operator|+
name|i
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  SM_STRLCAT -- size bounded string concatenation ** **	This is a bounds-checking variant of strcat. **	If strlen(dst)< size, then append at most size - strlen(dst) - 1 **	characters from the source string to the destination string, **	nul terminating the result.  Otherwise, dst is not modified. ** **	The result is the initial length of dst + the length of src. **	You can detect overflow (not all of the characters in the **	source string were copied) using the following idiom: ** **		char *s, buf[BUFSIZ]; **		... **		if (sm_strlcat(buf, s, sizeof(buf))>= sizeof(buf)) **			goto overflow; ** **	Parameters: **		dst -- nul-terminated destination string buffer **		src -- nul-terminated source string **		size -- size of destination buffer ** **	Returns: **		total length of the string tried to create **		(= initial length of dst + length of src) */
end_comment

begin_function
name|size_t
name|sm_strlcat
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|size
parameter_list|)
specifier|register
name|char
modifier|*
name|dst
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
name|ssize_t
name|size
decl_stmt|;
block|{
specifier|register
name|ssize_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|o
decl_stmt|;
name|o
operator|=
name|strlen
argument_list|(
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|o
operator|+
literal|1
condition|)
return|return
name|o
operator|+
name|strlen
argument_list|(
name|src
argument_list|)
return|;
name|size
operator|-=
name|o
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|o
init|;
name|i
operator|<
name|size
operator|&&
operator|(
name|dst
index|[
name|j
index|]
operator|=
name|src
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
continue|continue;
name|dst
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|src
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
return|return
name|j
return|;
else|else
return|return
name|j
operator|+
name|strlen
argument_list|(
name|src
operator|+
name|i
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  SM_STRLCAT2 -- append two strings to dst obeying length and **		'\0' terminate it ** **		strlcat2 will append at most len - strlen(dst) - 1 chars. **		terminates with '\0' if len> 0 **		dst = dst "+" src1 "+" src2 **		use this instead of sm_strlcat(dst,src1); sm_strlcat(dst,src2); **		for better speed. ** **	Parameters: **		dst -- "destination" string. **		src1 -- "from" string 1. **		src2 -- "from" string 2. **		len -- max. length of "destination" string. ** **	Returns: **		total length of the string tried to create **		(= initial length of dst + length of src) **		if this is greater than len then an overflow would have **		occurred. ** */
end_comment

begin_function
name|size_t
name|sm_strlcat2
parameter_list|(
name|dst
parameter_list|,
name|src1
parameter_list|,
name|src2
parameter_list|,
name|len
parameter_list|)
specifier|register
name|char
modifier|*
name|dst
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|src1
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|src2
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
block|{
specifier|register
name|ssize_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|o
decl_stmt|;
comment|/* current size of dst */
name|o
operator|=
name|strlen
argument_list|(
name|dst
argument_list|)
expr_stmt|;
comment|/* max. size is less than current? */
if|if
condition|(
name|len
operator|<
name|o
operator|+
literal|1
condition|)
return|return
name|o
operator|+
name|strlen
argument_list|(
name|src1
argument_list|)
operator|+
name|strlen
argument_list|(
name|src2
argument_list|)
return|;
name|len
operator|-=
name|o
operator|+
literal|1
expr_stmt|;
comment|/* space left in dst */
comment|/* copy the first string; i: index in src1; j: index in dst */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|o
init|;
name|i
operator|<
name|len
operator|&&
operator|(
name|dst
index|[
name|j
index|]
operator|=
name|src1
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
continue|continue;
comment|/* src1: end reached? */
if|if
condition|(
name|src1
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* no: terminate dst; there is space since i< len */
name|dst
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|j
operator|+
name|strlen
argument_list|(
name|src1
operator|+
name|i
argument_list|)
operator|+
name|strlen
argument_list|(
name|src2
argument_list|)
return|;
block|}
name|len
operator|-=
name|i
expr_stmt|;
comment|/* space left in dst */
comment|/* copy the second string; i: index in src2; j: index in dst */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|&&
operator|(
name|dst
index|[
name|j
index|]
operator|=
name|src2
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
continue|continue;
name|dst
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate dst; there is space since i< len */
if|if
condition|(
name|src2
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
return|return
name|j
return|;
else|else
return|return
name|j
operator|+
name|strlen
argument_list|(
name|src2
operator|+
name|i
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  SM_STRLCPYN -- concatenate n strings and assign the result to dst **		while obeying length and '\0' terminate it ** **		dst = src1 "+" src2 "+" ... **		use this instead of sm_snprintf() for string values **		and repeated sm_strlc*() calls for better speed. ** **	Parameters: **		dst -- "destination" string. **		len -- max. length of "destination" string. **		n -- number of strings **		strings... ** **	Returns: **		total length of the string tried to create **		(= initial length of dst + length of src) **		if this is greater than len then an overflow would have **		occurred. */
end_comment

begin_function
name|size_t
ifdef|#
directive|ifdef
name|__STDC__
name|sm_strlcpyn
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
name|ssize_t
name|len
parameter_list|,
name|int
name|n
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
comment|/* __STDC__ */
function|sm_strlcpyn
parameter_list|(
name|dst
parameter_list|,
name|len
parameter_list|,
name|n
parameter_list|,
name|va_alist
parameter_list|)
specifier|register
name|char
modifier|*
name|dst
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|int
name|n
decl_stmt|;
function|va_dcl
endif|#
directive|endif
comment|/* __STDC__ */
block|{
specifier|register
name|ssize_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|SM_VA_LOCAL_DECL
name|SM_VA_START
argument_list|(
name|ap
argument_list|,
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|--
operator|<=
literal|0
condition|)
comment|/* This allows space for the terminating '\0' */
block|{
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
name|i
operator|+=
name|strlen
argument_list|(
name|SM_VA_ARG
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SM_VA_END
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
name|j
operator|=
literal|0
expr_stmt|;
comment|/* index in dst */
comment|/* loop through all source strings */
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
name|str
operator|=
name|SM_VA_ARG
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
comment|/* copy string; i: index in str; j: index in dst */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|j
operator|<
name|len
operator|&&
operator|(
name|dst
index|[
name|j
index|]
operator|=
name|str
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
continue|continue;
comment|/* str: end reached? */
if|if
condition|(
name|str
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* no: terminate dst; there is space since j< len */
name|dst
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
name|j
operator|+=
name|strlen
argument_list|(
name|str
operator|+
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
name|j
operator|+=
name|strlen
argument_list|(
name|SM_VA_ARG
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SM_VA_END
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|j
return|;
block|}
block|}
name|SM_VA_END
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|dst
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate dst; there is space since j< len */
return|return
name|j
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* **  SM_STRLAPP -- append string if it fits into buffer. ** **	If size> 0, copy up to size-1 characters from the nul terminated **	string src to dst, nul terminating the result.  If size == 0, **	the dst buffer is not modified. ** **	This routine is useful for appending strings in a loop, e.g, instead of **	s = buf; **	for (ptr, ptr != NULL, ptr = next->ptr) **	{ **		(void) sm_strlcpy(s, ptr->string, sizeof buf - (s - buf)); **		s += strlen(s); **	} **	replace the loop body with: **		if (!sm_strlapp(*s, ptr->string, sizeof buf - (s - buf))) **			break; **	it's faster... ** **	XXX interface isn't completely clear (yet), hence this code is **	not available. ** ** **	Parameters: **		dst -- (pointer to) destination buffer **		src -- source string **		size -- size of destination buffer ** **	Returns: **		true if strlen(src)< size ** **	Side Effects: **		modifies dst if append succeeds (enough space). */
end_comment

begin_comment
unit|bool sm_strlapp(dst, src, size) 	register char **dst; 	register const char *src; 	ssize_t size; { 	register size_t i;  	if (size--<= 0) 		return false; 	for (i = 0; i< size&& ((*dst)[i] = src[i]) != '\0'; i++) 		continue; 	(*dst)[i] = '\0'; 	if (src[i] == '\0') 	{ 		*dst += i; 		return true; 	}
comment|/* undo */
end_comment

begin_endif
unit|(*dst)[0] = '\0'; 	return false; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

end_unit

