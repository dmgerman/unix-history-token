begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2001 Proofpoint, Inc. and its suppliers.  *      All rights reserved.  * Copyright (c) 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Chris Torek.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  */
end_comment

begin_include
include|#
directive|include
file|<sm/gen.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: makebuf.c,v 1.27 2013/11/22 20:51:43 ca Exp $"
argument_list|)
end_macro

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sm/io.h>
end_include

begin_include
include|#
directive|include
file|<sm/heap.h>
end_include

begin_include
include|#
directive|include
file|<sm/conf.h>
end_include

begin_include
include|#
directive|include
file|"local.h"
end_include

begin_comment
comment|/* **  SM_MAKEBUF -- make a buffer for the file ** **	Parameters: **		fp -- the file to be buffered ** **	Returns: **		nothing ** **	Allocate a file buffer, or switch to unbuffered I/O. **	By default tty devices default to line buffered. */
end_comment

begin_function
name|void
name|sm_makebuf
parameter_list|(
name|fp
parameter_list|)
specifier|register
name|SM_FILE_T
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|void
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|flags
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|couldbetty
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
name|SMNBF
condition|)
block|{
name|fp
operator|->
name|f_bf
operator|.
name|smb_base
operator|=
name|fp
operator|->
name|f_p
operator|=
name|fp
operator|->
name|f_nbuf
expr_stmt|;
name|fp
operator|->
name|f_bf
operator|.
name|smb_size
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|flags
operator|=
name|sm_whatbuf
argument_list|(
name|fp
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|couldbetty
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|sm_malloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fp
operator|->
name|f_flags
operator||=
name|SMNBF
expr_stmt|;
name|fp
operator|->
name|f_bf
operator|.
name|smb_base
operator|=
name|fp
operator|->
name|f_p
operator|=
name|fp
operator|->
name|f_nbuf
expr_stmt|;
name|fp
operator|->
name|f_bf
operator|.
name|smb_size
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|Sm_IO_DidInit
condition|)
name|sm_init
argument_list|()
expr_stmt|;
name|flags
operator||=
name|SMMBF
expr_stmt|;
name|fp
operator|->
name|f_bf
operator|.
name|smb_base
operator|=
name|fp
operator|->
name|f_p
operator|=
name|p
expr_stmt|;
name|fp
operator|->
name|f_bf
operator|.
name|smb_size
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|couldbetty
operator|&&
name|isatty
argument_list|(
name|fp
operator|->
name|f_file
argument_list|)
condition|)
name|flags
operator||=
name|SMLBF
expr_stmt|;
name|fp
operator|->
name|f_flags
operator||=
name|flags
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  SM_WHATBUF -- determine proper buffer for a file (internal) ** **  Plus it fills in 'bufsize' for recommended buffer size and **  fills in flag to indicate if 'fp' could be a tty (nothing **  to do with "betty" :-) ). ** **	Parameters: **		fp -- file pointer to be buffered **		bufsize -- new buffer size (a return) **		couldbetty -- could be a tty (returns) ** **	Returns: **		Success: **		on error: **			SMNPT -- not seek opimized **			SMOPT -- seek opimized */
end_comment

begin_function
name|int
name|sm_whatbuf
parameter_list|(
name|fp
parameter_list|,
name|bufsize
parameter_list|,
name|couldbetty
parameter_list|)
specifier|register
name|SM_FILE_T
modifier|*
name|fp
decl_stmt|;
name|size_t
modifier|*
name|bufsize
decl_stmt|;
name|int
modifier|*
name|couldbetty
decl_stmt|;
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_file
operator|<
literal|0
operator|||
name|fstat
argument_list|(
name|fp
operator|->
name|f_file
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|couldbetty
operator|=
literal|0
expr_stmt|;
operator|*
name|bufsize
operator|=
name|SM_IO_BUFSIZ
expr_stmt|;
return|return
name|SMNPT
return|;
block|}
comment|/* could be a tty iff it is a character device */
operator|*
name|couldbetty
operator|=
name|S_ISCHR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|.
name|st_blksize
operator|==
literal|0
condition|)
block|{
operator|*
name|bufsize
operator|=
name|SM_IO_BUFSIZ
expr_stmt|;
return|return
name|SMNPT
return|;
block|}
if|#
directive|if
name|SM_IO_MAX_BUF_FILE
operator|>
literal|0
if|if
condition|(
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
operator|&&
name|st
operator|.
name|st_blksize
operator|>
name|SM_IO_MAX_BUF_FILE
condition|)
name|st
operator|.
name|st_blksize
operator|=
name|SM_IO_MAX_BUF_FILE
expr_stmt|;
endif|#
directive|endif
comment|/* SM_IO_MAX_BUF_FILE> 0 */
if|#
directive|if
name|SM_IO_MAX_BUF
operator|>
literal|0
operator|||
name|SM_IO_MIN_BUF
operator|>
literal|0
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|#
directive|if
name|SM_IO_MAX_BUF
operator|>
literal|0
if|if
condition|(
name|st
operator|.
name|st_blksize
operator|>
name|SM_IO_MAX_BUF
condition|)
name|st
operator|.
name|st_blksize
operator|=
name|SM_IO_MAX_BUF
expr_stmt|;
if|#
directive|if
name|SM_IO_MIN_BUF
operator|>
literal|0
elseif|else
endif|#
directive|endif
comment|/* SM_IO_MIN_BUF> 0 */
endif|#
directive|endif
comment|/* SM_IO_MAX_BUF> 0 */
if|#
directive|if
name|SM_IO_MIN_BUF
operator|>
literal|0
if|if
condition|(
name|st
operator|.
name|st_blksize
operator|<
name|SM_IO_MIN_BUF
condition|)
name|st
operator|.
name|st_blksize
operator|=
name|SM_IO_MIN_BUF
expr_stmt|;
endif|#
directive|endif
comment|/* SM_IO_MIN_BUF> 0 */
block|}
endif|#
directive|endif
comment|/* SM_IO_MAX_BUF> 0 || SM_IO_MIN_BUF> 0 */
comment|/* 	**  Optimise fseek() only if it is a regular file.  (The test for 	**  sm_std_seek is mainly paranoia.)  It is safe to set _blksize 	**  unconditionally; it will only be used if SMOPT is also set. 	*/
if|if
condition|(
operator|(
name|fp
operator|->
name|f_flags
operator|&
name|SMSTR
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|bufsize
operator|=
name|st
operator|.
name|st_blksize
expr_stmt|;
name|fp
operator|->
name|f_blksize
operator|=
name|st
operator|.
name|st_blksize
expr_stmt|;
block|}
else|else
operator|*
name|bufsize
operator|=
name|SM_IO_BUFSIZ
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
operator|&&
name|fp
operator|->
name|f_seek
operator|==
name|sm_stdseek
condition|)
return|return
name|SMOPT
return|;
else|else
return|return
name|SMNPT
return|;
block|}
end_function

end_unit

