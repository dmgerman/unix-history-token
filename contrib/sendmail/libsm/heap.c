begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2001, 2004 Sendmail, Inc. and its suppliers.  *	All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  */
end_comment

begin_include
include|#
directive|include
file|<sm/gen.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: heap.c,v 1.51 2004/08/03 20:32:00 ca Exp $"
argument_list|)
end_macro

begin_comment
comment|/* **  debugging memory allocation package **  See heap.html for documentation. */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sm/assert.h>
end_include

begin_include
include|#
directive|include
file|<sm/debug.h>
end_include

begin_include
include|#
directive|include
file|<sm/exc.h>
end_include

begin_include
include|#
directive|include
file|<sm/heap.h>
end_include

begin_include
include|#
directive|include
file|<sm/io.h>
end_include

begin_include
include|#
directive|include
file|<sm/signal.h>
end_include

begin_include
include|#
directive|include
file|<sm/xtrap.h>
end_include

begin_comment
comment|/* undef all macro versions of the "functions" so they can be specified here */
end_comment

begin_undef
undef|#
directive|undef
name|sm_malloc
end_undef

begin_undef
undef|#
directive|undef
name|sm_malloc_x
end_undef

begin_undef
undef|#
directive|undef
name|sm_malloc_tagged
end_undef

begin_undef
undef|#
directive|undef
name|sm_malloc_tagged_x
end_undef

begin_undef
undef|#
directive|undef
name|sm_free
end_undef

begin_undef
undef|#
directive|undef
name|sm_free_tagged
end_undef

begin_undef
undef|#
directive|undef
name|sm_realloc
end_undef

begin_if
if|#
directive|if
name|SM_HEAP_CHECK
end_if

begin_undef
undef|#
directive|undef
name|sm_heap_register
end_undef

begin_undef
undef|#
directive|undef
name|sm_heap_checkptr
end_undef

begin_undef
undef|#
directive|undef
name|sm_heap_report
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SM_HEAP_CHECK */
end_comment

begin_if
if|#
directive|if
name|SM_HEAP_CHECK
end_if

begin_decl_stmt
name|SM_DEBUG_T
name|SmHeapCheck
init|=
name|SM_DEBUG_INITIALIZER
argument_list|(
literal|"sm_check_heap"
argument_list|,
literal|"@(#)$Debug: sm_check_heap - check sm_malloc, sm_realloc, sm_free calls $"
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HEAP_CHECK
value|sm_debug_active(&SmHeapCheck, 1)
end_define

begin_decl_stmt
specifier|static
name|int
name|ptrhash
name|__P
argument_list|(
operator|(
name|void
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SM_HEAP_CHECK */
end_comment

begin_decl_stmt
specifier|const
name|SM_EXC_TYPE_T
name|SmHeapOutOfMemoryType
init|=
block|{
name|SmExcTypeMagic
block|,
literal|"F:sm.heap"
block|,
literal|""
block|,
name|sm_etype_printf
block|,
literal|"out of memory"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SM_EXC_T
name|SmHeapOutOfMemory
init|=
name|SM_EXC_INITIALIZER
argument_list|(
operator|&
name|SmHeapOutOfMemoryType
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  The behaviour of malloc with size==0 is platform dependent (it **  says so in the C standard): it can return NULL or non-NULL.  We **  don't want sm_malloc_x(0) to raise an exception on some platforms **  but not others, so this case requires special handling.  We've got **  two choices: "size = 1" or "return NULL". We use the former in the **  following. **	If we had something like autoconf we could figure out the **	behaviour of the platform and either use this hack or just **	use size. */
end_comment

begin_define
define|#
directive|define
name|MALLOC_SIZE
parameter_list|(
name|size
parameter_list|)
value|((size) == 0 ? 1 : (size))
end_define

begin_comment
comment|/* **  SM_MALLOC_X -- wrapper around malloc(), raises an exception on error. ** **	Parameters: **		size -- size of requested memory. ** **	Returns: **		Pointer to memory region. ** **	Note: **		sm_malloc_x only gets called from source files in which heap **		debugging is disabled at compile time.  Otherwise, a call to **		sm_malloc_x is macro expanded to a call to sm_malloc_tagged_x. ** **	Exceptions: **		F:sm_heap -- out of memory */
end_comment

begin_function
name|void
modifier|*
name|sm_malloc_x
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|ENTER_CRITICAL
argument_list|()
expr_stmt|;
name|ptr
operator|=
name|malloc
argument_list|(
name|MALLOC_SIZE
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|LEAVE_CRITICAL
argument_list|()
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
name|sm_exc_raise_x
argument_list|(
operator|&
name|SmHeapOutOfMemory
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|SM_HEAP_CHECK
end_if

begin_comment
comment|/* **  SM_MALLOC -- wrapper around malloc() ** **	Parameters: **		size -- size of requested memory. ** **	Returns: **		Pointer to memory region. */
end_comment

begin_function
name|void
modifier|*
name|sm_malloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|ENTER_CRITICAL
argument_list|()
expr_stmt|;
name|ptr
operator|=
name|malloc
argument_list|(
name|MALLOC_SIZE
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|LEAVE_CRITICAL
argument_list|()
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* **  SM_REALLOC -- wrapper for realloc() ** **	Parameters: **		ptr -- pointer to old memory area. **		size -- size of requested memory. ** **	Returns: **		Pointer to new memory area, NULL on failure. */
end_comment

begin_function
name|void
modifier|*
name|sm_realloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|void
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|void
modifier|*
name|newptr
decl_stmt|;
name|ENTER_CRITICAL
argument_list|()
expr_stmt|;
name|newptr
operator|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|MALLOC_SIZE
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|LEAVE_CRITICAL
argument_list|()
expr_stmt|;
return|return
name|newptr
return|;
block|}
end_function

begin_comment
comment|/* **  SM_REALLOC_X -- wrapper for realloc() ** **	Parameters: **		ptr -- pointer to old memory area. **		size -- size of requested memory. ** **	Returns: **		Pointer to new memory area. ** **	Exceptions: **		F:sm_heap -- out of memory */
end_comment

begin_function
name|void
modifier|*
name|sm_realloc_x
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|void
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|void
modifier|*
name|newptr
decl_stmt|;
name|ENTER_CRITICAL
argument_list|()
expr_stmt|;
name|newptr
operator|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|MALLOC_SIZE
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|LEAVE_CRITICAL
argument_list|()
expr_stmt|;
if|if
condition|(
name|newptr
operator|==
name|NULL
condition|)
name|sm_exc_raise_x
argument_list|(
operator|&
name|SmHeapOutOfMemory
argument_list|)
expr_stmt|;
return|return
name|newptr
return|;
block|}
end_function

begin_comment
comment|/* **  SM_FREE -- wrapper around free() ** **	Parameters: **		ptr -- pointer to memory region. ** **	Returns: **		none. */
end_comment

begin_function
name|void
name|sm_free
parameter_list|(
name|ptr
parameter_list|)
name|void
modifier|*
name|ptr
decl_stmt|;
block|{
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return;
name|ENTER_CRITICAL
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|LEAVE_CRITICAL
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !SM_HEAP_CHECK */
end_comment

begin_comment
comment|/* **  Each allocated block is assigned a "group number". **  By default, all blocks are assigned to group #1. **  By convention, group #0 is for memory that is never freed. **  You can use group numbers any way you want, in order to help make **  sense of sm_heap_report output. */
end_comment

begin_decl_stmt
name|int
name|SmHeapGroup
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|SmHeapMaxGroup
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  Total number of bytes allocated. **  This is only maintained if the sm_check_heap debug category is active. */
end_comment

begin_decl_stmt
name|size_t
name|SmHeapTotal
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  High water mark: the most that SmHeapTotal has ever been. */
end_comment

begin_decl_stmt
name|size_t
name|SmHeapMaxTotal
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  Maximum number of bytes that may be allocated at any one time. **  0 means no limit. **  This is only honoured if sm_check_heap is active. */
end_comment

begin_decl_stmt
name|SM_DEBUG_T
name|SmHeapLimit
init|=
name|SM_DEBUG_INITIALIZER
argument_list|(
literal|"sm_heap_limit"
argument_list|,
literal|"@(#)$Debug: sm_heap_limit - max # of bytes permitted in heap $"
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  This is the data structure that keeps track of all currently **  allocated blocks of memory known to the heap package. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|sm_heap_item
name|SM_HEAP_ITEM_T
typedef|;
end_typedef

begin_struct
struct|struct
name|sm_heap_item
block|{
name|void
modifier|*
name|hi_ptr
decl_stmt|;
name|size_t
name|hi_size
decl_stmt|;
name|char
modifier|*
name|hi_tag
decl_stmt|;
name|int
name|hi_num
decl_stmt|;
name|int
name|hi_group
decl_stmt|;
name|SM_HEAP_ITEM_T
modifier|*
name|hi_next
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SM_HEAP_TABLE_SIZE
value|256
end_define

begin_decl_stmt
specifier|static
name|SM_HEAP_ITEM_T
modifier|*
name|SmHeapTable
index|[
name|SM_HEAP_TABLE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  This is a randomly generated table **  which contains exactly one occurrence **  of each of the numbers between 0 and 255. **  It is used by ptrhash. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|hashtab
index|[
name|SM_HEAP_TABLE_SIZE
index|]
init|=
block|{
literal|161
block|,
literal|71
block|,
literal|77
block|,
literal|187
block|,
literal|15
block|,
literal|229
block|,
literal|9
block|,
literal|176
block|,
literal|221
block|,
literal|119
block|,
literal|239
block|,
literal|21
block|,
literal|85
block|,
literal|138
block|,
literal|203
block|,
literal|86
block|,
literal|102
block|,
literal|65
block|,
literal|80
block|,
literal|199
block|,
literal|235
block|,
literal|32
block|,
literal|140
block|,
literal|96
block|,
literal|224
block|,
literal|78
block|,
literal|126
block|,
literal|127
block|,
literal|144
block|,
literal|0
block|,
literal|11
block|,
literal|179
block|,
literal|64
block|,
literal|30
block|,
literal|120
block|,
literal|23
block|,
literal|225
block|,
literal|226
block|,
literal|33
block|,
literal|50
block|,
literal|205
block|,
literal|167
block|,
literal|130
block|,
literal|240
block|,
literal|174
block|,
literal|99
block|,
literal|206
block|,
literal|73
block|,
literal|231
block|,
literal|210
block|,
literal|189
block|,
literal|162
block|,
literal|48
block|,
literal|93
block|,
literal|246
block|,
literal|54
block|,
literal|213
block|,
literal|141
block|,
literal|135
block|,
literal|39
block|,
literal|41
block|,
literal|192
block|,
literal|236
block|,
literal|193
block|,
literal|157
block|,
literal|88
block|,
literal|95
block|,
literal|104
block|,
literal|188
block|,
literal|63
block|,
literal|133
block|,
literal|177
block|,
literal|234
block|,
literal|110
block|,
literal|158
block|,
literal|214
block|,
literal|238
block|,
literal|131
block|,
literal|233
block|,
literal|91
block|,
literal|125
block|,
literal|82
block|,
literal|94
block|,
literal|79
block|,
literal|66
block|,
literal|92
block|,
literal|151
block|,
literal|45
block|,
literal|252
block|,
literal|98
block|,
literal|26
block|,
literal|183
block|,
literal|7
block|,
literal|191
block|,
literal|171
block|,
literal|106
block|,
literal|145
block|,
literal|154
block|,
literal|251
block|,
literal|100
block|,
literal|113
block|,
literal|5
block|,
literal|74
block|,
literal|62
block|,
literal|76
block|,
literal|124
block|,
literal|14
block|,
literal|217
block|,
literal|200
block|,
literal|75
block|,
literal|115
block|,
literal|190
block|,
literal|103
block|,
literal|28
block|,
literal|198
block|,
literal|196
block|,
literal|169
block|,
literal|219
block|,
literal|37
block|,
literal|118
block|,
literal|150
block|,
literal|18
block|,
literal|152
block|,
literal|175
block|,
literal|49
block|,
literal|136
block|,
literal|6
block|,
literal|142
block|,
literal|89
block|,
literal|19
block|,
literal|243
block|,
literal|254
block|,
literal|47
block|,
literal|137
block|,
literal|24
block|,
literal|166
block|,
literal|180
block|,
literal|10
block|,
literal|40
block|,
literal|186
block|,
literal|202
block|,
literal|46
block|,
literal|184
block|,
literal|67
block|,
literal|148
block|,
literal|108
block|,
literal|181
block|,
literal|81
block|,
literal|25
block|,
literal|241
block|,
literal|13
block|,
literal|139
block|,
literal|58
block|,
literal|38
block|,
literal|84
block|,
literal|253
block|,
literal|201
block|,
literal|12
block|,
literal|116
block|,
literal|17
block|,
literal|195
block|,
literal|22
block|,
literal|112
block|,
literal|69
block|,
literal|255
block|,
literal|43
block|,
literal|147
block|,
literal|222
block|,
literal|111
block|,
literal|56
block|,
literal|194
block|,
literal|216
block|,
literal|149
block|,
literal|244
block|,
literal|42
block|,
literal|173
block|,
literal|232
block|,
literal|220
block|,
literal|249
block|,
literal|105
block|,
literal|207
block|,
literal|51
block|,
literal|197
block|,
literal|242
block|,
literal|72
block|,
literal|211
block|,
literal|208
block|,
literal|59
block|,
literal|122
block|,
literal|230
block|,
literal|237
block|,
literal|170
block|,
literal|165
block|,
literal|44
block|,
literal|68
block|,
literal|123
block|,
literal|129
block|,
literal|245
block|,
literal|143
block|,
literal|101
block|,
literal|8
block|,
literal|209
block|,
literal|215
block|,
literal|247
block|,
literal|185
block|,
literal|57
block|,
literal|218
block|,
literal|53
block|,
literal|114
block|,
literal|121
block|,
literal|3
block|,
literal|128
block|,
literal|4
block|,
literal|204
block|,
literal|212
block|,
literal|146
block|,
literal|2
block|,
literal|155
block|,
literal|83
block|,
literal|250
block|,
literal|87
block|,
literal|29
block|,
literal|31
block|,
literal|159
block|,
literal|60
block|,
literal|27
block|,
literal|107
block|,
literal|156
block|,
literal|227
block|,
literal|182
block|,
literal|1
block|,
literal|61
block|,
literal|36
block|,
literal|160
block|,
literal|109
block|,
literal|97
block|,
literal|90
block|,
literal|20
block|,
literal|168
block|,
literal|132
block|,
literal|223
block|,
literal|248
block|,
literal|70
block|,
literal|164
block|,
literal|55
block|,
literal|172
block|,
literal|34
block|,
literal|52
block|,
literal|163
block|,
literal|117
block|,
literal|35
block|,
literal|153
block|,
literal|134
block|,
literal|16
block|,
literal|178
block|,
literal|228
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  PTRHASH -- hash a pointer value ** **	Parameters: **		p -- pointer. ** **	Returns: **		hash value. ** **  ptrhash hashes a pointer value to a uniformly distributed random **  number between 0 and 255. ** **  This hash algorithm is based on Peter K. Pearson, **  "Fast Hashing of Variable-Length Text Strings", **  in Communications of the ACM, June 1990, vol 33 no 6. */
end_comment

begin_function
specifier|static
name|int
name|ptrhash
parameter_list|(
name|p
parameter_list|)
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|h
decl_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|==
literal|4
operator|&&
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
operator|==
literal|4
condition|)
block|{
name|unsigned
name|long
name|n
init|=
operator|(
name|unsigned
name|long
operator|)
name|p
decl_stmt|;
name|h
operator|=
name|hashtab
index|[
name|n
operator|&
literal|0xFF
index|]
expr_stmt|;
name|h
operator|=
name|hashtab
index|[
name|h
operator|^
operator|(
operator|(
name|n
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
operator|)
index|]
expr_stmt|;
name|h
operator|=
name|hashtab
index|[
name|h
operator|^
operator|(
operator|(
name|n
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
operator|)
index|]
expr_stmt|;
name|h
operator|=
name|hashtab
index|[
name|h
operator|^
operator|(
operator|(
name|n
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
operator|)
index|]
expr_stmt|;
block|}
if|#
directive|if
literal|0
if|else if (sizeof(void*) == 8&& sizeof(unsigned long) == 8) 	{ 		unsigned long n = (unsigned long)p;  		h = hashtab[n& 0xFF]; 		h = hashtab[h ^ ((n>> 8)& 0xFF)]; 		h = hashtab[h ^ ((n>> 16)& 0xFF)]; 		h = hashtab[h ^ ((n>> 24)& 0xFF)]; 		h = hashtab[h ^ ((n>> 32)& 0xFF)]; 		h = hashtab[h ^ ((n>> 40)& 0xFF)]; 		h = hashtab[h ^ ((n>> 48)& 0xFF)]; 		h = hashtab[h ^ ((n>> 56)& 0xFF)]; 	}
endif|#
directive|endif
comment|/* 0 */
else|else
block|{
name|unsigned
name|char
modifier|*
name|cp
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|h
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
condition|;
operator|++
name|i
control|)
name|h
operator|=
name|hashtab
index|[
name|h
operator|^
name|cp
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
end_function

begin_comment
comment|/* **  SM_MALLOC_TAGGED -- wrapper around malloc(), debugging version. ** **	Parameters: **		size -- size of requested memory. **		tag -- tag for debugging. **		num -- additional value for debugging. **		group -- heap group for debugging. ** **	Returns: **		Pointer to memory region. */
end_comment

begin_function
name|void
modifier|*
name|sm_malloc_tagged
parameter_list|(
name|size
parameter_list|,
name|tag
parameter_list|,
name|num
parameter_list|,
name|group
parameter_list|)
name|size_t
name|size
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|int
name|num
decl_stmt|;
name|int
name|group
decl_stmt|;
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|!
name|HEAP_CHECK
condition|)
block|{
name|ENTER_CRITICAL
argument_list|()
expr_stmt|;
name|ptr
operator|=
name|malloc
argument_list|(
name|MALLOC_SIZE
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|LEAVE_CRITICAL
argument_list|()
expr_stmt|;
return|return
name|ptr
return|;
block|}
if|if
condition|(
name|sm_xtrap_check
argument_list|()
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|sm_debug_active
argument_list|(
operator|&
name|SmHeapLimit
argument_list|,
literal|1
argument_list|)
operator|&&
name|sm_debug_level
argument_list|(
operator|&
name|SmHeapLimit
argument_list|)
operator|<
name|SmHeapTotal
operator|+
name|size
condition|)
return|return
name|NULL
return|;
name|ENTER_CRITICAL
argument_list|()
expr_stmt|;
name|ptr
operator|=
name|malloc
argument_list|(
name|MALLOC_SIZE
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|LEAVE_CRITICAL
argument_list|()
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
operator|&&
operator|!
name|sm_heap_register
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|tag
argument_list|,
name|num
argument_list|,
name|group
argument_list|)
condition|)
block|{
name|ENTER_CRITICAL
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|LEAVE_CRITICAL
argument_list|()
expr_stmt|;
name|ptr
operator|=
name|NULL
expr_stmt|;
block|}
name|SmHeapTotal
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|SmHeapTotal
operator|>
name|SmHeapMaxTotal
condition|)
name|SmHeapMaxTotal
operator|=
name|SmHeapTotal
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* **  SM_MALLOC_TAGGED_X -- wrapper around malloc(), debugging version. ** **	Parameters: **		size -- size of requested memory. **		tag -- tag for debugging. **		num -- additional value for debugging. **		group -- heap group for debugging. ** **	Returns: **		Pointer to memory region. ** **	Exceptions: **		F:sm_heap -- out of memory */
end_comment

begin_function
name|void
modifier|*
name|sm_malloc_tagged_x
parameter_list|(
name|size
parameter_list|,
name|tag
parameter_list|,
name|num
parameter_list|,
name|group
parameter_list|)
name|size_t
name|size
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|int
name|num
decl_stmt|;
name|int
name|group
decl_stmt|;
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|!
name|HEAP_CHECK
condition|)
block|{
name|ENTER_CRITICAL
argument_list|()
expr_stmt|;
name|ptr
operator|=
name|malloc
argument_list|(
name|MALLOC_SIZE
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|LEAVE_CRITICAL
argument_list|()
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
name|sm_exc_raise_x
argument_list|(
operator|&
name|SmHeapOutOfMemory
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
name|sm_xtrap_raise_x
argument_list|(
operator|&
name|SmHeapOutOfMemory
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm_debug_active
argument_list|(
operator|&
name|SmHeapLimit
argument_list|,
literal|1
argument_list|)
operator|&&
name|sm_debug_level
argument_list|(
operator|&
name|SmHeapLimit
argument_list|)
operator|<
name|SmHeapTotal
operator|+
name|size
condition|)
block|{
name|sm_exc_raise_x
argument_list|(
operator|&
name|SmHeapOutOfMemory
argument_list|)
expr_stmt|;
block|}
name|ENTER_CRITICAL
argument_list|()
expr_stmt|;
name|ptr
operator|=
name|malloc
argument_list|(
name|MALLOC_SIZE
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|LEAVE_CRITICAL
argument_list|()
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
operator|&&
operator|!
name|sm_heap_register
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|tag
argument_list|,
name|num
argument_list|,
name|group
argument_list|)
condition|)
block|{
name|ENTER_CRITICAL
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|LEAVE_CRITICAL
argument_list|()
expr_stmt|;
name|ptr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
name|sm_exc_raise_x
argument_list|(
operator|&
name|SmHeapOutOfMemory
argument_list|)
expr_stmt|;
name|SmHeapTotal
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|SmHeapTotal
operator|>
name|SmHeapMaxTotal
condition|)
name|SmHeapMaxTotal
operator|=
name|SmHeapTotal
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* **  SM_HEAP_REGISTER -- register a pointer into the heap for debugging. ** **	Parameters: **		ptr -- pointer to register. **		size -- size of requested memory. **		tag -- tag for debugging. **		num -- additional value for debugging. **		group -- heap group for debugging. ** **	Returns: **		true iff successfully registered (not yet in table). */
end_comment

begin_function
name|bool
name|sm_heap_register
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|,
name|tag
parameter_list|,
name|num
parameter_list|,
name|group
parameter_list|)
name|void
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|int
name|num
decl_stmt|;
name|int
name|group
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|SM_HEAP_ITEM_T
modifier|*
name|hi
decl_stmt|;
if|if
condition|(
operator|!
name|HEAP_CHECK
condition|)
return|return
name|true
return|;
name|SM_REQUIRE
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|i
operator|=
name|ptrhash
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|#
directive|if
name|SM_CHECK_REQUIRE
comment|/* 	** We require that ptr is not already in SmHeapTable. 	*/
for|for
control|(
name|hi
operator|=
name|SmHeapTable
index|[
name|i
index|]
init|;
name|hi
operator|!=
name|NULL
condition|;
name|hi
operator|=
name|hi
operator|->
name|hi_next
control|)
block|{
if|if
condition|(
name|hi
operator|->
name|hi_ptr
operator|==
name|ptr
condition|)
name|sm_abort
argument_list|(
literal|"sm_heap_register: ptr %p is already registered (%s:%d)"
argument_list|,
name|ptr
argument_list|,
name|hi
operator|->
name|hi_tag
argument_list|,
name|hi
operator|->
name|hi_num
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SM_CHECK_REQUIRE */
name|ENTER_CRITICAL
argument_list|()
expr_stmt|;
name|hi
operator|=
operator|(
name|SM_HEAP_ITEM_T
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SM_HEAP_ITEM_T
argument_list|)
argument_list|)
expr_stmt|;
name|LEAVE_CRITICAL
argument_list|()
expr_stmt|;
if|if
condition|(
name|hi
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|hi
operator|->
name|hi_ptr
operator|=
name|ptr
expr_stmt|;
name|hi
operator|->
name|hi_size
operator|=
name|size
expr_stmt|;
name|hi
operator|->
name|hi_tag
operator|=
name|tag
expr_stmt|;
name|hi
operator|->
name|hi_num
operator|=
name|num
expr_stmt|;
name|hi
operator|->
name|hi_group
operator|=
name|group
expr_stmt|;
name|hi
operator|->
name|hi_next
operator|=
name|SmHeapTable
index|[
name|i
index|]
expr_stmt|;
name|SmHeapTable
index|[
name|i
index|]
operator|=
name|hi
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* **  SM_REALLOC -- wrapper for realloc(), debugging version. ** **	Parameters: **		ptr -- pointer to old memory area. **		size -- size of requested memory. ** **	Returns: **		Pointer to new memory area, NULL on failure. */
end_comment

begin_function
name|void
modifier|*
name|sm_realloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|void
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|void
modifier|*
name|newptr
decl_stmt|;
name|SM_HEAP_ITEM_T
modifier|*
name|hi
decl_stmt|,
modifier|*
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
operator|!
name|HEAP_CHECK
condition|)
block|{
name|ENTER_CRITICAL
argument_list|()
expr_stmt|;
name|newptr
operator|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|MALLOC_SIZE
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|LEAVE_CRITICAL
argument_list|()
expr_stmt|;
return|return
name|newptr
return|;
block|}
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return
name|sm_malloc_tagged
argument_list|(
name|size
argument_list|,
literal|"realloc"
argument_list|,
literal|0
argument_list|,
name|SmHeapGroup
argument_list|)
return|;
for|for
control|(
name|hp
operator|=
operator|&
name|SmHeapTable
index|[
name|ptrhash
argument_list|(
name|ptr
argument_list|)
index|]
init|;
operator|*
name|hp
operator|!=
name|NULL
condition|;
name|hp
operator|=
operator|&
operator|(
operator|*
operator|*
name|hp
operator|)
operator|.
name|hi_next
control|)
block|{
if|if
condition|(
operator|(
operator|*
operator|*
name|hp
operator|)
operator|.
name|hi_ptr
operator|==
name|ptr
condition|)
block|{
if|if
condition|(
name|sm_xtrap_check
argument_list|()
condition|)
return|return
name|NULL
return|;
name|hi
operator|=
operator|*
name|hp
expr_stmt|;
if|if
condition|(
name|sm_debug_active
argument_list|(
operator|&
name|SmHeapLimit
argument_list|,
literal|1
argument_list|)
operator|&&
name|sm_debug_level
argument_list|(
operator|&
name|SmHeapLimit
argument_list|)
operator|<
name|SmHeapTotal
operator|-
name|hi
operator|->
name|hi_size
operator|+
name|size
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|ENTER_CRITICAL
argument_list|()
expr_stmt|;
name|newptr
operator|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|MALLOC_SIZE
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|LEAVE_CRITICAL
argument_list|()
expr_stmt|;
if|if
condition|(
name|newptr
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|SmHeapTotal
operator|=
name|SmHeapTotal
operator|-
name|hi
operator|->
name|hi_size
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|SmHeapTotal
operator|>
name|SmHeapMaxTotal
condition|)
name|SmHeapMaxTotal
operator|=
name|SmHeapTotal
expr_stmt|;
operator|*
name|hp
operator|=
name|hi
operator|->
name|hi_next
expr_stmt|;
name|hi
operator|->
name|hi_ptr
operator|=
name|newptr
expr_stmt|;
name|hi
operator|->
name|hi_size
operator|=
name|size
expr_stmt|;
name|hp
operator|=
operator|&
name|SmHeapTable
index|[
name|ptrhash
argument_list|(
name|newptr
argument_list|)
index|]
expr_stmt|;
name|hi
operator|->
name|hi_next
operator|=
operator|*
name|hp
expr_stmt|;
operator|*
name|hp
operator|=
name|hi
expr_stmt|;
return|return
name|newptr
return|;
block|}
block|}
name|sm_abort
argument_list|(
literal|"sm_realloc: bad argument (%p)"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|NULL
return|;
comment|/* keep Irix compiler happy */
block|}
end_function

begin_comment
comment|/* **  SM_REALLOC_X -- wrapper for realloc(), debugging version. ** **	Parameters: **		ptr -- pointer to old memory area. **		size -- size of requested memory. ** **	Returns: **		Pointer to new memory area. ** **	Exceptions: **		F:sm_heap -- out of memory */
end_comment

begin_function
name|void
modifier|*
name|sm_realloc_x
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|void
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|void
modifier|*
name|newptr
decl_stmt|;
name|SM_HEAP_ITEM_T
modifier|*
name|hi
decl_stmt|,
modifier|*
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
operator|!
name|HEAP_CHECK
condition|)
block|{
name|ENTER_CRITICAL
argument_list|()
expr_stmt|;
name|newptr
operator|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|MALLOC_SIZE
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|LEAVE_CRITICAL
argument_list|()
expr_stmt|;
if|if
condition|(
name|newptr
operator|==
name|NULL
condition|)
name|sm_exc_raise_x
argument_list|(
operator|&
name|SmHeapOutOfMemory
argument_list|)
expr_stmt|;
return|return
name|newptr
return|;
block|}
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return
name|sm_malloc_tagged_x
argument_list|(
name|size
argument_list|,
literal|"realloc"
argument_list|,
literal|0
argument_list|,
name|SmHeapGroup
argument_list|)
return|;
for|for
control|(
name|hp
operator|=
operator|&
name|SmHeapTable
index|[
name|ptrhash
argument_list|(
name|ptr
argument_list|)
index|]
init|;
operator|*
name|hp
operator|!=
name|NULL
condition|;
name|hp
operator|=
operator|&
operator|(
operator|*
operator|*
name|hp
operator|)
operator|.
name|hi_next
control|)
block|{
if|if
condition|(
operator|(
operator|*
operator|*
name|hp
operator|)
operator|.
name|hi_ptr
operator|==
name|ptr
condition|)
block|{
name|sm_xtrap_raise_x
argument_list|(
operator|&
name|SmHeapOutOfMemory
argument_list|)
expr_stmt|;
name|hi
operator|=
operator|*
name|hp
expr_stmt|;
if|if
condition|(
name|sm_debug_active
argument_list|(
operator|&
name|SmHeapLimit
argument_list|,
literal|1
argument_list|)
operator|&&
name|sm_debug_level
argument_list|(
operator|&
name|SmHeapLimit
argument_list|)
operator|<
name|SmHeapTotal
operator|-
name|hi
operator|->
name|hi_size
operator|+
name|size
condition|)
block|{
name|sm_exc_raise_x
argument_list|(
operator|&
name|SmHeapOutOfMemory
argument_list|)
expr_stmt|;
block|}
name|ENTER_CRITICAL
argument_list|()
expr_stmt|;
name|newptr
operator|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|MALLOC_SIZE
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|LEAVE_CRITICAL
argument_list|()
expr_stmt|;
if|if
condition|(
name|newptr
operator|==
name|NULL
condition|)
name|sm_exc_raise_x
argument_list|(
operator|&
name|SmHeapOutOfMemory
argument_list|)
expr_stmt|;
name|SmHeapTotal
operator|=
name|SmHeapTotal
operator|-
name|hi
operator|->
name|hi_size
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|SmHeapTotal
operator|>
name|SmHeapMaxTotal
condition|)
name|SmHeapMaxTotal
operator|=
name|SmHeapTotal
expr_stmt|;
operator|*
name|hp
operator|=
name|hi
operator|->
name|hi_next
expr_stmt|;
name|hi
operator|->
name|hi_ptr
operator|=
name|newptr
expr_stmt|;
name|hi
operator|->
name|hi_size
operator|=
name|size
expr_stmt|;
name|hp
operator|=
operator|&
name|SmHeapTable
index|[
name|ptrhash
argument_list|(
name|newptr
argument_list|)
index|]
expr_stmt|;
name|hi
operator|->
name|hi_next
operator|=
operator|*
name|hp
expr_stmt|;
operator|*
name|hp
operator|=
name|hi
expr_stmt|;
return|return
name|newptr
return|;
block|}
block|}
name|sm_abort
argument_list|(
literal|"sm_realloc_x: bad argument (%p)"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|NULL
return|;
comment|/* keep Irix compiler happy */
block|}
end_function

begin_comment
comment|/* **  SM_FREE_TAGGED -- wrapper around free(), debugging version. ** **	Parameters: **		ptr -- pointer to memory region. **		tag -- tag for debugging. **		num -- additional value for debugging. ** **	Returns: **		none. */
end_comment

begin_function
name|void
name|sm_free_tagged
parameter_list|(
name|ptr
parameter_list|,
name|tag
parameter_list|,
name|num
parameter_list|)
name|void
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|int
name|num
decl_stmt|;
block|{
name|SM_HEAP_ITEM_T
modifier|*
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
name|HEAP_CHECK
condition|)
block|{
name|ENTER_CRITICAL
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|LEAVE_CRITICAL
argument_list|()
expr_stmt|;
return|return;
block|}
for|for
control|(
name|hp
operator|=
operator|&
name|SmHeapTable
index|[
name|ptrhash
argument_list|(
name|ptr
argument_list|)
index|]
init|;
operator|*
name|hp
operator|!=
name|NULL
condition|;
name|hp
operator|=
operator|&
operator|(
operator|*
operator|*
name|hp
operator|)
operator|.
name|hi_next
control|)
block|{
if|if
condition|(
operator|(
operator|*
operator|*
name|hp
operator|)
operator|.
name|hi_ptr
operator|==
name|ptr
condition|)
block|{
name|SM_HEAP_ITEM_T
modifier|*
name|hi
init|=
operator|*
name|hp
decl_stmt|;
operator|*
name|hp
operator|=
name|hi
operator|->
name|hi_next
expr_stmt|;
comment|/* 			**  Fill the block with zeros before freeing. 			**  This is intended to catch problems with 			**  dangling pointers.  The block is filled with 			**  zeros, not with some non-zero value, because 			**  it is common practice in some C code to store 			**  a zero in a structure member before freeing the 			**  structure, as a defense against dangling pointers. 			*/
operator|(
name|void
operator|)
name|memset
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
name|hi
operator|->
name|hi_size
argument_list|)
expr_stmt|;
name|SmHeapTotal
operator|-=
name|hi
operator|->
name|hi_size
expr_stmt|;
name|ENTER_CRITICAL
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|LEAVE_CRITICAL
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|sm_abort
argument_list|(
literal|"sm_free: bad argument (%p) (%s:%d)"
argument_list|,
name|ptr
argument_list|,
name|tag
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  SM_HEAP_CHECKPTR_TAGGED -- check whether ptr is a valid argument to sm_free ** **	Parameters: **		ptr -- pointer to memory region. **		tag -- tag for debugging. **		num -- additional value for debugging. ** **	Returns: **		none. ** **	Side Effects: **		aborts if check fails. */
end_comment

begin_function
name|void
name|sm_heap_checkptr_tagged
parameter_list|(
name|ptr
parameter_list|,
name|tag
parameter_list|,
name|num
parameter_list|)
name|void
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|int
name|num
decl_stmt|;
block|{
name|SM_HEAP_ITEM_T
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
operator|!
name|HEAP_CHECK
condition|)
return|return;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|hp
operator|=
name|SmHeapTable
index|[
name|ptrhash
argument_list|(
name|ptr
argument_list|)
index|]
init|;
name|hp
operator|!=
name|NULL
condition|;
name|hp
operator|=
name|hp
operator|->
name|hi_next
control|)
block|{
if|if
condition|(
name|hp
operator|->
name|hi_ptr
operator|==
name|ptr
condition|)
return|return;
block|}
name|sm_abort
argument_list|(
literal|"sm_heap_checkptr(%p): bad ptr (%s:%d)"
argument_list|,
name|ptr
argument_list|,
name|tag
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  SM_HEAP_REPORT -- output "map" of used heap. ** **	Parameters: **		stream -- the file pointer to write to. **		verbosity -- how much info? ** **	Returns: **		none. */
end_comment

begin_function
name|void
name|sm_heap_report
parameter_list|(
name|stream
parameter_list|,
name|verbosity
parameter_list|)
name|SM_FILE_T
modifier|*
name|stream
decl_stmt|;
name|int
name|verbosity
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|group0total
decl_stmt|,
name|group1total
decl_stmt|,
name|otherstotal
decl_stmt|,
name|grandtotal
decl_stmt|;
if|if
condition|(
operator|!
name|HEAP_CHECK
operator|||
name|verbosity
operator|<=
literal|0
condition|)
return|return;
name|group0total
operator|=
name|group1total
operator|=
name|otherstotal
operator|=
name|grandtotal
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|SmHeapTable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|SmHeapTable
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|SM_HEAP_ITEM_T
modifier|*
name|hi
init|=
name|SmHeapTable
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|hi
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|verbosity
operator|>
literal|2
operator|||
operator|(
name|verbosity
operator|>
literal|1
operator|&&
name|hi
operator|->
name|hi_group
operator|!=
literal|0
operator|)
condition|)
block|{
name|sm_io_fprintf
argument_list|(
name|stream
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%4d %*lx %7lu bytes"
argument_list|,
name|hi
operator|->
name|hi_group
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
literal|2
argument_list|,
operator|(
name|long
operator|)
name|hi
operator|->
name|hi_ptr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|hi
operator|->
name|hi_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi
operator|->
name|hi_tag
operator|!=
name|NULL
condition|)
block|{
name|sm_io_fprintf
argument_list|(
name|stream
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"  %s"
argument_list|,
name|hi
operator|->
name|hi_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi
operator|->
name|hi_num
condition|)
block|{
name|sm_io_fprintf
argument_list|(
name|stream
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|":%d"
argument_list|,
name|hi
operator|->
name|hi_num
argument_list|)
expr_stmt|;
block|}
block|}
name|sm_io_fprintf
argument_list|(
name|stream
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|hi
operator|->
name|hi_group
condition|)
block|{
case|case
literal|0
case|:
name|group0total
operator|+=
name|hi
operator|->
name|hi_size
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|group1total
operator|+=
name|hi
operator|->
name|hi_size
expr_stmt|;
break|break;
default|default:
name|otherstotal
operator|+=
name|hi
operator|->
name|hi_size
expr_stmt|;
break|break;
block|}
name|grandtotal
operator|+=
name|hi
operator|->
name|hi_size
expr_stmt|;
name|hi
operator|=
name|hi
operator|->
name|hi_next
expr_stmt|;
block|}
block|}
name|sm_io_fprintf
argument_list|(
name|stream
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"heap max=%lu, total=%lu, "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|SmHeapMaxTotal
argument_list|,
name|grandtotal
argument_list|)
expr_stmt|;
name|sm_io_fprintf
argument_list|(
name|stream
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"group 0=%lu, group 1=%lu, others=%lu\n"
argument_list|,
name|group0total
argument_list|,
name|group1total
argument_list|,
name|otherstotal
argument_list|)
expr_stmt|;
if|if
condition|(
name|grandtotal
operator|!=
name|SmHeapTotal
condition|)
block|{
name|sm_io_fprintf
argument_list|(
name|stream
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"BUG => SmHeapTotal: got %lu, expected %lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|SmHeapTotal
argument_list|,
name|grandtotal
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SM_HEAP_CHECK */
end_comment

end_unit

