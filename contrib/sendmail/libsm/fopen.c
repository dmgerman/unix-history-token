begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2002 Sendmail, Inc. and its suppliers.  *      All rights reserved.  * Copyright (c) 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Chris Torek.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  */
end_comment

begin_include
include|#
directive|include
file|<sm/gen.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: fopen.c,v 1.60 2002/01/07 21:41:35 ca Exp $"
argument_list|)
end_macro

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sm/heap.h>
end_include

begin_include
include|#
directive|include
file|<sm/signal.h>
end_include

begin_include
include|#
directive|include
file|<sm/assert.h>
end_include

begin_include
include|#
directive|include
file|<sm/io.h>
end_include

begin_include
include|#
directive|include
file|<sm/clock.h>
end_include

begin_include
include|#
directive|include
file|"local.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|sm_io_fclose
name|__P
argument_list|(
operator|(
name|SM_FILE_T
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|jmp_buf
name|OpenTimeOut
decl_stmt|,
name|ReopenTimeOut
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  OPENALRM -- handler when timeout activated for sm_io_open() ** **  Returns flow of control to where setjmp(OpenTimeOut) was set. ** **	Parameters: **		sig -- unused ** **	Returns: **		does not return ** **	Side Effects: **		returns flow of control to setjmp(OpenTimeOut). ** **	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD **		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE **		DOING. */
end_comment

begin_comment
comment|/* ARGSUSED0 */
end_comment

begin_function
specifier|static
name|void
name|openalrm
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|longjmp
argument_list|(
name|OpenTimeOut
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  REOPENALRM -- handler when timeout activated for sm_io_reopen() ** **  Returns flow of control to where setjmp(ReopenTimeOut) was set. ** **	Parameters: **		sig -- unused ** **	Returns: **		does not return ** **	Side Effects: **		returns flow of control to setjmp(ReopenTimeOut). ** **	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD **		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE **		DOING. */
end_comment

begin_comment
comment|/* ARGSUSED0 */
end_comment

begin_function
specifier|static
name|void
name|reopenalrm
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|longjmp
argument_list|(
name|ReopenTimeOut
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  SM_IO_OPEN -- open a file of a specific type ** **	Parameters: **		type -- type of file to open **		timeout -- time to complete the open **		info -- info describing what is to be opened (type dependant) **		flags -- user selected flags **		rpool -- pointer to rpool to be used for this open ** **	Returns: **		Raises exception on heap exhaustion. **		Aborts if type is invalid. **		Returns NULL and sets errno **			- when the type specific open fails **			- when open vector errors **			- when flags not set or invalid **		Success returns a file pointer to the opened file type. */
end_comment

begin_function
name|SM_FILE_T
modifier|*
name|sm_io_open
parameter_list|(
name|type
parameter_list|,
name|timeout
parameter_list|,
name|info
parameter_list|,
name|flags
parameter_list|,
name|rpool
parameter_list|)
specifier|const
name|SM_FILE_T
modifier|*
name|type
decl_stmt|;
name|int
name|SM_NONVOLATILE
name|timeout
decl_stmt|;
comment|/* this is not the file type timeout */
specifier|const
name|void
modifier|*
name|info
decl_stmt|;
name|int
name|flags
decl_stmt|;
specifier|const
name|void
modifier|*
name|rpool
decl_stmt|;
block|{
specifier|register
name|SM_FILE_T
modifier|*
name|fp
decl_stmt|;
name|int
name|ioflags
decl_stmt|;
name|SM_EVENT
modifier|*
name|evt
init|=
name|NULL
decl_stmt|;
name|ioflags
operator|=
name|sm_flags
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioflags
operator|==
literal|0
condition|)
block|{
comment|/* must give some indication/intent */
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|timeout
operator|==
name|SM_TIME_DEFAULT
condition|)
name|timeout
operator|=
name|SM_TIME_FOREVER
expr_stmt|;
if|if
condition|(
name|timeout
operator|==
name|SM_TIME_IMMEDIATE
condition|)
block|{
name|errno
operator|=
name|EAGAIN
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|fp
operator|=
name|sm_fp
argument_list|(
name|type
argument_list|,
name|ioflags
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  Okay, this is where we set the timeout.  */
if|if
condition|(
name|timeout
operator|!=
name|SM_TIME_FOREVER
condition|)
block|{
if|if
condition|(
name|setjmp
argument_list|(
name|OpenTimeOut
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|EAGAIN
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|evt
operator|=
name|sm_seteventm
argument_list|(
name|timeout
argument_list|,
name|openalrm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
call|(
modifier|*
name|fp
operator|->
name|f_open
call|)
argument_list|(
name|fp
argument_list|,
name|info
argument_list|,
name|flags
argument_list|,
name|rpool
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fp
operator|->
name|f_flags
operator|=
literal|0
expr_stmt|;
comment|/* release */
name|fp
operator|->
name|sm_magic
operator|=
name|NULL
expr_stmt|;
comment|/* release */
return|return
name|NULL
return|;
block|}
comment|/*  We're back. So undo our timeout and handler */
if|if
condition|(
name|evt
operator|!=
name|NULL
condition|)
name|sm_clrevent
argument_list|(
name|evt
argument_list|)
expr_stmt|;
if|#
directive|if
name|SM_RPOOL
if|if
condition|(
name|rpool
operator|!=
name|NULL
condition|)
name|sm_rpool_attach_x
argument_list|(
name|rpool
argument_list|,
name|sm_io_fclose
argument_list|,
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SM_RPOOL */
return|return
name|fp
return|;
block|}
end_function

begin_comment
comment|/* **  SM_IO_DUP -- duplicate a file pointer ** **	Parameters: **		fp -- file pointer to duplicate ** **	Returns: **		Success - the duplicated file pointer **		Failure - NULL (was an invalid file pointer or too many open) ** **	Increments the duplicate counter (dup_cnt) for the open file pointer. **	The counter counts the number of duplicates. When the duplicate **	counter is 0 (zero) then the file pointer is the only one left **	(no duplicates, it is the only one). */
end_comment

begin_function
name|SM_FILE_T
modifier|*
name|sm_io_dup
parameter_list|(
name|fp
parameter_list|)
name|SM_FILE_T
modifier|*
name|fp
decl_stmt|;
block|{
name|SM_REQUIRE_ISA
argument_list|(
name|fp
argument_list|,
name|SmFileMagic
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|sm_magic
operator|!=
name|SmFileMagic
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|fp
operator|->
name|f_dup_cnt
operator|>=
name|INT_MAX
operator|-
literal|1
condition|)
block|{
comment|/* Can't let f_dup_cnt wrap! */
name|errno
operator|=
name|EMFILE
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|fp
operator|->
name|f_dup_cnt
operator|++
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_comment
comment|/* **  SM_IO_REOPEN -- open a new file using the old file pointer ** **	Parameters: **		type -- file type to be opened **		timeout -- time to complete the reopen **		info -- infomation about what is to be "re-opened" (type dep.) **		flags -- user flags to map to internal flags **		rpool -- rpool file to be associated with **		fp -- the file pointer to reuse ** **	Returns: **		Raises an exception on heap exhaustion. **		Aborts if type is invalid. **		Failure: returns NULL **		Success: returns "reopened" file pointer */
end_comment

begin_function
name|SM_FILE_T
modifier|*
name|sm_io_reopen
parameter_list|(
name|type
parameter_list|,
name|timeout
parameter_list|,
name|info
parameter_list|,
name|flags
parameter_list|,
name|rpool
parameter_list|,
name|fp
parameter_list|)
specifier|const
name|SM_FILE_T
modifier|*
name|type
decl_stmt|;
name|int
name|SM_NONVOLATILE
name|timeout
decl_stmt|;
specifier|const
name|void
modifier|*
name|info
decl_stmt|;
name|int
name|flags
decl_stmt|;
specifier|const
name|void
modifier|*
name|rpool
decl_stmt|;
name|SM_FILE_T
modifier|*
name|fp
decl_stmt|;
block|{
name|int
name|ioflags
decl_stmt|,
name|ret
decl_stmt|;
name|SM_FILE_T
modifier|*
name|fp2
decl_stmt|;
name|SM_EVENT
modifier|*
name|evt
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|ioflags
operator|=
name|sm_flags
argument_list|(
name|flags
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|fp
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|Sm_IO_DidInit
condition|)
name|sm_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|timeout
operator|==
name|SM_TIME_DEFAULT
condition|)
name|timeout
operator|=
name|SM_TIME_FOREVER
expr_stmt|;
if|if
condition|(
name|timeout
operator|==
name|SM_TIME_IMMEDIATE
condition|)
block|{
comment|/* 		**  Filling the buffer will take time and we are wanted to 		**  return immediately. So... 		*/
name|errno
operator|=
name|EAGAIN
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*  Okay, this is where we set the timeout.  */
if|if
condition|(
name|timeout
operator|!=
name|SM_TIME_FOREVER
condition|)
block|{
if|if
condition|(
name|setjmp
argument_list|(
name|ReopenTimeOut
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|EAGAIN
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|evt
operator|=
name|sm_seteventm
argument_list|(
name|timeout
argument_list|,
name|reopenalrm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  There are actually programs that depend on being able to "reopen" 	**  descriptors that weren't originally open.  Keep this from breaking. 	**  Remember whether the stream was open to begin with, and which file 	**  descriptor (if any) was associated with it.  If it was attached to 	**  a descriptor, defer closing it; reopen("/dev/stdin", "r", stdin) 	**  should work.  This is unnecessary if it was not a Unix file. 	*/
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|sm_magic
operator|!=
name|SmFileMagic
condition|)
name|fp
operator|->
name|f_flags
operator|=
name|SMFEOF
expr_stmt|;
comment|/* hold on to it */
else|else
block|{
comment|/* flush the stream; ANSI doesn't require this. */
operator|(
name|void
operator|)
name|sm_io_flush
argument_list|(
name|fp
argument_list|,
name|SM_TIME_FOREVER
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|fp
argument_list|,
name|SM_TIME_FOREVER
argument_list|)
expr_stmt|;
block|}
block|}
name|fp2
operator|=
name|sm_fp
argument_list|(
name|type
argument_list|,
name|ioflags
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|ret
operator|=
call|(
modifier|*
name|fp2
operator|->
name|f_open
call|)
argument_list|(
name|fp2
argument_list|,
name|info
argument_list|,
name|flags
argument_list|,
name|rpool
argument_list|)
expr_stmt|;
comment|/*  We're back. So undo our timeout and handler */
if|if
condition|(
name|evt
operator|!=
name|NULL
condition|)
name|sm_clrevent
argument_list|(
name|evt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|fp2
operator|->
name|f_flags
operator|=
literal|0
expr_stmt|;
comment|/* release */
name|fp2
operator|->
name|sm_magic
operator|=
name|NULL
expr_stmt|;
comment|/* release */
return|return
name|NULL
return|;
block|}
comment|/* 	**  We're not preserving this logic (below) for sm_io because it is now 	**  abstracted at least one "layer" away. By closing and reopening 	**  the 1st fd used should be the just released one (when Unix 	**  behavior followed). Old comment:: 	**  If reopening something that was open before on a real file, try 	**  to maintain the descriptor.  Various C library routines (perror) 	**  assume stderr is always fd STDERR_FILENO, even if being reopen'd. 	*/
if|#
directive|if
name|SM_RPOOL
if|if
condition|(
name|rpool
operator|!=
name|NULL
condition|)
name|sm_rpool_attach_x
argument_list|(
name|rpool
argument_list|,
name|sm_io_close
argument_list|,
name|fp2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SM_RPOOL */
return|return
name|fp2
return|;
block|}
end_function

begin_comment
comment|/* **  SM_IO_AUTOFLUSH -- link another file to this for auto-flushing ** **	When a read occurs on fp, fp2 will be flushed iff there is no **	data waiting on fp. ** **	Parameters: **		fp -- the file opened for reading. **		fp2 -- the file opened for writing. ** **	Returns: **		The old flush file pointer. */
end_comment

begin_function
name|SM_FILE_T
modifier|*
name|sm_io_autoflush
parameter_list|(
name|fp
parameter_list|,
name|fp2
parameter_list|)
name|SM_FILE_T
modifier|*
name|fp
decl_stmt|;
name|SM_FILE_T
modifier|*
name|fp2
decl_stmt|;
block|{
name|SM_FILE_T
modifier|*
name|savefp
decl_stmt|;
name|SM_REQUIRE_ISA
argument_list|(
name|fp
argument_list|,
name|SmFileMagic
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp2
operator|!=
name|NULL
condition|)
name|SM_REQUIRE_ISA
argument_list|(
name|fp2
argument_list|,
name|SmFileMagic
argument_list|)
expr_stmt|;
name|savefp
operator|=
name|fp
operator|->
name|f_flushfp
expr_stmt|;
name|fp
operator|->
name|f_flushfp
operator|=
name|fp2
expr_stmt|;
return|return
name|savefp
return|;
block|}
end_function

begin_comment
comment|/* **  SM_IO_AUTOMODE -- link another file to this for auto-moding ** **	When the mode (blocking or non-blocking) changes for fp1 then **	update fp2's mode at the same time. This is to be used when **	a system dup() has generated a second file descriptor for **	another sm_io_open() by file descriptor. The modes have been **	linked in the system and this formalizes it for sm_io internally. ** **	Parameters: **		fp1 -- the first file **		fp2 -- the second file ** **	Returns: **		nothing */
end_comment

begin_function
name|void
name|sm_io_automode
parameter_list|(
name|fp1
parameter_list|,
name|fp2
parameter_list|)
name|SM_FILE_T
modifier|*
name|fp1
decl_stmt|;
name|SM_FILE_T
modifier|*
name|fp2
decl_stmt|;
block|{
name|SM_REQUIRE_ISA
argument_list|(
name|fp1
argument_list|,
name|SmFileMagic
argument_list|)
expr_stmt|;
name|SM_REQUIRE_ISA
argument_list|(
name|fp2
argument_list|,
name|SmFileMagic
argument_list|)
expr_stmt|;
name|fp1
operator|->
name|f_modefp
operator|=
name|fp2
expr_stmt|;
name|fp2
operator|->
name|f_modefp
operator|=
name|fp1
expr_stmt|;
block|}
end_function

end_unit

