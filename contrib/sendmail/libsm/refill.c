begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2001 Sendmail, Inc. and its suppliers.  *      All rights reserved.  * Copyright (c) 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Chris Torek.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  */
end_comment

begin_include
include|#
directive|include
file|<sm/gen.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: refill.c,v 1.49 2001/09/11 04:04:49 gshapiro Exp $"
argument_list|)
end_macro

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sm/io.h>
end_include

begin_include
include|#
directive|include
file|<sm/conf.h>
end_include

begin_include
include|#
directive|include
file|<sm/assert.h>
end_include

begin_include
include|#
directive|include
file|"local.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|sm_lflush
name|__P
argument_list|(
operator|(
name|SM_FILE_T
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  SM_IO_RD_TIMEOUT -- measured timeout for reads ** **  This #define uses a select() to wait for the 'fd' to become readable. **  The select() can be active for up to 'To' time. The select() may not **  use all of the the 'To' time. Hence, the amount of "wall-clock" time is **  measured to decide how much to subtract from 'To' to update it. On some **  BSD-based/like systems the timeout for a select() is updated for the **  amount of time used. On many/most systems this does not happen. Therefore **  the updating of 'To' must be done ourselves; a copy of 'To' is passed **  since a BSD-like system will have updated it and we don't want to **  double the time used! **  Note: if a valid 'fd' doesn't exist yet, don't use this (e.g. the **  sendmail buffered file type in sendmail/bf.c; see use below). ** **	Parameters **		fp -- the file pointer for the active file **		fd -- raw file descriptor (from 'fp') to use for select() **		to -- struct timeval of the timeout **		timeout -- the original timeout value **		sel_ret -- the return value from the select() ** **	Returns: **		nothing, flow through code */
end_comment

begin_define
define|#
directive|define
name|SM_IO_RD_TIMEOUT
parameter_list|(
name|fp
parameter_list|,
name|fd
parameter_list|,
name|to
parameter_list|,
name|timeout
parameter_list|,
name|sel_ret
parameter_list|)
define|\
value|{									\ 	struct timeval sm_io_to_before, sm_io_to_after, sm_io_to_diff;	\ 	fd_set sm_io_to_mask, sm_io_x_mask;				\ 	errno = 0;							\ 	if (timeout == SM_TIME_IMMEDIATE)				\ 	{								\ 		errno = EAGAIN;						\ 		return SM_IO_EOF;					\ 	}								\ 	FD_ZERO(&sm_io_to_mask);					\ 	FD_SET((fd),&sm_io_to_mask);					\ 	FD_ZERO(&sm_io_x_mask);						\ 	FD_SET((fd),&sm_io_x_mask);					\ 	if (gettimeofday(&sm_io_to_before, NULL)< 0)			\ 		return SM_IO_EOF;					\ 	(sel_ret) = select((fd) + 1,&sm_io_to_mask, NULL,		\&sm_io_x_mask, (to));			\ 	if ((sel_ret)< 0)						\ 	{								\
comment|/* something went wrong, errno set */
value|\ 		fp->f_r = 0;						\ 		fp->f_flags |= SMERR;					\ 		return SM_IO_EOF;					\ 	}								\ 	else if ((sel_ret) == 0)					\ 	{								\
comment|/* timeout */
value|\ 		errno = EAGAIN;						\ 		return SM_IO_EOF;					\ 	}								\
comment|/* calulate wall-clock time used */
value|\ 	if (gettimeofday(&sm_io_to_after, NULL)< 0)			\ 		return SM_IO_EOF;					\ 	timersub(&sm_io_to_before,&sm_io_to_after,&sm_io_to_diff);	\ 	timersub((to),&sm_io_to_diff, (to));				\ }
end_define

begin_comment
comment|/* **  SM_LFLUSH -- flush a file if it is line buffered and writable ** **	Parameters: **		fp -- file pointer to flush **		timeout -- original timeout value (in milliseconds) ** **	Returns: **		Failure: returns SM_IO_EOF and sets errno **		Success: returns 0 */
end_comment

begin_function
specifier|static
name|int
name|sm_lflush
parameter_list|(
name|fp
parameter_list|,
name|timeout
parameter_list|)
name|SM_FILE_T
modifier|*
name|fp
decl_stmt|;
name|int
modifier|*
name|timeout
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|fp
operator|->
name|f_flags
operator|&
operator|(
name|SMLBF
operator||
name|SMWR
operator|)
operator|)
operator|==
operator|(
name|SMLBF
operator||
name|SMWR
operator|)
condition|)
return|return
name|sm_flush
argument_list|(
name|fp
argument_list|,
name|timeout
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* **  SM_REFILL -- refill a buffer ** **	Parameters: **		fp -- file pointer for buffer refill **		timeout -- time to complete filling the buffer in milliseconds ** **	Returns: **		Success: returns 0 **		Failure: returns SM_IO_EOF */
end_comment

begin_function
name|int
name|sm_refill
parameter_list|(
name|fp
parameter_list|,
name|timeout
parameter_list|)
specifier|register
name|SM_FILE_T
modifier|*
name|fp
decl_stmt|;
name|int
name|timeout
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|,
name|r
decl_stmt|;
name|struct
name|timeval
name|to
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|timeout
operator|==
name|SM_TIME_DEFAULT
condition|)
name|timeout
operator|=
name|fp
operator|->
name|f_timeout
expr_stmt|;
if|if
condition|(
name|timeout
operator|==
name|SM_TIME_IMMEDIATE
condition|)
block|{
comment|/* 		**  Filling the buffer will take time and we are wanted to 		**  return immediately. And we're not EOF or ERR really. 		**  So... the failure is we couldn't do it in time. 		*/
name|errno
operator|=
name|EAGAIN
expr_stmt|;
name|fp
operator|->
name|f_r
operator|=
literal|0
expr_stmt|;
comment|/* just to be sure */
return|return
literal|0
return|;
block|}
comment|/* make sure stdio is set up */
if|if
condition|(
operator|!
name|Sm_IO_DidInit
condition|)
name|sm_init
argument_list|()
expr_stmt|;
name|fp
operator|->
name|f_r
operator|=
literal|0
expr_stmt|;
comment|/* largely a convenience for callers */
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
name|SMFEOF
condition|)
return|return
name|SM_IO_EOF
return|;
name|SM_CONVERT_TIME
argument_list|(
name|fp
argument_list|,
name|fd
argument_list|,
name|timeout
argument_list|,
operator|&
name|to
argument_list|)
expr_stmt|;
comment|/* if not already reading, have to be reading and writing */
if|if
condition|(
operator|(
name|fp
operator|->
name|f_flags
operator|&
name|SMRD
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|->
name|f_flags
operator|&
name|SMRW
operator|)
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
name|fp
operator|->
name|f_flags
operator||=
name|SMERR
expr_stmt|;
return|return
name|SM_IO_EOF
return|;
block|}
comment|/* switch to reading */
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
name|SMWR
condition|)
block|{
if|if
condition|(
name|sm_flush
argument_list|(
name|fp
argument_list|,
operator|&
name|timeout
argument_list|)
condition|)
return|return
name|SM_IO_EOF
return|;
name|fp
operator|->
name|f_flags
operator|&=
operator|~
name|SMWR
expr_stmt|;
name|fp
operator|->
name|f_w
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|f_lbfsize
operator|=
literal|0
expr_stmt|;
block|}
name|fp
operator|->
name|f_flags
operator||=
name|SMRD
expr_stmt|;
block|}
else|else
block|{
comment|/* 		**  We were reading.  If there is an ungetc buffer, 		**  we must have been reading from that.  Drop it, 		**  restoring the previous buffer (if any).  If there 		**  is anything in that buffer, return. 		*/
if|if
condition|(
name|HASUB
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|FREEUB
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|->
name|f_r
operator|=
name|fp
operator|->
name|f_ur
operator|)
operator|!=
literal|0
condition|)
block|{
name|fp
operator|->
name|f_p
operator|=
name|fp
operator|->
name|f_up
expr_stmt|;
comment|/* revert blocking state */
return|return
literal|0
return|;
block|}
block|}
block|}
if|if
condition|(
name|fp
operator|->
name|f_bf
operator|.
name|smb_base
operator|==
name|NULL
condition|)
name|sm_makebuf
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* 	**  Before reading from a line buffered or unbuffered file, 	**  flush all line buffered output files, per the ANSI C standard. 	*/
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
operator|(
name|SMLBF
operator||
name|SMNBF
operator|)
condition|)
operator|(
name|void
operator|)
name|sm_fwalk
argument_list|(
name|sm_lflush
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
comment|/* 	**  If this file is linked to another, and we are going to hang 	**  on the read, flush the linked file before continuing. 	*/
if|if
condition|(
name|fp
operator|->
name|f_flushfp
operator|!=
name|NULL
operator|&&
call|(
modifier|*
name|fp
operator|->
name|f_getinfo
call|)
argument_list|(
name|fp
argument_list|,
name|SM_IO_IS_READABLE
argument_list|,
name|NULL
argument_list|)
operator|<=
literal|0
condition|)
name|sm_flush
argument_list|(
name|fp
operator|->
name|f_flushfp
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_p
operator|=
name|fp
operator|->
name|f_bf
operator|.
name|smb_base
expr_stmt|;
comment|/* 	**  The do-while loop stops trying to read when something is read 	**  or it appears that the timeout has expired before finding 	**  something available to be read (via select()). 	*/
name|ret
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* needed to ensure EOF correctly found */
name|r
operator|=
call|(
modifier|*
name|fp
operator|->
name|f_read
call|)
argument_list|(
name|fp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fp
operator|->
name|f_p
argument_list|,
name|fp
operator|->
name|f_bf
operator|.
name|smb_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|==
literal|0
operator|&&
name|errno
operator|==
literal|0
condition|)
break|break;
comment|/* EOF found */
if|if
condition|(
name|IS_IO_ERROR
argument_list|(
name|fd
argument_list|,
name|r
argument_list|,
name|timeout
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* errno set */
comment|/* read would block */
name|SM_IO_RD_TIMEOUT
argument_list|(
name|fp
argument_list|,
name|fd
argument_list|,
operator|&
name|to
argument_list|,
name|timeout
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|r
operator|<=
literal|0
operator|&&
name|ret
operator|>
literal|0
condition|)
do|;
name|err
label|:
if|if
condition|(
name|r
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|==
literal|0
condition|)
name|fp
operator|->
name|f_flags
operator||=
name|SMFEOF
expr_stmt|;
else|else
name|fp
operator|->
name|f_flags
operator||=
name|SMERR
expr_stmt|;
name|fp
operator|->
name|f_r
operator|=
literal|0
expr_stmt|;
return|return
name|SM_IO_EOF
return|;
block|}
name|fp
operator|->
name|f_r
operator|=
name|r
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* **  SM_RGET -- refills buffer and returns first character ** **  Handle sm_getc() when the buffer ran out: **  Refill, then return the first character in the newly-filled buffer. ** **	Parameters: **		fp -- file pointer to work on **		timeout -- time to complete refill ** **	Returns: **		Success: first character in refilled buffer as an int **		Failure: SM_IO_EOF */
end_comment

begin_function
name|int
name|sm_rget
parameter_list|(
name|fp
parameter_list|,
name|timeout
parameter_list|)
specifier|register
name|SM_FILE_T
modifier|*
name|fp
decl_stmt|;
name|int
name|timeout
decl_stmt|;
block|{
if|if
condition|(
name|sm_refill
argument_list|(
name|fp
argument_list|,
name|timeout
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fp
operator|->
name|f_r
operator|--
expr_stmt|;
return|return
operator|*
name|fp
operator|->
name|f_p
operator|++
return|;
block|}
return|return
name|SM_IO_EOF
return|;
block|}
end_function

end_unit

