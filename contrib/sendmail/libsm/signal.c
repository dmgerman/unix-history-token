begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2001 Sendmail, Inc. and its suppliers.  *      All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  */
end_comment

begin_include
include|#
directive|include
file|<sm/gen.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: signal.c,v 1.1.1.1 2002/02/17 21:56:43 gshapiro Exp $"
argument_list|)
end_macro

begin_if
if|#
directive|if
name|SM_CONF_SETITIMER
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SM_CONF_SETITIMER */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sm/clock.h>
end_include

begin_include
include|#
directive|include
file|<sm/signal.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sm/string.h>
end_include

begin_decl_stmt
name|unsigned
name|int
specifier|volatile
name|InCriticalSection
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*>0 if inside critical section */
end_comment

begin_decl_stmt
name|int
specifier|volatile
name|PendingSignal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pending signal to resend */
end_comment

begin_comment
comment|/* **  SM_SIGNAL -- set a signal handler ** **	This is essentially old BSD "signal(3)". ** **	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD **		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE **		DOING. */
end_comment

begin_function
name|sigfunc_t
name|sm_signal
parameter_list|(
name|sig
parameter_list|,
name|handler
parameter_list|)
name|int
name|sig
decl_stmt|;
name|sigfunc_t
name|handler
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|SA_RESTART
argument_list|)
operator|||
operator|(
operator|!
name|defined
argument_list|(
name|SYS5SIGNALS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BSD4_3
argument_list|)
operator|)
name|struct
name|sigaction
name|n
decl_stmt|,
name|o
decl_stmt|;
endif|#
directive|endif
comment|/* defined(SA_RESTART) || (!defined(SYS5SIGNALS)&& !defined(BSD4_3)) */
comment|/* 	**  First, try for modern signal calls 	**  and restartable syscalls 	*/
ifdef|#
directive|ifdef
name|SA_RESTART
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|&
name|n
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|n
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_SA_SIGACTION
name|n
operator|.
name|sa_sigaction
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|,
name|siginfo_t
operator|*
argument_list|,
name|void
operator|*
argument_list|)
operator|)
name|handler
expr_stmt|;
name|n
operator|.
name|sa_flags
operator|=
name|SA_RESTART
operator||
name|SA_SIGINFO
expr_stmt|;
else|#
directive|else
comment|/* USE_SA_SIGACTION */
name|n
operator|.
name|sa_handler
operator|=
name|handler
expr_stmt|;
name|n
operator|.
name|sa_flags
operator|=
name|SA_RESTART
expr_stmt|;
endif|#
directive|endif
comment|/* USE_SA_SIGACTION */
if|if
condition|(
name|sigaction
argument_list|(
name|sig
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|o
argument_list|)
operator|<
literal|0
condition|)
return|return
name|SIG_ERR
return|;
return|return
name|o
operator|.
name|sa_handler
return|;
else|#
directive|else
comment|/* SA_RESTART */
comment|/* 	**  Else check for SYS5SIGNALS or 	**  BSD4_3 signals 	*/
if|#
directive|if
name|defined
argument_list|(
name|SYS5SIGNALS
argument_list|)
operator|||
name|defined
argument_list|(
name|BSD4_3
argument_list|)
ifdef|#
directive|ifdef
name|BSD4_3
return|return
name|signal
argument_list|(
name|sig
argument_list|,
name|handler
argument_list|)
return|;
else|#
directive|else
comment|/* BSD4_3 */
return|return
name|sigset
argument_list|(
name|sig
argument_list|,
name|handler
argument_list|)
return|;
endif|#
directive|endif
comment|/* BSD4_3 */
else|#
directive|else
comment|/* defined(SYS5SIGNALS) || defined(BSD4_3) */
comment|/* 	**  Finally, if nothing else is available, 	**  go for a default 	*/
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|&
name|n
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|n
argument_list|)
expr_stmt|;
name|n
operator|.
name|sa_handler
operator|=
name|handler
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|sig
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|o
argument_list|)
operator|<
literal|0
condition|)
return|return
name|SIG_ERR
return|;
return|return
name|o
operator|.
name|sa_handler
return|;
endif|#
directive|endif
comment|/* defined(SYS5SIGNALS) || defined(BSD4_3) */
endif|#
directive|endif
comment|/* SA_RESTART */
block|}
end_function

begin_comment
comment|/* **  SM_BLOCKSIGNAL -- hold a signal to prevent delivery ** **	Parameters: **		sig -- the signal to block. ** **	Returns: **		1 signal was previously blocked **		0 signal was not previously blocked **		-1 on failure. */
end_comment

begin_function
name|int
name|sm_blocksignal
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BSD4_3
ifndef|#
directive|ifndef
name|sigmask
define|#
directive|define
name|sigmask
parameter_list|(
name|s
parameter_list|)
value|(1<< ((s) - 1))
endif|#
directive|endif
comment|/* ! sigmask */
return|return
operator|(
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|sig
argument_list|)
argument_list|)
operator|&
name|sigmask
argument_list|(
name|sig
argument_list|)
operator|)
operator|!=
literal|0
return|;
else|#
directive|else
comment|/* BSD4_3 */
ifdef|#
directive|ifdef
name|ALTOS_SYSTEM_V
name|sigfunc_t
name|handler
decl_stmt|;
name|handler
operator|=
name|sigset
argument_list|(
name|sig
argument_list|,
name|SIG_HOLD
argument_list|)
expr_stmt|;
if|if
condition|(
name|handler
operator|==
name|SIG_ERR
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
name|handler
operator|==
name|SIG_HOLD
return|;
else|#
directive|else
comment|/* ALTOS_SYSTEM_V */
name|sigset_t
name|sset
decl_stmt|,
name|oset
decl_stmt|;
operator|(
name|void
operator|)
name|sigemptyset
argument_list|(
operator|&
name|sset
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaddset
argument_list|(
operator|&
name|sset
argument_list|,
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|sset
argument_list|,
operator|&
name|oset
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
name|sigismember
argument_list|(
operator|&
name|oset
argument_list|,
name|sig
argument_list|)
return|;
endif|#
directive|endif
comment|/* ALTOS_SYSTEM_V */
endif|#
directive|endif
comment|/* BSD4_3 */
block|}
end_function

begin_comment
comment|/* **  SM_RELEASESIGNAL -- release a held signal ** **	Parameters: **		sig -- the signal to release. ** **	Returns: **		1 signal was previously blocked **		0 signal was not previously blocked **		-1 on failure. */
end_comment

begin_function
name|int
name|sm_releasesignal
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BSD4_3
return|return
operator|(
name|sigsetmask
argument_list|(
name|sigblock
argument_list|(
literal|0
argument_list|)
operator|&
operator|~
name|sigmask
argument_list|(
name|sig
argument_list|)
argument_list|)
operator|&
name|sigmask
argument_list|(
name|sig
argument_list|)
operator|)
operator|!=
literal|0
return|;
else|#
directive|else
comment|/* BSD4_3 */
ifdef|#
directive|ifdef
name|ALTOS_SYSTEM_V
name|sigfunc_t
name|handler
decl_stmt|;
name|handler
operator|=
name|sigset
argument_list|(
name|sig
argument_list|,
name|SIG_HOLD
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrelse
argument_list|(
name|sig
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
name|handler
operator|==
name|SIG_HOLD
return|;
else|#
directive|else
comment|/* ALTOS_SYSTEM_V */
name|sigset_t
name|sset
decl_stmt|,
name|oset
decl_stmt|;
operator|(
name|void
operator|)
name|sigemptyset
argument_list|(
operator|&
name|sset
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaddset
argument_list|(
operator|&
name|sset
argument_list|,
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigprocmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|sset
argument_list|,
operator|&
name|oset
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
name|sigismember
argument_list|(
operator|&
name|oset
argument_list|,
name|sig
argument_list|)
return|;
endif|#
directive|endif
comment|/* ALTOS_SYSTEM_V */
endif|#
directive|endif
comment|/* BSD4_3 */
block|}
end_function

begin_comment
comment|/* **  PEND_SIGNAL -- Add a signal to the pending signal list ** **	Parameters: **		sig -- signal to add ** **	Returns: **		none. ** **	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD **		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE **		DOING. */
end_comment

begin_function
name|void
name|pend_signal
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|int
name|sigbit
decl_stmt|;
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|#
directive|if
name|SM_CONF_SETITIMER
name|struct
name|itimerval
name|clr
decl_stmt|;
endif|#
directive|endif
comment|/* SM_CONF_SETITIMER */
comment|/* 	**  Don't want to interrupt something critical, hence delay 	**  the alarm for one second.  Hopefully, by then we 	**  will be out of the critical section.  If not, then 	**  we will just delay again.  The events to be run will 	**  still all be run, maybe just a little bit late. 	*/
switch|switch
condition|(
name|sig
condition|)
block|{
case|case
name|SIGHUP
case|:
name|sigbit
operator|=
name|PEND_SIGHUP
expr_stmt|;
break|break;
case|case
name|SIGINT
case|:
name|sigbit
operator|=
name|PEND_SIGINT
expr_stmt|;
break|break;
case|case
name|SIGTERM
case|:
name|sigbit
operator|=
name|PEND_SIGTERM
expr_stmt|;
break|break;
case|case
name|SIGUSR1
case|:
name|sigbit
operator|=
name|PEND_SIGUSR1
expr_stmt|;
break|break;
case|case
name|SIGALRM
case|:
comment|/* don't have to pend these */
name|sigbit
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* If we get here, we are in trouble */
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
comment|/* shut up stupid compiler warning on HP-UX 11 */
name|sigbit
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sigbit
operator|!=
literal|0
condition|)
name|PendingSignal
operator||=
name|sigbit
expr_stmt|;
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGALRM
argument_list|,
name|sm_tick
argument_list|)
expr_stmt|;
if|#
directive|if
name|SM_CONF_SETITIMER
name|clr
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|clr
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|clr
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
literal|1
expr_stmt|;
name|clr
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|clr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SM_CONF_SETITIMER */
operator|(
name|void
operator|)
name|alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SM_CONF_SETITIMER */
name|errno
operator|=
name|save_errno
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  SM_ALLSIGNALS -- act on all signals ** **	Parameters: **		block -- whether to block or release all signals. ** **	Returns: **		none. */
end_comment

begin_function
name|void
name|sm_allsignals
parameter_list|(
name|block
parameter_list|)
name|bool
name|block
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BSD4_3
ifndef|#
directive|ifndef
name|sigmask
define|#
directive|define
name|sigmask
parameter_list|(
name|s
parameter_list|)
value|(1<< ((s) - 1))
endif|#
directive|endif
comment|/* ! sigmask */
if|if
condition|(
name|block
condition|)
block|{
name|int
name|mask
init|=
literal|0
decl_stmt|;
name|mask
operator||=
name|sigmask
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
name|mask
operator||=
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
name|mask
operator||=
name|sigmask
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
name|mask
operator||=
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
name|mask
operator||=
name|sigmask
argument_list|(
name|SIGTERM
argument_list|)
expr_stmt|;
name|mask
operator||=
name|sigmask
argument_list|(
name|SIGUSR1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigblock
argument_list|(
name|mask
argument_list|)
expr_stmt|;
block|}
else|else
name|sigsetmask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* BSD4_3 */
ifdef|#
directive|ifdef
name|ALTOS_SYSTEM_V
if|if
condition|(
name|block
condition|)
block|{
operator|(
name|void
operator|)
name|sigset
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_HOLD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigset
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_HOLD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigset
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_HOLD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigset
argument_list|(
name|SIGINT
argument_list|,
name|SIG_HOLD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigset
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_HOLD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigset
argument_list|(
name|SIGUSR1
argument_list|,
name|SIG_HOLD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sigset
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigset
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigset
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigset
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigset
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigset
argument_list|(
name|SIGUSR1
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* ALTOS_SYSTEM_V */
name|sigset_t
name|sset
decl_stmt|;
operator|(
name|void
operator|)
name|sigemptyset
argument_list|(
operator|&
name|sset
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaddset
argument_list|(
operator|&
name|sset
argument_list|,
name|SIGALRM
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaddset
argument_list|(
operator|&
name|sset
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaddset
argument_list|(
operator|&
name|sset
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaddset
argument_list|(
operator|&
name|sset
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaddset
argument_list|(
operator|&
name|sset
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaddset
argument_list|(
operator|&
name|sset
argument_list|,
name|SIGUSR1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigprocmask
argument_list|(
name|block
condition|?
name|SIG_BLOCK
else|:
name|SIG_UNBLOCK
argument_list|,
operator|&
name|sset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ALTOS_SYSTEM_V */
endif|#
directive|endif
comment|/* BSD4_3 */
block|}
end_function

begin_comment
comment|/* **  SM_SIGNAL_NOOP -- A signal no-op function ** **	Parameters: **		sig -- signal received ** **	Returns: **		SIGFUNC_RETURN */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|SIGFUNC_DECL
name|sm_signal_noop
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|FIX_SYSV_SIGNAL
argument_list|(
name|sig
argument_list|,
name|sm_signal_noop
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
name|SIGFUNC_RETURN
return|;
block|}
end_function

end_unit

