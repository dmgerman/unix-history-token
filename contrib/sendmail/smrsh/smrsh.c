begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.  *	All rights reserved.  * Copyright (c) 1993 Eric P. Allman.  All rights reserved.  * Copyright (c) 1993  *	The Regents of the University of California.  All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_include
include|#
directive|include
file|<sm/gen.h>
end_include

begin_macro
name|SM_IDSTR
argument_list|(
argument|copyright
argument_list|,
literal|"@(#) Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.\n\ 	All rights reserved.\n\      Copyright (c) 1993 Eric P. Allman.  All rights reserved.\n\      Copyright (c) 1993\n\ 	The Regents of the University of California.  All rights reserved.\n"
argument_list|)
end_macro

begin_macro
name|SM_IDSTR
argument_list|(
argument|id
argument_list|,
literal|"@(#)$Id: smrsh.c,v 8.55 2001/09/11 04:05:22 gshapiro Exp $"
argument_list|)
end_macro

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* **  SMRSH -- sendmail restricted shell ** **	This is a patch to get around the prog mailer bugs in most **	versions of sendmail. ** **	Use this in place of /bin/sh in the "prog" mailer definition **	in your sendmail.cf file.  You then create CMDDIR (owned by **	root, mode 755) and put links to any programs you want **	available to prog mailers in that directory.  This should **	include things like "vacation" and "procmail", but not "sed" **	or "sh". ** **	Leading pathnames are stripped from program names so that **	existing .forward files that reference things like **	"/usr/bin/vacation" will continue to work. ** **	The following characters are completely illegal: **<>  ^&  `  (  ) \n \r **	The following characters are sometimes illegal: **		|& **	This is more restrictive than strictly necessary. ** **	To use this, add FEATURE(`smrsh') to your .mc file. ** **	This can be used on any version of sendmail. ** **	In loving memory of RTM.  11/02/93. */
end_comment

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sm/io.h>
end_include

begin_include
include|#
directive|include
file|<sm/string.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EX_OK
end_ifdef

begin_undef
undef|#
directive|undef
name|EX_OK
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EX_OK */
end_comment

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sm/conf.h>
end_include

begin_include
include|#
directive|include
file|<sm/errstring.h>
end_include

begin_comment
comment|/* directory in which all commands must reside */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CMDDIR
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|SMRSH_CMDDIR
end_ifdef

begin_define
define|#
directive|define
name|CMDDIR
value|SMRSH_CMDDIR
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SMRSH_CMDDIR */
end_comment

begin_define
define|#
directive|define
name|CMDDIR
value|"/usr/adm/sm.bin"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SMRSH_CMDDIR */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! CMDDIR */
end_comment

begin_comment
comment|/* characters disallowed in the shell "-c" argument */
end_comment

begin_define
define|#
directive|define
name|SPECIALS
value|"<|>^();&`$\r\n"
end_define

begin_comment
comment|/* default search path */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PATH
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|SMRSH_PATH
end_ifdef

begin_define
define|#
directive|define
name|PATH
value|SMRSH_PATH
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SMRSH_PATH */
end_comment

begin_define
define|#
directive|define
name|PATH
value|"/bin:/usr/bin:/usr/ucb"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SMRSH_PATH */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! PATH */
end_comment

begin_decl_stmt
name|char
name|newcmdbuf
index|[
literal|1000
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|prg
decl_stmt|,
modifier|*
name|par
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  ADDCMD -- add a string to newcmdbuf, check for overflow ** **    Parameters: **	s -- string to add **	cmd -- it's a command: prepend CMDDIR/ **	len -- length of string to add ** **    Side Effects: **	changes newcmdbuf or exits with a failure. ** */
end_comment

begin_function
name|void
name|addcmd
parameter_list|(
name|s
parameter_list|,
name|cmd
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|bool
name|cmd
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return;
if|if
condition|(
sizeof|sizeof
name|newcmdbuf
operator|-
name|strlen
argument_list|(
name|newcmdbuf
argument_list|)
operator|<=
name|len
operator|+
operator|(
name|cmd
condition|?
operator|(
name|strlen
argument_list|(
name|CMDDIR
argument_list|)
operator|+
literal|1
operator|)
else|:
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioerr
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s: command too long: %s\n"
argument_list|,
name|prg
argument_list|,
name|par
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DEBUG
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"command too long: %.40s"
argument_list|,
name|par
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! DEBUG */
name|exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmd
condition|)
block|{
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|newcmdbuf
argument_list|,
name|CMDDIR
argument_list|,
sizeof|sizeof
name|newcmdbuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|newcmdbuf
argument_list|,
literal|"/"
argument_list|,
sizeof|sizeof
name|newcmdbuf
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|newcmdbuf
argument_list|,
name|s
argument_list|,
sizeof|sizeof
name|newcmdbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|char
modifier|*
name|r
decl_stmt|;
specifier|register
name|char
modifier|*
name|cmd
decl_stmt|;
name|int
name|isexec
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
name|char
modifier|*
name|newenv
index|[
literal|2
index|]
decl_stmt|;
name|char
name|cmdbuf
index|[
literal|1000
index|]
decl_stmt|;
name|char
name|pathbuf
index|[
literal|1000
index|]
decl_stmt|;
name|char
name|specialbuf
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
ifndef|#
directive|ifndef
name|DEBUG
ifndef|#
directive|ifndef
name|LOG_MAIL
name|openlog
argument_list|(
literal|"smrsh"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! LOG_MAIL */
name|openlog
argument_list|(
literal|"smrsh"
argument_list|,
name|LOG_ODELAY
operator||
name|LOG_CONS
argument_list|,
name|LOG_MAIL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! LOG_MAIL */
endif|#
directive|endif
comment|/* ! DEBUG */
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|pathbuf
argument_list|,
literal|"PATH="
argument_list|,
sizeof|sizeof
name|pathbuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|pathbuf
argument_list|,
name|PATH
argument_list|,
sizeof|sizeof
name|pathbuf
argument_list|)
expr_stmt|;
name|newenv
index|[
literal|0
index|]
operator|=
name|pathbuf
expr_stmt|;
name|newenv
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* 	**  Do basic argv usage checking 	*/
name|prg
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
operator|||
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-c"
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioerr
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Usage: %s -c command\n"
argument_list|,
name|prg
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DEBUG
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"usage"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! DEBUG */
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
name|par
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
comment|/* 	**  Disallow special shell syntax.  This is overly restrictive, 	**  but it should shut down all attacks. 	**  Be sure to include 8-bit versions, since many shells strip 	**  the address to 7 bits before checking. 	*/
if|if
condition|(
name|strlen
argument_list|(
name|SPECIALS
argument_list|)
operator|*
literal|2
operator|>=
sizeof|sizeof
name|specialbuf
condition|)
block|{
ifndef|#
directive|ifndef
name|DEBUG
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"too many specials: %.40s"
argument_list|,
name|SPECIALS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! DEBUG */
name|exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|specialbuf
argument_list|,
name|SPECIALS
argument_list|,
sizeof|sizeof
name|specialbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|specialbuf
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator||=
literal|'\200'
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|specialbuf
argument_list|,
name|SPECIALS
argument_list|,
sizeof|sizeof
name|specialbuf
argument_list|)
expr_stmt|;
comment|/* 	**  Do a quick sanity check on command line length. 	*/
if|if
condition|(
name|strlen
argument_list|(
name|par
argument_list|)
operator|>
operator|(
sizeof|sizeof
name|newcmdbuf
operator|-
sizeof|sizeof
name|CMDDIR
operator|-
literal|2
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioerr
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s: command too long: %s\n"
argument_list|,
name|prg
argument_list|,
name|par
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DEBUG
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"command too long: %.40s"
argument_list|,
name|par
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! DEBUG */
name|exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
name|q
operator|=
name|par
expr_stmt|;
name|newcmdbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|isexec
operator|=
name|false
expr_stmt|;
while|while
condition|(
operator|*
name|q
condition|)
block|{
comment|/* 		**  Strip off a leading pathname on the command name.  For 		**  example, change /usr/ucb/vacation to vacation. 		*/
comment|/* strip leading spaces */
while|while
condition|(
operator|*
name|q
operator|!=
literal|'\0'
operator|&&
name|isascii
argument_list|(
operator|*
name|q
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|q
argument_list|)
condition|)
name|q
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|isexec
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioerr
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s: missing command to exec\n"
argument_list|,
name|prg
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DEBUG
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"uid %d: missing command to exec"
argument_list|,
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! DEBUG */
name|exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* find the end of the command name */
name|p
operator|=
name|strpbrk
argument_list|(
name|q
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|cmd
operator|=
operator|&
name|q
index|[
name|strlen
argument_list|(
name|q
argument_list|)
index|]
expr_stmt|;
else|else
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|cmd
operator|=
name|p
expr_stmt|;
block|}
comment|/* search backwards for last / (allow for 0200 bit) */
while|while
condition|(
name|cmd
operator|>
name|q
condition|)
block|{
if|if
condition|(
operator|(
operator|*
operator|--
name|cmd
operator|&
literal|0177
operator|)
operator|==
literal|'/'
condition|)
block|{
name|cmd
operator|++
expr_stmt|;
break|break;
block|}
block|}
comment|/* cmd now points at final component of path name */
comment|/* allow a few shell builtins */
if|if
condition|(
name|strcmp
argument_list|(
name|q
argument_list|,
literal|"exec"
argument_list|)
operator|==
literal|0
operator|&&
name|p
operator|!=
name|NULL
condition|)
block|{
name|addcmd
argument_list|(
literal|"exec "
argument_list|,
name|false
argument_list|,
name|strlen
argument_list|(
literal|"exec "
argument_list|)
argument_list|)
expr_stmt|;
comment|/* test _next_ arg */
name|q
operator|=
operator|++
name|p
expr_stmt|;
name|isexec
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|q
argument_list|,
literal|"exit"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|q
argument_list|,
literal|"echo"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|addcmd
argument_list|(
name|cmd
argument_list|,
name|false
argument_list|,
name|strlen
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* test following chars */
block|}
else|else
block|{
comment|/* 			**  Check to see if the command name is legal. 			*/
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|cmdbuf
argument_list|,
name|CMDDIR
argument_list|,
sizeof|sizeof
name|cmdbuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|cmdbuf
argument_list|,
literal|"/"
argument_list|,
sizeof|sizeof
name|cmdbuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|cmdbuf
argument_list|,
name|cmd
argument_list|,
sizeof|sizeof
name|cmdbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Trying %s\n"
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|stat
argument_list|(
name|cmdbuf
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* can't stat it */
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioerr
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s: %s not available for sendmail programs (stat failed)\n"
argument_list|,
name|prg
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
ifndef|#
directive|ifndef
name|DEBUG
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"uid %d: attempt to use %s (stat failed)"
argument_list|,
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! DEBUG */
name|exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
ifdef|#
directive|ifdef
name|S_ISLNK
operator|&&
operator|!
name|S_ISLNK
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
endif|#
directive|endif
comment|/* S_ISLNK */
condition|)
block|{
comment|/* can't stat it */
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioerr
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s: %s not available for sendmail programs (not a file)\n"
argument_list|,
name|prg
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
ifndef|#
directive|ifndef
name|DEBUG
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"uid %d: attempt to use %s (not a file)"
argument_list|,
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! DEBUG */
name|exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|access
argument_list|(
name|cmdbuf
argument_list|,
name|X_OK
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* oops....  crack attack possiblity */
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioerr
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s: %s not available for sendmail programs\n"
argument_list|,
name|prg
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
ifndef|#
directive|ifndef
name|DEBUG
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"uid %d: attempt to use %s"
argument_list|,
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! DEBUG */
name|exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
comment|/* 			**  Create the actual shell input. 			*/
name|addcmd
argument_list|(
name|cmd
argument_list|,
name|true
argument_list|,
name|strlen
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|isexec
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
else|else
break|break;
name|r
operator|=
name|strpbrk
argument_list|(
name|p
argument_list|,
name|specialbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
name|addcmd
argument_list|(
name|p
argument_list|,
name|false
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|ALLOWSEMI
if|if
condition|(
operator|*
name|r
operator|==
literal|';'
condition|)
block|{
name|addcmd
argument_list|(
name|p
argument_list|,
name|false
argument_list|,
name|r
operator|-
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|q
operator|=
name|r
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* ALLOWSEMI */
if|if
condition|(
operator|(
operator|*
name|r
operator|==
literal|'&'
operator|&&
operator|*
operator|(
name|r
operator|+
literal|1
operator|)
operator|==
literal|'&'
operator|)
operator|||
operator|(
operator|*
name|r
operator|==
literal|'|'
operator|&&
operator|*
operator|(
name|r
operator|+
literal|1
operator|)
operator|==
literal|'|'
operator|)
condition|)
block|{
name|addcmd
argument_list|(
name|p
argument_list|,
name|false
argument_list|,
name|r
operator|-
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
name|q
operator|=
name|r
operator|+
literal|2
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioerr
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s: cannot use %c in command\n"
argument_list|,
name|prg
argument_list|,
operator|*
name|r
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DEBUG
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"uid %d: attempt to use %c in command: %s"
argument_list|,
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|,
operator|*
name|r
argument_list|,
name|par
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! DEBUG */
name|exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
comment|/* end of while *q */
if|if
condition|(
name|isexec
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioerr
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s: missing command to exec\n"
argument_list|,
name|prg
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DEBUG
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"uid %d: missing command to exec"
argument_list|,
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! DEBUG */
name|exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
comment|/* make sure we created something */
if|if
condition|(
name|newcmdbuf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioerr
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Usage: %s -c command\n"
argument_list|,
name|prg
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DEBUG
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"usage"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! DEBUG */
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Now invoke the shell 	*/
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s\n"
argument_list|,
name|newcmdbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
operator|(
name|void
operator|)
name|execle
argument_list|(
literal|"/bin/sh"
argument_list|,
literal|"/bin/sh"
argument_list|,
literal|"-c"
argument_list|,
name|newcmdbuf
argument_list|,
name|NULL
argument_list|,
name|newenv
argument_list|)
expr_stmt|;
name|save_errno
operator|=
name|errno
expr_stmt|;
ifndef|#
directive|ifndef
name|DEBUG
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"Cannot exec /bin/sh: %s"
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! DEBUG */
name|errno
operator|=
name|save_errno
expr_stmt|;
name|sm_perror
argument_list|(
literal|"/bin/sh"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSFILE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|EX_OSFILE
return|;
block|}
end_function

end_unit

