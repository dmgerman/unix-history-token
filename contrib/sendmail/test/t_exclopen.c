begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1999 Proofpoint, Inc. and its suppliers.  *	All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_comment
comment|/* **  This program tests your system to see if you have the lovely **  security-defeating semantics that an open with O_CREAT|O_EXCL **  set will successfully open a file named by a symbolic link that **  points to a non-existent file.  Sadly, Posix is mute on what **  should happen in this situation. ** **  Results to date: **	AIX 3.2		OK **	BSD family	OK **	  BSD/OS 2.1	OK **	  FreeBSD 2.1	OK **	DEC OSF/1 3.0	OK **	HP-UX 9.04	FAIL **	HP-UX 9.05	FAIL **	HP-UX 9.07	OK **	HP-UX 10.01	OK **	HP-UX 10.10	OK **	HP-UX 10.20	OK **	Irix 5.3	OK **	Irix 6.2	OK **	Irix 6.3	OK **	Irix 6.4	OK **	Linux		OK **	NeXT 2.1	OK **	Solaris 2.x	OK **	SunOS 4.x	OK **	Ultrix 4.3	OK */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|id
index|[]
init|=
literal|"@(#)$Id: t_exclopen.c,v 8.7 2013-11-22 20:52:01 ca Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! lint */
end_comment

begin_decl_stmt
specifier|static
name|char
name|Attacker
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|Attackee
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|bail
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|Attacker
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|Attackee
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|sprintf
argument_list|(
name|Attacker
argument_list|,
literal|"/tmp/attacker.%d.%ld"
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|Attackee
argument_list|,
literal|"/tmp/attackee.%d.%ld"
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|symlink
argument_list|(
name|Attackee
argument_list|,
name|Attacker
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Could not create %s->%s symlink: %d\n"
argument_list|,
name|Attacker
argument_list|,
name|Attackee
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|bail
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|Attackee
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|Attackee
argument_list|,
operator|&
name|st
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s already exists -- remove and try again.\n"
argument_list|,
name|Attackee
argument_list|)
expr_stmt|;
name|bail
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|open
argument_list|(
name|Attacker
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0644
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|Attackee
argument_list|,
operator|&
name|st
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Weird.  Open failed but %s was created anyhow (errno = %d)\n"
argument_list|,
name|Attackee
argument_list|,
name|save_errno
argument_list|)
expr_stmt|;
name|bail
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Good show!  Exclusive open works properly with symbolic links (errno = %d).\n"
argument_list|,
name|save_errno
argument_list|)
expr_stmt|;
name|bail
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|Attackee
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Weird.  Open succeeded but %s was not created\n"
argument_list|,
name|Attackee
argument_list|)
expr_stmt|;
name|bail
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Bad news: you can do an exclusive open through a symbolic link\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tBe sure you #define BOGUS_O_EXCL in conf.h\n"
argument_list|)
expr_stmt|;
name|bail
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

