begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.  *	All rights reserved.  * Copyright (c) 1983, 1987, 1993  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1983 Eric P. Allman.  All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.\n\ 	All rights reserved.\n\      Copyright (c) 1983, 1987, 1993\n\ 	The Regents of the University of California.  All rights reserved.\n\      Copyright (c) 1983 Eric P. Allman.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|id
index|[]
init|=
literal|"@(#)$Id: vacation.c,v 8.68.4.21 2001/05/07 22:06:41 gshapiro Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! lint */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EX_OK
end_ifdef

begin_undef
undef|#
directive|undef
name|EX_OK
end_undef

begin_comment
comment|/* unistd.h may have another use for this */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EX_OK */
end_comment

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|"sendmail/sendmail.h"
end_include

begin_include
include|#
directive|include
file|"libsmdb/smdb.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HPUX11
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|syslog
end_undef

begin_comment
comment|/* Undo hard_syslog conf.h change */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(__hpux)&& !defined(HPUX11) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_PATH_SENDMAIL
end_ifndef

begin_define
define|#
directive|define
name|_PATH_SENDMAIL
value|"/usr/lib/sendmail"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! _PATH_SENDMAIL */
end_comment

begin_define
define|#
directive|define
name|ONLY_ONCE
value|((time_t) 0)
end_define

begin_comment
comment|/* send at most one reply */
end_comment

begin_define
define|#
directive|define
name|INTERVAL_UNDEF
value|((time_t) (-1))
end_define

begin_comment
comment|/* no value given */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! TRUE */
end_comment

begin_decl_stmt
name|uid_t
name|RealUid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|gid_t
name|RealGid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|RealUserName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uid_t
name|RunAsUid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uid_t
name|RunAsGid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|RunAsUserName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Verbose
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|DontInitGroups
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uid_t
name|TrustedUid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BITMAP256
name|DontBlameSendmail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  VACATION -- return a message to the sender when on vacation. ** **	This program is invoked as a message receiver.  It returns a **	message specified by the user to whomever sent the mail, taking **	care not to return a message too often to prevent "I am on **	vacation" loops. */
end_comment

begin_define
define|#
directive|define
name|VDB
value|".vacation"
end_define

begin_comment
comment|/* vacation database */
end_comment

begin_define
define|#
directive|define
name|VMSG
value|".vacation.msg"
end_define

begin_comment
comment|/* vacation message */
end_comment

begin_define
define|#
directive|define
name|SECSPERDAY
value|(60 * 60 * 24)
end_define

begin_define
define|#
directive|define
name|DAYSPERWEEK
value|7
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|__P
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|__P
parameter_list|(
name|protos
parameter_list|)
value|protos
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __STDC__ */
end_comment

begin_define
define|#
directive|define
name|__P
parameter_list|(
name|protos
parameter_list|)
value|()
end_define

begin_define
define|#
directive|define
name|const
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STDC__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! __P */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|alias
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|alias
modifier|*
name|next
decl_stmt|;
block|}
name|ALIAS
typedef|;
end_typedef

begin_decl_stmt
name|ALIAS
modifier|*
name|Names
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SMDB_DATABASE
modifier|*
name|Db
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|From
index|[
name|MAXLINE
index|]
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|_FFR_DEBUG
end_if

begin_function_decl
name|void
function_decl|(
modifier|*
name|msglog
function_decl|)
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
init|=
operator|&
name|syslog
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|debuglog
name|__P
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* _FFR_DEBUG */
end_comment

begin_define
define|#
directive|define
name|msglog
value|syslog
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_DEBUG */
end_comment

begin_decl_stmt
specifier|static
name|void
name|eatmsg
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* exit after reading input */
end_comment

begin_define
define|#
directive|define
name|EXITIT
parameter_list|(
name|excode
parameter_list|)
value|{ \ 				eatmsg(); \ 				return excode; \ 			}
end_define

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|bool
name|iflag
decl_stmt|,
name|emptysender
decl_stmt|,
name|exclude
decl_stmt|;
if|#
directive|if
name|_FFR_BLACKBOX
name|bool
name|runasuser
init|=
name|FALSE
decl_stmt|;
endif|#
directive|endif
comment|/* _FFR_BLACKBOX */
if|#
directive|if
name|_FFR_LISTDB
name|bool
name|lflag
init|=
name|FALSE
decl_stmt|;
endif|#
directive|endif
comment|/* _FFR_LISTDB */
name|int
name|mfail
init|=
literal|0
decl_stmt|,
name|ufail
init|=
literal|0
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|result
decl_stmt|;
name|long
name|sff
decl_stmt|;
name|time_t
name|interval
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|ALIAS
modifier|*
name|cur
decl_stmt|;
name|char
modifier|*
name|dbfilename
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|msgfilename
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|SMDB_USER_INFO
name|user_info
decl_stmt|;
specifier|static
name|char
name|rnamebuf
index|[
name|MAXNAME
index|]
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|,
name|opterr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|extern
name|void
name|usage
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|setinterval
name|__P
argument_list|(
operator|(
name|time_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|readheaders
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|bool
name|recent
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|setreply
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|time_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|sendmessage
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|bool
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|xclude
name|__P
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
if|#
directive|if
name|_FFR_LISTDB
define|#
directive|define
name|EXITM
parameter_list|(
name|excode
parameter_list|)
value|{ \ 				if (!iflag&& !lflag) \ 					eatmsg(); \ 				exit(excode); \ 			}
else|#
directive|else
comment|/* _FFR_LISTDB */
define|#
directive|define
name|EXITM
parameter_list|(
name|excode
parameter_list|)
value|{ \ 				if (!iflag) \ 					eatmsg(); \ 				exit(excode); \ 			}
endif|#
directive|endif
comment|/* _FFR_LISTDB */
comment|/* Vars needed to link with smutil */
name|clrbitmap
argument_list|(
name|DontBlameSendmail
argument_list|)
expr_stmt|;
name|RunAsUid
operator|=
name|RealUid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|RunAsGid
operator|=
name|RealGid
operator|=
name|getgid
argument_list|()
expr_stmt|;
name|pw
operator|=
name|getpwuid
argument_list|(
name|RealUid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|)
operator|>
name|MAXNAME
operator|-
literal|1
condition|)
name|pw
operator|->
name|pw_name
index|[
name|MAXNAME
index|]
operator|=
literal|'\0'
expr_stmt|;
name|snprintf
argument_list|(
name|rnamebuf
argument_list|,
sizeof|sizeof
name|rnamebuf
argument_list|,
literal|"%s"
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
block|}
else|else
name|snprintf
argument_list|(
name|rnamebuf
argument_list|,
sizeof|sizeof
name|rnamebuf
argument_list|,
literal|"Unknown UID %d"
argument_list|,
operator|(
name|int
operator|)
name|RealUid
argument_list|)
expr_stmt|;
name|RunAsUserName
operator|=
name|RealUserName
operator|=
name|rnamebuf
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG_MAIL
name|openlog
argument_list|(
literal|"vacation"
argument_list|,
name|LOG_PID
argument_list|,
name|LOG_MAIL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* LOG_MAIL */
name|openlog
argument_list|(
literal|"vacation"
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOG_MAIL */
name|opterr
operator|=
literal|0
expr_stmt|;
name|iflag
operator|=
name|FALSE
expr_stmt|;
name|emptysender
operator|=
name|FALSE
expr_stmt|;
name|exclude
operator|=
name|FALSE
expr_stmt|;
name|interval
operator|=
name|INTERVAL_UNDEF
expr_stmt|;
operator|*
name|From
operator|=
literal|'\0'
expr_stmt|;
define|#
directive|define
name|OPTIONS
value|"a:df:Iilm:r:s:t:Uxz"
while|while
condition|(
name|mfail
operator|==
literal|0
operator|&&
name|ufail
operator|==
literal|0
operator|&&
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|OPTIONS
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
operator|(
name|char
operator|)
name|ch
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* alias */
name|cur
operator|=
operator|(
name|ALIAS
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|u_int
operator|)
sizeof|sizeof
argument_list|(
name|ALIAS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
block|{
name|mfail
operator|++
expr_stmt|;
break|break;
block|}
name|cur
operator|->
name|name
operator|=
name|optarg
expr_stmt|;
name|cur
operator|->
name|next
operator|=
name|Names
expr_stmt|;
name|Names
operator|=
name|cur
expr_stmt|;
break|break;
if|#
directive|if
name|_FFR_DEBUG
case|case
literal|'d'
case|:
comment|/* debug mode */
name|msglog
operator|=
operator|&
name|debuglog
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* _FFR_DEBUG */
case|case
literal|'f'
case|:
comment|/* alternate database */
name|dbfilename
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* backward compatible */
case|case
literal|'i'
case|:
comment|/* init the database */
name|iflag
operator|=
name|TRUE
expr_stmt|;
break|break;
if|#
directive|if
name|_FFR_LISTDB
case|case
literal|'l'
case|:
name|lflag
operator|=
name|TRUE
expr_stmt|;
comment|/* list the database */
break|break;
endif|#
directive|endif
comment|/* _FFR_LISTDB */
case|case
literal|'m'
case|:
comment|/* alternate message file */
name|msgfilename
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|isascii
argument_list|(
operator|*
name|optarg
argument_list|)
operator|&&
name|isdigit
argument_list|(
operator|*
name|optarg
argument_list|)
condition|)
block|{
name|interval
operator|=
name|atol
argument_list|(
name|optarg
argument_list|)
operator|*
name|SECSPERDAY
expr_stmt|;
if|if
condition|(
name|interval
operator|<
literal|0
condition|)
name|ufail
operator|++
expr_stmt|;
block|}
else|else
name|interval
operator|=
name|ONLY_ONCE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* alternate sender name */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|From
argument_list|,
name|optarg
argument_list|,
sizeof|sizeof
name|From
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* SunOS: -t1d (default expire) */
break|break;
if|#
directive|if
name|_FFR_BLACKBOX
case|case
literal|'U'
case|:
comment|/* run as single user mode */
name|runasuser
operator|=
name|TRUE
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* _FFR_BLACKBOX */
case|case
literal|'x'
case|:
name|exclude
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|emptysender
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|ufail
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|mfail
operator|!=
literal|0
condition|)
block|{
name|msglog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"vacation: can't allocate memory for alias.\n"
argument_list|)
expr_stmt|;
name|EXITM
argument_list|(
name|EX_TEMPFAIL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ufail
operator|!=
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|iflag
operator|&&
if|#
directive|if
name|_FFR_LISTDB
operator|!
name|lflag
operator|&&
endif|#
directive|endif
comment|/* _FFR_LISTDB */
operator|!
name|exclude
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msglog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"vacation: no such user uid %u.\n"
argument_list|,
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|EXITM
argument_list|(
name|EX_NOUSER
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|pw
operator|->
name|pw_name
expr_stmt|;
name|user_info
operator|.
name|smdbu_id
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
name|user_info
operator|.
name|smdbu_group_id
operator|=
name|pw
operator|->
name|pw_gid
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|user_info
operator|.
name|smdbu_name
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
name|SMDB_MAX_USER_NAME_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|msglog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"vacation: no such directory %s.\n"
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|EXITM
argument_list|(
name|EX_NOINPUT
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|_FFR_BLACKBOX
elseif|else
if|if
condition|(
name|runasuser
condition|)
block|{
name|name
operator|=
operator|*
name|argv
expr_stmt|;
if|if
condition|(
name|dbfilename
operator|==
name|NULL
operator|||
name|msgfilename
operator|==
name|NULL
condition|)
block|{
name|msglog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"vacation: -U requires setting both -f and -m\n"
argument_list|)
expr_stmt|;
name|EXITM
argument_list|(
name|EX_NOINPUT
argument_list|)
expr_stmt|;
block|}
name|user_info
operator|.
name|smdbu_id
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
name|user_info
operator|.
name|smdbu_group_id
operator|=
name|pw
operator|->
name|pw_gid
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|user_info
operator|.
name|smdbu_name
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
name|SMDB_MAX_USER_NAME_LEN
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _FFR_BLACKBOX */
elseif|else
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
operator|*
name|argv
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msglog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"vacation: no such user %s.\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|EXITM
argument_list|(
name|EX_NOUSER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|pw
operator|->
name|pw_name
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|msglog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"vacation: no such directory %s.\n"
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|EXITM
argument_list|(
name|EX_NOINPUT
argument_list|)
expr_stmt|;
block|}
name|user_info
operator|.
name|smdbu_id
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
name|user_info
operator|.
name|smdbu_group_id
operator|=
name|pw
operator|->
name|pw_gid
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|user_info
operator|.
name|smdbu_name
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
name|SMDB_MAX_USER_NAME_LEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dbfilename
operator|==
name|NULL
condition|)
name|dbfilename
operator|=
name|VDB
expr_stmt|;
if|if
condition|(
name|msgfilename
operator|==
name|NULL
condition|)
name|msgfilename
operator|=
name|VMSG
expr_stmt|;
name|sff
operator|=
name|SFF_CREAT
expr_stmt|;
if|#
directive|if
name|_FFR_BLACKBOX
if|if
condition|(
name|getegid
argument_list|()
operator|!=
name|getgid
argument_list|()
condition|)
block|{
comment|/* Allow a set-group-id vacation binary */
name|RunAsGid
operator|=
name|user_info
operator|.
name|smdbu_group_id
operator|=
name|getegid
argument_list|()
expr_stmt|;
name|sff
operator||=
name|SFF_NOPATHCHECK
operator||
name|SFF_OPENASROOT
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _FFR_BLACKBOX */
name|result
operator|=
name|smdb_open_database
argument_list|(
operator|&
name|Db
argument_list|,
name|dbfilename
argument_list|,
name|O_CREAT
operator||
name|O_RDWR
operator||
operator|(
name|iflag
condition|?
name|O_TRUNC
else|:
literal|0
operator|)
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|,
name|sff
argument_list|,
name|SMDB_TYPE_DEFAULT
argument_list|,
operator|&
name|user_info
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SMDBE_OK
condition|)
block|{
name|msglog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"vacation: %s: %s\n"
argument_list|,
name|dbfilename
argument_list|,
name|errstring
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|EXITM
argument_list|(
name|EX_DATAERR
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|_FFR_LISTDB
if|if
condition|(
name|lflag
condition|)
block|{
specifier|static
name|void
name|listdb
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
name|listdb
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|Db
operator|->
name|smdb_close
argument_list|(
name|Db
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _FFR_LISTDB */
if|if
condition|(
name|interval
operator|!=
name|INTERVAL_UNDEF
condition|)
name|setinterval
argument_list|(
name|interval
argument_list|)
expr_stmt|;
if|if
condition|(
name|iflag
operator|&&
operator|!
name|exclude
condition|)
block|{
operator|(
name|void
operator|)
name|Db
operator|->
name|smdb_close
argument_list|(
name|Db
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exclude
condition|)
block|{
name|xclude
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Db
operator|->
name|smdb_close
argument_list|(
name|Db
argument_list|)
expr_stmt|;
name|EXITM
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cur
operator|=
operator|(
name|ALIAS
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|u_int
operator|)
sizeof|sizeof
argument_list|(
name|ALIAS
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msglog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"vacation: can't allocate memory for username.\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Db
operator|->
name|smdb_close
argument_list|(
name|Db
argument_list|)
expr_stmt|;
name|EXITM
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
name|cur
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|cur
operator|->
name|next
operator|=
name|Names
expr_stmt|;
name|Names
operator|=
name|cur
expr_stmt|;
name|result
operator|=
name|readheaders
argument_list|()
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|EX_OK
operator|&&
operator|!
name|recent
argument_list|()
condition|)
block|{
name|time_t
name|now
decl_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|setreply
argument_list|(
name|From
argument_list|,
name|now
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Db
operator|->
name|smdb_close
argument_list|(
name|Db
argument_list|)
expr_stmt|;
name|sendmessage
argument_list|(
name|name
argument_list|,
name|msgfilename
argument_list|,
name|emptysender
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|Db
operator|->
name|smdb_close
argument_list|(
name|Db
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|EX_NOUSER
condition|)
name|result
operator|=
name|EX_OK
expr_stmt|;
name|exit
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** EATMSG -- read stdin till EOF ** **	Parameters: **		none. ** **	Returns: **		nothing. ** */
end_comment

begin_function
specifier|static
name|void
name|eatmsg
parameter_list|()
block|{
comment|/* 	**  read the rest of the e-mail and ignore it to avoid problems 	**  with EPIPE in sendmail 	*/
while|while
condition|(
name|getc
argument_list|(
name|stdin
argument_list|)
operator|!=
name|EOF
condition|)
continue|continue;
block|}
end_function

begin_comment
comment|/* ** READHEADERS -- read mail headers ** **	Parameters: **		none. ** **	Returns: **		a exit code: NOUSER if no reply, OK if reply, * if error ** **	Side Effects: **		may exit(). ** */
end_comment

begin_function
name|int
name|readheaders
parameter_list|()
block|{
name|bool
name|tome
decl_stmt|,
name|cont
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|ALIAS
modifier|*
name|cur
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
specifier|extern
name|bool
name|junkmail
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|bool
name|nsearch
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
name|cont
operator|=
name|tome
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|stdin
argument_list|)
operator|&&
operator|*
name|buf
operator|!=
literal|'\n'
condition|)
block|{
switch|switch
condition|(
operator|*
name|buf
condition|)
block|{
case|case
literal|'F'
case|:
comment|/* "From " */
name|cont
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"From "
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bool
name|quoted
init|=
name|FALSE
decl_stmt|;
name|p
operator|=
name|buf
operator|+
literal|5
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
comment|/* escaped character */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|msglog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"vacation: badly formatted \"From \" line.\n"
argument_list|)
expr_stmt|;
name|EXITIT
argument_list|(
name|EX_DATAERR
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
condition|)
name|quoted
operator|=
operator|!
name|quoted
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\r'
operator|||
operator|*
name|p
operator|==
literal|'\n'
condition|)
break|break;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
operator|&&
operator|!
name|quoted
condition|)
break|break;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|quoted
condition|)
block|{
name|msglog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"vacation: badly formatted \"From \" line.\n"
argument_list|)
expr_stmt|;
name|EXITIT
argument_list|(
name|EX_DATAERR
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* ok since both strings have MAXLINE length */
if|if
condition|(
operator|*
name|From
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|From
argument_list|,
name|buf
operator|+
literal|5
argument_list|,
sizeof|sizeof
name|From
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buf
operator|+
literal|5
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|junkmail
argument_list|(
name|buf
operator|+
literal|5
argument_list|)
condition|)
name|EXITIT
argument_list|(
name|EX_NOUSER
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'P'
case|:
comment|/* "Precedence:" */
case|case
literal|'p'
case|:
name|cont
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|<=
literal|10
operator|||
name|strncasecmp
argument_list|(
name|buf
argument_list|,
literal|"Precedence"
argument_list|,
literal|10
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|buf
index|[
literal|10
index|]
operator|!=
literal|':'
operator|&&
name|buf
index|[
literal|10
index|]
operator|!=
literal|' '
operator|&&
name|buf
index|[
literal|10
index|]
operator|!=
literal|'\t'
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
while|while
condition|(
operator|*
operator|++
name|p
operator|!=
literal|'\0'
operator|&&
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|strncasecmp
argument_list|(
name|p
argument_list|,
literal|"junk"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|strncasecmp
argument_list|(
name|p
argument_list|,
literal|"bulk"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|strncasecmp
argument_list|(
name|p
argument_list|,
literal|"list"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|EXITIT
argument_list|(
name|EX_NOUSER
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* "Cc:" */
case|case
literal|'c'
case|:
if|if
condition|(
name|strncasecmp
argument_list|(
name|buf
argument_list|,
literal|"Cc:"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|cont
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|findme
goto|;
case|case
literal|'T'
case|:
comment|/* "To:" */
case|case
literal|'t'
case|:
if|if
condition|(
name|strncasecmp
argument_list|(
name|buf
argument_list|,
literal|"To:"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|cont
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|findme
goto|;
default|default:
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|buf
argument_list|)
operator|||
operator|!
name|isspace
argument_list|(
operator|*
name|buf
argument_list|)
operator|||
operator|!
name|cont
operator|||
name|tome
condition|)
block|{
name|cont
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|findme
label|:
for|for
control|(
name|cur
operator|=
name|Names
init|;
operator|!
name|tome
operator|&&
name|cur
operator|!=
name|NULL
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
name|tome
operator|=
name|nsearch
argument_list|(
name|cur
operator|->
name|name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|tome
condition|)
name|EXITIT
argument_list|(
name|EX_NOUSER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|From
operator|==
literal|'\0'
condition|)
block|{
name|msglog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"vacation: no initial \"From \" line.\n"
argument_list|)
expr_stmt|;
name|EXITIT
argument_list|(
name|EX_DATAERR
argument_list|)
expr_stmt|;
block|}
name|EXITIT
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** NSEARCH -- **	do a nice, slow, search of a string for a substring. ** **	Parameters: **		name -- name to search. **		str -- string in which to search. ** **	Returns: **		is name a substring of str? ** */
end_comment

begin_function
name|bool
name|nsearch
parameter_list|(
name|name
parameter_list|,
name|str
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|str
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|size_t
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|str
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
operator|++
name|s
control|)
block|{
comment|/* 		**  Check to make sure that the string matches and 		**  the previous character is not an alphanumeric and 		**  the next character after the match is not an alphanumeric. 		** 		**  This prevents matching "eric" to "derick" while still 		**  matching "eric" to "<eric+detail>". 		*/
if|if
condition|(
name|tolower
argument_list|(
operator|*
name|s
argument_list|)
operator|==
name|tolower
argument_list|(
operator|*
name|name
argument_list|)
operator|&&
name|strncasecmp
argument_list|(
name|name
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|s
operator|==
name|str
operator|||
operator|!
name|isascii
argument_list|(
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
argument_list|)
operator|||
operator|!
name|isalnum
argument_list|(
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|isascii
argument_list|(
operator|*
operator|(
name|s
operator|+
name|len
operator|)
argument_list|)
operator|||
operator|!
name|isalnum
argument_list|(
operator|*
operator|(
name|s
operator|+
name|len
operator|)
argument_list|)
operator|)
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_block

begin_comment
comment|/* ** JUNKMAIL -- **	read the header and return if automagic/junk/bulk/list mail ** **	Parameters: **		from -- sender address. ** **	Returns: **		is this some automated/junk/bulk/list mail? ** */
end_comment

begin_struct
struct|struct
name|ignore
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|ignore
name|IGNORE_T
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MAX_USER_LEN
value|256
end_define

begin_comment
comment|/* maximum length of local part (sender) */
end_comment

begin_comment
comment|/* delimiters for the local part of an address */
end_comment

begin_define
define|#
directive|define
name|isdelim
parameter_list|(
name|c
parameter_list|)
value|((c) == '%' || (c) == '@' || (c) == '+')
end_define

begin_function
name|bool
name|junkmail
parameter_list|(
name|from
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|;
block|{
name|bool
name|quot
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|IGNORE_T
modifier|*
name|cur
decl_stmt|;
name|char
name|sender
index|[
name|MAX_USER_LEN
index|]
decl_stmt|;
specifier|static
name|IGNORE_T
name|ignore
index|[]
init|=
block|{
block|{
literal|"postmaster"
block|,
literal|10
block|}
block|,
block|{
literal|"uucp"
block|,
literal|4
block|}
block|,
block|{
literal|"mailer-daemon"
block|,
literal|13
block|}
block|,
block|{
literal|"mailer"
block|,
literal|6
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|IGNORE_T
name|ignorepost
index|[]
init|=
block|{
block|{
literal|"-request"
block|,
literal|8
block|}
block|,
block|{
literal|"-relay"
block|,
literal|6
block|}
block|,
block|{
literal|"-owner"
block|,
literal|6
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|IGNORE_T
name|ignorepre
index|[]
init|=
block|{
block|{
literal|"owner-"
block|,
literal|6
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
comment|/* 	**  This is mildly amusing, and I'm not positive it's right; trying 	**  to find the "real" name of the sender, assuming that addresses 	**  will be some variant of: 	** 	**  From site!site!SENDER%site.domain%site.domain@site.domain 	*/
name|quot
operator|=
name|FALSE
expr_stmt|;
name|e
operator|=
name|from
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|e
operator|!=
literal|'\0'
operator|&&
operator|(
name|quot
operator|||
operator|!
name|isdelim
argument_list|(
operator|*
name|e
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|e
operator|==
literal|'"'
condition|)
block|{
name|quot
operator|=
operator|!
name|quot
expr_stmt|;
operator|++
name|e
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|e
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
operator|++
name|e
operator|)
operator|==
literal|'\0'
condition|)
block|{
comment|/* '\\' at end of string? */
break|break;
block|}
if|if
condition|(
name|len
operator|<
name|MAX_USER_LEN
condition|)
name|sender
index|[
name|len
operator|++
index|]
operator|=
operator|*
name|e
expr_stmt|;
operator|++
name|e
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|e
operator|==
literal|'!'
operator|&&
operator|!
name|quot
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
name|sender
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|<
name|MAX_USER_LEN
condition|)
name|sender
index|[
name|len
operator|++
index|]
operator|=
operator|*
name|e
expr_stmt|;
operator|++
name|e
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<
name|MAX_USER_LEN
condition|)
name|sender
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|sender
index|[
name|MAX_USER_LEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return
name|FALSE
return|;
if|#
directive|if
literal|0
block|if (quot) 		return FALSE;
comment|/* syntax error... */
endif|#
directive|endif
comment|/* 0 */
comment|/* test prefixes */
for|for
control|(
name|cur
operator|=
name|ignorepre
init|;
name|cur
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|cur
control|)
block|{
if|if
condition|(
name|len
operator|>=
name|cur
operator|->
name|len
operator|&&
name|strncasecmp
argument_list|(
name|cur
operator|->
name|name
argument_list|,
name|sender
argument_list|,
name|cur
operator|->
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
block|}
comment|/* 	**  If the name is truncated, don't test the rest. 	**	We could extract the "tail" of the sender address and 	**	compare it it ignorepost, however, it seems not worth 	**	the effort. 	**	The address surely can't match any entry in ignore[] 	**	(as long as all of them are shorter than MAX_USER_LEN). 	*/
if|if
condition|(
name|len
operator|>
name|MAX_USER_LEN
condition|)
return|return
name|FALSE
return|;
comment|/* test full local parts */
for|for
control|(
name|cur
operator|=
name|ignore
init|;
name|cur
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|cur
control|)
block|{
if|if
condition|(
name|len
operator|==
name|cur
operator|->
name|len
operator|&&
name|strncasecmp
argument_list|(
name|cur
operator|->
name|name
argument_list|,
name|sender
argument_list|,
name|cur
operator|->
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
block|}
comment|/* test postfixes */
for|for
control|(
name|cur
operator|=
name|ignorepost
init|;
name|cur
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|cur
control|)
block|{
if|if
condition|(
name|len
operator|>=
name|cur
operator|->
name|len
operator|&&
name|strncasecmp
argument_list|(
name|cur
operator|->
name|name
argument_list|,
name|e
operator|-
name|cur
operator|->
name|len
operator|-
literal|1
argument_list|,
name|cur
operator|->
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_define
define|#
directive|define
name|VIT
value|"__VACATION__INTERVAL__TIMER__"
end_define

begin_comment
comment|/* ** RECENT -- **	find out if user has gotten a vacation message recently. ** **	Parameters: **		none. ** **	Returns: **		TRUE iff user has gotten a vacation message recently. ** */
end_comment

begin_function
name|bool
name|recent
parameter_list|()
block|{
name|SMDB_DBENT
name|key
decl_stmt|,
name|data
decl_stmt|;
name|time_t
name|then
decl_stmt|,
name|next
decl_stmt|;
name|bool
name|trydomain
init|=
name|FALSE
decl_stmt|;
name|int
name|st
decl_stmt|;
name|char
modifier|*
name|domain
decl_stmt|;
name|memset
argument_list|(
operator|&
name|key
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|key
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
comment|/* get interval time */
name|key
operator|.
name|data
operator|=
name|VIT
expr_stmt|;
name|key
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|VIT
argument_list|)
expr_stmt|;
name|st
operator|=
name|Db
operator|->
name|smdb_get
argument_list|(
name|Db
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|!=
name|SMDBE_OK
condition|)
name|next
operator|=
name|SECSPERDAY
operator|*
name|DAYSPERWEEK
expr_stmt|;
else|else
name|memmove
argument_list|(
operator|&
name|next
argument_list|,
name|data
operator|.
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
comment|/* get record for this address */
name|key
operator|.
name|data
operator|=
name|From
expr_stmt|;
name|key
operator|.
name|size
operator|=
name|strlen
argument_list|(
name|From
argument_list|)
expr_stmt|;
do|do
block|{
name|st
operator|=
name|Db
operator|->
name|smdb_get
argument_list|(
name|Db
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
name|SMDBE_OK
condition|)
block|{
name|memmove
argument_list|(
operator|&
name|then
argument_list|,
name|data
operator|.
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|then
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|ONLY_ONCE
operator|||
name|then
operator|==
name|ONLY_ONCE
operator|||
name|then
operator|+
name|next
operator|>
name|time
argument_list|(
name|NULL
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
if|if
condition|(
operator|(
name|trydomain
operator|=
operator|!
name|trydomain
operator|)
operator|&&
operator|(
name|domain
operator|=
name|strchr
argument_list|(
name|From
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|key
operator|.
name|data
operator|=
name|domain
expr_stmt|;
name|key
operator|.
name|size
operator|=
name|strlen
argument_list|(
name|domain
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|trydomain
condition|)
do|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* ** SETINTERVAL -- **	store the reply interval ** **	Parameters: **		interval -- time interval for replies. ** **	Returns: **		nothing. ** **	Side Effects: **		stores the reply interval in database. */
end_comment

begin_function
name|void
name|setinterval
parameter_list|(
name|interval
parameter_list|)
name|time_t
name|interval
decl_stmt|;
block|{
name|SMDB_DBENT
name|key
decl_stmt|,
name|data
decl_stmt|;
name|memset
argument_list|(
operator|&
name|key
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|key
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
name|key
operator|.
name|data
operator|=
name|VIT
expr_stmt|;
name|key
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|VIT
argument_list|)
expr_stmt|;
name|data
operator|.
name|data
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|interval
expr_stmt|;
name|data
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|interval
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
name|Db
operator|->
name|smdb_put
argument_list|)
argument_list|(
name|Db
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** SETREPLY -- **	store that this user knows about the vacation. ** **	Parameters: **		from -- sender address. **		when -- last reply time. ** **	Returns: **		nothing. ** **	Side Effects: **		stores user/time in database. */
end_comment

begin_function
name|void
name|setreply
parameter_list|(
name|from
parameter_list|,
name|when
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|;
name|time_t
name|when
decl_stmt|;
block|{
name|SMDB_DBENT
name|key
decl_stmt|,
name|data
decl_stmt|;
name|memset
argument_list|(
operator|&
name|key
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|key
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
name|key
operator|.
name|data
operator|=
name|from
expr_stmt|;
name|key
operator|.
name|size
operator|=
name|strlen
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|data
operator|.
name|data
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|when
expr_stmt|;
name|data
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|when
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
name|Db
operator|->
name|smdb_put
argument_list|)
argument_list|(
name|Db
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** XCLUDE -- **	add users to vacation db so they don't get a reply. ** **	Parameters: **		f -- file pointer with list of address to exclude ** **	Returns: **		nothing. ** **	Side Effects: **		stores users in database. */
end_comment

begin_function
name|void
name|xclude
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|f
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|setreply
argument_list|(
name|buf
argument_list|,
name|ONLY_ONCE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** SENDMESSAGE -- **	exec sendmail to send the vacation file to sender ** **	Parameters: **		myname -- user name. **		msgfn -- name of file with vacation message. **		emptysender -- use<> as sender address? ** **	Returns: **		nothing. ** **	Side Effects: **		sends vacation reply. */
end_comment

begin_function
name|void
name|sendmessage
parameter_list|(
name|myname
parameter_list|,
name|msgfn
parameter_list|,
name|emptysender
parameter_list|)
name|char
modifier|*
name|myname
decl_stmt|;
name|char
modifier|*
name|msgfn
decl_stmt|;
name|bool
name|emptysender
decl_stmt|;
block|{
name|FILE
modifier|*
name|mfp
decl_stmt|,
modifier|*
name|sfp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|pvect
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|pv
index|[
literal|8
index|]
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|mfp
operator|=
name|fopen
argument_list|(
name|msgfn
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|msgfn
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|msglog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"vacation: no %s file.\n"
argument_list|,
name|msgfn
argument_list|)
expr_stmt|;
else|else
name|msglog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"vacation: no ~%s/%s file.\n"
argument_list|,
name|myname
argument_list|,
name|msgfn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_NOINPUT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pipe
argument_list|(
name|pvect
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msglog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"vacation: pipe: %s"
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
name|pv
index|[
literal|0
index|]
operator|=
literal|"sendmail"
expr_stmt|;
name|pv
index|[
literal|1
index|]
operator|=
literal|"-oi"
expr_stmt|;
name|pv
index|[
literal|2
index|]
operator|=
literal|"-f"
expr_stmt|;
if|if
condition|(
name|emptysender
condition|)
name|pv
index|[
literal|3
index|]
operator|=
literal|"<>"
expr_stmt|;
else|else
name|pv
index|[
literal|3
index|]
operator|=
name|myname
expr_stmt|;
name|pv
index|[
literal|4
index|]
operator|=
literal|"--"
expr_stmt|;
name|pv
index|[
literal|5
index|]
operator|=
name|From
expr_stmt|;
name|pv
index|[
literal|6
index|]
operator|=
name|NULL
expr_stmt|;
name|i
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|msglog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"vacation: fork: %s"
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|pvect
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|pvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|pvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|mfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|execv
argument_list|(
name|_PATH_SENDMAIL
argument_list|,
name|pv
argument_list|)
expr_stmt|;
name|msglog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"vacation: can't exec %s: %s"
argument_list|,
name|_PATH_SENDMAIL
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
comment|/* check return status of the following calls? XXX */
operator|(
name|void
operator|)
name|close
argument_list|(
name|pvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sfp
operator|=
name|fdopen
argument_list|(
name|pvect
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|sfp
argument_list|,
literal|"To: %s\n"
argument_list|,
name|From
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|sfp
argument_list|,
literal|"Auto-Submitted: auto-generated\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|mfp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|buf
argument_list|,
name|sfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|mfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|sfp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|mfp
argument_list|)
expr_stmt|;
name|msglog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"vacation: can't open pipe to sendmail"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|usage
parameter_list|()
block|{
name|msglog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"uid %u: usage: vacation [-a alias]%s [-f db] [-i]%s [-m msg] [-r interval] [-s sender] [-t time]%s [-x] [-z] login\n"
argument_list|,
name|getuid
argument_list|()
argument_list|,
if|#
directive|if
name|_FFR_DEBUG
literal|" [-d]"
argument_list|,
else|#
directive|else
comment|/* _FFR_DEBUG */
literal|""
argument_list|,
endif|#
directive|endif
comment|/* _FFR_DEBUG */
if|#
directive|if
name|_FFR_LISTDB
literal|" [-l]"
argument_list|,
else|#
directive|else
comment|/* _FFR_LISTDB */
literal|""
argument_list|,
endif|#
directive|endif
comment|/* _FFR_LISTDB */
if|#
directive|if
name|_FFR_BLACKBOX
literal|" [-U]"
else|#
directive|else
comment|/* _FFR_BLACKBOX */
literal|""
endif|#
directive|endif
comment|/* _FFR_BLACKBOX */
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|_FFR_LISTDB
end_if

begin_comment
comment|/* ** LISTDB -- list the contents of the vacation database ** **	Parameters: **		none. ** **	Returns: **		nothing. */
end_comment

begin_function
specifier|static
name|void
name|listdb
parameter_list|()
block|{
name|int
name|result
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|SMDB_CURSOR
modifier|*
name|cursor
init|=
name|NULL
decl_stmt|;
name|SMDB_DBENT
name|db_key
decl_stmt|,
name|db_value
decl_stmt|;
name|memset
argument_list|(
operator|&
name|db_key
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|db_key
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|db_value
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|db_value
argument_list|)
expr_stmt|;
name|result
operator|=
name|Db
operator|->
name|smdb_cursor
argument_list|(
name|Db
argument_list|,
operator|&
name|cursor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SMDBE_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vacation: set cursor: %s\n"
argument_list|,
name|errstring
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|result
operator|=
name|cursor
operator|->
name|smdbc_get
argument_list|(
name|cursor
argument_list|,
operator|&
name|db_key
argument_list|,
operator|&
name|db_value
argument_list|,
name|SMDB_CURSOR_GET_NEXT
argument_list|)
operator|)
operator|==
name|SMDBE_OK
condition|)
block|{
comment|/* skip magic VIT entry */
if|if
condition|(
operator|(
name|int
operator|)
name|db_key
operator|.
name|size
operator|-
literal|1
operator|==
name|strlen
argument_list|(
name|VIT
argument_list|)
operator|&&
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|db_key
operator|.
name|data
argument_list|,
name|VIT
argument_list|,
operator|(
name|int
operator|)
name|db_key
operator|.
name|size
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* skip bogus values */
if|if
condition|(
name|db_value
operator|.
name|size
operator|!=
sizeof|sizeof
name|t
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vacation: %.*s invalid time stamp\n"
argument_list|,
operator|(
name|int
operator|)
name|db_key
operator|.
name|size
argument_list|,
operator|(
name|char
operator|*
operator|)
name|db_key
operator|.
name|data
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|memcpy
argument_list|(
operator|&
name|t
argument_list|,
name|db_value
operator|.
name|data
argument_list|,
sizeof|sizeof
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_key
operator|.
name|size
operator|>
literal|40
condition|)
name|db_key
operator|.
name|size
operator|=
literal|40
expr_stmt|;
name|printf
argument_list|(
literal|"%-40.*s %-10s"
argument_list|,
operator|(
name|int
operator|)
name|db_key
operator|.
name|size
argument_list|,
operator|(
name|char
operator|*
operator|)
name|db_key
operator|.
name|data
argument_list|,
name|ctime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|db_key
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|db_key
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|db_value
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|db_value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|SMDBE_OK
operator|&&
name|result
operator|!=
name|SMDBE_LAST_ENTRY
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vacation: get value at cursor: %s\n"
argument_list|,
name|errstring
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursor
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|cursor
operator|->
name|smdbc_close
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
operator|(
name|void
operator|)
name|cursor
operator|->
name|smdbc_close
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_LISTDB */
end_comment

begin_if
if|#
directive|if
name|_FFR_DEBUG
end_if

begin_comment
comment|/* ** DEBUGLOG -- write message to standard error ** **	Append a message to the standard error for the convenience of **	end-users debugging without access to the syslog messages. ** **	Parameters: **		i -- syslog log level **		fmt -- string format ** **	Returns: **		nothing. */
end_comment

begin_comment
comment|/*VARARGS2*/
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|debuglog
parameter_list|(
name|int
name|i
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
comment|/* __STDC__ */
function|debuglog
parameter_list|(
name|i
parameter_list|,
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
function|va_dcl
endif|#
directive|endif
comment|/* __STDC__ */
block|{
name|VA_LOCAL_DECL
name|VA_START
argument_list|(
name|fmt
argument_list|)
decl_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_END
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_DEBUG */
end_comment

begin_comment
comment|/*VARARGS1*/
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|message
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
comment|/* __STDC__ */
function|message
parameter_list|(
name|msg
parameter_list|,
name|va_alist
parameter_list|)
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
function|va_dcl
endif|#
directive|endif
comment|/* __STDC__ */
block|{
specifier|const
name|char
modifier|*
name|m
decl_stmt|;
name|VA_LOCAL_DECL
name|m
init|=
name|msg
decl_stmt|;
if|if
condition|(
name|isascii
argument_list|(
name|m
index|[
literal|0
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|m
index|[
literal|0
index|]
argument_list|)
operator|&&
name|isascii
argument_list|(
name|m
index|[
literal|1
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|m
index|[
literal|1
index|]
argument_list|)
operator|&&
name|isascii
argument_list|(
name|m
index|[
literal|2
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|m
index|[
literal|2
index|]
argument_list|)
operator|&&
name|m
index|[
literal|3
index|]
operator|==
literal|' '
condition|)
name|m
operator|+=
literal|4
expr_stmt|;
name|VA_START
argument_list|(
name|msg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|m
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_END
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*VARARGS1*/
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|syserr
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
comment|/* __STDC__ */
function|syserr
parameter_list|(
name|msg
parameter_list|,
name|va_alist
parameter_list|)
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
function|va_dcl
endif|#
directive|endif
comment|/* __STDC__ */
block|{
specifier|const
name|char
modifier|*
name|m
decl_stmt|;
name|VA_LOCAL_DECL
name|m
init|=
name|msg
decl_stmt|;
if|if
condition|(
name|isascii
argument_list|(
name|m
index|[
literal|0
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|m
index|[
literal|0
index|]
argument_list|)
operator|&&
name|isascii
argument_list|(
name|m
index|[
literal|1
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|m
index|[
literal|1
index|]
argument_list|)
operator|&&
name|isascii
argument_list|(
name|m
index|[
literal|2
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|m
index|[
literal|2
index|]
argument_list|)
operator|&&
name|m
index|[
literal|3
index|]
operator|==
literal|' '
condition|)
name|m
operator|+=
literal|4
expr_stmt|;
name|VA_START
argument_list|(
name|msg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|m
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_END
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dumpfd
parameter_list|(
name|fd
parameter_list|,
name|printclosed
parameter_list|,
name|logit
parameter_list|)
name|int
name|fd
decl_stmt|;
name|bool
name|printclosed
decl_stmt|;
name|bool
name|logit
decl_stmt|;
block|{
return|return;
block|}
end_function

end_unit

