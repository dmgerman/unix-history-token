begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Copyright (c) 1999-2001 Sendmail, Inc. and its suppliers.  *	All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_include
include|#
directive|include
file|<sm/gen.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: engine.c,v 8.102 2001/12/13 17:10:00 ca Exp $"
argument_list|)
end_macro

begin_include
include|#
directive|include
file|"libmilter.h"
end_include

begin_if
if|#
directive|if
name|NETINET
operator|||
name|NETINET6
end_if

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NETINET || NETINET6 */
end_comment

begin_comment
comment|/* generic argument for functions in the command table */
end_comment

begin_struct
struct|struct
name|arg_struct
block|{
name|size_t
name|a_len
decl_stmt|;
comment|/* length of buffer */
name|char
modifier|*
name|a_buf
decl_stmt|;
comment|/* argument string */
name|int
name|a_idx
decl_stmt|;
comment|/* index for macro array */
name|SMFICTX_PTR
name|a_ctx
decl_stmt|;
comment|/* context */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|arg_struct
name|genarg
typedef|;
end_typedef

begin_comment
comment|/* structure for commands received from MTA */
end_comment

begin_struct
struct|struct
name|cmdfct_t
block|{
name|char
name|cm_cmd
decl_stmt|;
comment|/* command */
name|int
name|cm_argt
decl_stmt|;
comment|/* type of arguments expected */
name|int
name|cm_next
decl_stmt|;
comment|/* next state */
name|int
name|cm_todo
decl_stmt|;
comment|/* what to do next */
name|int
name|cm_macros
decl_stmt|;
comment|/* index for macros */
name|int
argument_list|(
argument|*cm_fct
argument_list|)
name|__P
argument_list|(
operator|(
name|genarg
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* function to execute */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|cmdfct_t
name|cmdfct
typedef|;
end_typedef

begin_comment
comment|/* possible values for cm_argt */
end_comment

begin_define
define|#
directive|define
name|CM_ARG0
value|0
end_define

begin_comment
comment|/* no args */
end_comment

begin_define
define|#
directive|define
name|CM_ARG1
value|1
end_define

begin_comment
comment|/* one arg (string) */
end_comment

begin_define
define|#
directive|define
name|CM_ARG2
value|2
end_define

begin_comment
comment|/* two args (strings) */
end_comment

begin_define
define|#
directive|define
name|CM_ARGA
value|4
end_define

begin_comment
comment|/* one string and _SOCK_ADDR */
end_comment

begin_define
define|#
directive|define
name|CM_ARGO
value|5
end_define

begin_comment
comment|/* two integers */
end_comment

begin_define
define|#
directive|define
name|CM_ARGV
value|8
end_define

begin_comment
comment|/* \0 separated list of args, NULL-terminated */
end_comment

begin_define
define|#
directive|define
name|CM_ARGN
value|9
end_define

begin_comment
comment|/* \0 separated list of args (strings) */
end_comment

begin_comment
comment|/* possible values for cm_todo */
end_comment

begin_define
define|#
directive|define
name|CT_CONT
value|0x0000
end_define

begin_comment
comment|/* continue reading commands */
end_comment

begin_define
define|#
directive|define
name|CT_IGNO
value|0x0001
end_define

begin_comment
comment|/* continue even when error  */
end_comment

begin_comment
comment|/* not needed right now, done via return code instead */
end_comment

begin_define
define|#
directive|define
name|CT_KEEP
value|0x0004
end_define

begin_comment
comment|/* keep buffer (contains symbols) */
end_comment

begin_define
define|#
directive|define
name|CT_END
value|0x0008
end_define

begin_comment
comment|/* start replying */
end_comment

begin_comment
comment|/* index in macro array: macros only for these commands */
end_comment

begin_define
define|#
directive|define
name|CI_NONE
value|(-1)
end_define

begin_define
define|#
directive|define
name|CI_CONN
value|0
end_define

begin_define
define|#
directive|define
name|CI_HELO
value|1
end_define

begin_define
define|#
directive|define
name|CI_MAIL
value|2
end_define

begin_define
define|#
directive|define
name|CI_RCPT
value|3
end_define

begin_if
if|#
directive|if
name|CI_RCPT
operator|>=
name|MAX_MACROS_ENTRIES
end_if

begin_label
name|ERROR
label|:
end_label

begin_do
do|do
name|not
name|compile
name|with
name|CI_RCPT
operator|>=
name|MAX_MACROS_ENTRIES
endif|#
directive|endif
comment|/* function prototypes */
specifier|static
name|int
name|st_abortfct
name|__P
argument_list|(
operator|(
name|genarg
operator|*
operator|)
argument_list|)
expr_stmt|;
do|static int	st_macros __P((genarg *
end_do

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|static
name|int
name|st_optionneg
name|__P
argument_list|(
operator|(
name|genarg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|st_bodychunk
name|__P
argument_list|(
operator|(
name|genarg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|st_connectinfo
name|__P
argument_list|(
operator|(
name|genarg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|st_bodyend
name|__P
argument_list|(
operator|(
name|genarg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|st_helo
name|__P
argument_list|(
operator|(
name|genarg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|st_header
name|__P
argument_list|(
operator|(
name|genarg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|st_sender
name|__P
argument_list|(
operator|(
name|genarg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|st_rcpt
name|__P
argument_list|(
operator|(
name|genarg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|st_eoh
name|__P
argument_list|(
operator|(
name|genarg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|st_quit
name|__P
argument_list|(
operator|(
name|genarg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sendreply
name|__P
argument_list|(
operator|(
name|sfsistat
operator|,
name|socket_t
operator|,
expr|struct
name|timeval
operator|*
operator|,
name|SMFICTX_PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fix_stm
name|__P
argument_list|(
operator|(
name|SMFICTX_PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|trans_ok
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|dec_argv
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dec_arg2
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|size_t
operator|,
name|char
operator|*
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* states */
end_comment

begin_define
define|#
directive|define
name|ST_NONE
value|(-1)
end_define

begin_define
define|#
directive|define
name|ST_INIT
value|0
end_define

begin_comment
comment|/* initial state */
end_comment

begin_define
define|#
directive|define
name|ST_OPTS
value|1
end_define

begin_comment
comment|/* option negotiation */
end_comment

begin_define
define|#
directive|define
name|ST_CONN
value|2
end_define

begin_comment
comment|/* connection info */
end_comment

begin_define
define|#
directive|define
name|ST_HELO
value|3
end_define

begin_comment
comment|/* helo */
end_comment

begin_define
define|#
directive|define
name|ST_MAIL
value|4
end_define

begin_comment
comment|/* mail from */
end_comment

begin_define
define|#
directive|define
name|ST_RCPT
value|5
end_define

begin_comment
comment|/* rcpt to */
end_comment

begin_define
define|#
directive|define
name|ST_HDRS
value|6
end_define

begin_comment
comment|/* headers */
end_comment

begin_define
define|#
directive|define
name|ST_EOHS
value|7
end_define

begin_comment
comment|/* end of headers */
end_comment

begin_define
define|#
directive|define
name|ST_BODY
value|8
end_define

begin_comment
comment|/* body */
end_comment

begin_define
define|#
directive|define
name|ST_ENDM
value|9
end_define

begin_comment
comment|/* end of message */
end_comment

begin_define
define|#
directive|define
name|ST_QUIT
value|10
end_define

begin_comment
comment|/* quit */
end_comment

begin_define
define|#
directive|define
name|ST_ABRT
value|11
end_define

begin_comment
comment|/* abort */
end_comment

begin_define
define|#
directive|define
name|ST_LAST
value|ST_ABRT
end_define

begin_define
define|#
directive|define
name|ST_SKIP
value|15
end_define

begin_comment
comment|/* not a state but required for the state table */
end_comment

begin_comment
comment|/* in a mail transaction? must be before eom according to spec. */
end_comment

begin_define
define|#
directive|define
name|ST_IN_MAIL
parameter_list|(
name|st
parameter_list|)
value|((st)>= ST_MAIL&& (st)< ST_ENDM)
end_define

begin_comment
comment|/* **  set of next states **  each state (ST_*) corresponds to bit in an int value (1<< state) **  each state has a set of allowed transitions ('or' of bits of states) **  so a state transition is valid if the mask of the next state **  is set in the NX_* value **  this function is coded in trans_ok(), see below. */
end_comment

begin_define
define|#
directive|define
name|MASK
parameter_list|(
name|x
parameter_list|)
value|(0x0001<< (x))
end_define

begin_comment
comment|/* generate a bit "mask" for a state */
end_comment

begin_define
define|#
directive|define
name|NX_INIT
value|(MASK(ST_OPTS))
end_define

begin_define
define|#
directive|define
name|NX_OPTS
value|(MASK(ST_CONN))
end_define

begin_define
define|#
directive|define
name|NX_CONN
value|(MASK(ST_HELO) | MASK(ST_MAIL))
end_define

begin_define
define|#
directive|define
name|NX_HELO
value|(MASK(ST_HELO) | MASK(ST_MAIL))
end_define

begin_define
define|#
directive|define
name|NX_MAIL
value|(MASK(ST_RCPT) | MASK(ST_ABRT))
end_define

begin_define
define|#
directive|define
name|NX_RCPT
value|(MASK(ST_HDRS) | MASK(ST_EOHS) | \ 		 MASK(ST_BODY) | MASK(ST_ENDM) | \ 		 MASK(ST_RCPT) | MASK(ST_ABRT))
end_define

begin_define
define|#
directive|define
name|NX_HDRS
value|(MASK(ST_EOHS) | MASK(ST_HDRS) | MASK(ST_ABRT))
end_define

begin_define
define|#
directive|define
name|NX_EOHS
value|(MASK(ST_BODY) | MASK(ST_ENDM) | MASK(ST_ABRT))
end_define

begin_define
define|#
directive|define
name|NX_BODY
value|(MASK(ST_ENDM) | MASK(ST_BODY) | MASK(ST_ABRT))
end_define

begin_define
define|#
directive|define
name|NX_ENDM
value|(MASK(ST_QUIT) | MASK(ST_MAIL))
end_define

begin_define
define|#
directive|define
name|NX_QUIT
value|0
end_define

begin_define
define|#
directive|define
name|NX_ABRT
value|0
end_define

begin_define
define|#
directive|define
name|NX_SKIP
value|MASK(ST_SKIP)
end_define

begin_decl_stmt
specifier|static
name|int
name|next_states
index|[]
init|=
block|{
name|NX_INIT
block|,
name|NX_OPTS
block|,
name|NX_CONN
block|,
name|NX_HELO
block|,
name|NX_MAIL
block|,
name|NX_RCPT
block|,
name|NX_HDRS
block|,
name|NX_EOHS
block|,
name|NX_BODY
block|,
name|NX_ENDM
block|,
name|NX_QUIT
block|,
name|NX_ABRT
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* commands received by milter */
end_comment

begin_decl_stmt
specifier|static
name|cmdfct
name|cmds
index|[]
init|=
block|{
block|{
name|SMFIC_ABORT
block|,
name|CM_ARG0
block|,
name|ST_ABRT
block|,
name|CT_CONT
block|,
name|CI_NONE
block|,
name|st_abortfct
block|}
block|,
block|{
name|SMFIC_MACRO
block|,
name|CM_ARGV
block|,
name|ST_NONE
block|,
name|CT_KEEP
block|,
name|CI_NONE
block|,
name|st_macros
block|}
block|,
block|{
name|SMFIC_BODY
block|,
name|CM_ARG1
block|,
name|ST_BODY
block|,
name|CT_CONT
block|,
name|CI_NONE
block|,
name|st_bodychunk
block|}
block|,
block|{
name|SMFIC_CONNECT
block|,
name|CM_ARG2
block|,
name|ST_CONN
block|,
name|CT_CONT
block|,
name|CI_CONN
block|,
name|st_connectinfo
block|}
block|,
block|{
name|SMFIC_BODYEOB
block|,
name|CM_ARG1
block|,
name|ST_ENDM
block|,
name|CT_CONT
block|,
name|CI_NONE
block|,
name|st_bodyend
block|}
block|,
block|{
name|SMFIC_HELO
block|,
name|CM_ARG1
block|,
name|ST_HELO
block|,
name|CT_CONT
block|,
name|CI_HELO
block|,
name|st_helo
block|}
block|,
block|{
name|SMFIC_HEADER
block|,
name|CM_ARG2
block|,
name|ST_HDRS
block|,
name|CT_CONT
block|,
name|CI_NONE
block|,
name|st_header
block|}
block|,
block|{
name|SMFIC_MAIL
block|,
name|CM_ARGV
block|,
name|ST_MAIL
block|,
name|CT_CONT
block|,
name|CI_MAIL
block|,
name|st_sender
block|}
block|,
block|{
name|SMFIC_OPTNEG
block|,
name|CM_ARGO
block|,
name|ST_OPTS
block|,
name|CT_CONT
block|,
name|CI_NONE
block|,
name|st_optionneg
block|}
block|,
block|{
name|SMFIC_EOH
block|,
name|CM_ARG0
block|,
name|ST_EOHS
block|,
name|CT_CONT
block|,
name|CI_NONE
block|,
name|st_eoh
block|}
block|,
block|{
name|SMFIC_QUIT
block|,
name|CM_ARG0
block|,
name|ST_QUIT
block|,
name|CT_END
block|,
name|CI_NONE
block|,
name|st_quit
block|}
block|,
block|{
name|SMFIC_RCPT
block|,
name|CM_ARGV
block|,
name|ST_RCPT
block|,
name|CT_IGNO
block|,
name|CI_RCPT
block|,
name|st_rcpt
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* additional (internal) reply codes */
end_comment

begin_define
define|#
directive|define
name|_SMFIS_KEEP
value|20
end_define

begin_define
define|#
directive|define
name|_SMFIS_ABORT
value|21
end_define

begin_define
define|#
directive|define
name|_SMFIS_OPTIONS
value|22
end_define

begin_define
define|#
directive|define
name|_SMFIS_NOREPLY
value|23
end_define

begin_define
define|#
directive|define
name|_SMFIS_FAIL
value|(-1)
end_define

begin_define
define|#
directive|define
name|_SMFIS_NONE
value|(-2)
end_define

begin_comment
comment|/* **  MI_ENGINE -- receive commands and process them ** **	Parameters: **		ctx -- context structure ** **	Returns: **		MI_FAILURE/MI_SUCCESS */
end_comment

begin_function
name|int
name|mi_engine
parameter_list|(
name|ctx
parameter_list|)
name|SMFICTX_PTR
name|ctx
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|socket_t
name|sd
decl_stmt|;
name|int
name|ret
init|=
name|MI_SUCCESS
decl_stmt|;
name|int
name|ncmds
init|=
sizeof|sizeof
argument_list|(
name|cmds
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|cmdfct
argument_list|)
decl_stmt|;
name|int
name|curstate
init|=
name|ST_INIT
decl_stmt|;
name|int
name|newstate
decl_stmt|;
name|bool
name|call_abort
decl_stmt|;
name|sfsistat
name|r
decl_stmt|;
name|char
name|cmd
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|genarg
name|arg
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
name|int
argument_list|(
argument|*f
argument_list|)
name|__P
argument_list|(
operator|(
name|genarg
operator|*
operator|)
argument_list|)
expr_stmt|;
name|sfsistat
argument_list|(
argument|*fi_abort
argument_list|)
name|__P
argument_list|(
operator|(
name|SMFICTX
operator|*
operator|)
argument_list|)
expr_stmt|;
name|sfsistat
argument_list|(
argument|*fi_close
argument_list|)
name|__P
argument_list|(
operator|(
name|SMFICTX
operator|*
operator|)
argument_list|)
expr_stmt|;
name|arg
operator|.
name|a_ctx
operator|=
name|ctx
expr_stmt|;
name|sd
operator|=
name|ctx
operator|->
name|ctx_sd
expr_stmt|;
name|fi_abort
operator|=
name|ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_abort
expr_stmt|;
name|mi_clr_macros
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fix_stm
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|r
operator|=
name|_SMFIS_NONE
expr_stmt|;
do|do
block|{
comment|/* call abort only if in a mail transaction */
name|call_abort
operator|=
name|ST_IN_MAIL
argument_list|(
name|curstate
argument_list|)
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
name|ctx
operator|->
name|ctx_timeout
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mi_stop
argument_list|()
operator|==
name|MILTER_ABRT
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|ctx_dbg
operator|>
literal|3
condition|)
name|sm_dprintf
argument_list|(
literal|"[%d] milter_abort\n"
argument_list|,
operator|(
name|int
operator|)
name|ctx
operator|->
name|ctx_id
argument_list|)
expr_stmt|;
name|ret
operator|=
name|MI_FAILURE
expr_stmt|;
break|break;
block|}
comment|/* 		**  Notice: buf is allocated by mi_rd_cmd() and it will 		**  usually be free()d after it has been used in f(). 		**  However, if the function returns _SMFIS_KEEP then buf 		**  contains macros and will not be free()d. 		**  Hence r must be set to _SMFIS_NONE if a new buf is 		**  allocated to avoid problem with housekeeping, esp. 		**  if the code "break"s out of the loop. 		*/
name|r
operator|=
name|_SMFIS_NONE
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|mi_rd_cmd
argument_list|(
name|sd
argument_list|,
operator|&
name|timeout
argument_list|,
operator|&
name|cmd
argument_list|,
operator|&
name|len
argument_list|,
name|ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_name
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
name|cmd
operator|<
name|SMFIC_VALIDCMD
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|ctx_dbg
operator|>
literal|5
condition|)
name|sm_dprintf
argument_list|(
literal|"[%d] mi_engine: mi_rd_cmd error (%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|ctx
operator|->
name|ctx_id
argument_list|,
operator|(
name|int
operator|)
name|cmd
argument_list|)
expr_stmt|;
comment|/* 			**  eof is currently treated as failure -> 			**  abort() instead of close(), otherwise use: 			**  if (cmd != SMFIC_EOF) 			*/
name|ret
operator|=
name|MI_FAILURE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ctx
operator|->
name|ctx_dbg
operator|>
literal|4
condition|)
name|sm_dprintf
argument_list|(
literal|"[%d] got cmd '%c' len %d\n"
argument_list|,
operator|(
name|int
operator|)
name|ctx
operator|->
name|ctx_id
argument_list|,
name|cmd
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncmds
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cmd
operator|==
name|cmds
index|[
name|i
index|]
operator|.
name|cm_cmd
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|ncmds
condition|)
block|{
comment|/* unknown command */
if|if
condition|(
name|ctx
operator|->
name|ctx_dbg
operator|>
literal|1
condition|)
name|sm_dprintf
argument_list|(
literal|"[%d] cmd '%c' unknown\n"
argument_list|,
operator|(
name|int
operator|)
name|ctx
operator|->
name|ctx_id
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|MI_FAILURE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|f
operator|=
name|cmds
index|[
name|i
index|]
operator|.
name|cm_fct
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* stop for now */
if|if
condition|(
name|ctx
operator|->
name|ctx_dbg
operator|>
literal|1
condition|)
name|sm_dprintf
argument_list|(
literal|"[%d] cmd '%c' not impl\n"
argument_list|,
operator|(
name|int
operator|)
name|ctx
operator|->
name|ctx_id
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|MI_FAILURE
expr_stmt|;
break|break;
block|}
comment|/* is new state ok? */
name|newstate
operator|=
name|cmds
index|[
name|i
index|]
operator|.
name|cm_next
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|ctx_dbg
operator|>
literal|5
condition|)
name|sm_dprintf
argument_list|(
literal|"[%d] cur %x new %x nextmask %x\n"
argument_list|,
operator|(
name|int
operator|)
name|ctx
operator|->
name|ctx_id
argument_list|,
name|curstate
argument_list|,
name|newstate
argument_list|,
name|next_states
index|[
name|curstate
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|newstate
operator|!=
name|ST_NONE
operator|&&
operator|!
name|trans_ok
argument_list|(
name|curstate
argument_list|,
name|newstate
argument_list|)
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|ctx_dbg
operator|>
literal|1
condition|)
name|sm_dprintf
argument_list|(
literal|"[%d] abort: cur %d (%x) new %d (%x) next %x\n"
argument_list|,
operator|(
name|int
operator|)
name|ctx
operator|->
name|ctx_id
argument_list|,
name|curstate
argument_list|,
name|MASK
argument_list|(
name|curstate
argument_list|)
argument_list|,
name|newstate
argument_list|,
name|MASK
argument_list|(
name|newstate
argument_list|)
argument_list|,
name|next_states
index|[
name|curstate
index|]
argument_list|)
expr_stmt|;
comment|/* call abort only if in a mail transaction */
if|if
condition|(
name|fi_abort
operator|!=
name|NULL
operator|&&
name|call_abort
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|fi_abort
argument_list|)
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
comment|/* 			**  try to reach the new state from HELO 			**  if it can't be reached, ignore the command. 			*/
name|curstate
operator|=
name|ST_HELO
expr_stmt|;
if|if
condition|(
operator|!
name|trans_ok
argument_list|(
name|curstate
argument_list|,
name|newstate
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
block|}
name|arg
operator|.
name|a_len
operator|=
name|len
expr_stmt|;
name|arg
operator|.
name|a_buf
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|newstate
operator|!=
name|ST_NONE
condition|)
block|{
name|curstate
operator|=
name|newstate
expr_stmt|;
name|ctx
operator|->
name|ctx_state
operator|=
name|curstate
expr_stmt|;
block|}
name|arg
operator|.
name|a_idx
operator|=
name|cmds
index|[
name|i
index|]
operator|.
name|cm_macros
expr_stmt|;
comment|/* call function to deal with command */
name|r
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|_SMFIS_KEEP
operator|&&
name|buf
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sendreply
argument_list|(
name|r
argument_list|,
name|sd
argument_list|,
operator|&
name|timeout
argument_list|,
name|ctx
argument_list|)
operator|!=
name|MI_SUCCESS
condition|)
block|{
name|ret
operator|=
name|MI_FAILURE
expr_stmt|;
break|break;
block|}
name|call_abort
operator|=
name|ST_IN_MAIL
argument_list|(
name|curstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|SMFIS_ACCEPT
condition|)
block|{
comment|/* accept mail, no further actions taken */
name|curstate
operator|=
name|ST_HELO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
name|SMFIS_REJECT
operator|||
name|r
operator|==
name|SMFIS_DISCARD
operator|||
name|r
operator|==
name|SMFIS_TEMPFAIL
condition|)
block|{
comment|/* 			**  further actions depend on current state 			**  if the IGNO bit is set: "ignore" the error, 			**  i.e., stay in the current state 			*/
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|CT_IGNO
argument_list|,
name|cmds
index|[
name|i
index|]
operator|.
name|cm_todo
argument_list|)
condition|)
name|curstate
operator|=
name|ST_HELO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
name|_SMFIS_ABORT
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|ctx_dbg
operator|>
literal|5
condition|)
name|sm_dprintf
argument_list|(
literal|"[%d] function returned abort\n"
argument_list|,
operator|(
name|int
operator|)
name|ctx
operator|->
name|ctx_id
argument_list|)
expr_stmt|;
name|ret
operator|=
name|MI_FAILURE
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|!
name|bitset
argument_list|(
name|CT_END
argument_list|,
name|cmds
index|[
name|i
index|]
operator|.
name|cm_todo
argument_list|)
condition|)
do|;
if|if
condition|(
name|ret
operator|!=
name|MI_SUCCESS
condition|)
block|{
comment|/* call abort only if in a mail transaction */
if|if
condition|(
name|fi_abort
operator|!=
name|NULL
operator|&&
name|call_abort
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|fi_abort
argument_list|)
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
comment|/* close must always be called */
if|if
condition|(
operator|(
name|fi_close
operator|=
name|ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_close
operator|)
operator|!=
name|NULL
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|fi_close
argument_list|)
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|_SMFIS_KEEP
operator|&&
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|mi_clr_macros
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* **  SENDREPLY -- send a reply to the MTA ** **	Parameters: **		r -- reply code **		sd -- socket descriptor **		timeout_ptr -- (ptr to) timeout to use for sending **		ctx -- context structure ** **	Returns: **		MI_SUCCESS/MI_FAILURE */
end_comment

begin_function
specifier|static
name|int
name|sendreply
parameter_list|(
name|r
parameter_list|,
name|sd
parameter_list|,
name|timeout_ptr
parameter_list|,
name|ctx
parameter_list|)
name|sfsistat
name|r
decl_stmt|;
name|socket_t
name|sd
decl_stmt|;
name|struct
name|timeval
modifier|*
name|timeout_ptr
decl_stmt|;
name|SMFICTX_PTR
name|ctx
decl_stmt|;
block|{
name|int
name|ret
init|=
name|MI_SUCCESS
decl_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|SMFIS_CONTINUE
case|:
name|ret
operator|=
name|mi_wr_cmd
argument_list|(
name|sd
argument_list|,
name|timeout_ptr
argument_list|,
name|SMFIR_CONTINUE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMFIS_TEMPFAIL
case|:
case|case
name|SMFIS_REJECT
case|:
if|if
condition|(
name|ctx
operator|->
name|ctx_reply
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|mi_wr_cmd
argument_list|(
name|sd
argument_list|,
name|timeout_ptr
argument_list|,
name|SMFIR_REPLYCODE
argument_list|,
name|ctx
operator|->
name|ctx_reply
argument_list|,
name|strlen
argument_list|(
name|ctx
operator|->
name|ctx_reply
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
operator|->
name|ctx_reply
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ctx_reply
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|mi_wr_cmd
argument_list|(
name|sd
argument_list|,
name|timeout_ptr
argument_list|,
name|r
operator|==
name|SMFIS_REJECT
condition|?
name|SMFIR_REJECT
else|:
name|SMFIR_TEMPFAIL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SMFIS_DISCARD
case|:
name|ret
operator|=
name|mi_wr_cmd
argument_list|(
name|sd
argument_list|,
name|timeout_ptr
argument_list|,
name|SMFIR_DISCARD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMFIS_ACCEPT
case|:
name|ret
operator|=
name|mi_wr_cmd
argument_list|(
name|sd
argument_list|,
name|timeout_ptr
argument_list|,
name|SMFIR_ACCEPT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|_SMFIS_OPTIONS
case|:
block|{
name|char
name|buf
index|[
name|MILTER_OPTLEN
index|]
decl_stmt|;
name|mi_int32
name|v
decl_stmt|;
name|v
operator|=
name|htonl
argument_list|(
name|ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_version
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|&
operator|(
name|buf
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|v
argument_list|,
name|MILTER_LEN_BYTES
argument_list|)
expr_stmt|;
name|v
operator|=
name|htonl
argument_list|(
name|ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_flags
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|&
operator|(
name|buf
index|[
name|MILTER_LEN_BYTES
index|]
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|v
argument_list|,
name|MILTER_LEN_BYTES
argument_list|)
expr_stmt|;
name|v
operator|=
name|htonl
argument_list|(
name|ctx
operator|->
name|ctx_pflags
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|&
operator|(
name|buf
index|[
name|MILTER_LEN_BYTES
operator|*
literal|2
index|]
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|v
argument_list|,
name|MILTER_LEN_BYTES
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mi_wr_cmd
argument_list|(
name|sd
argument_list|,
name|timeout_ptr
argument_list|,
name|SMFIC_OPTNEG
argument_list|,
name|buf
argument_list|,
name|MILTER_OPTLEN
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* don't send a reply */
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* **  CLR_MACROS -- clear set of macros starting from a given index ** **	Parameters: **		ctx -- context structure **		m -- index from which to clear all macros ** **	Returns: **		None. */
end_comment

begin_function
name|void
name|mi_clr_macros
parameter_list|(
name|ctx
parameter_list|,
name|m
parameter_list|)
name|SMFICTX_PTR
name|ctx
decl_stmt|;
name|int
name|m
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|m
init|;
name|i
operator|<
name|MAX_MACROS_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ctx
operator|->
name|ctx_mac_ptr
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ctx
operator|->
name|ctx_mac_ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ctx_mac_ptr
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|ctx_mac_buf
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ctx
operator|->
name|ctx_mac_buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ctx_mac_buf
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* **  ST_OPTIONNEG -- negotiate options ** **	Parameters: **		g -- generic argument structure ** **	Returns: **		abort/send options/continue */
end_comment

begin_function
specifier|static
name|int
name|st_optionneg
parameter_list|(
name|g
parameter_list|)
name|genarg
modifier|*
name|g
decl_stmt|;
block|{
name|mi_int32
name|i
decl_stmt|,
name|v
decl_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
operator|||
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|==
name|NULL
condition|)
return|return
name|SMFIS_CONTINUE
return|;
name|mi_clr_macros
argument_list|(
name|g
operator|->
name|a_ctx
argument_list|,
name|g
operator|->
name|a_idx
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* check for minimum length */
if|if
condition|(
name|g
operator|->
name|a_len
operator|<
name|MILTER_OPTLEN
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: st_optionneg[%d]: len too short %d< %d"
argument_list|,
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_name
argument_list|,
operator|(
name|int
operator|)
name|g
operator|->
name|a_ctx
operator|->
name|ctx_id
argument_list|,
name|g
operator|->
name|a_len
argument_list|,
name|MILTER_OPTLEN
argument_list|)
expr_stmt|;
return|return
name|_SMFIS_ABORT
return|;
block|}
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|g
operator|->
name|a_buf
index|[
literal|0
index|]
operator|)
argument_list|,
name|MILTER_LEN_BYTES
argument_list|)
expr_stmt|;
name|v
operator|=
name|ntohl
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|<
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_version
condition|)
block|{
comment|/* hard failure for now! */
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: st_optionneg[%d]: version mismatch MTA: %d< milter: %d"
argument_list|,
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_name
argument_list|,
operator|(
name|int
operator|)
name|g
operator|->
name|a_ctx
operator|->
name|ctx_id
argument_list|,
operator|(
name|int
operator|)
name|v
argument_list|,
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_version
argument_list|)
expr_stmt|;
return|return
name|_SMFIS_ABORT
return|;
block|}
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|g
operator|->
name|a_buf
index|[
name|MILTER_LEN_BYTES
index|]
operator|)
argument_list|,
name|MILTER_LEN_BYTES
argument_list|)
expr_stmt|;
name|v
operator|=
name|ntohl
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* no flags? set to default value for V1 actions */
if|if
condition|(
name|v
operator|==
literal|0
condition|)
name|v
operator|=
name|SMFI_V1_ACTS
expr_stmt|;
name|i
operator|=
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_flags
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|&
name|i
operator|)
operator|!=
name|i
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: st_optionneg[%d]: 0x%x does not fulfill action requirements 0x%x"
argument_list|,
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_name
argument_list|,
operator|(
name|int
operator|)
name|g
operator|->
name|a_ctx
operator|->
name|ctx_id
argument_list|,
name|v
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|_SMFIS_ABORT
return|;
block|}
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|g
operator|->
name|a_buf
index|[
name|MILTER_LEN_BYTES
operator|*
literal|2
index|]
operator|)
argument_list|,
name|MILTER_LEN_BYTES
argument_list|)
expr_stmt|;
name|v
operator|=
name|ntohl
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* no flags? set to default value for V1 protocol */
if|if
condition|(
name|v
operator|==
literal|0
condition|)
name|v
operator|=
name|SMFI_V1_PROT
expr_stmt|;
name|i
operator|=
name|g
operator|->
name|a_ctx
operator|->
name|ctx_pflags
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|&
name|i
operator|)
operator|!=
name|i
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: st_optionneg[%d]: 0x%x does not fulfill protocol requirements 0x%x"
argument_list|,
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_name
argument_list|,
operator|(
name|int
operator|)
name|g
operator|->
name|a_ctx
operator|->
name|ctx_id
argument_list|,
name|v
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|_SMFIS_ABORT
return|;
block|}
return|return
name|_SMFIS_OPTIONS
return|;
block|}
end_function

begin_comment
comment|/* **  ST_CONNECTINFO -- receive connection information ** **	Parameters: **		g -- generic argument structure ** **	Returns: **		continue or filter-specified value */
end_comment

begin_function
specifier|static
name|int
name|st_connectinfo
parameter_list|(
name|g
parameter_list|)
name|genarg
modifier|*
name|g
decl_stmt|;
block|{
name|size_t
name|l
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
name|family
decl_stmt|;
name|unsigned
name|short
name|port
init|=
literal|0
decl_stmt|;
name|_SOCK_ADDR
name|sockaddr
decl_stmt|;
name|sfsistat
argument_list|(
argument|*fi_connect
argument_list|)
name|__P
argument_list|(
operator|(
name|SMFICTX
operator|*
operator|,
name|char
operator|*
operator|,
name|_SOCK_ADDR
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
return|return
name|_SMFIS_ABORT
return|;
name|mi_clr_macros
argument_list|(
name|g
operator|->
name|a_ctx
argument_list|,
name|g
operator|->
name|a_idx
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|==
name|NULL
operator|||
operator|(
name|fi_connect
operator|=
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_connect
operator|)
operator|==
name|NULL
condition|)
return|return
name|SMFIS_CONTINUE
return|;
name|s
operator|=
name|g
operator|->
name|a_buf
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|l
operator|=
name|g
operator|->
name|a_len
expr_stmt|;
while|while
condition|(
name|s
index|[
name|i
index|]
operator|!=
literal|'\0'
operator|&&
name|i
operator|<=
name|l
condition|)
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|l
condition|)
return|return
name|_SMFIS_ABORT
return|;
comment|/* Move past trailing \0 in host string */
name|i
operator|++
expr_stmt|;
name|family
operator|=
name|s
index|[
name|i
operator|++
index|]
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sockaddr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|sockaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|family
operator|!=
name|SMFIA_UNKNOWN
condition|)
block|{
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|port
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|s
operator|+
name|i
operator|)
argument_list|,
sizeof|sizeof
name|port
argument_list|)
expr_stmt|;
name|port
operator|=
name|ntohs
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+=
sizeof|sizeof
name|port
operator|)
operator|>=
name|l
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: connect[%d]: wrong len %d>= %d"
argument_list|,
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_name
argument_list|,
operator|(
name|int
operator|)
name|g
operator|->
name|a_ctx
operator|->
name|ctx_id
argument_list|,
name|i
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
name|_SMFIS_ABORT
return|;
block|}
if|#
directive|if
name|NETINET
if|if
condition|(
name|family
operator|==
name|SMFIA_INET
condition|)
block|{
if|if
condition|(
name|inet_aton
argument_list|(
name|s
operator|+
name|i
argument_list|,
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
name|sockaddr
operator|.
name|sin
operator|.
name|sin_addr
argument_list|)
operator|==
name|INADDR_NONE
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: connect[%d]: inet_aton failed"
argument_list|,
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_name
argument_list|,
operator|(
name|int
operator|)
name|g
operator|->
name|a_ctx
operator|->
name|ctx_id
argument_list|)
expr_stmt|;
return|return
name|_SMFIS_ABORT
return|;
block|}
name|sockaddr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
if|if
condition|(
name|port
operator|>
literal|0
condition|)
name|sockaddr
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET6
if|if
condition|(
name|family
operator|==
name|SMFIA_INET6
condition|)
block|{
if|if
condition|(
name|mi_inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|s
operator|+
name|i
argument_list|,
operator|&
name|sockaddr
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: connect[%d]: mi_inet_pton failed"
argument_list|,
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_name
argument_list|,
operator|(
name|int
operator|)
name|g
operator|->
name|a_ctx
operator|->
name|ctx_id
argument_list|)
expr_stmt|;
return|return
name|_SMFIS_ABORT
return|;
block|}
name|sockaddr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET6
expr_stmt|;
if|if
condition|(
name|port
operator|>
literal|0
condition|)
name|sockaddr
operator|.
name|sin6
operator|.
name|sin6_port
operator|=
name|port
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* NETINET6 */
if|#
directive|if
name|NETUNIX
if|if
condition|(
name|family
operator|==
name|SMFIA_UNIX
condition|)
block|{
if|if
condition|(
name|sm_strlcpy
argument_list|(
name|sockaddr
operator|.
name|sunix
operator|.
name|sun_path
argument_list|,
name|s
operator|+
name|i
argument_list|,
sizeof|sizeof
name|sockaddr
operator|.
name|sunix
operator|.
name|sun_path
argument_list|)
operator|>=
sizeof|sizeof
name|sockaddr
operator|.
name|sunix
operator|.
name|sun_path
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: connect[%d]: path too long"
argument_list|,
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_name
argument_list|,
operator|(
name|int
operator|)
name|g
operator|->
name|a_ctx
operator|->
name|ctx_id
argument_list|)
expr_stmt|;
return|return
name|_SMFIS_ABORT
return|;
block|}
name|sockaddr
operator|.
name|sunix
operator|.
name|sun_family
operator|=
name|AF_UNIX
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* NETUNIX */
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: connect[%d]: unknown family %d"
argument_list|,
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_name
argument_list|,
operator|(
name|int
operator|)
name|g
operator|->
name|a_ctx
operator|->
name|ctx_id
argument_list|,
name|family
argument_list|)
expr_stmt|;
return|return
name|_SMFIS_ABORT
return|;
block|}
block|}
return|return
call|(
modifier|*
name|fi_connect
call|)
argument_list|(
name|g
operator|->
name|a_ctx
argument_list|,
name|g
operator|->
name|a_buf
argument_list|,
name|family
operator|!=
name|SMFIA_UNKNOWN
condition|?
operator|&
name|sockaddr
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  ST_EOH -- end of headers ** **	Parameters: **		g -- generic argument structure ** **	Returns: **		continue or filter-specified value */
end_comment

begin_function
specifier|static
name|int
name|st_eoh
parameter_list|(
name|g
parameter_list|)
name|genarg
modifier|*
name|g
decl_stmt|;
block|{
name|sfsistat
argument_list|(
argument|*fi_eoh
argument_list|)
name|__P
argument_list|(
operator|(
name|SMFICTX
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
return|return
name|_SMFIS_ABORT
return|;
if|if
condition|(
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|!=
name|NULL
operator|&&
operator|(
name|fi_eoh
operator|=
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_eoh
operator|)
operator|!=
name|NULL
condition|)
return|return
call|(
modifier|*
name|fi_eoh
call|)
argument_list|(
name|g
operator|->
name|a_ctx
argument_list|)
return|;
return|return
name|SMFIS_CONTINUE
return|;
block|}
end_function

begin_comment
comment|/* **  ST_HELO -- helo/ehlo command ** **	Parameters: **		g -- generic argument structure ** **	Returns: **		continue or filter-specified value */
end_comment

begin_function
specifier|static
name|int
name|st_helo
parameter_list|(
name|g
parameter_list|)
name|genarg
modifier|*
name|g
decl_stmt|;
block|{
name|sfsistat
argument_list|(
argument|*fi_helo
argument_list|)
name|__P
argument_list|(
operator|(
name|SMFICTX
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
return|return
name|_SMFIS_ABORT
return|;
name|mi_clr_macros
argument_list|(
name|g
operator|->
name|a_ctx
argument_list|,
name|g
operator|->
name|a_idx
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|!=
name|NULL
operator|&&
operator|(
name|fi_helo
operator|=
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_helo
operator|)
operator|!=
name|NULL
condition|)
return|return
call|(
modifier|*
name|fi_helo
call|)
argument_list|(
name|g
operator|->
name|a_ctx
argument_list|,
name|g
operator|->
name|a_buf
argument_list|)
return|;
return|return
name|SMFIS_CONTINUE
return|;
block|}
end_function

begin_comment
comment|/* **  ST_HEADER -- header line ** **	Parameters: **		g -- generic argument structure ** **	Returns: **		continue or filter-specified value */
end_comment

begin_function
specifier|static
name|int
name|st_header
parameter_list|(
name|g
parameter_list|)
name|genarg
modifier|*
name|g
decl_stmt|;
block|{
name|char
modifier|*
name|hf
decl_stmt|,
modifier|*
name|hv
decl_stmt|;
name|sfsistat
argument_list|(
argument|*fi_header
argument_list|)
name|__P
argument_list|(
operator|(
name|SMFICTX
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
return|return
name|_SMFIS_ABORT
return|;
if|if
condition|(
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|==
name|NULL
operator|||
operator|(
name|fi_header
operator|=
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_header
operator|)
operator|==
name|NULL
condition|)
return|return
name|SMFIS_CONTINUE
return|;
if|if
condition|(
name|dec_arg2
argument_list|(
name|g
operator|->
name|a_buf
argument_list|,
name|g
operator|->
name|a_len
argument_list|,
operator|&
name|hf
argument_list|,
operator|&
name|hv
argument_list|)
operator|==
name|MI_SUCCESS
condition|)
return|return
call|(
modifier|*
name|fi_header
call|)
argument_list|(
name|g
operator|->
name|a_ctx
argument_list|,
name|hf
argument_list|,
name|hv
argument_list|)
return|;
else|else
return|return
name|_SMFIS_ABORT
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ARGV_FCT
parameter_list|(
name|lf
parameter_list|,
name|rf
parameter_list|,
name|idx
parameter_list|)
define|\
value|char **argv;						\ 	sfsistat (*lf) __P((SMFICTX *, char **));		\ 	int r;							\ 								\ 	if (g == NULL)						\ 		return _SMFIS_ABORT;				\ 	mi_clr_macros(g->a_ctx, g->a_idx + 1);			\ 	if (g->a_ctx->ctx_smfi == NULL ||			\ 	    (lf = g->a_ctx->ctx_smfi->rf) == NULL)		\ 		return SMFIS_CONTINUE;				\ 	if ((argv = dec_argv(g->a_buf, g->a_len)) == NULL)	\ 		return _SMFIS_ABORT;				\ 	r = (*lf)(g->a_ctx, argv);				\ 	free(argv);						\ 	return r;
end_define

begin_comment
comment|/* **  ST_SENDER -- MAIL FROM command ** **	Parameters: **		g -- generic argument structure ** **	Returns: **		continue or filter-specified value */
end_comment

begin_function
specifier|static
name|int
name|st_sender
parameter_list|(
name|g
parameter_list|)
name|genarg
modifier|*
name|g
decl_stmt|;
block|{
name|ARGV_FCT
argument_list|(
argument|fi_envfrom
argument_list|,
argument|xxfi_envfrom
argument_list|,
argument|CI_MAIL
argument_list|)
block|}
end_function

begin_comment
comment|/* **  ST_RCPT -- RCPT TO command ** **	Parameters: **		g -- generic argument structure ** **	Returns: **		continue or filter-specified value */
end_comment

begin_function
specifier|static
name|int
name|st_rcpt
parameter_list|(
name|g
parameter_list|)
name|genarg
modifier|*
name|g
decl_stmt|;
block|{
name|ARGV_FCT
argument_list|(
argument|fi_envrcpt
argument_list|,
argument|xxfi_envrcpt
argument_list|,
argument|CI_RCPT
argument_list|)
block|}
end_function

begin_comment
comment|/* **  ST_MACROS -- deal with macros received from the MTA ** **	Parameters: **		g -- generic argument structure ** **	Returns: **		continue/keep ** **	Side effects: **		set pointer in macro array to current values. */
end_comment

begin_function
specifier|static
name|int
name|st_macros
parameter_list|(
name|g
parameter_list|)
name|genarg
modifier|*
name|g
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
operator|||
name|g
operator|->
name|a_len
operator|<
literal|1
condition|)
return|return
name|_SMFIS_FAIL
return|;
if|if
condition|(
operator|(
name|argv
operator|=
name|dec_argv
argument_list|(
name|g
operator|->
name|a_buf
operator|+
literal|1
argument_list|,
name|g
operator|->
name|a_len
operator|-
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|_SMFIS_FAIL
return|;
switch|switch
condition|(
name|g
operator|->
name|a_buf
index|[
literal|0
index|]
condition|)
block|{
case|case
name|SMFIC_CONNECT
case|:
name|i
operator|=
name|CI_CONN
expr_stmt|;
break|break;
case|case
name|SMFIC_HELO
case|:
name|i
operator|=
name|CI_HELO
expr_stmt|;
break|break;
case|case
name|SMFIC_MAIL
case|:
name|i
operator|=
name|CI_MAIL
expr_stmt|;
break|break;
case|case
name|SMFIC_RCPT
case|:
name|i
operator|=
name|CI_RCPT
expr_stmt|;
break|break;
default|default:
name|free
argument_list|(
name|argv
argument_list|)
expr_stmt|;
return|return
name|_SMFIS_FAIL
return|;
block|}
if|if
condition|(
name|g
operator|->
name|a_ctx
operator|->
name|ctx_mac_ptr
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|g
operator|->
name|a_ctx
operator|->
name|ctx_mac_ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|a_ctx
operator|->
name|ctx_mac_buf
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|g
operator|->
name|a_ctx
operator|->
name|ctx_mac_buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|g
operator|->
name|a_ctx
operator|->
name|ctx_mac_ptr
index|[
name|i
index|]
operator|=
name|argv
expr_stmt|;
name|g
operator|->
name|a_ctx
operator|->
name|ctx_mac_buf
index|[
name|i
index|]
operator|=
name|g
operator|->
name|a_buf
expr_stmt|;
return|return
name|_SMFIS_KEEP
return|;
block|}
end_function

begin_comment
comment|/* **  ST_QUIT -- quit command ** **	Parameters: **		g -- generic argument structure ** **	Returns: **		noreply */
end_comment

begin_function
specifier|static
name|int
name|st_quit
parameter_list|(
name|g
parameter_list|)
name|genarg
modifier|*
name|g
decl_stmt|;
block|{
return|return
name|_SMFIS_NOREPLY
return|;
block|}
end_function

begin_comment
comment|/* **  ST_BODYCHUNK -- deal with a piece of the mail body ** **	Parameters: **		g -- generic argument structure ** **	Returns: **		continue or filter-specified value */
end_comment

begin_function
specifier|static
name|int
name|st_bodychunk
parameter_list|(
name|g
parameter_list|)
name|genarg
modifier|*
name|g
decl_stmt|;
block|{
name|sfsistat
argument_list|(
argument|*fi_body
argument_list|)
name|__P
argument_list|(
operator|(
name|SMFICTX
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
return|return
name|_SMFIS_ABORT
return|;
if|if
condition|(
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|!=
name|NULL
operator|&&
operator|(
name|fi_body
operator|=
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_body
operator|)
operator|!=
name|NULL
condition|)
return|return
call|(
modifier|*
name|fi_body
call|)
argument_list|(
name|g
operator|->
name|a_ctx
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|g
operator|->
name|a_buf
argument_list|,
name|g
operator|->
name|a_len
argument_list|)
return|;
return|return
name|SMFIS_CONTINUE
return|;
block|}
end_function

begin_comment
comment|/* **  ST_BODYEND -- deal with the last piece of the mail body ** **	Parameters: **		g -- generic argument structure ** **	Returns: **		continue or filter-specified value ** **	Side effects: **		sends a reply for the body part (if non-empty). */
end_comment

begin_function
specifier|static
name|int
name|st_bodyend
parameter_list|(
name|g
parameter_list|)
name|genarg
modifier|*
name|g
decl_stmt|;
block|{
name|sfsistat
name|r
decl_stmt|;
name|sfsistat
argument_list|(
argument|*fi_body
argument_list|)
name|__P
argument_list|(
operator|(
name|SMFICTX
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
expr_stmt|;
name|sfsistat
argument_list|(
argument|*fi_eom
argument_list|)
name|__P
argument_list|(
operator|(
name|SMFICTX
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
return|return
name|_SMFIS_ABORT
return|;
name|r
operator|=
name|SMFIS_CONTINUE
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|fi_body
operator|=
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_body
operator|)
operator|!=
name|NULL
operator|&&
name|g
operator|->
name|a_len
operator|>
literal|0
condition|)
block|{
name|socket_t
name|sd
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
name|g
operator|->
name|a_ctx
operator|->
name|ctx_timeout
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|sd
operator|=
name|g
operator|->
name|a_ctx
operator|->
name|ctx_sd
expr_stmt|;
name|r
operator|=
call|(
modifier|*
name|fi_body
call|)
argument_list|(
name|g
operator|->
name|a_ctx
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|g
operator|->
name|a_buf
argument_list|,
name|g
operator|->
name|a_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|SMFIS_CONTINUE
operator|&&
name|sendreply
argument_list|(
name|r
argument_list|,
name|sd
argument_list|,
operator|&
name|timeout
argument_list|,
name|g
operator|->
name|a_ctx
argument_list|)
operator|!=
name|MI_SUCCESS
condition|)
return|return
name|_SMFIS_ABORT
return|;
block|}
block|}
if|if
condition|(
name|r
operator|==
name|SMFIS_CONTINUE
operator|&&
operator|(
name|fi_eom
operator|=
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_eom
operator|)
operator|!=
name|NULL
condition|)
return|return
call|(
modifier|*
name|fi_eom
call|)
argument_list|(
name|g
operator|->
name|a_ctx
argument_list|)
return|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* **  ST_ABORTFCT -- deal with aborts ** **	Parameters: **		g -- generic argument structure ** **	Returns: **		abort or filter-specified value */
end_comment

begin_function
specifier|static
name|int
name|st_abortfct
parameter_list|(
name|g
parameter_list|)
name|genarg
modifier|*
name|g
decl_stmt|;
block|{
name|sfsistat
argument_list|(
argument|*fi_abort
argument_list|)
name|__P
argument_list|(
operator|(
name|SMFICTX
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
return|return
name|_SMFIS_ABORT
return|;
if|if
condition|(
name|g
operator|!=
name|NULL
operator|&&
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|!=
name|NULL
operator|&&
operator|(
name|fi_abort
operator|=
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_abort
operator|)
operator|!=
name|NULL
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|fi_abort
argument_list|)
argument_list|(
name|g
operator|->
name|a_ctx
argument_list|)
expr_stmt|;
return|return
name|_SMFIS_NOREPLY
return|;
block|}
end_function

begin_comment
comment|/* **  TRANS_OK -- is the state transition ok? ** **	Parameters: **		old -- old state **		new -- new state ** **	Returns: **		state transition ok */
end_comment

begin_function
specifier|static
name|bool
name|trans_ok
parameter_list|(
name|old
parameter_list|,
name|new
parameter_list|)
name|int
name|old
decl_stmt|,
name|new
decl_stmt|;
block|{
name|int
name|s
decl_stmt|,
name|n
decl_stmt|;
name|s
operator|=
name|old
expr_stmt|;
do|do
block|{
comment|/* is this state transition allowed? */
if|if
condition|(
operator|(
name|MASK
argument_list|(
name|new
argument_list|)
operator|&
name|next_states
index|[
name|s
index|]
operator|)
operator|!=
literal|0
condition|)
return|return
name|true
return|;
comment|/* 		**  no: try next state; 		**  this works since the relevant states are ordered 		**  strict sequentially 		*/
name|n
operator|=
name|s
operator|+
literal|1
expr_stmt|;
comment|/* 		**  can we actually "skip" this state? 		**  see fix_stm() which sets this bit for those 		**  states which the filter program is not interested in 		*/
if|if
condition|(
name|bitset
argument_list|(
name|NX_SKIP
argument_list|,
name|next_states
index|[
name|n
index|]
argument_list|)
condition|)
name|s
operator|=
name|n
expr_stmt|;
else|else
return|return
name|false
return|;
block|}
do|while
condition|(
name|s
operator|<=
name|ST_LAST
condition|)
do|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* **  FIX_STM -- add "skip" bits to the state transition table ** **	Parameters: **		ctx -- context structure ** **	Returns: **		None. ** **	Side effects: **		may change state transition table. */
end_comment

begin_function
specifier|static
name|void
name|fix_stm
parameter_list|(
name|ctx
parameter_list|)
name|SMFICTX_PTR
name|ctx
decl_stmt|;
block|{
name|unsigned
name|long
name|fl
decl_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
operator|||
name|ctx
operator|->
name|ctx_smfi
operator|==
name|NULL
condition|)
return|return;
name|fl
operator|=
name|ctx
operator|->
name|ctx_pflags
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|SMFIP_NOCONNECT
argument_list|,
name|fl
argument_list|)
condition|)
name|next_states
index|[
name|ST_CONN
index|]
operator||=
name|NX_SKIP
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|SMFIP_NOHELO
argument_list|,
name|fl
argument_list|)
condition|)
name|next_states
index|[
name|ST_HELO
index|]
operator||=
name|NX_SKIP
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|SMFIP_NOMAIL
argument_list|,
name|fl
argument_list|)
condition|)
name|next_states
index|[
name|ST_MAIL
index|]
operator||=
name|NX_SKIP
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|SMFIP_NORCPT
argument_list|,
name|fl
argument_list|)
condition|)
name|next_states
index|[
name|ST_RCPT
index|]
operator||=
name|NX_SKIP
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|SMFIP_NOHDRS
argument_list|,
name|fl
argument_list|)
condition|)
name|next_states
index|[
name|ST_HDRS
index|]
operator||=
name|NX_SKIP
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|SMFIP_NOEOH
argument_list|,
name|fl
argument_list|)
condition|)
name|next_states
index|[
name|ST_EOHS
index|]
operator||=
name|NX_SKIP
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|SMFIP_NOBODY
argument_list|,
name|fl
argument_list|)
condition|)
name|next_states
index|[
name|ST_BODY
index|]
operator||=
name|NX_SKIP
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  DEC_ARGV -- split a buffer into a list of strings, NULL terminated ** **	Parameters: **		buf -- buffer with several strings **		len -- length of buffer ** **	Returns: **		array of pointers to the individual strings */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|dec_argv
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|elem
decl_stmt|,
name|nelem
decl_stmt|;
name|nelem
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
operator|++
name|nelem
expr_stmt|;
block|}
if|if
condition|(
name|nelem
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* last entry is only for the name */
name|s
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|nelem
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
expr|*
name|s
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|s
index|[
literal|0
index|]
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|elem
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|&&
name|elem
operator|<
name|nelem
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
name|s
index|[
operator|++
name|elem
index|]
operator|=
operator|&
operator|(
name|buf
index|[
name|i
operator|+
literal|1
index|]
operator|)
expr_stmt|;
block|}
comment|/* overwrite last entry */
name|s
index|[
name|elem
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* **  DEC_ARG2 -- split a buffer into two strings ** **	Parameters: **		buf -- buffer with two strings **		len -- length of buffer **		s1,s2 -- pointer to result strings ** **	Returns: **		MI_FAILURE/MI_SUCCESS */
end_comment

begin_function
specifier|static
name|int
name|dec_arg2
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|,
name|s1
parameter_list|,
name|s2
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
modifier|*
name|s1
decl_stmt|;
name|char
modifier|*
modifier|*
name|s2
decl_stmt|;
block|{
name|size_t
name|i
decl_stmt|;
operator|*
name|s1
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|len
operator|&&
name|buf
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
continue|continue;
if|if
condition|(
name|i
operator|>=
name|len
operator|-
literal|1
condition|)
return|return
name|MI_FAILURE
return|;
operator|*
name|s2
operator|=
name|buf
operator|+
name|i
operator|+
literal|1
expr_stmt|;
return|return
name|MI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* **  SENDOK -- is it ok for the filter to send stuff to the MTA? ** **	Parameters: **		ctx -- context structure **		flag -- flag to check ** **	Returns: **		sending allowed (in current state) */
end_comment

begin_function
name|bool
name|mi_sendok
parameter_list|(
name|ctx
parameter_list|,
name|flag
parameter_list|)
name|SMFICTX_PTR
name|ctx
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
if|if
condition|(
name|ctx
operator|==
name|NULL
operator|||
name|ctx
operator|->
name|ctx_smfi
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* did the milter request this operation? */
if|if
condition|(
name|flag
operator|!=
literal|0
operator|&&
operator|!
name|bitset
argument_list|(
name|flag
argument_list|,
name|ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_flags
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* are we in the correct state? It must be "End of Message". */
return|return
name|ctx
operator|->
name|ctx_state
operator|==
name|ST_ENDM
return|;
block|}
end_function

end_unit

