begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Copyright (c) 1999-2004, 2006 Sendmail, Inc. and its suppliers.  *	All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_include
include|#
directive|include
file|<sm/gen.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: engine.c,v 8.157 2007/03/26 18:10:04 ca Exp $"
argument_list|)
end_macro

begin_include
include|#
directive|include
file|"libmilter.h"
end_include

begin_if
if|#
directive|if
name|NETINET
operator|||
name|NETINET6
end_if

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NETINET || NETINET6 */
end_comment

begin_comment
comment|/* generic argument for functions in the command table */
end_comment

begin_struct
struct|struct
name|arg_struct
block|{
name|size_t
name|a_len
decl_stmt|;
comment|/* length of buffer */
name|char
modifier|*
name|a_buf
decl_stmt|;
comment|/* argument string */
name|int
name|a_idx
decl_stmt|;
comment|/* index for macro array */
name|SMFICTX_PTR
name|a_ctx
decl_stmt|;
comment|/* context */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|arg_struct
name|genarg
typedef|;
end_typedef

begin_comment
comment|/* structure for commands received from MTA */
end_comment

begin_struct
struct|struct
name|cmdfct_t
block|{
name|char
name|cm_cmd
decl_stmt|;
comment|/* command */
name|int
name|cm_argt
decl_stmt|;
comment|/* type of arguments expected */
name|int
name|cm_next
decl_stmt|;
comment|/* next state */
name|int
name|cm_todo
decl_stmt|;
comment|/* what to do next */
name|int
name|cm_macros
decl_stmt|;
comment|/* index for macros */
name|int
argument_list|(
argument|*cm_fct
argument_list|)
name|__P
argument_list|(
operator|(
name|genarg
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* function to execute */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|cmdfct_t
name|cmdfct
typedef|;
end_typedef

begin_comment
comment|/* possible values for cm_argt */
end_comment

begin_define
define|#
directive|define
name|CM_ARG0
value|0
end_define

begin_comment
comment|/* no args */
end_comment

begin_define
define|#
directive|define
name|CM_ARG1
value|1
end_define

begin_comment
comment|/* one arg (string) */
end_comment

begin_define
define|#
directive|define
name|CM_ARG2
value|2
end_define

begin_comment
comment|/* two args (strings) */
end_comment

begin_define
define|#
directive|define
name|CM_ARGA
value|4
end_define

begin_comment
comment|/* one string and _SOCK_ADDR */
end_comment

begin_define
define|#
directive|define
name|CM_ARGO
value|5
end_define

begin_comment
comment|/* two integers */
end_comment

begin_define
define|#
directive|define
name|CM_ARGV
value|8
end_define

begin_comment
comment|/* \0 separated list of args, NULL-terminated */
end_comment

begin_define
define|#
directive|define
name|CM_ARGN
value|9
end_define

begin_comment
comment|/* \0 separated list of args (strings) */
end_comment

begin_comment
comment|/* possible values for cm_todo */
end_comment

begin_define
define|#
directive|define
name|CT_CONT
value|0x0000
end_define

begin_comment
comment|/* continue reading commands */
end_comment

begin_define
define|#
directive|define
name|CT_IGNO
value|0x0001
end_define

begin_comment
comment|/* continue even when error  */
end_comment

begin_comment
comment|/* not needed right now, done via return code instead */
end_comment

begin_define
define|#
directive|define
name|CT_KEEP
value|0x0004
end_define

begin_comment
comment|/* keep buffer (contains symbols) */
end_comment

begin_define
define|#
directive|define
name|CT_END
value|0x0008
end_define

begin_comment
comment|/* last command of session, stop replying */
end_comment

begin_comment
comment|/* index in macro array: macros only for these commands */
end_comment

begin_define
define|#
directive|define
name|CI_NONE
value|(-1)
end_define

begin_define
define|#
directive|define
name|CI_CONN
value|0
end_define

begin_define
define|#
directive|define
name|CI_HELO
value|1
end_define

begin_define
define|#
directive|define
name|CI_MAIL
value|2
end_define

begin_define
define|#
directive|define
name|CI_RCPT
value|3
end_define

begin_define
define|#
directive|define
name|CI_DATA
value|4
end_define

begin_define
define|#
directive|define
name|CI_EOM
value|5
end_define

begin_define
define|#
directive|define
name|CI_EOH
value|6
end_define

begin_define
define|#
directive|define
name|CI_LAST
value|CI_EOH
end_define

begin_if
if|#
directive|if
name|CI_LAST
operator|<
name|CI_DATA
end_if

begin_label
name|ERROR
label|:
end_label

begin_do
do|do
name|not
name|compile
name|with
name|CI_LAST
operator|<
name|CI_DATA
endif|#
directive|endif
if|#
directive|if
name|CI_LAST
operator|<
name|CI_EOM
name|ERROR
operator|:
do|do
name|not
name|compile
name|with
name|CI_LAST
operator|<
name|CI_EOM
endif|#
directive|endif
if|#
directive|if
name|CI_LAST
operator|<
name|CI_EOH
name|ERROR
operator|:
do|do
name|not
name|compile
name|with
name|CI_LAST
operator|<
name|CI_EOH
endif|#
directive|endif
if|#
directive|if
name|CI_LAST
operator|<
name|CI_ENVRCPT
name|ERROR
operator|:
do|do
name|not
name|compile
name|with
name|CI_LAST
operator|<
name|CI_ENVRCPT
endif|#
directive|endif
if|#
directive|if
name|CI_LAST
operator|<
name|CI_ENVFROM
name|ERROR
operator|:
do|do
name|not
name|compile
name|with
name|CI_LAST
operator|<
name|CI_ENVFROM
endif|#
directive|endif
if|#
directive|if
name|CI_LAST
operator|<
name|CI_HELO
name|ERROR
operator|:
do|do
name|not
name|compile
name|with
name|CI_LAST
operator|<
name|CI_HELO
endif|#
directive|endif
if|#
directive|if
name|CI_LAST
operator|<
name|CI_CONNECT
name|ERROR
operator|:
do|do
name|not
name|compile
name|with
name|CI_LAST
operator|<
name|CI_CONNECT
endif|#
directive|endif
if|#
directive|if
name|CI_LAST
operator|>=
name|MAX_MACROS_ENTRIES
name|ERROR
operator|:
do|do
name|not
name|compile
name|with
name|CI_LAST
operator|>=
name|MAX_MACROS_ENTRIES
endif|#
directive|endif
comment|/* function prototypes */
specifier|static
name|int
name|st_abortfct
name|__P
argument_list|(
operator|(
name|genarg
operator|*
operator|)
argument_list|)
expr_stmt|;
do|static int	st_macros __P((genarg *
end_do

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|static
name|int
name|st_optionneg
name|__P
argument_list|(
operator|(
name|genarg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|st_bodychunk
name|__P
argument_list|(
operator|(
name|genarg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|st_connectinfo
name|__P
argument_list|(
operator|(
name|genarg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|st_bodyend
name|__P
argument_list|(
operator|(
name|genarg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|st_helo
name|__P
argument_list|(
operator|(
name|genarg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|st_header
name|__P
argument_list|(
operator|(
name|genarg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|st_sender
name|__P
argument_list|(
operator|(
name|genarg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|st_rcpt
name|__P
argument_list|(
operator|(
name|genarg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|st_unknown
name|__P
argument_list|(
operator|(
name|genarg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|st_data
name|__P
argument_list|(
operator|(
name|genarg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|st_eoh
name|__P
argument_list|(
operator|(
name|genarg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|st_quit
name|__P
argument_list|(
operator|(
name|genarg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sendreply
name|__P
argument_list|(
operator|(
name|sfsistat
operator|,
name|socket_t
operator|,
expr|struct
name|timeval
operator|*
operator|,
name|SMFICTX_PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fix_stm
name|__P
argument_list|(
operator|(
name|SMFICTX_PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|trans_ok
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|dec_argv
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dec_arg2
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|size_t
operator|,
name|char
operator|*
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|_FFR_WORKERS_POOL
end_if

begin_decl_stmt
specifier|static
name|bool
name|mi_rd_socket_ready
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_WORKERS_POOL */
end_comment

begin_comment
comment|/* states */
end_comment

begin_define
define|#
directive|define
name|ST_NONE
value|(-1)
end_define

begin_define
define|#
directive|define
name|ST_INIT
value|0
end_define

begin_comment
comment|/* initial state */
end_comment

begin_define
define|#
directive|define
name|ST_OPTS
value|1
end_define

begin_comment
comment|/* option negotiation */
end_comment

begin_define
define|#
directive|define
name|ST_CONN
value|2
end_define

begin_comment
comment|/* connection info */
end_comment

begin_define
define|#
directive|define
name|ST_HELO
value|3
end_define

begin_comment
comment|/* helo */
end_comment

begin_define
define|#
directive|define
name|ST_MAIL
value|4
end_define

begin_comment
comment|/* mail from */
end_comment

begin_define
define|#
directive|define
name|ST_RCPT
value|5
end_define

begin_comment
comment|/* rcpt to */
end_comment

begin_define
define|#
directive|define
name|ST_DATA
value|6
end_define

begin_comment
comment|/* data */
end_comment

begin_define
define|#
directive|define
name|ST_HDRS
value|7
end_define

begin_comment
comment|/* headers */
end_comment

begin_define
define|#
directive|define
name|ST_EOHS
value|8
end_define

begin_comment
comment|/* end of headers */
end_comment

begin_define
define|#
directive|define
name|ST_BODY
value|9
end_define

begin_comment
comment|/* body */
end_comment

begin_define
define|#
directive|define
name|ST_ENDM
value|10
end_define

begin_comment
comment|/* end of message */
end_comment

begin_define
define|#
directive|define
name|ST_QUIT
value|11
end_define

begin_comment
comment|/* quit */
end_comment

begin_define
define|#
directive|define
name|ST_ABRT
value|12
end_define

begin_comment
comment|/* abort */
end_comment

begin_define
define|#
directive|define
name|ST_UNKN
value|13
end_define

begin_comment
comment|/* unknown SMTP command */
end_comment

begin_define
define|#
directive|define
name|ST_Q_NC
value|14
end_define

begin_comment
comment|/* quit, new connection follows */
end_comment

begin_define
define|#
directive|define
name|ST_LAST
value|ST_Q_NC
end_define

begin_comment
comment|/* last valid state */
end_comment

begin_define
define|#
directive|define
name|ST_SKIP
value|16
end_define

begin_comment
comment|/* not a state but required for the state table */
end_comment

begin_comment
comment|/* in a mail transaction? must be before eom according to spec. */
end_comment

begin_define
define|#
directive|define
name|ST_IN_MAIL
parameter_list|(
name|st
parameter_list|)
value|((st)>= ST_MAIL&& (st)< ST_ENDM)
end_define

begin_comment
comment|/* **  set of next states **  each state (ST_*) corresponds to bit in an int value (1<< state) **  each state has a set of allowed transitions ('or' of bits of states) **  so a state transition is valid if the mask of the next state **  is set in the NX_* value **  this function is coded in trans_ok(), see below. */
end_comment

begin_define
define|#
directive|define
name|MI_MASK
parameter_list|(
name|x
parameter_list|)
value|(0x0001<< (x))
end_define

begin_comment
comment|/* generate a bit "mask" for a state */
end_comment

begin_define
define|#
directive|define
name|NX_INIT
value|(MI_MASK(ST_OPTS))
end_define

begin_define
define|#
directive|define
name|NX_OPTS
value|(MI_MASK(ST_CONN) | MI_MASK(ST_UNKN))
end_define

begin_define
define|#
directive|define
name|NX_CONN
value|(MI_MASK(ST_HELO) | MI_MASK(ST_MAIL) | MI_MASK(ST_UNKN))
end_define

begin_define
define|#
directive|define
name|NX_HELO
value|(MI_MASK(ST_HELO) | MI_MASK(ST_MAIL) | MI_MASK(ST_UNKN))
end_define

begin_define
define|#
directive|define
name|NX_MAIL
value|(MI_MASK(ST_RCPT) | MI_MASK(ST_ABRT) | MI_MASK(ST_UNKN))
end_define

begin_define
define|#
directive|define
name|NX_RCPT
value|(MI_MASK(ST_HDRS) | MI_MASK(ST_EOHS) | MI_MASK(ST_DATA) | \ 		 MI_MASK(ST_BODY) | MI_MASK(ST_ENDM) | \ 		 MI_MASK(ST_RCPT) | MI_MASK(ST_ABRT) | MI_MASK(ST_UNKN))
end_define

begin_define
define|#
directive|define
name|NX_DATA
value|(MI_MASK(ST_EOHS) | MI_MASK(ST_HDRS) | MI_MASK(ST_ABRT))
end_define

begin_define
define|#
directive|define
name|NX_HDRS
value|(MI_MASK(ST_EOHS) | MI_MASK(ST_HDRS) | MI_MASK(ST_ABRT))
end_define

begin_define
define|#
directive|define
name|NX_EOHS
value|(MI_MASK(ST_BODY) | MI_MASK(ST_ENDM) | MI_MASK(ST_ABRT))
end_define

begin_define
define|#
directive|define
name|NX_BODY
value|(MI_MASK(ST_ENDM) | MI_MASK(ST_BODY) | MI_MASK(ST_ABRT))
end_define

begin_define
define|#
directive|define
name|NX_ENDM
value|(MI_MASK(ST_QUIT) | MI_MASK(ST_MAIL) | MI_MASK(ST_UNKN) | \ 		MI_MASK(ST_Q_NC))
end_define

begin_define
define|#
directive|define
name|NX_QUIT
value|0
end_define

begin_define
define|#
directive|define
name|NX_ABRT
value|0
end_define

begin_define
define|#
directive|define
name|NX_UNKN
value|(MI_MASK(ST_HELO) | MI_MASK(ST_MAIL) | \ 		 MI_MASK(ST_RCPT) | MI_MASK(ST_ABRT) | \ 		 MI_MASK(ST_DATA) | \ 		 MI_MASK(ST_BODY) | MI_MASK(ST_UNKN) | \ 		 MI_MASK(ST_ABRT) | MI_MASK(ST_QUIT) | MI_MASK(ST_Q_NC))
end_define

begin_define
define|#
directive|define
name|NX_Q_NC
value|(MI_MASK(ST_CONN) | MI_MASK(ST_UNKN))
end_define

begin_define
define|#
directive|define
name|NX_SKIP
value|MI_MASK(ST_SKIP)
end_define

begin_decl_stmt
specifier|static
name|int
name|next_states
index|[]
init|=
block|{
name|NX_INIT
block|,
name|NX_OPTS
block|,
name|NX_CONN
block|,
name|NX_HELO
block|,
name|NX_MAIL
block|,
name|NX_RCPT
block|,
name|NX_DATA
block|,
name|NX_HDRS
block|,
name|NX_EOHS
block|,
name|NX_BODY
block|,
name|NX_ENDM
block|,
name|NX_QUIT
block|,
name|NX_ABRT
block|,
name|NX_UNKN
block|,
name|NX_Q_NC
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SIZE_NEXT_STATES
value|(sizeof(next_states) / sizeof(next_states[0]))
end_define

begin_comment
comment|/* commands received by milter */
end_comment

begin_decl_stmt
specifier|static
name|cmdfct
name|cmds
index|[]
init|=
block|{
block|{
name|SMFIC_ABORT
block|,
name|CM_ARG0
block|,
name|ST_ABRT
block|,
name|CT_CONT
block|,
name|CI_NONE
block|,
name|st_abortfct
block|}
block|,
block|{
name|SMFIC_MACRO
block|,
name|CM_ARGV
block|,
name|ST_NONE
block|,
name|CT_KEEP
block|,
name|CI_NONE
block|,
name|st_macros
block|}
block|,
block|{
name|SMFIC_BODY
block|,
name|CM_ARG1
block|,
name|ST_BODY
block|,
name|CT_CONT
block|,
name|CI_NONE
block|,
name|st_bodychunk
block|}
block|,
block|{
name|SMFIC_CONNECT
block|,
name|CM_ARG2
block|,
name|ST_CONN
block|,
name|CT_CONT
block|,
name|CI_CONN
block|,
name|st_connectinfo
block|}
block|,
block|{
name|SMFIC_BODYEOB
block|,
name|CM_ARG1
block|,
name|ST_ENDM
block|,
name|CT_CONT
block|,
name|CI_EOM
block|,
name|st_bodyend
block|}
block|,
block|{
name|SMFIC_HELO
block|,
name|CM_ARG1
block|,
name|ST_HELO
block|,
name|CT_CONT
block|,
name|CI_HELO
block|,
name|st_helo
block|}
block|,
block|{
name|SMFIC_HEADER
block|,
name|CM_ARG2
block|,
name|ST_HDRS
block|,
name|CT_CONT
block|,
name|CI_NONE
block|,
name|st_header
block|}
block|,
block|{
name|SMFIC_MAIL
block|,
name|CM_ARGV
block|,
name|ST_MAIL
block|,
name|CT_CONT
block|,
name|CI_MAIL
block|,
name|st_sender
block|}
block|,
block|{
name|SMFIC_OPTNEG
block|,
name|CM_ARGO
block|,
name|ST_OPTS
block|,
name|CT_CONT
block|,
name|CI_NONE
block|,
name|st_optionneg
block|}
block|,
block|{
name|SMFIC_EOH
block|,
name|CM_ARG0
block|,
name|ST_EOHS
block|,
name|CT_CONT
block|,
name|CI_EOH
block|,
name|st_eoh
block|}
block|,
block|{
name|SMFIC_QUIT
block|,
name|CM_ARG0
block|,
name|ST_QUIT
block|,
name|CT_END
block|,
name|CI_NONE
block|,
name|st_quit
block|}
block|,
block|{
name|SMFIC_DATA
block|,
name|CM_ARG0
block|,
name|ST_DATA
block|,
name|CT_CONT
block|,
name|CI_DATA
block|,
name|st_data
block|}
block|,
block|{
name|SMFIC_RCPT
block|,
name|CM_ARGV
block|,
name|ST_RCPT
block|,
name|CT_IGNO
block|,
name|CI_RCPT
block|,
name|st_rcpt
block|}
block|,
block|{
name|SMFIC_UNKNOWN
block|,
name|CM_ARG1
block|,
name|ST_UNKN
block|,
name|CT_IGNO
block|,
name|CI_NONE
block|,
name|st_unknown
block|}
block|,
block|{
name|SMFIC_QUIT_NC
block|,
name|CM_ARG0
block|,
name|ST_Q_NC
block|,
name|CT_CONT
block|,
name|CI_NONE
block|,
name|st_quit
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  Additional (internal) reply codes; **  must be coordinated wit libmilter/mfapi.h */
end_comment

begin_define
define|#
directive|define
name|_SMFIS_KEEP
value|20
end_define

begin_define
define|#
directive|define
name|_SMFIS_ABORT
value|21
end_define

begin_define
define|#
directive|define
name|_SMFIS_OPTIONS
value|22
end_define

begin_define
define|#
directive|define
name|_SMFIS_NOREPLY
value|SMFIS_NOREPLY
end_define

begin_define
define|#
directive|define
name|_SMFIS_FAIL
value|(-1)
end_define

begin_define
define|#
directive|define
name|_SMFIS_NONE
value|(-2)
end_define

begin_comment
comment|/* **  MI_ENGINE -- receive commands and process them ** **	Parameters: **		ctx -- context structure ** **	Returns: **		MI_FAILURE/MI_SUCCESS */
end_comment

begin_function
name|int
name|mi_engine
parameter_list|(
name|ctx
parameter_list|)
name|SMFICTX_PTR
name|ctx
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|socket_t
name|sd
decl_stmt|;
name|int
name|ret
init|=
name|MI_SUCCESS
decl_stmt|;
name|int
name|ncmds
init|=
sizeof|sizeof
argument_list|(
name|cmds
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|cmdfct
argument_list|)
decl_stmt|;
name|int
name|curstate
init|=
name|ST_INIT
decl_stmt|;
name|int
name|newstate
decl_stmt|;
name|bool
name|call_abort
decl_stmt|;
name|sfsistat
name|r
decl_stmt|;
name|char
name|cmd
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|genarg
name|arg
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
name|int
argument_list|(
argument|*f
argument_list|)
name|__P
argument_list|(
operator|(
name|genarg
operator|*
operator|)
argument_list|)
expr_stmt|;
name|sfsistat
argument_list|(
argument|*fi_abort
argument_list|)
name|__P
argument_list|(
operator|(
name|SMFICTX
operator|*
operator|)
argument_list|)
expr_stmt|;
name|sfsistat
argument_list|(
argument|*fi_close
argument_list|)
name|__P
argument_list|(
operator|(
name|SMFICTX
operator|*
operator|)
argument_list|)
expr_stmt|;
name|arg
operator|.
name|a_ctx
operator|=
name|ctx
expr_stmt|;
name|sd
operator|=
name|ctx
operator|->
name|ctx_sd
expr_stmt|;
name|fi_abort
operator|=
name|ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_abort
expr_stmt|;
if|#
directive|if
name|_FFR_WORKERS_POOL
name|curstate
operator|=
name|ctx
operator|->
name|ctx_state
expr_stmt|;
if|if
condition|(
name|curstate
operator|==
name|ST_INIT
condition|)
block|{
name|mi_clr_macros
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fix_stm
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* _FFR_WORKERS_POOL */
name|mi_clr_macros
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fix_stm
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_WORKERS_POOL */
name|r
operator|=
name|_SMFIS_NONE
expr_stmt|;
do|do
block|{
comment|/* call abort only if in a mail transaction */
name|call_abort
operator|=
name|ST_IN_MAIL
argument_list|(
name|curstate
argument_list|)
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
name|ctx
operator|->
name|ctx_timeout
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mi_stop
argument_list|()
operator|==
name|MILTER_ABRT
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|ctx_dbg
operator|>
literal|3
condition|)
name|sm_dprintf
argument_list|(
literal|"[%ld] milter_abort\n"
argument_list|,
operator|(
name|long
operator|)
name|ctx
operator|->
name|ctx_id
argument_list|)
expr_stmt|;
name|ret
operator|=
name|MI_FAILURE
expr_stmt|;
break|break;
block|}
comment|/* 		**  Notice: buf is allocated by mi_rd_cmd() and it will 		**  usually be free()d after it has been used in f(). 		**  However, if the function returns _SMFIS_KEEP then buf 		**  contains macros and will not be free()d. 		**  Hence r must be set to _SMFIS_NONE if a new buf is 		**  allocated to avoid problem with housekeeping, esp. 		**  if the code "break"s out of the loop. 		*/
if|#
directive|if
name|_FFR_WORKERS_POOL
comment|/* Is the socket ready to be read ??? */
if|if
condition|(
operator|!
name|mi_rd_socket_ready
argument_list|(
name|sd
argument_list|)
condition|)
block|{
name|ret
operator|=
name|MI_CONTINUE
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* _FFR_WORKERS_POOL */
name|r
operator|=
name|_SMFIS_NONE
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|mi_rd_cmd
argument_list|(
name|sd
argument_list|,
operator|&
name|timeout
argument_list|,
operator|&
name|cmd
argument_list|,
operator|&
name|len
argument_list|,
name|ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_name
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
name|cmd
operator|<
name|SMFIC_VALIDCMD
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|ctx_dbg
operator|>
literal|5
condition|)
name|sm_dprintf
argument_list|(
literal|"[%ld] mi_engine: mi_rd_cmd error (%x)\n"
argument_list|,
operator|(
name|long
operator|)
name|ctx
operator|->
name|ctx_id
argument_list|,
operator|(
name|int
operator|)
name|cmd
argument_list|)
expr_stmt|;
comment|/* 			**  eof is currently treated as failure -> 			**  abort() instead of close(), otherwise use: 			**  if (cmd != SMFIC_EOF) 			*/
name|ret
operator|=
name|MI_FAILURE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ctx
operator|->
name|ctx_dbg
operator|>
literal|4
condition|)
name|sm_dprintf
argument_list|(
literal|"[%ld] got cmd '%c' len %d\n"
argument_list|,
operator|(
name|long
operator|)
name|ctx
operator|->
name|ctx_id
argument_list|,
name|cmd
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncmds
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cmd
operator|==
name|cmds
index|[
name|i
index|]
operator|.
name|cm_cmd
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|ncmds
condition|)
block|{
comment|/* unknown command */
if|if
condition|(
name|ctx
operator|->
name|ctx_dbg
operator|>
literal|1
condition|)
name|sm_dprintf
argument_list|(
literal|"[%ld] cmd '%c' unknown\n"
argument_list|,
operator|(
name|long
operator|)
name|ctx
operator|->
name|ctx_id
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|MI_FAILURE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|f
operator|=
name|cmds
index|[
name|i
index|]
operator|.
name|cm_fct
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* stop for now */
if|if
condition|(
name|ctx
operator|->
name|ctx_dbg
operator|>
literal|1
condition|)
name|sm_dprintf
argument_list|(
literal|"[%ld] cmd '%c' not impl\n"
argument_list|,
operator|(
name|long
operator|)
name|ctx
operator|->
name|ctx_id
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|MI_FAILURE
expr_stmt|;
break|break;
block|}
comment|/* is new state ok? */
name|newstate
operator|=
name|cmds
index|[
name|i
index|]
operator|.
name|cm_next
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|ctx_dbg
operator|>
literal|5
condition|)
name|sm_dprintf
argument_list|(
literal|"[%ld] cur %x new %x nextmask %x\n"
argument_list|,
operator|(
name|long
operator|)
name|ctx
operator|->
name|ctx_id
argument_list|,
name|curstate
argument_list|,
name|newstate
argument_list|,
name|next_states
index|[
name|curstate
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|newstate
operator|!=
name|ST_NONE
operator|&&
operator|!
name|trans_ok
argument_list|(
name|curstate
argument_list|,
name|newstate
argument_list|)
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|ctx_dbg
operator|>
literal|1
condition|)
name|sm_dprintf
argument_list|(
literal|"[%ld] abort: cur %d (%x) new %d (%x) next %x\n"
argument_list|,
operator|(
name|long
operator|)
name|ctx
operator|->
name|ctx_id
argument_list|,
name|curstate
argument_list|,
name|MI_MASK
argument_list|(
name|curstate
argument_list|)
argument_list|,
name|newstate
argument_list|,
name|MI_MASK
argument_list|(
name|newstate
argument_list|)
argument_list|,
name|next_states
index|[
name|curstate
index|]
argument_list|)
expr_stmt|;
comment|/* call abort only if in a mail transaction */
if|if
condition|(
name|fi_abort
operator|!=
name|NULL
operator|&&
name|call_abort
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|fi_abort
argument_list|)
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
comment|/* 			**  try to reach the new state from HELO 			**  if it can't be reached, ignore the command. 			*/
name|curstate
operator|=
name|ST_HELO
expr_stmt|;
if|if
condition|(
operator|!
name|trans_ok
argument_list|(
name|curstate
argument_list|,
name|newstate
argument_list|)
condition|)
block|{
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
continue|continue;
block|}
block|}
name|arg
operator|.
name|a_len
operator|=
name|len
expr_stmt|;
name|arg
operator|.
name|a_buf
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|newstate
operator|!=
name|ST_NONE
condition|)
block|{
name|curstate
operator|=
name|newstate
expr_stmt|;
name|ctx
operator|->
name|ctx_state
operator|=
name|curstate
expr_stmt|;
block|}
name|arg
operator|.
name|a_idx
operator|=
name|cmds
index|[
name|i
index|]
operator|.
name|cm_macros
expr_stmt|;
name|call_abort
operator|=
name|ST_IN_MAIL
argument_list|(
name|curstate
argument_list|)
expr_stmt|;
comment|/* call function to deal with command */
name|MI_MONITOR_BEGIN
argument_list|(
name|ctx
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|r
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
name|MI_MONITOR_END
argument_list|(
name|ctx
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|_SMFIS_KEEP
operator|&&
name|buf
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sendreply
argument_list|(
name|r
argument_list|,
name|sd
argument_list|,
operator|&
name|timeout
argument_list|,
name|ctx
argument_list|)
operator|!=
name|MI_SUCCESS
condition|)
block|{
name|ret
operator|=
name|MI_FAILURE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|r
operator|==
name|SMFIS_ACCEPT
condition|)
block|{
comment|/* accept mail, no further actions taken */
name|curstate
operator|=
name|ST_HELO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
name|SMFIS_REJECT
operator|||
name|r
operator|==
name|SMFIS_DISCARD
operator|||
name|r
operator|==
name|SMFIS_TEMPFAIL
condition|)
block|{
comment|/* 			**  further actions depend on current state 			**  if the IGNO bit is set: "ignore" the error, 			**  i.e., stay in the current state 			*/
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|CT_IGNO
argument_list|,
name|cmds
index|[
name|i
index|]
operator|.
name|cm_todo
argument_list|)
condition|)
name|curstate
operator|=
name|ST_HELO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
name|_SMFIS_ABORT
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|ctx_dbg
operator|>
literal|5
condition|)
name|sm_dprintf
argument_list|(
literal|"[%ld] function returned abort\n"
argument_list|,
operator|(
name|long
operator|)
name|ctx
operator|->
name|ctx_id
argument_list|)
expr_stmt|;
name|ret
operator|=
name|MI_FAILURE
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|!
name|bitset
argument_list|(
name|CT_END
argument_list|,
name|cmds
index|[
name|i
index|]
operator|.
name|cm_todo
argument_list|)
condition|)
do|;
name|ctx
operator|->
name|ctx_state
operator|=
name|curstate
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|MI_FAILURE
condition|)
block|{
comment|/* call abort only if in a mail transaction */
if|if
condition|(
name|fi_abort
operator|!=
name|NULL
operator|&&
name|call_abort
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|fi_abort
argument_list|)
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
comment|/* has close been called? */
if|if
condition|(
name|ctx
operator|->
name|ctx_state
operator|!=
name|ST_QUIT
if|#
directive|if
name|_FFR_WORKERS_POOL
operator|&&
name|ret
operator|!=
name|MI_CONTINUE
endif|#
directive|endif
comment|/* _FFR_WORKERS_POOL */
condition|)
block|{
if|if
condition|(
operator|(
name|fi_close
operator|=
name|ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_close
operator|)
operator|!=
name|NULL
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|fi_close
argument_list|)
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|!=
name|_SMFIS_KEEP
operator|&&
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|_FFR_WORKERS_POOL
name|mi_clr_macros
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_WORKERS_POOL */
return|return
name|ret
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|size_t
name|milter_addsymlist
name|__P
argument_list|(
operator|(
name|SMFICTX_PTR
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|size_t
name|milter_addsymlist
parameter_list|(
name|ctx
parameter_list|,
name|buf
parameter_list|,
name|newbuf
parameter_list|)
name|SMFICTX_PTR
name|ctx
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
modifier|*
name|newbuf
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mi_int32
name|v
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|SM_ASSERT
argument_list|(
name|ctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SM_ASSERT
argument_list|(
name|buf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SM_ASSERT
argument_list|(
name|newbuf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_MACROS_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ctx
operator|->
name|ctx_mac_list
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|len
operator|+=
name|strlen
argument_list|(
name|ctx
operator|->
name|ctx_mac_list
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
operator|+
name|MILTER_LEN_BYTES
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|size_t
name|offset
decl_stmt|;
name|SM_ASSERT
argument_list|(
name|len
operator|+
name|MILTER_OPTLEN
operator|>
name|len
argument_list|)
expr_stmt|;
name|len
operator|+=
name|MILTER_OPTLEN
expr_stmt|;
name|buffer
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|buf
argument_list|,
name|MILTER_OPTLEN
argument_list|)
expr_stmt|;
name|offset
operator|=
name|MILTER_OPTLEN
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_MACROS_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|l
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|ctx_mac_list
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|SM_ASSERT
argument_list|(
name|offset
operator|+
name|MILTER_LEN_BYTES
operator|<
name|len
argument_list|)
expr_stmt|;
name|v
operator|=
name|htonl
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|buffer
operator|+
name|offset
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|v
argument_list|,
name|MILTER_LEN_BYTES
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|MILTER_LEN_BYTES
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|ctx
operator|->
name|ctx_mac_list
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|SM_ASSERT
argument_list|(
name|offset
operator|+
name|l
operator|<=
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|buffer
operator|+
name|offset
argument_list|,
name|ctx
operator|->
name|ctx_mac_list
index|[
name|i
index|]
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|l
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* oops ... */
block|}
block|}
else|else
block|{
name|len
operator|=
name|MILTER_OPTLEN
expr_stmt|;
name|buffer
operator|=
name|buf
expr_stmt|;
block|}
operator|*
name|newbuf
operator|=
name|buffer
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* **  GET_NR_BIT -- get "no reply" bit matching state ** **	Parameters: **		state -- current protocol stage ** **	Returns: **		0: no matching bit **>0: the matching "no reply" bit */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|get_nr_bit
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|long
name|get_nr_bit
parameter_list|(
name|state
parameter_list|)
name|int
name|state
decl_stmt|;
block|{
name|unsigned
name|long
name|bit
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|ST_CONN
case|:
name|bit
operator|=
name|SMFIP_NR_CONN
expr_stmt|;
break|break;
case|case
name|ST_HELO
case|:
name|bit
operator|=
name|SMFIP_NR_HELO
expr_stmt|;
break|break;
case|case
name|ST_MAIL
case|:
name|bit
operator|=
name|SMFIP_NR_MAIL
expr_stmt|;
break|break;
case|case
name|ST_RCPT
case|:
name|bit
operator|=
name|SMFIP_NR_RCPT
expr_stmt|;
break|break;
case|case
name|ST_DATA
case|:
name|bit
operator|=
name|SMFIP_NR_DATA
expr_stmt|;
break|break;
case|case
name|ST_UNKN
case|:
name|bit
operator|=
name|SMFIP_NR_UNKN
expr_stmt|;
break|break;
case|case
name|ST_HDRS
case|:
name|bit
operator|=
name|SMFIP_NR_HDR
expr_stmt|;
break|break;
case|case
name|ST_EOHS
case|:
name|bit
operator|=
name|SMFIP_NR_EOH
expr_stmt|;
break|break;
case|case
name|ST_BODY
case|:
name|bit
operator|=
name|SMFIP_NR_BODY
expr_stmt|;
break|break;
default|default:
name|bit
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|bit
return|;
block|}
end_function

begin_comment
comment|/* **  SENDREPLY -- send a reply to the MTA ** **	Parameters: **		r -- reply code **		sd -- socket descriptor **		timeout_ptr -- (ptr to) timeout to use for sending **		ctx -- context structure ** **	Returns: **		MI_SUCCESS/MI_FAILURE */
end_comment

begin_function
specifier|static
name|int
name|sendreply
parameter_list|(
name|r
parameter_list|,
name|sd
parameter_list|,
name|timeout_ptr
parameter_list|,
name|ctx
parameter_list|)
name|sfsistat
name|r
decl_stmt|;
name|socket_t
name|sd
decl_stmt|;
name|struct
name|timeval
modifier|*
name|timeout_ptr
decl_stmt|;
name|SMFICTX_PTR
name|ctx
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
name|unsigned
name|long
name|bit
decl_stmt|;
name|ret
operator|=
name|MI_SUCCESS
expr_stmt|;
name|bit
operator|=
name|get_nr_bit
argument_list|(
name|ctx
operator|->
name|ctx_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit
operator|!=
literal|0
operator|&&
operator|(
name|ctx
operator|->
name|ctx_pflags
operator|&
name|bit
operator|)
operator|!=
literal|0
operator|&&
name|r
operator|!=
name|SMFIS_NOREPLY
condition|)
block|{
if|if
condition|(
name|r
operator|>=
name|SMFIS_CONTINUE
operator|&&
name|r
operator|<
name|_SMFIS_KEEP
condition|)
block|{
comment|/* milter said it wouldn't reply, but it lied... */
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: milter claimed not to reply in state %d but did anyway %d\n"
argument_list|,
name|ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_name
argument_list|,
name|ctx
operator|->
name|ctx_state
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
comment|/* 		**  Force specified behavior, otherwise libmilter 		**  and MTA will fail to communicate properly. 		*/
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|SMFIS_CONTINUE
case|:
case|case
name|SMFIS_TEMPFAIL
case|:
case|case
name|SMFIS_REJECT
case|:
case|case
name|SMFIS_DISCARD
case|:
case|case
name|SMFIS_ACCEPT
case|:
case|case
name|SMFIS_SKIP
case|:
case|case
name|_SMFIS_OPTIONS
case|:
name|r
operator|=
name|SMFIS_NOREPLY
expr_stmt|;
break|break;
block|}
block|}
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|SMFIS_CONTINUE
case|:
name|ret
operator|=
name|mi_wr_cmd
argument_list|(
name|sd
argument_list|,
name|timeout_ptr
argument_list|,
name|SMFIR_CONTINUE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMFIS_TEMPFAIL
case|:
case|case
name|SMFIS_REJECT
case|:
if|if
condition|(
name|ctx
operator|->
name|ctx_reply
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|r
operator|==
name|SMFIS_TEMPFAIL
operator|&&
operator|*
name|ctx
operator|->
name|ctx_reply
operator|==
literal|'4'
operator|)
operator|||
operator|(
name|r
operator|==
name|SMFIS_REJECT
operator|&&
operator|*
name|ctx
operator|->
name|ctx_reply
operator|==
literal|'5'
operator|)
operator|)
condition|)
block|{
name|ret
operator|=
name|mi_wr_cmd
argument_list|(
name|sd
argument_list|,
name|timeout_ptr
argument_list|,
name|SMFIR_REPLYCODE
argument_list|,
name|ctx
operator|->
name|ctx_reply
argument_list|,
name|strlen
argument_list|(
name|ctx
operator|->
name|ctx_reply
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
operator|->
name|ctx_reply
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ctx_reply
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|mi_wr_cmd
argument_list|(
name|sd
argument_list|,
name|timeout_ptr
argument_list|,
name|r
operator|==
name|SMFIS_REJECT
condition|?
name|SMFIR_REJECT
else|:
name|SMFIR_TEMPFAIL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SMFIS_DISCARD
case|:
name|ret
operator|=
name|mi_wr_cmd
argument_list|(
name|sd
argument_list|,
name|timeout_ptr
argument_list|,
name|SMFIR_DISCARD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMFIS_ACCEPT
case|:
name|ret
operator|=
name|mi_wr_cmd
argument_list|(
name|sd
argument_list|,
name|timeout_ptr
argument_list|,
name|SMFIR_ACCEPT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMFIS_SKIP
case|:
name|ret
operator|=
name|mi_wr_cmd
argument_list|(
name|sd
argument_list|,
name|timeout_ptr
argument_list|,
name|SMFIR_SKIP
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|_SMFIS_OPTIONS
case|:
block|{
name|mi_int32
name|v
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|char
name|buf
index|[
name|MILTER_OPTLEN
index|]
decl_stmt|;
name|v
operator|=
name|htonl
argument_list|(
name|ctx
operator|->
name|ctx_prot_vers2mta
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|&
operator|(
name|buf
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|v
argument_list|,
name|MILTER_LEN_BYTES
argument_list|)
expr_stmt|;
name|v
operator|=
name|htonl
argument_list|(
name|ctx
operator|->
name|ctx_aflags
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|&
operator|(
name|buf
index|[
name|MILTER_LEN_BYTES
index|]
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|v
argument_list|,
name|MILTER_LEN_BYTES
argument_list|)
expr_stmt|;
name|v
operator|=
name|htonl
argument_list|(
name|ctx
operator|->
name|ctx_pflags2mta
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|&
operator|(
name|buf
index|[
name|MILTER_LEN_BYTES
operator|*
literal|2
index|]
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|v
argument_list|,
name|MILTER_LEN_BYTES
argument_list|)
expr_stmt|;
name|len
operator|=
name|milter_addsymlist
argument_list|(
name|ctx
argument_list|,
name|buf
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|!=
name|NULL
condition|)
name|ret
operator|=
name|mi_wr_cmd
argument_list|(
name|sd
argument_list|,
name|timeout_ptr
argument_list|,
name|SMFIC_OPTNEG
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|MI_FAILURE
expr_stmt|;
block|}
break|break;
case|case
name|SMFIS_NOREPLY
case|:
if|if
condition|(
name|bit
operator|!=
literal|0
operator|&&
operator|(
name|ctx
operator|->
name|ctx_pflags
operator|&
name|bit
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ctx
operator|->
name|ctx_mta_pflags
operator|&
name|bit
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			**  milter doesn't want to send a reply, 			**  but the MTA doesn't have that feature: fake it. 			*/
name|ret
operator|=
name|mi_wr_cmd
argument_list|(
name|sd
argument_list|,
name|timeout_ptr
argument_list|,
name|SMFIR_CONTINUE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* don't send a reply */
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* **  CLR_MACROS -- clear set of macros starting from a given index ** **	Parameters: **		ctx -- context structure **		m -- index from which to clear all macros ** **	Returns: **		None. */
end_comment

begin_function
name|void
name|mi_clr_macros
parameter_list|(
name|ctx
parameter_list|,
name|m
parameter_list|)
name|SMFICTX_PTR
name|ctx
decl_stmt|;
name|int
name|m
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|m
init|;
name|i
operator|<
name|MAX_MACROS_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ctx
operator|->
name|ctx_mac_ptr
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ctx
operator|->
name|ctx_mac_ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ctx_mac_ptr
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|ctx_mac_buf
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ctx
operator|->
name|ctx_mac_buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ctx_mac_buf
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* **  ST_OPTIONNEG -- negotiate options ** **	Parameters: **		g -- generic argument structure ** **	Returns: **		abort/send options/continue */
end_comment

begin_function
specifier|static
name|int
name|st_optionneg
parameter_list|(
name|g
parameter_list|)
name|genarg
modifier|*
name|g
decl_stmt|;
block|{
name|mi_int32
name|i
decl_stmt|,
name|v
decl_stmt|,
name|fake_pflags
decl_stmt|;
name|SMFICTX_PTR
name|ctx
decl_stmt|;
name|int
argument_list|(
argument|*fi_negotiate
argument_list|)
name|__P
argument_list|(
operator|(
name|SMFICTX
operator|*
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|*
operator|,
name|unsigned
name|long
operator|*
operator|,
name|unsigned
name|long
operator|*
operator|,
name|unsigned
name|long
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
operator|||
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|==
name|NULL
condition|)
return|return
name|SMFIS_CONTINUE
return|;
name|ctx
operator|=
name|g
operator|->
name|a_ctx
expr_stmt|;
name|mi_clr_macros
argument_list|(
name|ctx
argument_list|,
name|g
operator|->
name|a_idx
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ctx_prot_vers
operator|=
name|SMFI_PROT_VERSION
expr_stmt|;
comment|/* check for minimum length */
if|if
condition|(
name|g
operator|->
name|a_len
operator|<
name|MILTER_OPTLEN
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: st_optionneg[%ld]: len too short %d< %d"
argument_list|,
name|ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_name
argument_list|,
operator|(
name|long
operator|)
name|ctx
operator|->
name|ctx_id
argument_list|,
operator|(
name|int
operator|)
name|g
operator|->
name|a_len
argument_list|,
name|MILTER_OPTLEN
argument_list|)
expr_stmt|;
return|return
name|_SMFIS_ABORT
return|;
block|}
comment|/* protocol version */
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|g
operator|->
name|a_buf
index|[
literal|0
index|]
operator|)
argument_list|,
name|MILTER_LEN_BYTES
argument_list|)
expr_stmt|;
name|v
operator|=
name|ntohl
argument_list|(
name|i
argument_list|)
expr_stmt|;
define|#
directive|define
name|SMFI_PROT_VERSION_MIN
value|2
comment|/* check for minimum version */
if|if
condition|(
name|v
operator|<
name|SMFI_PROT_VERSION_MIN
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: st_optionneg[%ld]: protocol version too old %d< %d"
argument_list|,
name|ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_name
argument_list|,
operator|(
name|long
operator|)
name|ctx
operator|->
name|ctx_id
argument_list|,
name|v
argument_list|,
name|SMFI_PROT_VERSION_MIN
argument_list|)
expr_stmt|;
return|return
name|_SMFIS_ABORT
return|;
block|}
name|ctx
operator|->
name|ctx_mta_prot_vers
operator|=
name|v
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|ctx_prot_vers
operator|<
name|ctx
operator|->
name|ctx_mta_prot_vers
condition|)
name|ctx
operator|->
name|ctx_prot_vers2mta
operator|=
name|ctx
operator|->
name|ctx_prot_vers
expr_stmt|;
else|else
name|ctx
operator|->
name|ctx_prot_vers2mta
operator|=
name|ctx
operator|->
name|ctx_mta_prot_vers
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|g
operator|->
name|a_buf
index|[
name|MILTER_LEN_BYTES
index|]
operator|)
argument_list|,
name|MILTER_LEN_BYTES
argument_list|)
expr_stmt|;
name|v
operator|=
name|ntohl
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* no flags? set to default value for V1 actions */
if|if
condition|(
name|v
operator|==
literal|0
condition|)
name|v
operator|=
name|SMFI_V1_ACTS
expr_stmt|;
name|ctx
operator|->
name|ctx_mta_aflags
operator|=
name|v
expr_stmt|;
comment|/* MTA action flags */
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|g
operator|->
name|a_buf
index|[
name|MILTER_LEN_BYTES
operator|*
literal|2
index|]
operator|)
argument_list|,
name|MILTER_LEN_BYTES
argument_list|)
expr_stmt|;
name|v
operator|=
name|ntohl
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* no flags? set to default value for V1 protocol */
if|if
condition|(
name|v
operator|==
literal|0
condition|)
name|v
operator|=
name|SMFI_V1_PROT
expr_stmt|;
name|ctx
operator|->
name|ctx_mta_pflags
operator|=
name|v
expr_stmt|;
comment|/* MTA protocol flags */
comment|/* 	**  Copy flags from milter struct into libmilter context; 	**  this variable will be used later on to check whether 	**  the MTA "actions" can fulfill the milter requirements, 	**  but it may be overwritten by the negotiate callback. 	*/
name|ctx
operator|->
name|ctx_aflags
operator|=
name|ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_flags
expr_stmt|;
name|fake_pflags
operator|=
name|SMFIP_NR_CONN
operator||
name|SMFIP_NR_HELO
operator||
name|SMFIP_NR_MAIL
operator||
name|SMFIP_NR_RCPT
operator||
name|SMFIP_NR_DATA
operator||
name|SMFIP_NR_UNKN
operator||
name|SMFIP_NR_HDR
operator||
name|SMFIP_NR_EOH
operator||
name|SMFIP_NR_BODY
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|!=
name|NULL
operator|&&
operator|(
name|fi_negotiate
operator|=
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_negotiate
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|r
decl_stmt|;
name|unsigned
name|long
name|m_aflags
decl_stmt|,
name|m_pflags
decl_stmt|,
name|m_f2
decl_stmt|,
name|m_f3
decl_stmt|;
comment|/* 		**  let milter decide whether the features offered by the 		**  MTA are "good enough". 		**  Notes: 		**  - libmilter can "fake" some features (e.g., SMFIP_NR_HDR) 		**  - m_f2, m_f3 are for future extensions 		*/
name|m_f2
operator|=
name|m_f3
operator|=
literal|0
expr_stmt|;
name|m_aflags
operator|=
name|ctx
operator|->
name|ctx_mta_aflags
expr_stmt|;
name|m_pflags
operator|=
name|ctx
operator|->
name|ctx_pflags
expr_stmt|;
if|if
condition|(
operator|(
name|SMFIP_SKIP
operator|&
name|ctx
operator|->
name|ctx_mta_pflags
operator|)
operator|!=
literal|0
condition|)
name|m_pflags
operator||=
name|SMFIP_SKIP
expr_stmt|;
name|r
operator|=
name|fi_negotiate
argument_list|(
name|g
operator|->
name|a_ctx
argument_list|,
name|ctx
operator|->
name|ctx_mta_aflags
argument_list|,
name|ctx
operator|->
name|ctx_mta_pflags
operator||
name|fake_pflags
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|m_aflags
argument_list|,
operator|&
name|m_pflags
argument_list|,
operator|&
name|m_f2
argument_list|,
operator|&
name|m_f3
argument_list|)
expr_stmt|;
comment|/* 		**  Types of protocol flags (pflags): 		**  1. do NOT send protocol step X 		**  2. MTA can do/understand something extra (SKIP, 		**	send unknown RCPTs) 		**  3. MTA can deal with "no reply" for various protocol steps 		**  Note: this mean that it isn't possible to simply set all 		**	flags to get "everything": 		**	setting a flag of type 1 turns off a step 		**		(it should be the other way around: 		**		a flag means a protocol step can be sent) 		**	setting a flag of type 3 requires that milter 		**	never sends a reply for the corresponding step. 		**  Summary: the "negation" of protocol flags is causing 		**	problems, but at least for type 3 there is no simple 		**	solution. 		** 		**  What should "all options" mean? 		**  send all protocol steps _except_ those for which there is 		**	no callback (currently registered in ctx_pflags) 		**  expect SKIP as return code?		Yes 		**  send unknown RCPTs?			No, 		**				must be explicitly requested? 		**  "no reply" for some protocol steps?	No, 		**				must be explicitly requested. 		*/
if|if
condition|(
name|SMFIS_ALL_OPTS
operator|==
name|r
condition|)
block|{
name|ctx
operator|->
name|ctx_aflags
operator|=
name|ctx
operator|->
name|ctx_mta_aflags
expr_stmt|;
name|ctx
operator|->
name|ctx_pflags2mta
operator|=
name|ctx
operator|->
name|ctx_pflags
expr_stmt|;
if|if
condition|(
operator|(
name|SMFIP_SKIP
operator|&
name|ctx
operator|->
name|ctx_mta_pflags
operator|)
operator|!=
literal|0
condition|)
name|ctx
operator|->
name|ctx_pflags2mta
operator||=
name|SMFIP_SKIP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|!=
name|SMFIS_CONTINUE
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: st_optionneg[%ld]: xxfi_negotiate returned %d (protocol options=0x%lx, actions=0x%lx)"
argument_list|,
name|ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_name
argument_list|,
operator|(
name|long
operator|)
name|ctx
operator|->
name|ctx_id
argument_list|,
name|r
argument_list|,
name|ctx
operator|->
name|ctx_mta_pflags
argument_list|,
name|ctx
operator|->
name|ctx_mta_aflags
argument_list|)
expr_stmt|;
return|return
name|_SMFIS_ABORT
return|;
block|}
else|else
block|{
name|ctx
operator|->
name|ctx_aflags
operator|=
name|m_aflags
expr_stmt|;
name|ctx
operator|->
name|ctx_pflags
operator|=
name|m_pflags
expr_stmt|;
name|ctx
operator|->
name|ctx_pflags2mta
operator|=
name|m_pflags
expr_stmt|;
block|}
comment|/* check whether some flags need to be "faked" */
name|i
operator|=
name|ctx
operator|->
name|ctx_pflags2mta
expr_stmt|;
if|if
condition|(
operator|(
name|ctx
operator|->
name|ctx_mta_pflags
operator|&
name|i
operator|)
operator|!=
name|i
condition|)
block|{
name|unsigned
name|int
name|idx
decl_stmt|;
name|unsigned
name|long
name|b
decl_stmt|;
comment|/* 			**  If some behavior can be faked (set in fake_pflags), 			**  but the MTA doesn't support it, then unset 			**  that flag in the value that is sent to the MTA. 			*/
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
literal|32
condition|;
name|idx
operator|++
control|)
block|{
name|b
operator|=
literal|1
operator|<<
name|idx
expr_stmt|;
if|if
condition|(
operator|(
name|ctx
operator|->
name|ctx_mta_pflags
operator|&
name|b
operator|)
operator|!=
name|b
operator|&&
operator|(
name|fake_pflags
operator|&
name|b
operator|)
operator|==
name|b
condition|)
name|ctx
operator|->
name|ctx_pflags2mta
operator|&=
operator|~
name|b
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		**  Set the protocol flags based on the values determined 		**  in mi_listener() which checked the defined callbacks. 		*/
name|ctx
operator|->
name|ctx_pflags2mta
operator|=
name|ctx
operator|->
name|ctx_pflags
expr_stmt|;
block|}
comment|/* check whether actions and protocol requirements can be satisfied */
name|i
operator|=
name|ctx
operator|->
name|ctx_aflags
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
name|ctx
operator|->
name|ctx_mta_aflags
operator|)
operator|!=
name|i
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: st_optionneg[%ld]: 0x%lx does not fulfill action requirements 0x%x"
argument_list|,
name|ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_name
argument_list|,
operator|(
name|long
operator|)
name|ctx
operator|->
name|ctx_id
argument_list|,
name|ctx
operator|->
name|ctx_mta_aflags
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|_SMFIS_ABORT
return|;
block|}
name|i
operator|=
name|ctx
operator|->
name|ctx_pflags2mta
expr_stmt|;
if|if
condition|(
operator|(
name|ctx
operator|->
name|ctx_mta_pflags
operator|&
name|i
operator|)
operator|!=
name|i
condition|)
block|{
comment|/* 		**  Older MTAs do not support some protocol steps. 		**  As this protocol is a bit "wierd" (it asks for steps 		**  NOT to be taken/sent) we have to check whether we 		**  should turn off those "negative" requests. 		**  Currently these are only SMFIP_NODATA and SMFIP_NOUNKNOWN. 		*/
if|if
condition|(
name|bitset
argument_list|(
name|SMFIP_NODATA
argument_list|,
name|ctx
operator|->
name|ctx_pflags2mta
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|SMFIP_NODATA
argument_list|,
name|ctx
operator|->
name|ctx_mta_pflags
argument_list|)
condition|)
name|ctx
operator|->
name|ctx_pflags2mta
operator|&=
operator|~
name|SMFIP_NODATA
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|SMFIP_NOUNKNOWN
argument_list|,
name|ctx
operator|->
name|ctx_pflags2mta
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|SMFIP_NOUNKNOWN
argument_list|,
name|ctx
operator|->
name|ctx_mta_pflags
argument_list|)
condition|)
name|ctx
operator|->
name|ctx_pflags2mta
operator|&=
operator|~
name|SMFIP_NOUNKNOWN
expr_stmt|;
name|i
operator|=
name|ctx
operator|->
name|ctx_pflags2mta
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ctx
operator|->
name|ctx_mta_pflags
operator|&
name|i
operator|)
operator|!=
name|i
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: st_optionneg[%ld]: 0x%lx does not fulfill protocol requirements 0x%x"
argument_list|,
name|ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_name
argument_list|,
operator|(
name|long
operator|)
name|ctx
operator|->
name|ctx_id
argument_list|,
name|ctx
operator|->
name|ctx_mta_pflags
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|_SMFIS_ABORT
return|;
block|}
if|if
condition|(
name|ctx
operator|->
name|ctx_dbg
operator|>
literal|3
condition|)
name|sm_dprintf
argument_list|(
literal|"[%ld] milter_negotiate:"
literal|" mta_actions=0x%lx, mta_flags=0x%lx"
literal|" actions=0x%lx, flags=0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|ctx
operator|->
name|ctx_id
argument_list|,
name|ctx
operator|->
name|ctx_mta_aflags
argument_list|,
name|ctx
operator|->
name|ctx_mta_pflags
argument_list|,
name|ctx
operator|->
name|ctx_aflags
argument_list|,
name|ctx
operator|->
name|ctx_pflags
argument_list|)
expr_stmt|;
return|return
name|_SMFIS_OPTIONS
return|;
block|}
end_function

begin_comment
comment|/* **  ST_CONNECTINFO -- receive connection information ** **	Parameters: **		g -- generic argument structure ** **	Returns: **		continue or filter-specified value */
end_comment

begin_function
specifier|static
name|int
name|st_connectinfo
parameter_list|(
name|g
parameter_list|)
name|genarg
modifier|*
name|g
decl_stmt|;
block|{
name|size_t
name|l
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
name|family
decl_stmt|;
name|unsigned
name|short
name|port
init|=
literal|0
decl_stmt|;
name|_SOCK_ADDR
name|sockaddr
decl_stmt|;
name|sfsistat
argument_list|(
argument|*fi_connect
argument_list|)
name|__P
argument_list|(
operator|(
name|SMFICTX
operator|*
operator|,
name|char
operator|*
operator|,
name|_SOCK_ADDR
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
return|return
name|_SMFIS_ABORT
return|;
name|mi_clr_macros
argument_list|(
name|g
operator|->
name|a_ctx
argument_list|,
name|g
operator|->
name|a_idx
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|==
name|NULL
operator|||
operator|(
name|fi_connect
operator|=
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_connect
operator|)
operator|==
name|NULL
condition|)
return|return
name|SMFIS_CONTINUE
return|;
name|s
operator|=
name|g
operator|->
name|a_buf
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|l
operator|=
name|g
operator|->
name|a_len
expr_stmt|;
while|while
condition|(
name|s
index|[
name|i
index|]
operator|!=
literal|'\0'
operator|&&
name|i
operator|<=
name|l
condition|)
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|>=
name|l
condition|)
return|return
name|_SMFIS_ABORT
return|;
comment|/* Move past trailing \0 in host string */
name|i
operator|++
expr_stmt|;
name|family
operator|=
name|s
index|[
name|i
operator|++
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|&
name|sockaddr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|sockaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|family
operator|!=
name|SMFIA_UNKNOWN
condition|)
block|{
if|if
condition|(
name|i
operator|+
sizeof|sizeof
name|port
operator|>=
name|l
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: connect[%ld]: wrong len %d>= %d"
argument_list|,
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_name
argument_list|,
operator|(
name|long
operator|)
name|g
operator|->
name|a_ctx
operator|->
name|ctx_id
argument_list|,
operator|(
name|int
operator|)
name|i
argument_list|,
operator|(
name|int
operator|)
name|l
argument_list|)
expr_stmt|;
return|return
name|_SMFIS_ABORT
return|;
block|}
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|port
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|s
operator|+
name|i
operator|)
argument_list|,
sizeof|sizeof
name|port
argument_list|)
expr_stmt|;
name|i
operator|+=
sizeof|sizeof
name|port
expr_stmt|;
comment|/* make sure string is terminated */
if|if
condition|(
name|s
index|[
name|l
operator|-
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
name|_SMFIS_ABORT
return|;
if|#
directive|if
name|NETINET
if|if
condition|(
name|family
operator|==
name|SMFIA_INET
condition|)
block|{
if|if
condition|(
name|inet_aton
argument_list|(
name|s
operator|+
name|i
argument_list|,
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
name|sockaddr
operator|.
name|sin
operator|.
name|sin_addr
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: connect[%ld]: inet_aton failed"
argument_list|,
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_name
argument_list|,
operator|(
name|long
operator|)
name|g
operator|->
name|a_ctx
operator|->
name|ctx_id
argument_list|)
expr_stmt|;
return|return
name|_SMFIS_ABORT
return|;
block|}
name|sockaddr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
if|if
condition|(
name|port
operator|>
literal|0
condition|)
name|sockaddr
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET6
if|if
condition|(
name|family
operator|==
name|SMFIA_INET6
condition|)
block|{
if|if
condition|(
name|mi_inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|s
operator|+
name|i
argument_list|,
operator|&
name|sockaddr
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: connect[%ld]: mi_inet_pton failed"
argument_list|,
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_name
argument_list|,
operator|(
name|long
operator|)
name|g
operator|->
name|a_ctx
operator|->
name|ctx_id
argument_list|)
expr_stmt|;
return|return
name|_SMFIS_ABORT
return|;
block|}
name|sockaddr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET6
expr_stmt|;
if|if
condition|(
name|port
operator|>
literal|0
condition|)
name|sockaddr
operator|.
name|sin6
operator|.
name|sin6_port
operator|=
name|port
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* NETINET6 */
if|#
directive|if
name|NETUNIX
if|if
condition|(
name|family
operator|==
name|SMFIA_UNIX
condition|)
block|{
if|if
condition|(
name|sm_strlcpy
argument_list|(
name|sockaddr
operator|.
name|sunix
operator|.
name|sun_path
argument_list|,
name|s
operator|+
name|i
argument_list|,
sizeof|sizeof
name|sockaddr
operator|.
name|sunix
operator|.
name|sun_path
argument_list|)
operator|>=
sizeof|sizeof
name|sockaddr
operator|.
name|sunix
operator|.
name|sun_path
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: connect[%ld]: path too long"
argument_list|,
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_name
argument_list|,
operator|(
name|long
operator|)
name|g
operator|->
name|a_ctx
operator|->
name|ctx_id
argument_list|)
expr_stmt|;
return|return
name|_SMFIS_ABORT
return|;
block|}
name|sockaddr
operator|.
name|sunix
operator|.
name|sun_family
operator|=
name|AF_UNIX
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* NETUNIX */
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: connect[%ld]: unknown family %d"
argument_list|,
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_name
argument_list|,
operator|(
name|long
operator|)
name|g
operator|->
name|a_ctx
operator|->
name|ctx_id
argument_list|,
name|family
argument_list|)
expr_stmt|;
return|return
name|_SMFIS_ABORT
return|;
block|}
block|}
return|return
call|(
modifier|*
name|fi_connect
call|)
argument_list|(
name|g
operator|->
name|a_ctx
argument_list|,
name|g
operator|->
name|a_buf
argument_list|,
name|family
operator|!=
name|SMFIA_UNKNOWN
condition|?
operator|&
name|sockaddr
else|:
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  ST_EOH -- end of headers ** **	Parameters: **		g -- generic argument structure ** **	Returns: **		continue or filter-specified value */
end_comment

begin_function
specifier|static
name|int
name|st_eoh
parameter_list|(
name|g
parameter_list|)
name|genarg
modifier|*
name|g
decl_stmt|;
block|{
name|sfsistat
argument_list|(
argument|*fi_eoh
argument_list|)
name|__P
argument_list|(
operator|(
name|SMFICTX
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
return|return
name|_SMFIS_ABORT
return|;
if|if
condition|(
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|!=
name|NULL
operator|&&
operator|(
name|fi_eoh
operator|=
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_eoh
operator|)
operator|!=
name|NULL
condition|)
return|return
call|(
modifier|*
name|fi_eoh
call|)
argument_list|(
name|g
operator|->
name|a_ctx
argument_list|)
return|;
return|return
name|SMFIS_CONTINUE
return|;
block|}
end_function

begin_comment
comment|/* **  ST_DATA -- DATA command ** **	Parameters: **		g -- generic argument structure ** **	Returns: **		continue or filter-specified value */
end_comment

begin_function
specifier|static
name|int
name|st_data
parameter_list|(
name|g
parameter_list|)
name|genarg
modifier|*
name|g
decl_stmt|;
block|{
name|sfsistat
argument_list|(
argument|*fi_data
argument_list|)
name|__P
argument_list|(
operator|(
name|SMFICTX
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
return|return
name|_SMFIS_ABORT
return|;
if|if
condition|(
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|!=
name|NULL
operator|&&
operator|(
name|fi_data
operator|=
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_data
operator|)
operator|!=
name|NULL
condition|)
return|return
call|(
modifier|*
name|fi_data
call|)
argument_list|(
name|g
operator|->
name|a_ctx
argument_list|)
return|;
return|return
name|SMFIS_CONTINUE
return|;
block|}
end_function

begin_comment
comment|/* **  ST_HELO -- helo/ehlo command ** **	Parameters: **		g -- generic argument structure ** **	Returns: **		continue or filter-specified value */
end_comment

begin_function
specifier|static
name|int
name|st_helo
parameter_list|(
name|g
parameter_list|)
name|genarg
modifier|*
name|g
decl_stmt|;
block|{
name|sfsistat
argument_list|(
argument|*fi_helo
argument_list|)
name|__P
argument_list|(
operator|(
name|SMFICTX
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
return|return
name|_SMFIS_ABORT
return|;
name|mi_clr_macros
argument_list|(
name|g
operator|->
name|a_ctx
argument_list|,
name|g
operator|->
name|a_idx
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|!=
name|NULL
operator|&&
operator|(
name|fi_helo
operator|=
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_helo
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* paranoia: check for terminating '\0' */
if|if
condition|(
name|g
operator|->
name|a_len
operator|==
literal|0
operator|||
name|g
operator|->
name|a_buf
index|[
name|g
operator|->
name|a_len
operator|-
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
name|MI_FAILURE
return|;
return|return
call|(
modifier|*
name|fi_helo
call|)
argument_list|(
name|g
operator|->
name|a_ctx
argument_list|,
name|g
operator|->
name|a_buf
argument_list|)
return|;
block|}
return|return
name|SMFIS_CONTINUE
return|;
block|}
end_function

begin_comment
comment|/* **  ST_HEADER -- header line ** **	Parameters: **		g -- generic argument structure ** **	Returns: **		continue or filter-specified value */
end_comment

begin_function
specifier|static
name|int
name|st_header
parameter_list|(
name|g
parameter_list|)
name|genarg
modifier|*
name|g
decl_stmt|;
block|{
name|char
modifier|*
name|hf
decl_stmt|,
modifier|*
name|hv
decl_stmt|;
name|sfsistat
argument_list|(
argument|*fi_header
argument_list|)
name|__P
argument_list|(
operator|(
name|SMFICTX
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
return|return
name|_SMFIS_ABORT
return|;
if|if
condition|(
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|==
name|NULL
operator|||
operator|(
name|fi_header
operator|=
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_header
operator|)
operator|==
name|NULL
condition|)
return|return
name|SMFIS_CONTINUE
return|;
if|if
condition|(
name|dec_arg2
argument_list|(
name|g
operator|->
name|a_buf
argument_list|,
name|g
operator|->
name|a_len
argument_list|,
operator|&
name|hf
argument_list|,
operator|&
name|hv
argument_list|)
operator|==
name|MI_SUCCESS
condition|)
return|return
call|(
modifier|*
name|fi_header
call|)
argument_list|(
name|g
operator|->
name|a_ctx
argument_list|,
name|hf
argument_list|,
name|hv
argument_list|)
return|;
else|else
return|return
name|_SMFIS_ABORT
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ARGV_FCT
parameter_list|(
name|lf
parameter_list|,
name|rf
parameter_list|,
name|idx
parameter_list|)
define|\
value|char **argv;						\ 	sfsistat (*lf) __P((SMFICTX *, char **));		\ 	int r;							\ 								\ 	if (g == NULL)						\ 		return _SMFIS_ABORT;				\ 	mi_clr_macros(g->a_ctx, g->a_idx + 1);			\ 	if (g->a_ctx->ctx_smfi == NULL ||			\ 	    (lf = g->a_ctx->ctx_smfi->rf) == NULL)		\ 		return SMFIS_CONTINUE;				\ 	if ((argv = dec_argv(g->a_buf, g->a_len)) == NULL)	\ 		return _SMFIS_ABORT;				\ 	r = (*lf)(g->a_ctx, argv);				\ 	free(argv);						\ 	return r;
end_define

begin_comment
comment|/* **  ST_SENDER -- MAIL FROM command ** **	Parameters: **		g -- generic argument structure ** **	Returns: **		continue or filter-specified value */
end_comment

begin_function
specifier|static
name|int
name|st_sender
parameter_list|(
name|g
parameter_list|)
name|genarg
modifier|*
name|g
decl_stmt|;
block|{
name|ARGV_FCT
argument_list|(
argument|fi_envfrom
argument_list|,
argument|xxfi_envfrom
argument_list|,
argument|CI_MAIL
argument_list|)
block|}
end_function

begin_comment
comment|/* **  ST_RCPT -- RCPT TO command ** **	Parameters: **		g -- generic argument structure ** **	Returns: **		continue or filter-specified value */
end_comment

begin_function
specifier|static
name|int
name|st_rcpt
parameter_list|(
name|g
parameter_list|)
name|genarg
modifier|*
name|g
decl_stmt|;
block|{
name|ARGV_FCT
argument_list|(
argument|fi_envrcpt
argument_list|,
argument|xxfi_envrcpt
argument_list|,
argument|CI_RCPT
argument_list|)
block|}
end_function

begin_comment
comment|/* **  ST_UNKNOWN -- unrecognized or unimplemented command ** **	Parameters: **		g -- generic argument structure ** **	Returns: **		continue or filter-specified value */
end_comment

begin_function
specifier|static
name|int
name|st_unknown
parameter_list|(
name|g
parameter_list|)
name|genarg
modifier|*
name|g
decl_stmt|;
block|{
name|sfsistat
argument_list|(
argument|*fi_unknown
argument_list|)
name|__P
argument_list|(
operator|(
name|SMFICTX
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
return|return
name|_SMFIS_ABORT
return|;
if|if
condition|(
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|!=
name|NULL
operator|&&
operator|(
name|fi_unknown
operator|=
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_unknown
operator|)
operator|!=
name|NULL
condition|)
return|return
call|(
modifier|*
name|fi_unknown
call|)
argument_list|(
name|g
operator|->
name|a_ctx
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|g
operator|->
name|a_buf
argument_list|)
return|;
return|return
name|SMFIS_CONTINUE
return|;
block|}
end_function

begin_comment
comment|/* **  ST_MACROS -- deal with macros received from the MTA ** **	Parameters: **		g -- generic argument structure ** **	Returns: **		continue/keep ** **	Side effects: **		set pointer in macro array to current values. */
end_comment

begin_function
specifier|static
name|int
name|st_macros
parameter_list|(
name|g
parameter_list|)
name|genarg
modifier|*
name|g
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
operator|||
name|g
operator|->
name|a_len
operator|<
literal|1
condition|)
return|return
name|_SMFIS_FAIL
return|;
if|if
condition|(
operator|(
name|argv
operator|=
name|dec_argv
argument_list|(
name|g
operator|->
name|a_buf
operator|+
literal|1
argument_list|,
name|g
operator|->
name|a_len
operator|-
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|_SMFIS_FAIL
return|;
switch|switch
condition|(
name|g
operator|->
name|a_buf
index|[
literal|0
index|]
condition|)
block|{
case|case
name|SMFIC_CONNECT
case|:
name|i
operator|=
name|CI_CONN
expr_stmt|;
break|break;
case|case
name|SMFIC_HELO
case|:
name|i
operator|=
name|CI_HELO
expr_stmt|;
break|break;
case|case
name|SMFIC_MAIL
case|:
name|i
operator|=
name|CI_MAIL
expr_stmt|;
break|break;
case|case
name|SMFIC_RCPT
case|:
name|i
operator|=
name|CI_RCPT
expr_stmt|;
break|break;
case|case
name|SMFIC_DATA
case|:
name|i
operator|=
name|CI_DATA
expr_stmt|;
break|break;
case|case
name|SMFIC_BODYEOB
case|:
name|i
operator|=
name|CI_EOM
expr_stmt|;
break|break;
case|case
name|SMFIC_EOH
case|:
name|i
operator|=
name|CI_EOH
expr_stmt|;
break|break;
default|default:
name|free
argument_list|(
name|argv
argument_list|)
expr_stmt|;
return|return
name|_SMFIS_FAIL
return|;
block|}
if|if
condition|(
name|g
operator|->
name|a_ctx
operator|->
name|ctx_mac_ptr
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|g
operator|->
name|a_ctx
operator|->
name|ctx_mac_ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|a_ctx
operator|->
name|ctx_mac_buf
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|g
operator|->
name|a_ctx
operator|->
name|ctx_mac_buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|g
operator|->
name|a_ctx
operator|->
name|ctx_mac_ptr
index|[
name|i
index|]
operator|=
name|argv
expr_stmt|;
name|g
operator|->
name|a_ctx
operator|->
name|ctx_mac_buf
index|[
name|i
index|]
operator|=
name|g
operator|->
name|a_buf
expr_stmt|;
return|return
name|_SMFIS_KEEP
return|;
block|}
end_function

begin_comment
comment|/* **  ST_QUIT -- quit command ** **	Parameters: **		g -- generic argument structure ** **	Returns: **		noreply */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|st_quit
parameter_list|(
name|g
parameter_list|)
name|genarg
modifier|*
name|g
decl_stmt|;
block|{
name|sfsistat
argument_list|(
argument|*fi_close
argument_list|)
name|__P
argument_list|(
operator|(
name|SMFICTX
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
return|return
name|_SMFIS_ABORT
return|;
if|if
condition|(
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|!=
name|NULL
operator|&&
operator|(
name|fi_close
operator|=
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_close
operator|)
operator|!=
name|NULL
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|fi_close
argument_list|)
argument_list|(
name|g
operator|->
name|a_ctx
argument_list|)
expr_stmt|;
name|mi_clr_macros
argument_list|(
name|g
operator|->
name|a_ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|_SMFIS_NOREPLY
return|;
block|}
end_function

begin_comment
comment|/* **  ST_BODYCHUNK -- deal with a piece of the mail body ** **	Parameters: **		g -- generic argument structure ** **	Returns: **		continue or filter-specified value */
end_comment

begin_function
specifier|static
name|int
name|st_bodychunk
parameter_list|(
name|g
parameter_list|)
name|genarg
modifier|*
name|g
decl_stmt|;
block|{
name|sfsistat
argument_list|(
argument|*fi_body
argument_list|)
name|__P
argument_list|(
operator|(
name|SMFICTX
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
return|return
name|_SMFIS_ABORT
return|;
if|if
condition|(
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|!=
name|NULL
operator|&&
operator|(
name|fi_body
operator|=
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_body
operator|)
operator|!=
name|NULL
condition|)
return|return
call|(
modifier|*
name|fi_body
call|)
argument_list|(
name|g
operator|->
name|a_ctx
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|g
operator|->
name|a_buf
argument_list|,
name|g
operator|->
name|a_len
argument_list|)
return|;
return|return
name|SMFIS_CONTINUE
return|;
block|}
end_function

begin_comment
comment|/* **  ST_BODYEND -- deal with the last piece of the mail body ** **	Parameters: **		g -- generic argument structure ** **	Returns: **		continue or filter-specified value ** **	Side effects: **		sends a reply for the body part (if non-empty). */
end_comment

begin_function
specifier|static
name|int
name|st_bodyend
parameter_list|(
name|g
parameter_list|)
name|genarg
modifier|*
name|g
decl_stmt|;
block|{
name|sfsistat
name|r
decl_stmt|;
name|sfsistat
argument_list|(
argument|*fi_body
argument_list|)
name|__P
argument_list|(
operator|(
name|SMFICTX
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
expr_stmt|;
name|sfsistat
argument_list|(
argument|*fi_eom
argument_list|)
name|__P
argument_list|(
operator|(
name|SMFICTX
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
return|return
name|_SMFIS_ABORT
return|;
name|r
operator|=
name|SMFIS_CONTINUE
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|fi_body
operator|=
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_body
operator|)
operator|!=
name|NULL
operator|&&
name|g
operator|->
name|a_len
operator|>
literal|0
condition|)
block|{
name|socket_t
name|sd
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
name|g
operator|->
name|a_ctx
operator|->
name|ctx_timeout
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|sd
operator|=
name|g
operator|->
name|a_ctx
operator|->
name|ctx_sd
expr_stmt|;
name|r
operator|=
call|(
modifier|*
name|fi_body
call|)
argument_list|(
name|g
operator|->
name|a_ctx
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|g
operator|->
name|a_buf
argument_list|,
name|g
operator|->
name|a_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|SMFIS_CONTINUE
operator|&&
name|sendreply
argument_list|(
name|r
argument_list|,
name|sd
argument_list|,
operator|&
name|timeout
argument_list|,
name|g
operator|->
name|a_ctx
argument_list|)
operator|!=
name|MI_SUCCESS
condition|)
return|return
name|_SMFIS_ABORT
return|;
block|}
block|}
if|if
condition|(
name|r
operator|==
name|SMFIS_CONTINUE
operator|&&
operator|(
name|fi_eom
operator|=
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_eom
operator|)
operator|!=
name|NULL
condition|)
return|return
call|(
modifier|*
name|fi_eom
call|)
argument_list|(
name|g
operator|->
name|a_ctx
argument_list|)
return|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* **  ST_ABORTFCT -- deal with aborts ** **	Parameters: **		g -- generic argument structure ** **	Returns: **		abort or filter-specified value */
end_comment

begin_function
specifier|static
name|int
name|st_abortfct
parameter_list|(
name|g
parameter_list|)
name|genarg
modifier|*
name|g
decl_stmt|;
block|{
name|sfsistat
argument_list|(
argument|*fi_abort
argument_list|)
name|__P
argument_list|(
operator|(
name|SMFICTX
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
return|return
name|_SMFIS_ABORT
return|;
if|if
condition|(
name|g
operator|!=
name|NULL
operator|&&
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|!=
name|NULL
operator|&&
operator|(
name|fi_abort
operator|=
name|g
operator|->
name|a_ctx
operator|->
name|ctx_smfi
operator|->
name|xxfi_abort
operator|)
operator|!=
name|NULL
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|fi_abort
argument_list|)
argument_list|(
name|g
operator|->
name|a_ctx
argument_list|)
expr_stmt|;
return|return
name|_SMFIS_NOREPLY
return|;
block|}
end_function

begin_comment
comment|/* **  TRANS_OK -- is the state transition ok? ** **	Parameters: **		old -- old state **		new -- new state ** **	Returns: **		state transition ok */
end_comment

begin_function
specifier|static
name|bool
name|trans_ok
parameter_list|(
name|old
parameter_list|,
name|new
parameter_list|)
name|int
name|old
decl_stmt|,
name|new
decl_stmt|;
block|{
name|int
name|s
decl_stmt|,
name|n
decl_stmt|;
name|s
operator|=
name|old
expr_stmt|;
if|if
condition|(
name|s
operator|>=
name|SIZE_NEXT_STATES
condition|)
return|return
name|false
return|;
do|do
block|{
comment|/* is this state transition allowed? */
if|if
condition|(
operator|(
name|MI_MASK
argument_list|(
name|new
argument_list|)
operator|&
name|next_states
index|[
name|s
index|]
operator|)
operator|!=
literal|0
condition|)
return|return
name|true
return|;
comment|/* 		**  no: try next state; 		**  this works since the relevant states are ordered 		**  strict sequentially 		*/
name|n
operator|=
name|s
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|SIZE_NEXT_STATES
condition|)
return|return
name|false
return|;
comment|/* 		**  can we actually "skip" this state? 		**  see fix_stm() which sets this bit for those 		**  states which the filter program is not interested in 		*/
if|if
condition|(
name|bitset
argument_list|(
name|NX_SKIP
argument_list|,
name|next_states
index|[
name|n
index|]
argument_list|)
condition|)
name|s
operator|=
name|n
expr_stmt|;
else|else
return|return
name|false
return|;
block|}
do|while
condition|(
name|s
operator|<
name|SIZE_NEXT_STATES
condition|)
do|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* **  FIX_STM -- add "skip" bits to the state transition table ** **	Parameters: **		ctx -- context structure ** **	Returns: **		None. ** **	Side effects: **		may change state transition table. */
end_comment

begin_function
specifier|static
name|void
name|fix_stm
parameter_list|(
name|ctx
parameter_list|)
name|SMFICTX_PTR
name|ctx
decl_stmt|;
block|{
name|unsigned
name|long
name|fl
decl_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
operator|||
name|ctx
operator|->
name|ctx_smfi
operator|==
name|NULL
condition|)
return|return;
name|fl
operator|=
name|ctx
operator|->
name|ctx_pflags
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|SMFIP_NOCONNECT
argument_list|,
name|fl
argument_list|)
condition|)
name|next_states
index|[
name|ST_CONN
index|]
operator||=
name|NX_SKIP
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|SMFIP_NOHELO
argument_list|,
name|fl
argument_list|)
condition|)
name|next_states
index|[
name|ST_HELO
index|]
operator||=
name|NX_SKIP
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|SMFIP_NOMAIL
argument_list|,
name|fl
argument_list|)
condition|)
name|next_states
index|[
name|ST_MAIL
index|]
operator||=
name|NX_SKIP
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|SMFIP_NORCPT
argument_list|,
name|fl
argument_list|)
condition|)
name|next_states
index|[
name|ST_RCPT
index|]
operator||=
name|NX_SKIP
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|SMFIP_NOHDRS
argument_list|,
name|fl
argument_list|)
condition|)
name|next_states
index|[
name|ST_HDRS
index|]
operator||=
name|NX_SKIP
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|SMFIP_NOEOH
argument_list|,
name|fl
argument_list|)
condition|)
name|next_states
index|[
name|ST_EOHS
index|]
operator||=
name|NX_SKIP
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|SMFIP_NOBODY
argument_list|,
name|fl
argument_list|)
condition|)
name|next_states
index|[
name|ST_BODY
index|]
operator||=
name|NX_SKIP
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|SMFIP_NODATA
argument_list|,
name|fl
argument_list|)
condition|)
name|next_states
index|[
name|ST_DATA
index|]
operator||=
name|NX_SKIP
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|SMFIP_NOUNKNOWN
argument_list|,
name|fl
argument_list|)
condition|)
name|next_states
index|[
name|ST_UNKN
index|]
operator||=
name|NX_SKIP
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  DEC_ARGV -- split a buffer into a list of strings, NULL terminated ** **	Parameters: **		buf -- buffer with several strings **		len -- length of buffer ** **	Returns: **		array of pointers to the individual strings */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|dec_argv
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|elem
decl_stmt|,
name|nelem
decl_stmt|;
name|nelem
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
operator|++
name|nelem
expr_stmt|;
block|}
if|if
condition|(
name|nelem
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* last entry is only for the name */
name|s
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|nelem
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
expr|*
name|s
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|s
index|[
literal|0
index|]
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|elem
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|&&
name|elem
operator|<
name|nelem
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|++
name|elem
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|>=
name|len
condition|)
name|s
index|[
name|elem
index|]
operator|=
name|NULL
expr_stmt|;
else|else
name|s
index|[
name|elem
index|]
operator|=
operator|&
operator|(
name|buf
index|[
name|i
operator|+
literal|1
index|]
operator|)
expr_stmt|;
block|}
block|}
comment|/* overwrite last entry (already done above, just paranoia) */
name|s
index|[
name|elem
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* **  DEC_ARG2 -- split a buffer into two strings ** **	Parameters: **		buf -- buffer with two strings **		len -- length of buffer **		s1,s2 -- pointer to result strings ** **	Returns: **		MI_FAILURE/MI_SUCCESS */
end_comment

begin_function
specifier|static
name|int
name|dec_arg2
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|,
name|s1
parameter_list|,
name|s2
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
modifier|*
name|s1
decl_stmt|;
name|char
modifier|*
modifier|*
name|s2
decl_stmt|;
block|{
name|size_t
name|i
decl_stmt|;
comment|/* paranoia: check for terminating '\0' */
if|if
condition|(
name|len
operator|==
literal|0
operator|||
name|buf
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
name|MI_FAILURE
return|;
operator|*
name|s1
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|len
operator|&&
name|buf
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
continue|continue;
if|if
condition|(
name|i
operator|>=
name|len
operator|-
literal|1
condition|)
return|return
name|MI_FAILURE
return|;
operator|*
name|s2
operator|=
name|buf
operator|+
name|i
operator|+
literal|1
expr_stmt|;
return|return
name|MI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* **  SENDOK -- is it ok for the filter to send stuff to the MTA? ** **	Parameters: **		ctx -- context structure **		flag -- flag to check ** **	Returns: **		sending allowed (in current state) */
end_comment

begin_function
name|bool
name|mi_sendok
parameter_list|(
name|ctx
parameter_list|,
name|flag
parameter_list|)
name|SMFICTX_PTR
name|ctx
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
if|if
condition|(
name|ctx
operator|==
name|NULL
operator|||
name|ctx
operator|->
name|ctx_smfi
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* did the milter request this operation? */
if|if
condition|(
name|flag
operator|!=
literal|0
operator|&&
operator|!
name|bitset
argument_list|(
name|flag
argument_list|,
name|ctx
operator|->
name|ctx_aflags
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* are we in the correct state? It must be "End of Message". */
return|return
name|ctx
operator|->
name|ctx_state
operator|==
name|ST_ENDM
return|;
block|}
end_function

begin_if
if|#
directive|if
name|_FFR_WORKERS_POOL
end_if

begin_comment
comment|/* **  MI_RD_SOCKET_READY - checks if the socket is ready for read(2) ** **	Parameters: **		sd -- socket_t ** **	Returns: **		true iff socket is ready for read(2) */
end_comment

begin_define
define|#
directive|define
name|MI_RD_CMD_TO
value|1
end_define

begin_define
define|#
directive|define
name|MI_RD_MAX_ERR
value|16
end_define

begin_function
specifier|static
name|bool
name|mi_rd_socket_ready
parameter_list|(
name|sd
parameter_list|)
name|socket_t
name|sd
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|int
name|nerr
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|SM_CONF_POLL
name|struct
name|pollfd
name|pfd
decl_stmt|;
else|#
directive|else
comment|/* SM_CONF_POLL */
name|fd_set
name|rd_set
decl_stmt|,
name|exc_set
decl_stmt|;
endif|#
directive|endif
comment|/* SM_CONF_POLL */
do|do
block|{
if|#
directive|if
name|SM_CONF_POLL
name|pfd
operator|.
name|fd
operator|=
name|sd
expr_stmt|;
name|pfd
operator|.
name|events
operator|=
name|POLLIN
expr_stmt|;
name|pfd
operator|.
name|revents
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|poll
argument_list|(
operator|&
name|pfd
argument_list|,
literal|1
argument_list|,
name|MI_RD_CMD_TO
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SM_CONF_POLL */
name|struct
name|timeval
name|timeout
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|rd_set
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|exc_set
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|sd
argument_list|,
operator|&
name|rd_set
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|sd
argument_list|,
operator|&
name|exc_set
argument_list|)
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
name|MI_RD_CMD_TO
operator|/
literal|1000
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|select
argument_list|(
name|sd
operator|+
literal|1
argument_list|,
operator|&
name|rd_set
argument_list|,
name|NULL
argument_list|,
operator|&
name|exc_set
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SM_CONF_POLL */
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
name|nerr
operator|++
expr_stmt|;
continue|continue;
block|}
return|return
name|true
return|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|false
return|;
break|break;
block|}
do|while
condition|(
name|nerr
operator|<
name|MI_RD_MAX_ERR
condition|)
do|;
if|if
condition|(
name|nerr
operator|>=
name|MI_RD_MAX_ERR
condition|)
return|return
name|false
return|;
if|#
directive|if
name|SM_CONF_POLL
return|return
operator|(
name|pfd
operator|.
name|revents
operator|!=
literal|0
operator|)
return|;
else|#
directive|else
comment|/* SM_CONF_POLL */
return|return
name|FD_ISSET
argument_list|(
name|sd
argument_list|,
operator|&
name|rd_set
argument_list|)
operator|||
name|FD_ISSET
argument_list|(
name|sd
argument_list|,
operator|&
name|exc_set
argument_list|)
return|;
endif|#
directive|endif
comment|/* SM_CONF_POLL */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_WORKERS_POOL */
end_comment

end_unit

