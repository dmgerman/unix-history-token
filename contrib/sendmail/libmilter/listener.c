begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Copyright (c) 1999-2007 Sendmail, Inc. and its suppliers.  *	All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_include
include|#
directive|include
file|<sm/gen.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: listener.c,v 8.122 2006/11/02 17:54:44 ca Exp $"
argument_list|)
end_macro

begin_comment
comment|/* **  listener.c -- threaded network listener */
end_comment

begin_include
include|#
directive|include
file|"libmilter.h"
end_include

begin_include
include|#
directive|include
file|<sm/errstring.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_if
if|#
directive|if
name|NETINET
operator|||
name|NETINET6
end_if

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NETINET || NETINET6 */
end_comment

begin_if
if|#
directive|if
name|SM_CONF_POLL
end_if

begin_undef
undef|#
directive|undef
name|SM_FD_OK_SELECT
end_undef

begin_define
define|#
directive|define
name|SM_FD_OK_SELECT
parameter_list|(
name|fd
parameter_list|)
value|true
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SM_CONF_POLL */
end_comment

begin_decl_stmt
specifier|static
name|smutex_t
name|L_Mutex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|L_family
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SOCKADDR_LEN_T
name|L_socksize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|socket_t
name|listenfd
init|=
name|INVALID_SOCKET
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|socket_t
name|mi_milteropen
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|bool
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|_FFR_WORKERS_POOL
end_if

begin_decl_stmt
specifier|static
name|void
modifier|*
name|mi_thread_handle_wrapper
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_FFR_WORKERS_POOL */
end_comment

begin_comment
comment|/* **  MI_OPENSOCKET -- create the socket where this filter and the MTA will meet ** **	Parameters: **		conn -- connection description **		backlog -- listen backlog **		dbg -- debug level **		rmsocket -- if true, try to unlink() the socket first **			(UNIX domain sockets only) **		smfi -- filter structure to use ** **	Return value: **		MI_SUCCESS/MI_FAILURE */
end_comment

begin_function
name|int
name|mi_opensocket
parameter_list|(
name|conn
parameter_list|,
name|backlog
parameter_list|,
name|dbg
parameter_list|,
name|rmsocket
parameter_list|,
name|smfi
parameter_list|)
name|char
modifier|*
name|conn
decl_stmt|;
name|int
name|backlog
decl_stmt|;
name|int
name|dbg
decl_stmt|;
name|bool
name|rmsocket
decl_stmt|;
name|smfiDesc_ptr
name|smfi
decl_stmt|;
block|{
if|if
condition|(
name|smfi
operator|==
name|NULL
operator|||
name|conn
operator|==
name|NULL
condition|)
return|return
name|MI_FAILURE
return|;
if|if
condition|(
name|ValidSocket
argument_list|(
name|listenfd
argument_list|)
condition|)
return|return
name|MI_SUCCESS
return|;
if|if
condition|(
name|dbg
operator|>
literal|0
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_DEBUG
argument_list|,
literal|"%s: Opening listen socket on conn %s"
argument_list|,
name|smfi
operator|->
name|xxfi_name
argument_list|,
name|conn
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|smutex_init
argument_list|(
operator|&
name|L_Mutex
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|smutex_lock
argument_list|(
operator|&
name|L_Mutex
argument_list|)
expr_stmt|;
name|listenfd
operator|=
name|mi_milteropen
argument_list|(
name|conn
argument_list|,
name|backlog
argument_list|,
name|rmsocket
argument_list|,
name|smfi
operator|->
name|xxfi_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ValidSocket
argument_list|(
name|listenfd
argument_list|)
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_FATAL
argument_list|,
literal|"%s: Unable to create listening socket on conn %s"
argument_list|,
name|smfi
operator|->
name|xxfi_name
argument_list|,
name|conn
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|smutex_unlock
argument_list|(
operator|&
name|L_Mutex
argument_list|)
expr_stmt|;
return|return
name|MI_FAILURE
return|;
block|}
if|if
condition|(
operator|!
name|SM_FD_OK_SELECT
argument_list|(
name|listenfd
argument_list|)
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: fd %d is larger than FD_SETSIZE %d"
argument_list|,
name|smfi
operator|->
name|xxfi_name
argument_list|,
name|listenfd
argument_list|,
name|FD_SETSIZE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|smutex_unlock
argument_list|(
operator|&
name|L_Mutex
argument_list|)
expr_stmt|;
return|return
name|MI_FAILURE
return|;
block|}
operator|(
name|void
operator|)
name|smutex_unlock
argument_list|(
operator|&
name|L_Mutex
argument_list|)
expr_stmt|;
return|return
name|MI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* **  MI_MILTEROPEN -- setup socket to listen on ** **	Parameters: **		conn -- connection description **		backlog -- listen backlog **		rmsocket -- if true, try to unlink() the socket first **			(UNIX domain sockets only) **		name -- name for logging ** **	Returns: **		socket upon success, error code otherwise. ** **	Side effect: **		sets sockpath if UNIX socket. */
end_comment

begin_if
if|#
directive|if
name|NETUNIX
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sockpath
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NETUNIX */
end_comment

begin_function
specifier|static
name|socket_t
name|mi_milteropen
parameter_list|(
name|conn
parameter_list|,
name|backlog
parameter_list|,
name|rmsocket
parameter_list|,
name|name
parameter_list|)
name|char
modifier|*
name|conn
decl_stmt|;
name|int
name|backlog
decl_stmt|;
name|bool
name|rmsocket
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|socket_t
name|sock
decl_stmt|;
name|int
name|sockopt
init|=
literal|1
decl_stmt|;
name|int
name|fdflags
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|colon
decl_stmt|;
name|char
modifier|*
name|at
decl_stmt|;
name|SOCKADDR
name|addr
decl_stmt|;
if|if
condition|(
name|conn
operator|==
name|NULL
operator|||
name|conn
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: empty or missing socket information"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|&
name|addr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|addr
argument_list|)
expr_stmt|;
comment|/* protocol:filename or protocol:port@host */
name|p
operator|=
name|conn
expr_stmt|;
name|colon
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|colon
operator|!=
name|NULL
condition|)
block|{
operator|*
name|colon
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
if|#
directive|if
name|NETUNIX
comment|/* default to AF_UNIX */
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_UNIX
expr_stmt|;
name|L_socksize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* NETUNIX */
if|#
directive|if
name|NETINET
comment|/* default to AF_INET */
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
name|L_socksize
operator|=
sizeof|sizeof
name|addr
operator|.
name|sin
expr_stmt|;
else|#
directive|else
comment|/* NETINET */
if|#
directive|if
name|NETINET6
comment|/* default to AF_INET6 */
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET6
expr_stmt|;
name|L_socksize
operator|=
sizeof|sizeof
name|addr
operator|.
name|sin6
expr_stmt|;
else|#
directive|else
comment|/* NETINET6 */
comment|/* no protocols available */
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: no valid socket protocols available"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
endif|#
directive|endif
comment|/* NETINET6 */
endif|#
directive|endif
comment|/* NETINET */
endif|#
directive|endif
comment|/* NETUNIX */
block|}
if|#
directive|if
name|NETUNIX
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|p
argument_list|,
literal|"unix"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
name|p
argument_list|,
literal|"local"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_UNIX
expr_stmt|;
name|L_socksize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NETUNIX */
if|#
directive|if
name|NETINET
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|p
argument_list|,
literal|"inet"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
name|L_socksize
operator|=
sizeof|sizeof
name|addr
operator|.
name|sin
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET6
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|p
argument_list|,
literal|"inet6"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET6
expr_stmt|;
name|L_socksize
operator|=
sizeof|sizeof
name|addr
operator|.
name|sin6
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NETINET6 */
else|else
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: unknown socket type %s"
argument_list|,
name|name
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
operator|*
name|colon
operator|++
operator|=
literal|':'
expr_stmt|;
block|}
else|else
block|{
name|colon
operator|=
name|p
expr_stmt|;
if|#
directive|if
name|NETUNIX
comment|/* default to AF_UNIX */
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_UNIX
expr_stmt|;
name|L_socksize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* NETUNIX */
if|#
directive|if
name|NETINET
comment|/* default to AF_INET */
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
name|L_socksize
operator|=
sizeof|sizeof
name|addr
operator|.
name|sin
expr_stmt|;
else|#
directive|else
comment|/* NETINET */
if|#
directive|if
name|NETINET6
comment|/* default to AF_INET6 */
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET6
expr_stmt|;
name|L_socksize
operator|=
sizeof|sizeof
name|addr
operator|.
name|sin6
expr_stmt|;
else|#
directive|else
comment|/* NETINET6 */
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: unknown socket type %s"
argument_list|,
name|name
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
endif|#
directive|endif
comment|/* NETINET6 */
endif|#
directive|endif
comment|/* NETINET */
endif|#
directive|endif
comment|/* NETUNIX */
block|}
if|#
directive|if
name|NETUNIX
if|if
condition|(
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_UNIX
condition|)
block|{
if|#
directive|if
literal|0
block|long sff = SFF_SAFEDIRPATH|SFF_OPENASROOT|SFF_NOLINK|SFF_CREAT|SFF_MUSTOWN;
endif|#
directive|endif
comment|/* 0 */
name|at
operator|=
name|colon
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|colon
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
name|addr
operator|.
name|sunix
operator|.
name|sun_path
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: UNIX socket name %s too long"
argument_list|,
name|name
argument_list|,
name|colon
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|addr
operator|.
name|sunix
operator|.
name|sun_path
argument_list|,
name|colon
argument_list|,
sizeof|sizeof
name|addr
operator|.
name|sunix
operator|.
name|sun_path
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|errno = safefile(colon, RunAsUid, RunAsGid, RunAsUserName, sff, 				 S_IRUSR|S_IWUSR, NULL);
comment|/* if not safe, don't create */
block|if (errno != 0) 		{ 			smi_log(SMI_LOG_ERR, 				"%s: UNIX socket name %s unsafe", 				name, colon); 			return INVALID_SOCKET; 		}
endif|#
directive|endif
comment|/* 0 */
block|}
endif|#
directive|endif
comment|/* NETUNIX */
if|#
directive|if
name|NETINET
operator|||
name|NETINET6
if|if
condition|(
if|#
directive|if
name|NETINET
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET
operator|&&
name|NETINET6
operator|||
endif|#
directive|endif
comment|/* NETINET&& NETINET6 */
if|#
directive|if
name|NETINET6
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
endif|#
directive|endif
comment|/* NETINET6 */
condition|)
block|{
name|unsigned
name|short
name|port
decl_stmt|;
comment|/* Parse port@host */
name|at
operator|=
name|strchr
argument_list|(
name|colon
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|addr
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
if|#
directive|if
name|NETINET
case|case
name|AF_INET
case|:
name|addr
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET6
case|case
name|AF_INET6
case|:
name|addr
operator|.
name|sin6
operator|.
name|sin6_addr
operator|=
name|in6addr_any
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET6 */
block|}
block|}
else|else
operator|*
name|at
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|isascii
argument_list|(
operator|*
name|colon
argument_list|)
operator|&&
name|isdigit
argument_list|(
operator|*
name|colon
argument_list|)
condition|)
name|port
operator|=
name|htons
argument_list|(
operator|(
name|unsigned
name|short
operator|)
name|atoi
argument_list|(
name|colon
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|NO_GETSERVBYNAME
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: invalid port number %s"
argument_list|,
name|name
argument_list|,
name|colon
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
else|#
directive|else
comment|/* NO_GETSERVBYNAME */
specifier|register
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|getservbyname
argument_list|(
name|colon
argument_list|,
literal|"tcp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: unknown port name %s"
argument_list|,
name|name
argument_list|,
name|colon
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
name|port
operator|=
name|sp
operator|->
name|s_port
expr_stmt|;
endif|#
directive|endif
comment|/* NO_GETSERVBYNAME */
block|}
if|if
condition|(
name|at
operator|!=
name|NULL
condition|)
block|{
operator|*
name|at
operator|++
operator|=
literal|'@'
expr_stmt|;
if|if
condition|(
operator|*
name|at
operator|==
literal|'['
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|end
operator|=
name|strchr
argument_list|(
name|at
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|!=
name|NULL
condition|)
block|{
name|bool
name|found
init|=
name|false
decl_stmt|;
if|#
directive|if
name|NETINET
name|unsigned
name|long
name|hid
init|=
name|INADDR_NONE
decl_stmt|;
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET6
name|struct
name|sockaddr_in6
name|hid6
decl_stmt|;
endif|#
directive|endif
comment|/* NETINET6 */
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
if|#
directive|if
name|NETINET
if|if
condition|(
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
operator|&&
operator|(
name|hid
operator|=
name|inet_addr
argument_list|(
operator|&
name|at
index|[
literal|1
index|]
argument_list|)
operator|)
operator|!=
name|INADDR_NONE
condition|)
block|{
name|addr
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|hid
expr_stmt|;
name|addr
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET6
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|&
name|hid6
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|hid6
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
operator|&&
name|mi_inet_pton
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|at
index|[
literal|1
index|]
argument_list|,
operator|&
name|hid6
operator|.
name|sin6_addr
argument_list|)
operator|==
literal|1
condition|)
block|{
name|addr
operator|.
name|sin6
operator|.
name|sin6_addr
operator|=
name|hid6
operator|.
name|sin6_addr
expr_stmt|;
name|addr
operator|.
name|sin6
operator|.
name|sin6_port
operator|=
name|port
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NETINET6 */
operator|*
name|end
operator|=
literal|']'
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: Invalid numeric domain spec \"%s\""
argument_list|,
name|name
argument_list|,
name|at
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
block|}
else|else
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: Invalid numeric domain spec \"%s\""
argument_list|,
name|name
argument_list|,
name|at
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
block|}
else|else
block|{
name|struct
name|hostent
modifier|*
name|hp
init|=
name|NULL
decl_stmt|;
name|hp
operator|=
name|mi_gethostbyname
argument_list|(
name|at
argument_list|,
name|addr
operator|.
name|sa
operator|.
name|sa_family
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: Unknown host name %s"
argument_list|,
name|name
argument_list|,
name|at
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
switch|switch
condition|(
name|hp
operator|->
name|h_addrtype
condition|)
block|{
if|#
directive|if
name|NETINET
case|case
name|AF_INET
case|:
operator|(
name|void
operator|)
name|memmove
argument_list|(
operator|&
name|addr
operator|.
name|sin
operator|.
name|sin_addr
argument_list|,
name|hp
operator|->
name|h_addr
argument_list|,
name|INADDRSZ
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET6
case|case
name|AF_INET6
case|:
operator|(
name|void
operator|)
name|memmove
argument_list|(
operator|&
name|addr
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|,
name|hp
operator|->
name|h_addr
argument_list|,
name|IN6ADDRSZ
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin6
operator|.
name|sin6_port
operator|=
name|port
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET6 */
default|default:
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: Unknown protocol for %s (%d)"
argument_list|,
name|name
argument_list|,
name|at
argument_list|,
name|hp
operator|->
name|h_addrtype
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
if|#
directive|if
name|NETINET6
name|freehostent
argument_list|(
name|hp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NETINET6 */
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|addr
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
if|#
directive|if
name|NETINET
case|case
name|AF_INET
case|:
name|addr
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET6
case|case
name|AF_INET6
case|:
name|addr
operator|.
name|sin6
operator|.
name|sin6_port
operator|=
name|port
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET6 */
block|}
block|}
block|}
endif|#
directive|endif
comment|/* NETINET || NETINET6 */
name|sock
operator|=
name|socket
argument_list|(
name|addr
operator|.
name|sa
operator|.
name|sa_family
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ValidSocket
argument_list|(
name|sock
argument_list|)
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: Unable to create new socket: %s"
argument_list|,
name|name
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
if|if
condition|(
operator|(
name|fdflags
operator|=
name|fcntl
argument_list|(
name|sock
argument_list|,
name|F_GETFD
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|||
name|fcntl
argument_list|(
name|sock
argument_list|,
name|F_SETFD
argument_list|,
name|fdflags
operator||
name|FD_CLOEXEC
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: Unable to set close-on-exec: %s"
argument_list|,
name|name
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closesocket
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
if|if
condition|(
if|#
directive|if
name|NETUNIX
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|AF_UNIX
operator|&&
endif|#
directive|endif
comment|/* NETUNIX */
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sockopt
argument_list|,
sizeof|sizeof
argument_list|(
name|sockopt
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: set reuseaddr failed (%s)"
argument_list|,
name|name
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closesocket
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
if|#
directive|if
name|NETUNIX
if|if
condition|(
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_UNIX
operator|&&
name|rmsocket
condition|)
block|{
name|struct
name|stat
name|s
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|colon
argument_list|,
operator|&
name|s
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: Unable to stat() %s: %s"
argument_list|,
name|name
argument_list|,
name|colon
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closesocket
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|S_ISSOCK
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: %s is not a UNIX domain socket"
argument_list|,
name|name
argument_list|,
name|colon
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closesocket
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
elseif|else
if|if
condition|(
name|unlink
argument_list|(
name|colon
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: Unable to remove %s: %s"
argument_list|,
name|name
argument_list|,
name|colon
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closesocket
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
block|}
endif|#
directive|endif
comment|/* NETUNIX */
if|if
condition|(
name|bind
argument_list|(
name|sock
argument_list|,
operator|&
name|addr
operator|.
name|sa
argument_list|,
name|L_socksize
argument_list|)
operator|<
literal|0
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: Unable to bind to port %s: %s"
argument_list|,
name|name
argument_list|,
name|conn
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closesocket
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
if|if
condition|(
name|listen
argument_list|(
name|sock
argument_list|,
name|backlog
argument_list|)
operator|<
literal|0
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: listen call failed: %s"
argument_list|,
name|name
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closesocket
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
if|#
directive|if
name|NETUNIX
if|if
condition|(
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_UNIX
operator|&&
name|len
operator|>
literal|0
condition|)
block|{
comment|/* 		**  Set global variable sockpath so the UNIX socket can be 		**  unlink()ed at exit. 		*/
name|sockpath
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockpath
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|sockpath
argument_list|,
name|colon
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: can't malloc(%d) for sockpath: %s"
argument_list|,
name|name
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closesocket
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
block|}
endif|#
directive|endif
comment|/* NETUNIX */
name|L_family
operator|=
name|addr
operator|.
name|sa
operator|.
name|sa_family
expr_stmt|;
return|return
name|sock
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|_FFR_WORKERS_POOL
end_if

begin_comment
comment|/* **  MI_THREAD_HANDLE_WRAPPER -- small wrapper to handle session ** **	Parameters: **		arg -- argument to pass to mi_handle_session() ** **	Returns: **		results from mi_handle_session() */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|mi_thread_handle_wrapper
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
comment|/* 	**  Note: on some systems this generates a compiler warning: 	**  cast to pointer from integer of different size 	**  You can safely ignore this warning as the result of this function 	**  is not used anywhere. 	*/
return|return
operator|(
name|void
operator|*
operator|)
name|mi_handle_session
argument_list|(
name|arg
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_WORKERS_POOL */
end_comment

begin_comment
comment|/* **  MI_CLOSENER -- close listen socket ** **	Parameters: **		none. ** **	Returns: **		none. */
end_comment

begin_function
name|void
name|mi_closener
parameter_list|()
block|{
operator|(
name|void
operator|)
name|smutex_lock
argument_list|(
operator|&
name|L_Mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ValidSocket
argument_list|(
name|listenfd
argument_list|)
condition|)
block|{
if|#
directive|if
name|NETUNIX
name|bool
name|removable
decl_stmt|;
name|struct
name|stat
name|sockinfo
decl_stmt|;
name|struct
name|stat
name|fileinfo
decl_stmt|;
name|removable
operator|=
name|sockpath
operator|!=
name|NULL
operator|&&
name|geteuid
argument_list|()
operator|!=
literal|0
operator|&&
name|fstat
argument_list|(
name|listenfd
argument_list|,
operator|&
name|sockinfo
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|S_ISFIFO
argument_list|(
name|sockinfo
operator|.
name|st_mode
argument_list|)
ifdef|#
directive|ifdef
name|S_ISSOCK
operator|||
name|S_ISSOCK
argument_list|(
name|sockinfo
operator|.
name|st_mode
argument_list|)
endif|#
directive|endif
comment|/* S_ISSOCK */
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* NETUNIX */
operator|(
name|void
operator|)
name|closesocket
argument_list|(
name|listenfd
argument_list|)
expr_stmt|;
name|listenfd
operator|=
name|INVALID_SOCKET
expr_stmt|;
if|#
directive|if
name|NETUNIX
comment|/* XXX sleep() some time before doing this? */
if|if
condition|(
name|sockpath
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|removable
operator|&&
name|stat
argument_list|(
name|sockpath
argument_list|,
operator|&
name|fileinfo
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|fileinfo
operator|.
name|st_dev
operator|==
name|sockinfo
operator|.
name|st_dev
operator|&&
name|fileinfo
operator|.
name|st_ino
operator|==
name|sockinfo
operator|.
name|st_ino
operator|)
ifdef|#
directive|ifdef
name|S_ISSOCK
operator|||
name|S_ISSOCK
argument_list|(
name|fileinfo
operator|.
name|st_mode
argument_list|)
endif|#
directive|endif
comment|/* S_ISSOCK */
operator|)
operator|&&
operator|(
name|S_ISFIFO
argument_list|(
name|fileinfo
operator|.
name|st_mode
argument_list|)
ifdef|#
directive|ifdef
name|S_ISSOCK
operator|||
name|S_ISSOCK
argument_list|(
name|fileinfo
operator|.
name|st_mode
argument_list|)
endif|#
directive|endif
comment|/* S_ISSOCK */
operator|)
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|sockpath
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sockpath
argument_list|)
expr_stmt|;
name|sockpath
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NETUNIX */
block|}
operator|(
name|void
operator|)
name|smutex_unlock
argument_list|(
operator|&
name|L_Mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  MI_LISTENER -- Generic listener harness ** **	Open up listen port **	Wait for connections ** **	Parameters: **		conn -- connection description **		dbg -- debug level **		smfi -- filter structure to use **		timeout -- timeout for reads/writes **		backlog -- listen queue backlog size ** **	Returns: **		MI_SUCCESS -- Exited normally **			   (session finished or we were told to exit) **		MI_FAILURE -- Network initialization failed. */
end_comment

begin_if
if|#
directive|if
name|BROKEN_PTHREAD_SLEEP
end_if

begin_comment
comment|/* **  Solaris 2.6, perhaps others, gets an internal threads library panic **  when sleep() is used: ** **  thread_create() failed, returned 11 (EINVAL) **  co_enable, thr_create() returned error = 24 **  libthread panic: co_enable failed (PID: 17793 LWP 1) **  stacktrace: **	ef526b10 **	ef52646c **	ef534cbc **	156a4 **	14644 **	1413c **	135e0 **	0 */
end_comment

begin_define
define|#
directive|define
name|MI_SLEEP
parameter_list|(
name|s
parameter_list|)
define|\
value|{									\ 	int rs = 0;							\ 	struct timeval st;						\ 									\ 	st.tv_sec = (s);						\ 	st.tv_usec = 0;							\ 	if (st.tv_sec> 0)						\ 	{								\ 		for (;;)						\ 		{							\ 			rs = select(0, NULL, NULL, NULL,&st);		\ 			if (rs< 0&& errno == EINTR)			\ 				continue;				\ 			if (rs != 0)					\ 			{						\ 				smi_log(SMI_LOG_ERR,			\ 					"MI_SLEEP(): select() returned non-zero result %d, errno = %d",	\ 					rs, errno);			\ 			}						\ 			break;						\ 		}							\ 	}								\ }
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* BROKEN_PTHREAD_SLEEP */
end_comment

begin_define
define|#
directive|define
name|MI_SLEEP
parameter_list|(
name|s
parameter_list|)
value|sleep((s))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BROKEN_PTHREAD_SLEEP */
end_comment

begin_function
name|int
name|mi_listener
parameter_list|(
name|conn
parameter_list|,
name|dbg
parameter_list|,
name|smfi
parameter_list|,
name|timeout
parameter_list|,
name|backlog
parameter_list|)
name|char
modifier|*
name|conn
decl_stmt|;
name|int
name|dbg
decl_stmt|;
name|smfiDesc_ptr
name|smfi
decl_stmt|;
name|time_t
name|timeout
decl_stmt|;
name|int
name|backlog
decl_stmt|;
block|{
name|socket_t
name|connfd
init|=
name|INVALID_SOCKET
decl_stmt|;
if|#
directive|if
name|_FFR_DUP_FD
name|socket_t
name|dupfd
init|=
name|INVALID_SOCKET
decl_stmt|;
endif|#
directive|endif
comment|/* _FFR_DUP_FD */
name|int
name|sockopt
init|=
literal|1
decl_stmt|;
name|int
name|r
decl_stmt|,
name|mistop
decl_stmt|;
name|int
name|ret
init|=
name|MI_SUCCESS
decl_stmt|;
name|int
name|mcnt
init|=
literal|0
decl_stmt|;
comment|/* error count for malloc() failures */
name|int
name|tcnt
init|=
literal|0
decl_stmt|;
comment|/* error count for thread_create() failures */
name|int
name|acnt
init|=
literal|0
decl_stmt|;
comment|/* error count for accept() failures */
name|int
name|scnt
init|=
literal|0
decl_stmt|;
comment|/* error count for select() failures */
name|int
name|save_errno
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|!
name|_FFR_WORKERS_POOL
name|sthread_t
name|thread_id
decl_stmt|;
endif|#
directive|endif
comment|/* !_FFR_WORKERS_POOL */
name|_SOCK_ADDR
name|cliaddr
decl_stmt|;
name|SOCKADDR_LEN_T
name|clilen
decl_stmt|;
name|SMFICTX_PTR
name|ctx
decl_stmt|;
name|FD_RD_VAR
argument_list|(
name|rds
argument_list|,
name|excs
argument_list|)
expr_stmt|;
name|struct
name|timeval
name|chktime
decl_stmt|;
if|if
condition|(
name|mi_opensocket
argument_list|(
name|conn
argument_list|,
name|backlog
argument_list|,
name|dbg
argument_list|,
name|false
argument_list|,
name|smfi
argument_list|)
operator|==
name|MI_FAILURE
condition|)
return|return
name|MI_FAILURE
return|;
if|#
directive|if
name|_FFR_WORKERS_POOL
if|if
condition|(
name|mi_pool_controller_init
argument_list|()
operator|==
name|MI_FAILURE
condition|)
return|return
name|MI_FAILURE
return|;
endif|#
directive|endif
comment|/* _FFR_WORKERS_POOL */
name|clilen
operator|=
name|L_socksize
expr_stmt|;
while|while
condition|(
operator|(
name|mistop
operator|=
name|mi_stop
argument_list|()
operator|)
operator|==
name|MILTER_CONT
condition|)
block|{
operator|(
name|void
operator|)
name|smutex_lock
argument_list|(
operator|&
name|L_Mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ValidSocket
argument_list|(
name|listenfd
argument_list|)
condition|)
block|{
name|ret
operator|=
name|MI_FAILURE
expr_stmt|;
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: listenfd=%d corrupted, terminating, errno=%d"
argument_list|,
name|smfi
operator|->
name|xxfi_name
argument_list|,
name|listenfd
argument_list|,
name|errno
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|smutex_unlock
argument_list|(
operator|&
name|L_Mutex
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* select on interface ports */
name|FD_RD_INIT
argument_list|(
name|listenfd
argument_list|,
name|rds
argument_list|,
name|excs
argument_list|)
expr_stmt|;
name|chktime
operator|.
name|tv_sec
operator|=
name|MI_CHK_TIME
expr_stmt|;
name|chktime
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|FD_RD_READY
argument_list|(
name|listenfd
argument_list|,
name|rds
argument_list|,
name|excs
argument_list|,
operator|&
name|chktime
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
comment|/* timeout */
block|{
operator|(
name|void
operator|)
name|smutex_unlock
argument_list|(
operator|&
name|L_Mutex
argument_list|)
expr_stmt|;
continue|continue;
comment|/* just check mi_stop() */
block|}
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|smutex_unlock
argument_list|(
operator|&
name|L_Mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_errno
operator|==
name|EINTR
condition|)
continue|continue;
name|scnt
operator|++
expr_stmt|;
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: select() failed (%s), %s"
argument_list|,
name|smfi
operator|->
name|xxfi_name
argument_list|,
name|sm_errstring
argument_list|(
name|save_errno
argument_list|)
argument_list|,
name|scnt
operator|>=
name|MAX_FAILS_S
condition|?
literal|"abort"
else|:
literal|"try again"
argument_list|)
expr_stmt|;
name|MI_SLEEP
argument_list|(
name|scnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|scnt
operator|>=
name|MAX_FAILS_S
condition|)
block|{
name|ret
operator|=
name|MI_FAILURE
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
if|if
condition|(
operator|!
name|FD_IS_RD_RDY
argument_list|(
name|listenfd
argument_list|,
name|rds
argument_list|,
name|excs
argument_list|)
condition|)
block|{
comment|/* some error: just stop for now... */
name|ret
operator|=
name|MI_FAILURE
expr_stmt|;
operator|(
name|void
operator|)
name|smutex_unlock
argument_list|(
operator|&
name|L_Mutex
argument_list|)
expr_stmt|;
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: %s() returned exception for socket, abort"
argument_list|,
name|smfi
operator|->
name|xxfi_name
argument_list|,
name|MI_POLLSELECT
argument_list|)
expr_stmt|;
break|break;
block|}
name|scnt
operator|=
literal|0
expr_stmt|;
comment|/* reset error counter for select() */
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|&
name|cliaddr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|cliaddr
argument_list|)
expr_stmt|;
name|connfd
operator|=
name|accept
argument_list|(
name|listenfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|cliaddr
argument_list|,
operator|&
name|clilen
argument_list|)
expr_stmt|;
name|save_errno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|smutex_unlock
argument_list|(
operator|&
name|L_Mutex
argument_list|)
expr_stmt|;
comment|/* 		**  If remote side closes before accept() finishes, 		**  sockaddr might not be fully filled in. 		*/
if|if
condition|(
name|ValidSocket
argument_list|(
name|connfd
argument_list|)
operator|&&
operator|(
name|clilen
operator|==
literal|0
operator|||
ifdef|#
directive|ifdef
name|BSD4_4_SOCKADDR
name|cliaddr
operator|.
name|sa
operator|.
name|sa_len
operator|==
literal|0
operator|||
endif|#
directive|endif
comment|/* BSD4_4_SOCKADDR */
name|cliaddr
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|L_family
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|closesocket
argument_list|(
name|connfd
argument_list|)
expr_stmt|;
name|connfd
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|save_errno
operator|=
name|EINVAL
expr_stmt|;
block|}
comment|/* check if acceptable for select() */
if|if
condition|(
name|ValidSocket
argument_list|(
name|connfd
argument_list|)
operator|&&
operator|!
name|SM_FD_OK_SELECT
argument_list|(
name|connfd
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|closesocket
argument_list|(
name|connfd
argument_list|)
expr_stmt|;
name|connfd
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|save_errno
operator|=
name|ERANGE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ValidSocket
argument_list|(
name|connfd
argument_list|)
condition|)
block|{
if|if
condition|(
name|save_errno
operator|==
name|EINTR
ifdef|#
directive|ifdef
name|EAGAIN
operator|||
name|save_errno
operator|==
name|EAGAIN
endif|#
directive|endif
comment|/* EAGAIN */
ifdef|#
directive|ifdef
name|ECONNABORTED
operator|||
name|save_errno
operator|==
name|ECONNABORTED
endif|#
directive|endif
comment|/* ECONNABORTED */
ifdef|#
directive|ifdef
name|EMFILE
operator|||
name|save_errno
operator|==
name|EMFILE
endif|#
directive|endif
comment|/* EMFILE */
ifdef|#
directive|ifdef
name|ENFILE
operator|||
name|save_errno
operator|==
name|ENFILE
endif|#
directive|endif
comment|/* ENFILE */
ifdef|#
directive|ifdef
name|ENOBUFS
operator|||
name|save_errno
operator|==
name|ENOBUFS
endif|#
directive|endif
comment|/* ENOBUFS */
ifdef|#
directive|ifdef
name|ENOMEM
operator|||
name|save_errno
operator|==
name|ENOMEM
endif|#
directive|endif
comment|/* ENOMEM */
ifdef|#
directive|ifdef
name|ENOSR
operator|||
name|save_errno
operator|==
name|ENOSR
endif|#
directive|endif
comment|/* ENOSR */
ifdef|#
directive|ifdef
name|EWOULDBLOCK
operator|||
name|save_errno
operator|==
name|EWOULDBLOCK
endif|#
directive|endif
comment|/* EWOULDBLOCK */
condition|)
continue|continue;
name|acnt
operator|++
expr_stmt|;
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: accept() returned invalid socket (%s), %s"
argument_list|,
name|smfi
operator|->
name|xxfi_name
argument_list|,
name|sm_errstring
argument_list|(
name|save_errno
argument_list|)
argument_list|,
name|acnt
operator|>=
name|MAX_FAILS_A
condition|?
literal|"abort"
else|:
literal|"try again"
argument_list|)
expr_stmt|;
name|MI_SLEEP
argument_list|(
name|acnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|acnt
operator|>=
name|MAX_FAILS_A
condition|)
block|{
name|ret
operator|=
name|MI_FAILURE
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
name|acnt
operator|=
literal|0
expr_stmt|;
comment|/* reset error counter for accept() */
if|#
directive|if
name|_FFR_DUP_FD
name|dupfd
operator|=
name|fcntl
argument_list|(
name|connfd
argument_list|,
name|F_DUPFD
argument_list|,
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|ValidSocket
argument_list|(
name|dupfd
argument_list|)
operator|&&
name|SM_FD_OK_SELECT
argument_list|(
name|dupfd
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|connfd
argument_list|)
expr_stmt|;
name|connfd
operator|=
name|dupfd
expr_stmt|;
name|dupfd
operator|=
name|INVALID_SOCKET
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _FFR_DUP_FD */
if|if
condition|(
name|setsockopt
argument_list|(
name|connfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sockopt
argument_list|,
sizeof|sizeof
name|sockopt
argument_list|)
operator|<
literal|0
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_WARN
argument_list|,
literal|"%s: set keepalive failed (%s)"
argument_list|,
name|smfi
operator|->
name|xxfi_name
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX: continue? */
block|}
if|if
condition|(
operator|(
name|ctx
operator|=
operator|(
name|SMFICTX_PTR
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|ctx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|closesocket
argument_list|(
name|connfd
argument_list|)
expr_stmt|;
name|mcnt
operator|++
expr_stmt|;
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: malloc(ctx) failed (%s), %s"
argument_list|,
name|smfi
operator|->
name|xxfi_name
argument_list|,
name|sm_errstring
argument_list|(
name|save_errno
argument_list|)
argument_list|,
name|mcnt
operator|>=
name|MAX_FAILS_M
condition|?
literal|"abort"
else|:
literal|"try again"
argument_list|)
expr_stmt|;
name|MI_SLEEP
argument_list|(
name|mcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcnt
operator|>=
name|MAX_FAILS_M
condition|)
block|{
name|ret
operator|=
name|MI_FAILURE
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
name|mcnt
operator|=
literal|0
expr_stmt|;
comment|/* reset error counter for malloc() */
operator|(
name|void
operator|)
name|memset
argument_list|(
name|ctx
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
expr|*
name|ctx
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ctx_sd
operator|=
name|connfd
expr_stmt|;
name|ctx
operator|->
name|ctx_dbg
operator|=
name|dbg
expr_stmt|;
name|ctx
operator|->
name|ctx_timeout
operator|=
name|timeout
expr_stmt|;
name|ctx
operator|->
name|ctx_smfi
operator|=
name|smfi
expr_stmt|;
if|if
condition|(
name|smfi
operator|->
name|xxfi_connect
operator|==
name|NULL
condition|)
name|ctx
operator|->
name|ctx_pflags
operator||=
name|SMFIP_NOCONNECT
expr_stmt|;
if|if
condition|(
name|smfi
operator|->
name|xxfi_helo
operator|==
name|NULL
condition|)
name|ctx
operator|->
name|ctx_pflags
operator||=
name|SMFIP_NOHELO
expr_stmt|;
if|if
condition|(
name|smfi
operator|->
name|xxfi_envfrom
operator|==
name|NULL
condition|)
name|ctx
operator|->
name|ctx_pflags
operator||=
name|SMFIP_NOMAIL
expr_stmt|;
if|if
condition|(
name|smfi
operator|->
name|xxfi_envrcpt
operator|==
name|NULL
condition|)
name|ctx
operator|->
name|ctx_pflags
operator||=
name|SMFIP_NORCPT
expr_stmt|;
if|if
condition|(
name|smfi
operator|->
name|xxfi_header
operator|==
name|NULL
condition|)
name|ctx
operator|->
name|ctx_pflags
operator||=
name|SMFIP_NOHDRS
expr_stmt|;
if|if
condition|(
name|smfi
operator|->
name|xxfi_eoh
operator|==
name|NULL
condition|)
name|ctx
operator|->
name|ctx_pflags
operator||=
name|SMFIP_NOEOH
expr_stmt|;
if|if
condition|(
name|smfi
operator|->
name|xxfi_body
operator|==
name|NULL
condition|)
name|ctx
operator|->
name|ctx_pflags
operator||=
name|SMFIP_NOBODY
expr_stmt|;
if|if
condition|(
name|smfi
operator|->
name|xxfi_version
operator|<=
literal|3
operator|||
name|smfi
operator|->
name|xxfi_data
operator|==
name|NULL
condition|)
name|ctx
operator|->
name|ctx_pflags
operator||=
name|SMFIP_NODATA
expr_stmt|;
if|if
condition|(
name|smfi
operator|->
name|xxfi_version
operator|<=
literal|2
operator|||
name|smfi
operator|->
name|xxfi_unknown
operator|==
name|NULL
condition|)
name|ctx
operator|->
name|ctx_pflags
operator||=
name|SMFIP_NOUNKNOWN
expr_stmt|;
if|#
directive|if
name|_FFR_WORKERS_POOL
define|#
directive|define
name|LOG_CRT_FAIL
value|"%s: mi_start_session() failed: %d, %s"
if|if
condition|(
operator|(
name|r
operator|=
name|mi_start_session
argument_list|(
name|ctx
argument_list|)
operator|)
operator|!=
name|MI_SUCCESS
condition|)
else|#
directive|else
comment|/* _FFR_WORKERS_POOL */
define|#
directive|define
name|LOG_CRT_FAIL
value|"%s: thread_create() failed: %d, %s"
if|if
condition|(
operator|(
name|r
operator|=
name|thread_create
argument_list|(
operator|&
name|thread_id
argument_list|,
name|mi_thread_handle_wrapper
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ctx
argument_list|)
operator|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
comment|/* _FFR_WORKERS_POOL */
block|{
name|tcnt
operator|++
expr_stmt|;
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
name|LOG_CRT_FAIL
argument_list|,
name|smfi
operator|->
name|xxfi_name
argument_list|,
name|r
argument_list|,
name|tcnt
operator|>=
name|MAX_FAILS_T
condition|?
literal|"abort"
else|:
literal|"try again"
argument_list|)
expr_stmt|;
name|MI_SLEEP
argument_list|(
name|tcnt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closesocket
argument_list|(
name|connfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcnt
operator|>=
name|MAX_FAILS_T
condition|)
block|{
name|ret
operator|=
name|MI_FAILURE
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
name|tcnt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
name|MI_SUCCESS
condition|)
name|mi_stop_milters
argument_list|(
name|MILTER_ABRT
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|mistop
operator|!=
name|MILTER_CONT
condition|)
name|smi_log
argument_list|(
name|SMI_LOG_INFO
argument_list|,
literal|"%s: mi_stop=%d"
argument_list|,
name|smfi
operator|->
name|xxfi_name
argument_list|,
name|mistop
argument_list|)
expr_stmt|;
name|mi_closener
argument_list|()
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|smutex_destroy
argument_list|(
operator|&
name|L_Mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

