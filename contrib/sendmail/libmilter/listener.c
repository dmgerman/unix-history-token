begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Copyright (c) 1999-2002 Sendmail, Inc. and its suppliers.  *	All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_include
include|#
directive|include
file|<sm/gen.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: listener.c,v 1.1.1.7 2002/04/10 03:05:00 gshapiro Exp $"
argument_list|)
end_macro

begin_comment
comment|/* **  listener.c -- threaded network listener */
end_comment

begin_include
include|#
directive|include
file|"libmilter.h"
end_include

begin_include
include|#
directive|include
file|<sm/errstring.h>
end_include

begin_if
if|#
directive|if
name|NETINET
operator|||
name|NETINET6
end_if

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NETINET || NETINET6 */
end_comment

begin_decl_stmt
specifier|static
name|smutex_t
name|L_Mutex
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  MI_MILTEROPEN -- setup socket to listen on ** **	Parameters: **		conn -- connection description **		backlog -- listen backlog **		socksize -- socksize of created socket **		family -- family of created socket **		name -- name for logging ** **	Returns: **		socket upon success, error code otherwise. ** **	Side effect: **		sets sockpath if UNIX socket. */
end_comment

begin_if
if|#
directive|if
name|NETUNIX
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sockpath
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NETUNIX */
end_comment

begin_function
specifier|static
name|socket_t
name|mi_milteropen
parameter_list|(
name|conn
parameter_list|,
name|backlog
parameter_list|,
name|socksize
parameter_list|,
name|family
parameter_list|,
name|name
parameter_list|)
name|char
modifier|*
name|conn
decl_stmt|;
name|int
name|backlog
decl_stmt|;
name|SOCKADDR_LEN_T
modifier|*
name|socksize
decl_stmt|;
name|int
modifier|*
name|family
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|socket_t
name|sock
decl_stmt|;
name|int
name|sockopt
init|=
literal|1
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|colon
decl_stmt|;
name|char
modifier|*
name|at
decl_stmt|;
name|SOCKADDR
name|addr
decl_stmt|;
if|if
condition|(
name|conn
operator|==
name|NULL
operator|||
name|conn
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: empty or missing socket information"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|&
name|addr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|addr
argument_list|)
expr_stmt|;
comment|/* protocol:filename or protocol:port@host */
name|p
operator|=
name|conn
expr_stmt|;
name|colon
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|colon
operator|!=
name|NULL
condition|)
block|{
operator|*
name|colon
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
if|#
directive|if
name|NETUNIX
comment|/* default to AF_UNIX */
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_UNIX
expr_stmt|;
operator|*
name|socksize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* NETUNIX */
if|#
directive|if
name|NETINET
comment|/* default to AF_INET */
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
operator|*
name|socksize
operator|=
sizeof|sizeof
name|addr
operator|.
name|sin
expr_stmt|;
else|#
directive|else
comment|/* NETINET */
if|#
directive|if
name|NETINET6
comment|/* default to AF_INET6 */
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET6
expr_stmt|;
operator|*
name|socksize
operator|=
sizeof|sizeof
name|addr
operator|.
name|sin6
expr_stmt|;
else|#
directive|else
comment|/* NETINET6 */
comment|/* no protocols available */
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: no valid socket protocols available"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
endif|#
directive|endif
comment|/* NETINET6 */
endif|#
directive|endif
comment|/* NETINET */
endif|#
directive|endif
comment|/* NETUNIX */
block|}
if|#
directive|if
name|NETUNIX
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|p
argument_list|,
literal|"unix"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
name|p
argument_list|,
literal|"local"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_UNIX
expr_stmt|;
operator|*
name|socksize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NETUNIX */
if|#
directive|if
name|NETINET
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|p
argument_list|,
literal|"inet"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
operator|*
name|socksize
operator|=
sizeof|sizeof
name|addr
operator|.
name|sin
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET6
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|p
argument_list|,
literal|"inet6"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET6
expr_stmt|;
operator|*
name|socksize
operator|=
sizeof|sizeof
name|addr
operator|.
name|sin6
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NETINET6 */
else|else
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: unknown socket type %s"
argument_list|,
name|name
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
operator|*
name|colon
operator|++
operator|=
literal|':'
expr_stmt|;
block|}
else|else
block|{
name|colon
operator|=
name|p
expr_stmt|;
if|#
directive|if
name|NETUNIX
comment|/* default to AF_UNIX */
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_UNIX
expr_stmt|;
operator|*
name|socksize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* NETUNIX */
if|#
directive|if
name|NETINET
comment|/* default to AF_INET */
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
operator|*
name|socksize
operator|=
sizeof|sizeof
name|addr
operator|.
name|sin
expr_stmt|;
else|#
directive|else
comment|/* NETINET */
if|#
directive|if
name|NETINET6
comment|/* default to AF_INET6 */
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET6
expr_stmt|;
operator|*
name|socksize
operator|=
sizeof|sizeof
name|addr
operator|.
name|sin6
expr_stmt|;
else|#
directive|else
comment|/* NETINET6 */
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: unknown socket type %s"
argument_list|,
name|name
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
endif|#
directive|endif
comment|/* NETINET6 */
endif|#
directive|endif
comment|/* NETINET */
endif|#
directive|endif
comment|/* NETUNIX */
block|}
if|#
directive|if
name|NETUNIX
if|if
condition|(
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_UNIX
condition|)
block|{
if|#
directive|if
literal|0
block|long sff = SFF_SAFEDIRPATH|SFF_OPENASROOT|SFF_NOLINK|SFF_CREAT|SFF_MUSTOWN;
endif|#
directive|endif
comment|/* 0 */
name|at
operator|=
name|colon
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|colon
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
name|addr
operator|.
name|sunix
operator|.
name|sun_path
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: UNIX socket name %s too long"
argument_list|,
name|name
argument_list|,
name|colon
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|addr
operator|.
name|sunix
operator|.
name|sun_path
argument_list|,
name|colon
argument_list|,
sizeof|sizeof
name|addr
operator|.
name|sunix
operator|.
name|sun_path
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|errno = safefile(colon, RunAsUid, RunAsGid, RunAsUserName, sff, 				 S_IRUSR|S_IWUSR, NULL);
comment|/* if not safe, don't create */
block|if (errno != 0) 		{ 			smi_log(SMI_LOG_ERR, 				"%s: UNIX socket name %s unsafe", 				name, colon); 			return INVALID_SOCKET; 		}
endif|#
directive|endif
comment|/* 0 */
block|}
endif|#
directive|endif
comment|/* NETUNIX */
if|#
directive|if
name|NETINET
operator|||
name|NETINET6
if|if
condition|(
if|#
directive|if
name|NETINET
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET
operator|&&
name|NETINET6
operator|||
endif|#
directive|endif
comment|/* NETINET&& NETINET6 */
if|#
directive|if
name|NETINET6
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
endif|#
directive|endif
comment|/* NETINET6 */
condition|)
block|{
name|unsigned
name|short
name|port
decl_stmt|;
comment|/* Parse port@host */
name|at
operator|=
name|strchr
argument_list|(
name|colon
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|addr
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
if|#
directive|if
name|NETINET
case|case
name|AF_INET
case|:
name|addr
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET6
case|case
name|AF_INET6
case|:
name|addr
operator|.
name|sin6
operator|.
name|sin6_addr
operator|=
name|in6addr_any
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET6 */
block|}
block|}
else|else
operator|*
name|at
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|isascii
argument_list|(
operator|*
name|colon
argument_list|)
operator|&&
name|isdigit
argument_list|(
operator|*
name|colon
argument_list|)
condition|)
name|port
operator|=
name|htons
argument_list|(
operator|(
name|unsigned
name|short
operator|)
name|atoi
argument_list|(
name|colon
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|NO_GETSERVBYNAME
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: invalid port number %s"
argument_list|,
name|name
argument_list|,
name|colon
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
else|#
directive|else
comment|/* NO_GETSERVBYNAME */
specifier|register
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|getservbyname
argument_list|(
name|colon
argument_list|,
literal|"tcp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: unknown port name %s"
argument_list|,
name|name
argument_list|,
name|colon
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
name|port
operator|=
name|sp
operator|->
name|s_port
expr_stmt|;
endif|#
directive|endif
comment|/* NO_GETSERVBYNAME */
block|}
if|if
condition|(
name|at
operator|!=
name|NULL
condition|)
block|{
operator|*
name|at
operator|++
operator|=
literal|'@'
expr_stmt|;
if|if
condition|(
operator|*
name|at
operator|==
literal|'['
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|end
operator|=
name|strchr
argument_list|(
name|at
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|!=
name|NULL
condition|)
block|{
name|bool
name|found
init|=
name|false
decl_stmt|;
if|#
directive|if
name|NETINET
name|unsigned
name|long
name|hid
init|=
name|INADDR_NONE
decl_stmt|;
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET6
name|struct
name|sockaddr_in6
name|hid6
decl_stmt|;
endif|#
directive|endif
comment|/* NETINET6 */
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
if|#
directive|if
name|NETINET
if|if
condition|(
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
operator|&&
operator|(
name|hid
operator|=
name|inet_addr
argument_list|(
operator|&
name|at
index|[
literal|1
index|]
argument_list|)
operator|)
operator|!=
name|INADDR_NONE
condition|)
block|{
name|addr
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|hid
expr_stmt|;
name|addr
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET6
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|&
name|hid6
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|hid6
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
operator|&&
name|mi_inet_pton
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|at
index|[
literal|1
index|]
argument_list|,
operator|&
name|hid6
operator|.
name|sin6_addr
argument_list|)
operator|==
literal|1
condition|)
block|{
name|addr
operator|.
name|sin6
operator|.
name|sin6_addr
operator|=
name|hid6
operator|.
name|sin6_addr
expr_stmt|;
name|addr
operator|.
name|sin6
operator|.
name|sin6_port
operator|=
name|port
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NETINET6 */
operator|*
name|end
operator|=
literal|']'
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: Invalid numeric domain spec \"%s\""
argument_list|,
name|name
argument_list|,
name|at
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
block|}
else|else
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: Invalid numeric domain spec \"%s\""
argument_list|,
name|name
argument_list|,
name|at
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
block|}
else|else
block|{
name|struct
name|hostent
modifier|*
name|hp
init|=
name|NULL
decl_stmt|;
name|hp
operator|=
name|mi_gethostbyname
argument_list|(
name|at
argument_list|,
name|addr
operator|.
name|sa
operator|.
name|sa_family
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: Unknown host name %s"
argument_list|,
name|name
argument_list|,
name|at
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
switch|switch
condition|(
name|hp
operator|->
name|h_addrtype
condition|)
block|{
if|#
directive|if
name|NETINET
case|case
name|AF_INET
case|:
name|memmove
argument_list|(
operator|&
name|addr
operator|.
name|sin
operator|.
name|sin_addr
argument_list|,
name|hp
operator|->
name|h_addr
argument_list|,
name|INADDRSZ
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET6
case|case
name|AF_INET6
case|:
name|memmove
argument_list|(
operator|&
name|addr
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|,
name|hp
operator|->
name|h_addr
argument_list|,
name|IN6ADDRSZ
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin6
operator|.
name|sin6_port
operator|=
name|port
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET6 */
default|default:
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: Unknown protocol for %s (%d)"
argument_list|,
name|name
argument_list|,
name|at
argument_list|,
name|hp
operator|->
name|h_addrtype
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
if|#
directive|if
name|NETINET6
name|freehostent
argument_list|(
name|hp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NETINET6 */
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|addr
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
if|#
directive|if
name|NETINET
case|case
name|AF_INET
case|:
name|addr
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET6
case|case
name|AF_INET6
case|:
name|addr
operator|.
name|sin6
operator|.
name|sin6_port
operator|=
name|port
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET6 */
block|}
block|}
block|}
endif|#
directive|endif
comment|/* NETINET || NETINET6 */
name|sock
operator|=
name|socket
argument_list|(
name|addr
operator|.
name|sa
operator|.
name|sa_family
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ValidSocket
argument_list|(
name|sock
argument_list|)
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: Unable to create new socket: %s"
argument_list|,
name|name
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
if|if
condition|(
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sockopt
argument_list|,
sizeof|sizeof
argument_list|(
name|sockopt
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: Unable to setsockopt: %s"
argument_list|,
name|name
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closesocket
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
if|if
condition|(
name|bind
argument_list|(
name|sock
argument_list|,
operator|&
name|addr
operator|.
name|sa
argument_list|,
operator|*
name|socksize
argument_list|)
operator|<
literal|0
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: Unable to bind to port %s: %s"
argument_list|,
name|name
argument_list|,
name|conn
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closesocket
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
if|if
condition|(
name|listen
argument_list|(
name|sock
argument_list|,
name|backlog
argument_list|)
operator|<
literal|0
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: listen call failed: %s"
argument_list|,
name|name
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closesocket
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
if|#
directive|if
name|NETUNIX
if|if
condition|(
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_UNIX
operator|&&
name|len
operator|>
literal|0
condition|)
block|{
comment|/* 		**  Set global variable sockpath so the UNIX socket can be 		**  unlink()ed at exit. 		*/
name|sockpath
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockpath
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|sockpath
argument_list|,
name|colon
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: can't malloc(%d) for sockpath: %s"
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closesocket
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
name|INVALID_SOCKET
return|;
block|}
block|}
endif|#
directive|endif
comment|/* NETUNIX */
operator|*
name|family
operator|=
name|addr
operator|.
name|sa
operator|.
name|sa_family
expr_stmt|;
return|return
name|sock
return|;
block|}
end_function

begin_comment
comment|/* **  MI_THREAD_HANDLE_WRAPPER -- small wrapper to handle session ** **	Parameters: **		arg -- argument to pass to mi_handle_session() ** **	Returns: **		results from mi_handle_session() */
end_comment

begin_function
name|void
modifier|*
name|mi_thread_handle_wrapper
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
return|return
operator|(
name|void
operator|*
operator|)
name|mi_handle_session
argument_list|(
name|arg
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|socket_t
name|listenfd
init|=
name|INVALID_SOCKET
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  MI_CLOSENER -- close listen socket ** **	NOTE: It is assumed that this function is called from a **	      function that has a mutex lock (currently mi_stop_milters()). ** **	Parameters: **		none. ** **	Returns: **		none. */
end_comment

begin_function
name|void
name|mi_closener
parameter_list|()
block|{
operator|(
name|void
operator|)
name|smutex_lock
argument_list|(
operator|&
name|L_Mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ValidSocket
argument_list|(
name|listenfd
argument_list|)
condition|)
block|{
if|#
directive|if
name|NETUNIX
name|bool
name|removable
decl_stmt|;
name|struct
name|stat
name|sockinfo
decl_stmt|;
name|struct
name|stat
name|fileinfo
decl_stmt|;
name|removable
operator|=
name|sockpath
operator|!=
name|NULL
operator|&&
if|#
directive|if
name|_FFR_MILTER_ROOT_UNSAFE
name|geteuid
argument_list|()
operator|!=
literal|0
operator|&&
endif|#
directive|endif
comment|/* _FFR_MILTER_ROOT_UNSAFE */
name|fstat
argument_list|(
name|listenfd
argument_list|,
operator|&
name|sockinfo
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|S_ISFIFO
argument_list|(
name|sockinfo
operator|.
name|st_mode
argument_list|)
ifdef|#
directive|ifdef
name|S_ISSOCK
operator|||
name|S_ISSOCK
argument_list|(
name|sockinfo
operator|.
name|st_mode
argument_list|)
endif|#
directive|endif
comment|/* S_ISSOCK */
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* NETUNIX */
operator|(
name|void
operator|)
name|closesocket
argument_list|(
name|listenfd
argument_list|)
expr_stmt|;
name|listenfd
operator|=
name|INVALID_SOCKET
expr_stmt|;
if|#
directive|if
name|NETUNIX
comment|/* XXX sleep() some time before doing this? */
if|if
condition|(
name|sockpath
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|removable
operator|&&
name|stat
argument_list|(
name|sockpath
argument_list|,
operator|&
name|fileinfo
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|fileinfo
operator|.
name|st_dev
operator|==
name|sockinfo
operator|.
name|st_dev
operator|&&
name|fileinfo
operator|.
name|st_ino
operator|==
name|sockinfo
operator|.
name|st_ino
operator|)
ifdef|#
directive|ifdef
name|S_ISSOCK
operator|||
name|S_ISSOCK
argument_list|(
name|fileinfo
operator|.
name|st_mode
argument_list|)
endif|#
directive|endif
comment|/* S_ISSOCK */
operator|)
operator|&&
operator|(
name|S_ISFIFO
argument_list|(
name|fileinfo
operator|.
name|st_mode
argument_list|)
ifdef|#
directive|ifdef
name|S_ISSOCK
operator|||
name|S_ISSOCK
argument_list|(
name|fileinfo
operator|.
name|st_mode
argument_list|)
endif|#
directive|endif
comment|/* S_ISSOCK */
operator|)
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|sockpath
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sockpath
argument_list|)
expr_stmt|;
name|sockpath
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NETUNIX */
block|}
operator|(
name|void
operator|)
name|smutex_unlock
argument_list|(
operator|&
name|L_Mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  MI_LISTENER -- Generic listener harness ** **	Open up listen port **	Wait for connections ** **	Parameters: **		conn -- connection description **		dbg -- debug level **		smfi -- filter structure to use **		timeout -- timeout for reads/writes ** **	Returns: **		MI_SUCCESS -- Exited normally **			   (session finished or we were told to exit) **		MI_FAILURE -- Network initialization failed. */
end_comment

begin_if
if|#
directive|if
name|BROKEN_PTHREAD_SLEEP
end_if

begin_comment
comment|/* **  Solaris 2.6, perhaps others, gets an internal threads library panic **  when sleep() is used: ** **  thread_create() failed, returned 11 (EINVAL) **  co_enable, thr_create() returned error = 24 **  libthread panic: co_enable failed (PID: 17793 LWP 1) **  stacktrace: **	ef526b10 **	ef52646c **	ef534cbc **	156a4 **	14644 **	1413c **	135e0 **	0 */
end_comment

begin_define
define|#
directive|define
name|MI_SLEEP
parameter_list|(
name|s
parameter_list|)
define|\
value|{									\ 	int rs = 0;							\ 	struct timeval st;						\ 									\ 	st.tv_sec = (s);						\ 	st.tv_usec = 0;							\ 	if (st.tv_sec> 0)						\ 		rs = select(0, NULL, NULL, NULL,&st);			\ 	if (rs != 0)							\ 	{								\ 		smi_log(SMI_LOG_ERR,					\ 			"MI_SLEEP(): select() returned non-zero result %d, errno = %d",								\ 			rs, errno);					\ 	}								\ }
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* BROKEN_PTHREAD_SLEEP */
end_comment

begin_define
define|#
directive|define
name|MI_SLEEP
parameter_list|(
name|s
parameter_list|)
value|sleep((s))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BROKEN_PTHREAD_SLEEP */
end_comment

begin_function
name|int
name|mi_listener
parameter_list|(
name|conn
parameter_list|,
name|dbg
parameter_list|,
name|smfi
parameter_list|,
name|timeout
parameter_list|,
name|backlog
parameter_list|)
name|char
modifier|*
name|conn
decl_stmt|;
name|int
name|dbg
decl_stmt|;
name|smfiDesc_ptr
name|smfi
decl_stmt|;
name|time_t
name|timeout
decl_stmt|;
name|int
name|backlog
decl_stmt|;
block|{
name|socket_t
name|connfd
init|=
name|INVALID_SOCKET
decl_stmt|;
name|int
name|family
init|=
name|AF_UNSPEC
decl_stmt|;
name|int
name|sockopt
init|=
literal|1
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|ret
init|=
name|MI_SUCCESS
decl_stmt|;
name|int
name|mcnt
init|=
literal|0
decl_stmt|;
comment|/* error count for malloc() failures */
name|int
name|tcnt
init|=
literal|0
decl_stmt|;
comment|/* error count for thread_create() failures */
name|int
name|acnt
init|=
literal|0
decl_stmt|;
comment|/* error count for accept() failures */
name|int
name|scnt
init|=
literal|0
decl_stmt|;
comment|/* error count for select() failures */
name|int
name|save_errno
init|=
literal|0
decl_stmt|;
name|sthread_t
name|thread_id
decl_stmt|;
name|_SOCK_ADDR
name|cliaddr
decl_stmt|;
name|SOCKADDR_LEN_T
name|socksize
decl_stmt|;
name|SOCKADDR_LEN_T
name|clilen
decl_stmt|;
name|SMFICTX_PTR
name|ctx
decl_stmt|;
name|fd_set
name|readset
decl_stmt|,
name|excset
decl_stmt|;
name|struct
name|timeval
name|chktime
decl_stmt|;
if|if
condition|(
name|dbg
operator|>
literal|0
condition|)
name|smi_log
argument_list|(
name|SMI_LOG_DEBUG
argument_list|,
literal|"%s: Opening listen socket on conn %s"
argument_list|,
name|smfi
operator|->
name|xxfi_name
argument_list|,
name|conn
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|smutex_init
argument_list|(
operator|&
name|L_Mutex
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|smutex_lock
argument_list|(
operator|&
name|L_Mutex
argument_list|)
expr_stmt|;
name|listenfd
operator|=
name|mi_milteropen
argument_list|(
name|conn
argument_list|,
name|backlog
argument_list|,
operator|&
name|socksize
argument_list|,
operator|&
name|family
argument_list|,
name|smfi
operator|->
name|xxfi_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ValidSocket
argument_list|(
name|listenfd
argument_list|)
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_FATAL
argument_list|,
literal|"%s: Unable to create listening socket on conn %s"
argument_list|,
name|smfi
operator|->
name|xxfi_name
argument_list|,
name|conn
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|smutex_unlock
argument_list|(
operator|&
name|L_Mutex
argument_list|)
expr_stmt|;
return|return
name|MI_FAILURE
return|;
block|}
name|clilen
operator|=
name|socksize
expr_stmt|;
if|if
condition|(
name|listenfd
operator|>=
name|FD_SETSIZE
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: fd %d is larger than FD_SETSIZE %d"
argument_list|,
name|smfi
operator|->
name|xxfi_name
argument_list|,
name|listenfd
argument_list|,
name|FD_SETSIZE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|smutex_unlock
argument_list|(
operator|&
name|L_Mutex
argument_list|)
expr_stmt|;
return|return
name|MI_FAILURE
return|;
block|}
operator|(
name|void
operator|)
name|smutex_unlock
argument_list|(
operator|&
name|L_Mutex
argument_list|)
expr_stmt|;
while|while
condition|(
name|mi_stop
argument_list|()
operator|==
name|MILTER_CONT
condition|)
block|{
operator|(
name|void
operator|)
name|smutex_lock
argument_list|(
operator|&
name|L_Mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ValidSocket
argument_list|(
name|listenfd
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|smutex_unlock
argument_list|(
operator|&
name|L_Mutex
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* select on interface ports */
name|FD_ZERO
argument_list|(
operator|&
name|readset
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|excset
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|listenfd
argument_list|,
operator|&
name|readset
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|listenfd
argument_list|,
operator|&
name|excset
argument_list|)
expr_stmt|;
name|chktime
operator|.
name|tv_sec
operator|=
name|MI_CHK_TIME
expr_stmt|;
name|chktime
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|select
argument_list|(
name|listenfd
operator|+
literal|1
argument_list|,
operator|&
name|readset
argument_list|,
name|NULL
argument_list|,
operator|&
name|excset
argument_list|,
operator|&
name|chktime
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
comment|/* timeout */
block|{
operator|(
name|void
operator|)
name|smutex_unlock
argument_list|(
operator|&
name|L_Mutex
argument_list|)
expr_stmt|;
continue|continue;
comment|/* just check mi_stop() */
block|}
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|smutex_unlock
argument_list|(
operator|&
name|L_Mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_errno
operator|==
name|EINTR
condition|)
continue|continue;
name|scnt
operator|++
expr_stmt|;
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: select() failed (%s), %s"
argument_list|,
name|smfi
operator|->
name|xxfi_name
argument_list|,
name|sm_errstring
argument_list|(
name|save_errno
argument_list|)
argument_list|,
name|scnt
operator|>=
name|MAX_FAILS_S
condition|?
literal|"abort"
else|:
literal|"try again"
argument_list|)
expr_stmt|;
name|MI_SLEEP
argument_list|(
name|scnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|scnt
operator|>=
name|MAX_FAILS_S
condition|)
block|{
name|ret
operator|=
name|MI_FAILURE
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
if|if
condition|(
operator|!
name|FD_ISSET
argument_list|(
name|listenfd
argument_list|,
operator|&
name|readset
argument_list|)
condition|)
block|{
comment|/* some error: just stop for now... */
name|ret
operator|=
name|MI_FAILURE
expr_stmt|;
operator|(
name|void
operator|)
name|smutex_unlock
argument_list|(
operator|&
name|L_Mutex
argument_list|)
expr_stmt|;
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: select() returned exception for socket, abort"
argument_list|,
name|smfi
operator|->
name|xxfi_name
argument_list|)
expr_stmt|;
break|break;
block|}
name|scnt
operator|=
literal|0
expr_stmt|;
comment|/* reset error counter for select() */
name|memset
argument_list|(
operator|&
name|cliaddr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|cliaddr
argument_list|)
expr_stmt|;
name|connfd
operator|=
name|accept
argument_list|(
name|listenfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|cliaddr
argument_list|,
operator|&
name|clilen
argument_list|)
expr_stmt|;
name|save_errno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|smutex_unlock
argument_list|(
operator|&
name|L_Mutex
argument_list|)
expr_stmt|;
comment|/* 		**  If remote side closes before 		**  accept() finishes, sockaddr 		**  might not be fully filled in. 		*/
if|if
condition|(
name|ValidSocket
argument_list|(
name|connfd
argument_list|)
operator|&&
operator|(
name|clilen
operator|==
literal|0
operator|||
ifdef|#
directive|ifdef
name|BSD4_4_SOCKADDR
name|cliaddr
operator|.
name|sa
operator|.
name|sa_len
operator|==
literal|0
operator|||
endif|#
directive|endif
comment|/* BSD4_4_SOCKADDR */
name|cliaddr
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|family
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|closesocket
argument_list|(
name|connfd
argument_list|)
expr_stmt|;
name|connfd
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|save_errno
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ValidSocket
argument_list|(
name|connfd
argument_list|)
condition|)
block|{
if|if
condition|(
name|save_errno
operator|==
name|EINTR
condition|)
continue|continue;
name|acnt
operator|++
expr_stmt|;
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: accept() returned invalid socket (%s), %s"
argument_list|,
name|smfi
operator|->
name|xxfi_name
argument_list|,
name|sm_errstring
argument_list|(
name|save_errno
argument_list|)
argument_list|,
name|acnt
operator|>=
name|MAX_FAILS_A
condition|?
literal|"abort"
else|:
literal|"try again"
argument_list|)
expr_stmt|;
name|MI_SLEEP
argument_list|(
name|acnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|acnt
operator|>=
name|MAX_FAILS_A
condition|)
block|{
name|ret
operator|=
name|MI_FAILURE
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
name|acnt
operator|=
literal|0
expr_stmt|;
comment|/* reset error counter for accept() */
if|if
condition|(
name|setsockopt
argument_list|(
name|connfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sockopt
argument_list|,
sizeof|sizeof
name|sockopt
argument_list|)
operator|<
literal|0
condition|)
block|{
name|smi_log
argument_list|(
name|SMI_LOG_WARN
argument_list|,
literal|"%s: setsockopt() failed (%s)"
argument_list|,
name|smfi
operator|->
name|xxfi_name
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX: continue? */
block|}
if|if
condition|(
operator|(
name|ctx
operator|=
operator|(
name|SMFICTX_PTR
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|ctx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|closesocket
argument_list|(
name|connfd
argument_list|)
expr_stmt|;
name|mcnt
operator|++
expr_stmt|;
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: malloc(ctx) failed (%s), %s"
argument_list|,
name|smfi
operator|->
name|xxfi_name
argument_list|,
name|sm_errstring
argument_list|(
name|save_errno
argument_list|)
argument_list|,
name|mcnt
operator|>=
name|MAX_FAILS_M
condition|?
literal|"abort"
else|:
literal|"try again"
argument_list|)
expr_stmt|;
name|MI_SLEEP
argument_list|(
name|mcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcnt
operator|>=
name|MAX_FAILS_M
condition|)
block|{
name|ret
operator|=
name|MI_FAILURE
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
name|mcnt
operator|=
literal|0
expr_stmt|;
comment|/* reset error counter for malloc() */
name|memset
argument_list|(
name|ctx
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
expr|*
name|ctx
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ctx_sd
operator|=
name|connfd
expr_stmt|;
name|ctx
operator|->
name|ctx_dbg
operator|=
name|dbg
expr_stmt|;
name|ctx
operator|->
name|ctx_timeout
operator|=
name|timeout
expr_stmt|;
name|ctx
operator|->
name|ctx_smfi
operator|=
name|smfi
expr_stmt|;
if|#
directive|if
literal|0
block|if (smfi->xxfi_eoh == NULL) 		if (smfi->xxfi_eom == NULL) 		if (smfi->xxfi_abort == NULL) 		if (smfi->xxfi_close == NULL)
endif|#
directive|endif
comment|/* 0 */
if|if
condition|(
name|smfi
operator|->
name|xxfi_connect
operator|==
name|NULL
condition|)
name|ctx
operator|->
name|ctx_pflags
operator||=
name|SMFIP_NOCONNECT
expr_stmt|;
if|if
condition|(
name|smfi
operator|->
name|xxfi_helo
operator|==
name|NULL
condition|)
name|ctx
operator|->
name|ctx_pflags
operator||=
name|SMFIP_NOHELO
expr_stmt|;
if|if
condition|(
name|smfi
operator|->
name|xxfi_envfrom
operator|==
name|NULL
condition|)
name|ctx
operator|->
name|ctx_pflags
operator||=
name|SMFIP_NOMAIL
expr_stmt|;
if|if
condition|(
name|smfi
operator|->
name|xxfi_envrcpt
operator|==
name|NULL
condition|)
name|ctx
operator|->
name|ctx_pflags
operator||=
name|SMFIP_NORCPT
expr_stmt|;
if|if
condition|(
name|smfi
operator|->
name|xxfi_header
operator|==
name|NULL
condition|)
name|ctx
operator|->
name|ctx_pflags
operator||=
name|SMFIP_NOHDRS
expr_stmt|;
if|if
condition|(
name|smfi
operator|->
name|xxfi_eoh
operator|==
name|NULL
condition|)
name|ctx
operator|->
name|ctx_pflags
operator||=
name|SMFIP_NOEOH
expr_stmt|;
if|if
condition|(
name|smfi
operator|->
name|xxfi_body
operator|==
name|NULL
condition|)
name|ctx
operator|->
name|ctx_pflags
operator||=
name|SMFIP_NOBODY
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|thread_create
argument_list|(
operator|&
name|thread_id
argument_list|,
name|mi_thread_handle_wrapper
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ctx
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|tcnt
operator|++
expr_stmt|;
name|smi_log
argument_list|(
name|SMI_LOG_ERR
argument_list|,
literal|"%s: thread_create() failed: %d, %s"
argument_list|,
name|smfi
operator|->
name|xxfi_name
argument_list|,
name|r
argument_list|,
name|tcnt
operator|>=
name|MAX_FAILS_T
condition|?
literal|"abort"
else|:
literal|"try again"
argument_list|)
expr_stmt|;
name|MI_SLEEP
argument_list|(
name|tcnt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closesocket
argument_list|(
name|connfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcnt
operator|>=
name|MAX_FAILS_T
condition|)
block|{
name|ret
operator|=
name|MI_FAILURE
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
name|tcnt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
name|MI_SUCCESS
condition|)
name|mi_stop_milters
argument_list|(
name|MILTER_ABRT
argument_list|)
expr_stmt|;
else|else
name|mi_closener
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|smutex_destroy
argument_list|(
operator|&
name|L_Mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

