begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.  *	All rights reserved.  * Copyright (c) 1992 Eric P. Allman.  All rights reserved.  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.\n\ 	All rights reserved.\n\      Copyright (c) 1992 Eric P. Allman.  All rights reserved.\n\      Copyright (c) 1992, 1993\n\ 	The Regents of the University of California.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|id
index|[]
init|=
literal|"@(#)$Id: makemap.c,v 8.135.4.13 2000/10/05 23:00:50 gshapiro Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! lint */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|ISC_UNIX
end_ifndef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! ISC_UNIX */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EX_OK
end_ifdef

begin_undef
undef|#
directive|undef
name|EX_OK
end_undef

begin_comment
comment|/* unistd.h may have another use for this */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EX_OK */
end_comment

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<sendmail/sendmail.h>
end_include

begin_include
include|#
directive|include
file|<sendmail/pathnames.h>
end_include

begin_include
include|#
directive|include
file|<libsmdb/smdb.h>
end_include

begin_decl_stmt
name|uid_t
name|RealUid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|gid_t
name|RealGid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|RealUserName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uid_t
name|RunAsUid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uid_t
name|RunAsGid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|RunAsUserName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Verbose
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|DontInitGroups
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uid_t
name|TrustedUid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BITMAP256
name|DontBlameSendmail
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BUFSIZE
value|1024
end_define

begin_if
if|#
directive|if
name|_FFR_DELIM
end_if

begin_define
define|#
directive|define
name|ISSEP
parameter_list|(
name|c
parameter_list|)
value|((sep == '\0'&& isascii(c)&& isspace(c)) || (c) == sep)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* _FFR_DELIM */
end_comment

begin_define
define|#
directive|define
name|ISSEP
parameter_list|(
name|c
parameter_list|)
value|(isascii(c)&& isspace(c))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_DELIM */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|progname
parameter_list|)
name|char
modifier|*
name|progname
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [-C cffile] [-N] [-c cachesize] [-d] [-e] [-f] [-l] [-o] [-r] [-s] %s[-u] [-v] type mapname\n"
argument_list|,
name|progname
argument_list|,
if|#
directive|if
name|_FFR_DELIM
literal|"[-t  delimiter] "
else|#
directive|else
comment|/* _FFR_DELIM */
literal|""
endif|#
directive|endif
comment|/* _FFR_DELIM */
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|progname
decl_stmt|;
name|char
modifier|*
name|cfile
decl_stmt|;
name|bool
name|inclnull
init|=
name|FALSE
decl_stmt|;
name|bool
name|notrunc
init|=
name|FALSE
decl_stmt|;
name|bool
name|allowreplace
init|=
name|FALSE
decl_stmt|;
name|bool
name|allowempty
init|=
name|FALSE
decl_stmt|;
name|bool
name|verbose
init|=
name|FALSE
decl_stmt|;
name|bool
name|foldcase
init|=
name|TRUE
decl_stmt|;
name|bool
name|unmake
init|=
name|FALSE
decl_stmt|;
if|#
directive|if
name|_FFR_DELIM
name|char
name|sep
init|=
literal|'\0'
decl_stmt|;
endif|#
directive|endif
comment|/* _FFR_DELIM */
name|int
name|exitstat
decl_stmt|;
name|int
name|opt
decl_stmt|;
name|char
modifier|*
name|typename
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|mapname
init|=
name|NULL
decl_stmt|;
name|int
name|lineno
decl_stmt|;
name|int
name|st
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|smode
decl_stmt|;
name|int
name|putflags
init|=
literal|0
decl_stmt|;
name|long
name|sff
init|=
name|SFF_ROOTOK
operator||
name|SFF_REGONLY
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|SMDB_DATABASE
modifier|*
name|database
decl_stmt|;
name|SMDB_CURSOR
modifier|*
name|cursor
decl_stmt|;
name|SMDB_DBENT
name|db_key
decl_stmt|,
name|db_val
decl_stmt|;
name|SMDB_DBPARAMS
name|params
decl_stmt|;
name|SMDB_USER_INFO
name|user_info
decl_stmt|;
name|char
name|ibuf
index|[
name|BUFSIZE
index|]
decl_stmt|;
if|#
directive|if
name|HASFCHOWN
name|FILE
modifier|*
name|cfp
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* HASFCHOWN */
specifier|static
name|char
name|rnamebuf
index|[
name|MAXNAME
index|]
decl_stmt|;
comment|/* holds RealUserName */
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
name|memset
argument_list|(
operator|&
name|params
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|params
argument_list|)
expr_stmt|;
name|params
operator|.
name|smdbp_cache_size
operator|=
literal|1024
operator|*
literal|1024
expr_stmt|;
name|progname
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|progname
operator|!=
name|NULL
condition|)
name|progname
operator|++
expr_stmt|;
else|else
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|cfile
operator|=
name|_PATH_SENDMAILCF
expr_stmt|;
name|clrbitmap
argument_list|(
name|DontBlameSendmail
argument_list|)
expr_stmt|;
name|RunAsUid
operator|=
name|RealUid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|RunAsGid
operator|=
name|RealGid
operator|=
name|getgid
argument_list|()
expr_stmt|;
name|pw
operator|=
name|getpwuid
argument_list|(
name|RealUid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|rnamebuf
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
sizeof|sizeof
name|rnamebuf
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|rnamebuf
argument_list|,
sizeof|sizeof
name|rnamebuf
argument_list|,
literal|"Unknown UID %d"
argument_list|,
operator|(
name|int
operator|)
name|RealUid
argument_list|)
expr_stmt|;
name|RunAsUserName
operator|=
name|RealUserName
operator|=
name|rnamebuf
expr_stmt|;
name|user_info
operator|.
name|smdbu_id
operator|=
name|RunAsUid
expr_stmt|;
name|user_info
operator|.
name|smdbu_group_id
operator|=
name|RunAsGid
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|user_info
operator|.
name|smdbu_name
argument_list|,
name|RunAsUserName
argument_list|,
name|SMDB_MAX_USER_NAME_LEN
argument_list|)
expr_stmt|;
define|#
directive|define
name|OPTIONS
value|"C:Nc:t:deflorsuv"
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|OPTIONS
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'C'
case|:
name|cfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|inclnull
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|params
operator|.
name|smdbp_cache_size
operator|=
name|atol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|params
operator|.
name|smdbp_allow_dup
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|allowempty
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|foldcase
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|smdb_print_available_types
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|notrunc
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|allowreplace
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|setbitn
argument_list|(
name|DBS_MAPINUNSAFEDIRPATH
argument_list|,
name|DontBlameSendmail
argument_list|)
expr_stmt|;
name|setbitn
argument_list|(
name|DBS_WRITEMAPTOHARDLINK
argument_list|,
name|DontBlameSendmail
argument_list|)
expr_stmt|;
name|setbitn
argument_list|(
name|DBS_WRITEMAPTOSYMLINK
argument_list|,
name|DontBlameSendmail
argument_list|)
expr_stmt|;
name|setbitn
argument_list|(
name|DBS_LINKEDMAPINWRITABLEDIR
argument_list|,
name|DontBlameSendmail
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|_FFR_DELIM
case|case
literal|'t'
case|:
if|if
condition|(
name|optarg
operator|==
name|NULL
operator|||
operator|*
name|optarg
operator|==
literal|'\0'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid separator\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|sep
operator|=
operator|*
name|optarg
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* _FFR_DELIM */
case|case
literal|'u'
case|:
name|unmake
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
name|progname
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|DBS_WRITEMAPTOSYMLINK
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
name|sff
operator||=
name|SFF_NOSLINK
expr_stmt|;
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|DBS_WRITEMAPTOHARDLINK
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
name|sff
operator||=
name|SFF_NOHLINK
expr_stmt|;
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|DBS_LINKEDMAPINWRITABLEDIR
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
name|sff
operator||=
name|SFF_NOWLINK
expr_stmt|;
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|usage
argument_list|(
name|progname
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
else|else
block|{
name|typename
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|mapname
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
block|}
if|#
directive|if
name|HASFCHOWN
comment|/* Find TrustedUser value in sendmail.cf */
if|if
condition|(
operator|(
name|cfp
operator|=
name|fopen
argument_list|(
name|cfile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"makemap: %s: %s"
argument_list|,
name|cfile
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_NOINPUT
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|cfp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|char
modifier|*
name|b
decl_stmt|;
if|if
condition|(
operator|(
name|b
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|b
operator|=
literal|'\0'
expr_stmt|;
name|b
operator|=
name|buf
expr_stmt|;
switch|switch
condition|(
operator|*
name|b
operator|++
condition|)
block|{
case|case
literal|'O'
case|:
comment|/* option */
if|if
condition|(
name|strncasecmp
argument_list|(
name|b
argument_list|,
literal|" TrustedUser"
argument_list|,
literal|12
argument_list|)
operator|==
literal|0
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
name|b
index|[
literal|12
index|]
argument_list|)
operator|&&
name|isalnum
argument_list|(
name|b
index|[
literal|12
index|]
argument_list|)
operator|)
condition|)
block|{
name|b
operator|=
name|strchr
argument_list|(
name|b
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
continue|continue;
while|while
condition|(
name|isascii
argument_list|(
operator|*
operator|++
name|b
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|b
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|isascii
argument_list|(
operator|*
name|b
argument_list|)
operator|&&
name|isdigit
argument_list|(
operator|*
name|b
argument_list|)
condition|)
name|TrustedUid
operator|=
name|atoi
argument_list|(
name|b
argument_list|)
expr_stmt|;
else|else
block|{
name|TrustedUid
operator|=
literal|0
expr_stmt|;
name|pw
operator|=
name|getpwnam
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"TrustedUser: unknown user %s\n"
argument_list|,
name|b
argument_list|)
expr_stmt|;
else|else
name|TrustedUid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|UID_MAX
if|if
condition|(
name|TrustedUid
operator|>
name|UID_MAX
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"TrustedUser: uid value (%ld)> UID_MAX (%ld)"
argument_list|,
operator|(
name|long
operator|)
name|TrustedUid
argument_list|,
operator|(
name|long
operator|)
name|UID_MAX
argument_list|)
expr_stmt|;
name|TrustedUid
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* UID_MAX */
break|break;
block|}
default|default:
continue|continue;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|cfp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HASFCHOWN */
if|if
condition|(
operator|!
name|params
operator|.
name|smdbp_allow_dup
operator|&&
operator|!
name|allowreplace
condition|)
name|putflags
operator|=
name|SMDBF_NO_OVERWRITE
expr_stmt|;
if|if
condition|(
name|unmake
condition|)
block|{
name|mode
operator|=
name|O_RDONLY
expr_stmt|;
name|smode
operator|=
name|S_IRUSR
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
name|O_RDWR
expr_stmt|;
if|if
condition|(
operator|!
name|notrunc
condition|)
block|{
name|mode
operator||=
name|O_CREAT
operator||
name|O_TRUNC
expr_stmt|;
name|sff
operator||=
name|SFF_CREAT
expr_stmt|;
block|}
name|smode
operator|=
name|S_IWUSR
expr_stmt|;
block|}
name|params
operator|.
name|smdbp_num_elements
operator|=
literal|4096
expr_stmt|;
name|errno
operator|=
name|smdb_open_database
argument_list|(
operator|&
name|database
argument_list|,
name|mapname
argument_list|,
name|mode
argument_list|,
name|smode
argument_list|,
name|sff
argument_list|,
name|typename
argument_list|,
operator|&
name|user_info
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|SMDBE_OK
condition|)
block|{
name|char
modifier|*
name|hint
decl_stmt|;
if|if
condition|(
name|errno
operator|==
name|SMDBE_UNSUPPORTED_DB_TYPE
operator|&&
operator|(
name|hint
operator|=
name|smdb_db_definition
argument_list|(
name|typename
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Need to recompile with -D%s for %s support\n"
argument_list|,
name|progname
argument_list|,
name|hint
argument_list|,
name|typename
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: error opening type %s map %s: %s\n"
argument_list|,
name|progname
argument_list|,
name|typename
argument_list|,
name|mapname
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_CANTCREAT
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|database
operator|->
name|smdb_sync
argument_list|(
name|database
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unmake
operator|&&
name|geteuid
argument_list|()
operator|==
literal|0
operator|&&
name|TrustedUid
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|database
operator|->
name|smdb_set_owner
argument_list|(
name|database
argument_list|,
name|TrustedUid
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|SMDBE_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"WARNING: ownership change on %s failed %s"
argument_list|,
name|mapname
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	**  Copy the data 	*/
name|exitstat
operator|=
name|EX_OK
expr_stmt|;
if|if
condition|(
name|unmake
condition|)
block|{
name|errno
operator|=
name|database
operator|->
name|smdb_cursor
argument_list|(
name|database
argument_list|,
operator|&
name|cursor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|SMDBE_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: cannot make cursor for type %s map %s\n"
argument_list|,
name|progname
argument_list|,
name|typename
argument_list|,
name|mapname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|db_key
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|db_key
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|db_val
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|db_val
argument_list|)
expr_stmt|;
for|for
control|(
name|lineno
operator|=
literal|0
init|;
condition|;
name|lineno
operator|++
control|)
block|{
name|errno
operator|=
name|cursor
operator|->
name|smdbc_get
argument_list|(
name|cursor
argument_list|,
operator|&
name|db_key
argument_list|,
operator|&
name|db_val
argument_list|,
name|SMDB_CURSOR_GET_NEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|SMDBE_OK
condition|)
break|break;
name|printf
argument_list|(
literal|"%.*s\t%.*s\n"
argument_list|,
operator|(
name|int
operator|)
name|db_key
operator|.
name|size
argument_list|,
operator|(
name|char
operator|*
operator|)
name|db_key
operator|.
name|data
argument_list|,
operator|(
name|int
operator|)
name|db_val
operator|.
name|size
argument_list|,
operator|(
name|char
operator|*
operator|)
name|db_val
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|cursor
operator|->
name|smdbc_close
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lineno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|ibuf
argument_list|,
sizeof|sizeof
name|ibuf
argument_list|,
name|stdin
argument_list|)
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|lineno
operator|++
expr_stmt|;
comment|/* 			**  Parse the line. 			*/
name|p
operator|=
name|strchr
argument_list|(
name|ibuf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: line %d: line too long (%ld bytes max)\n"
argument_list|,
name|progname
argument_list|,
name|mapname
argument_list|,
name|lineno
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
name|ibuf
argument_list|)
expr_stmt|;
name|exitstat
operator|=
name|EX_DATAERR
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ibuf
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|ibuf
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
if|if
condition|(
if|#
directive|if
name|_FFR_DELIM
name|sep
operator|==
literal|'\0'
operator|&&
endif|#
directive|endif
comment|/* _FFR_DELIM */
name|isascii
argument_list|(
name|ibuf
index|[
literal|0
index|]
argument_list|)
operator|&&
name|isspace
argument_list|(
name|ibuf
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: line %d: syntax error (leading space)\n"
argument_list|,
name|progname
argument_list|,
name|mapname
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|exitstat
operator|=
name|EX_DATAERR
expr_stmt|;
continue|continue;
block|}
name|memset
argument_list|(
operator|&
name|db_key
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|db_key
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|db_val
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|db_val
argument_list|)
expr_stmt|;
name|db_key
operator|.
name|data
operator|=
name|ibuf
expr_stmt|;
for|for
control|(
name|p
operator|=
name|ibuf
init|;
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|!
operator|(
name|ISSEP
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|foldcase
operator|&&
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isupper
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
name|db_key
operator|.
name|size
operator|=
name|p
operator|-
name|ibuf
expr_stmt|;
if|if
condition|(
name|inclnull
condition|)
name|db_key
operator|.
name|size
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|ISSEP
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|allowempty
operator|&&
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: line %d: no RHS for LHS %s\n"
argument_list|,
name|progname
argument_list|,
name|mapname
argument_list|,
name|lineno
argument_list|,
operator|(
name|char
operator|*
operator|)
name|db_key
operator|.
name|data
argument_list|)
expr_stmt|;
name|exitstat
operator|=
name|EX_DATAERR
expr_stmt|;
continue|continue;
block|}
name|db_val
operator|.
name|data
operator|=
name|p
expr_stmt|;
name|db_val
operator|.
name|size
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|inclnull
condition|)
name|db_val
operator|.
name|size
operator|++
expr_stmt|;
comment|/* 			**  Do the database insert. 			*/
if|if
condition|(
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|"key=`%s', val=`%s'\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|db_key
operator|.
name|data
argument_list|,
operator|(
name|char
operator|*
operator|)
name|db_val
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
name|database
operator|->
name|smdb_put
argument_list|(
name|database
argument_list|,
operator|&
name|db_key
argument_list|,
operator|&
name|db_val
argument_list|,
name|putflags
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|SMDBE_KEY_EXIST
case|:
name|st
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|st
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|st
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|st
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: line %d: key %s: put error: %s\n"
argument_list|,
name|progname
argument_list|,
name|mapname
argument_list|,
name|lineno
argument_list|,
operator|(
name|char
operator|*
operator|)
name|db_key
operator|.
name|data
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exitstat
operator|=
name|EX_IOERR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|st
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: line %d: key %s: duplicate key\n"
argument_list|,
name|progname
argument_list|,
name|mapname
argument_list|,
name|lineno
argument_list|,
operator|(
name|char
operator|*
operator|)
name|db_key
operator|.
name|data
argument_list|)
expr_stmt|;
name|exitstat
operator|=
name|EX_DATAERR
expr_stmt|;
block|}
block|}
block|}
comment|/* 	**  Now close the database. 	*/
name|errno
operator|=
name|database
operator|->
name|smdb_close
argument_list|(
name|database
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|SMDBE_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: close(%s): %s\n"
argument_list|,
name|progname
argument_list|,
name|mapname
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exitstat
operator|=
name|EX_IOERR
expr_stmt|;
block|}
name|smdb_free_database
argument_list|(
name|database
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exitstat
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|exitstat
return|;
block|}
end_function

begin_comment
comment|/*VARARGS1*/
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|message
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
comment|/* __STDC__ */
function|message
parameter_list|(
name|msg
parameter_list|,
name|va_alist
parameter_list|)
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
function|va_dcl
endif|#
directive|endif
comment|/* __STDC__ */
block|{
specifier|const
name|char
modifier|*
name|m
decl_stmt|;
name|VA_LOCAL_DECL
name|m
init|=
name|msg
decl_stmt|;
if|if
condition|(
name|isascii
argument_list|(
name|m
index|[
literal|0
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|m
index|[
literal|0
index|]
argument_list|)
operator|&&
name|isascii
argument_list|(
name|m
index|[
literal|1
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|m
index|[
literal|1
index|]
argument_list|)
operator|&&
name|isascii
argument_list|(
name|m
index|[
literal|2
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|m
index|[
literal|2
index|]
argument_list|)
operator|&&
name|m
index|[
literal|3
index|]
operator|==
literal|' '
condition|)
name|m
operator|+=
literal|4
expr_stmt|;
name|VA_START
argument_list|(
name|msg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|m
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_END
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*VARARGS1*/
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|syserr
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
comment|/* __STDC__ */
function|syserr
parameter_list|(
name|msg
parameter_list|,
name|va_alist
parameter_list|)
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
function|va_dcl
endif|#
directive|endif
comment|/* __STDC__ */
block|{
specifier|const
name|char
modifier|*
name|m
decl_stmt|;
name|VA_LOCAL_DECL
name|m
init|=
name|msg
decl_stmt|;
if|if
condition|(
name|isascii
argument_list|(
name|m
index|[
literal|0
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|m
index|[
literal|0
index|]
argument_list|)
operator|&&
name|isascii
argument_list|(
name|m
index|[
literal|1
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|m
index|[
literal|1
index|]
argument_list|)
operator|&&
name|isascii
argument_list|(
name|m
index|[
literal|2
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|m
index|[
literal|2
index|]
argument_list|)
operator|&&
name|m
index|[
literal|3
index|]
operator|==
literal|' '
condition|)
name|m
operator|+=
literal|4
expr_stmt|;
name|VA_START
argument_list|(
name|msg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|m
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_END
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

