begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998-2003, 2006 Sendmail, Inc. and its suppliers.  *	All rights reserved.  * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_include
include|#
directive|include
file|<sendmail.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: envelope.c,v 8.302 2006/11/10 23:12:52 ca Exp $"
argument_list|)
end_macro

begin_comment
comment|/* **  CLRSESSENVELOPE -- clear session oriented data in an envelope ** **	Parameters: **		e -- the envelope to clear. ** **	Returns: **		none. */
end_comment

begin_function
name|void
name|clrsessenvelope
parameter_list|(
name|e
parameter_list|)
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
if|#
directive|if
name|SASL
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{auth_type}"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{auth_authen}"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{auth_author}"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{auth_ssf}"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SASL */
if|#
directive|if
name|STARTTLS
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{cert_issuer}"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{cert_subject}"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{cipher_bits}"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{cipher}"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{tls_version}"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{verify}"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|#
directive|if
name|_FFR_TLS_1
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{alg_bits}"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{cn_issuer}"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{cn_subject}"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_TLS_1 */
endif|#
directive|endif
comment|/* STARTTLS */
block|}
end_function

begin_comment
comment|/* **  NEWENVELOPE -- fill in a new envelope ** **	Supports inheritance. ** **	Parameters: **		e -- the new envelope to fill in. **		parent -- the envelope to be the parent of e. **		rpool -- either NULL, or a pointer to a resource pool **			from which envelope memory is allocated, and **			to which envelope resources are attached. ** **	Returns: **		e. ** **	Side Effects: **		none. */
end_comment

begin_function
name|ENVELOPE
modifier|*
name|newenvelope
parameter_list|(
name|e
parameter_list|,
name|parent
parameter_list|,
name|rpool
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|parent
decl_stmt|;
name|SM_RPOOL_T
modifier|*
name|rpool
decl_stmt|;
block|{
name|int
name|sendmode
decl_stmt|;
comment|/* 	**  This code used to read: 	**	if (e == parent&& e->e_parent != NULL) 	**		parent = e->e_parent; 	**  So if e == parent&& e->e_parent == NULL then we would 	**  set e->e_parent = e, which creates a loop in the e_parent chain. 	**  This meant macvalue() could go into an infinite loop. 	*/
if|if
condition|(
name|parent
operator|!=
name|NULL
condition|)
name|sendmode
operator|=
name|parent
operator|->
name|e_sendmode
expr_stmt|;
else|else
name|sendmode
operator|=
name|DM_NOTSET
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|parent
condition|)
name|parent
operator|=
name|e
operator|->
name|e_parent
expr_stmt|;
name|clearenvelope
argument_list|(
name|e
argument_list|,
name|true
argument_list|,
name|rpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|CurEnv
condition|)
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|e
operator|->
name|e_from
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|NullAddress
argument_list|,
sizeof|sizeof
argument_list|(
name|e
operator|->
name|e_from
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|e
operator|->
name|e_from
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|CurEnv
operator|->
name|e_from
argument_list|,
sizeof|sizeof
argument_list|(
name|e
operator|->
name|e_from
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_parent
operator|=
name|parent
expr_stmt|;
name|assign_queueid
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_ctime
operator|=
name|curtime
argument_list|()
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
name|NULL
condition|)
block|{
name|e
operator|->
name|e_msgpriority
operator|=
name|parent
operator|->
name|e_msgsize
expr_stmt|;
if|if
condition|(
name|parent
operator|->
name|e_quarmsg
operator|==
name|NULL
condition|)
block|{
name|e
operator|->
name|e_quarmsg
operator|=
name|NULL
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{quarantine}"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e
operator|->
name|e_quarmsg
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|rpool
argument_list|,
name|parent
operator|->
name|e_quarmsg
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{quarantine}"
argument_list|)
argument_list|,
name|e
operator|->
name|e_quarmsg
argument_list|)
expr_stmt|;
block|}
block|}
name|e
operator|->
name|e_puthdr
operator|=
name|putheader
expr_stmt|;
name|e
operator|->
name|e_putbody
operator|=
name|putbody
expr_stmt|;
if|if
condition|(
name|CurEnv
operator|->
name|e_xfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_flush
argument_list|(
name|CurEnv
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendmode
operator|!=
name|DM_NOTSET
condition|)
name|e
operator|->
name|e_sendmode
operator|=
name|sendmode
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* values for msg_timeout, see also IS_* below for usage (bit layout) */
end_comment

begin_define
define|#
directive|define
name|MSG_T_O
value|0x01
end_define

begin_comment
comment|/* normal timeout */
end_comment

begin_define
define|#
directive|define
name|MSG_T_O_NOW
value|0x02
end_define

begin_comment
comment|/* NOW timeout */
end_comment

begin_define
define|#
directive|define
name|MSG_NOT_BY
value|0x04
end_define

begin_comment
comment|/* Deliver-By time exceeded, mode R */
end_comment

begin_define
define|#
directive|define
name|MSG_WARN
value|0x10
end_define

begin_comment
comment|/* normal queue warning */
end_comment

begin_define
define|#
directive|define
name|MSG_WARN_BY
value|0x20
end_define

begin_comment
comment|/* Deliver-By time exceeded, mode N */
end_comment

begin_define
define|#
directive|define
name|IS_MSG_ERR
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x0f) != 0)
end_define

begin_comment
comment|/* return an error */
end_comment

begin_comment
comment|/* immediate return */
end_comment

begin_define
define|#
directive|define
name|IS_IMM_RET
parameter_list|(
name|x
parameter_list|)
value|(((x)& (MSG_T_O_NOW|MSG_NOT_BY)) != 0)
end_define

begin_define
define|#
directive|define
name|IS_MSG_WARN
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0xf0) != 0)
end_define

begin_comment
comment|/* return a warning */
end_comment

begin_comment
comment|/* **  DROPENVELOPE -- deallocate an envelope. ** **	Parameters: **		e -- the envelope to deallocate. **		fulldrop -- if set, do return receipts. **		split -- if true, split by recipient if message is queued up ** **	Returns: **		none. ** **	Side Effects: **		housekeeping necessary to dispose of an envelope. **		Unlocks this queue file. */
end_comment

begin_function
name|void
name|dropenvelope
parameter_list|(
name|e
parameter_list|,
name|fulldrop
parameter_list|,
name|split
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|bool
name|fulldrop
decl_stmt|;
name|bool
name|split
decl_stmt|;
block|{
name|bool
name|panic
init|=
name|false
decl_stmt|;
name|bool
name|queueit
init|=
name|false
decl_stmt|;
name|int
name|msg_timeout
init|=
literal|0
decl_stmt|;
name|bool
name|failure_return
init|=
name|false
decl_stmt|;
name|bool
name|delay_return
init|=
name|false
decl_stmt|;
name|bool
name|success_return
init|=
name|false
decl_stmt|;
name|bool
name|pmnotify
init|=
name|bitset
argument_list|(
name|EF_PM_NOTIFY
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
decl_stmt|;
name|bool
name|done
init|=
name|false
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|id
init|=
name|e
operator|->
name|e_id
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|50
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"dropenvelope %p: id="
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|", flags="
argument_list|)
expr_stmt|;
name|printenvflags
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|50
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"sendq="
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|e
operator|->
name|e_sendqueue
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LogLevel
operator|>
literal|84
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|id
argument_list|,
literal|"dropenvelope, e_flags=0x%lx, OpMode=%c, pid=%d"
argument_list|,
name|e
operator|->
name|e_flags
argument_list|,
name|OpMode
argument_list|,
operator|(
name|int
operator|)
name|CurrentPid
argument_list|)
expr_stmt|;
comment|/* we must have an id to remove disk files */
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
return|return;
comment|/* if verify-only mode, we can skip most of this */
if|if
condition|(
name|OpMode
operator|==
name|MD_VERIFY
condition|)
goto|goto
name|simpledrop
goto|;
if|if
condition|(
name|LogLevel
operator|>
literal|4
operator|&&
name|bitset
argument_list|(
name|EF_LOGSENDER
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|logsender
argument_list|(
name|e
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_LOGSENDER
expr_stmt|;
comment|/* post statistics */
name|poststats
argument_list|(
name|StatFile
argument_list|)
expr_stmt|;
comment|/* 	**  Extract state information from dregs of send list. 	*/
name|now
operator|=
name|curtime
argument_list|()
expr_stmt|;
if|if
condition|(
name|now
operator|>=
name|e
operator|->
name|e_ctime
operator|+
name|TimeOuts
operator|.
name|to_q_return
index|[
name|e
operator|->
name|e_timeoutclass
index|]
condition|)
name|msg_timeout
operator|=
name|MSG_T_O
expr_stmt|;
if|if
condition|(
name|IS_DLVR_RETURN
argument_list|(
name|e
argument_list|)
operator|&&
name|e
operator|->
name|e_deliver_by
operator|>
literal|0
operator|&&
name|now
operator|>=
name|e
operator|->
name|e_ctime
operator|+
name|e
operator|->
name|e_deliver_by
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_RESPONSE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|msg_timeout
operator|=
name|MSG_NOT_BY
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_FATALERRS
operator||
name|EF_CLRQUEUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TimeOuts
operator|.
name|to_q_return
index|[
name|e
operator|->
name|e_timeoutclass
index|]
operator|==
name|NOW
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_RESPONSE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|msg_timeout
operator|=
name|MSG_T_O_NOW
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_FATALERRS
operator||
name|EF_CLRQUEUE
expr_stmt|;
block|}
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_QUEUERUN
expr_stmt|;
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|QS_IS_UNDELIVERED
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
condition|)
name|queueit
operator|=
name|true
expr_stmt|;
comment|/* see if a notification is needed */
if|if
condition|(
name|bitset
argument_list|(
name|QPINGONFAILURE
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
operator|&&
operator|(
operator|(
name|IS_MSG_ERR
argument_list|(
name|msg_timeout
argument_list|)
operator|&&
name|QS_IS_UNDELIVERED
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
operator|)
operator|||
name|QS_IS_BADADDR
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
operator|||
name|IS_IMM_RET
argument_list|(
name|msg_timeout
argument_list|)
operator|)
condition|)
block|{
name|failure_return
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|done
operator|&&
name|q
operator|->
name|q_owner
operator|==
name|NULL
operator|&&
operator|!
name|emptyaddr
argument_list|(
operator|&
name|e
operator|->
name|e_from
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sendtolist
argument_list|(
name|e
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|,
name|NULLADDR
argument_list|,
operator|&
name|e
operator|->
name|e_errorqueue
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|done
operator|=
name|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|bitset
argument_list|(
name|QPINGONSUCCESS
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
operator|&&
operator|(
operator|(
name|QS_IS_SENT
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
operator|&&
name|bitnset
argument_list|(
name|M_LOCALMAILER
argument_list|,
name|q
operator|->
name|q_mailer
operator|->
name|m_flags
argument_list|)
operator|)
operator|||
name|bitset
argument_list|(
name|QRELAYED
operator||
name|QEXPANDED
operator||
name|QDELIVERED
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
operator|)
operator|)
operator|||
name|bitset
argument_list|(
name|QBYTRACE
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
operator|||
name|bitset
argument_list|(
name|QBYNRELAY
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
block|{
name|success_return
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|->
name|e_class
operator|<
literal|0
condition|)
name|e
operator|->
name|e_flags
operator||=
name|EF_NO_BODY_RETN
expr_stmt|;
comment|/* 	**  See if the message timed out. 	*/
if|if
condition|(
operator|!
name|queueit
condition|)
comment|/* EMPTY */
comment|/* nothing to do */
empty_stmt|;
elseif|else
if|if
condition|(
name|IS_MSG_ERR
argument_list|(
name|msg_timeout
argument_list|)
condition|)
block|{
if|if
condition|(
name|failure_return
condition|)
block|{
if|if
condition|(
name|msg_timeout
operator|==
name|MSG_NOT_BY
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"delivery time expired %lds"
argument_list|,
name|e
operator|->
name|e_deliver_by
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Cannot send message for %s"
argument_list|,
name|pintvl
argument_list|(
name|TimeOuts
operator|.
name|to_q_return
index|[
name|e
operator|->
name|e_timeoutclass
index|]
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* don't free, allocated from e_rpool */
name|e
operator|->
name|e_message
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_CLRQUEUE
expr_stmt|;
block|}
if|if
condition|(
name|msg_timeout
operator|==
name|MSG_NOT_BY
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Delivery time (%lds) expired\n"
argument_list|,
name|e
operator|->
name|e_deliver_by
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Message could not be delivered for %s\n"
argument_list|,
name|pintvl
argument_list|(
name|TimeOuts
operator|.
name|to_q_return
index|[
name|e
operator|->
name|e_timeoutclass
index|]
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Message will be deleted from queue\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|QS_IS_UNDELIVERED
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
condition|)
block|{
name|q
operator|->
name|q_state
operator|=
name|QS_BADADDR
expr_stmt|;
if|if
condition|(
name|msg_timeout
operator|==
name|MSG_NOT_BY
condition|)
name|q
operator|->
name|q_status
operator|=
literal|"5.4.7"
expr_stmt|;
else|else
name|q
operator|->
name|q_status
operator|=
literal|"4.4.7"
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|TimeOuts
operator|.
name|to_q_warning
index|[
name|e
operator|->
name|e_timeoutclass
index|]
operator|>
literal|0
operator|&&
name|now
operator|>=
name|e
operator|->
name|e_ctime
operator|+
name|TimeOuts
operator|.
name|to_q_warning
index|[
name|e
operator|->
name|e_timeoutclass
index|]
condition|)
name|msg_timeout
operator|=
name|MSG_WARN
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_DLVR_NOTIFY
argument_list|(
name|e
argument_list|)
operator|&&
name|e
operator|->
name|e_deliver_by
operator|>
literal|0
operator|&&
name|now
operator|>=
name|e
operator|->
name|e_ctime
operator|+
name|e
operator|->
name|e_deliver_by
condition|)
name|msg_timeout
operator|=
name|MSG_WARN_BY
expr_stmt|;
if|if
condition|(
name|IS_MSG_WARN
argument_list|(
name|msg_timeout
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|EF_WARNING
operator||
name|EF_RESPONSE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
name|e
operator|->
name|e_class
operator|>=
literal|0
operator|&&
name|e
operator|->
name|e_from
operator|.
name|q_paddr
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|e
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|,
literal|"<>"
argument_list|)
operator|!=
literal|0
operator|&&
name|sm_strncasecmp
argument_list|(
name|e
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|,
literal|"owner-"
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|strlen
argument_list|(
name|e
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|)
operator|<=
literal|8
operator|||
name|sm_strcasecmp
argument_list|(
operator|&
name|e
operator|->
name|e_from
operator|.
name|q_paddr
index|[
name|strlen
argument_list|(
name|e
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|)
operator|-
literal|8
index|]
argument_list|,
literal|"-request"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|QS_IS_UNDELIVERED
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
if|#
directive|if
name|_FFR_NODELAYDSN_ON_HOLD
operator|&&
operator|!
name|bitnset
argument_list|(
name|M_HOLD
argument_list|,
name|q
operator|->
name|q_mailer
operator|->
name|m_flags
argument_list|)
endif|#
directive|endif
comment|/* _FFR_NODELAYDSN_ON_HOLD */
condition|)
block|{
if|if
condition|(
name|msg_timeout
operator|==
name|MSG_WARN_BY
operator|&&
operator|(
name|bitset
argument_list|(
name|QPINGONDELAY
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
operator|||
operator|!
name|bitset
argument_list|(
name|QHASNOTIFY
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
operator|)
condition|)
block|{
name|q
operator|->
name|q_flags
operator||=
name|QBYNDELAY
expr_stmt|;
name|delay_return
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|QPINGONDELAY
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
block|{
name|q
operator|->
name|q_flags
operator||=
name|QDELAYED
expr_stmt|;
name|delay_return
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|delay_return
condition|)
block|{
if|if
condition|(
name|msg_timeout
operator|==
name|MSG_WARN_BY
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Warning: Delivery time (%lds) exceeded"
argument_list|,
name|e
operator|->
name|e_deliver_by
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Warning: could not send message for past %s"
argument_list|,
name|pintvl
argument_list|(
name|TimeOuts
operator|.
name|to_q_warning
index|[
name|e
operator|->
name|e_timeoutclass
index|]
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
comment|/* don't free, allocated from e_rpool */
name|e
operator|->
name|e_message
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_WARNING
expr_stmt|;
block|}
if|if
condition|(
name|msg_timeout
operator|==
name|MSG_WARN_BY
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Warning: Delivery time (%lds) exceeded\n"
argument_list|,
name|e
operator|->
name|e_deliver_by
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Warning: message still undelivered after %s\n"
argument_list|,
name|pintvl
argument_list|(
name|TimeOuts
operator|.
name|to_q_warning
index|[
name|e
operator|->
name|e_timeoutclass
index|]
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Will keep trying until message is %s old\n"
argument_list|,
name|pintvl
argument_list|(
name|TimeOuts
operator|.
name|to_q_return
index|[
name|e
operator|->
name|e_timeoutclass
index|]
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|50
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"failure_return=%d delay_return=%d success_return=%d queueit=%d\n"
argument_list|,
name|failure_return
argument_list|,
name|delay_return
argument_list|,
name|success_return
argument_list|,
name|queueit
argument_list|)
expr_stmt|;
comment|/* 	**  If we had some fatal error, but no addresses are marked as 	**  bad, mark them _all_ as bad. 	*/
if|if
condition|(
name|bitset
argument_list|(
name|EF_FATALERRS
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
operator|!
name|failure_return
condition|)
block|{
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
operator|(
name|QS_IS_OK
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
operator|||
name|QS_IS_VERIFIED
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
operator|)
operator|&&
name|bitset
argument_list|(
name|QPINGONFAILURE
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
block|{
name|failure_return
operator|=
name|true
expr_stmt|;
name|q
operator|->
name|q_state
operator|=
name|QS_BADADDR
expr_stmt|;
block|}
block|}
block|}
comment|/* 	**  Send back return receipts as requested. 	*/
if|if
condition|(
name|success_return
operator|&&
operator|!
name|failure_return
operator|&&
operator|!
name|delay_return
operator|&&
name|fulldrop
operator|&&
operator|!
name|bitset
argument_list|(
name|PRIV_NORECEIPTS
argument_list|,
name|PrivacyFlags
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|e
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|,
literal|"<>"
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|auto
name|ADDRESS
modifier|*
name|rlist
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|50
argument_list|,
literal|8
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"dropenvelope(%s): sending return receipt\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_SENDRECEIPT
expr_stmt|;
operator|(
name|void
operator|)
name|sendtolist
argument_list|(
name|e
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|,
name|NULLADDR
argument_list|,
operator|&
name|rlist
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|returntosender
argument_list|(
literal|"Return receipt"
argument_list|,
name|rlist
argument_list|,
name|RTSF_NO_BODY
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_SENDRECEIPT
expr_stmt|;
comment|/* 	**  Arrange to send error messages if there are fatal errors. 	*/
if|if
condition|(
operator|(
name|failure_return
operator|||
name|delay_return
operator|)
operator|&&
name|e
operator|->
name|e_errormode
operator|!=
name|EM_QUIET
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|50
argument_list|,
literal|8
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"dropenvelope(%s): saving mail\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|panic
operator|=
name|savemail
argument_list|(
name|e
argument_list|,
operator|!
name|bitset
argument_list|(
name|EF_NO_BODY_RETN
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Arrange to send warning messages to postmaster as requested. 	*/
if|if
condition|(
operator|(
name|failure_return
operator|||
name|pmnotify
operator|)
operator|&&
name|PostMasterCopy
operator|!=
name|NULL
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_RESPONSE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
name|e
operator|->
name|e_class
operator|>=
literal|0
condition|)
block|{
specifier|auto
name|ADDRESS
modifier|*
name|rlist
init|=
name|NULL
decl_stmt|;
name|char
name|pcopy
index|[
name|MAXNAME
index|]
decl_stmt|;
if|if
condition|(
name|failure_return
condition|)
block|{
name|expand
argument_list|(
name|PostMasterCopy
argument_list|,
name|pcopy
argument_list|,
sizeof|sizeof
argument_list|(
name|pcopy
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|50
argument_list|,
literal|8
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"dropenvelope(%s): sending postmaster copy to %s\n"
argument_list|,
name|id
argument_list|,
name|pcopy
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sendtolist
argument_list|(
name|pcopy
argument_list|,
name|NULLADDR
argument_list|,
operator|&
name|rlist
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pmnotify
condition|)
operator|(
name|void
operator|)
name|sendtolist
argument_list|(
literal|"postmaster"
argument_list|,
name|NULLADDR
argument_list|,
operator|&
name|rlist
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|returntosender
argument_list|(
name|e
operator|->
name|e_message
argument_list|,
name|rlist
argument_list|,
name|RTSF_PM_BOUNCE
operator||
name|RTSF_NO_BODY
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Instantiate or deinstantiate the queue. 	*/
name|simpledrop
label|:
if|if
condition|(
name|tTd
argument_list|(
literal|50
argument_list|,
literal|8
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"dropenvelope(%s): at simpledrop, queueit=%d\n"
argument_list|,
name|id
argument_list|,
name|queueit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|queueit
operator|||
name|bitset
argument_list|(
name|EF_CLRQUEUE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|50
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"\n===== Dropping queue files for %s... queueit=%d, e_flags="
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|queueit
argument_list|)
expr_stmt|;
name|printenvflags
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|panic
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_dfp
operator|=
name|NULL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|xunlink
argument_list|(
name|queuename
argument_list|(
name|e
argument_list|,
name|DATAFL_LETTER
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|panic
operator|&&
name|QueueMode
operator|==
name|QM_LOST
condition|)
block|{
comment|/* 			**  leave the Qf file behind as 			**  the delivery attempt failed. 			*/
comment|/* EMPTY */
block|}
elseif|else
if|if
condition|(
name|xunlink
argument_list|(
name|queuename
argument_list|(
name|e
argument_list|,
name|ANYQFL_LETTER
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* add to available space in filesystem */
name|updfs
argument_list|(
name|e
argument_list|,
operator|-
literal|1
argument_list|,
name|panic
condition|?
literal|0
else|:
operator|-
literal|1
argument_list|,
literal|"dropenvelope"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|e_ntries
operator|>
literal|0
operator|&&
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|id
argument_list|,
literal|"done; delay=%s, ntries=%d"
argument_list|,
name|pintvl
argument_list|(
name|curtime
argument_list|()
operator|-
name|e
operator|->
name|e_ctime
argument_list|,
name|true
argument_list|)
argument_list|,
name|e
operator|->
name|e_ntries
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|queueit
operator|||
operator|!
name|bitset
argument_list|(
name|EF_INQUEUE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|split
condition|)
name|queueup
argument_list|(
name|e
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
else|else
block|{
name|ENVELOPE
modifier|*
name|oldsib
decl_stmt|;
name|ENVELOPE
modifier|*
name|ee
decl_stmt|;
comment|/* 			**  Save old sibling and set it to NULL to avoid 			**  queueing up the same envelopes again. 			**  This requires that envelopes in that list have 			**  been take care of before (or at some other place). 			*/
name|oldsib
operator|=
name|e
operator|->
name|e_sibling
expr_stmt|;
name|e
operator|->
name|e_sibling
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|split_by_recipient
argument_list|(
name|e
argument_list|)
operator|&&
name|bitset
argument_list|(
name|EF_FATALERRS
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|syserr
argument_list|(
literal|"!dropenvelope(%s): cannot commit data file %s, uid=%d"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|queuename
argument_list|(
name|e
argument_list|,
name|DATAFL_LETTER
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ee
operator|=
name|e
operator|->
name|e_sibling
init|;
name|ee
operator|!=
name|NULL
condition|;
name|ee
operator|=
name|ee
operator|->
name|e_sibling
control|)
name|queueup
argument_list|(
name|ee
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|queueup
argument_list|(
name|e
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* clean up */
for|for
control|(
name|ee
operator|=
name|e
operator|->
name|e_sibling
init|;
name|ee
operator|!=
name|NULL
condition|;
name|ee
operator|=
name|ee
operator|->
name|e_sibling
control|)
block|{
comment|/* now unlock the job */
if|if
condition|(
name|tTd
argument_list|(
literal|50
argument_list|,
literal|8
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"dropenvelope(%s): unlocking job\n"
argument_list|,
name|ee
operator|->
name|e_id
argument_list|)
expr_stmt|;
name|closexscript
argument_list|(
name|ee
argument_list|)
expr_stmt|;
name|unlockqueue
argument_list|(
name|ee
argument_list|)
expr_stmt|;
comment|/* this envelope is marked unused */
if|if
condition|(
name|ee
operator|->
name|e_dfp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|ee
operator|->
name|e_dfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
name|ee
operator|->
name|e_dfp
operator|=
name|NULL
expr_stmt|;
block|}
name|ee
operator|->
name|e_id
operator|=
name|NULL
expr_stmt|;
name|ee
operator|->
name|e_flags
operator|&=
operator|~
name|EF_HAS_DF
expr_stmt|;
block|}
name|e
operator|->
name|e_sibling
operator|=
name|oldsib
expr_stmt|;
block|}
block|}
comment|/* now unlock the job */
if|if
condition|(
name|tTd
argument_list|(
literal|50
argument_list|,
literal|8
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"dropenvelope(%s): unlocking job\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|closexscript
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|unlockqueue
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* make sure that this envelope is marked unused */
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_dfp
operator|=
name|NULL
expr_stmt|;
block|}
name|e
operator|->
name|e_id
operator|=
name|NULL
expr_stmt|;
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_HAS_DF
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  CLEARENVELOPE -- clear an envelope without unlocking ** **	This is normally used by a child process to get a clean **	envelope without disturbing the parent. ** **	Parameters: **		e -- the envelope to clear. **		fullclear - if set, the current envelope is total **			garbage and should be ignored; otherwise, **			release any resources it may indicate. **		rpool -- either NULL, or a pointer to a resource pool **			from which envelope memory is allocated, and **			to which envelope resources are attached. ** **	Returns: **		none. ** **	Side Effects: **		Closes files associated with the envelope. **		Marks the envelope as unallocated. */
end_comment

begin_function
name|void
name|clearenvelope
parameter_list|(
name|e
parameter_list|,
name|fullclear
parameter_list|,
name|rpool
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|bool
name|fullclear
decl_stmt|;
name|SM_RPOOL_T
modifier|*
name|rpool
decl_stmt|;
block|{
specifier|register
name|HDR
modifier|*
name|bh
decl_stmt|;
specifier|register
name|HDR
modifier|*
modifier|*
name|nhp
decl_stmt|;
specifier|extern
name|ENVELOPE
name|BlankEnvelope
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|fullclear
condition|)
block|{
comment|/* clear out any file information */
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_xfp
operator|=
name|e
operator|->
name|e_dfp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	**  Copy BlankEnvelope into *e. 	**  It is not safe to simply copy pointers to strings; 	**  the strings themselves must be copied (or set to NULL). 	**  The problem is that when we assign a new string value to 	**  a member of BlankEnvelope, we free the old string. 	**  We did not need to do this copying in sendmail 8.11 :-( 	**  and it is a potential performance hit.  Reference counted 	**  strings are one way out. 	*/
operator|*
name|e
operator|=
name|BlankEnvelope
expr_stmt|;
name|e
operator|->
name|e_message
operator|=
name|NULL
expr_stmt|;
name|e
operator|->
name|e_qfletter
operator|=
literal|'\0'
expr_stmt|;
name|e
operator|->
name|e_quarmsg
operator|=
name|NULL
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{quarantine}"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 	**  Copy the macro table. 	**  We might be able to avoid this by zeroing the macro table 	**  and always searching BlankEnvelope.e_macro after e->e_macro 	**  in macvalue(). 	*/
for|for
control|(
name|p
operator|=
operator|&
name|e
operator|->
name|e_macro
operator|.
name|mac_table
index|[
literal|0
index|]
init|;
name|p
operator|<=
operator|&
name|e
operator|->
name|e_macro
operator|.
name|mac_table
index|[
name|MAXMACROID
index|]
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|rpool
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  XXX There are many strings in the envelope structure 	**  XXX that we are not attempting to copy here. 	**  XXX Investigate this further. 	*/
name|e
operator|->
name|e_rpool
operator|=
name|rpool
expr_stmt|;
name|e
operator|->
name|e_macro
operator|.
name|mac_rpool
operator|=
name|rpool
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|set_delivery_mode
argument_list|(
name|SM_DELIVER
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|bh
operator|=
name|BlankEnvelope
operator|.
name|e_header
expr_stmt|;
name|nhp
operator|=
operator|&
name|e
operator|->
name|e_header
expr_stmt|;
while|while
condition|(
name|bh
operator|!=
name|NULL
condition|)
block|{
operator|*
name|nhp
operator|=
operator|(
name|HDR
operator|*
operator|)
name|sm_rpool_malloc_x
argument_list|(
name|rpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bh
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|nhp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bh
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bh
argument_list|)
argument_list|)
expr_stmt|;
name|bh
operator|=
name|bh
operator|->
name|h_link
expr_stmt|;
name|nhp
operator|=
operator|&
operator|(
operator|*
name|nhp
operator|)
operator|->
name|h_link
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  INITSYS -- initialize instantiation of system ** **	In Daemon mode, this is done in the child. ** **	Parameters: **		e -- the envelope to use. ** **	Returns: **		none. ** **	Side Effects: **		Initializes the system macros, some global variables, **		etc.  In particular, the current time in various **		forms is set. */
end_comment

begin_function
name|void
name|initsys
parameter_list|(
name|e
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|TTYNAME
specifier|static
name|char
name|ybuf
index|[
literal|60
index|]
decl_stmt|;
comment|/* holds tty id */
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|char
modifier|*
name|ttyname
parameter_list|()
function_decl|;
endif|#
directive|endif
comment|/* TTYNAME */
comment|/* 	**  Give this envelope a reality. 	**	I.e., an id, a transcript, and a creation time. 	**  We don't select the queue until all of the recipients are known. 	*/
name|openxscript
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_ctime
operator|=
name|curtime
argument_list|()
expr_stmt|;
name|e
operator|->
name|e_qfletter
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	**  Set OutChannel to something useful if stdout isn't it. 	**	This arranges that any extra stuff the mailer produces 	**	gets sent back to the user on error (because it is 	**	tucked away in the transcript). 	*/
if|if
condition|(
name|OpMode
operator|==
name|MD_DAEMON
operator|&&
name|bitset
argument_list|(
name|EF_QUEUERUN
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
condition|)
name|OutChannel
operator|=
name|e
operator|->
name|e_xfp
expr_stmt|;
comment|/* 	**  Set up some basic system macros. 	*/
comment|/* process id */
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|CurrentPid
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
literal|'p'
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* hop count */
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|e
operator|->
name|e_hopcount
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
literal|'c'
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* time as integer, unix time, arpa time */
name|settime
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* Load average */
name|sm_getla
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TTYNAME
comment|/* tty name */
if|if
condition|(
name|macvalue
argument_list|(
literal|'y'
argument_list|,
name|e
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|p
operator|=
name|ttyname
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strrchr
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
name|p
operator|=
name|strrchr
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|ybuf
argument_list|,
sizeof|sizeof
argument_list|(
name|ybuf
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'y'
argument_list|,
name|ybuf
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* TTYNAME */
block|}
end_function

begin_comment
comment|/* **  SETTIME -- set the current time. ** **	Parameters: **		e -- the envelope in which the macros should be set. ** **	Returns: **		none. ** **	Side Effects: **		Sets the various time macros -- $a, $b, $d, $t. */
end_comment

begin_function
name|void
name|settime
parameter_list|(
name|e
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|auto
name|time_t
name|now
decl_stmt|;
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
specifier|register
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|now
operator|=
name|curtime
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|now
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{time}"
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|tm
operator|=
name|gmtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%04d%02d%02d%02d%02d"
argument_list|,
name|tm
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|tm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|tm
operator|->
name|tm_mday
argument_list|,
name|tm
operator|->
name|tm_hour
argument_list|,
name|tm
operator|->
name|tm_min
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
literal|'t'
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|buf
argument_list|,
name|ctime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
literal|'d'
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
literal|'b'
argument_list|,
name|arpadate
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|macvalue
argument_list|(
literal|'a'
argument_list|,
name|e
argument_list|)
operator|==
name|NULL
condition|)
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'a'
argument_list|,
name|macvalue
argument_list|(
literal|'b'
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  OPENXSCRIPT -- Open transcript file ** **	Creates a transcript file for possible eventual mailing or **	sending back. ** **	Parameters: **		e -- the envelope to create the transcript in/for. ** **	Returns: **		none ** **	Side Effects: **		Creates the transcript file. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|O_APPEND
end_ifndef

begin_define
define|#
directive|define
name|O_APPEND
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! O_APPEND */
end_comment

begin_function
name|void
name|openxscript
parameter_list|(
name|e
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
condition|)
return|return;
if|#
directive|if
literal|0
block|if (e->e_lockfp == NULL&& bitset(EF_INQUEUE, e->e_flags)) 		syserr("openxscript: job not locked");
endif|#
directive|endif
comment|/* 0 */
name|p
operator|=
name|queuename
argument_list|(
name|e
argument_list|,
name|XSCRPT_LETTER
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_xfp
operator|=
name|bfopen
argument_list|(
name|p
argument_list|,
name|FileMode
argument_list|,
name|XscriptFileBufferSize
argument_list|,
name|SFF_NOTEXCL
operator||
name|SFF_OPENASROOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"Can't create transcript file %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_xfp
operator|=
name|sm_io_open
argument_list|(
name|SmFtStdio
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|SM_PATH_DEVNULL
argument_list|,
name|SM_IO_RDWR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"!Can't open %s"
argument_list|,
name|SM_PATH_DEVNULL
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_io_setvbuf
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|NULL
argument_list|,
name|SM_IO_LBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|46
argument_list|,
literal|9
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"openxscript(%s):\n  "
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|dumpfd
argument_list|(
name|sm_io_getinfo
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  CLOSEXSCRIPT -- close the transcript file. ** **	Parameters: **		e -- the envelope containing the transcript to close. ** **	Returns: **		none. ** **	Side Effects: **		none. */
end_comment

begin_function
name|void
name|closexscript
parameter_list|(
name|e
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|==
name|NULL
condition|)
return|return;
if|#
directive|if
literal|0
block|if (e->e_lockfp == NULL) 		syserr("closexscript: job not locked");
endif|#
directive|endif
comment|/* 0 */
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_xfp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  SETSENDER -- set the person who this message is from ** **	Under certain circumstances allow the user to say who **	s/he is (using -f or -r).  These are: **	1.  The user's uid is zero (root). **	2.  The user's login name is in an approved list (typically **	    from a network server). **	3.  The address the user is trying to claim has a **	    "!" character in it (since #2 doesn't do it for **	    us if we are dialing out for UUCP). **	A better check to replace #3 would be if the **	effective uid is "UUCP" -- this would require me **	to rewrite getpwent to "grab" uucp as it went by, **	make getname more nasty, do another passwd file **	scan, or compile the UID of "UUCP" into the code, **	all of which are reprehensible. ** **	Assuming all of these fail, we figure out something **	ourselves. ** **	Parameters: **		from -- the person we would like to believe this message **			is from, as specified on the command line. **		e -- the envelope in which we would like the sender set. **		delimptr -- if non-NULL, set to the location of the **			trailing delimiter. **		delimchar -- the character that will delimit the sender **			address. **		internal -- set if this address is coming from an internal **			source such as an owner alias. ** **	Returns: **		none. ** **	Side Effects: **		sets sendmail's notion of who the from person is. */
end_comment

begin_function
name|void
name|setsender
parameter_list|(
name|from
parameter_list|,
name|e
parameter_list|,
name|delimptr
parameter_list|,
name|delimchar
parameter_list|,
name|internal
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
modifier|*
name|delimptr
decl_stmt|;
name|int
name|delimchar
decl_stmt|;
name|bool
name|internal
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
name|char
modifier|*
name|realname
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
name|char
name|buf
index|[
name|MAXNAME
operator|+
literal|2
index|]
decl_stmt|;
name|char
name|pvpbuf
index|[
name|PSBUFSIZE
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|FullName
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|45
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"setsender(%s)\n"
argument_list|,
name|from
operator|==
name|NULL
condition|?
literal|""
else|:
name|from
argument_list|)
expr_stmt|;
comment|/* may be set from earlier calls */
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'x'
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 	**  Figure out the real user executing us. 	**	Username can return errno != 0 on non-errors. 	*/
if|if
condition|(
name|bitset
argument_list|(
name|EF_QUEUERUN
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|||
name|OpMode
operator|==
name|MD_SMTP
operator|||
name|OpMode
operator|==
name|MD_ARPAFTP
operator|||
name|OpMode
operator|==
name|MD_DAEMON
condition|)
name|realname
operator|=
name|from
expr_stmt|;
if|if
condition|(
name|realname
operator|==
name|NULL
operator|||
name|realname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|realname
operator|=
name|username
argument_list|()
expr_stmt|;
if|if
condition|(
name|ConfigLevel
operator|<
literal|2
condition|)
name|SuprErrs
operator|=
name|true
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{addr_type}"
argument_list|)
argument_list|,
literal|"e s"
argument_list|)
expr_stmt|;
comment|/* preset state for then clause in case from == NULL */
name|e
operator|->
name|e_from
operator|.
name|q_state
operator|=
name|QS_BADADDR
expr_stmt|;
name|e
operator|->
name|e_from
operator|.
name|q_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|from
operator|==
name|NULL
operator|||
name|parseaddr
argument_list|(
name|from
argument_list|,
operator|&
name|e
operator|->
name|e_from
argument_list|,
name|RF_COPYALL
operator||
name|RF_SENDERADDR
argument_list|,
name|delimchar
argument_list|,
name|delimptr
argument_list|,
name|e
argument_list|,
name|false
argument_list|)
operator|==
name|NULL
operator|||
name|QS_IS_BADADDR
argument_list|(
name|e
operator|->
name|e_from
operator|.
name|q_state
argument_list|)
operator|||
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|==
name|ProgMailer
operator|||
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|==
name|FileMailer
operator|||
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|==
name|InclMailer
condition|)
block|{
comment|/* log garbage addresses for traceback */
if|if
condition|(
name|from
operator|!=
name|NULL
operator|&&
name|LogLevel
operator|>
literal|2
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|ebuf
index|[
name|MAXNAME
operator|*
literal|2
operator|+
literal|2
index|]
decl_stmt|;
name|p
operator|=
name|macvalue
argument_list|(
literal|'_'
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|host
init|=
name|RealHostName
decl_stmt|;
if|if
condition|(
name|host
operator|==
name|NULL
condition|)
name|host
operator|=
name|MyHostName
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|ebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|ebuf
argument_list|)
argument_list|,
literal|"%.*s@%.*s"
argument_list|,
name|MAXNAME
argument_list|,
name|realname
argument_list|,
name|MAXNAME
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|p
operator|=
name|ebuf
expr_stmt|;
block|}
name|sm_syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"setsender: %s: invalid or unparsable, received from %s"
argument_list|,
name|shortenstring
argument_list|(
name|from
argument_list|,
literal|83
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|from
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|QS_IS_BADADDR
argument_list|(
name|e
operator|->
name|e_from
operator|.
name|q_state
argument_list|)
condition|)
block|{
comment|/* it was a bogus mailer in the from addr */
name|e
operator|->
name|e_status
operator|=
literal|"5.1.7"
expr_stmt|;
name|usrerrenh
argument_list|(
name|e
operator|->
name|e_status
argument_list|,
literal|"553 Invalid sender address"
argument_list|)
expr_stmt|;
block|}
name|SuprErrs
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|from
operator|==
name|realname
operator|||
name|parseaddr
argument_list|(
name|from
operator|=
name|realname
argument_list|,
operator|&
name|e
operator|->
name|e_from
argument_list|,
name|RF_COPYALL
operator||
name|RF_SENDERADDR
argument_list|,
literal|' '
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
name|false
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|char
name|nbuf
index|[
literal|100
index|]
decl_stmt|;
name|SuprErrs
operator|=
name|true
expr_stmt|;
name|expand
argument_list|(
literal|"\201n"
argument_list|,
name|nbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|nbuf
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|from
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|parseaddr
argument_list|(
name|from
argument_list|,
operator|&
name|e
operator|->
name|e_from
argument_list|,
name|RF_COPYALL
argument_list|,
literal|' '
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
name|false
argument_list|)
operator|==
name|NULL
operator|&&
name|parseaddr
argument_list|(
name|from
operator|=
literal|"postmaster"
argument_list|,
operator|&
name|e
operator|->
name|e_from
argument_list|,
name|RF_COPYALL
argument_list|,
literal|' '
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
name|false
argument_list|)
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"553 5.3.0 setsender: can't even parse postmaster!"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|FromFlag
operator|=
name|true
expr_stmt|;
name|e
operator|->
name|e_from
operator|.
name|q_state
operator|=
name|QS_SENDER
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|45
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"setsender: QS_SENDER "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
operator|&
name|e
operator|->
name|e_from
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|SuprErrs
operator|=
name|false
expr_stmt|;
if|#
directive|if
name|USERDB
if|if
condition|(
name|bitnset
argument_list|(
name|M_CHECKUDB
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|->
name|m_flags
argument_list|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|udbsender
argument_list|(
name|e
operator|->
name|e_from
operator|.
name|q_user
argument_list|,
name|e
operator|->
name|e_rpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|from
operator|=
name|p
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USERDB */
if|if
condition|(
name|bitnset
argument_list|(
name|M_HASPWENT
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|->
name|m_flags
argument_list|)
condition|)
block|{
name|SM_MBDB_T
name|user
decl_stmt|;
if|if
condition|(
operator|!
name|internal
condition|)
block|{
comment|/* if the user already given fullname don't redefine */
if|if
condition|(
name|FullName
operator|==
name|NULL
condition|)
name|FullName
operator|=
name|macvalue
argument_list|(
literal|'x'
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|FullName
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|FullName
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|FullName
operator|=
name|NULL
expr_stmt|;
else|else
name|FullName
operator|=
name|newstr
argument_list|(
name|FullName
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|->
name|e_from
operator|.
name|q_user
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|sm_mbdb_lookup
argument_list|(
name|e
operator|->
name|e_from
operator|.
name|q_user
argument_list|,
operator|&
name|user
argument_list|)
operator|==
name|EX_OK
condition|)
block|{
comment|/* 			**  Process passwd file entry. 			*/
comment|/* extract home directory */
if|if
condition|(
operator|*
name|user
operator|.
name|mbdb_homedir
operator|==
literal|'\0'
condition|)
name|e
operator|->
name|e_from
operator|.
name|q_home
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|user
operator|.
name|mbdb_homedir
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
condition|)
name|e
operator|->
name|e_from
operator|.
name|q_home
operator|=
literal|""
expr_stmt|;
else|else
name|e
operator|->
name|e_from
operator|.
name|q_home
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|user
operator|.
name|mbdb_homedir
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'z'
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_home
argument_list|)
expr_stmt|;
comment|/* extract user and group id */
if|if
condition|(
name|user
operator|.
name|mbdb_uid
operator|!=
name|SM_NO_UID
condition|)
block|{
name|e
operator|->
name|e_from
operator|.
name|q_uid
operator|=
name|user
operator|.
name|mbdb_uid
expr_stmt|;
name|e
operator|->
name|e_from
operator|.
name|q_gid
operator|=
name|user
operator|.
name|mbdb_gid
expr_stmt|;
name|e
operator|->
name|e_from
operator|.
name|q_flags
operator||=
name|QGOODUID
expr_stmt|;
block|}
comment|/* extract full name from passwd file */
if|if
condition|(
name|FullName
operator|==
name|NULL
operator|&&
operator|!
name|internal
operator|&&
name|user
operator|.
name|mbdb_fullname
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|strcmp
argument_list|(
name|user
operator|.
name|mbdb_name
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_user
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FullName
operator|=
name|newstr
argument_list|(
name|user
operator|.
name|mbdb_fullname
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|e
operator|->
name|e_from
operator|.
name|q_home
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|FullName
operator|!=
name|NULL
operator|&&
operator|!
name|internal
condition|)
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
literal|'x'
argument_list|,
name|FullName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|internal
operator|&&
name|OpMode
operator|!=
name|MD_DAEMON
operator|&&
name|OpMode
operator|!=
name|MD_SMTP
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|e_from
operator|.
name|q_home
operator|==
name|NULL
condition|)
block|{
name|e
operator|->
name|e_from
operator|.
name|q_home
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_from
operator|.
name|q_home
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|e
operator|->
name|e_from
operator|.
name|q_home
operator|==
literal|'\0'
condition|)
name|e
operator|->
name|e_from
operator|.
name|q_home
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|e
operator|->
name|e_from
operator|.
name|q_home
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
condition|)
name|e
operator|->
name|e_from
operator|.
name|q_home
operator|++
expr_stmt|;
block|}
block|}
name|e
operator|->
name|e_from
operator|.
name|q_uid
operator|=
name|RealUid
expr_stmt|;
name|e
operator|->
name|e_from
operator|.
name|q_gid
operator|=
name|RealGid
expr_stmt|;
name|e
operator|->
name|e_from
operator|.
name|q_flags
operator||=
name|QGOODUID
expr_stmt|;
block|}
comment|/* 	**  Rewrite the from person to dispose of possible implicit 	**	links in the net. 	*/
name|pvp
operator|=
name|prescan
argument_list|(
name|from
argument_list|,
name|delimchar
argument_list|,
name|pvpbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pvpbuf
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|IntTokenTab
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
block|{
comment|/* don't need to give error -- prescan did that already */
if|if
condition|(
name|LogLevel
operator|>
literal|2
condition|)
name|sm_syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"cannot prescan from (%s)"
argument_list|,
name|shortenstring
argument_list|(
name|from
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|REWRITE
argument_list|(
name|pvp
argument_list|,
literal|3
argument_list|,
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|REWRITE
argument_list|(
name|pvp
argument_list|,
literal|1
argument_list|,
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|REWRITE
argument_list|(
name|pvp
argument_list|,
literal|4
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{addr_type}"
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buf
operator|+
literal|1
expr_stmt|;
name|cataddr
argument_list|(
name|pvp
argument_list|,
name|NULL
argument_list|,
name|bp
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|2
argument_list|,
literal|'\0'
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'@'
operator|&&
operator|!
name|bitnset
argument_list|(
name|M_NOBRACKET
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|->
name|m_flags
argument_list|)
condition|)
block|{
comment|/* heuristic: route-addr: add angle brackets */
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|bp
argument_list|,
literal|">"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
operator|--
name|bp
operator|=
literal|'<'
expr_stmt|;
block|}
name|e
operator|->
name|e_sender
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'f'
argument_list|,
name|e
operator|->
name|e_sender
argument_list|)
expr_stmt|;
comment|/* save the domain spec if this mailer wants it */
if|if
condition|(
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|!=
name|NULL
operator|&&
name|bitnset
argument_list|(
name|M_CANONICAL
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|->
name|m_flags
argument_list|)
condition|)
block|{
name|char
modifier|*
modifier|*
name|lastat
decl_stmt|;
comment|/* get rid of any pesky angle brackets */
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{addr_type}"
argument_list|)
argument_list|,
literal|"e s"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|REWRITE
argument_list|(
name|pvp
argument_list|,
literal|3
argument_list|,
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|REWRITE
argument_list|(
name|pvp
argument_list|,
literal|1
argument_list|,
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|REWRITE
argument_list|(
name|pvp
argument_list|,
literal|4
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{addr_type}"
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* strip off to the last "@" sign */
for|for
control|(
name|lastat
operator|=
name|NULL
init|;
operator|*
name|pvp
operator|!=
name|NULL
condition|;
name|pvp
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|pvp
argument_list|,
literal|"@"
argument_list|)
operator|==
literal|0
condition|)
name|lastat
operator|=
name|pvp
expr_stmt|;
block|}
if|if
condition|(
name|lastat
operator|!=
name|NULL
condition|)
block|{
name|e
operator|->
name|e_fromdomain
operator|=
name|copyplist
argument_list|(
name|lastat
argument_list|,
name|true
argument_list|,
name|e
operator|->
name|e_rpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|45
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"Saving from domain: "
argument_list|)
expr_stmt|;
name|printav
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|e
operator|->
name|e_fromdomain
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* **  PRINTENVFLAGS -- print envelope flags for debugging ** **	Parameters: **		e -- the envelope with the flags to be printed. ** **	Returns: **		none. */
end_comment

begin_struct
struct|struct
name|eflags
block|{
name|char
modifier|*
name|ef_name
decl_stmt|;
name|unsigned
name|long
name|ef_bit
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|eflags
name|EnvelopeFlags
index|[]
init|=
block|{
block|{
literal|"OLDSTYLE"
block|,
name|EF_OLDSTYLE
block|}
block|,
block|{
literal|"INQUEUE"
block|,
name|EF_INQUEUE
block|}
block|,
block|{
literal|"NO_BODY_RETN"
block|,
name|EF_NO_BODY_RETN
block|}
block|,
block|{
literal|"CLRQUEUE"
block|,
name|EF_CLRQUEUE
block|}
block|,
block|{
literal|"SENDRECEIPT"
block|,
name|EF_SENDRECEIPT
block|}
block|,
block|{
literal|"FATALERRS"
block|,
name|EF_FATALERRS
block|}
block|,
block|{
literal|"DELETE_BCC"
block|,
name|EF_DELETE_BCC
block|}
block|,
block|{
literal|"RESPONSE"
block|,
name|EF_RESPONSE
block|}
block|,
block|{
literal|"RESENT"
block|,
name|EF_RESENT
block|}
block|,
block|{
literal|"VRFYONLY"
block|,
name|EF_VRFYONLY
block|}
block|,
block|{
literal|"WARNING"
block|,
name|EF_WARNING
block|}
block|,
block|{
literal|"QUEUERUN"
block|,
name|EF_QUEUERUN
block|}
block|,
block|{
literal|"GLOBALERRS"
block|,
name|EF_GLOBALERRS
block|}
block|,
block|{
literal|"PM_NOTIFY"
block|,
name|EF_PM_NOTIFY
block|}
block|,
block|{
literal|"METOO"
block|,
name|EF_METOO
block|}
block|,
block|{
literal|"LOGSENDER"
block|,
name|EF_LOGSENDER
block|}
block|,
block|{
literal|"NORECEIPT"
block|,
name|EF_NORECEIPT
block|}
block|,
block|{
literal|"HAS8BIT"
block|,
name|EF_HAS8BIT
block|}
block|,
block|{
literal|"NL_NOT_EOL"
block|,
name|EF_NL_NOT_EOL
block|}
block|,
block|{
literal|"CRLF_NOT_EOL"
block|,
name|EF_CRLF_NOT_EOL
block|}
block|,
block|{
literal|"RET_PARAM"
block|,
name|EF_RET_PARAM
block|}
block|,
block|{
literal|"HAS_DF"
block|,
name|EF_HAS_DF
block|}
block|,
block|{
literal|"IS_MIME"
block|,
name|EF_IS_MIME
block|}
block|,
block|{
literal|"DONT_MIME"
block|,
name|EF_DONT_MIME
block|}
block|,
block|{
literal|"DISCARD"
block|,
name|EF_DISCARD
block|}
block|,
block|{
literal|"TOOBIG"
block|,
name|EF_TOOBIG
block|}
block|,
block|{
literal|"SPLIT"
block|,
name|EF_SPLIT
block|}
block|,
block|{
literal|"UNSAFE"
block|,
name|EF_UNSAFE
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|printenvflags
parameter_list|(
name|e
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|struct
name|eflags
modifier|*
name|ef
decl_stmt|;
name|bool
name|first
init|=
name|true
decl_stmt|;
name|sm_dprintf
argument_list|(
literal|"%lx"
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
expr_stmt|;
for|for
control|(
name|ef
operator|=
name|EnvelopeFlags
init|;
name|ef
operator|->
name|ef_name
operator|!=
name|NULL
condition|;
name|ef
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|ef
operator|->
name|ef_bit
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|first
condition|)
name|sm_dprintf
argument_list|(
literal|"<%s"
argument_list|,
name|ef
operator|->
name|ef_name
argument_list|)
expr_stmt|;
else|else
name|sm_dprintf
argument_list|(
literal|",%s"
argument_list|,
name|ef
operator|->
name|ef_name
argument_list|)
expr_stmt|;
name|first
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|first
condition|)
name|sm_dprintf
argument_list|(
literal|">\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

