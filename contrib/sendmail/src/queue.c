begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998-2005 Sendmail, Inc. and its suppliers.  *	All rights reserved.  * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_include
include|#
directive|include
file|<sendmail.h>
end_include

begin_include
include|#
directive|include
file|<sm/sem.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: queue.c,v 8.951 2006/03/02 19:13:38 ca Exp $"
argument_list|)
end_macro

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_define
define|#
directive|define
name|RELEASE_QUEUE
value|(void) 0
end_define

begin_define
define|#
directive|define
name|ST_INODE
parameter_list|(
name|st
parameter_list|)
value|(st).st_ino
end_define

begin_define
define|#
directive|define
name|sm_file_exists
parameter_list|(
name|errno
parameter_list|)
value|((errno) == EEXIST)
end_define

begin_if
if|#
directive|if
name|HASFLOCK
operator|&&
name|defined
argument_list|(
name|O_EXLOCK
argument_list|)
end_if

begin_define
define|#
directive|define
name|SM_OPEN_EXLOCK
value|1
end_define

begin_define
define|#
directive|define
name|TF_OPEN_FLAGS
value|(O_CREAT|O_WRONLY|O_EXCL|O_EXLOCK)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* HASFLOCK&& defined(O_EXLOCK) */
end_comment

begin_define
define|#
directive|define
name|TF_OPEN_FLAGS
value|(O_CREAT|O_WRONLY|O_EXCL)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HASFLOCK&& defined(O_EXLOCK) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SM_OPEN_EXLOCK
end_ifndef

begin_define
define|#
directive|define
name|SM_OPEN_EXLOCK
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! SM_OPEN_EXLOCK */
end_comment

begin_comment
comment|/* **  Historical notes: **	QF_VERSION == 4 was sendmail 8.10/8.11 without _FFR_QUEUEDELAY **	QF_VERSION == 5 was sendmail 8.10/8.11 with    _FFR_QUEUEDELAY **	QF_VERSION == 6 was sendmail 8.12      without _FFR_QUEUEDELAY **	QF_VERSION == 7 was sendmail 8.12      with    _FFR_QUEUEDELAY **	QF_VERSION == 8 is  sendmail 8.13 */
end_comment

begin_define
define|#
directive|define
name|QF_VERSION
value|8
end_define

begin_comment
comment|/* version number of this queue format */
end_comment

begin_decl_stmt
specifier|static
name|char
name|queue_letter
name|__P
argument_list|(
operator|(
name|ENVELOPE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|quarantine_queue_item
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|ENVELOPE
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Naming convention: qgrp: index of queue group, qg: QUEUEGROUP */
end_comment

begin_comment
comment|/* **  Work queue. */
end_comment

begin_struct
struct|struct
name|work
block|{
name|char
modifier|*
name|w_name
decl_stmt|;
comment|/* name of control file */
name|char
modifier|*
name|w_host
decl_stmt|;
comment|/* name of recipient host */
name|bool
name|w_lock
decl_stmt|;
comment|/* is message locked? */
name|bool
name|w_tooyoung
decl_stmt|;
comment|/* is it too young to run? */
name|long
name|w_pri
decl_stmt|;
comment|/* priority of message, see below */
name|time_t
name|w_ctime
decl_stmt|;
comment|/* creation time */
name|time_t
name|w_mtime
decl_stmt|;
comment|/* modification time */
name|int
name|w_qgrp
decl_stmt|;
comment|/* queue group located in */
name|int
name|w_qdir
decl_stmt|;
comment|/* queue directory located in */
name|struct
name|work
modifier|*
name|w_next
decl_stmt|;
comment|/* next in queue */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|work
name|WORK
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|WORK
modifier|*
name|WorkQ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* queue of things to be done */
end_comment

begin_decl_stmt
specifier|static
name|int
name|NumWorkGroups
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of work groups */
end_comment

begin_decl_stmt
specifier|static
name|time_t
name|Current_LA_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get new load average every 30 seconds. */
end_comment

begin_define
define|#
directive|define
name|GET_NEW_LA_TIME
value|30
end_define

begin_define
define|#
directive|define
name|SM_GET_LA
parameter_list|(
name|now
parameter_list|)
define|\
value|do							\ 	{							\ 		now = curtime();				\ 		if (Current_LA_time< now - GET_NEW_LA_TIME)	\ 		{						\ 			sm_getla();				\ 			Current_LA_time = now;			\ 		}						\ 	} while (0)
end_define

begin_comment
comment|/* **  DoQueueRun indicates that a queue run is needed. **	Notice: DoQueueRun is modified in a signal handler! */
end_comment

begin_decl_stmt
specifier|static
name|bool
specifier|volatile
name|DoQueueRun
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* non-interrupt time queue run needed */
end_comment

begin_comment
comment|/* **  Work group definition structure. **	Each work group contains one or more queue groups. This is done **	to manage the number of queue group runners active at the same time **	to be within the constraints of MaxQueueChildren (if it is set). **	The number of queue groups that can be run on the next work run **	is kept track of. The queue groups are run in a round robin. */
end_comment

begin_struct
struct|struct
name|workgrp
block|{
name|int
name|wg_numqgrp
decl_stmt|;
comment|/* number of queue groups in work grp */
name|int
name|wg_runners
decl_stmt|;
comment|/* total runners */
name|int
name|wg_curqgrp
decl_stmt|;
comment|/* current queue group */
name|QUEUEGRP
modifier|*
modifier|*
name|wg_qgs
decl_stmt|;
comment|/* array of queue groups */
name|int
name|wg_maxact
decl_stmt|;
comment|/* max # of active runners */
name|time_t
name|wg_lowqintvl
decl_stmt|;
comment|/* lowest queue interval */
name|int
name|wg_restart
decl_stmt|;
comment|/* needs restarting? */
name|int
name|wg_restartcnt
decl_stmt|;
comment|/* count of times restarted */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|workgrp
name|WORKGRP
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|WORKGRP
specifier|volatile
name|WorkGrp
index|[
name|MAXWORKGROUPS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* work groups */
end_comment

begin_if
if|#
directive|if
name|SM_HEAP_CHECK
end_if

begin_decl_stmt
specifier|static
name|SM_DEBUG_T
name|DebugLeakQ
init|=
name|SM_DEBUG_INITIALIZER
argument_list|(
literal|"leak_q"
argument_list|,
literal|"@(#)$Debug: leak_q - trace memory leaks during queue processing $"
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SM_HEAP_CHECK */
end_comment

begin_comment
comment|/* **  We use EmptyString instead of "" to avoid **  'zero-length format string' warnings from gcc */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|EmptyString
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|grow_wlist
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|multiqueue_cache
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|QUEUEGRP
operator|*
operator|,
name|int
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gatherq
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|bool
operator|,
name|bool
operator|*
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sortq
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|printctladdr
name|__P
argument_list|(
operator|(
name|ADDRESS
operator|*
operator|,
name|SM_FILE_T
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|readqf
name|__P
argument_list|(
operator|(
name|ENVELOPE
operator|*
operator|,
name|bool
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|restart_work_group
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|runner_work
name|__P
argument_list|(
operator|(
name|ENVELOPE
operator|*
operator|,
name|int
operator|,
name|bool
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|schedule_queue_runs
name|__P
argument_list|(
operator|(
name|bool
operator|,
name|int
operator|,
name|bool
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|strrev
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ADDRESS
modifier|*
name|setctluser
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|_FFR_RHS
end_if

begin_decl_stmt
specifier|static
name|int
name|sm_strshufflecmp
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_shuffle_alphabet
name|__P
argument_list|(
operator|(
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_RHS */
end_comment

begin_function_decl
specifier|static
name|int
name|workcmpf0
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|workcmpf1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|workcmpf2
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|workcmpf3
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|workcmpf4
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|randi
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index for workcmpf5() */
end_comment

begin_function_decl
specifier|static
name|int
name|workcmpf5
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|workcmpf6
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|_FFR_RHS
end_if

begin_function_decl
specifier|static
name|int
name|workcmpf7
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_RHS */
end_comment

begin_if
if|#
directive|if
name|RANDOMSHIFT
end_if

begin_define
define|#
directive|define
name|get_rand_mod
parameter_list|(
name|m
parameter_list|)
value|((get_random()>> RANDOMSHIFT) % (m))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* RANDOMSHIFT */
end_comment

begin_define
define|#
directive|define
name|get_rand_mod
parameter_list|(
name|m
parameter_list|)
value|(get_random() % (m))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RANDOMSHIFT */
end_comment

begin_comment
comment|/* **  File system definition. **	Used to keep track of how much free space is available **	on a file system in which one or more queue directories reside. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|filesys_shared
name|FILESYS
typedef|;
end_typedef

begin_struct
struct|struct
name|filesys_shared
block|{
name|dev_t
name|fs_dev
decl_stmt|;
comment|/* unique device id */
name|long
name|fs_avail
decl_stmt|;
comment|/* number of free blocks available */
name|long
name|fs_blksize
decl_stmt|;
comment|/* block size, in bytes */
block|}
struct|;
end_struct

begin_comment
comment|/* probably kept in shared memory */
end_comment

begin_decl_stmt
specifier|static
name|FILESYS
name|FileSys
index|[
name|MAXFILESYS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* queue file systems */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|FSPath
index|[
name|MAXFILESYS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pathnames for file systems */
end_comment

begin_if
if|#
directive|if
name|SM_CONF_SHM
end_if

begin_comment
comment|/* **  Shared memory data ** **  Current layout: **	size -- size of shared memory segment **	pid -- pid of owner, should be a unique id to avoid misinterpretations **		by other processes. **	tag -- should be a unique id to avoid misinterpretations by others. **		idea: hash over configuration data that will be stored here. **	NumFileSys -- number of file systems. **	FileSys -- (arrary of) structure for used file systems. **	RSATmpCnt -- counter for number of uses of ephemeral RSA key. **	QShm -- (array of) structure for information about queue directories. */
end_comment

begin_comment
comment|/* **  Queue data in shared memory */
end_comment

begin_typedef
typedef|typedef
name|struct
name|queue_shared
name|QUEUE_SHM_T
typedef|;
end_typedef

begin_struct
struct|struct
name|queue_shared
block|{
name|int
name|qs_entries
decl_stmt|;
comment|/* number of entries */
comment|/* XXX more to follow? */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
modifier|*
name|Pshm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to shared memory */
end_comment

begin_decl_stmt
specifier|static
name|FILESYS
modifier|*
name|PtrFileSys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to queue file system array */
end_comment

begin_decl_stmt
name|int
name|ShmId
init|=
name|SM_SHM_NO_ID
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* shared memory id */
end_comment

begin_decl_stmt
specifier|static
name|QUEUE_SHM_T
modifier|*
name|QShm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to shared queue data */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|shms
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SHM_OFF_PID
parameter_list|(
name|p
parameter_list|)
value|(((char *) (p)) + sizeof(int))
end_define

begin_define
define|#
directive|define
name|SHM_OFF_TAG
parameter_list|(
name|p
parameter_list|)
value|(((char *) (p)) + sizeof(pid_t) + sizeof(int))
end_define

begin_define
define|#
directive|define
name|SHM_OFF_HEAD
value|(sizeof(pid_t) + sizeof(int) * 2)
end_define

begin_comment
comment|/* how to access FileSys */
end_comment

begin_define
define|#
directive|define
name|FILE_SYS
parameter_list|(
name|i
parameter_list|)
value|(PtrFileSys[i])
end_define

begin_comment
comment|/* first entry is a tag, for now just the size */
end_comment

begin_define
define|#
directive|define
name|OFF_FILE_SYS
parameter_list|(
name|p
parameter_list|)
value|(((char *) (p)) + SHM_OFF_HEAD)
end_define

begin_comment
comment|/* offset for PNumFileSys */
end_comment

begin_define
define|#
directive|define
name|OFF_NUM_FILE_SYS
parameter_list|(
name|p
parameter_list|)
value|(((char *) (p)) + SHM_OFF_HEAD + sizeof(FileSys))
end_define

begin_comment
comment|/* offset for PRSATmpCnt */
end_comment

begin_define
define|#
directive|define
name|OFF_RSA_TMP_CNT
parameter_list|(
name|p
parameter_list|)
value|(((char *) (p)) + SHM_OFF_HEAD + sizeof(FileSys) + sizeof(int))
end_define

begin_decl_stmt
name|int
modifier|*
name|PRSATmpCnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* offset for queue_shm */
end_comment

begin_define
define|#
directive|define
name|OFF_QUEUE_SHM
parameter_list|(
name|p
parameter_list|)
value|(((char *) (p)) + SHM_OFF_HEAD + sizeof(FileSys) + sizeof(int) * 2)
end_define

begin_define
define|#
directive|define
name|QSHM_ENTRIES
parameter_list|(
name|i
parameter_list|)
value|QShm[i].qs_entries
end_define

begin_comment
comment|/* basic size of shared memory segment */
end_comment

begin_define
define|#
directive|define
name|SM_T_SIZE
value|(SHM_OFF_HEAD + sizeof(FileSys) + sizeof(int) * 2)
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|hash_q
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  HASH_Q -- simple hash function ** **	Parameters: **		p -- string to hash. **		h -- hash start value (from previous run). ** **	Returns: **		hash value. */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|hash_q
parameter_list|(
name|p
parameter_list|,
name|h
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|h
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|d
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|d
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|c
operator|=
name|d
expr_stmt|;
name|c
operator|^=
name|c
operator|<<
literal|6
expr_stmt|;
name|h
operator|+=
operator|(
name|c
operator|<<
literal|11
operator|)
operator|^
operator|(
name|c
operator|>>
literal|1
operator|)
expr_stmt|;
name|h
operator|^=
operator|(
name|d
operator|<<
literal|14
operator|)
operator|+
operator|(
name|d
operator|<<
literal|7
operator|)
operator|+
operator|(
name|d
operator|<<
literal|4
operator|)
operator|+
name|d
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SM_CONF_SHM */
end_comment

begin_define
define|#
directive|define
name|FILE_SYS
parameter_list|(
name|i
parameter_list|)
value|FileSys[i]
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SM_CONF_SHM */
end_comment

begin_comment
comment|/* access to the various components of file system data */
end_comment

begin_define
define|#
directive|define
name|FILE_SYS_NAME
parameter_list|(
name|i
parameter_list|)
value|FSPath[i]
end_define

begin_define
define|#
directive|define
name|FILE_SYS_AVAIL
parameter_list|(
name|i
parameter_list|)
value|FILE_SYS(i).fs_avail
end_define

begin_define
define|#
directive|define
name|FILE_SYS_BLKSIZE
parameter_list|(
name|i
parameter_list|)
value|FILE_SYS(i).fs_blksize
end_define

begin_define
define|#
directive|define
name|FILE_SYS_DEV
parameter_list|(
name|i
parameter_list|)
value|FILE_SYS(i).fs_dev
end_define

begin_comment
comment|/* **  Current qf file field assignments: ** **	A	AUTH= parameter **	B	body type **	C	controlling user **	D	data file name **	d	data file directory name (added in 8.12) **	E	error recipient **	F	flag bits **	G	free (was: queue delay algorithm if _FFR_QUEUEDELAY) **	H	header **	I	data file's inode number **	K	time of last delivery attempt **	L	Solaris Content-Length: header (obsolete) **	M	message **	N	number of delivery attempts **	P	message priority **	q	quarantine reason **	Q	original recipient (ORCPT=) **	r	final recipient (Final-Recipient: DSN field) **	R	recipient **	S	sender **	T	init time **	V	queue file version **	X	free (was: character set if _FFR_SAVE_CHARSET) **	Y	free (was: current delay if _FFR_QUEUEDELAY) **	Z	original envelope id from ESMTP **	!	deliver by (added in 8.12) **	$	define macro **	.	terminate file */
end_comment

begin_comment
comment|/* **  QUEUEUP -- queue a message up for future transmission. ** **	Parameters: **		e -- the envelope to queue up. **		announce -- if true, tell when you are queueing up. **		msync -- if true, then fsync() if SuperSafe interactive mode. ** **	Returns: **		none. ** **	Side Effects: **		The current request is saved in a control file. **		The queue file is left locked. */
end_comment

begin_function
name|void
name|queueup
parameter_list|(
name|e
parameter_list|,
name|announce
parameter_list|,
name|msync
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|bool
name|announce
decl_stmt|;
name|bool
name|msync
decl_stmt|;
block|{
specifier|register
name|SM_FILE_T
modifier|*
name|tfp
decl_stmt|;
specifier|register
name|HDR
modifier|*
name|h
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
name|int
name|tfd
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bool
name|newid
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|MAILER
name|nullmailer
decl_stmt|;
name|MCI
name|mcibuf
decl_stmt|;
name|char
name|qf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|tf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|df
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
comment|/* 	**  Create control file. 	*/
define|#
directive|define
name|OPEN_TF
value|do							\ 		{							\ 			MODE_T oldumask = 0;				\ 									\ 			if (bitset(S_IWGRP, QueueFileMode))		\ 				oldumask = umask(002);			\ 			tfd = open(tf, TF_OPEN_FLAGS, QueueFileMode);	\ 			if (bitset(S_IWGRP, QueueFileMode))		\ 				(void) umask(oldumask);			\ 		} while (0)
name|newid
operator|=
operator|(
name|e
operator|->
name|e_id
operator|==
name|NULL
operator|)
operator|||
operator|!
name|bitset
argument_list|(
name|EF_INQUEUE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|tf
argument_list|,
name|queuename
argument_list|(
name|e
argument_list|,
name|NEWQFL_LETTER
argument_list|)
argument_list|,
sizeof|sizeof
name|tf
argument_list|)
expr_stmt|;
name|tfp
operator|=
name|e
operator|->
name|e_lockfp
expr_stmt|;
if|if
condition|(
name|tfp
operator|==
name|NULL
operator|&&
name|newid
condition|)
block|{
comment|/* 		**  open qf file directly: this will give an error if the file 		**  already exists and hence prevent problems if a queue-id 		**  is reused (e.g., because the clock is set back). 		*/
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|tf
argument_list|,
name|queuename
argument_list|(
name|e
argument_list|,
name|ANYQFL_LETTER
argument_list|)
argument_list|,
sizeof|sizeof
name|tf
argument_list|)
expr_stmt|;
name|OPEN_TF
expr_stmt|;
if|if
condition|(
name|tfd
operator|<
literal|0
operator|||
if|#
directive|if
operator|!
name|SM_OPEN_EXLOCK
operator|!
name|lockfile
argument_list|(
name|tfd
argument_list|,
name|tf
argument_list|,
name|NULL
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
operator|||
endif|#
directive|endif
comment|/* !SM_OPEN_EXLOCK */
operator|(
name|tfp
operator|=
name|sm_io_open
argument_list|(
name|SmFtStdiofd
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|tfd
argument_list|,
name|SM_IO_WRONLY
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|printopenfds
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
name|syserr
argument_list|(
literal|"!queueup: cannot create queue file %s, euid=%d, fd=%d, fp=%p"
argument_list|,
name|tf
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|,
name|tfd
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|e
operator|->
name|e_lockfp
operator|=
name|tfp
expr_stmt|;
name|upd_qs
argument_list|(
name|e
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"queueup"
argument_list|)
expr_stmt|;
block|}
comment|/* if newid, write the queue file directly (instead of temp file) */
if|if
condition|(
operator|!
name|newid
condition|)
block|{
comment|/* get a locked tf file */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tfd
operator|<
literal|0
condition|)
block|{
name|OPEN_TF
expr_stmt|;
if|if
condition|(
name|tfd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
break|break;
if|if
condition|(
name|LogLevel
operator|>
literal|0
operator|&&
operator|(
name|i
operator|%
literal|32
operator|)
operator|==
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ALERT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"queueup: cannot create %s, uid=%d: %s"
argument_list|,
name|tf
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|SM_OPEN_EXLOCK
else|else
break|break;
endif|#
directive|endif
comment|/* SM_OPEN_EXLOCK */
block|}
if|if
condition|(
name|tfd
operator|>=
literal|0
condition|)
block|{
if|#
directive|if
name|SM_OPEN_EXLOCK
comment|/* file is locked by open() */
break|break;
else|#
directive|else
comment|/* SM_OPEN_EXLOCK */
if|if
condition|(
name|lockfile
argument_list|(
name|tfd
argument_list|,
name|tf
argument_list|,
name|NULL
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
condition|)
break|break;
elseif|else
endif|#
directive|endif
comment|/* SM_OPEN_EXLOCK */
if|if
condition|(
name|LogLevel
operator|>
literal|0
operator|&&
operator|(
name|i
operator|%
literal|32
operator|)
operator|==
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ALERT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"queueup: cannot lock %s: %s"
argument_list|,
name|tf
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|%
literal|32
operator|)
operator|==
literal|31
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|tfd
argument_list|)
expr_stmt|;
name|tfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|i
operator|%
literal|32
operator|)
operator|==
literal|31
condition|)
block|{
comment|/* save the old temp file away */
operator|(
name|void
operator|)
name|rename
argument_list|(
name|tf
argument_list|,
name|queuename
argument_list|(
name|e
argument_list|,
name|TEMPQF_LETTER
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|sleep
argument_list|(
name|i
operator|%
literal|32
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tfd
operator|<
literal|0
operator|||
operator|(
name|tfp
operator|=
name|sm_io_open
argument_list|(
name|SmFtStdiofd
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|tfd
argument_list|,
name|SM_IO_WRONLY_B
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|printopenfds
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
name|syserr
argument_list|(
literal|"!queueup: cannot create queue temp file %s, uid=%d"
argument_list|,
name|tf
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"\n>>>>> queueing %s/%s%s>>>>>\n"
argument_list|,
name|qid_printqueue
argument_list|(
name|e
operator|->
name|e_qgrp
argument_list|,
name|e
operator|->
name|e_qdir
argument_list|)
argument_list|,
name|queuename
argument_list|(
name|e
argument_list|,
name|ANYQFL_LETTER
argument_list|)
argument_list|,
name|newid
condition|?
literal|" (new id)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"  e_flags="
argument_list|)
expr_stmt|;
name|printenvflags
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|32
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"  sendq="
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|e
operator|->
name|e_sendqueue
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|9
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"  tfp="
argument_list|)
expr_stmt|;
name|dumpfd
argument_list|(
name|sm_io_getinfo
argument_list|(
name|tfp
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"  lockfp="
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_lockfp
operator|==
name|NULL
condition|)
name|sm_dprintf
argument_list|(
literal|"NULL\n"
argument_list|)
expr_stmt|;
else|else
name|dumpfd
argument_list|(
name|sm_io_getinfo
argument_list|(
name|e
operator|->
name|e_lockfp
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  If there is no data file yet, create one. 	*/
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|df
argument_list|,
name|queuename
argument_list|(
name|e
argument_list|,
name|DATAFL_LETTER
argument_list|)
argument_list|,
sizeof|sizeof
name|df
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|EF_HAS_DF
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|!=
name|NULL
operator|&&
name|SuperSafe
operator|!=
name|SAFE_REALLY
operator|&&
name|SuperSafe
operator|!=
name|SAFE_REALLY_POSTMILTER
operator|&&
name|sm_io_setinfo
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
name|SM_BF_COMMIT
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINVAL
condition|)
block|{
name|syserr
argument_list|(
literal|"!queueup: cannot commit data file %s, uid=%d"
argument_list|,
name|queuename
argument_list|(
name|e
argument_list|,
name|DATAFL_LETTER
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|!=
name|NULL
operator|&&
name|SuperSafe
operator|==
name|SAFE_INTERACTIVE
operator|&&
name|msync
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|32
argument_list|)
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"queueup: fsync(e->e_dfp)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsync
argument_list|(
name|sm_io_getinfo
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|newid
condition|)
name|syserr
argument_list|(
literal|"!552 Error writing data file %s"
argument_list|,
name|df
argument_list|)
expr_stmt|;
else|else
name|syserr
argument_list|(
literal|"!452 Error writing data file %s"
argument_list|,
name|df
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|int
name|dfd
decl_stmt|;
name|MODE_T
name|oldumask
init|=
literal|0
decl_stmt|;
specifier|register
name|SM_FILE_T
modifier|*
name|dfp
init|=
name|NULL
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|!=
name|NULL
operator|&&
name|sm_io_getinfo
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
name|SM_IO_WHAT_ISTYPE
argument_list|,
name|BF_FILE_TYPE
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"committing over bf file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|S_IWGRP
argument_list|,
name|QueueFileMode
argument_list|)
condition|)
name|oldumask
operator|=
name|umask
argument_list|(
literal|002
argument_list|)
expr_stmt|;
name|dfd
operator|=
name|open
argument_list|(
name|df
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|QF_O_EXTRA
argument_list|,
name|QueueFileMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|S_IWGRP
argument_list|,
name|QueueFileMode
argument_list|)
condition|)
operator|(
name|void
operator|)
name|umask
argument_list|(
name|oldumask
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfd
operator|<
literal|0
operator|||
operator|(
name|dfp
operator|=
name|sm_io_open
argument_list|(
name|SmFtStdiofd
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|dfd
argument_list|,
name|SM_IO_WRONLY_B
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"!queueup: cannot create data temp file %s, uid=%d"
argument_list|,
name|df
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|dfd
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|<
literal|0
condition|)
name|e
operator|->
name|e_dfino
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|e
operator|->
name|e_dfdev
operator|=
name|stbuf
operator|.
name|st_dev
expr_stmt|;
name|e
operator|->
name|e_dfino
operator|=
name|ST_INODE
argument_list|(
name|stbuf
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|e_flags
operator||=
name|EF_HAS_DF
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mcibuf
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|mcibuf
argument_list|)
expr_stmt|;
name|mcibuf
operator|.
name|mci_out
operator|=
name|dfp
expr_stmt|;
name|mcibuf
operator|.
name|mci_mailer
operator|=
name|FileMailer
expr_stmt|;
call|(
modifier|*
name|e
operator|->
name|e_putbody
call|)
argument_list|(
operator|&
name|mcibuf
argument_list|,
name|e
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|SuperSafe
operator|==
name|SAFE_REALLY
operator|||
name|SuperSafe
operator|==
name|SAFE_REALLY_POSTMILTER
operator|||
operator|(
name|SuperSafe
operator|==
name|SAFE_INTERACTIVE
operator|&&
name|msync
operator|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|32
argument_list|)
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"queueup: fsync(dfp)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsync
argument_list|(
name|sm_io_getinfo
argument_list|(
name|dfp
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|newid
condition|)
name|syserr
argument_list|(
literal|"!552 Error writing data file %s"
argument_list|,
name|df
argument_list|)
expr_stmt|;
else|else
name|syserr
argument_list|(
literal|"!452 Error writing data file %s"
argument_list|,
name|df
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sm_io_close
argument_list|(
name|dfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"!queueup: cannot save data temp file %s, uid=%d"
argument_list|,
name|df
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_putbody
operator|=
name|putbody
expr_stmt|;
block|}
comment|/* 	**  Output future work requests. 	**	Priority and creation time should be first, since 	**	they are required by gatherq. 	*/
comment|/* output queue version number (must be first!) */
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"V%d\n"
argument_list|,
name|QF_VERSION
argument_list|)
expr_stmt|;
comment|/* output creation time */
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"T%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|e
operator|->
name|e_ctime
argument_list|)
expr_stmt|;
comment|/* output last delivery time */
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"K%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|e
operator|->
name|e_dtime
argument_list|)
expr_stmt|;
comment|/* output number of delivery attempts */
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"N%d\n"
argument_list|,
name|e
operator|->
name|e_ntries
argument_list|)
expr_stmt|;
comment|/* output message priority */
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"P%ld\n"
argument_list|,
name|e
operator|->
name|e_msgpriority
argument_list|)
expr_stmt|;
comment|/* 	**  If data file is in a different directory than the queue file, 	**  output a "d" record naming the directory of the data file. 	*/
if|if
condition|(
name|e
operator|->
name|e_dfqgrp
operator|!=
name|e
operator|->
name|e_qgrp
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"d%s\n"
argument_list|,
name|Queue
index|[
name|e
operator|->
name|e_dfqgrp
index|]
operator|->
name|qg_qpaths
index|[
name|e
operator|->
name|e_dfqdir
index|]
operator|.
name|qp_name
argument_list|)
expr_stmt|;
block|}
comment|/* output inode number of data file */
comment|/* XXX should probably include device major/minor too */
if|if
condition|(
name|e
operator|->
name|e_dfino
operator|!=
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"I%ld/%ld/%llu\n"
argument_list|,
operator|(
name|long
operator|)
name|major
argument_list|(
name|e
operator|->
name|e_dfdev
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|minor
argument_list|(
name|e
operator|->
name|e_dfdev
argument_list|)
argument_list|,
operator|(
name|ULONGLONG_T
operator|)
name|e
operator|->
name|e_dfino
argument_list|)
expr_stmt|;
block|}
comment|/* output body type */
if|if
condition|(
name|e
operator|->
name|e_bodytype
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"B%s\n"
argument_list|,
name|denlstring
argument_list|(
name|e
operator|->
name|e_bodytype
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
comment|/* quarantine reason */
if|if
condition|(
name|e
operator|->
name|e_quarmsg
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"q%s\n"
argument_list|,
name|denlstring
argument_list|(
name|e
operator|->
name|e_quarmsg
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
comment|/* message from envelope, if it exists */
if|if
condition|(
name|e
operator|->
name|e_message
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"M%s\n"
argument_list|,
name|denlstring
argument_list|(
name|e
operator|->
name|e_message
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
comment|/* send various flag bits through */
name|p
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|EF_WARNING
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
literal|'w'
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|EF_RESPONSE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
literal|'r'
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|EF_HAS8BIT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
literal|'8'
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|EF_DELETE_BCC
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
literal|'b'
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|EF_RET_PARAM
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
literal|'d'
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|EF_NO_BODY_RETN
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
literal|'n'
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|EF_SPLIT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
literal|'s'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"F%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* save $={persistentMacros} macro values */
name|queueup_macros
argument_list|(
name|macid
argument_list|(
literal|"{persistentMacros}"
argument_list|)
argument_list|,
name|tfp
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* output name of sender */
if|if
condition|(
name|bitnset
argument_list|(
name|M_UDBENVELOPE
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|->
name|m_flags
argument_list|)
condition|)
name|p
operator|=
name|e
operator|->
name|e_sender
expr_stmt|;
else|else
name|p
operator|=
name|e
operator|->
name|e_from
operator|.
name|q_paddr
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"S%s\n"
argument_list|,
name|denlstring
argument_list|(
name|p
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
comment|/* output ESMTP-supplied "original" information */
if|if
condition|(
name|e
operator|->
name|e_envid
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Z%s\n"
argument_list|,
name|denlstring
argument_list|(
name|e
operator|->
name|e_envid
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
comment|/* output AUTH= parameter */
if|if
condition|(
name|e
operator|->
name|e_auth_param
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"A%s\n"
argument_list|,
name|denlstring
argument_list|(
name|e
operator|->
name|e_auth_param
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_dlvr_flag
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"!%c %ld\n"
argument_list|,
operator|(
name|char
operator|)
name|e
operator|->
name|e_dlvr_flag
argument_list|,
name|e
operator|->
name|e_deliver_by
argument_list|)
expr_stmt|;
comment|/* output list of recipient addresses */
name|printctladdr
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
operator|!
name|QS_IS_UNDELIVERED
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
condition|)
continue|continue;
comment|/* message for this recipient, if it exists */
if|if
condition|(
name|q
operator|->
name|q_message
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"M%s\n"
argument_list|,
name|denlstring
argument_list|(
name|q
operator|->
name|q_message
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
name|printctladdr
argument_list|(
name|q
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|q_orcpt
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Q%s\n"
argument_list|,
name|denlstring
argument_list|(
name|q
operator|->
name|q_orcpt
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|q_finalrcpt
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"r%s\n"
argument_list|,
name|denlstring
argument_list|(
name|q
operator|->
name|q_finalrcpt
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|'R'
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|QPRIMARY
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|'P'
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|QHASNOTIFY
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|'N'
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|QPINGONSUCCESS
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|'S'
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|QPINGONFAILURE
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|'F'
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|QPINGONDELAY
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|'D'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|q_alias
operator|!=
name|NULL
operator|&&
name|bitset
argument_list|(
name|QALIAS
argument_list|,
name|q
operator|->
name|q_alias
operator|->
name|q_flags
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|'A'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s\n"
argument_list|,
name|denlstring
argument_list|(
name|q
operator|->
name|q_paddr
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|announce
condition|)
block|{
name|char
modifier|*
name|tag
init|=
literal|"queued"
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|e_quarmsg
operator|!=
name|NULL
condition|)
name|tag
operator|=
literal|"quarantined"
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|q
operator|->
name|q_paddr
expr_stmt|;
name|message
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|logdelivery
argument_list|(
name|q
operator|->
name|q_mailer
argument_list|,
name|NULL
argument_list|,
name|q
operator|->
name|q_status
argument_list|,
name|tag
argument_list|,
name|NULL
argument_list|,
operator|(
name|time_t
operator|)
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"queueing "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|q
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	**  Output headers for this message. 	**	Expand macros completely here.  Queue run will deal with 	**	everything as absolute headers. 	**		All headers that must be relative to the recipient 	**		can be cracked later. 	**	We set up a "null mailer" -- i.e., a mailer that will have 	**	no effect on the addresses as they are output. 	*/
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|nullmailer
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|nullmailer
argument_list|)
expr_stmt|;
name|nullmailer
operator|.
name|m_re_rwset
operator|=
name|nullmailer
operator|.
name|m_rh_rwset
operator|=
name|nullmailer
operator|.
name|m_se_rwset
operator|=
name|nullmailer
operator|.
name|m_sh_rwset
operator|=
operator|-
literal|1
expr_stmt|;
name|nullmailer
operator|.
name|m_eol
operator|=
literal|"\n"
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mcibuf
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|mcibuf
argument_list|)
expr_stmt|;
name|mcibuf
operator|.
name|mci_mailer
operator|=
operator|&
name|nullmailer
expr_stmt|;
name|mcibuf
operator|.
name|mci_out
operator|=
name|tfp
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'g'
argument_list|,
literal|"\201f"
argument_list|)
expr_stmt|;
for|for
control|(
name|h
operator|=
name|e
operator|->
name|e_header
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|h_link
control|)
block|{
if|if
condition|(
name|h
operator|->
name|h_value
operator|==
name|NULL
condition|)
continue|continue;
comment|/* don't output resent headers on non-resent messages */
if|if
condition|(
name|bitset
argument_list|(
name|H_RESENT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_RESENT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
continue|continue;
comment|/* expand macros; if null, don't output header at all */
if|if
condition|(
name|bitset
argument_list|(
name|H_DEFAULT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|expand
argument_list|(
name|h
operator|->
name|h_value
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
block|}
comment|/* output this header */
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"H?"
argument_list|)
expr_stmt|;
comment|/* output conditional macro if present */
if|if
condition|(
name|h
operator|->
name|h_macro
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|bitset
argument_list|(
literal|0200
argument_list|,
name|h
operator|->
name|h_macro
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"${%s}"
argument_list|,
name|macname
argument_list|(
name|bitidx
argument_list|(
name|h
operator|->
name|h_macro
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"$%c"
argument_list|,
name|h
operator|->
name|h_macro
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|bitzerop
argument_list|(
name|h
operator|->
name|h_mflags
argument_list|)
operator|&&
name|bitset
argument_list|(
name|H_CHECK
operator||
name|H_ACHECK
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
comment|/* if conditional, output the set of conditions */
for|for
control|(
name|j
operator|=
literal|'\0'
init|;
name|j
operator|<=
literal|'\177'
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|bitnset
argument_list|(
name|j
argument_list|,
name|h
operator|->
name|h_mflags
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|'?'
argument_list|)
expr_stmt|;
comment|/* output the header: expand macros, convert addresses */
if|if
condition|(
name|bitset
argument_list|(
name|H_DEFAULT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|H_BINDLATE
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|h
operator|->
name|h_field
argument_list|,
name|denlstring
argument_list|(
name|buf
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|H_FROM
operator||
name|H_RCPT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|H_BINDLATE
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
block|{
name|bool
name|oldstyle
init|=
name|bitset
argument_list|(
name|EF_OLDSTYLE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
decl_stmt|;
name|SM_FILE_T
modifier|*
name|savetrace
init|=
name|TrafficLogFile
decl_stmt|;
name|TrafficLogFile
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|H_FROM
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
name|oldstyle
operator|=
name|false
expr_stmt|;
name|commaize
argument_list|(
name|h
argument_list|,
name|h
operator|->
name|h_value
argument_list|,
name|oldstyle
argument_list|,
operator|&
name|mcibuf
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|TrafficLogFile
operator|=
name|savetrace
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|h
operator|->
name|h_field
argument_list|,
name|denlstring
argument_list|(
name|h
operator|->
name|h_value
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	**  Clean up. 	** 	**	Write a terminator record -- this is to prevent 	**	scurrilous crackers from appending any data. 	*/
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm_io_flush
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|SuperSafe
operator|==
name|SAFE_REALLY
operator|||
name|SuperSafe
operator|==
name|SAFE_REALLY_POSTMILTER
operator|||
operator|(
name|SuperSafe
operator|==
name|SAFE_INTERACTIVE
operator|&&
name|msync
operator|)
operator|)
operator|&&
name|fsync
argument_list|(
name|sm_io_getinfo
argument_list|(
name|tfp
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
operator|||
name|sm_io_error
argument_list|(
name|tfp
argument_list|)
condition|)
block|{
if|if
condition|(
name|newid
condition|)
name|syserr
argument_list|(
literal|"!552 Error writing control file %s"
argument_list|,
name|tf
argument_list|)
expr_stmt|;
else|else
name|syserr
argument_list|(
literal|"!452 Error writing control file %s"
argument_list|,
name|tf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|newid
condition|)
block|{
name|char
name|new
init|=
name|queue_letter
argument_list|(
name|e
argument_list|,
name|ANYQFL_LETTER
argument_list|)
decl_stmt|;
comment|/* rename (locked) tf to be (locked) [qh]f */
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|qf
argument_list|,
name|queuename
argument_list|(
name|e
argument_list|,
name|ANYQFL_LETTER
argument_list|)
argument_list|,
sizeof|sizeof
name|qf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|tf
argument_list|,
name|qf
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"cannot rename(%s, %s), uid=%d"
argument_list|,
name|tf
argument_list|,
name|qf
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 			**  Check if type has changed and only 			**  remove the old item if the rename above 			**  succeeded. 			*/
if|if
condition|(
name|e
operator|->
name|e_qfletter
operator|!=
literal|'\0'
operator|&&
name|e
operator|->
name|e_qfletter
operator|!=
name|new
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"type changed from %c to %c\n"
argument_list|,
name|e
operator|->
name|e_qfletter
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unlink
argument_list|(
name|queuename
argument_list|(
name|e
argument_list|,
name|e
operator|->
name|e_qfletter
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* XXX: something more drastic? */
if|if
condition|(
name|LogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"queueup: unlink(%s) failed: %s"
argument_list|,
name|queuename
argument_list|(
name|e
argument_list|,
name|e
operator|->
name|e_qfletter
argument_list|)
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|e
operator|->
name|e_qfletter
operator|=
name|new
expr_stmt|;
comment|/* 		**  fsync() after renaming to make sure metadata is 		**  written to disk on filesystems in which renames are 		**  not guaranteed. 		*/
if|if
condition|(
name|SuperSafe
operator|!=
name|SAFE_NO
condition|)
block|{
comment|/* for softupdates */
if|if
condition|(
name|tfd
operator|>=
literal|0
operator|&&
name|fsync
argument_list|(
name|tfd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"!queueup: cannot fsync queue temp file %s"
argument_list|,
name|tf
argument_list|)
expr_stmt|;
block|}
name|SYNC_DIR
argument_list|(
name|qf
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
comment|/* close and unlock old (locked) queue file */
if|if
condition|(
name|e
operator|->
name|e_lockfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|e
operator|->
name|e_lockfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_lockfp
operator|=
name|tfp
expr_stmt|;
comment|/* save log info */
if|if
condition|(
name|LogLevel
operator|>
literal|79
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"queueup %s"
argument_list|,
name|qf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* save log info */
if|if
condition|(
name|LogLevel
operator|>
literal|79
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"queueup %s"
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_qfletter
operator|=
name|queue_letter
argument_list|(
name|e
argument_list|,
name|ANYQFL_LETTER
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_INQUEUE
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"<<<<< done queueing %s<<<<<\n\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* **  PRINTCTLADDR -- print control address to file. ** **	Parameters: **		a -- address. **		tfp -- file pointer. ** **	Returns: **		none. ** **	Side Effects: **		The control address (if changed) is printed to the file. **		The last control address and uid are saved. */
end_comment

begin_function
specifier|static
name|void
name|printctladdr
parameter_list|(
name|a
parameter_list|,
name|tfp
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
name|SM_FILE_T
modifier|*
name|tfp
decl_stmt|;
block|{
name|char
modifier|*
name|user
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
specifier|static
name|ADDRESS
modifier|*
name|lastctladdr
init|=
name|NULL
decl_stmt|;
specifier|static
name|uid_t
name|lastuid
decl_stmt|;
comment|/* initialization */
if|if
condition|(
name|a
operator|==
name|NULL
operator|||
name|a
operator|->
name|q_alias
operator|==
name|NULL
operator|||
name|tfp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|lastctladdr
operator|!=
name|NULL
operator|&&
name|tfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"C\n"
argument_list|)
expr_stmt|;
name|lastctladdr
operator|=
name|NULL
expr_stmt|;
name|lastuid
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* find the active uid */
name|q
operator|=
name|getctladdr
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
name|user
operator|=
name|NULL
expr_stmt|;
name|uid
operator|=
literal|0
expr_stmt|;
name|gid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|user
operator|=
name|q
operator|->
name|q_ruser
operator|!=
name|NULL
condition|?
name|q
operator|->
name|q_ruser
else|:
name|q
operator|->
name|q_user
expr_stmt|;
name|uid
operator|=
name|q
operator|->
name|q_uid
expr_stmt|;
name|gid
operator|=
name|q
operator|->
name|q_gid
expr_stmt|;
block|}
name|a
operator|=
name|a
operator|->
name|q_alias
expr_stmt|;
comment|/* check to see if this is the same as last time */
if|if
condition|(
name|lastctladdr
operator|!=
name|NULL
operator|&&
name|uid
operator|==
name|lastuid
operator|&&
name|strcmp
argument_list|(
name|lastctladdr
operator|->
name|q_paddr
argument_list|,
name|a
operator|->
name|q_paddr
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|lastuid
operator|=
name|uid
expr_stmt|;
name|lastctladdr
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|uid
operator|==
literal|0
operator|||
name|user
operator|==
name|NULL
operator|||
name|user
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"C"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"C%s:%ld:%ld"
argument_list|,
name|denlstring
argument_list|(
name|user
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|uid
argument_list|,
operator|(
name|long
operator|)
name|gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|":%s\n"
argument_list|,
name|denlstring
argument_list|(
name|a
operator|->
name|q_paddr
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  RUNNERS_SIGTERM -- propagate a SIGTERM to queue runner process ** **	This propagates the signal to the child processes that are queue **	runners. This is for a queue runner "cleanup". After all of the **	child queue runner processes are signaled (it should be SIGTERM **	being the sig) then the old signal handler (Oldsh) is called **	to handle any cleanup set for this process (provided it is not **	SIG_DFL or SIG_IGN). The signal may not be handled immediately **	if the BlockOldsh flag is set. If the current process doesn't **	have a parent then handle the signal immediately, regardless of **	BlockOldsh. ** **	Parameters: **		sig -- the signal number being sent ** **	Returns: **		none. ** **	Side Effects: **		Sets the NoMoreRunners boolean to true to stop more runners **		from being started in runqueue(). ** **	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD **		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE **		DOING. */
end_comment

begin_decl_stmt
specifier|static
name|bool
specifier|volatile
name|NoMoreRunners
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sigfunc_t
name|Oldsh_term
init|=
name|SIG_DFL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sigfunc_t
name|Oldsh_hup
init|=
name|SIG_DFL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sigfunc_t
specifier|volatile
name|Oldsh
init|=
name|SIG_DFL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|BlockOldsh
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
specifier|volatile
name|Oldsig
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SIGFUNC_DECL
name|runners_sigterm
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SIGFUNC_DECL
name|runners_sighup
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|SIGFUNC_DECL
name|runners_sigterm
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|FIX_SYSV_SIGNAL
argument_list|(
name|sig
argument_list|,
name|runners_sigterm
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
name|CHECK_CRITICAL
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|NoMoreRunners
operator|=
name|true
expr_stmt|;
name|Oldsh
operator|=
name|Oldsh_term
expr_stmt|;
name|Oldsig
operator|=
name|sig
expr_stmt|;
name|proc_list_signal
argument_list|(
name|PROC_QUEUE
argument_list|,
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BlockOldsh
operator|||
name|getppid
argument_list|()
operator|<=
literal|1
condition|)
block|{
comment|/* Check that a valid 'old signal handler' is callable */
if|if
condition|(
name|Oldsh_term
operator|!=
name|SIG_DFL
operator|&&
name|Oldsh_term
operator|!=
name|SIG_IGN
operator|&&
name|Oldsh_term
operator|!=
name|runners_sigterm
condition|)
call|(
modifier|*
name|Oldsh_term
call|)
argument_list|(
name|sig
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
name|SIGFUNC_RETURN
return|;
block|}
end_function

begin_comment
comment|/* **  RUNNERS_SIGHUP -- propagate a SIGHUP to queue runner process ** **	This propagates the signal to the child processes that are queue **	runners. This is for a queue runner "cleanup". After all of the **	child queue runner processes are signaled (it should be SIGHUP **	being the sig) then the old signal handler (Oldsh) is called to **	handle any cleanup set for this process (provided it is not SIG_DFL **	or SIG_IGN). The signal may not be handled immediately if the **	BlockOldsh flag is set. If the current process doesn't have **	a parent then handle the signal immediately, regardless of **	BlockOldsh. ** **	Parameters: **		sig -- the signal number being sent ** **	Returns: **		none. ** **	Side Effects: **		Sets the NoMoreRunners boolean to true to stop more runners **		from being started in runqueue(). ** **	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD **		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE **		DOING. */
end_comment

begin_function
specifier|static
name|SIGFUNC_DECL
name|runners_sighup
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|FIX_SYSV_SIGNAL
argument_list|(
name|sig
argument_list|,
name|runners_sighup
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
name|CHECK_CRITICAL
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|NoMoreRunners
operator|=
name|true
expr_stmt|;
name|Oldsh
operator|=
name|Oldsh_hup
expr_stmt|;
name|Oldsig
operator|=
name|sig
expr_stmt|;
name|proc_list_signal
argument_list|(
name|PROC_QUEUE
argument_list|,
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BlockOldsh
operator|||
name|getppid
argument_list|()
operator|<=
literal|1
condition|)
block|{
comment|/* Check that a valid 'old signal handler' is callable */
if|if
condition|(
name|Oldsh_hup
operator|!=
name|SIG_DFL
operator|&&
name|Oldsh_hup
operator|!=
name|SIG_IGN
operator|&&
name|Oldsh_hup
operator|!=
name|runners_sighup
condition|)
call|(
modifier|*
name|Oldsh_hup
call|)
argument_list|(
name|sig
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
name|SIGFUNC_RETURN
return|;
block|}
end_function

begin_comment
comment|/* **  MARK_WORK_GROUP_RESTART -- mark a work group as needing a restart ** **  Sets a workgroup for restarting. ** **	Parameters: **		wgrp -- the work group id to restart. **		reason -- why (signal?), -1 to turn off restart ** **	Returns: **		none. ** **	Side effects: **		May set global RestartWorkGroup to true. ** **	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD **		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE **		DOING. */
end_comment

begin_function
name|void
name|mark_work_group_restart
parameter_list|(
name|wgrp
parameter_list|,
name|reason
parameter_list|)
name|int
name|wgrp
decl_stmt|;
name|int
name|reason
decl_stmt|;
block|{
if|if
condition|(
name|wgrp
operator|<
literal|0
operator|||
name|wgrp
operator|>
name|NumWorkGroups
condition|)
return|return;
name|WorkGrp
index|[
name|wgrp
index|]
operator|.
name|wg_restart
operator|=
name|reason
expr_stmt|;
if|if
condition|(
name|reason
operator|>=
literal|0
condition|)
name|RestartWorkGroup
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  RESTART_MARKED_WORK_GROUPS -- restart work groups marked as needing restart ** **  Restart any workgroup marked as needing a restart provided more **  runners are allowed. ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side effects: **		Sets global RestartWorkGroup to false. */
end_comment

begin_function
name|void
name|restart_marked_work_groups
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
name|wasblocked
decl_stmt|;
if|if
condition|(
name|NoMoreRunners
condition|)
return|return;
comment|/* Block SIGCHLD so reapchild() doesn't mess with us */
name|wasblocked
operator|=
name|sm_blocksignal
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NumWorkGroups
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|WorkGrp
index|[
name|i
index|]
operator|.
name|wg_restart
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"restart queue runner=%d due to signal 0x%x"
argument_list|,
name|i
argument_list|,
name|WorkGrp
index|[
name|i
index|]
operator|.
name|wg_restart
argument_list|)
expr_stmt|;
name|restart_work_group
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|RestartWorkGroup
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|wasblocked
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|sm_releasesignal
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  RESTART_WORK_GROUP -- restart a specific work group ** **  Restart a specific workgroup provided more runners are allowed. **  If the requested work group has been restarted too many times log **  this and refuse to restart. ** **	Parameters: **		wgrp -- the work group id to restart ** **	Returns: **		none. ** **	Side Effects: **		starts another process doing the work of wgrp */
end_comment

begin_define
define|#
directive|define
name|MAX_PERSIST_RESTART
value|10
end_define

begin_comment
comment|/* max allowed number of restarts */
end_comment

begin_function
specifier|static
name|void
name|restart_work_group
parameter_list|(
name|wgrp
parameter_list|)
name|int
name|wgrp
decl_stmt|;
block|{
if|if
condition|(
name|NoMoreRunners
operator|||
name|wgrp
operator|<
literal|0
operator|||
name|wgrp
operator|>
name|NumWorkGroups
condition|)
return|return;
name|WorkGrp
index|[
name|wgrp
index|]
operator|.
name|wg_restart
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|WorkGrp
index|[
name|wgrp
index|]
operator|.
name|wg_restartcnt
operator|<
name|MAX_PERSIST_RESTART
condition|)
block|{
comment|/* avoid overflow; increment here */
name|WorkGrp
index|[
name|wgrp
index|]
operator|.
name|wg_restartcnt
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|run_work_group
argument_list|(
name|wgrp
argument_list|,
name|RWG_FORK
operator||
name|RWG_PERSISTENT
operator||
name|RWG_RUNALL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"ERROR: persistent queue runner=%d restarted too many times, queue runner lost"
argument_list|,
name|wgrp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  SCHEDULE_QUEUE_RUNS -- schedule the next queue run for a work group. ** **	Parameters: **		runall -- schedule even if individual bit is not set. **		wgrp -- the work group id to schedule. **		didit -- the queue run was performed for this work group. ** **	Returns: **		nothing */
end_comment

begin_define
define|#
directive|define
name|INCR_MOD
parameter_list|(
name|v
parameter_list|,
name|m
parameter_list|)
value|if (++v>= m)	\ 				v = 0;	\ 			else
end_define

begin_function
specifier|static
name|void
name|schedule_queue_runs
parameter_list|(
name|runall
parameter_list|,
name|wgrp
parameter_list|,
name|didit
parameter_list|)
name|bool
name|runall
decl_stmt|;
name|int
name|wgrp
decl_stmt|;
name|bool
name|didit
decl_stmt|;
block|{
name|int
name|qgrp
decl_stmt|,
name|cgrp
decl_stmt|,
name|endgrp
decl_stmt|;
if|#
directive|if
name|_FFR_QUEUE_SCHED_DBG
name|time_t
name|lastsched
decl_stmt|;
name|bool
name|sched
decl_stmt|;
endif|#
directive|endif
comment|/* _FFR_QUEUE_SCHED_DBG */
name|time_t
name|now
decl_stmt|;
name|time_t
name|minqintvl
decl_stmt|;
comment|/* 	**  This is a bit ugly since we have to duplicate the 	**  code that "walks" through a work queue group. 	*/
name|now
operator|=
name|curtime
argument_list|()
expr_stmt|;
name|minqintvl
operator|=
literal|0
expr_stmt|;
name|cgrp
operator|=
name|endgrp
operator|=
name|WorkGrp
index|[
name|wgrp
index|]
operator|.
name|wg_curqgrp
expr_stmt|;
do|do
block|{
name|time_t
name|qintvl
decl_stmt|;
if|#
directive|if
name|_FFR_QUEUE_SCHED_DBG
name|lastsched
operator|=
literal|0
expr_stmt|;
name|sched
operator|=
name|false
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_QUEUE_SCHED_DBG */
name|qgrp
operator|=
name|WorkGrp
index|[
name|wgrp
index|]
operator|.
name|wg_qgs
index|[
name|cgrp
index|]
operator|->
name|qg_index
expr_stmt|;
if|if
condition|(
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_queueintvl
operator|>
literal|0
condition|)
name|qintvl
operator|=
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_queueintvl
expr_stmt|;
elseif|else
if|if
condition|(
name|QueueIntvl
operator|>
literal|0
condition|)
name|qintvl
operator|=
name|QueueIntvl
expr_stmt|;
else|else
name|qintvl
operator|=
operator|(
name|time_t
operator|)
literal|0
expr_stmt|;
if|#
directive|if
name|_FFR_QUEUE_SCHED_DBG
name|lastsched
operator|=
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_nextrun
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_QUEUE_SCHED_DBG */
if|if
condition|(
operator|(
name|runall
operator|||
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_nextrun
operator|<=
name|now
operator|)
operator|&&
name|qintvl
operator|>
literal|0
condition|)
block|{
if|#
directive|if
name|_FFR_QUEUE_SCHED_DBG
name|sched
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_QUEUE_SCHED_DBG */
if|if
condition|(
name|minqintvl
operator|==
literal|0
operator|||
name|qintvl
operator|<
name|minqintvl
condition|)
name|minqintvl
operator|=
name|qintvl
expr_stmt|;
comment|/* 			**  Only set a new time if a queue run was performed 			**  for this queue group.  If the queue was not run, 			**  we could starve it by setting a new time on each 			**  call. 			*/
if|if
condition|(
name|didit
condition|)
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_nextrun
operator|+=
name|qintvl
expr_stmt|;
block|}
if|#
directive|if
name|_FFR_QUEUE_SCHED_DBG
if|if
condition|(
name|tTd
argument_list|(
literal|69
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"sqr: wgrp=%d, cgrp=%d, qgrp=%d, intvl=%ld, QI=%ld, runall=%d, lastrun=%ld, nextrun=%ld, sched=%d"
argument_list|,
name|wgrp
argument_list|,
name|cgrp
argument_list|,
name|qgrp
argument_list|,
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_queueintvl
argument_list|,
name|QueueIntvl
argument_list|,
name|runall
argument_list|,
name|lastsched
argument_list|,
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_nextrun
argument_list|,
name|sched
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_QUEUE_SCHED_DBG */
name|INCR_MOD
argument_list|(
name|cgrp
argument_list|,
name|WorkGrp
index|[
name|wgrp
index|]
operator|.
name|wg_numqgrp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|endgrp
operator|!=
name|cgrp
condition|)
do|;
if|if
condition|(
name|minqintvl
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|sm_setevent
argument_list|(
name|minqintvl
argument_list|,
name|runqueueevent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|_FFR_QUEUE_RUN_PARANOIA
end_if

begin_comment
comment|/* **  CHECKQUEUERUNNER -- check whether a queue group hasn't been run. ** **	Use this if events may get lost and hence queue runners may not **	be started and mail will pile up in a queue. ** **	Parameters: **		none. ** **	Returns: **		true if a queue run is necessary. ** **	Side Effects: **		may schedule a queue run. */
end_comment

begin_function
name|bool
name|checkqueuerunner
parameter_list|()
block|{
name|int
name|qgrp
decl_stmt|;
name|time_t
name|now
decl_stmt|,
name|minqintvl
decl_stmt|;
name|now
operator|=
name|curtime
argument_list|()
expr_stmt|;
name|minqintvl
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|qgrp
operator|=
literal|0
init|;
name|qgrp
operator|<
name|NumQueue
operator|&&
name|Queue
index|[
name|qgrp
index|]
operator|!=
name|NULL
condition|;
name|qgrp
operator|++
control|)
block|{
name|time_t
name|qintvl
decl_stmt|;
if|if
condition|(
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_queueintvl
operator|>
literal|0
condition|)
name|qintvl
operator|=
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_queueintvl
expr_stmt|;
elseif|else
if|if
condition|(
name|QueueIntvl
operator|>
literal|0
condition|)
name|qintvl
operator|=
name|QueueIntvl
expr_stmt|;
else|else
name|qintvl
operator|=
operator|(
name|time_t
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_nextrun
operator|<=
name|now
operator|-
name|qintvl
condition|)
block|{
if|if
condition|(
name|minqintvl
operator|==
literal|0
operator|||
name|qintvl
operator|<
name|minqintvl
condition|)
name|minqintvl
operator|=
name|qintvl
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|1
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"checkqueuerunner: queue %d should have been run at %s, queue interval %ld"
argument_list|,
name|qgrp
argument_list|,
name|arpadate
argument_list|(
name|ctime
argument_list|(
operator|&
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_nextrun
argument_list|)
argument_list|)
argument_list|,
name|qintvl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|minqintvl
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sm_setevent
argument_list|(
name|minqintvl
argument_list|,
name|runqueueevent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_QUEUE_RUN_PARANOIA */
end_comment

begin_comment
comment|/* **  RUNQUEUE -- run the jobs in the queue. ** **	Gets the stuff out of the queue in some presumably logical **	order and processes them. ** **	Parameters: **		forkflag -- true if the queue scanning should be done in **			a child process.  We double-fork so it is not our **			child and we don't have to clean up after it. **			false can be ignored if we have multiple queues. **		verbose -- if true, print out status information. **		persistent -- persistent queue runner? **		runall -- run all groups or only a subset (DoQueueRun)? ** **	Returns: **		true if the queue run successfully began. ** **	Side Effects: **		runs things in the mail queue using run_work_group(). **		maybe schedules next queue run. */
end_comment

begin_decl_stmt
specifier|static
name|ENVELOPE
name|QueueEnvelope
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the queue run envelope */
end_comment

begin_decl_stmt
specifier|static
name|time_t
name|LastQueueTime
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last time a queue ID assigned */
end_comment

begin_decl_stmt
specifier|static
name|pid_t
name|LastQueuePid
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last PID which had a queue ID */
end_comment

begin_comment
comment|/* values for qp_supdirs */
end_comment

begin_define
define|#
directive|define
name|QP_NOSUB
value|0x0000
end_define

begin_comment
comment|/* No subdirectories */
end_comment

begin_define
define|#
directive|define
name|QP_SUBDF
value|0x0001
end_define

begin_comment
comment|/* "df" subdirectory */
end_comment

begin_define
define|#
directive|define
name|QP_SUBQF
value|0x0002
end_define

begin_comment
comment|/* "qf" subdirectory */
end_comment

begin_define
define|#
directive|define
name|QP_SUBXF
value|0x0004
end_define

begin_comment
comment|/* "xf" subdirectory */
end_comment

begin_function
name|bool
name|runqueue
parameter_list|(
name|forkflag
parameter_list|,
name|verbose
parameter_list|,
name|persistent
parameter_list|,
name|runall
parameter_list|)
name|bool
name|forkflag
decl_stmt|;
name|bool
name|verbose
decl_stmt|;
name|bool
name|persistent
decl_stmt|;
name|bool
name|runall
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|bool
name|ret
init|=
name|true
decl_stmt|;
specifier|static
name|int
name|curnum
init|=
literal|0
decl_stmt|;
name|sigfunc_t
name|cursh
decl_stmt|;
if|#
directive|if
name|SM_HEAP_CHECK
name|SM_NONVOLATILE
name|int
name|oldgroup
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sm_debug_active
argument_list|(
operator|&
name|DebugLeakQ
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|oldgroup
operator|=
name|sm_heap_group
argument_list|()
expr_stmt|;
name|sm_heap_newgroup
argument_list|()
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"runqueue() heap group #%d\n"
argument_list|,
name|sm_heap_group
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SM_HEAP_CHECK */
comment|/* queue run has been started, don't do any more this time */
name|DoQueueRun
operator|=
name|false
expr_stmt|;
comment|/* more than one queue or more than one directory per queue */
if|if
condition|(
operator|!
name|forkflag
operator|&&
operator|!
name|verbose
operator|&&
operator|(
name|WorkGrp
index|[
literal|0
index|]
operator|.
name|wg_qgs
index|[
literal|0
index|]
operator|->
name|qg_numqueues
operator|>
literal|1
operator|||
name|NumWorkGroups
operator|>
literal|1
operator|||
name|WorkGrp
index|[
literal|0
index|]
operator|.
name|wg_numqgrp
operator|>
literal|1
operator|)
condition|)
name|forkflag
operator|=
name|true
expr_stmt|;
comment|/* 	**  For controlling queue runners via signals sent to this process. 	**  Oldsh* will get called too by runners_sig* (if it is not SIG_IGN 	**  or SIG_DFL) to preserve cleanup behavior. Now that this process 	**  will have children (and perhaps grandchildren) this handler will 	**  be left in place. This is because this process, once it has 	**  finished spinning off queue runners, may go back to doing something 	**  else (like being a daemon). And we still want on a SIG{TERM,HUP} to 	**  clean up the child queue runners. Only install 'runners_sig*' once 	**  else we'll get stuck looping forever. 	*/
name|cursh
operator|=
name|sm_signal
argument_list|(
name|SIGTERM
argument_list|,
name|runners_sigterm
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursh
operator|!=
name|runners_sigterm
condition|)
name|Oldsh_term
operator|=
name|cursh
expr_stmt|;
name|cursh
operator|=
name|sm_signal
argument_list|(
name|SIGHUP
argument_list|,
name|runners_sighup
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursh
operator|!=
name|runners_sighup
condition|)
name|Oldsh_hup
operator|=
name|cursh
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NumWorkGroups
operator|&&
operator|!
name|NoMoreRunners
condition|;
name|i
operator|++
control|)
block|{
name|int
name|rwgflags
init|=
name|RWG_NONE
decl_stmt|;
comment|/* 		**  If MaxQueueChildren active then test whether the start 		**  of the next queue group's additional queue runners (maximum) 		**  will result in MaxQueueChildren being exceeded. 		** 		**  Note: do not use continue; even though another workgroup 		**	may have fewer queue runners, this would be "unfair", 		**	i.e., this work group might "starve" then. 		*/
if|#
directive|if
name|_FFR_QUEUE_SCHED_DBG
if|if
condition|(
name|tTd
argument_list|(
literal|69
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"rq: curnum=%d, MaxQueueChildren=%d, CurRunners=%d, WorkGrp[curnum].wg_maxact=%d"
argument_list|,
name|curnum
argument_list|,
name|MaxQueueChildren
argument_list|,
name|CurRunners
argument_list|,
name|WorkGrp
index|[
name|curnum
index|]
operator|.
name|wg_maxact
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_QUEUE_SCHED_DBG */
if|if
condition|(
name|MaxQueueChildren
operator|>
literal|0
operator|&&
name|CurRunners
operator|+
name|WorkGrp
index|[
name|curnum
index|]
operator|.
name|wg_maxact
operator|>
name|MaxQueueChildren
condition|)
break|break;
comment|/* 		**  Pick up where we left off (curnum), in case we 		**  used up all the children last time without finishing. 		**  This give a round-robin fairness to queue runs. 		** 		**  Increment CurRunners before calling run_work_group() 		**  to avoid a "race condition" with proc_list_drop() which 		**  decrements CurRunners if the queue runners terminate. 		**  Notice: CurRunners is an upper limit, in some cases 		**  (too few jobs in the queue) this value is larger than 		**  the actual number of queue runners. The discrepancy can 		**  increase if some queue runners "hang" for a long time. 		*/
name|CurRunners
operator|+=
name|WorkGrp
index|[
name|curnum
index|]
operator|.
name|wg_maxact
expr_stmt|;
if|if
condition|(
name|forkflag
condition|)
name|rwgflags
operator||=
name|RWG_FORK
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|rwgflags
operator||=
name|RWG_VERBOSE
expr_stmt|;
if|if
condition|(
name|persistent
condition|)
name|rwgflags
operator||=
name|RWG_PERSISTENT
expr_stmt|;
if|if
condition|(
name|runall
condition|)
name|rwgflags
operator||=
name|RWG_RUNALL
expr_stmt|;
name|ret
operator|=
name|run_work_group
argument_list|(
name|curnum
argument_list|,
name|rwgflags
argument_list|)
expr_stmt|;
comment|/* 		**  Failure means a message was printed for ETRN 		**  and subsequent queues are likely to fail as well. 		**  Decrement CurRunners in that case because 		**  none have been started. 		*/
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|CurRunners
operator|-=
name|WorkGrp
index|[
name|curnum
index|]
operator|.
name|wg_maxact
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|persistent
condition|)
name|schedule_queue_runs
argument_list|(
name|runall
argument_list|,
name|curnum
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|INCR_MOD
argument_list|(
name|curnum
argument_list|,
name|NumWorkGroups
argument_list|)
expr_stmt|;
block|}
comment|/* schedule left over queue runs */
if|if
condition|(
name|i
operator|<
name|NumWorkGroups
operator|&&
operator|!
name|NoMoreRunners
operator|&&
operator|!
name|persistent
condition|)
block|{
name|int
name|h
decl_stmt|;
for|for
control|(
name|h
operator|=
name|curnum
init|;
name|i
operator|<
name|NumWorkGroups
condition|;
name|i
operator|++
control|)
block|{
name|schedule_queue_runs
argument_list|(
name|runall
argument_list|,
name|h
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|INCR_MOD
argument_list|(
name|h
argument_list|,
name|NumWorkGroups
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|SM_HEAP_CHECK
if|if
condition|(
name|sm_debug_active
argument_list|(
operator|&
name|DebugLeakQ
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_heap_setgroup
argument_list|(
name|oldgroup
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SM_HEAP_CHECK */
return|return
name|ret
return|;
block|}
end_function

begin_if
if|#
directive|if
name|_FFR_SKIP_DOMAINS
end_if

begin_comment
comment|/* **  SKIP_DOMAINS -- Skip 'skip' number of domains in the WorkQ. ** **  Added by Stephen Frost<sfrost@snowman.net> to support **  having each runner process every N'th domain instead of **  every N'th message. ** **	Parameters: **		skip -- number of domains in WorkQ to skip. ** **	Returns: **		total number of messages skipped. ** **	Side Effects: **		may change WorkQ */
end_comment

begin_function
specifier|static
name|int
name|skip_domains
parameter_list|(
name|skip
parameter_list|)
name|int
name|skip
decl_stmt|;
block|{
name|int
name|n
decl_stmt|,
name|seqjump
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|seqjump
operator|=
literal|0
init|;
name|n
operator|<
name|skip
operator|&&
name|WorkQ
operator|!=
name|NULL
condition|;
name|seqjump
operator|++
control|)
block|{
if|if
condition|(
name|WorkQ
operator|->
name|w_next
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|WorkQ
operator|->
name|w_host
operator|!=
name|NULL
operator|&&
name|WorkQ
operator|->
name|w_next
operator|->
name|w_host
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|WorkQ
operator|->
name|w_host
argument_list|,
name|WorkQ
operator|->
name|w_next
operator|->
name|w_host
argument_list|)
operator|!=
literal|0
condition|)
name|n
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|WorkQ
operator|->
name|w_host
operator|!=
name|NULL
operator|&&
name|WorkQ
operator|->
name|w_next
operator|->
name|w_host
operator|==
name|NULL
operator|)
operator|||
operator|(
name|WorkQ
operator|->
name|w_host
operator|==
name|NULL
operator|&&
name|WorkQ
operator|->
name|w_next
operator|->
name|w_host
operator|!=
name|NULL
operator|)
condition|)
name|n
operator|++
expr_stmt|;
block|}
block|}
name|WorkQ
operator|=
name|WorkQ
operator|->
name|w_next
expr_stmt|;
block|}
return|return
name|seqjump
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_SKIP_DOMAINS */
end_comment

begin_comment
comment|/* **  RUNNER_WORK -- have a queue runner do its work ** **  Have a queue runner do its work a list of entries. **  When work isn't directly being done then this process can take a signal **  and terminate immediately (in a clean fashion of course). **  When work is directly being done, it's not to be interrupted **  immediately: the work should be allowed to finish at a clean point **  before termination (in a clean fashion of course). ** **	Parameters: **		e -- envelope. **		sequenceno -- 'th process to run WorkQ. **		didfork -- did the calling process fork()? **		skip -- process only each skip'th item. **		njobs -- number of jobs in WorkQ. ** **	Returns: **		none. ** **	Side Effects: **		runs things in the mail queue. */
end_comment

begin_function
specifier|static
name|void
name|runner_work
parameter_list|(
name|e
parameter_list|,
name|sequenceno
parameter_list|,
name|didfork
parameter_list|,
name|skip
parameter_list|,
name|njobs
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|int
name|sequenceno
decl_stmt|;
name|bool
name|didfork
decl_stmt|;
name|int
name|skip
decl_stmt|;
name|int
name|njobs
decl_stmt|;
block|{
name|int
name|n
decl_stmt|,
name|seqjump
decl_stmt|;
name|WORK
modifier|*
name|w
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|SM_GET_LA
argument_list|(
name|now
argument_list|)
expr_stmt|;
comment|/* 	**  Here we temporarily block the second calling of the handlers. 	**  This allows us to handle the signal without terminating in the 	**  middle of direct work. If a signal does come, the test for 	**  NoMoreRunners will find it. 	*/
name|BlockOldsh
operator|=
name|true
expr_stmt|;
name|seqjump
operator|=
name|skip
expr_stmt|;
comment|/* process them once at a time */
while|while
condition|(
name|WorkQ
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
name|SM_HEAP_CHECK
name|SM_NONVOLATILE
name|int
name|oldgroup
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sm_debug_active
argument_list|(
operator|&
name|DebugLeakQ
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|oldgroup
operator|=
name|sm_heap_group
argument_list|()
expr_stmt|;
name|sm_heap_newgroup
argument_list|()
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"run_queue_group() heap group #%d\n"
argument_list|,
name|sm_heap_group
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SM_HEAP_CHECK */
comment|/* do no more work */
if|if
condition|(
name|NoMoreRunners
condition|)
block|{
comment|/* Check that a valid signal handler is callable */
if|if
condition|(
name|Oldsh
operator|!=
name|SIG_DFL
operator|&&
name|Oldsh
operator|!=
name|SIG_IGN
operator|&&
name|Oldsh
operator|!=
name|runners_sighup
operator|&&
name|Oldsh
operator|!=
name|runners_sigterm
condition|)
call|(
modifier|*
name|Oldsh
call|)
argument_list|(
name|Oldsig
argument_list|)
expr_stmt|;
break|break;
block|}
name|w
operator|=
name|WorkQ
expr_stmt|;
comment|/* assign current work item */
comment|/* 		**  Set the head of the WorkQ to the next work item. 		**  It is set 'skip' ahead (the number of parallel queue 		**  runners working on WorkQ together) since each runner 		**  works on every 'skip'th (N-th) item. #if _FFR_SKIP_DOMAINS 		**  In the case of the BYHOST Queue Sort Order, the 'item' 		**  is a domain, so we work on every 'skip'th (N-th) domain. #endif * _FFR_SKIP_DOMAINS * 		*/
if|#
directive|if
name|_FFR_SKIP_DOMAINS
if|if
condition|(
name|QueueSortOrder
operator|==
name|QSO_BYHOST
condition|)
block|{
name|seqjump
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|WorkQ
operator|->
name|w_next
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|WorkQ
operator|->
name|w_host
operator|!=
name|NULL
operator|&&
name|WorkQ
operator|->
name|w_next
operator|->
name|w_host
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|WorkQ
operator|->
name|w_host
argument_list|,
name|WorkQ
operator|->
name|w_next
operator|->
name|w_host
argument_list|)
operator|!=
literal|0
condition|)
name|seqjump
operator|=
name|skip_domains
argument_list|(
name|skip
argument_list|)
expr_stmt|;
else|else
name|WorkQ
operator|=
name|WorkQ
operator|->
name|w_next
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|WorkQ
operator|->
name|w_host
operator|!=
name|NULL
operator|&&
name|WorkQ
operator|->
name|w_next
operator|->
name|w_host
operator|==
name|NULL
operator|)
operator|||
operator|(
name|WorkQ
operator|->
name|w_host
operator|==
name|NULL
operator|&&
name|WorkQ
operator|->
name|w_next
operator|->
name|w_host
operator|!=
name|NULL
operator|)
condition|)
name|seqjump
operator|=
name|skip_domains
argument_list|(
name|skip
argument_list|)
expr_stmt|;
else|else
name|WorkQ
operator|=
name|WorkQ
operator|->
name|w_next
expr_stmt|;
block|}
block|}
else|else
name|WorkQ
operator|=
name|WorkQ
operator|->
name|w_next
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* _FFR_SKIP_DOMAINS */
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|skip
operator|&&
name|WorkQ
operator|!=
name|NULL
condition|;
name|n
operator|++
control|)
name|WorkQ
operator|=
name|WorkQ
operator|->
name|w_next
expr_stmt|;
block|}
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
comment|/* 		**  Ignore jobs that are too expensive for the moment. 		** 		**	Get new load average every GET_NEW_LA_TIME seconds. 		*/
name|SM_GET_LA
argument_list|(
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldqueue
argument_list|(
name|WkRecipFact
argument_list|,
name|Current_LA_time
argument_list|)
condition|)
block|{
name|char
modifier|*
name|msg
init|=
literal|"Aborting queue run: load average too high"
decl_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|message
argument_list|(
literal|"%s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"runqueue: %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|shouldqueue
argument_list|(
name|w
operator|->
name|w_pri
argument_list|,
name|w
operator|->
name|w_ctime
argument_list|)
condition|)
block|{
if|if
condition|(
name|Verbose
condition|)
name|message
argument_list|(
name|EmptyString
argument_list|)
expr_stmt|;
if|if
condition|(
name|QueueSortOrder
operator|==
name|QSO_BYPRIORITY
condition|)
block|{
if|if
condition|(
name|Verbose
condition|)
name|message
argument_list|(
literal|"Skipping %s/%s (sequence %d of %d) and flushing rest of queue"
argument_list|,
name|qid_printqueue
argument_list|(
name|w
operator|->
name|w_qgrp
argument_list|,
name|w
operator|->
name|w_qdir
argument_list|)
argument_list|,
name|w
operator|->
name|w_name
operator|+
literal|2
argument_list|,
name|sequenceno
argument_list|,
name|njobs
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"runqueue: Flushing queue from %s/%s (pri %ld, LA %d, %d of %d)"
argument_list|,
name|qid_printqueue
argument_list|(
name|w
operator|->
name|w_qgrp
argument_list|,
name|w
operator|->
name|w_qdir
argument_list|)
argument_list|,
name|w
operator|->
name|w_name
operator|+
literal|2
argument_list|,
name|w
operator|->
name|w_pri
argument_list|,
name|CurrentLA
argument_list|,
name|sequenceno
argument_list|,
name|njobs
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|Verbose
condition|)
name|message
argument_list|(
literal|"Skipping %s/%s (sequence %d of %d)"
argument_list|,
name|qid_printqueue
argument_list|(
name|w
operator|->
name|w_qgrp
argument_list|,
name|w
operator|->
name|w_qdir
argument_list|)
argument_list|,
name|w
operator|->
name|w_name
operator|+
literal|2
argument_list|,
name|sequenceno
argument_list|,
name|njobs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Verbose
condition|)
block|{
name|message
argument_list|(
name|EmptyString
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"Running %s/%s (sequence %d of %d)"
argument_list|,
name|qid_printqueue
argument_list|(
name|w
operator|->
name|w_qgrp
argument_list|,
name|w
operator|->
name|w_qdir
argument_list|)
argument_list|,
name|w
operator|->
name|w_name
operator|+
literal|2
argument_list|,
name|sequenceno
argument_list|,
name|njobs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|didfork
operator|&&
name|MaxQueueChildren
operator|>
literal|0
condition|)
block|{
name|sm_blocksignal
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGCHLD
argument_list|,
name|reapchild
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|63
argument_list|,
literal|100
argument_list|)
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|NOQID
argument_list|,
literal|"runqueue %s dowork(%s)"
argument_list|,
name|qid_printqueue
argument_list|(
name|w
operator|->
name|w_qgrp
argument_list|,
name|w
operator|->
name|w_qdir
argument_list|)
argument_list|,
name|w
operator|->
name|w_name
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dowork
argument_list|(
name|w
operator|->
name|w_qgrp
argument_list|,
name|w
operator|->
name|w_qdir
argument_list|,
name|w
operator|->
name|w_name
operator|+
literal|2
argument_list|,
name|ForkQueueRuns
argument_list|,
name|false
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
name|sm_free
argument_list|(
name|w
operator|->
name|w_name
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|w
operator|->
name|w_host
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|w
operator|->
name|w_host
argument_list|)
expr_stmt|;
comment|/* XXX */
name|sm_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|w
argument_list|)
expr_stmt|;
comment|/* XXX */
name|sequenceno
operator|+=
name|seqjump
expr_stmt|;
comment|/* next sequence number */
if|#
directive|if
name|SM_HEAP_CHECK
if|if
condition|(
name|sm_debug_active
argument_list|(
operator|&
name|DebugLeakQ
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_heap_setgroup
argument_list|(
name|oldgroup
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SM_HEAP_CHECK */
block|}
name|BlockOldsh
operator|=
name|false
expr_stmt|;
comment|/* check the signals didn't happen during the revert */
if|if
condition|(
name|NoMoreRunners
condition|)
block|{
comment|/* Check that a valid signal handler is callable */
if|if
condition|(
name|Oldsh
operator|!=
name|SIG_DFL
operator|&&
name|Oldsh
operator|!=
name|SIG_IGN
operator|&&
name|Oldsh
operator|!=
name|runners_sighup
operator|&&
name|Oldsh
operator|!=
name|runners_sigterm
condition|)
call|(
modifier|*
name|Oldsh
call|)
argument_list|(
name|Oldsig
argument_list|)
expr_stmt|;
block|}
name|Oldsh
operator|=
name|SIG_DFL
expr_stmt|;
comment|/* after the NoMoreRunners check */
block|}
end_function

begin_comment
comment|/* **  RUN_WORK_GROUP -- run the jobs in a queue group from a work group. ** **	Gets the stuff out of the queue in some presumably logical **	order and processes them. ** **	Parameters: **		wgrp -- work group to process. **		flags -- RWG_* flags ** **	Returns: **		true if the queue run successfully began. ** **	Side Effects: **		runs things in the mail queue. */
end_comment

begin_comment
comment|/* Minimum sleep time for persistent queue runners */
end_comment

begin_define
define|#
directive|define
name|MIN_SLEEP_TIME
value|5
end_define

begin_function
name|bool
name|run_work_group
parameter_list|(
name|wgrp
parameter_list|,
name|flags
parameter_list|)
name|int
name|wgrp
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|int
name|njobs
decl_stmt|,
name|qdir
decl_stmt|;
name|int
name|sequenceno
init|=
literal|1
decl_stmt|;
name|int
name|qgrp
decl_stmt|,
name|endgrp
decl_stmt|,
name|h
decl_stmt|,
name|i
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|bool
name|full
decl_stmt|,
name|more
decl_stmt|;
name|SM_RPOOL_T
modifier|*
name|rpool
decl_stmt|;
specifier|extern
name|void
name|rmexpstab
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|ENVELOPE
name|BlankEnvelope
decl_stmt|;
specifier|extern
name|SIGFUNC_DECL
name|reapchild
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|wgrp
operator|<
literal|0
condition|)
return|return
name|false
return|;
comment|/* 	**  If no work will ever be selected, don't even bother reading 	**  the queue. 	*/
name|SM_GET_LA
argument_list|(
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|RWG_PERSISTENT
argument_list|,
name|flags
argument_list|)
operator|&&
name|shouldqueue
argument_list|(
name|WkRecipFact
argument_list|,
name|Current_LA_time
argument_list|)
condition|)
block|{
name|char
modifier|*
name|msg
init|=
literal|"Skipping queue run -- load average too high"
decl_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RWG_VERBOSE
argument_list|,
name|flags
argument_list|)
condition|)
name|message
argument_list|(
literal|"458 %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"runqueue: %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* 	**  See if we already have too many children. 	*/
if|if
condition|(
name|bitset
argument_list|(
name|RWG_FORK
argument_list|,
name|flags
argument_list|)
operator|&&
name|WorkGrp
index|[
name|wgrp
index|]
operator|.
name|wg_lowqintvl
operator|>
literal|0
operator|&&
operator|!
name|bitset
argument_list|(
name|RWG_PERSISTENT
argument_list|,
name|flags
argument_list|)
operator|&&
name|MaxChildren
operator|>
literal|0
operator|&&
name|CurChildren
operator|>=
name|MaxChildren
condition|)
block|{
name|char
modifier|*
name|msg
init|=
literal|"Skipping queue run -- too many children"
decl_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RWG_VERBOSE
argument_list|,
name|flags
argument_list|)
condition|)
name|message
argument_list|(
literal|"458 %s (%d)\n"
argument_list|,
name|msg
argument_list|,
name|CurChildren
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"runqueue: %s (%d)"
argument_list|,
name|msg
argument_list|,
name|CurChildren
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* 	**  See if we want to go off and do other useful work. 	*/
if|if
condition|(
name|bitset
argument_list|(
name|RWG_FORK
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|pid_t
name|pid
decl_stmt|;
operator|(
name|void
operator|)
name|sm_blocksignal
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGCHLD
argument_list|,
name|reapchild
argument_list|)
expr_stmt|;
name|pid
operator|=
name|dofork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
literal|"Skipping queue run -- fork() failed"
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
init|=
name|sm_errstring
argument_list|(
name|errno
argument_list|)
decl_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RWG_VERBOSE
argument_list|,
name|flags
argument_list|)
condition|)
name|message
argument_list|(
literal|"458 %s: %s\n"
argument_list|,
name|msg
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"runqueue: %s: %s"
argument_list|,
name|msg
argument_list|,
name|err
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_releasesignal
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|pid
operator|!=
literal|0
condition|)
block|{
comment|/* parent -- pick up intermediate zombie */
operator|(
name|void
operator|)
name|sm_blocksignal
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
comment|/* wgrp only used when queue runners are persistent */
name|proc_list_add
argument_list|(
name|pid
argument_list|,
literal|"Queue runner"
argument_list|,
name|PROC_QUEUE
argument_list|,
name|WorkGrp
index|[
name|wgrp
index|]
operator|.
name|wg_maxact
argument_list|,
name|bitset
argument_list|(
name|RWG_PERSISTENT
argument_list|,
name|flags
argument_list|)
condition|?
name|wgrp
else|:
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_releasesignal
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_releasesignal
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* child -- clean up signals */
comment|/* Reset global flags */
name|RestartRequest
operator|=
name|NULL
expr_stmt|;
name|RestartWorkGroup
operator|=
name|false
expr_stmt|;
name|ShutdownRequest
operator|=
name|NULL
expr_stmt|;
name|PendingSignal
operator|=
literal|0
expr_stmt|;
name|CurrentPid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|close_sendmail_pid
argument_list|()
expr_stmt|;
comment|/* 		**  Initialize exception stack and default exception 		**  handler for child process. 		*/
name|sm_exc_newthread
argument_list|(
name|fatal_error
argument_list|)
expr_stmt|;
name|clrcontrol
argument_list|()
expr_stmt|;
name|proc_list_clear
argument_list|()
expr_stmt|;
comment|/* Add parent process as first child item */
name|proc_list_add
argument_list|(
name|CurrentPid
argument_list|,
literal|"Queue runner child process"
argument_list|,
name|PROC_QUEUE_CHILD
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_releasesignal
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGTERM
argument_list|,
name|intsig
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Release any resources used by the daemon code. 	*/
name|clrdaemon
argument_list|()
expr_stmt|;
comment|/* force it to run expensive jobs */
name|NoConnect
operator|=
name|false
expr_stmt|;
comment|/* drop privileges */
if|if
condition|(
name|geteuid
argument_list|()
operator|==
operator|(
name|uid_t
operator|)
literal|0
condition|)
operator|(
name|void
operator|)
name|drop_privileges
argument_list|(
name|false
argument_list|)
expr_stmt|;
comment|/* 	**  Create ourselves an envelope 	*/
name|CurEnv
operator|=
operator|&
name|QueueEnvelope
expr_stmt|;
name|rpool
operator|=
name|sm_rpool_new_x
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|e
operator|=
name|newenvelope
argument_list|(
operator|&
name|QueueEnvelope
argument_list|,
name|CurEnv
argument_list|,
name|rpool
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator|=
name|BlankEnvelope
operator|.
name|e_flags
expr_stmt|;
name|e
operator|->
name|e_parent
operator|=
name|NULL
expr_stmt|;
comment|/* make sure we have disconnected from parent */
if|if
condition|(
name|bitset
argument_list|(
name|RWG_FORK
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|disconnect
argument_list|(
literal|1
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|QuickAbort
operator|=
name|false
expr_stmt|;
block|}
comment|/* 	**  If we are running part of the queue, always ignore stored 	**  host status. 	*/
if|if
condition|(
name|QueueLimitId
operator|!=
name|NULL
operator|||
name|QueueLimitSender
operator|!=
name|NULL
operator|||
name|QueueLimitQuarantine
operator|!=
name|NULL
operator|||
name|QueueLimitRecipient
operator|!=
name|NULL
condition|)
block|{
name|IgnoreHostStatus
operator|=
name|true
expr_stmt|;
name|MinQueueAge
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	**  Here is where we choose the queue group from the work group. 	**  The caller of the "domorework" label must setup a new envelope. 	*/
name|endgrp
operator|=
name|WorkGrp
index|[
name|wgrp
index|]
operator|.
name|wg_curqgrp
expr_stmt|;
comment|/* to not spin endlessly */
name|domorework
label|:
comment|/* 	**  Run a queue group if: 	**  RWG_RUNALL bit is set or the bit for this group is set. 	*/
name|now
operator|=
name|curtime
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		**  Find the next queue group within the work group that 		**  has been marked as needing a run. 		*/
name|qgrp
operator|=
name|WorkGrp
index|[
name|wgrp
index|]
operator|.
name|wg_qgs
index|[
name|WorkGrp
index|[
name|wgrp
index|]
operator|.
name|wg_curqgrp
index|]
operator|->
name|qg_index
expr_stmt|;
name|WorkGrp
index|[
name|wgrp
index|]
operator|.
name|wg_curqgrp
operator|++
expr_stmt|;
comment|/* advance */
name|WorkGrp
index|[
name|wgrp
index|]
operator|.
name|wg_curqgrp
operator|%=
name|WorkGrp
index|[
name|wgrp
index|]
operator|.
name|wg_numqgrp
expr_stmt|;
comment|/* wrap */
if|if
condition|(
name|bitset
argument_list|(
name|RWG_RUNALL
argument_list|,
name|flags
argument_list|)
operator|||
operator|(
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_nextrun
operator|<=
name|now
operator|&&
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_nextrun
operator|!=
operator|(
name|time_t
operator|)
operator|-
literal|1
operator|)
condition|)
break|break;
if|if
condition|(
name|endgrp
operator|==
name|WorkGrp
index|[
name|wgrp
index|]
operator|.
name|wg_curqgrp
condition|)
block|{
name|e
operator|->
name|e_id
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RWG_FORK
argument_list|,
name|flags
argument_list|)
condition|)
name|finis
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
return|return
name|true
return|;
comment|/* we're done */
block|}
block|}
name|qdir
operator|=
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_curnum
expr_stmt|;
comment|/* round-robin init of queue position */
if|#
directive|if
name|_FFR_QUEUE_SCHED_DBG
if|if
condition|(
name|tTd
argument_list|(
literal|69
argument_list|,
literal|12
argument_list|)
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"rwg: wgrp=%d, qgrp=%d, qdir=%d, name=%s, curqgrp=%d, numgrps=%d"
argument_list|,
name|wgrp
argument_list|,
name|qgrp
argument_list|,
name|qdir
argument_list|,
name|qid_printqueue
argument_list|(
name|qgrp
argument_list|,
name|qdir
argument_list|)
argument_list|,
name|WorkGrp
index|[
name|wgrp
index|]
operator|.
name|wg_curqgrp
argument_list|,
name|WorkGrp
index|[
name|wgrp
index|]
operator|.
name|wg_numqgrp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_QUEUE_SCHED_DBG */
if|#
directive|if
name|HASNICE
comment|/* tweak niceness of queue runs */
if|if
condition|(
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_nice
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|nice
argument_list|(
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_nice
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HASNICE */
comment|/* XXX running queue group... */
name|sm_setproctitle
argument_list|(
name|true
argument_list|,
name|CurEnv
argument_list|,
literal|"running queue: %s"
argument_list|,
name|qid_printqueue
argument_list|(
name|qgrp
argument_list|,
name|qdir
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|69
operator|||
name|tTd
argument_list|(
literal|63
argument_list|,
literal|99
argument_list|)
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|NOQID
argument_list|,
literal|"runqueue %s, pid=%d, forkflag=%d"
argument_list|,
name|qid_printqueue
argument_list|(
name|qgrp
argument_list|,
name|qdir
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|CurrentPid
argument_list|,
name|bitset
argument_list|(
name|RWG_FORK
argument_list|,
name|flags
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	**  Start making passes through the queue. 	**	First, read and sort the entire queue. 	**	Then, process the work in that order. 	**		But if you take too long, start over. 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_numqueues
condition|;
name|i
operator|++
control|)
block|{
name|h
operator|=
name|gatherq
argument_list|(
name|qgrp
argument_list|,
name|qdir
argument_list|,
name|false
argument_list|,
operator|&
name|full
argument_list|,
operator|&
name|more
argument_list|)
expr_stmt|;
if|#
directive|if
name|SM_CONF_SHM
if|if
condition|(
name|ShmId
operator|!=
name|SM_SHM_NO_ID
condition|)
name|QSHM_ENTRIES
argument_list|(
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_qpaths
index|[
name|qdir
index|]
operator|.
name|qp_idx
argument_list|)
operator|=
name|h
expr_stmt|;
endif|#
directive|endif
comment|/* SM_CONF_SHM */
comment|/* If there are no more items in this queue advance */
if|if
condition|(
operator|!
name|more
condition|)
block|{
comment|/* A round-robin advance */
name|qdir
operator|++
expr_stmt|;
name|qdir
operator|%=
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_numqueues
expr_stmt|;
block|}
comment|/* Has the WorkList reached the limit? */
if|if
condition|(
name|full
condition|)
break|break;
comment|/* don't try to gather more */
block|}
comment|/* order the existing work requests */
name|njobs
operator|=
name|sortq
argument_list|(
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_maxlist
argument_list|)
expr_stmt|;
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_curnum
operator|=
name|qdir
expr_stmt|;
comment|/* update */
if|if
condition|(
operator|!
name|Verbose
operator|&&
name|bitnset
argument_list|(
name|QD_FORK
argument_list|,
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_flags
argument_list|)
condition|)
block|{
name|int
name|loop
decl_stmt|,
name|maxrunners
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
comment|/* 		**  For this WorkQ we want to fork off N children (maxrunners) 		**  at this point. Each child has a copy of WorkQ. Each child 		**  will process every N-th item. The parent will wait for all 		**  of the children to finish before moving on to the next 		**  queue group within the work group. This saves us forking 		**  a new runner-child for each work item. 		**  It's valid for qg_maxqrun == 0 since this may be an 		**  explicit "don't run this queue" setting. 		*/
name|maxrunners
operator|=
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_maxqrun
expr_stmt|;
comment|/* No need to have more runners then there are jobs */
if|if
condition|(
name|maxrunners
operator|>
name|njobs
condition|)
name|maxrunners
operator|=
name|njobs
expr_stmt|;
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
name|maxrunners
condition|;
name|loop
operator|++
control|)
block|{
comment|/* 			**  Since the delivery may happen in a child and the 			**  parent does not wait, the parent may close the 			**  maps thereby removing any shared memory used by 			**  the map.  Therefore, close the maps now so the 			**  child will dynamically open them if necessary. 			*/
name|closemaps
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"run_work_group: cannot fork"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
block|{
comment|/* parent -- clean out connection cache */
name|mci_flush
argument_list|(
name|false
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
name|_FFR_SKIP_DOMAINS
if|if
condition|(
name|QueueSortOrder
operator|==
name|QSO_BYHOST
condition|)
block|{
name|sequenceno
operator|+=
name|skip_domains
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* _FFR_SKIP_DOMAINS */
block|{
comment|/* for the skip */
name|WorkQ
operator|=
name|WorkQ
operator|->
name|w_next
expr_stmt|;
name|sequenceno
operator|++
expr_stmt|;
block|}
name|proc_list_add
argument_list|(
name|pid
argument_list|,
literal|"Queue child runner process"
argument_list|,
name|PROC_QUEUE_CHILD
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* No additional work, no additional runners */
if|if
condition|(
name|WorkQ
operator|==
name|NULL
condition|)
break|break;
block|}
else|else
block|{
comment|/* child -- Reset global flags */
name|RestartRequest
operator|=
name|NULL
expr_stmt|;
name|RestartWorkGroup
operator|=
name|false
expr_stmt|;
name|ShutdownRequest
operator|=
name|NULL
expr_stmt|;
name|PendingSignal
operator|=
literal|0
expr_stmt|;
name|CurrentPid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|close_sendmail_pid
argument_list|()
expr_stmt|;
comment|/* 				**  Initialize exception stack and default 				**  exception handler for child process. 				**  When fork()'d the child now has a private 				**  copy of WorkQ at its current position. 				*/
name|sm_exc_newthread
argument_list|(
name|fatal_error
argument_list|)
expr_stmt|;
comment|/* 				**  SMTP processes (whether -bd or -bs) set 				**  SIGCHLD to reapchild to collect 				**  children status.  However, at delivery 				**  time, that status must be collected 				**  by sm_wait() to be dealt with properly 				**  (check success of delivery based 				**  on status code, etc).  Therefore, if we 				**  are an SMTP process, reset SIGCHLD 				**  back to the default so reapchild 				**  doesn't collect status before 				**  sm_wait(). 				*/
if|if
condition|(
name|OpMode
operator|==
name|MD_SMTP
operator|||
name|OpMode
operator|==
name|MD_DAEMON
operator|||
name|MaxQueueChildren
operator|>
literal|0
condition|)
block|{
name|proc_list_clear
argument_list|()
expr_stmt|;
name|sm_releasesignal
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
block|}
comment|/* child -- error messages to the transcript */
name|QuickAbort
operator|=
name|OnlyOneError
operator|=
name|false
expr_stmt|;
name|runner_work
argument_list|(
name|e
argument_list|,
name|sequenceno
argument_list|,
name|true
argument_list|,
name|maxrunners
argument_list|,
name|njobs
argument_list|)
expr_stmt|;
comment|/* This child is done */
name|finis
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
name|sm_releasesignal
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
comment|/* 		**  Wait until all of the runners have completed before 		**  seeing if there is another queue group in the 		**  work group to process. 		**  XXX Future enhancement: don't wait() for all children 		**  here, just go ahead and make sure that overall the number 		**  of children is not exceeded. 		*/
while|while
condition|(
name|CurChildren
operator|>
literal|0
condition|)
block|{
name|int
name|status
decl_stmt|;
name|pid_t
name|ret
decl_stmt|;
while|while
condition|(
operator|(
name|ret
operator|=
name|sm_wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|<=
literal|0
condition|)
continue|continue;
name|proc_list_drop
argument_list|(
name|ret
argument_list|,
name|status
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_maxqrun
operator|>
literal|0
operator|||
name|bitset
argument_list|(
name|RWG_FORCE
argument_list|,
name|flags
argument_list|)
condition|)
block|{
comment|/* 		**  When current process will not fork children to do the work, 		**  it will do the work itself. The 'skip' will be 1 since 		**  there are no child runners to divide the work across. 		*/
name|runner_work
argument_list|(
name|e
argument_list|,
name|sequenceno
argument_list|,
name|false
argument_list|,
literal|1
argument_list|,
name|njobs
argument_list|)
expr_stmt|;
block|}
comment|/* free memory allocated by newenvelope() above */
name|sm_rpool_free
argument_list|(
name|rpool
argument_list|)
expr_stmt|;
name|QueueEnvelope
operator|.
name|e_rpool
operator|=
name|NULL
expr_stmt|;
comment|/* Are there still more queues in the work group to process? */
if|if
condition|(
name|endgrp
operator|!=
name|WorkGrp
index|[
name|wgrp
index|]
operator|.
name|wg_curqgrp
condition|)
block|{
name|rpool
operator|=
name|sm_rpool_new_x
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|e
operator|=
name|newenvelope
argument_list|(
operator|&
name|QueueEnvelope
argument_list|,
name|CurEnv
argument_list|,
name|rpool
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator|=
name|BlankEnvelope
operator|.
name|e_flags
expr_stmt|;
goto|goto
name|domorework
goto|;
block|}
comment|/* No more queues in work group to process. Now check persistent. */
if|if
condition|(
name|bitset
argument_list|(
name|RWG_PERSISTENT
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|sequenceno
operator|=
literal|1
expr_stmt|;
name|sm_setproctitle
argument_list|(
name|true
argument_list|,
name|CurEnv
argument_list|,
literal|"running queue: %s"
argument_list|,
name|qid_printqueue
argument_list|(
name|qgrp
argument_list|,
name|qdir
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		**  close bogus maps, i.e., maps which caused a tempfail, 		**	so we get fresh map connections on the next lookup. 		**  closemaps() is also called when children are started. 		*/
name|closemaps
argument_list|(
name|true
argument_list|)
expr_stmt|;
comment|/* Close any cached connections. */
name|mci_flush
argument_list|(
name|true
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Clean out expired related entries. */
name|rmexpstab
argument_list|()
expr_stmt|;
if|#
directive|if
name|NAMED_BIND
comment|/* Update MX records for FallbackMX. */
if|if
condition|(
name|FallbackMX
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|getfallbackmxrr
argument_list|(
name|FallbackMX
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NAMED_BIND */
if|#
directive|if
name|USERDB
comment|/* close UserDatabase */
name|_udbx_close
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* USERDB */
if|#
directive|if
name|SM_HEAP_CHECK
if|if
condition|(
name|sm_debug_active
argument_list|(
operator|&
name|SmHeapCheck
argument_list|,
literal|2
argument_list|)
operator|&&
name|access
argument_list|(
literal|"memdump"
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SM_FILE_T
modifier|*
name|out
decl_stmt|;
name|remove
argument_list|(
literal|"memdump"
argument_list|)
expr_stmt|;
name|out
operator|=
name|sm_io_open
argument_list|(
name|SmFtStdio
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"memdump.out"
argument_list|,
name|SM_IO_APPEND
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"----------------------\n"
argument_list|)
expr_stmt|;
name|sm_heap_report
argument_list|(
name|out
argument_list|,
name|sm_debug_level
argument_list|(
operator|&
name|SmHeapCheck
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SM_HEAP_CHECK */
comment|/* let me rest for a second to catch my breath */
if|if
condition|(
name|njobs
operator|==
literal|0
operator|&&
name|WorkGrp
index|[
name|wgrp
index|]
operator|.
name|wg_lowqintvl
operator|<
name|MIN_SLEEP_TIME
condition|)
name|sleep
argument_list|(
name|MIN_SLEEP_TIME
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WorkGrp
index|[
name|wgrp
index|]
operator|.
name|wg_lowqintvl
operator|<=
literal|0
condition|)
name|sleep
argument_list|(
name|QueueIntvl
operator|>
literal|0
condition|?
name|QueueIntvl
else|:
name|MIN_SLEEP_TIME
argument_list|)
expr_stmt|;
else|else
name|sleep
argument_list|(
name|WorkGrp
index|[
name|wgrp
index|]
operator|.
name|wg_lowqintvl
argument_list|)
expr_stmt|;
comment|/* 		**  Get the LA outside the WorkQ loop if necessary. 		**  In a persistent queue runner the code is repeated over 		**  and over but gatherq() may ignore entries due to 		**  shouldqueue() (do we really have to do this twice?). 		**  Hence the queue runners would just idle around when once 		**  CurrentLA caused all entries in a queue to be ignored. 		*/
if|if
condition|(
name|njobs
operator|==
literal|0
condition|)
name|SM_GET_LA
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|rpool
operator|=
name|sm_rpool_new_x
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|e
operator|=
name|newenvelope
argument_list|(
operator|&
name|QueueEnvelope
argument_list|,
name|CurEnv
argument_list|,
name|rpool
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator|=
name|BlankEnvelope
operator|.
name|e_flags
expr_stmt|;
goto|goto
name|domorework
goto|;
block|}
comment|/* exit without the usual cleanup */
name|e
operator|->
name|e_id
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RWG_FORK
argument_list|,
name|flags
argument_list|)
condition|)
name|finis
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* **  DOQUEUERUN -- do a queue run? */
end_comment

begin_function
name|bool
name|doqueuerun
parameter_list|()
block|{
return|return
name|DoQueueRun
return|;
block|}
end_function

begin_comment
comment|/* **  RUNQUEUEEVENT -- Sets a flag to indicate that a queue run should be done. ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		The invocation of this function via an alarm may interrupt **		a set of actions. Thus errno may be set in that context. **		We need to restore errno at the end of this function to ensure **		that any work done here that sets errno doesn't return a **		misleading/false errno value. Errno may	be EINTR upon entry to **		this function because of non-restartable/continuable system **		API was active. Iff this is true we will override errno as **		a timeout (as a more accurate error message). ** **	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD **		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE **		DOING. */
end_comment

begin_function
name|void
name|runqueueevent
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
comment|/* 	**  Set the general bit that we want a queue run, 	**  tested in doqueuerun() 	*/
name|DoQueueRun
operator|=
name|true
expr_stmt|;
if|#
directive|if
name|_FFR_QUEUE_SCHED_DBG
if|if
condition|(
name|tTd
argument_list|(
literal|69
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"rqe: done"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_QUEUE_SCHED_DBG */
name|errno
operator|=
name|save_errno
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
name|errno
operator|=
name|ETIMEDOUT
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  GATHERQ -- gather messages from the message queue(s) the work queue. ** **	Parameters: **		qgrp -- the index of the queue group. **		qdir -- the index of the queue directory. **		doall -- if set, include everything in the queue (even **			the jobs that cannot be run because the load **			average is too high, or MaxQueueRun is reached). **			Otherwise, exclude those jobs. **		full -- (optional) to be set 'true' if WorkList is full **		more -- (optional) to be set 'true' if there are still more **			messages in this queue not added to WorkList ** **	Returns: **		The number of request in the queue (not necessarily **		the number of requests in WorkList however). ** **	Side Effects: **		prepares available work into WorkList */
end_comment

begin_define
define|#
directive|define
name|NEED_P
value|0001
end_define

begin_comment
comment|/* 'P': priority */
end_comment

begin_define
define|#
directive|define
name|NEED_T
value|0002
end_define

begin_comment
comment|/* 'T': time */
end_comment

begin_define
define|#
directive|define
name|NEED_R
value|0004
end_define

begin_comment
comment|/* 'R': recipient */
end_comment

begin_define
define|#
directive|define
name|NEED_S
value|0010
end_define

begin_comment
comment|/* 'S': sender */
end_comment

begin_define
define|#
directive|define
name|NEED_H
value|0020
end_define

begin_comment
comment|/* host */
end_comment

begin_define
define|#
directive|define
name|HAS_QUARANTINE
value|0040
end_define

begin_comment
comment|/* has an unexpected 'q' line */
end_comment

begin_define
define|#
directive|define
name|NEED_QUARANTINE
value|0100
end_define

begin_comment
comment|/* 'q': reason */
end_comment

begin_decl_stmt
specifier|static
name|WORK
modifier|*
name|WorkList
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of unsort work */
end_comment

begin_decl_stmt
specifier|static
name|int
name|WorkListSize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current max size of WorkList */
end_comment

begin_decl_stmt
specifier|static
name|int
name|WorkListCount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of work items in WorkList */
end_comment

begin_function
specifier|static
name|int
name|gatherq
parameter_list|(
name|qgrp
parameter_list|,
name|qdir
parameter_list|,
name|doall
parameter_list|,
name|full
parameter_list|,
name|more
parameter_list|)
name|int
name|qgrp
decl_stmt|;
name|int
name|qdir
decl_stmt|;
name|bool
name|doall
decl_stmt|;
name|bool
modifier|*
name|full
decl_stmt|;
name|bool
modifier|*
name|more
decl_stmt|;
block|{
specifier|register
name|struct
name|dirent
modifier|*
name|d
decl_stmt|;
specifier|register
name|WORK
modifier|*
name|w
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|DIR
modifier|*
name|f
decl_stmt|;
name|int
name|i
decl_stmt|,
name|num_ent
decl_stmt|;
name|int
name|wn
decl_stmt|;
name|QUEUE_CHAR
modifier|*
name|check
decl_stmt|;
name|char
name|qd
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|qf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|wn
operator|=
name|WorkListCount
operator|-
literal|1
expr_stmt|;
name|num_ent
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|qdir
operator|==
name|NOQDIR
condition|)
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|qd
argument_list|,
literal|"."
argument_list|,
sizeof|sizeof
name|qd
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|qd
argument_list|,
sizeof|sizeof
name|qd
argument_list|,
literal|2
argument_list|,
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_qpaths
index|[
name|qdir
index|]
operator|.
name|qp_name
argument_list|,
operator|(
name|bitset
argument_list|(
name|QP_SUBQF
argument_list|,
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_qpaths
index|[
name|qdir
index|]
operator|.
name|qp_subdirs
argument_list|)
condition|?
literal|"/qf"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"gatherq:\n"
argument_list|)
expr_stmt|;
name|check
operator|=
name|QueueLimitId
expr_stmt|;
while|while
condition|(
name|check
operator|!=
name|NULL
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"\tQueueLimitId = %s%s\n"
argument_list|,
name|check
operator|->
name|queue_negate
condition|?
literal|"!"
else|:
literal|""
argument_list|,
name|check
operator|->
name|queue_match
argument_list|)
expr_stmt|;
name|check
operator|=
name|check
operator|->
name|queue_next
expr_stmt|;
block|}
name|check
operator|=
name|QueueLimitSender
expr_stmt|;
while|while
condition|(
name|check
operator|!=
name|NULL
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"\tQueueLimitSender = %s%s\n"
argument_list|,
name|check
operator|->
name|queue_negate
condition|?
literal|"!"
else|:
literal|""
argument_list|,
name|check
operator|->
name|queue_match
argument_list|)
expr_stmt|;
name|check
operator|=
name|check
operator|->
name|queue_next
expr_stmt|;
block|}
name|check
operator|=
name|QueueLimitRecipient
expr_stmt|;
while|while
condition|(
name|check
operator|!=
name|NULL
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"\tQueueLimitRecipient = %s%s\n"
argument_list|,
name|check
operator|->
name|queue_negate
condition|?
literal|"!"
else|:
literal|""
argument_list|,
name|check
operator|->
name|queue_match
argument_list|)
expr_stmt|;
name|check
operator|=
name|check
operator|->
name|queue_next
expr_stmt|;
block|}
if|if
condition|(
name|QueueMode
operator|==
name|QM_QUARANTINE
condition|)
block|{
name|check
operator|=
name|QueueLimitQuarantine
expr_stmt|;
while|while
condition|(
name|check
operator|!=
name|NULL
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"\tQueueLimitQuarantine = %s%s\n"
argument_list|,
name|check
operator|->
name|queue_negate
condition|?
literal|"!"
else|:
literal|""
argument_list|,
name|check
operator|->
name|queue_match
argument_list|)
expr_stmt|;
name|check
operator|=
name|check
operator|->
name|queue_next
expr_stmt|;
block|}
block|}
block|}
comment|/* open the queue directory */
name|f
operator|=
name|opendir
argument_list|(
name|qd
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"gatherq: cannot open \"%s\""
argument_list|,
name|qid_printqueue
argument_list|(
name|qgrp
argument_list|,
name|qdir
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|full
operator|!=
name|NULL
condition|)
operator|*
name|full
operator|=
name|WorkListCount
operator|>=
name|MaxQueueRun
operator|&&
name|MaxQueueRun
operator|>
literal|0
expr_stmt|;
if|if
condition|(
name|more
operator|!=
name|NULL
condition|)
operator|*
name|more
operator|=
name|false
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	**  Read the work directory. 	*/
while|while
condition|(
operator|(
name|d
operator|=
name|readdir
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SM_FILE_T
modifier|*
name|cf
decl_stmt|;
name|int
name|qfver
init|=
literal|0
decl_stmt|;
name|char
name|lbuf
index|[
name|MAXNAME
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|50
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"gatherq: checking %s.."
argument_list|,
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
comment|/* is this an interesting entry? */
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
name|QueueMode
operator|==
name|QM_NORMAL
operator|&&
name|d
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
name|NORMQF_LETTER
operator|)
operator|||
operator|(
name|QueueMode
operator|==
name|QM_QUARANTINE
operator|&&
name|d
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
name|QUARQF_LETTER
operator|)
operator|||
operator|(
name|QueueMode
operator|==
name|QM_LOST
operator|&&
name|d
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
name|LOSEQF_LETTER
operator|)
operator|)
operator|&&
name|d
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'f'
operator|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|50
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"  skipping\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|50
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|d
operator|->
name|d_name
argument_list|)
operator|>=
name|MAXQFNAME
condition|)
block|{
if|if
condition|(
name|Verbose
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"gatherq: %s too long, %d max characters\n"
argument_list|,
name|d
operator|->
name|d_name
argument_list|,
name|MAXQFNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ALERT
argument_list|,
name|NOQID
argument_list|,
literal|"gatherq: %s too long, %d max characters"
argument_list|,
name|d
operator|->
name|d_name
argument_list|,
name|MAXQFNAME
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|check
operator|=
name|QueueLimitId
expr_stmt|;
while|while
condition|(
name|check
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcontainedin
argument_list|(
name|false
argument_list|,
name|check
operator|->
name|queue_match
argument_list|,
name|d
operator|->
name|d_name
argument_list|)
operator|!=
name|check
operator|->
name|queue_negate
condition|)
break|break;
else|else
name|check
operator|=
name|check
operator|->
name|queue_next
expr_stmt|;
block|}
if|if
condition|(
name|QueueLimitId
operator|!=
name|NULL
operator|&&
name|check
operator|==
name|NULL
condition|)
continue|continue;
comment|/* grow work list if necessary */
if|if
condition|(
operator|++
name|wn
operator|>=
name|MaxQueueRun
operator|&&
name|MaxQueueRun
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|wn
operator|==
name|MaxQueueRun
operator|&&
name|LogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"WorkList for %s maxed out at %d"
argument_list|,
name|qid_printqueue
argument_list|(
name|qgrp
argument_list|,
name|qdir
argument_list|)
argument_list|,
name|MaxQueueRun
argument_list|)
expr_stmt|;
if|if
condition|(
name|doall
condition|)
continue|continue;
comment|/* just count entries */
break|break;
block|}
if|if
condition|(
name|wn
operator|>=
name|WorkListSize
condition|)
block|{
name|grow_wlist
argument_list|(
name|qgrp
argument_list|,
name|qdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|wn
operator|>=
name|WorkListSize
condition|)
continue|continue;
block|}
name|SM_ASSERT
argument_list|(
name|wn
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|w
operator|=
operator|&
name|WorkList
index|[
name|wn
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|qf
argument_list|,
sizeof|sizeof
name|qf
argument_list|,
literal|3
argument_list|,
name|qd
argument_list|,
literal|"/"
argument_list|,
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|qf
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"gatherq: can't stat %s/%s"
argument_list|,
name|qid_printqueue
argument_list|(
name|qgrp
argument_list|,
name|qdir
argument_list|)
argument_list|,
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|wn
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|S_IFREG
argument_list|,
name|sbuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* Yikes!  Skip it or we will hang on open! */
if|if
condition|(
operator|!
operator|(
operator|(
name|d
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
name|DATAFL_LETTER
operator|||
name|d
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
name|NORMQF_LETTER
operator|||
name|d
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
name|QUARQF_LETTER
operator|||
name|d
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
name|LOSEQF_LETTER
operator|||
name|d
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
name|XSCRPT_LETTER
operator|)
operator|&&
name|d
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
name|d
operator|->
name|d_name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
condition|)
name|syserr
argument_list|(
literal|"gatherq: %s/%s is not a regular file"
argument_list|,
name|qid_printqueue
argument_list|(
name|qgrp
argument_list|,
name|qdir
argument_list|)
argument_list|,
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|wn
operator|--
expr_stmt|;
continue|continue;
block|}
comment|/* avoid work if possible */
if|if
condition|(
operator|(
name|QueueSortOrder
operator|==
name|QSO_BYFILENAME
operator|||
name|QueueSortOrder
operator|==
name|QSO_BYMODTIME
operator|||
name|QueueSortOrder
operator|==
name|QSO_RANDOM
operator|)
operator|&&
name|QueueLimitQuarantine
operator|==
name|NULL
operator|&&
name|QueueLimitSender
operator|==
name|NULL
operator|&&
name|QueueLimitRecipient
operator|==
name|NULL
condition|)
block|{
name|w
operator|->
name|w_qgrp
operator|=
name|qgrp
expr_stmt|;
name|w
operator|->
name|w_qdir
operator|=
name|qdir
expr_stmt|;
name|w
operator|->
name|w_name
operator|=
name|newstr
argument_list|(
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|w
operator|->
name|w_host
operator|=
name|NULL
expr_stmt|;
name|w
operator|->
name|w_lock
operator|=
name|w
operator|->
name|w_tooyoung
operator|=
name|false
expr_stmt|;
name|w
operator|->
name|w_pri
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|w_ctime
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|w_mtime
operator|=
name|sbuf
operator|.
name|st_mtime
expr_stmt|;
operator|++
name|num_ent
expr_stmt|;
continue|continue;
block|}
comment|/* open control file */
name|cf
operator|=
name|sm_io_open
argument_list|(
name|SmFtStdio
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|qf
argument_list|,
name|SM_IO_RDONLY_B
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cf
operator|==
name|NULL
operator|&&
name|OpMode
operator|!=
name|MD_PRINT
condition|)
block|{
comment|/* this may be some random person sending hir msgs */
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"gatherq: cannot open %s: %s\n"
argument_list|,
name|d
operator|->
name|d_name
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|wn
operator|--
expr_stmt|;
continue|continue;
block|}
name|w
operator|->
name|w_qgrp
operator|=
name|qgrp
expr_stmt|;
name|w
operator|->
name|w_qdir
operator|=
name|qdir
expr_stmt|;
name|w
operator|->
name|w_name
operator|=
name|newstr
argument_list|(
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|w
operator|->
name|w_host
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cf
operator|!=
name|NULL
condition|)
block|{
name|w
operator|->
name|w_lock
operator|=
operator|!
name|lockfile
argument_list|(
name|sm_io_getinfo
argument_list|(
name|cf
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|w
operator|->
name|w_name
argument_list|,
name|NULL
argument_list|,
name|LOCK_SH
operator||
name|LOCK_NB
argument_list|)
expr_stmt|;
block|}
name|w
operator|->
name|w_tooyoung
operator|=
name|false
expr_stmt|;
comment|/* make sure jobs in creation don't clog queue */
name|w
operator|->
name|w_pri
operator|=
literal|0x7fffffff
expr_stmt|;
name|w
operator|->
name|w_ctime
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|w_mtime
operator|=
name|sbuf
operator|.
name|st_mtime
expr_stmt|;
comment|/* extract useful information */
name|i
operator|=
name|NEED_P
operator||
name|NEED_T
expr_stmt|;
if|if
condition|(
name|QueueSortOrder
operator|==
name|QSO_BYHOST
if|#
directive|if
name|_FFR_RHS
operator|||
name|QueueSortOrder
operator|==
name|QSO_BYSHUFFLE
endif|#
directive|endif
comment|/* _FFR_RHS */
condition|)
block|{
comment|/* need w_host set for host sort order */
name|i
operator||=
name|NEED_H
expr_stmt|;
block|}
if|if
condition|(
name|QueueLimitSender
operator|!=
name|NULL
condition|)
name|i
operator||=
name|NEED_S
expr_stmt|;
if|if
condition|(
name|QueueLimitRecipient
operator|!=
name|NULL
condition|)
name|i
operator||=
name|NEED_R
expr_stmt|;
if|if
condition|(
name|QueueLimitQuarantine
operator|!=
name|NULL
condition|)
name|i
operator||=
name|NEED_QUARANTINE
expr_stmt|;
while|while
condition|(
name|cf
operator|!=
name|NULL
operator|&&
name|i
operator|!=
literal|0
operator|&&
name|sm_io_fgets
argument_list|(
name|cf
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|lbuf
argument_list|,
sizeof|sizeof
name|lbuf
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|c
decl_stmt|;
name|time_t
name|age
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|lbuf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
comment|/* flush rest of overly long line */
while|while
condition|(
operator|(
name|c
operator|=
name|sm_io_getc
argument_list|(
name|cf
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
operator|)
operator|!=
name|SM_IO_EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
continue|continue;
block|}
switch|switch
condition|(
name|lbuf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'V'
case|:
name|qfver
operator|=
name|atoi
argument_list|(
operator|&
name|lbuf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|w
operator|->
name|w_pri
operator|=
name|atol
argument_list|(
operator|&
name|lbuf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|&=
operator|~
name|NEED_P
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|w
operator|->
name|w_ctime
operator|=
name|atol
argument_list|(
operator|&
name|lbuf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|&=
operator|~
name|NEED_T
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
if|if
condition|(
name|QueueMode
operator|!=
name|QM_QUARANTINE
operator|&&
name|QueueMode
operator|!=
name|QM_LOST
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|49
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"%s not marked as quarantined but has a 'q' line\n"
argument_list|,
name|w
operator|->
name|w_name
argument_list|)
expr_stmt|;
name|i
operator||=
name|HAS_QUARANTINE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QueueMode
operator|==
name|QM_QUARANTINE
condition|)
block|{
if|if
condition|(
name|QueueLimitQuarantine
operator|==
name|NULL
condition|)
block|{
name|i
operator|&=
operator|~
name|NEED_QUARANTINE
expr_stmt|;
break|break;
block|}
name|p
operator|=
operator|&
name|lbuf
index|[
literal|1
index|]
expr_stmt|;
name|check
operator|=
name|QueueLimitQuarantine
expr_stmt|;
while|while
condition|(
name|check
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcontainedin
argument_list|(
name|false
argument_list|,
name|check
operator|->
name|queue_match
argument_list|,
name|p
argument_list|)
operator|!=
name|check
operator|->
name|queue_negate
condition|)
break|break;
else|else
name|check
operator|=
name|check
operator|->
name|queue_next
expr_stmt|;
block|}
if|if
condition|(
name|check
operator|!=
name|NULL
condition|)
name|i
operator|&=
operator|~
name|NEED_QUARANTINE
expr_stmt|;
block|}
break|break;
case|case
literal|'R'
case|:
if|if
condition|(
name|w
operator|->
name|w_host
operator|==
name|NULL
operator|&&
operator|(
name|p
operator|=
name|strrchr
argument_list|(
operator|&
name|lbuf
index|[
literal|1
index|]
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
name|_FFR_RHS
if|if
condition|(
name|QueueSortOrder
operator|==
name|QSO_BYSHUFFLE
condition|)
name|w
operator|->
name|w_host
operator|=
name|newstr
argument_list|(
operator|&
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* _FFR_RHS */
name|w
operator|->
name|w_host
operator|=
name|strrev
argument_list|(
operator|&
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|makelower
argument_list|(
name|w
operator|->
name|w_host
argument_list|)
expr_stmt|;
name|i
operator|&=
operator|~
name|NEED_H
expr_stmt|;
block|}
if|if
condition|(
name|QueueLimitRecipient
operator|==
name|NULL
condition|)
block|{
name|i
operator|&=
operator|~
name|NEED_R
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|qfver
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|strchr
argument_list|(
operator|&
name|lbuf
index|[
literal|1
index|]
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
operator|&
name|lbuf
index|[
literal|1
index|]
expr_stmt|;
else|else
operator|++
name|p
expr_stmt|;
comment|/* skip over ':' */
block|}
else|else
name|p
operator|=
operator|&
name|lbuf
index|[
literal|1
index|]
expr_stmt|;
name|check
operator|=
name|QueueLimitRecipient
expr_stmt|;
while|while
condition|(
name|check
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcontainedin
argument_list|(
name|true
argument_list|,
name|check
operator|->
name|queue_match
argument_list|,
name|p
argument_list|)
operator|!=
name|check
operator|->
name|queue_negate
condition|)
break|break;
else|else
name|check
operator|=
name|check
operator|->
name|queue_next
expr_stmt|;
block|}
if|if
condition|(
name|check
operator|!=
name|NULL
condition|)
name|i
operator|&=
operator|~
name|NEED_R
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|check
operator|=
name|QueueLimitSender
expr_stmt|;
while|while
condition|(
name|check
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcontainedin
argument_list|(
name|true
argument_list|,
name|check
operator|->
name|queue_match
argument_list|,
operator|&
name|lbuf
index|[
literal|1
index|]
argument_list|)
operator|!=
name|check
operator|->
name|queue_negate
condition|)
break|break;
else|else
name|check
operator|=
name|check
operator|->
name|queue_next
expr_stmt|;
block|}
if|if
condition|(
name|check
operator|!=
name|NULL
condition|)
name|i
operator|&=
operator|~
name|NEED_S
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|age
operator|=
name|curtime
argument_list|()
operator|-
operator|(
name|time_t
operator|)
name|atol
argument_list|(
operator|&
name|lbuf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|age
operator|>=
literal|0
operator|&&
name|MinQueueAge
operator|>
literal|0
operator|&&
name|age
operator|<
name|MinQueueAge
condition|)
name|w
operator|->
name|w_tooyoung
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
if|if
condition|(
name|atol
argument_list|(
operator|&
name|lbuf
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
name|w
operator|->
name|w_tooyoung
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|cf
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|cf
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|doall
operator|&&
operator|(
name|shouldqueue
argument_list|(
name|w
operator|->
name|w_pri
argument_list|,
name|w
operator|->
name|w_ctime
argument_list|)
operator|||
name|w
operator|->
name|w_tooyoung
operator|)
operator|)
operator|||
name|bitset
argument_list|(
name|HAS_QUARANTINE
argument_list|,
name|i
argument_list|)
operator|||
name|bitset
argument_list|(
name|NEED_QUARANTINE
argument_list|,
name|i
argument_list|)
operator|||
name|bitset
argument_list|(
name|NEED_R
operator||
name|NEED_S
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* don't even bother sorting this job in */
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|49
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"skipping %s (%x)\n"
argument_list|,
name|w
operator|->
name|w_name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sm_free
argument_list|(
name|w
operator|->
name|w_name
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|w
operator|->
name|w_host
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|w
operator|->
name|w_host
argument_list|)
expr_stmt|;
comment|/* XXX */
name|wn
operator|--
expr_stmt|;
block|}
else|else
operator|++
name|num_ent
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|wn
operator|++
expr_stmt|;
name|i
operator|=
name|wn
operator|-
name|WorkListCount
expr_stmt|;
name|WorkListCount
operator|+=
name|SM_MIN
argument_list|(
name|num_ent
argument_list|,
name|WorkListSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|more
operator|!=
name|NULL
condition|)
operator|*
name|more
operator|=
name|WorkListCount
operator|<
name|wn
expr_stmt|;
if|if
condition|(
name|full
operator|!=
name|NULL
condition|)
operator|*
name|full
operator|=
operator|(
name|wn
operator|>=
name|MaxQueueRun
operator|&&
name|MaxQueueRun
operator|>
literal|0
operator|)
operator|||
operator|(
name|WorkList
operator|==
name|NULL
operator|&&
name|wn
operator|>
literal|0
operator|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* **  SORTQ -- sort the work list ** **	First the old WorkQ is cleared away. Then the WorkList is sorted **	for all items so that important (higher sorting value) items are not **	trunctated off. Then the most important items are moved from **	WorkList to WorkQ. The lower count of 'max' or MaxListCount items **	are moved. ** **	Parameters: **		max -- maximum number of items to be placed in WorkQ ** **	Returns: **		the number of items in WorkQ ** **	Side Effects: **		WorkQ gets released and filled with new work. WorkList **		gets released. Work items get sorted in order. */
end_comment

begin_function
specifier|static
name|int
name|sortq
parameter_list|(
name|max
parameter_list|)
name|int
name|max
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* local counter */
specifier|register
name|WORK
modifier|*
name|w
decl_stmt|;
comment|/* tmp item pointer */
name|int
name|wc
init|=
name|WorkListCount
decl_stmt|;
comment|/* trim size for WorkQ */
if|if
condition|(
name|WorkQ
operator|!=
name|NULL
condition|)
block|{
name|WORK
modifier|*
name|nw
decl_stmt|;
comment|/* Clear out old WorkQ. */
for|for
control|(
name|w
operator|=
name|WorkQ
init|;
name|w
operator|!=
name|NULL
condition|;
name|w
operator|=
name|nw
control|)
block|{
name|nw
operator|=
name|w
operator|->
name|w_next
expr_stmt|;
name|sm_free
argument_list|(
name|w
operator|->
name|w_name
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|w
operator|->
name|w_host
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|w
operator|->
name|w_host
argument_list|)
expr_stmt|;
comment|/* XXX */
name|sm_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|w
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
name|WorkQ
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|WorkList
operator|==
name|NULL
operator|||
name|wc
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* 	**  The sort now takes place using all of the items in WorkList. 	**  The list gets trimmed to the most important items after the sort. 	**  If the trim were to happen before the sort then one or more 	**  important items might get truncated off -- not what we want. 	*/
if|if
condition|(
name|QueueSortOrder
operator|==
name|QSO_BYHOST
condition|)
block|{
comment|/* 		**  Sort the work directory for the first time, 		**  based on host name, lock status, and priority. 		*/
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|WorkList
argument_list|,
name|wc
argument_list|,
sizeof|sizeof
expr|*
name|WorkList
argument_list|,
name|workcmpf1
argument_list|)
expr_stmt|;
comment|/* 		**  If one message to host is locked, "lock" all messages 		**  to that host. 		*/
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|wc
condition|)
block|{
if|if
condition|(
operator|!
name|WorkList
index|[
name|i
index|]
operator|.
name|w_lock
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
name|w
operator|=
operator|&
name|WorkList
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|++
name|i
operator|<
name|wc
condition|)
block|{
if|if
condition|(
name|WorkList
index|[
name|i
index|]
operator|.
name|w_host
operator|==
name|NULL
operator|&&
name|w
operator|->
name|w_host
operator|==
name|NULL
condition|)
name|WorkList
index|[
name|i
index|]
operator|.
name|w_lock
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|WorkList
index|[
name|i
index|]
operator|.
name|w_host
operator|!=
name|NULL
operator|&&
name|w
operator|->
name|w_host
operator|!=
name|NULL
operator|&&
name|sm_strcasecmp
argument_list|(
name|WorkList
index|[
name|i
index|]
operator|.
name|w_host
argument_list|,
name|w
operator|->
name|w_host
argument_list|)
operator|==
literal|0
condition|)
name|WorkList
index|[
name|i
index|]
operator|.
name|w_lock
operator|=
name|true
expr_stmt|;
else|else
break|break;
block|}
block|}
comment|/* 		**  Sort the work directory for the second time, 		**  based on lock status, host name, and priority. 		*/
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|WorkList
argument_list|,
name|wc
argument_list|,
sizeof|sizeof
expr|*
name|WorkList
argument_list|,
name|workcmpf2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QueueSortOrder
operator|==
name|QSO_BYTIME
condition|)
block|{
comment|/* 		**  Simple sort based on submission time only. 		*/
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|WorkList
argument_list|,
name|wc
argument_list|,
sizeof|sizeof
expr|*
name|WorkList
argument_list|,
name|workcmpf3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QueueSortOrder
operator|==
name|QSO_BYFILENAME
condition|)
block|{
comment|/* 		**  Sort based on queue filename. 		*/
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|WorkList
argument_list|,
name|wc
argument_list|,
sizeof|sizeof
expr|*
name|WorkList
argument_list|,
name|workcmpf4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QueueSortOrder
operator|==
name|QSO_RANDOM
condition|)
block|{
comment|/* 		**  Sort randomly.  To avoid problems with an instable sort, 		**  use a random index into the queue file name to start 		**  comparison. 		*/
name|randi
operator|=
name|get_rand_mod
argument_list|(
name|MAXQFNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|randi
operator|<
literal|2
condition|)
name|randi
operator|=
literal|3
expr_stmt|;
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|WorkList
argument_list|,
name|wc
argument_list|,
sizeof|sizeof
expr|*
name|WorkList
argument_list|,
name|workcmpf5
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QueueSortOrder
operator|==
name|QSO_BYMODTIME
condition|)
block|{
comment|/* 		**  Simple sort based on modification time of queue file. 		**  This puts the oldest items first. 		*/
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|WorkList
argument_list|,
name|wc
argument_list|,
sizeof|sizeof
expr|*
name|WorkList
argument_list|,
name|workcmpf6
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|_FFR_RHS
elseif|else
if|if
condition|(
name|QueueSortOrder
operator|==
name|QSO_BYSHUFFLE
condition|)
block|{
comment|/* 		**  Simple sort based on shuffled host name. 		*/
name|init_shuffle_alphabet
argument_list|()
expr_stmt|;
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|WorkList
argument_list|,
name|wc
argument_list|,
sizeof|sizeof
expr|*
name|WorkList
argument_list|,
name|workcmpf7
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _FFR_RHS */
elseif|else
if|if
condition|(
name|QueueSortOrder
operator|==
name|QSO_BYPRIORITY
condition|)
block|{
comment|/* 		**  Simple sort based on queue priority only. 		*/
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|WorkList
argument_list|,
name|wc
argument_list|,
sizeof|sizeof
expr|*
name|WorkList
argument_list|,
name|workcmpf0
argument_list|)
expr_stmt|;
block|}
comment|/* else don't sort at all */
comment|/* Check if the per queue group item limit will be exceeded */
if|if
condition|(
name|wc
operator|>
name|max
operator|&&
name|max
operator|>
literal|0
condition|)
name|wc
operator|=
name|max
expr_stmt|;
comment|/* 	**  Convert the work list into canonical form. 	**	Should be turning it into a list of envelopes here perhaps. 	**  Only take the most important items up to the per queue group 	**  maximum. 	*/
for|for
control|(
name|i
operator|=
name|wc
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|w
operator|=
operator|(
name|WORK
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|w
argument_list|)
expr_stmt|;
name|w
operator|->
name|w_qgrp
operator|=
name|WorkList
index|[
name|i
index|]
operator|.
name|w_qgrp
expr_stmt|;
name|w
operator|->
name|w_qdir
operator|=
name|WorkList
index|[
name|i
index|]
operator|.
name|w_qdir
expr_stmt|;
name|w
operator|->
name|w_name
operator|=
name|WorkList
index|[
name|i
index|]
operator|.
name|w_name
expr_stmt|;
name|w
operator|->
name|w_host
operator|=
name|WorkList
index|[
name|i
index|]
operator|.
name|w_host
expr_stmt|;
name|w
operator|->
name|w_lock
operator|=
name|WorkList
index|[
name|i
index|]
operator|.
name|w_lock
expr_stmt|;
name|w
operator|->
name|w_tooyoung
operator|=
name|WorkList
index|[
name|i
index|]
operator|.
name|w_tooyoung
expr_stmt|;
name|w
operator|->
name|w_pri
operator|=
name|WorkList
index|[
name|i
index|]
operator|.
name|w_pri
expr_stmt|;
name|w
operator|->
name|w_ctime
operator|=
name|WorkList
index|[
name|i
index|]
operator|.
name|w_ctime
expr_stmt|;
name|w
operator|->
name|w_mtime
operator|=
name|WorkList
index|[
name|i
index|]
operator|.
name|w_mtime
expr_stmt|;
name|w
operator|->
name|w_next
operator|=
name|WorkQ
expr_stmt|;
name|WorkQ
operator|=
name|w
expr_stmt|;
block|}
comment|/* free the rest of the list */
for|for
control|(
name|i
operator|=
name|WorkListCount
init|;
operator|--
name|i
operator|>=
name|wc
condition|;
control|)
block|{
name|sm_free
argument_list|(
name|WorkList
index|[
name|i
index|]
operator|.
name|w_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|WorkList
index|[
name|i
index|]
operator|.
name|w_host
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|WorkList
index|[
name|i
index|]
operator|.
name|w_host
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|WorkList
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|WorkList
argument_list|)
expr_stmt|;
comment|/* XXX */
name|WorkList
operator|=
name|NULL
expr_stmt|;
name|WorkListSize
operator|=
literal|0
expr_stmt|;
name|WorkListCount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|1
argument_list|)
condition|)
block|{
for|for
control|(
name|w
operator|=
name|WorkQ
init|;
name|w
operator|!=
name|NULL
condition|;
name|w
operator|=
name|w
operator|->
name|w_next
control|)
block|{
if|if
condition|(
name|w
operator|->
name|w_host
operator|!=
name|NULL
condition|)
name|sm_dprintf
argument_list|(
literal|"%22s: pri=%ld %s\n"
argument_list|,
name|w
operator|->
name|w_name
argument_list|,
name|w
operator|->
name|w_pri
argument_list|,
name|w
operator|->
name|w_host
argument_list|)
expr_stmt|;
else|else
name|sm_dprintf
argument_list|(
literal|"%32s: pri=%ld\n"
argument_list|,
name|w
operator|->
name|w_name
argument_list|,
name|w
operator|->
name|w_pri
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|wc
return|;
comment|/* return number of WorkQ items */
block|}
end_function

begin_comment
comment|/* **  GROW_WLIST -- make the work list larger ** **	Parameters: **		qgrp -- the index for the queue group. **		qdir -- the index for the queue directory. ** **	Returns: **		none. ** **	Side Effects: **		Adds another QUEUESEGSIZE entries to WorkList if possible. **		It can fail if there isn't enough memory, so WorkListSize **		should be checked again upon return. */
end_comment

begin_function
specifier|static
name|void
name|grow_wlist
parameter_list|(
name|qgrp
parameter_list|,
name|qdir
parameter_list|)
name|int
name|qgrp
decl_stmt|;
name|int
name|qdir
decl_stmt|;
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"grow_wlist: WorkListSize=%d\n"
argument_list|,
name|WorkListSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|WorkList
operator|==
name|NULL
condition|)
block|{
name|WorkList
operator|=
operator|(
name|WORK
operator|*
operator|)
name|xalloc
argument_list|(
operator|(
sizeof|sizeof
expr|*
name|WorkList
operator|)
operator|*
operator|(
name|QUEUESEGSIZE
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|WorkListSize
operator|=
name|QUEUESEGSIZE
expr_stmt|;
block|}
else|else
block|{
name|int
name|newsize
init|=
name|WorkListSize
operator|+
name|QUEUESEGSIZE
decl_stmt|;
name|WORK
modifier|*
name|newlist
init|=
operator|(
name|WORK
operator|*
operator|)
name|sm_realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|WorkList
argument_list|,
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|WORK
argument_list|)
operator|*
operator|(
name|newsize
operator|+
literal|1
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|newlist
operator|!=
name|NULL
condition|)
block|{
name|WorkListSize
operator|=
name|newsize
expr_stmt|;
name|WorkList
operator|=
name|newlist
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|1
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"grew WorkList for %s to %d"
argument_list|,
name|qid_printqueue
argument_list|(
name|qgrp
argument_list|,
name|qdir
argument_list|)
argument_list|,
name|WorkListSize
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|LogLevel
operator|>
literal|0
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_ALERT
argument_list|,
name|NOQID
argument_list|,
literal|"FAILED to grow WorkList for %s to %d"
argument_list|,
name|qid_printqueue
argument_list|(
name|qgrp
argument_list|,
name|qdir
argument_list|)
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"grow_wlist: WorkListSize now %d\n"
argument_list|,
name|WorkListSize
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  WORKCMPF0 -- simple priority-only compare function. ** **	Parameters: **		a -- the first argument. **		b -- the second argument. ** **	Returns: **		-1 if a< b **		 0 if a == b **		+1 if a> b ** */
end_comment

begin_function
specifier|static
name|int
name|workcmpf0
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|WORK
modifier|*
name|a
decl_stmt|;
specifier|register
name|WORK
modifier|*
name|b
decl_stmt|;
block|{
name|long
name|pa
init|=
name|a
operator|->
name|w_pri
decl_stmt|;
name|long
name|pb
init|=
name|b
operator|->
name|w_pri
decl_stmt|;
if|if
condition|(
name|pa
operator|==
name|pb
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|pa
operator|>
name|pb
condition|)
return|return
literal|1
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* **  WORKCMPF1 -- first compare function for ordering work based on host name. ** **	Sorts on host name, lock status, and priority in that order. ** **	Parameters: **		a -- the first argument. **		b -- the second argument. ** **	Returns: **<0 if a< b **		 0 if a == b **>0 if a> b ** */
end_comment

begin_function
specifier|static
name|int
name|workcmpf1
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|WORK
modifier|*
name|a
decl_stmt|;
specifier|register
name|WORK
modifier|*
name|b
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* host name */
if|if
condition|(
name|a
operator|->
name|w_host
operator|!=
name|NULL
operator|&&
name|b
operator|->
name|w_host
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|w_host
operator|==
name|NULL
operator|&&
name|b
operator|->
name|w_host
operator|!=
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|w_host
operator|!=
name|NULL
operator|&&
name|b
operator|->
name|w_host
operator|!=
name|NULL
operator|&&
operator|(
name|i
operator|=
name|sm_strcasecmp
argument_list|(
name|a
operator|->
name|w_host
argument_list|,
name|b
operator|->
name|w_host
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|i
return|;
comment|/* lock status */
if|if
condition|(
name|a
operator|->
name|w_lock
operator|!=
name|b
operator|->
name|w_lock
condition|)
return|return
name|b
operator|->
name|w_lock
operator|-
name|a
operator|->
name|w_lock
return|;
comment|/* job priority */
return|return
name|workcmpf0
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  WORKCMPF2 -- second compare function for ordering work based on host name. ** **	Sorts on lock status, host name, and priority in that order. ** **	Parameters: **		a -- the first argument. **		b -- the second argument. ** **	Returns: **<0 if a< b **		 0 if a == b **>0 if a> b ** */
end_comment

begin_function
specifier|static
name|int
name|workcmpf2
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|WORK
modifier|*
name|a
decl_stmt|;
specifier|register
name|WORK
modifier|*
name|b
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* lock status */
if|if
condition|(
name|a
operator|->
name|w_lock
operator|!=
name|b
operator|->
name|w_lock
condition|)
return|return
name|a
operator|->
name|w_lock
operator|-
name|b
operator|->
name|w_lock
return|;
comment|/* host name */
if|if
condition|(
name|a
operator|->
name|w_host
operator|!=
name|NULL
operator|&&
name|b
operator|->
name|w_host
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|w_host
operator|==
name|NULL
operator|&&
name|b
operator|->
name|w_host
operator|!=
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|w_host
operator|!=
name|NULL
operator|&&
name|b
operator|->
name|w_host
operator|!=
name|NULL
operator|&&
operator|(
name|i
operator|=
name|sm_strcasecmp
argument_list|(
name|a
operator|->
name|w_host
argument_list|,
name|b
operator|->
name|w_host
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|i
return|;
comment|/* job priority */
return|return
name|workcmpf0
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  WORKCMPF3 -- simple submission-time-only compare function. ** **	Parameters: **		a -- the first argument. **		b -- the second argument. ** **	Returns: **		-1 if a< b **		 0 if a == b **		+1 if a> b ** */
end_comment

begin_function
specifier|static
name|int
name|workcmpf3
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|WORK
modifier|*
name|a
decl_stmt|;
specifier|register
name|WORK
modifier|*
name|b
decl_stmt|;
block|{
if|if
condition|(
name|a
operator|->
name|w_ctime
operator|>
name|b
operator|->
name|w_ctime
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|w_ctime
operator|<
name|b
operator|->
name|w_ctime
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* **  WORKCMPF4 -- compare based on file name ** **	Parameters: **		a -- the first argument. **		b -- the second argument. ** **	Returns: **		-1 if a< b **		 0 if a == b **		+1 if a> b ** */
end_comment

begin_function
specifier|static
name|int
name|workcmpf4
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|WORK
modifier|*
name|a
decl_stmt|;
specifier|register
name|WORK
modifier|*
name|b
decl_stmt|;
block|{
return|return
name|strcmp
argument_list|(
name|a
operator|->
name|w_name
argument_list|,
name|b
operator|->
name|w_name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  WORKCMPF5 -- compare based on assigned random number ** **	Parameters: **		a -- the first argument (ignored). **		b -- the second argument (ignored). ** **	Returns: **		randomly 1/-1 */
end_comment

begin_comment
comment|/* ARGSUSED0 */
end_comment

begin_function
specifier|static
name|int
name|workcmpf5
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|WORK
modifier|*
name|a
decl_stmt|;
specifier|register
name|WORK
modifier|*
name|b
decl_stmt|;
block|{
if|if
condition|(
name|strlen
argument_list|(
name|a
operator|->
name|w_name
argument_list|)
operator|<
name|randi
operator|||
name|strlen
argument_list|(
name|b
operator|->
name|w_name
argument_list|)
operator|<
name|randi
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|a
operator|->
name|w_name
index|[
name|randi
index|]
operator|-
name|b
operator|->
name|w_name
index|[
name|randi
index|]
return|;
block|}
end_function

begin_comment
comment|/* **  WORKCMPF6 -- simple modification-time-only compare function. ** **	Parameters: **		a -- the first argument. **		b -- the second argument. ** **	Returns: **		-1 if a< b **		 0 if a == b **		+1 if a> b ** */
end_comment

begin_function
specifier|static
name|int
name|workcmpf6
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|WORK
modifier|*
name|a
decl_stmt|;
specifier|register
name|WORK
modifier|*
name|b
decl_stmt|;
block|{
if|if
condition|(
name|a
operator|->
name|w_mtime
operator|>
name|b
operator|->
name|w_mtime
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|w_mtime
operator|<
name|b
operator|->
name|w_mtime
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
name|_FFR_RHS
end_if

begin_comment
comment|/* **  WORKCMPF7 -- compare function for ordering work based on shuffled host name. ** **	Sorts on lock status, host name, and priority in that order. ** **	Parameters: **		a -- the first argument. **		b -- the second argument. ** **	Returns: **<0 if a< b **		 0 if a == b **>0 if a> b ** */
end_comment

begin_function
specifier|static
name|int
name|workcmpf7
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|WORK
modifier|*
name|a
decl_stmt|;
specifier|register
name|WORK
modifier|*
name|b
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* lock status */
if|if
condition|(
name|a
operator|->
name|w_lock
operator|!=
name|b
operator|->
name|w_lock
condition|)
return|return
name|a
operator|->
name|w_lock
operator|-
name|b
operator|->
name|w_lock
return|;
comment|/* host name */
if|if
condition|(
name|a
operator|->
name|w_host
operator|!=
name|NULL
operator|&&
name|b
operator|->
name|w_host
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|w_host
operator|==
name|NULL
operator|&&
name|b
operator|->
name|w_host
operator|!=
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|w_host
operator|!=
name|NULL
operator|&&
name|b
operator|->
name|w_host
operator|!=
name|NULL
operator|&&
operator|(
name|i
operator|=
name|sm_strshufflecmp
argument_list|(
name|a
operator|->
name|w_host
argument_list|,
name|b
operator|->
name|w_host
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|i
return|;
comment|/* job priority */
return|return
name|workcmpf0
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_RHS */
end_comment

begin_comment
comment|/* **  STRREV -- reverse string ** **	Returns a pointer to a new string that is the reverse of **	the string pointed to by fwd.  The space for the new **	string is obtained using xalloc(). ** **	Parameters: **		fwd -- the string to reverse. ** **	Returns: **		the reversed string. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|strrev
parameter_list|(
name|fwd
parameter_list|)
name|char
modifier|*
name|fwd
decl_stmt|;
block|{
name|char
modifier|*
name|rev
init|=
name|NULL
decl_stmt|;
name|int
name|len
decl_stmt|,
name|cnt
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|fwd
argument_list|)
expr_stmt|;
name|rev
operator|=
name|xalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|len
condition|;
operator|++
name|cnt
control|)
name|rev
index|[
name|cnt
index|]
operator|=
name|fwd
index|[
name|len
operator|-
name|cnt
operator|-
literal|1
index|]
expr_stmt|;
name|rev
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|rev
return|;
block|}
end_function

begin_if
if|#
directive|if
name|_FFR_RHS
end_if

begin_define
define|#
directive|define
name|NASCII
value|128
end_define

begin_define
define|#
directive|define
name|NCHAR
value|256
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|ShuffledAlphabet
index|[
name|NCHAR
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_shuffle_alphabet
parameter_list|()
block|{
specifier|static
name|bool
name|init
init|=
name|false
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|init
condition|)
return|return;
comment|/* fill the ShuffledAlphabet */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NASCII
condition|;
name|i
operator|++
control|)
name|ShuffledAlphabet
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
comment|/* mix it */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NASCII
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|int
name|j
init|=
name|get_random
argument_list|()
operator|%
name|NASCII
decl_stmt|;
specifier|register
name|int
name|tmp
decl_stmt|;
name|tmp
operator|=
name|ShuffledAlphabet
index|[
name|j
index|]
expr_stmt|;
name|ShuffledAlphabet
index|[
name|j
index|]
operator|=
name|ShuffledAlphabet
index|[
name|i
index|]
expr_stmt|;
name|ShuffledAlphabet
index|[
name|i
index|]
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* make it case insensitive */
for|for
control|(
name|i
operator|=
literal|'A'
init|;
name|i
operator|<=
literal|'Z'
condition|;
name|i
operator|++
control|)
name|ShuffledAlphabet
index|[
name|i
index|]
operator|=
name|ShuffledAlphabet
index|[
name|i
operator|+
literal|'a'
operator|-
literal|'A'
index|]
expr_stmt|;
comment|/* fill the upper part */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NASCII
condition|;
name|i
operator|++
control|)
name|ShuffledAlphabet
index|[
name|i
operator|+
name|NASCII
index|]
operator|=
name|ShuffledAlphabet
index|[
name|i
index|]
expr_stmt|;
name|init
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sm_strshufflecmp
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|char
modifier|*
name|a
decl_stmt|;
name|char
modifier|*
name|b
decl_stmt|;
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|us1
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|a
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|us2
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|b
decl_stmt|;
while|while
condition|(
name|ShuffledAlphabet
index|[
operator|*
name|us1
index|]
operator|==
name|ShuffledAlphabet
index|[
operator|*
name|us2
operator|++
index|]
condition|)
block|{
if|if
condition|(
operator|*
name|us1
operator|++
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
block|}
return|return
operator|(
name|ShuffledAlphabet
index|[
operator|*
name|us1
index|]
operator|-
name|ShuffledAlphabet
index|[
operator|*
operator|--
name|us2
index|]
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_RHS */
end_comment

begin_comment
comment|/* **  DOWORK -- do a work request. ** **	Parameters: **		qgrp -- the index of the queue group for the job. **		qdir -- the index of the queue directory for the job. **		id -- the ID of the job to run. **		forkflag -- if set, run this in background. **		requeueflag -- if set, reinstantiate the queue quickly. **			This is used when expanding aliases in the queue. **			If forkflag is also set, it doesn't wait for the **			child. **		e - the envelope in which to run it. ** **	Returns: **		process id of process that is running the queue job. ** **	Side Effects: **		The work request is satisfied if possible. */
end_comment

begin_function
name|pid_t
name|dowork
parameter_list|(
name|qgrp
parameter_list|,
name|qdir
parameter_list|,
name|id
parameter_list|,
name|forkflag
parameter_list|,
name|requeueflag
parameter_list|,
name|e
parameter_list|)
name|int
name|qgrp
decl_stmt|;
name|int
name|qdir
decl_stmt|;
name|char
modifier|*
name|id
decl_stmt|;
name|bool
name|forkflag
decl_stmt|;
name|bool
name|requeueflag
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|pid_t
name|pid
decl_stmt|;
name|SM_RPOOL_T
modifier|*
name|rpool
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"dowork(%s/%s)\n"
argument_list|,
name|qid_printqueue
argument_list|(
name|qgrp
argument_list|,
name|qdir
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* 	**  Fork for work. 	*/
if|if
condition|(
name|forkflag
condition|)
block|{
comment|/* 		**  Since the delivery may happen in a child and the 		**  parent does not wait, the parent may close the 		**  maps thereby removing any shared memory used by 		**  the map.  Therefore, close the maps now so the 		**  child will dynamically open them if necessary. 		*/
name|closemaps
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"dowork: cannot fork"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
block|{
comment|/* parent -- clean out connection cache */
name|mci_flush
argument_list|(
name|false
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			**  Initialize exception stack and default exception 			**  handler for child process. 			*/
comment|/* Reset global flags */
name|RestartRequest
operator|=
name|NULL
expr_stmt|;
name|RestartWorkGroup
operator|=
name|false
expr_stmt|;
name|ShutdownRequest
operator|=
name|NULL
expr_stmt|;
name|PendingSignal
operator|=
literal|0
expr_stmt|;
name|CurrentPid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|sm_exc_newthread
argument_list|(
name|fatal_error
argument_list|)
expr_stmt|;
comment|/* 			**  See note above about SMTP processes and SIGCHLD. 			*/
if|if
condition|(
name|OpMode
operator|==
name|MD_SMTP
operator|||
name|OpMode
operator|==
name|MD_DAEMON
operator|||
name|MaxQueueChildren
operator|>
literal|0
condition|)
block|{
name|proc_list_clear
argument_list|()
expr_stmt|;
name|sm_releasesignal
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
block|}
comment|/* child -- error messages to the transcript */
name|QuickAbort
operator|=
name|OnlyOneError
operator|=
name|false
expr_stmt|;
block|}
block|}
else|else
block|{
name|pid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* 		**  CHILD 		**	Lock the control file to avoid duplicate deliveries. 		**		Then run the file as though we had just read it. 		**	We save an idea of the temporary name so we 		**		can recover on interrupt. 		*/
if|if
condition|(
name|forkflag
condition|)
block|{
comment|/* Reset global flags */
name|RestartRequest
operator|=
name|NULL
expr_stmt|;
name|RestartWorkGroup
operator|=
name|false
expr_stmt|;
name|ShutdownRequest
operator|=
name|NULL
expr_stmt|;
name|PendingSignal
operator|=
literal|0
expr_stmt|;
block|}
comment|/* set basic modes, etc. */
name|sm_clear_events
argument_list|()
expr_stmt|;
name|clearstats
argument_list|()
expr_stmt|;
name|rpool
operator|=
name|sm_rpool_new_x
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|clearenvelope
argument_list|(
name|e
argument_list|,
name|false
argument_list|,
name|rpool
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_QUEUERUN
operator||
name|EF_GLOBALERRS
expr_stmt|;
name|set_delivery_mode
argument_list|(
name|SM_DELIVER
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_errormode
operator|=
name|EM_MAIL
expr_stmt|;
name|e
operator|->
name|e_id
operator|=
name|id
expr_stmt|;
name|e
operator|->
name|e_qgrp
operator|=
name|qgrp
expr_stmt|;
name|e
operator|->
name|e_qdir
operator|=
name|qdir
expr_stmt|;
name|GrabTo
operator|=
name|UseErrorsTo
operator|=
name|false
expr_stmt|;
name|ExitStat
operator|=
name|EX_OK
expr_stmt|;
if|if
condition|(
name|forkflag
condition|)
block|{
name|disconnect
argument_list|(
literal|1
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|set_op_mode
argument_list|(
name|MD_QUEUERUN
argument_list|)
expr_stmt|;
block|}
name|sm_setproctitle
argument_list|(
name|true
argument_list|,
name|e
argument_list|,
literal|"%s from queue"
argument_list|,
name|qid_printname
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|76
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"dowork, pid=%d"
argument_list|,
operator|(
name|int
operator|)
name|CurrentPid
argument_list|)
expr_stmt|;
comment|/* don't use the headers from sendmail.cf... */
name|e
operator|->
name|e_header
operator|=
name|NULL
expr_stmt|;
comment|/* read the queue control file -- return if locked */
if|if
condition|(
operator|!
name|readqf
argument_list|(
name|e
argument_list|,
name|false
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|4
argument_list|)
operator|&&
name|e
operator|->
name|e_id
operator|!=
name|NULL
condition|)
name|sm_dprintf
argument_list|(
literal|"readqf(%s) failed\n"
argument_list|,
name|qid_printname
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_id
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|forkflag
condition|)
name|finis
argument_list|(
name|false
argument_list|,
name|true
argument_list|,
name|EX_OK
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* adding this frees 8 bytes */
name|clearenvelope
argument_list|(
name|e
argument_list|,
name|false
argument_list|,
name|rpool
argument_list|)
expr_stmt|;
comment|/* adding this frees 12 bytes */
name|sm_rpool_free
argument_list|(
name|rpool
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_rpool
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|e
operator|->
name|e_flags
operator||=
name|EF_INQUEUE
expr_stmt|;
name|eatheader
argument_list|(
name|e
argument_list|,
name|requeueflag
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|requeueflag
condition|)
name|queueup
argument_list|(
name|e
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* do the delivery */
name|sendall
argument_list|(
name|e
argument_list|,
name|SM_DELIVER
argument_list|)
expr_stmt|;
comment|/* finish up and exit */
if|if
condition|(
name|forkflag
condition|)
name|finis
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
else|else
block|{
name|dropenvelope
argument_list|(
name|e
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|sm_rpool_free
argument_list|(
name|rpool
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_rpool
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|e
operator|->
name|e_id
operator|=
name|NULL
expr_stmt|;
return|return
name|pid
return|;
block|}
end_function

begin_comment
comment|/* **  DOWORKLIST -- process a list of envelopes as work requests ** **	Similar to dowork(), except that after forking, it processes an **	envelope and its siblings, treating each envelope as a work request. ** **	Parameters: **		el -- envelope to be processed including its siblings. **		forkflag -- if set, run this in background. **		requeueflag -- if set, reinstantiate the queue quickly. **			This is used when expanding aliases in the queue. **			If forkflag is also set, it doesn't wait for the **			child. ** **	Returns: **		process id of process that is running the queue job. ** **	Side Effects: **		The work request is satisfied if possible. */
end_comment

begin_function
name|pid_t
name|doworklist
parameter_list|(
name|el
parameter_list|,
name|forkflag
parameter_list|,
name|requeueflag
parameter_list|)
name|ENVELOPE
modifier|*
name|el
decl_stmt|;
name|bool
name|forkflag
decl_stmt|;
name|bool
name|requeueflag
decl_stmt|;
block|{
specifier|register
name|pid_t
name|pid
decl_stmt|;
name|ENVELOPE
modifier|*
name|ei
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"doworklist()\n"
argument_list|)
expr_stmt|;
comment|/* 	**  Fork for work. 	*/
if|if
condition|(
name|forkflag
condition|)
block|{
comment|/* 		**  Since the delivery may happen in a child and the 		**  parent does not wait, the parent may close the 		**  maps thereby removing any shared memory used by 		**  the map.  Therefore, close the maps now so the 		**  child will dynamically open them if necessary. 		*/
name|closemaps
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"doworklist: cannot fork"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
block|{
comment|/* parent -- clean out connection cache */
name|mci_flush
argument_list|(
name|false
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			**  Initialize exception stack and default exception 			**  handler for child process. 			*/
comment|/* Reset global flags */
name|RestartRequest
operator|=
name|NULL
expr_stmt|;
name|RestartWorkGroup
operator|=
name|false
expr_stmt|;
name|ShutdownRequest
operator|=
name|NULL
expr_stmt|;
name|PendingSignal
operator|=
literal|0
expr_stmt|;
name|CurrentPid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|sm_exc_newthread
argument_list|(
name|fatal_error
argument_list|)
expr_stmt|;
comment|/* 			**  See note above about SMTP processes and SIGCHLD. 			*/
if|if
condition|(
name|OpMode
operator|==
name|MD_SMTP
operator|||
name|OpMode
operator|==
name|MD_DAEMON
operator|||
name|MaxQueueChildren
operator|>
literal|0
condition|)
block|{
name|proc_list_clear
argument_list|()
expr_stmt|;
name|sm_releasesignal
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
block|}
comment|/* child -- error messages to the transcript */
name|QuickAbort
operator|=
name|OnlyOneError
operator|=
name|false
expr_stmt|;
block|}
block|}
else|else
block|{
name|pid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|!=
literal|0
condition|)
return|return
name|pid
return|;
comment|/* 	**  IN CHILD 	**	Lock the control file to avoid duplicate deliveries. 	**		Then run the file as though we had just read it. 	**	We save an idea of the temporary name so we 	**		can recover on interrupt. 	*/
if|if
condition|(
name|forkflag
condition|)
block|{
comment|/* Reset global flags */
name|RestartRequest
operator|=
name|NULL
expr_stmt|;
name|RestartWorkGroup
operator|=
name|false
expr_stmt|;
name|ShutdownRequest
operator|=
name|NULL
expr_stmt|;
name|PendingSignal
operator|=
literal|0
expr_stmt|;
block|}
comment|/* set basic modes, etc. */
name|sm_clear_events
argument_list|()
expr_stmt|;
name|clearstats
argument_list|()
expr_stmt|;
name|GrabTo
operator|=
name|UseErrorsTo
operator|=
name|false
expr_stmt|;
name|ExitStat
operator|=
name|EX_OK
expr_stmt|;
if|if
condition|(
name|forkflag
condition|)
block|{
name|disconnect
argument_list|(
literal|1
argument_list|,
name|el
argument_list|)
expr_stmt|;
name|set_op_mode
argument_list|(
name|MD_QUEUERUN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LogLevel
operator|>
literal|76
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|el
operator|->
name|e_id
argument_list|,
literal|"doworklist, pid=%d"
argument_list|,
operator|(
name|int
operator|)
name|CurrentPid
argument_list|)
expr_stmt|;
for|for
control|(
name|ei
operator|=
name|el
init|;
name|ei
operator|!=
name|NULL
condition|;
name|ei
operator|=
name|ei
operator|->
name|e_sibling
control|)
block|{
name|ENVELOPE
name|e
decl_stmt|;
name|SM_RPOOL_T
modifier|*
name|rpool
decl_stmt|;
if|if
condition|(
name|WILL_BE_QUEUED
argument_list|(
name|ei
operator|->
name|e_sendmode
argument_list|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|QueueMode
operator|!=
name|QM_QUARANTINE
operator|&&
name|ei
operator|->
name|e_quarmsg
operator|!=
name|NULL
condition|)
continue|continue;
name|rpool
operator|=
name|sm_rpool_new_x
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|clearenvelope
argument_list|(
operator|&
name|e
argument_list|,
name|true
argument_list|,
name|rpool
argument_list|)
expr_stmt|;
name|e
operator|.
name|e_flags
operator||=
name|EF_QUEUERUN
operator||
name|EF_GLOBALERRS
expr_stmt|;
name|set_delivery_mode
argument_list|(
name|SM_DELIVER
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|e
operator|.
name|e_errormode
operator|=
name|EM_MAIL
expr_stmt|;
name|e
operator|.
name|e_id
operator|=
name|ei
operator|->
name|e_id
expr_stmt|;
name|e
operator|.
name|e_qgrp
operator|=
name|ei
operator|->
name|e_qgrp
expr_stmt|;
name|e
operator|.
name|e_qdir
operator|=
name|ei
operator|->
name|e_qdir
expr_stmt|;
name|openxscript
argument_list|(
operator|&
name|e
argument_list|)
expr_stmt|;
name|sm_setproctitle
argument_list|(
name|true
argument_list|,
operator|&
name|e
argument_list|,
literal|"%s from queue"
argument_list|,
name|qid_printname
argument_list|(
operator|&
name|e
argument_list|)
argument_list|)
expr_stmt|;
comment|/* don't use the headers from sendmail.cf... */
name|e
operator|.
name|e_header
operator|=
name|NULL
expr_stmt|;
name|CurEnv
operator|=
operator|&
name|e
expr_stmt|;
comment|/* read the queue control file -- return if locked */
if|if
condition|(
name|readqf
argument_list|(
operator|&
name|e
argument_list|,
name|false
argument_list|)
condition|)
block|{
name|e
operator|.
name|e_flags
operator||=
name|EF_INQUEUE
expr_stmt|;
name|eatheader
argument_list|(
operator|&
name|e
argument_list|,
name|requeueflag
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|requeueflag
condition|)
name|queueup
argument_list|(
operator|&
name|e
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* do the delivery */
name|sendall
argument_list|(
operator|&
name|e
argument_list|,
name|SM_DELIVER
argument_list|)
expr_stmt|;
name|dropenvelope
argument_list|(
operator|&
name|e
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|4
argument_list|)
operator|&&
name|e
operator|.
name|e_id
operator|!=
name|NULL
condition|)
name|sm_dprintf
argument_list|(
literal|"readqf(%s) failed\n"
argument_list|,
name|qid_printname
argument_list|(
operator|&
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sm_rpool_free
argument_list|(
name|rpool
argument_list|)
expr_stmt|;
name|ei
operator|->
name|e_id
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* restore CurEnv */
name|CurEnv
operator|=
name|el
expr_stmt|;
comment|/* finish up and exit */
if|if
condition|(
name|forkflag
condition|)
name|finis
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* **  READQF -- read queue file and set up environment. ** **	Parameters: **		e -- the envelope of the job to run. **		openonly -- only open the qf (returned as e_lockfp) ** **	Returns: **		true if it successfully read the queue file. **		false otherwise. ** **	Side Effects: **		The queue file is returned locked. */
end_comment

begin_function
specifier|static
name|bool
name|readqf
parameter_list|(
name|e
parameter_list|,
name|openonly
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|bool
name|openonly
decl_stmt|;
block|{
specifier|register
name|SM_FILE_T
modifier|*
name|qfp
decl_stmt|;
name|ADDRESS
modifier|*
name|ctladdr
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|,
name|stf
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
name|int
name|qfver
init|=
literal|0
decl_stmt|;
name|long
name|hdrsize
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|frcpt
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|orcpt
init|=
name|NULL
decl_stmt|;
name|bool
name|nomore
init|=
name|false
decl_stmt|;
name|bool
name|bogus
init|=
name|false
decl_stmt|;
name|MODE_T
name|qsafe
decl_stmt|;
name|char
modifier|*
name|err
decl_stmt|;
name|char
name|qf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
comment|/* 	**  Read and process the file. 	*/
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|qf
argument_list|,
name|queuename
argument_list|(
name|e
argument_list|,
name|ANYQFL_LETTER
argument_list|)
argument_list|,
sizeof|sizeof
name|qf
argument_list|)
expr_stmt|;
name|qfp
operator|=
name|sm_io_open
argument_list|(
name|SmFtStdio
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|qf
argument_list|,
name|SM_IO_RDWR_B
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|qfp
operator|==
name|NULL
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|8
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"readqf(%s): sm_io_open failure (%s)\n"
argument_list|,
name|qf
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|syserr
argument_list|(
literal|"readqf: no control file %s"
argument_list|,
name|qf
argument_list|)
expr_stmt|;
name|RELEASE_QUEUE
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|lockfile
argument_list|(
name|sm_io_getinfo
argument_list|(
name|qfp
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|qf
argument_list|,
name|NULL
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
condition|)
block|{
comment|/* being processed by another queuer */
if|if
condition|(
name|Verbose
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s: locked\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|8
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"%s: locked\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|19
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"locked"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|qfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
name|RELEASE_QUEUE
expr_stmt|;
return|return
name|false
return|;
block|}
name|RELEASE_QUEUE
expr_stmt|;
comment|/* 	**  Prevent locking race condition. 	** 	**  Process A: readqf(): qfp = fopen(qffile) 	**  Process B: queueup(): rename(tf, qf) 	**  Process B: unlocks(tf) 	**  Process A: lockfile(qf); 	** 	**  Process A (us) has the old qf file (before the rename deleted 	**  the directory entry) and will be delivering based on old data. 	**  This can lead to multiple deliveries of the same recipients. 	** 	**  Catch this by checking if the underlying qf file has changed 	**  *after* acquiring our lock and if so, act as though the file 	**  was still locked (i.e., just return like the lockfile() case 	**  above. 	*/
if|if
condition|(
name|stat
argument_list|(
name|qf
argument_list|,
operator|&
name|stf
argument_list|)
operator|<
literal|0
operator|||
name|fstat
argument_list|(
name|sm_io_getinfo
argument_list|(
name|qfp
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* must have been being processed by someone else */
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|8
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"readqf(%s): [f]stat failure (%s)\n"
argument_list|,
name|qf
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|qfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|st
operator|.
name|st_nlink
operator|!=
name|stf
operator|.
name|st_nlink
operator|||
name|st
operator|.
name|st_dev
operator|!=
name|stf
operator|.
name|st_dev
operator|||
name|ST_INODE
argument_list|(
name|st
argument_list|)
operator|!=
name|ST_INODE
argument_list|(
name|stf
argument_list|)
operator|||
if|#
directive|if
name|HAS_ST_GEN
operator|&&
literal|0
comment|/* AFS returns garbage in st_gen */
name|st
operator|.
name|st_gen
operator|!=
name|stf
operator|.
name|st_gen
operator|||
endif|#
directive|endif
comment|/* HAS_ST_GEN&& 0 */
name|st
operator|.
name|st_uid
operator|!=
name|stf
operator|.
name|st_uid
operator|||
name|st
operator|.
name|st_gid
operator|!=
name|stf
operator|.
name|st_gid
operator|||
name|st
operator|.
name|st_size
operator|!=
name|stf
operator|.
name|st_size
condition|)
block|{
comment|/* changed after opened */
if|if
condition|(
name|Verbose
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s: changed\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|8
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"%s: changed\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|19
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"changed"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|qfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* 	**  Check the queue file for plausibility to avoid attacks. 	*/
name|qsafe
operator|=
name|S_IWOTH
operator||
name|S_IWGRP
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|S_IWGRP
argument_list|,
name|QueueFileMode
argument_list|)
condition|)
name|qsafe
operator|&=
operator|~
name|S_IWGRP
expr_stmt|;
name|bogus
operator|=
name|st
operator|.
name|st_uid
operator|!=
name|geteuid
argument_list|()
operator|&&
name|st
operator|.
name|st_uid
operator|!=
name|TrustedUid
operator|&&
name|geteuid
argument_list|()
operator|!=
name|RealUid
expr_stmt|;
comment|/* 	**  If this qf file results from a set-group-ID binary, then 	**  we check whether the directory is group-writable, 	**  the queue file mode contains the group-writable bit, and 	**  the groups are the same. 	**  Notice: this requires that the set-group-ID binary is used to 	**  run the queue! 	*/
if|if
condition|(
name|bogus
operator|&&
name|st
operator|.
name|st_gid
operator|==
name|getegid
argument_list|()
operator|&&
name|UseMSP
condition|)
block|{
name|char
name|delim
decl_stmt|;
name|struct
name|stat
name|dst
decl_stmt|;
name|bp
operator|=
name|SM_LAST_DIR_DELIM
argument_list|(
name|qf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
name|delim
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
name|delim
operator|=
operator|*
name|bp
expr_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|delim
operator|==
literal|'\0'
condition|?
literal|"."
else|:
name|qf
argument_list|,
operator|&
name|dst
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"readqf: cannot stat directory %s"
argument_list|,
name|delim
operator|==
literal|'\0'
condition|?
literal|"."
else|:
name|qf
argument_list|)
expr_stmt|;
else|else
block|{
name|bogus
operator|=
operator|!
operator|(
name|bitset
argument_list|(
name|S_IWGRP
argument_list|,
name|QueueFileMode
argument_list|)
operator|&&
name|bitset
argument_list|(
name|S_IWGRP
argument_list|,
name|dst
operator|.
name|st_mode
argument_list|)
operator|&&
name|dst
operator|.
name|st_gid
operator|==
name|st
operator|.
name|st_gid
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|delim
operator|!=
literal|'\0'
condition|)
operator|*
name|bp
operator|=
name|delim
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bogus
condition|)
name|bogus
operator|=
name|bitset
argument_list|(
name|qsafe
argument_list|,
name|st
operator|.
name|st_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|bogus
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|0
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_ALERT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"bogus queue file, uid=%d, gid=%d, mode=%o"
argument_list|,
name|st
operator|.
name|st_uid
argument_list|,
name|st
operator|.
name|st_gid
argument_list|,
name|st
operator|.
name|st_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|8
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"readqf(%s): bogus file\n"
argument_list|,
name|qf
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_INQUEUE
expr_stmt|;
if|if
condition|(
operator|!
name|openonly
condition|)
name|loseqfile
argument_list|(
name|e
argument_list|,
literal|"bogus file uid/gid in mqueue"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|qfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|st
operator|.
name|st_size
operator|==
literal|0
condition|)
block|{
comment|/* must be a bogus file -- if also old, just remove it */
if|if
condition|(
operator|!
name|openonly
operator|&&
name|st
operator|.
name|st_ctime
operator|+
literal|10
operator|*
literal|60
operator|<
name|curtime
argument_list|()
condition|)
block|{
operator|(
name|void
operator|)
name|xunlink
argument_list|(
name|queuename
argument_list|(
name|e
argument_list|,
name|DATAFL_LETTER
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xunlink
argument_list|(
name|queuename
argument_list|(
name|e
argument_list|,
name|ANYQFL_LETTER
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|qfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|st
operator|.
name|st_nlink
operator|==
literal|0
condition|)
block|{
comment|/* 		**  Race condition -- we got a file just as it was being 		**  unlinked.  Just assume it is zero length. 		*/
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|qfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|#
directive|if
name|_FFR_TRUSTED_QF
comment|/* 	**  If we don't own the file mark it as unsafe. 	**  However, allow TrustedUser to own it as well 	**  in case TrustedUser manipulates the queue. 	*/
if|if
condition|(
name|st
operator|.
name|st_uid
operator|!=
name|geteuid
argument_list|()
operator|&&
name|st
operator|.
name|st_uid
operator|!=
name|TrustedUid
condition|)
name|e
operator|->
name|e_flags
operator||=
name|EF_UNSAFE
expr_stmt|;
else|#
directive|else
comment|/* _FFR_TRUSTED_QF */
comment|/* If we don't own the file mark it as unsafe */
if|if
condition|(
name|st
operator|.
name|st_uid
operator|!=
name|geteuid
argument_list|()
condition|)
name|e
operator|->
name|e_flags
operator||=
name|EF_UNSAFE
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_TRUSTED_QF */
comment|/* good file -- save this lock */
name|e
operator|->
name|e_lockfp
operator|=
name|qfp
expr_stmt|;
comment|/* Just wanted the open file */
if|if
condition|(
name|openonly
condition|)
return|return
name|true
return|;
comment|/* do basic system initialization */
name|initsys
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'i'
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
name|LineNumber
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_GLOBALERRS
expr_stmt|;
name|set_op_mode
argument_list|(
name|MD_QUEUERUN
argument_list|)
expr_stmt|;
name|ctladdr
operator|=
name|NULL
expr_stmt|;
name|e
operator|->
name|e_qfletter
operator|=
name|queue_letter
argument_list|(
name|e
argument_list|,
name|ANYQFL_LETTER
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_dfqgrp
operator|=
name|e
operator|->
name|e_qgrp
expr_stmt|;
name|e
operator|->
name|e_dfqdir
operator|=
name|e
operator|->
name|e_qdir
expr_stmt|;
if|#
directive|if
name|_FFR_QUEUE_MACRO
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{queue}"
argument_list|)
argument_list|,
name|qid_printqueue
argument_list|(
name|e
operator|->
name|e_qgrp
argument_list|,
name|e
operator|->
name|e_qdir
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_QUEUE_MACRO */
name|e
operator|->
name|e_dfino
operator|=
operator|-
literal|1
expr_stmt|;
name|e
operator|->
name|e_msgsize
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|=
name|fgetfolded
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|qfp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|long
name|qflags
decl_stmt|;
name|ADDRESS
modifier|*
name|q
decl_stmt|;
name|int
name|r
decl_stmt|;
name|time_t
name|now
decl_stmt|;
specifier|auto
name|char
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|4
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"+++++ %s\n"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nomore
condition|)
block|{
comment|/* hack attack */
name|hackattack
label|:
name|syserr
argument_list|(
literal|"SECURITY ALERT: extra or bogus data in queue file: %s"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|err
operator|=
literal|"bogus queue line"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
switch|switch
condition|(
name|bp
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'A'
case|:
comment|/* AUTH= parameter */
if|if
condition|(
operator|!
name|xtextok
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
condition|)
goto|goto
name|hackattack
goto|;
name|e
operator|->
name|e_auth_param
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* body type */
name|r
operator|=
name|check_bodytype
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BODYTYPE_VALID
argument_list|(
name|r
argument_list|)
condition|)
goto|goto
name|hackattack
goto|;
name|e
operator|->
name|e_bodytype
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* specify controlling user */
name|ctladdr
operator|=
name|setctluser
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|,
name|qfver
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* data file name */
comment|/* obsolete -- ignore */
break|break;
case|case
literal|'d'
case|:
comment|/* data file directory name */
block|{
name|int
name|qgrp
decl_stmt|,
name|qdir
decl_stmt|;
if|#
directive|if
name|_FFR_MSP_PARANOIA
comment|/* forbid queue groups in MSP? */
if|if
condition|(
name|UseMSP
condition|)
goto|goto
name|hackattack
goto|;
endif|#
directive|endif
comment|/* _FFR_MSP_PARANOIA */
for|for
control|(
name|qgrp
operator|=
literal|0
init|;
name|qgrp
operator|<
name|NumQueue
operator|&&
name|Queue
index|[
name|qgrp
index|]
operator|!=
name|NULL
condition|;
operator|++
name|qgrp
control|)
block|{
for|for
control|(
name|qdir
operator|=
literal|0
init|;
name|qdir
operator|<
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_numqueues
condition|;
operator|++
name|qdir
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|,
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_qpaths
index|[
name|qdir
index|]
operator|.
name|qp_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|e
operator|->
name|e_dfqgrp
operator|=
name|qgrp
expr_stmt|;
name|e
operator|->
name|e_dfqdir
operator|=
name|qdir
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
name|err
operator|=
literal|"bogus queue file directory"
expr_stmt|;
goto|goto
name|fail
goto|;
name|done
label|:
break|break;
block|}
case|case
literal|'E'
case|:
comment|/* specify error recipient */
comment|/* no longer used */
break|break;
case|case
literal|'F'
case|:
comment|/* flag bits */
if|if
condition|(
name|strncmp
argument_list|(
name|bp
argument_list|,
literal|"From "
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* we are being spoofed! */
name|syserr
argument_list|(
literal|"SECURITY ALERT: bogus qf line %s"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|err
operator|=
literal|"bogus queue line"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|p
operator|=
operator|&
name|bp
index|[
literal|1
index|]
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'8'
case|:
comment|/* has 8 bit data */
name|e
operator|->
name|e_flags
operator||=
name|EF_HAS8BIT
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* delete Bcc: header */
name|e
operator|->
name|e_flags
operator||=
name|EF_DELETE_BCC
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* envelope has DSN RET= */
name|e
operator|->
name|e_flags
operator||=
name|EF_RET_PARAM
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* don't return body */
name|e
operator|->
name|e_flags
operator||=
name|EF_NO_BODY_RETN
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* response */
name|e
operator|->
name|e_flags
operator||=
name|EF_RESPONSE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* split */
name|e
operator|->
name|e_flags
operator||=
name|EF_SPLIT
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* warning sent */
name|e
operator|->
name|e_flags
operator||=
name|EF_WARNING
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
literal|'q'
case|:
comment|/* quarantine reason */
name|e
operator|->
name|e_quarmsg
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{quarantine}"
argument_list|)
argument_list|,
name|e
operator|->
name|e_quarmsg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* header */
comment|/* 			**  count size before chompheader() destroys the line. 			**  this isn't accurate due to macro expansion, but 			**  better than before. "-3" to skip H?? at least. 			*/
name|hdrsize
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
operator|-
literal|3
expr_stmt|;
operator|(
name|void
operator|)
name|chompheader
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|,
name|CHHDR_QUEUE
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* data file's inode number */
comment|/* regenerated below */
break|break;
case|case
literal|'K'
case|:
comment|/* time of last delivery attempt */
name|e
operator|->
name|e_dtime
operator|=
name|atol
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* Solaris Content-Length: */
case|case
literal|'M'
case|:
comment|/* message */
comment|/* ignore this; we want a new message next time */
break|break;
case|case
literal|'N'
case|:
comment|/* number of delivery attempts */
name|e
operator|->
name|e_ntries
operator|=
name|atoi
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* if this has been tried recently, let it be */
name|now
operator|=
name|curtime
argument_list|()
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_ntries
operator|>
literal|0
operator|&&
name|e
operator|->
name|e_dtime
operator|<=
name|now
operator|&&
name|now
operator|<
name|e
operator|->
name|e_dtime
operator|+
name|MinQueueAge
condition|)
block|{
name|char
modifier|*
name|howlong
decl_stmt|;
name|howlong
operator|=
name|pintvl
argument_list|(
name|now
operator|-
name|e
operator|->
name|e_dtime
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s: too young (%s)\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|howlong
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|8
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"%s: too young (%s)\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|howlong
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|19
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"too young (%s)"
argument_list|,
name|howlong
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_id
operator|=
name|NULL
expr_stmt|;
name|unlockqueue
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{ntries}"
argument_list|)
argument_list|,
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
name|NAMED_BIND
comment|/* adjust BIND parameters immediately */
if|if
condition|(
name|e
operator|->
name|e_ntries
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|retry
operator|=
name|TimeOuts
operator|.
name|res_retry
index|[
name|RES_TO_FIRST
index|]
expr_stmt|;
name|_res
operator|.
name|retrans
operator|=
name|TimeOuts
operator|.
name|res_retrans
index|[
name|RES_TO_FIRST
index|]
expr_stmt|;
block|}
else|else
block|{
name|_res
operator|.
name|retry
operator|=
name|TimeOuts
operator|.
name|res_retry
index|[
name|RES_TO_NORMAL
index|]
expr_stmt|;
name|_res
operator|.
name|retrans
operator|=
name|TimeOuts
operator|.
name|res_retrans
index|[
name|RES_TO_NORMAL
index|]
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NAMED_BIND */
break|break;
case|case
literal|'P'
case|:
comment|/* message priority */
name|e
operator|->
name|e_msgpriority
operator|=
name|atol
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
operator|+
name|WkTimeFact
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
comment|/* original recipient */
name|orcpt
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* final recipient */
name|frcpt
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* specify recipient */
name|p
operator|=
name|bp
expr_stmt|;
name|qflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|qfver
operator|>=
literal|1
condition|)
block|{
comment|/* get flag bits */
while|while
condition|(
operator|*
operator|++
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'N'
case|:
name|qflags
operator||=
name|QHASNOTIFY
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|qflags
operator||=
name|QPINGONSUCCESS
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|qflags
operator||=
name|QPINGONFAILURE
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|qflags
operator||=
name|QPINGONDELAY
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|qflags
operator||=
name|QPRIMARY
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
if|if
condition|(
name|ctladdr
operator|!=
name|NULL
condition|)
name|ctladdr
operator|->
name|q_flags
operator||=
name|QALIAS
expr_stmt|;
break|break;
default|default:
comment|/* ignore or complain? */
break|break;
block|}
block|}
block|}
else|else
name|qflags
operator||=
name|QPRIMARY
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{addr_type}"
argument_list|)
argument_list|,
literal|"e r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|q
operator|=
name|parseaddr
argument_list|(
operator|++
name|p
argument_list|,
name|NULLADDR
argument_list|,
name|RF_COPYALL
argument_list|,
literal|'\0'
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
name|true
argument_list|)
expr_stmt|;
else|else
name|q
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
block|{
comment|/* make sure we keep the current qgrp */
if|if
condition|(
name|ISVALIDQGRP
argument_list|(
name|e
operator|->
name|e_qgrp
argument_list|)
condition|)
name|q
operator|->
name|q_qgrp
operator|=
name|e
operator|->
name|e_qgrp
expr_stmt|;
name|q
operator|->
name|q_alias
operator|=
name|ctladdr
expr_stmt|;
if|if
condition|(
name|qfver
operator|>=
literal|1
condition|)
name|q
operator|->
name|q_flags
operator|&=
operator|~
name|Q_PINGFLAGS
expr_stmt|;
name|q
operator|->
name|q_flags
operator||=
name|qflags
expr_stmt|;
name|q
operator|->
name|q_finalrcpt
operator|=
name|frcpt
expr_stmt|;
name|q
operator|->
name|q_orcpt
operator|=
name|orcpt
expr_stmt|;
operator|(
name|void
operator|)
name|recipient
argument_list|(
name|q
argument_list|,
operator|&
name|e
operator|->
name|e_sendqueue
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|frcpt
operator|=
name|NULL
expr_stmt|;
name|orcpt
operator|=
name|NULL
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{addr_type}"
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* sender */
name|setsender
argument_list|(
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|e
argument_list|,
name|NULL
argument_list|,
literal|'\0'
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* init time */
name|e
operator|->
name|e_ctime
operator|=
name|atol
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
comment|/* queue file version number */
name|qfver
operator|=
name|atoi
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|qfver
operator|<=
name|QF_VERSION
condition|)
break|break;
name|syserr
argument_list|(
literal|"Version number in queue file (%d) greater than max (%d)"
argument_list|,
name|qfver
argument_list|,
name|QF_VERSION
argument_list|)
expr_stmt|;
name|err
operator|=
literal|"unsupported queue file version"
expr_stmt|;
goto|goto
name|fail
goto|;
comment|/* NOTREACHED */
break|break;
case|case
literal|'Z'
case|:
comment|/* original envelope id from ESMTP */
name|e
operator|->
name|e_envid
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{dsn_envid}"
argument_list|)
argument_list|,
name|e
operator|->
name|e_envid
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
comment|/* deliver by */
comment|/* format: flag (1 char) space long-integer */
name|e
operator|->
name|e_dlvr_flag
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|e
operator|->
name|e_deliver_by
operator|=
name|strtol
argument_list|(
operator|&
name|buf
index|[
literal|3
index|]
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
case|case
literal|'$'
case|:
comment|/* define macro */
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* XXX elimate p? */
name|r
operator|=
name|macid_parse
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|,
operator|&
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
break|break;
name|p
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|r
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'.'
case|:
comment|/* terminate file */
name|nomore
operator|=
name|true
expr_stmt|;
break|break;
if|#
directive|if
name|_FFR_QUEUEDELAY
case|case
literal|'G'
case|:
case|case
literal|'Y'
case|:
comment|/* 			**  Maintain backward compatibility for 			**  users who defined _FFR_QUEUEDELAY in 			**  previous releases.  Remove this 			**  code in 8.14 or 8.15. 			*/
if|if
condition|(
name|qfver
operator|==
literal|5
operator|||
name|qfver
operator|==
literal|7
condition|)
break|break;
comment|/* If not qfver 5 or 7, then 'G' or 'Y' is invalid */
comment|/* FALLTHROUGH */
endif|#
directive|endif
comment|/* _FFR_QUEUEDELAY */
default|default:
name|syserr
argument_list|(
literal|"readqf: %s: line %d: bad line \"%s\""
argument_list|,
name|qf
argument_list|,
name|LineNumber
argument_list|,
name|shortenstring
argument_list|(
name|bp
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
literal|"unrecognized line"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|bp
operator|!=
name|buf
condition|)
name|sm_free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
comment|/* 	**  If we haven't read any lines, this queue file is empty. 	**  Arrange to remove it without referencing any null pointers. 	*/
if|if
condition|(
name|LineNumber
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_CLRQUEUE
operator||
name|EF_FATALERRS
operator||
name|EF_RESPONSE
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Check to make sure we have a complete queue file read */
if|if
condition|(
operator|!
name|nomore
condition|)
block|{
name|syserr
argument_list|(
literal|"readqf: %s: incomplete queue file read"
argument_list|,
name|qf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|qfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* possibly set ${dsn_ret} macro */
if|if
condition|(
name|bitset
argument_list|(
name|EF_RET_PARAM
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|EF_NO_BODY_RETN
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{dsn_ret}"
argument_list|)
argument_list|,
literal|"hdrs"
argument_list|)
expr_stmt|;
else|else
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{dsn_ret}"
argument_list|)
argument_list|,
literal|"full"
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Arrange to read the data file. 	*/
name|p
operator|=
name|queuename
argument_list|(
name|e
argument_list|,
name|DATAFL_LETTER
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_dfp
operator|=
name|sm_io_open
argument_list|(
name|SmFtStdio
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|p
argument_list|,
name|SM_IO_RDONLY_B
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"readqf: cannot open %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e
operator|->
name|e_flags
operator||=
name|EF_HAS_DF
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|sm_io_getinfo
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|e
operator|->
name|e_msgsize
operator|=
name|st
operator|.
name|st_size
operator|+
name|hdrsize
expr_stmt|;
name|e
operator|->
name|e_dfdev
operator|=
name|st
operator|.
name|st_dev
expr_stmt|;
name|e
operator|->
name|e_dfino
operator|=
name|ST_INODE
argument_list|(
name|st
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"%ld"
argument_list|,
name|e
operator|->
name|e_msgsize
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{msg_size}"
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
name|fail
label|:
comment|/* 	**  There was some error reading the qf file (reason is in err var.) 	**  Cleanup: 	**	close file; clear e_lockfp since it is the same as qfp, 	**	hence it is invalid (as file) after qfp is closed; 	**	the qf file is on disk, so set the flag to avoid calling 	**	queueup() with bogus data. 	*/
if|if
condition|(
name|qfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|qfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_lockfp
operator|=
name|NULL
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_INQUEUE
expr_stmt|;
name|loseqfile
argument_list|(
name|e
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* **  PRTSTR -- print a string, "unprintable" characters are shown as \oct ** **	Parameters: **		s -- string to print **		ml -- maximum length of output ** **	Returns: **		number of entries ** **	Side Effects: **		Prints a string on stdout. */
end_comment

begin_function
specifier|static
name|void
name|prtstr
parameter_list|(
name|s
parameter_list|,
name|ml
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|ml
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
name|ml
operator|--
operator|>
literal|0
operator|&&
operator|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|ml
operator|--
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isascii
argument_list|(
name|c
argument_list|)
operator|&&
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|ml
operator|-=
literal|3
operator|)
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\\%03o"
argument_list|,
name|c
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* **  PRINTNQE -- print out number of entries in the mail queue ** **	Parameters: **		out -- output file pointer. **		prefix -- string to output in front of each line. ** **	Returns: **		none. */
end_comment

begin_function
name|void
name|printnqe
parameter_list|(
name|out
parameter_list|,
name|prefix
parameter_list|)
name|SM_FILE_T
modifier|*
name|out
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
block|{
if|#
directive|if
name|SM_CONF_SHM
name|int
name|i
decl_stmt|,
name|k
init|=
literal|0
decl_stmt|,
name|nrequests
init|=
literal|0
decl_stmt|;
name|bool
name|unknown
init|=
name|false
decl_stmt|;
if|if
condition|(
name|ShmId
operator|==
name|SM_SHM_NO_ID
condition|)
block|{
if|if
condition|(
name|prefix
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Data unavailable: shared memory not updated\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%sNOTCONFIGURED:-1\r\n"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NumQueue
operator|&&
name|Queue
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|k
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|Queue
index|[
name|i
index|]
operator|->
name|qg_numqueues
condition|;
name|j
operator|++
control|)
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|StopRequest
condition|)
name|stop_sendmail
argument_list|()
expr_stmt|;
name|n
operator|=
name|QSHM_ENTRIES
argument_list|(
name|Queue
index|[
name|i
index|]
operator|->
name|qg_qpaths
index|[
name|j
index|]
operator|.
name|qp_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s%s:%d\r\n"
argument_list|,
name|prefix
argument_list|,
name|qid_printqueue
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s: unknown number of entries\n"
argument_list|,
name|qid_printqueue
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|unknown
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s is empty\n"
argument_list|,
name|qid_printqueue
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s: entries=%d\n"
argument_list|,
name|qid_printqueue
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|nrequests
operator|+=
name|n
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|prefix
operator|==
name|NULL
operator|&&
name|k
operator|>
literal|1
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\t\tTotal requests: %d%s\n"
argument_list|,
name|nrequests
argument_list|,
name|unknown
condition|?
literal|" (about)"
else|:
literal|""
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SM_CONF_SHM */
if|if
condition|(
name|prefix
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Data unavailable without shared memory support\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%sNOTAVAILABLE:-1\r\n"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SM_CONF_SHM */
block|}
end_function

begin_comment
comment|/* **  PRINTQUEUE -- print out a representation of the mail queue ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		Prints a listing of the mail queue on the standard output. */
end_comment

begin_function
name|void
name|printqueue
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|k
init|=
literal|0
decl_stmt|,
name|nrequests
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NumQueue
operator|&&
name|Queue
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|k
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|Queue
index|[
name|i
index|]
operator|->
name|qg_numqueues
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|StopRequest
condition|)
name|stop_sendmail
argument_list|()
expr_stmt|;
name|nrequests
operator|+=
name|print_single_queue
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|k
operator|>
literal|1
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\t\tTotal requests: %d\n"
argument_list|,
name|nrequests
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  PRINT_SINGLE_QUEUE -- print out a representation of a single mail queue ** **	Parameters: **		qgrp -- the index of the queue group. **		qdir -- the queue directory. ** **	Returns: **		number of requests in mail queue. ** **	Side Effects: **		Prints a listing of the mail queue on the standard output. */
end_comment

begin_function
name|int
name|print_single_queue
parameter_list|(
name|qgrp
parameter_list|,
name|qdir
parameter_list|)
name|int
name|qgrp
decl_stmt|;
name|int
name|qdir
decl_stmt|;
block|{
specifier|register
name|WORK
modifier|*
name|w
decl_stmt|;
name|SM_FILE_T
modifier|*
name|f
decl_stmt|;
name|int
name|nrequests
decl_stmt|;
name|char
name|qd
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|qddf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
if|if
condition|(
name|qdir
operator|==
name|NOQDIR
condition|)
block|{
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|qd
argument_list|,
literal|"."
argument_list|,
sizeof|sizeof
name|qd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|qddf
argument_list|,
literal|"."
argument_list|,
sizeof|sizeof
name|qddf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|qd
argument_list|,
sizeof|sizeof
name|qd
argument_list|,
literal|2
argument_list|,
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_qpaths
index|[
name|qdir
index|]
operator|.
name|qp_name
argument_list|,
operator|(
name|bitset
argument_list|(
name|QP_SUBQF
argument_list|,
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_qpaths
index|[
name|qdir
index|]
operator|.
name|qp_subdirs
argument_list|)
condition|?
literal|"/qf"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|qddf
argument_list|,
sizeof|sizeof
name|qddf
argument_list|,
literal|2
argument_list|,
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_qpaths
index|[
name|qdir
index|]
operator|.
name|qp_name
argument_list|,
operator|(
name|bitset
argument_list|(
name|QP_SUBDF
argument_list|,
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_qpaths
index|[
name|qdir
index|]
operator|.
name|qp_subdirs
argument_list|)
condition|?
literal|"/df"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Check for permission to print the queue 	*/
if|if
condition|(
name|bitset
argument_list|(
name|PRIV_RESTRICTMAILQ
argument_list|,
name|PrivacyFlags
argument_list|)
operator|&&
name|RealUid
operator|!=
literal|0
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
ifdef|#
directive|ifdef
name|NGROUPS_MAX
name|int
name|n
decl_stmt|;
specifier|extern
name|GIDSET_T
name|InitialGidSet
index|[
name|NGROUPS_MAX
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* NGROUPS_MAX */
if|if
condition|(
name|stat
argument_list|(
name|qd
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"Cannot stat %s"
argument_list|,
name|qid_printqueue
argument_list|(
name|qgrp
argument_list|,
name|qdir
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|NGROUPS_MAX
name|n
operator|=
name|NGROUPS_MAX
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|InitialGidSet
index|[
name|n
index|]
operator|==
name|st
operator|.
name|st_gid
condition|)
break|break;
block|}
if|if
condition|(
name|n
operator|<
literal|0
operator|&&
name|RealGid
operator|!=
name|st
operator|.
name|st_gid
condition|)
else|#
directive|else
comment|/* NGROUPS_MAX */
if|if
condition|(
name|RealGid
operator|!=
name|st
operator|.
name|st_gid
condition|)
endif|#
directive|endif
comment|/* NGROUPS_MAX */
block|{
name|usrerr
argument_list|(
literal|"510 You are not permitted to see the queue"
argument_list|)
expr_stmt|;
name|setstat
argument_list|(
name|EX_NOPERM
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* 	**  Read and order the queue. 	*/
name|nrequests
operator|=
name|gatherq
argument_list|(
name|qgrp
argument_list|,
name|qdir
argument_list|,
name|true
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sortq
argument_list|(
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_maxlist
argument_list|)
expr_stmt|;
comment|/* 	**  Print the work list that we have read. 	*/
comment|/* first see if there is anything */
if|if
condition|(
name|nrequests
operator|<=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s is empty\n"
argument_list|,
name|qid_printqueue
argument_list|(
name|qgrp
argument_list|,
name|qdir
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sm_getla
argument_list|()
expr_stmt|;
comment|/* get load average */
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\t\t%s (%d request%s"
argument_list|,
name|qid_printqueue
argument_list|(
name|qgrp
argument_list|,
name|qdir
argument_list|)
argument_list|,
name|nrequests
argument_list|,
name|nrequests
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|MaxQueueRun
operator|>
literal|0
operator|&&
name|nrequests
operator|>
name|MaxQueueRun
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|", only %d printed"
argument_list|,
name|MaxQueueRun
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|")\n-----Q-ID----- --Size-- -Priority- ---Q-Time--- --------Sender/Recipient--------\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|")\n-----Q-ID----- --Size-- -----Q-Time----- ------------Sender/Recipient-----------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|w
operator|=
name|WorkQ
init|;
name|w
operator|!=
name|NULL
condition|;
name|w
operator|=
name|w
operator|->
name|w_next
control|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
specifier|auto
name|time_t
name|submittime
init|=
literal|0
decl_stmt|;
name|long
name|dfsize
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|int
name|qfver
decl_stmt|;
name|char
name|quarmsg
index|[
name|MAXLINE
index|]
decl_stmt|;
name|char
name|statmsg
index|[
name|MAXLINE
index|]
decl_stmt|;
name|char
name|bodytype
index|[
name|MAXNAME
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|qf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
name|StopRequest
condition|)
name|stop_sendmail
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%13s"
argument_list|,
name|w
operator|->
name|w_name
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|qf
argument_list|,
sizeof|sizeof
name|qf
argument_list|,
literal|3
argument_list|,
name|qd
argument_list|,
literal|"/"
argument_list|,
name|w
operator|->
name|w_name
argument_list|)
expr_stmt|;
name|f
operator|=
name|sm_io_open
argument_list|(
name|SmFtStdio
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|qf
argument_list|,
name|SM_IO_RDONLY_B
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EPERM
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|" (permission denied)\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|" (job completed)\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|" (%s)\n"
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|w
operator|->
name|w_name
index|[
literal|0
index|]
operator|=
name|DATAFL_LETTER
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|qf
argument_list|,
sizeof|sizeof
name|qf
argument_list|,
literal|3
argument_list|,
name|qddf
argument_list|,
literal|"/"
argument_list|,
name|w
operator|->
name|w_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|qf
argument_list|,
operator|&
name|st
argument_list|)
operator|>=
literal|0
condition|)
name|dfsize
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
else|else
block|{
name|ENVELOPE
name|e
decl_stmt|;
comment|/* 			**  Maybe the df file can't be statted because 			**  it is in a different directory than the qf file. 			**  In order to find out, we must read the qf file. 			*/
name|newenvelope
argument_list|(
operator|&
name|e
argument_list|,
operator|&
name|BlankEnvelope
argument_list|,
name|sm_rpool_new_x
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|e_id
operator|=
name|w
operator|->
name|w_name
operator|+
literal|2
expr_stmt|;
name|e
operator|.
name|e_qgrp
operator|=
name|qgrp
expr_stmt|;
name|e
operator|.
name|e_qdir
operator|=
name|qdir
expr_stmt|;
name|dfsize
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|readqf
argument_list|(
operator|&
name|e
argument_list|,
name|false
argument_list|)
condition|)
block|{
name|char
modifier|*
name|df
init|=
name|queuename
argument_list|(
operator|&
name|e
argument_list|,
name|DATAFL_LETTER
argument_list|)
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|df
argument_list|,
operator|&
name|st
argument_list|)
operator|>=
literal|0
condition|)
name|dfsize
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|.
name|e_lockfp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|e
operator|.
name|e_lockfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
name|e
operator|.
name|e_lockfp
operator|=
name|NULL
expr_stmt|;
block|}
name|clearenvelope
argument_list|(
operator|&
name|e
argument_list|,
name|false
argument_list|,
name|e
operator|.
name|e_rpool
argument_list|)
expr_stmt|;
name|sm_rpool_free
argument_list|(
name|e
operator|.
name|e_rpool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|->
name|w_lock
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|QueueMode
operator|==
name|QM_LOST
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"?"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|w
operator|->
name|w_tooyoung
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|shouldqueue
argument_list|(
name|w
operator|->
name|w_pri
argument_list|,
name|w
operator|->
name|w_ctime
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"X"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|quarmsg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|statmsg
index|[
literal|0
index|]
operator|=
name|bodytype
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|qfver
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sm_io_fgets
argument_list|(
name|f
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|StopRequest
condition|)
name|stop_sendmail
argument_list|()
expr_stmt|;
name|fixcrlf
argument_list|(
name|buf
argument_list|,
name|true
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'V'
case|:
comment|/* queue file version */
name|qfver
operator|=
name|atoi
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* error message */
if|if
condition|(
operator|(
name|i
operator|=
name|strlen
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
operator|)
operator|>=
sizeof|sizeof
name|statmsg
condition|)
name|i
operator|=
sizeof|sizeof
name|statmsg
operator|-
literal|1
expr_stmt|;
name|memmove
argument_list|(
name|statmsg
argument_list|,
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|statmsg
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* quarantine reason */
if|if
condition|(
operator|(
name|i
operator|=
name|strlen
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
operator|)
operator|>=
sizeof|sizeof
name|quarmsg
condition|)
name|i
operator|=
sizeof|sizeof
name|quarmsg
operator|-
literal|1
expr_stmt|;
name|memmove
argument_list|(
name|quarmsg
argument_list|,
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|quarmsg
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* body type */
if|if
condition|(
operator|(
name|i
operator|=
name|strlen
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
operator|)
operator|>=
sizeof|sizeof
name|bodytype
condition|)
name|i
operator|=
sizeof|sizeof
name|bodytype
operator|-
literal|1
expr_stmt|;
name|memmove
argument_list|(
name|bodytype
argument_list|,
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bodytype
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* sender name */
if|if
condition|(
name|Verbose
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%8ld %10ld%c%.12s "
argument_list|,
name|dfsize
argument_list|,
name|w
operator|->
name|w_pri
argument_list|,
name|bitset
argument_list|(
name|EF_WARNING
argument_list|,
name|flags
argument_list|)
condition|?
literal|'+'
else|:
literal|' '
argument_list|,
name|ctime
argument_list|(
operator|&
name|submittime
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|prtstr
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
literal|78
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%8ld %.16s "
argument_list|,
name|dfsize
argument_list|,
name|ctime
argument_list|(
operator|&
name|submittime
argument_list|)
argument_list|)
expr_stmt|;
name|prtstr
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
literal|39
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|quarmsg
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\n     QUARANTINE: %.*s"
argument_list|,
name|Verbose
condition|?
literal|100
else|:
literal|60
argument_list|,
name|quarmsg
argument_list|)
expr_stmt|;
name|quarmsg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|statmsg
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|||
name|bodytype
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\n    %10.10s"
argument_list|,
name|bodytype
argument_list|)
expr_stmt|;
if|if
condition|(
name|statmsg
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"   (%.*s)"
argument_list|,
name|Verbose
condition|?
literal|100
else|:
literal|60
argument_list|,
name|statmsg
argument_list|)
expr_stmt|;
name|statmsg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
break|break;
case|case
literal|'C'
case|:
comment|/* controlling user */
if|if
condition|(
name|Verbose
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\n\t\t\t\t\t\t(---%.64s---)"
argument_list|,
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* recipient name */
name|p
operator|=
operator|&
name|buf
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|qfver
operator|>=
literal|1
condition|)
block|{
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
break|break;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Verbose
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\n\t\t\t\t\t\t"
argument_list|)
expr_stmt|;
name|prtstr
argument_list|(
name|p
argument_list|,
literal|71
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\n\t\t\t\t\t "
argument_list|)
expr_stmt|;
name|prtstr
argument_list|(
name|p
argument_list|,
literal|38
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Verbose
operator|&&
name|statmsg
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\n\t\t (%.100s)"
argument_list|,
name|statmsg
argument_list|)
expr_stmt|;
name|statmsg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
break|break;
case|case
literal|'T'
case|:
comment|/* creation time */
name|submittime
operator|=
name|atol
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* flag bits */
for|for
control|(
name|p
operator|=
operator|&
name|buf
index|[
literal|1
index|]
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'w'
case|:
name|flags
operator||=
name|EF_WARNING
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|submittime
operator|==
operator|(
name|time_t
operator|)
literal|0
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|" (no control file)"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|f
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
block|}
return|return
name|nrequests
return|;
block|}
end_function

begin_comment
comment|/* **  QUEUE_LETTER -- get the proper queue letter for the current QueueMode. ** **	Parameters: **		e -- envelope to build it in/from. **		type -- the file type, used as the first character **			of the file name. ** **	Returns: **		the letter to use */
end_comment

begin_function
specifier|static
name|char
name|queue_letter
parameter_list|(
name|e
parameter_list|,
name|type
parameter_list|)
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
comment|/* Change type according to QueueMode */
if|if
condition|(
name|type
operator|==
name|ANYQFL_LETTER
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|e_quarmsg
operator|!=
name|NULL
condition|)
name|type
operator|=
name|QUARQF_LETTER
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|QueueMode
condition|)
block|{
case|case
name|QM_NORMAL
case|:
name|type
operator|=
name|NORMQF_LETTER
expr_stmt|;
break|break;
case|case
name|QM_QUARANTINE
case|:
name|type
operator|=
name|QUARQF_LETTER
expr_stmt|;
break|break;
case|case
name|QM_LOST
case|:
name|type
operator|=
name|LOSEQF_LETTER
expr_stmt|;
break|break;
default|default:
comment|/* should never happen */
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* **  QUEUENAME -- build a file name in the queue directory for this envelope. ** **	Parameters: **		e -- envelope to build it in/from. **		type -- the file type, used as the first character **			of the file name. ** **	Returns: **		a pointer to the queue name (in a static buffer). ** **	Side Effects: **		If no id code is already assigned, queuename() will **		assign an id code with assign_queueid().  If no queue **		directory is assigned, one will be set with setnewqueue(). */
end_comment

begin_function
name|char
modifier|*
name|queuename
parameter_list|(
name|e
parameter_list|,
name|type
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|int
name|qd
decl_stmt|,
name|qg
decl_stmt|;
name|char
modifier|*
name|sub
init|=
literal|"/"
decl_stmt|;
name|char
name|pref
index|[
literal|3
index|]
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
comment|/* Assign an ID if needed */
if|if
condition|(
name|e
operator|->
name|e_id
operator|==
name|NULL
condition|)
name|assign_queueid
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|type
operator|=
name|queue_letter
argument_list|(
name|e
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* begin of filename */
name|pref
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|type
expr_stmt|;
name|pref
index|[
literal|1
index|]
operator|=
literal|'f'
expr_stmt|;
name|pref
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Assign a queue group/directory if needed */
if|if
condition|(
name|type
operator|==
name|XSCRPT_LETTER
condition|)
block|{
comment|/* 		**  We don't want to call setnewqueue() if we are fetching 		**  the pathname of the transcript file, because setnewqueue 		**  chooses a queue, and sometimes we need to write to the 		**  transcript file before we have gathered enough information 		**  to choose a queue. 		*/
if|if
condition|(
name|e
operator|->
name|e_xfqgrp
operator|==
name|NOQGRP
operator|||
name|e
operator|->
name|e_xfqdir
operator|==
name|NOQDIR
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|e_qgrp
operator|!=
name|NOQGRP
operator|&&
name|e
operator|->
name|e_qdir
operator|!=
name|NOQDIR
condition|)
block|{
name|e
operator|->
name|e_xfqgrp
operator|=
name|e
operator|->
name|e_qgrp
expr_stmt|;
name|e
operator|->
name|e_xfqdir
operator|=
name|e
operator|->
name|e_qdir
expr_stmt|;
block|}
else|else
block|{
name|e
operator|->
name|e_xfqgrp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Queue
index|[
name|e
operator|->
name|e_xfqgrp
index|]
operator|->
name|qg_numqueues
operator|<=
literal|1
condition|)
name|e
operator|->
name|e_xfqdir
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|e
operator|->
name|e_xfqdir
operator|=
name|get_rand_mod
argument_list|(
name|Queue
index|[
name|e
operator|->
name|e_xfqgrp
index|]
operator|->
name|qg_numqueues
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|qd
operator|=
name|e
operator|->
name|e_xfqdir
expr_stmt|;
name|qg
operator|=
name|e
operator|->
name|e_xfqgrp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|e
operator|->
name|e_qgrp
operator|==
name|NOQGRP
operator|||
name|e
operator|->
name|e_qdir
operator|==
name|NOQDIR
condition|)
name|setnewqueue
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DATAFL_LETTER
condition|)
block|{
name|qd
operator|=
name|e
operator|->
name|e_dfqdir
expr_stmt|;
name|qg
operator|=
name|e
operator|->
name|e_dfqgrp
expr_stmt|;
block|}
else|else
block|{
name|qd
operator|=
name|e
operator|->
name|e_qdir
expr_stmt|;
name|qg
operator|=
name|e
operator|->
name|e_qgrp
expr_stmt|;
block|}
block|}
comment|/* xf files always have a valid qd and qg picked above */
if|if
condition|(
name|e
operator|->
name|e_qdir
operator|==
name|NOQDIR
operator|&&
name|type
operator|!=
name|XSCRPT_LETTER
condition|)
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|2
argument_list|,
name|pref
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DATAFL_LETTER
case|:
if|if
condition|(
name|bitset
argument_list|(
name|QP_SUBDF
argument_list|,
name|Queue
index|[
name|qg
index|]
operator|->
name|qg_qpaths
index|[
name|qd
index|]
operator|.
name|qp_subdirs
argument_list|)
condition|)
name|sub
operator|=
literal|"/df/"
expr_stmt|;
break|break;
case|case
name|QUARQF_LETTER
case|:
case|case
name|TEMPQF_LETTER
case|:
case|case
name|NEWQFL_LETTER
case|:
case|case
name|LOSEQF_LETTER
case|:
case|case
name|NORMQF_LETTER
case|:
if|if
condition|(
name|bitset
argument_list|(
name|QP_SUBQF
argument_list|,
name|Queue
index|[
name|qg
index|]
operator|->
name|qg_qpaths
index|[
name|qd
index|]
operator|.
name|qp_subdirs
argument_list|)
condition|)
name|sub
operator|=
literal|"/qf/"
expr_stmt|;
break|break;
case|case
name|XSCRPT_LETTER
case|:
if|if
condition|(
name|bitset
argument_list|(
name|QP_SUBXF
argument_list|,
name|Queue
index|[
name|qg
index|]
operator|->
name|qg_qpaths
index|[
name|qd
index|]
operator|.
name|qp_subdirs
argument_list|)
condition|)
name|sub
operator|=
literal|"/xf/"
expr_stmt|;
break|break;
default|default:
name|sm_abort
argument_list|(
literal|"queuename: bad queue file type %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|4
argument_list|,
name|Queue
index|[
name|qg
index|]
operator|->
name|qg_qpaths
index|[
name|qd
index|]
operator|.
name|qp_name
argument_list|,
name|sub
argument_list|,
name|pref
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|7
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"queuename: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* **  INIT_QID_ALG -- Initialize the (static) parameters that are used to **	generate a queue ID. ** **	This function is called by the daemon to reset **	LastQueueTime and LastQueuePid which are used by assign_queueid(). **	Otherwise the algorithm may cause problems because **	LastQueueTime and LastQueuePid are set indirectly by main() **	before the daemon process is started, hence LastQueuePid is not **	the pid of the daemon and therefore a child of the daemon can **	actually have the same pid as LastQueuePid which means the section **	in  assign_queueid(): **	* see if we need to get a new base time/pid * **	is NOT triggered which will cause the same queue id to be generated. ** **	Parameters: **		none ** **	Returns: **		none. */
end_comment

begin_function
name|void
name|init_qid_alg
parameter_list|()
block|{
name|LastQueueTime
operator|=
literal|0
expr_stmt|;
name|LastQueuePid
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  ASSIGN_QUEUEID -- assign a queue ID for this envelope. ** **	Assigns an id code if one does not already exist. **	This code assumes that nothing will remain in the queue for **	longer than 60 years.  It is critical that files with the given **	name do not already exist in the queue. **	[No longer initializes e_qdir to NOQDIR.] ** **	Parameters: **		e -- envelope to set it in. ** **	Returns: **		none. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|QueueIdChars
index|[]
init|=
literal|"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|QIC_LEN
value|60
end_define

begin_define
define|#
directive|define
name|QIC_LEN_R
value|62
end_define

begin_comment
comment|/* **  Note: the length is "officially" 60 because minutes and seconds are **	usually only 0-59.  However (Linux): **       tm_sec The number of seconds after the minute, normally in **		the range 0 to 59, but can be up to 61 to allow for **		leap seconds. **	Hence the real length of the string is 62 to take this into account. **	Alternatively % QIC_LEN can (should) be used for access everywhere. */
end_comment

begin_define
define|#
directive|define
name|queuenextid
parameter_list|()
value|CurrentPid
end_define

begin_function
name|void
name|assign_queueid
parameter_list|(
name|e
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|pid_t
name|pid
init|=
name|queuenextid
argument_list|()
decl_stmt|;
specifier|static
name|int
name|cX
init|=
literal|0
decl_stmt|;
specifier|static
name|long
name|random_offset
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|char
name|idbuf
index|[
name|MAXQFNAME
operator|-
literal|2
index|]
decl_stmt|;
name|int
name|seq
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|e_id
operator|!=
name|NULL
condition|)
return|return;
comment|/* see if we need to get a new base time/pid */
if|if
condition|(
name|cX
operator|>=
name|QIC_LEN
operator|*
name|QIC_LEN
operator|||
name|LastQueueTime
operator|==
literal|0
operator|||
name|LastQueuePid
operator|!=
name|pid
condition|)
block|{
name|time_t
name|then
init|=
name|LastQueueTime
decl_stmt|;
comment|/* if the first time through, pick a random offset */
if|if
condition|(
name|LastQueueTime
operator|==
literal|0
condition|)
name|random_offset
operator|=
name|get_random
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|LastQueueTime
operator|=
name|curtime
argument_list|()
operator|)
operator|==
name|then
operator|&&
name|LastQueuePid
operator|==
name|pid
condition|)
block|{
operator|(
name|void
operator|)
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|LastQueuePid
operator|=
name|queuenextid
argument_list|()
expr_stmt|;
name|cX
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	**  Generate a new sequence number between 0 and QIC_LEN*QIC_LEN-1. 	**  This lets us generate up to QIC_LEN*QIC_LEN unique queue ids 	**  per second, per process.  With envelope splitting, 	**  a single message can consume many queue ids. 	*/
name|seq
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|cX
operator|+
name|random_offset
operator|)
operator|%
operator|(
name|QIC_LEN
operator|*
name|QIC_LEN
operator|)
argument_list|)
expr_stmt|;
operator|++
name|cX
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|7
argument_list|,
literal|50
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"assign_queueid: random_offset = %ld (%d)\n"
argument_list|,
name|random_offset
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|tm
operator|=
name|gmtime
argument_list|(
operator|&
name|LastQueueTime
argument_list|)
expr_stmt|;
name|idbuf
index|[
literal|0
index|]
operator|=
name|QueueIdChars
index|[
name|tm
operator|->
name|tm_year
operator|%
name|QIC_LEN
index|]
expr_stmt|;
name|idbuf
index|[
literal|1
index|]
operator|=
name|QueueIdChars
index|[
name|tm
operator|->
name|tm_mon
index|]
expr_stmt|;
name|idbuf
index|[
literal|2
index|]
operator|=
name|QueueIdChars
index|[
name|tm
operator|->
name|tm_mday
index|]
expr_stmt|;
name|idbuf
index|[
literal|3
index|]
operator|=
name|QueueIdChars
index|[
name|tm
operator|->
name|tm_hour
index|]
expr_stmt|;
name|idbuf
index|[
literal|4
index|]
operator|=
name|QueueIdChars
index|[
name|tm
operator|->
name|tm_min
operator|%
name|QIC_LEN_R
index|]
expr_stmt|;
name|idbuf
index|[
literal|5
index|]
operator|=
name|QueueIdChars
index|[
name|tm
operator|->
name|tm_sec
operator|%
name|QIC_LEN_R
index|]
expr_stmt|;
name|idbuf
index|[
literal|6
index|]
operator|=
name|QueueIdChars
index|[
name|seq
operator|/
name|QIC_LEN
index|]
expr_stmt|;
name|idbuf
index|[
literal|7
index|]
operator|=
name|QueueIdChars
index|[
name|seq
operator|%
name|QIC_LEN
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
operator|&
name|idbuf
index|[
literal|8
index|]
argument_list|,
sizeof|sizeof
name|idbuf
operator|-
literal|8
argument_list|,
literal|"%06d"
argument_list|,
operator|(
name|int
operator|)
name|LastQueuePid
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_id
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|idbuf
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'i'
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX: inherited from MainEnvelope */
block|e->e_qgrp = NOQGRP;
comment|/* too early to do anything else */
block|e->e_qdir = NOQDIR; 	e->e_xfqgrp = NOQGRP;
endif|#
directive|endif
comment|/* 0 */
comment|/* New ID means it's not on disk yet */
name|e
operator|->
name|e_qfletter
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|7
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"assign_queueid: assigned id %s, e=%p\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|93
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"assigned id"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  SYNC_QUEUE_TIME -- Assure exclusive PID in any given second ** **	Make sure one PID can't be used by two processes in any one second. ** **		If the system rotates PIDs fast enough, may get the **		same pid in the same second for two distinct processes. **		This will interfere with the queue file naming system. ** **	Parameters: **		none ** **	Returns: **		none */
end_comment

begin_function
name|void
name|sync_queue_time
parameter_list|()
block|{
if|#
directive|if
name|FAST_PID_RECYCLE
if|if
condition|(
name|OpMode
operator|!=
name|MD_TEST
operator|&&
name|OpMode
operator|!=
name|MD_VERIFY
operator|&&
name|LastQueueTime
operator|>
literal|0
operator|&&
name|LastQueuePid
operator|==
name|CurrentPid
operator|&&
name|curtime
argument_list|()
operator|==
name|LastQueueTime
condition|)
operator|(
name|void
operator|)
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FAST_PID_RECYCLE */
block|}
end_function

begin_comment
comment|/* **  UNLOCKQUEUE -- unlock the queue entry for a specified envelope ** **	Parameters: **		e -- the envelope to unlock. ** **	Returns: **		none ** **	Side Effects: **		unlocks the queue for `e'. */
end_comment

begin_function
name|void
name|unlockqueue
parameter_list|(
name|e
parameter_list|)
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|51
argument_list|,
literal|4
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"unlockqueue(%s)\n"
argument_list|,
name|e
operator|->
name|e_id
operator|==
name|NULL
condition|?
literal|"NOQUEUE"
else|:
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
comment|/* if there is a lock file in the envelope, close it */
if|if
condition|(
name|e
operator|->
name|e_lockfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|e
operator|->
name|e_lockfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_lockfp
operator|=
name|NULL
expr_stmt|;
comment|/* don't create a queue id if we don't already have one */
if|if
condition|(
name|e
operator|->
name|e_id
operator|==
name|NULL
condition|)
return|return;
comment|/* remove the transcript */
if|if
condition|(
name|LogLevel
operator|>
literal|87
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"unlock"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tTd
argument_list|(
literal|51
argument_list|,
literal|104
argument_list|)
condition|)
operator|(
name|void
operator|)
name|xunlink
argument_list|(
name|queuename
argument_list|(
name|e
argument_list|,
name|XSCRPT_LETTER
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  SETCTLUSER -- create a controlling address ** **	Create a fake "address" given only a local login name; this is **	used as a "controlling user" for future recipient addresses. ** **	Parameters: **		user -- the user name of the controlling user. **		qfver -- the version stamp of this queue file. **		e -- envelope ** **	Returns: **		An address descriptor for the controlling user, **		using storage allocated from e->e_rpool. ** */
end_comment

begin_function
specifier|static
name|ADDRESS
modifier|*
name|setctluser
parameter_list|(
name|user
parameter_list|,
name|qfver
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|user
decl_stmt|;
name|int
name|qfver
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 	**  See if this clears our concept of controlling user. 	*/
if|if
condition|(
name|user
operator|==
name|NULL
operator|||
operator|*
name|user
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
comment|/* 	**  Set up addr fields for controlling user. 	*/
name|a
operator|=
operator|(
name|ADDRESS
operator|*
operator|)
name|sm_rpool_malloc_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
sizeof|sizeof
expr|*
name|a
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
expr|*
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|user
operator|==
literal|':'
condition|)
block|{
name|p
operator|=
operator|&
name|user
index|[
literal|1
index|]
expr_stmt|;
name|a
operator|->
name|q_user
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|strtok
argument_list|(
name|user
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_user
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|qfver
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|a
operator|->
name|q_uid
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|a
operator|->
name|q_gid
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|o
decl_stmt|;
name|a
operator|->
name|q_flags
operator||=
name|QGOODUID
expr_stmt|;
comment|/* if there is another ':': restore it */
if|if
condition|(
operator|(
name|o
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|o
operator|>
name|p
condition|)
name|o
index|[
operator|-
literal|1
index|]
operator|=
literal|':'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|pw
operator|=
name|sm_getpwnam
argument_list|(
name|user
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|pw
operator|->
name|pw_dir
operator|==
literal|'\0'
condition|)
name|a
operator|->
name|q_home
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
condition|)
name|a
operator|->
name|q_home
operator|=
literal|""
expr_stmt|;
else|else
name|a
operator|->
name|q_home
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_uid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
name|a
operator|->
name|q_gid
operator|=
name|pw
operator|->
name|pw_gid
expr_stmt|;
name|a
operator|->
name|q_flags
operator||=
name|QGOODUID
expr_stmt|;
block|}
block|}
name|a
operator|->
name|q_flags
operator||=
name|QPRIMARY
expr_stmt|;
comment|/* flag as a "ctladdr" */
name|a
operator|->
name|q_mailer
operator|=
name|LocalMailer
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|a
operator|->
name|q_paddr
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
else|else
name|a
operator|->
name|q_paddr
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_function

begin_comment
comment|/* **  LOSEQFILE -- rename queue file with LOSEQF_LETTER& try to let someone know ** **	Parameters: **		e -- the envelope (e->e_id will be used). **		why -- reported to whomever can hear. ** **	Returns: **		none. */
end_comment

begin_function
name|void
name|loseqfile
parameter_list|(
name|e
parameter_list|,
name|why
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|why
decl_stmt|;
block|{
name|bool
name|loseit
init|=
name|true
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
operator|||
name|e
operator|->
name|e_id
operator|==
name|NULL
condition|)
return|return;
name|p
operator|=
name|queuename
argument_list|(
name|e
argument_list|,
name|ANYQFL_LETTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm_strlcpy
argument_list|(
name|buf
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|>=
sizeof|sizeof
name|buf
condition|)
return|return;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|EF_INQUEUE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|queueup
argument_list|(
name|e
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|QueueMode
operator|==
name|QM_LOST
condition|)
name|loseit
operator|=
name|false
expr_stmt|;
comment|/* if already lost, no need to re-lose */
if|if
condition|(
name|loseit
condition|)
block|{
name|p
operator|=
name|queuename
argument_list|(
name|e
argument_list|,
name|LOSEQF_LETTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|buf
argument_list|,
name|p
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"cannot rename(%s, %s), uid=%d"
argument_list|,
name|buf
argument_list|,
name|p
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|LogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ALERT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Losing %s: %s"
argument_list|,
name|buf
argument_list|,
name|why
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_dfp
operator|=
name|NULL
expr_stmt|;
block|}
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_HAS_DF
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  NAME2QID -- translate a queue group name to a queue group id ** **	Parameters: **		queuename -- name of queue group. ** **	Returns: **		queue group id if found. **		NOQGRP otherwise. */
end_comment

begin_function
name|int
name|name2qid
parameter_list|(
name|queuename
parameter_list|)
name|char
modifier|*
name|queuename
decl_stmt|;
block|{
specifier|register
name|STAB
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|stab
argument_list|(
name|queuename
argument_list|,
name|ST_QUEUE
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|NOQGRP
return|;
return|return
name|s
operator|->
name|s_quegrp
operator|->
name|qg_index
return|;
block|}
end_function

begin_comment
comment|/* **  QID_PRINTNAME -- create externally printable version of queue id ** **	Parameters: **		e -- the envelope. ** **	Returns: **		a printable version */
end_comment

begin_function
name|char
modifier|*
name|qid_printname
parameter_list|(
name|e
parameter_list|)
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|char
modifier|*
name|id
decl_stmt|;
specifier|static
name|char
name|idbuf
index|[
name|MAXQFNAME
operator|+
literal|34
index|]
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
return|return
literal|""
return|;
if|if
condition|(
name|e
operator|->
name|e_id
operator|==
name|NULL
condition|)
name|id
operator|=
literal|""
expr_stmt|;
else|else
name|id
operator|=
name|e
operator|->
name|e_id
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_qdir
operator|==
name|NOQDIR
condition|)
return|return
name|id
return|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|idbuf
argument_list|,
sizeof|sizeof
name|idbuf
argument_list|,
literal|"%.32s/%s"
argument_list|,
name|Queue
index|[
name|e
operator|->
name|e_qgrp
index|]
operator|->
name|qg_qpaths
index|[
name|e
operator|->
name|e_qdir
index|]
operator|.
name|qp_name
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|idbuf
return|;
block|}
end_function

begin_comment
comment|/* **  QID_PRINTQUEUE -- create full version of queue directory for data files ** **	Parameters: **		qgrp -- index in queue group. **		qdir -- the short version of the queue directory ** **	Returns: **		the full pathname to the queue (might point to a static var) */
end_comment

begin_function
name|char
modifier|*
name|qid_printqueue
parameter_list|(
name|qgrp
parameter_list|,
name|qdir
parameter_list|)
name|int
name|qgrp
decl_stmt|;
name|int
name|qdir
decl_stmt|;
block|{
name|char
modifier|*
name|subdir
decl_stmt|;
specifier|static
name|char
name|dir
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
name|qdir
operator|==
name|NOQDIR
condition|)
return|return
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_qdir
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_qpaths
index|[
name|qdir
index|]
operator|.
name|qp_name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
name|subdir
operator|=
name|NULL
expr_stmt|;
else|else
name|subdir
operator|=
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_qpaths
index|[
name|qdir
index|]
operator|.
name|qp_name
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|dir
argument_list|,
sizeof|sizeof
name|dir
argument_list|,
literal|4
argument_list|,
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_qdir
argument_list|,
name|subdir
operator|==
name|NULL
condition|?
literal|""
else|:
literal|"/"
argument_list|,
name|subdir
operator|==
name|NULL
condition|?
literal|""
else|:
name|subdir
argument_list|,
operator|(
name|bitset
argument_list|(
name|QP_SUBDF
argument_list|,
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_qpaths
index|[
name|qdir
index|]
operator|.
name|qp_subdirs
argument_list|)
condition|?
literal|"/df"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
return|return
name|dir
return|;
block|}
end_function

begin_comment
comment|/* **  PICKQDIR -- Pick a queue directory from a queue group ** **	Parameters: **		qg -- queue group **		fsize -- file size in bytes **		e -- envelope, or NULL ** **	Result: **		NOQDIR if no queue directory in qg has enough free space to **		hold a file of size 'fsize', otherwise the index of **		a randomly selected queue directory which resides on a **		file system with enough disk space. **		XXX This could be extended to select a queuedir with **			a few (the fewest?) number of entries. That data **			is available if shared memory is used. ** **	Side Effects: **		If the request fails and e != NULL then sm_syslog is called. */
end_comment

begin_function
name|int
name|pickqdir
parameter_list|(
name|qg
parameter_list|,
name|fsize
parameter_list|,
name|e
parameter_list|)
name|QUEUEGRP
modifier|*
name|qg
decl_stmt|;
name|long
name|fsize
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|qdir
decl_stmt|;
name|int
name|i
decl_stmt|;
name|long
name|avail
init|=
literal|0
decl_stmt|;
comment|/* Pick a random directory, as a starting point. */
if|if
condition|(
name|qg
operator|->
name|qg_numqueues
operator|<=
literal|1
condition|)
name|qdir
operator|=
literal|0
expr_stmt|;
else|else
name|qdir
operator|=
name|get_rand_mod
argument_list|(
name|qg
operator|->
name|qg_numqueues
argument_list|)
expr_stmt|;
if|if
condition|(
name|MinBlocksFree
operator|<=
literal|0
operator|&&
name|fsize
operator|<=
literal|0
condition|)
return|return
name|qdir
return|;
comment|/* 	**  Now iterate over the queue directories, 	**  looking for a directory with enough space for this message. 	*/
name|i
operator|=
name|qdir
expr_stmt|;
do|do
block|{
name|QPATHS
modifier|*
name|qp
init|=
operator|&
name|qg
operator|->
name|qg_qpaths
index|[
name|i
index|]
decl_stmt|;
name|long
name|needed
init|=
literal|0
decl_stmt|;
name|long
name|fsavail
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fsize
operator|>
literal|0
condition|)
name|needed
operator|+=
name|fsize
operator|/
name|FILE_SYS_BLKSIZE
argument_list|(
name|qp
operator|->
name|qp_fsysidx
argument_list|)
operator|+
operator|(
operator|(
name|fsize
operator|%
name|FILE_SYS_BLKSIZE
argument_list|(
name|qp
operator|->
name|qp_fsysidx
argument_list|)
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|MinBlocksFree
operator|>
literal|0
condition|)
name|needed
operator|+=
name|MinBlocksFree
expr_stmt|;
name|fsavail
operator|=
name|FILE_SYS_AVAIL
argument_list|(
name|qp
operator|->
name|qp_fsysidx
argument_list|)
expr_stmt|;
if|#
directive|if
name|SM_CONF_SHM
if|if
condition|(
name|fsavail
operator|<=
literal|0
condition|)
block|{
name|long
name|blksize
decl_stmt|;
comment|/* 			**  might be not correctly updated, 			**  let's try to get the info directly. 			*/
name|fsavail
operator|=
name|freediskspace
argument_list|(
name|FILE_SYS_NAME
argument_list|(
name|qp
operator|->
name|qp_fsysidx
argument_list|)
argument_list|,
operator|&
name|blksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsavail
operator|<
literal|0
condition|)
name|fsavail
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SM_CONF_SHM */
if|if
condition|(
name|needed
operator|<=
name|fsavail
condition|)
return|return
name|i
return|;
if|if
condition|(
name|avail
operator|<
name|fsavail
condition|)
name|avail
operator|=
name|fsavail
expr_stmt|;
if|if
condition|(
name|qg
operator|->
name|qg_numqueues
operator|>
literal|0
condition|)
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|qg
operator|->
name|qg_numqueues
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|qdir
condition|)
do|;
if|if
condition|(
name|e
operator|!=
name|NULL
operator|&&
name|LogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ALERT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"low on space (%s needs %ld bytes + %ld blocks in %s), max avail: %ld"
argument_list|,
name|CurHostName
operator|==
name|NULL
condition|?
literal|"SMTP-DAEMON"
else|:
name|CurHostName
argument_list|,
name|fsize
argument_list|,
name|MinBlocksFree
argument_list|,
name|qg
operator|->
name|qg_qdir
argument_list|,
name|avail
argument_list|)
expr_stmt|;
return|return
name|NOQDIR
return|;
block|}
end_function

begin_comment
comment|/* **  SETNEWQUEUE -- Sets a new queue group and directory ** **	Assign a queue group and directory to an envelope and store the **	directory in e->e_qdir. ** **	Parameters: **		e -- envelope to assign a queue for. ** **	Returns: **		true if successful **		false otherwise ** **	Side Effects: **		On success, e->e_qgrp and e->e_qdir are non-negative. **		On failure (not enough disk space), **		e->qgrp = NOQGRP, e->e_qdir = NOQDIR **		and usrerr() is invoked (which could raise an exception). */
end_comment

begin_function
name|bool
name|setnewqueue
parameter_list|(
name|e
parameter_list|)
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|20
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"setnewqueue: called\n"
argument_list|)
expr_stmt|;
comment|/* not set somewhere else */
if|if
condition|(
name|e
operator|->
name|e_qgrp
operator|==
name|NOQGRP
condition|)
block|{
name|ADDRESS
modifier|*
name|q
decl_stmt|;
comment|/* 		**  Use the queue group of the "first" recipient, as set by 		**  the "queuegroup" rule set.  If that is not defined, then 		**  use the queue group of the mailer of the first recipient. 		**  If that is not defined either, then use the default 		**  queue group. 		**  Notice: "first" depends on the sorting of sendqueue 		**  in recipient(). 		**  To avoid problems with "bad" recipients look 		**  for a valid address first. 		*/
name|q
operator|=
name|e
operator|->
name|e_sendqueue
expr_stmt|;
while|while
condition|(
name|q
operator|!=
name|NULL
operator|&&
operator|(
name|QS_IS_BADADDR
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
operator|||
name|QS_IS_DEAD
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
operator|)
condition|)
block|{
name|q
operator|=
name|q
operator|->
name|q_next
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
name|e
operator|->
name|e_qgrp
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|q
operator|->
name|q_qgrp
operator|>=
literal|0
condition|)
name|e
operator|->
name|e_qgrp
operator|=
name|q
operator|->
name|q_qgrp
expr_stmt|;
elseif|else
if|if
condition|(
name|q
operator|->
name|q_mailer
operator|!=
name|NULL
operator|&&
name|ISVALIDQGRP
argument_list|(
name|q
operator|->
name|q_mailer
operator|->
name|m_qgrp
argument_list|)
condition|)
name|e
operator|->
name|e_qgrp
operator|=
name|q
operator|->
name|q_mailer
operator|->
name|m_qgrp
expr_stmt|;
else|else
name|e
operator|->
name|e_qgrp
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|e_dfqgrp
operator|=
name|e
operator|->
name|e_qgrp
expr_stmt|;
block|}
if|if
condition|(
name|ISVALIDQDIR
argument_list|(
name|e
operator|->
name|e_qdir
argument_list|)
operator|&&
name|ISVALIDQDIR
argument_list|(
name|e
operator|->
name|e_dfqdir
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|20
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"setnewqueue: e_qdir already assigned (%s)\n"
argument_list|,
name|qid_printqueue
argument_list|(
name|e
operator|->
name|e_qgrp
argument_list|,
name|e
operator|->
name|e_qdir
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|filesys_update
argument_list|()
expr_stmt|;
name|e
operator|->
name|e_qdir
operator|=
name|pickqdir
argument_list|(
name|Queue
index|[
name|e
operator|->
name|e_qgrp
index|]
argument_list|,
name|e
operator|->
name|e_msgsize
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_qdir
operator|==
name|NOQDIR
condition|)
block|{
name|e
operator|->
name|e_qgrp
operator|=
name|NOQGRP
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|EF_FATALERRS
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|usrerr
argument_list|(
literal|"452 4.4.5 Insufficient disk space; try again later"
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_FATALERRS
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|3
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"setnewqueue: Assigned queue directory %s\n"
argument_list|,
name|qid_printqueue
argument_list|(
name|e
operator|->
name|e_qgrp
argument_list|,
name|e
operator|->
name|e_qdir
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_xfqgrp
operator|==
name|NOQGRP
operator|||
name|e
operator|->
name|e_xfqdir
operator|==
name|NOQDIR
condition|)
block|{
name|e
operator|->
name|e_xfqgrp
operator|=
name|e
operator|->
name|e_qgrp
expr_stmt|;
name|e
operator|->
name|e_xfqdir
operator|=
name|e
operator|->
name|e_qdir
expr_stmt|;
block|}
name|e
operator|->
name|e_dfqdir
operator|=
name|e
operator|->
name|e_qdir
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* **  CHKQDIR -- check a queue directory ** **	Parameters: **		name -- name of queue directory **		sff -- flags for safefile() ** **	Returns: **		is it a queue directory? */
end_comment

begin_function
specifier|static
name|bool
name|chkqdir
parameter_list|(
name|name
parameter_list|,
name|sff
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|long
name|sff
decl_stmt|;
block|{
name|struct
name|stat
name|statb
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* skip over . and .. directories */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|)
condition|)
return|return
name|false
return|;
if|#
directive|if
name|HASLSTAT
if|if
condition|(
name|lstat
argument_list|(
name|name
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
comment|/* HASLSTAT */
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
comment|/* HASLSTAT */
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"chkqdir: stat(\"%s\"): %s\n"
argument_list|,
name|name
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|#
directive|if
name|HASLSTAT
if|if
condition|(
name|S_ISLNK
argument_list|(
name|statb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* 		**  For a symlink we need to make sure the 		**  target is a directory 		*/
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"chkqdir: stat(\"%s\"): %s\n"
argument_list|,
name|name
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
endif|#
directive|endif
comment|/* HASLSTAT */
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|statb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"chkqdir: \"%s\": Not a directory\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Print a warning if unsafe (but still use it) */
comment|/* XXX do this only if we want the warning? */
name|i
operator|=
name|safedirpath
argument_list|(
name|name
argument_list|,
name|RunAsUid
argument_list|,
name|RunAsGid
argument_list|,
name|NULL
argument_list|,
name|sff
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"chkqdir: \"%s\": Not safe: %s\n"
argument_list|,
name|name
argument_list|,
name|sm_errstring
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|_FFR_CHK_QUEUE
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"queue directory \"%s\": Not safe: %s"
argument_list|,
name|name
argument_list|,
name|sm_errstring
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_CHK_QUEUE */
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* **  MULTIQUEUE_CACHE -- cache a list of paths to queues. ** **	Each potential queue is checked as the cache is built. **	Thereafter, each is blindly trusted. **	Note that we can be called again after a timeout to rebuild **	(although code for that is not ready yet). ** **	Parameters: **		basedir -- base of all queue directories. **		blen -- strlen(basedir). **		qg -- queue group. **		qn -- number of queue directories already cached. **		phash -- pointer to hash value over queue dirs. #if SM_CONF_SHM **			only used if shared memory is active. #endif * SM_CONF_SHM * ** **	Returns: **		new number of queue directories. */
end_comment

begin_define
define|#
directive|define
name|INITIAL_SLOTS
value|20
end_define

begin_define
define|#
directive|define
name|ADD_SLOTS
value|10
end_define

begin_function
specifier|static
name|int
name|multiqueue_cache
parameter_list|(
name|basedir
parameter_list|,
name|blen
parameter_list|,
name|qg
parameter_list|,
name|qn
parameter_list|,
name|phash
parameter_list|)
name|char
modifier|*
name|basedir
decl_stmt|;
name|int
name|blen
decl_stmt|;
name|QUEUEGRP
modifier|*
name|qg
decl_stmt|;
name|int
name|qn
decl_stmt|;
name|unsigned
name|int
modifier|*
name|phash
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|int
name|slotsleft
init|=
literal|0
decl_stmt|;
name|long
name|sff
init|=
name|SFF_ANYFILE
decl_stmt|;
name|char
name|qpath
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|subdir
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|prefix
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
comment|/* dir relative to basedir */
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|20
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"multiqueue_cache: called\n"
argument_list|)
expr_stmt|;
comment|/* Initialize to current directory */
name|prefix
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|prefix
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|qg
operator|->
name|qg_numqueues
operator|!=
literal|0
operator|&&
name|qg
operator|->
name|qg_qpaths
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qg
operator|->
name|qg_numqueues
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|qg
operator|->
name|qg_qpaths
index|[
name|i
index|]
operator|.
name|qp_name
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_free
argument_list|(
name|qg
operator|->
name|qg_qpaths
index|[
name|i
index|]
operator|.
name|qp_name
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
operator|(
name|void
operator|)
name|sm_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qg
operator|->
name|qg_qpaths
argument_list|)
expr_stmt|;
comment|/* XXX */
name|qg
operator|->
name|qg_qpaths
operator|=
name|NULL
expr_stmt|;
name|qg
operator|->
name|qg_numqueues
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If running as root, allow safedirpath() checks to use privs */
if|if
condition|(
name|RunAsUid
operator|==
literal|0
condition|)
name|sff
operator||=
name|SFF_ROOTOK
expr_stmt|;
if|#
directive|if
name|_FFR_CHK_QUEUE
name|sff
operator||=
name|SFF_SAFEDIRPATH
operator||
name|SFF_NOWWFILES
expr_stmt|;
if|if
condition|(
operator|!
name|UseMSP
condition|)
name|sff
operator||=
name|SFF_NOGWFILES
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_CHK_QUEUE */
if|if
condition|(
operator|!
name|SM_IS_DIR_START
argument_list|(
name|qg
operator|->
name|qg_qdir
argument_list|)
condition|)
block|{
comment|/* 		**  XXX we could add basedir, but then we have to realloc() 		**  the string... Maybe another time. 		*/
name|syserr
argument_list|(
literal|"QueuePath %s not absolute"
argument_list|,
name|qg
operator|->
name|qg_qdir
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_CONFIG
expr_stmt|;
return|return
name|qn
return|;
block|}
comment|/* qpath: directory of current workgroup */
name|len
operator|=
name|sm_strlcpy
argument_list|(
name|qpath
argument_list|,
name|qg
operator|->
name|qg_qdir
argument_list|,
sizeof|sizeof
name|qpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
name|qpath
condition|)
block|{
name|syserr
argument_list|(
literal|"QueuePath %.256s too long (%d max)"
argument_list|,
name|qg
operator|->
name|qg_qdir
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
name|qpath
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_CONFIG
expr_stmt|;
return|return
name|qn
return|;
block|}
comment|/* begin of qpath must be same as basedir */
if|if
condition|(
name|strncmp
argument_list|(
name|basedir
argument_list|,
name|qpath
argument_list|,
name|blen
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|strncmp
argument_list|(
name|basedir
argument_list|,
name|qpath
argument_list|,
name|blen
operator|-
literal|1
argument_list|)
operator|!=
literal|0
operator|||
name|len
operator|!=
name|blen
operator|-
literal|1
operator|)
condition|)
block|{
name|syserr
argument_list|(
literal|"QueuePath %s not subpath of QueueDirectory %s"
argument_list|,
name|qpath
argument_list|,
name|basedir
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_CONFIG
expr_stmt|;
return|return
name|qn
return|;
block|}
comment|/* Do we have a nested subdirectory? */
if|if
condition|(
name|blen
operator|<
name|len
operator|&&
name|SM_FIRST_DIR_DELIM
argument_list|(
name|qg
operator|->
name|qg_qdir
operator|+
name|blen
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Copy subdirectory into prefix for later use */
if|if
condition|(
name|sm_strlcpy
argument_list|(
name|prefix
argument_list|,
name|qg
operator|->
name|qg_qdir
operator|+
name|blen
argument_list|,
sizeof|sizeof
name|prefix
argument_list|)
operator|>=
sizeof|sizeof
name|prefix
condition|)
block|{
name|syserr
argument_list|(
literal|"QueuePath %.256s too long (%d max)"
argument_list|,
name|qg
operator|->
name|qg_qdir
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
name|qpath
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_CONFIG
expr_stmt|;
return|return
name|qn
return|;
block|}
name|cp
operator|=
name|SM_LAST_DIR_DELIM
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|SM_ASSERT
argument_list|(
name|cp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* cut off trailing / */
block|}
comment|/* This is guaranteed by the basedir check above */
name|SM_ASSERT
argument_list|(
name|len
operator|>=
name|blen
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|qpath
index|[
name|len
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'*'
condition|)
block|{
specifier|register
name|DIR
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|dirent
modifier|*
name|d
decl_stmt|;
name|int
name|off
decl_stmt|;
name|char
modifier|*
name|delim
decl_stmt|;
name|char
name|relpath
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* Overwrite wildcard */
if|if
condition|(
operator|(
name|cp
operator|=
name|SM_LAST_DIR_DELIM
argument_list|(
name|qpath
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"QueueDirectory: can not wildcard relative path"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"multiqueue_cache: \"%s*\": Can not wildcard relative path.\n"
argument_list|,
name|qpath
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_CONFIG
expr_stmt|;
return|return
name|qn
return|;
block|}
if|if
condition|(
name|cp
operator|==
name|qpath
condition|)
block|{
comment|/* 			**  Special case of top level wildcard, like /foo* 			**	Change to //foo* 			*/
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|qpath
operator|+
literal|1
argument_list|,
name|qpath
argument_list|,
sizeof|sizeof
name|qpath
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|++
name|cp
expr_stmt|;
block|}
name|delim
operator|=
name|cp
expr_stmt|;
operator|*
operator|(
name|cp
operator|++
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* Replace / with \0 */
name|len
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* Last component of queue directory */
comment|/* 		**  Path relative to basedir, with trailing / 		**  It will be modified below to specify the subdirectories 		**  so they can be opened without chdir(). 		*/
name|off
operator|=
name|sm_strlcpyn
argument_list|(
name|relpath
argument_list|,
sizeof|sizeof
name|relpath
argument_list|,
literal|2
argument_list|,
name|prefix
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|SM_ASSERT
argument_list|(
name|off
operator|<
sizeof|sizeof
name|relpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"multiqueue_cache: prefix=\"%s%s\"\n"
argument_list|,
name|relpath
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* It is always basedir: we don't need to store it per group */
comment|/* XXX: optimize this! -> one more global? */
name|qg
operator|->
name|qg_qdir
operator|=
name|newstr
argument_list|(
name|basedir
argument_list|)
expr_stmt|;
name|qg
operator|->
name|qg_qdir
index|[
name|blen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* cut off trailing / */
comment|/* 		**  XXX Should probably wrap this whole loop in a timeout 		**  in case some wag decides to NFS mount the queues. 		*/
comment|/* Test path to get warning messages. */
if|if
condition|(
name|qn
operator|==
literal|0
condition|)
block|{
comment|/*  XXX qg_runasuid and qg_runasgid for specials? */
name|i
operator|=
name|safedirpath
argument_list|(
name|basedir
argument_list|,
name|RunAsUid
argument_list|,
name|RunAsGid
argument_list|,
name|NULL
argument_list|,
name|sff
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
name|tTd
argument_list|(
literal|41
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"multiqueue_cache: \"%s\": Not safe: %s\n"
argument_list|,
name|basedir
argument_list|,
name|sm_errstring
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dp
operator|=
name|opendir
argument_list|(
name|prefix
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"can not opendir(%s/%s)"
argument_list|,
name|qg
operator|->
name|qg_qdir
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"multiqueue_cache: opendir(\"%s/%s\"): %s\n"
argument_list|,
name|qg
operator|->
name|qg_qdir
argument_list|,
name|prefix
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_CONFIG
expr_stmt|;
return|return
name|qn
return|;
block|}
while|while
condition|(
operator|(
name|d
operator|=
name|readdir
argument_list|(
name|dp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|len
operator|||
name|strncmp
argument_list|(
name|d
operator|->
name|d_name
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"multiqueue_cache: \"%s\", skipped\n"
argument_list|,
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Create relative pathname: prefix + local directory */
name|i
operator|=
sizeof|sizeof
argument_list|(
name|relpath
argument_list|)
operator|-
name|off
expr_stmt|;
if|if
condition|(
name|sm_strlcpy
argument_list|(
name|relpath
operator|+
name|off
argument_list|,
name|d
operator|->
name|d_name
argument_list|,
name|i
argument_list|)
operator|>=
name|i
condition|)
continue|continue;
comment|/* way too long */
if|if
condition|(
operator|!
name|chkqdir
argument_list|(
name|relpath
argument_list|,
name|sff
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|qg
operator|->
name|qg_qpaths
operator|==
name|NULL
condition|)
block|{
name|slotsleft
operator|=
name|INITIAL_SLOTS
expr_stmt|;
name|qg
operator|->
name|qg_qpaths
operator|=
operator|(
name|QPATHS
operator|*
operator|)
name|xalloc
argument_list|(
operator|(
sizeof|sizeof
expr|*
name|qg
operator|->
name|qg_qpaths
operator|)
operator|*
name|slotsleft
argument_list|)
expr_stmt|;
name|qg
operator|->
name|qg_numqueues
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|slotsleft
operator|<
literal|1
condition|)
block|{
name|qg
operator|->
name|qg_qpaths
operator|=
operator|(
name|QPATHS
operator|*
operator|)
name|sm_realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qg
operator|->
name|qg_qpaths
argument_list|,
operator|(
sizeof|sizeof
expr|*
name|qg
operator|->
name|qg_qpaths
operator|)
operator|*
operator|(
name|qg
operator|->
name|qg_numqueues
operator|+
name|ADD_SLOTS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qg
operator|->
name|qg_qpaths
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return
name|qn
return|;
block|}
name|slotsleft
operator|+=
name|ADD_SLOTS
expr_stmt|;
block|}
comment|/* check subdirs */
name|qg
operator|->
name|qg_qpaths
index|[
name|qg
operator|->
name|qg_numqueues
index|]
operator|.
name|qp_subdirs
operator|=
name|QP_NOSUB
expr_stmt|;
define|#
directive|define
name|CHKRSUBDIR
parameter_list|(
name|name
parameter_list|,
name|flag
parameter_list|)
define|\
value|(void) sm_strlcpyn(subdir, sizeof subdir, 3, relpath, "/", name); \ 	if (chkqdir(subdir, sff))	\ 		qg->qg_qpaths[qg->qg_numqueues].qp_subdirs |= flag;	\ 	else
name|CHKRSUBDIR
argument_list|(
literal|"qf"
argument_list|,
name|QP_SUBQF
argument_list|)
expr_stmt|;
name|CHKRSUBDIR
argument_list|(
literal|"df"
argument_list|,
name|QP_SUBDF
argument_list|)
expr_stmt|;
name|CHKRSUBDIR
argument_list|(
literal|"xf"
argument_list|,
name|QP_SUBXF
argument_list|)
expr_stmt|;
comment|/* assert(strlen(d->d_name)< MAXPATHLEN - 14) */
comment|/* maybe even - 17 (subdirs) */
if|if
condition|(
name|prefix
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
name|qg
operator|->
name|qg_qpaths
index|[
name|qg
operator|->
name|qg_numqueues
index|]
operator|.
name|qp_name
operator|=
name|newstr
argument_list|(
name|relpath
argument_list|)
expr_stmt|;
else|else
name|qg
operator|->
name|qg_qpaths
index|[
name|qg
operator|->
name|qg_numqueues
index|]
operator|.
name|qp_name
operator|=
name|newstr
argument_list|(
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"multiqueue_cache: %d: \"%s\" cached (%x).\n"
argument_list|,
name|qg
operator|->
name|qg_numqueues
argument_list|,
name|relpath
argument_list|,
name|qg
operator|->
name|qg_qpaths
index|[
name|qg
operator|->
name|qg_numqueues
index|]
operator|.
name|qp_subdirs
argument_list|)
expr_stmt|;
if|#
directive|if
name|SM_CONF_SHM
name|qg
operator|->
name|qg_qpaths
index|[
name|qg
operator|->
name|qg_numqueues
index|]
operator|.
name|qp_idx
operator|=
name|qn
expr_stmt|;
operator|*
name|phash
operator|=
name|hash_q
argument_list|(
name|relpath
argument_list|,
operator|*
name|phash
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SM_CONF_SHM */
name|qg
operator|->
name|qg_numqueues
operator|++
expr_stmt|;
operator|++
name|qn
expr_stmt|;
name|slotsleft
operator|--
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dp
argument_list|)
expr_stmt|;
comment|/* undo damage */
operator|*
name|delim
operator|=
literal|'/'
expr_stmt|;
block|}
if|if
condition|(
name|qg
operator|->
name|qg_numqueues
operator|==
literal|0
condition|)
block|{
name|qg
operator|->
name|qg_qpaths
operator|=
operator|(
name|QPATHS
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|qg
operator|->
name|qg_qpaths
argument_list|)
expr_stmt|;
comment|/* test path to get warning messages */
name|i
operator|=
name|safedirpath
argument_list|(
name|qpath
argument_list|,
name|RunAsUid
argument_list|,
name|RunAsGid
argument_list|,
name|NULL
argument_list|,
name|sff
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|ENOENT
condition|)
block|{
name|syserr
argument_list|(
literal|"can not opendir(%s)"
argument_list|,
name|qpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"multiqueue_cache: opendir(\"%s\"): %s\n"
argument_list|,
name|qpath
argument_list|,
name|sm_errstring
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_CONFIG
expr_stmt|;
return|return
name|qn
return|;
block|}
name|qg
operator|->
name|qg_qpaths
index|[
literal|0
index|]
operator|.
name|qp_subdirs
operator|=
name|QP_NOSUB
expr_stmt|;
name|qg
operator|->
name|qg_numqueues
operator|=
literal|1
expr_stmt|;
comment|/* check subdirs */
define|#
directive|define
name|CHKSUBDIR
parameter_list|(
name|name
parameter_list|,
name|flag
parameter_list|)
define|\
value|(void) sm_strlcpyn(subdir, sizeof subdir, 3, qg->qg_qdir, "/", name); \ 	if (chkqdir(subdir, sff))	\ 		qg->qg_qpaths[0].qp_subdirs |= flag;	\ 	else
name|CHKSUBDIR
argument_list|(
literal|"qf"
argument_list|,
name|QP_SUBQF
argument_list|)
expr_stmt|;
name|CHKSUBDIR
argument_list|(
literal|"df"
argument_list|,
name|QP_SUBDF
argument_list|)
expr_stmt|;
name|CHKSUBDIR
argument_list|(
literal|"xf"
argument_list|,
name|QP_SUBXF
argument_list|)
expr_stmt|;
if|if
condition|(
name|qg
operator|->
name|qg_qdir
index|[
name|blen
operator|-
literal|1
index|]
operator|!=
literal|'\0'
operator|&&
name|qg
operator|->
name|qg_qdir
index|[
name|blen
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* 			**  Copy the last component into qpaths and 			**  cut off qdir 			*/
name|qg
operator|->
name|qg_qpaths
index|[
literal|0
index|]
operator|.
name|qp_name
operator|=
name|newstr
argument_list|(
name|qg
operator|->
name|qg_qdir
operator|+
name|blen
argument_list|)
expr_stmt|;
name|qg
operator|->
name|qg_qdir
index|[
name|blen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|qg
operator|->
name|qg_qpaths
index|[
literal|0
index|]
operator|.
name|qp_name
operator|=
name|newstr
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
if|#
directive|if
name|SM_CONF_SHM
name|qg
operator|->
name|qg_qpaths
index|[
literal|0
index|]
operator|.
name|qp_idx
operator|=
name|qn
expr_stmt|;
operator|*
name|phash
operator|=
name|hash_q
argument_list|(
name|qg
operator|->
name|qg_qpaths
index|[
literal|0
index|]
operator|.
name|qp_name
argument_list|,
operator|*
name|phash
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SM_CONF_SHM */
operator|++
name|qn
expr_stmt|;
block|}
return|return
name|qn
return|;
block|}
end_function

begin_comment
comment|/* **  FILESYS_FIND -- find entry in FileSys table, or add new one ** **	Given the pathname of a directory, determine the file system **	in which that directory resides, and return a pointer to the **	entry in the FileSys table that describes the file system. **	A new entry is added if necessary (and requested). **	If the directory does not exist, -1 is returned. ** **	Parameters: **		name -- name of directory (must be persistent!) **		path -- pathname of directory (name plus maybe "/df") **		add -- add to structure if not found. ** **	Returns: **>=0: found: index in file system table **<0: some error, i.e., **		FSF_TOO_MANY: too many filesystems (-> syserr()) **		FSF_STAT_FAIL: can't stat() filesystem (-> syserr()) **		FSF_NOT_FOUND: not in list */
end_comment

begin_decl_stmt
specifier|static
name|short
name|filesys_find
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|bool
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FSF_NOT_FOUND
value|(-1)
end_define

begin_define
define|#
directive|define
name|FSF_STAT_FAIL
value|(-2)
end_define

begin_define
define|#
directive|define
name|FSF_TOO_MANY
value|(-3)
end_define

begin_function
specifier|static
name|short
name|filesys_find
parameter_list|(
name|name
parameter_list|,
name|path
parameter_list|,
name|add
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|bool
name|add
decl_stmt|;
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|short
name|i
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"cannot stat queue directory %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
name|FSF_STAT_FAIL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NumFileSys
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|FILE_SYS_DEV
argument_list|(
name|i
argument_list|)
operator|==
name|st
operator|.
name|st_dev
condition|)
return|return
name|i
return|;
block|}
if|if
condition|(
name|i
operator|>=
name|MAXFILESYS
condition|)
block|{
name|syserr
argument_list|(
literal|"too many queue file systems (%d max)"
argument_list|,
name|MAXFILESYS
argument_list|)
expr_stmt|;
return|return
name|FSF_TOO_MANY
return|;
block|}
if|if
condition|(
operator|!
name|add
condition|)
return|return
name|FSF_NOT_FOUND
return|;
operator|++
name|NumFileSys
expr_stmt|;
name|FILE_SYS_NAME
argument_list|(
name|i
argument_list|)
operator|=
name|name
expr_stmt|;
name|FILE_SYS_DEV
argument_list|(
name|i
argument_list|)
operator|=
name|st
operator|.
name|st_dev
expr_stmt|;
name|FILE_SYS_AVAIL
argument_list|(
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
name|FILE_SYS_BLKSIZE
argument_list|(
name|i
argument_list|)
operator|=
literal|1024
expr_stmt|;
comment|/* avoid divide by zero */
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* **  FILESYS_SETUP -- set up mapping from queue directories to file systems ** **	This data structure is used to efficiently check the amount of **	free space available in a set of queue directories. ** **	Parameters: **		add -- initialize structure if necessary. ** **	Returns: **		0: success **<0: some error, i.e., **		FSF_NOT_FOUND: not in list **		FSF_STAT_FAIL: can't stat() filesystem (-> syserr()) **		FSF_TOO_MANY: too many filesystems (-> syserr()) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|filesys_setup
name|__P
argument_list|(
operator|(
name|bool
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|filesys_setup
parameter_list|(
name|add
parameter_list|)
name|bool
name|add
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|short
name|fs
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NumQueue
operator|&&
name|Queue
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|Queue
index|[
name|i
index|]
operator|->
name|qg_numqueues
condition|;
operator|++
name|j
control|)
block|{
name|QPATHS
modifier|*
name|qp
init|=
operator|&
name|Queue
index|[
name|i
index|]
operator|->
name|qg_qpaths
index|[
name|j
index|]
decl_stmt|;
name|char
name|qddf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|qddf
argument_list|,
sizeof|sizeof
name|qddf
argument_list|,
literal|2
argument_list|,
name|qp
operator|->
name|qp_name
argument_list|,
operator|(
name|bitset
argument_list|(
name|QP_SUBDF
argument_list|,
name|qp
operator|->
name|qp_subdirs
argument_list|)
condition|?
literal|"/df"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|fs
operator|=
name|filesys_find
argument_list|(
name|qp
operator|->
name|qp_name
argument_list|,
name|qddf
argument_list|,
name|add
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|>=
literal|0
condition|)
name|qp
operator|->
name|qp_fsysidx
operator|=
name|fs
expr_stmt|;
else|else
name|qp
operator|->
name|qp_fsysidx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fs
operator|<
name|ret
condition|)
name|ret
operator|=
name|fs
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* **  FILESYS_UPDATE -- update amount of free space on all file systems ** **	The FileSys table is used to cache the amount of free space **	available on all queue directory file systems. **	This function updates the cached information if it has expired. ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		Updates FileSys table. */
end_comment

begin_function
name|void
name|filesys_update
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|long
name|avail
decl_stmt|,
name|blksize
decl_stmt|;
name|time_t
name|now
decl_stmt|;
specifier|static
name|time_t
name|nextupdate
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|SM_CONF_SHM
comment|/* only the daemon updates this structure */
if|if
condition|(
name|ShmId
operator|!=
name|SM_SHM_NO_ID
operator|&&
name|DaemonPid
operator|!=
name|CurrentPid
condition|)
return|return;
endif|#
directive|endif
comment|/* SM_CONF_SHM */
name|now
operator|=
name|curtime
argument_list|()
expr_stmt|;
if|if
condition|(
name|now
operator|<
name|nextupdate
condition|)
return|return;
name|nextupdate
operator|=
name|now
operator|+
name|FILESYS_UPDATE_INTERVAL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NumFileSys
condition|;
operator|++
name|i
control|)
block|{
name|FILESYS
modifier|*
name|fs
init|=
operator|&
name|FILE_SYS
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|avail
operator|=
name|freediskspace
argument_list|(
name|FILE_SYS_NAME
argument_list|(
name|i
argument_list|)
argument_list|,
operator|&
name|blksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|avail
operator|<
literal|0
operator|||
name|blksize
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"filesys_update failed: %s, fs=%s, avail=%ld, blocksize=%ld"
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|,
name|FILE_SYS_NAME
argument_list|(
name|i
argument_list|)
argument_list|,
name|avail
argument_list|,
name|blksize
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_avail
operator|=
literal|0
expr_stmt|;
name|fs
operator|->
name|fs_blksize
operator|=
literal|1024
expr_stmt|;
comment|/* avoid divide by zero */
name|nextupdate
operator|=
name|now
operator|+
literal|2
expr_stmt|;
comment|/* let's do this soon again */
block|}
else|else
block|{
name|fs
operator|->
name|fs_avail
operator|=
name|avail
expr_stmt|;
name|fs
operator|->
name|fs_blksize
operator|=
name|blksize
expr_stmt|;
block|}
block|}
block|}
end_function

begin_if
if|#
directive|if
name|_FFR_ANY_FREE_FS
end_if

begin_comment
comment|/* **  FILESYS_FREE -- check whether there is at least one fs with enough space. ** **	Parameters: **		fsize -- file size in bytes ** **	Returns: **		true iff there is one fs with more than fsize bytes free. */
end_comment

begin_function
name|bool
name|filesys_free
parameter_list|(
name|fsize
parameter_list|)
name|long
name|fsize
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|fsize
operator|<=
literal|0
condition|)
return|return
name|true
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NumFileSys
condition|;
operator|++
name|i
control|)
block|{
name|long
name|needed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|FILE_SYS_AVAIL
argument_list|(
name|i
argument_list|)
operator|<
literal|0
operator|||
name|FILE_SYS_BLKSIZE
argument_list|(
name|i
argument_list|)
operator|<=
literal|0
condition|)
continue|continue;
name|needed
operator|+=
name|fsize
operator|/
name|FILE_SYS_BLKSIZE
argument_list|(
name|i
argument_list|)
operator|+
operator|(
operator|(
name|fsize
operator|%
name|FILE_SYS_BLKSIZE
argument_list|(
name|i
argument_list|)
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
name|MinBlocksFree
expr_stmt|;
if|if
condition|(
name|needed
operator|<=
name|FILE_SYS_AVAIL
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_ANY_FREE_FS */
end_comment

begin_if
if|#
directive|if
name|_FFR_CONTROL_MSTAT
end_if

begin_comment
comment|/* **  DISK_STATUS -- show amount of free space in queue directories ** **	Parameters: **		out -- output file pointer. **		prefix -- string to output in front of each line. ** **	Returns: **		none. */
end_comment

begin_function
name|void
name|disk_status
parameter_list|(
name|out
parameter_list|,
name|prefix
parameter_list|)
name|SM_FILE_T
modifier|*
name|out
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|long
name|avail
decl_stmt|,
name|blksize
decl_stmt|;
name|long
name|free
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NumFileSys
condition|;
operator|++
name|i
control|)
block|{
name|avail
operator|=
name|freediskspace
argument_list|(
name|FILE_SYS_NAME
argument_list|(
name|i
argument_list|)
argument_list|,
operator|&
name|blksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|avail
operator|>=
literal|0
operator|&&
name|blksize
operator|>
literal|0
condition|)
block|{
name|free
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
name|double
operator|)
name|avail
operator|*
operator|(
operator|(
name|double
operator|)
name|blksize
operator|/
literal|1024
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|free
operator|=
operator|-
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s%d/%s/%ld\r\n"
argument_list|,
name|prefix
argument_list|,
name|i
argument_list|,
name|FILE_SYS_NAME
argument_list|(
name|i
argument_list|)
argument_list|,
name|free
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_CONTROL_MSTAT */
end_comment

begin_if
if|#
directive|if
name|SM_CONF_SHM
end_if

begin_comment
comment|/* **  INIT_SEM -- initialize semaphore system ** **	Parameters: **		owner -- is this the owner of semaphores? ** **	Returns: **		none. */
end_comment

begin_if
if|#
directive|if
name|_FFR_USE_SEM_LOCKING
end_if

begin_if
if|#
directive|if
name|SM_CONF_SEM
end_if

begin_decl_stmt
specifier|static
name|int
name|SemId
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Semaphore Id */
end_comment

begin_decl_stmt
name|int
name|SemKey
init|=
name|SM_SEM_KEY
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SM_CONF_SEM */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_USE_SEM_LOCKING */
end_comment

begin_decl_stmt
specifier|static
name|void
name|init_sem
name|__P
argument_list|(
operator|(
name|bool
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_sem
parameter_list|(
name|owner
parameter_list|)
name|bool
name|owner
decl_stmt|;
block|{
if|#
directive|if
name|_FFR_USE_SEM_LOCKING
if|#
directive|if
name|SM_CONF_SEM
name|SemId
operator|=
name|sm_sem_start
argument_list|(
name|SemKey
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|SemId
operator|<
literal|0
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"func=init_sem, sem_key=%ld, sm_sem_start=%d"
argument_list|,
operator|(
name|long
operator|)
name|SemKey
argument_list|,
name|SemId
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* SM_CONF_SEM */
endif|#
directive|endif
comment|/* _FFR_USE_SEM_LOCKING */
return|return;
block|}
end_function

begin_comment
comment|/* **  STOP_SEM -- stop semaphore system ** **	Parameters: **		owner -- is this the owner of semaphores? ** **	Returns: **		none. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|stop_sem
name|__P
argument_list|(
operator|(
name|bool
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|stop_sem
parameter_list|(
name|owner
parameter_list|)
name|bool
name|owner
decl_stmt|;
block|{
if|#
directive|if
name|_FFR_USE_SEM_LOCKING
if|#
directive|if
name|SM_CONF_SEM
if|if
condition|(
name|owner
operator|&&
name|SemId
operator|>=
literal|0
condition|)
name|sm_sem_stop
argument_list|(
name|SemId
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SM_CONF_SEM */
endif|#
directive|endif
comment|/* _FFR_USE_SEM_LOCKING */
return|return;
block|}
end_function

begin_comment
comment|/* **  UPD_QS -- update information about queue when adding/deleting an entry ** **	Parameters: **		e -- envelope. **		count -- add/remove entry (+1/0/-1: add/no change/remove) **		space -- update the space available as well. **			(>0/0/<0: add/no change/remove) **		where -- caller (for logging) ** **	Returns: **		none. ** **	Side Effects: **		Modifies available space in filesystem. **		Changes number of entries in queue directory. */
end_comment

begin_function
name|void
name|upd_qs
parameter_list|(
name|e
parameter_list|,
name|count
parameter_list|,
name|space
parameter_list|,
name|where
parameter_list|)
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|space
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
block|{
name|short
name|fidx
decl_stmt|;
name|int
name|idx
decl_stmt|;
if|#
directive|if
name|_FFR_USE_SEM_LOCKING
name|int
name|r
decl_stmt|;
endif|#
directive|endif
comment|/* _FFR_USE_SEM_LOCKING */
name|long
name|s
decl_stmt|;
if|if
condition|(
name|ShmId
operator|==
name|SM_SHM_NO_ID
operator|||
name|e
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|e
operator|->
name|e_qgrp
operator|==
name|NOQGRP
operator|||
name|e
operator|->
name|e_qdir
operator|==
name|NOQDIR
condition|)
return|return;
name|idx
operator|=
name|Queue
index|[
name|e
operator|->
name|e_qgrp
index|]
operator|->
name|qg_qpaths
index|[
name|e
operator|->
name|e_qdir
index|]
operator|.
name|qp_idx
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|73
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"func=upd_qs, count=%d, space=%d, where=%s, idx=%d, entries=%d\n"
argument_list|,
name|count
argument_list|,
name|space
argument_list|,
name|where
argument_list|,
name|idx
argument_list|,
name|QSHM_ENTRIES
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX in theory this needs to be protected with a mutex */
if|if
condition|(
name|QSHM_ENTRIES
argument_list|(
name|idx
argument_list|)
operator|>=
literal|0
operator|&&
name|count
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
name|_FFR_USE_SEM_LOCKING
name|r
operator|=
name|sm_sem_acq
argument_list|(
name|SemId
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_USE_SEM_LOCKING */
name|QSHM_ENTRIES
argument_list|(
name|idx
argument_list|)
operator|+=
name|count
expr_stmt|;
if|#
directive|if
name|_FFR_USE_SEM_LOCKING
if|if
condition|(
name|r
operator|>=
literal|0
condition|)
name|r
operator|=
name|sm_sem_rel
argument_list|(
name|SemId
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_USE_SEM_LOCKING */
block|}
name|fidx
operator|=
name|Queue
index|[
name|e
operator|->
name|e_qgrp
index|]
operator|->
name|qg_qpaths
index|[
name|e
operator|->
name|e_qdir
index|]
operator|.
name|qp_fsysidx
expr_stmt|;
if|if
condition|(
name|fidx
operator|<
literal|0
condition|)
return|return;
comment|/* update available space also?  (might be loseqfile) */
if|if
condition|(
name|space
operator|==
literal|0
condition|)
return|return;
comment|/* convert size to blocks; this causes rounding errors */
name|s
operator|=
name|e
operator|->
name|e_msgsize
operator|/
name|FILE_SYS_BLKSIZE
argument_list|(
name|fidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
return|return;
comment|/* XXX in theory this needs to be protected with a mutex */
if|if
condition|(
name|space
operator|>
literal|0
condition|)
name|FILE_SYS_AVAIL
argument_list|(
name|fidx
argument_list|)
operator|+=
name|s
expr_stmt|;
else|else
name|FILE_SYS_AVAIL
argument_list|(
name|fidx
argument_list|)
operator|-=
name|s
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|_FFR_SELECT_SHM
end_if

begin_decl_stmt
specifier|static
name|bool
name|write_key_file
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|read_key_file
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  WRITE_KEY_FILE -- record some key into a file. ** **	Parameters: **		keypath -- file name. **		key -- key to write. ** **	Returns: **		true iff file could be written. ** **	Side Effects: **		writes file. */
end_comment

begin_function
specifier|static
name|bool
name|write_key_file
parameter_list|(
name|keypath
parameter_list|,
name|key
parameter_list|)
name|char
modifier|*
name|keypath
decl_stmt|;
name|long
name|key
decl_stmt|;
block|{
name|bool
name|ok
decl_stmt|;
name|long
name|sff
decl_stmt|;
name|SM_FILE_T
modifier|*
name|keyf
decl_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|keypath
operator|==
name|NULL
operator|||
operator|*
name|keypath
operator|==
literal|'\0'
condition|)
return|return
name|ok
return|;
name|sff
operator|=
name|SFF_NOLINK
operator||
name|SFF_ROOTOK
operator||
name|SFF_REGONLY
operator||
name|SFF_CREAT
expr_stmt|;
if|if
condition|(
name|TrustedUid
operator|!=
literal|0
operator|&&
name|RealUid
operator|==
name|TrustedUid
condition|)
name|sff
operator||=
name|SFF_OPENASROOT
expr_stmt|;
name|keyf
operator|=
name|safefopen
argument_list|(
name|keypath
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
argument_list|,
name|FileMode
argument_list|,
name|sff
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyf
operator|==
name|NULL
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"unable to write %s: %s"
argument_list|,
name|keypath
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|geteuid
argument_list|()
operator|==
literal|0
operator|&&
name|RunAsUid
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
name|HASFCHOWN
name|int
name|fd
decl_stmt|;
name|fd
operator|=
name|keyf
operator|->
name|f_file
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
operator|&&
name|fchown
argument_list|(
name|fd
argument_list|,
name|RunAsUid
argument_list|,
operator|-
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|err
init|=
name|errno
decl_stmt|;
name|sm_syslog
argument_list|(
name|LOG_ALERT
argument_list|,
name|NOQID
argument_list|,
literal|"ownership change on %s to %d failed: %s"
argument_list|,
name|keypath
argument_list|,
name|RunAsUid
argument_list|,
name|sm_errstring
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HASFCHOWN */
block|}
name|ok
operator|=
name|sm_io_fprintf
argument_list|(
name|keyf
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%ld\n"
argument_list|,
name|key
argument_list|)
operator|!=
name|SM_IO_EOF
expr_stmt|;
name|ok
operator|=
operator|(
name|sm_io_close
argument_list|(
name|keyf
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
operator|!=
name|SM_IO_EOF
operator|)
operator|&&
name|ok
expr_stmt|;
block|}
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/* **  READ_KEY_FILE -- read a key from a file. ** **	Parameters: **		keypath -- file name. **		key -- default key. ** **	Returns: **		key. */
end_comment

begin_function
specifier|static
name|long
name|read_key_file
parameter_list|(
name|keypath
parameter_list|,
name|key
parameter_list|)
name|char
modifier|*
name|keypath
decl_stmt|;
name|long
name|key
decl_stmt|;
block|{
name|int
name|r
decl_stmt|;
name|long
name|sff
decl_stmt|,
name|n
decl_stmt|;
name|SM_FILE_T
modifier|*
name|keyf
decl_stmt|;
if|if
condition|(
name|keypath
operator|==
name|NULL
operator|||
operator|*
name|keypath
operator|==
literal|'\0'
condition|)
return|return
name|key
return|;
name|sff
operator|=
name|SFF_NOLINK
operator||
name|SFF_ROOTOK
operator||
name|SFF_REGONLY
expr_stmt|;
if|if
condition|(
name|RealUid
operator|==
literal|0
operator|||
operator|(
name|TrustedUid
operator|!=
literal|0
operator|&&
name|RealUid
operator|==
name|TrustedUid
operator|)
condition|)
name|sff
operator||=
name|SFF_OPENASROOT
expr_stmt|;
name|keyf
operator|=
name|safefopen
argument_list|(
name|keypath
argument_list|,
name|O_RDONLY
argument_list|,
name|FileMode
argument_list|,
name|sff
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyf
operator|==
name|NULL
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"unable to read %s: %s"
argument_list|,
name|keypath
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|sm_io_fscanf
argument_list|(
name|keyf
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%ld"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|1
condition|)
name|key
operator|=
name|n
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|keyf
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
block|}
return|return
name|key
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_SELECT_SHM */
end_comment

begin_comment
comment|/* **  INIT_SHM -- initialize shared memory structure ** **	Initialize or attach to shared memory segment. **	Currently it is not a fatal error if this doesn't work. **	However, it causes us to have a "fallback" storage location **	for everything that is supposed to be in the shared memory, **	which makes the code slightly ugly. ** **	Parameters: **		qn -- number of queue directories. **		owner -- owner of shared memory. **		hash -- identifies data that is stored in shared memory. ** **	Returns: **		none. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|init_shm
name|__P
argument_list|(
operator|(
name|int
operator|,
name|bool
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_shm
parameter_list|(
name|qn
parameter_list|,
name|owner
parameter_list|,
name|hash
parameter_list|)
name|int
name|qn
decl_stmt|;
name|bool
name|owner
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
if|#
directive|if
name|_FFR_SELECT_SHM
name|bool
name|keyselect
decl_stmt|;
endif|#
directive|endif
comment|/* _FFR_SELECT_SHM */
name|PtrFileSys
operator|=
operator|&
name|FileSys
index|[
literal|0
index|]
expr_stmt|;
name|PNumFileSys
operator|=
operator|&
name|Numfilesys
expr_stmt|;
if|#
directive|if
name|_FFR_SELECT_SHM
comment|/* if this "key" is specified: select one yourself */
define|#
directive|define
name|SEL_SHM_KEY
value|((key_t) -1)
define|#
directive|define
name|FIRST_SHM_KEY
value|25
endif|#
directive|endif
comment|/* _FFR_SELECT_SHM */
comment|/* This allows us to disable shared memory at runtime. */
if|if
condition|(
name|ShmKey
operator|==
literal|0
condition|)
return|return;
name|count
operator|=
literal|0
expr_stmt|;
name|shms
operator|=
name|SM_T_SIZE
operator|+
name|qn
operator|*
sizeof|sizeof
argument_list|(
name|QUEUE_SHM_T
argument_list|)
expr_stmt|;
if|#
directive|if
name|_FFR_SELECT_SHM
name|keyselect
operator|=
name|ShmKey
operator|==
name|SEL_SHM_KEY
expr_stmt|;
if|if
condition|(
name|keyselect
condition|)
block|{
if|if
condition|(
name|owner
condition|)
name|ShmKey
operator|=
name|FIRST_SHM_KEY
expr_stmt|;
else|else
block|{
name|ShmKey
operator|=
name|read_key_file
argument_list|(
name|ShmKeyFile
argument_list|,
name|ShmKey
argument_list|)
expr_stmt|;
name|keyselect
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|ShmKey
operator|==
name|SEL_SHM_KEY
condition|)
goto|goto
name|error
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* _FFR_SELECT_SHM */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* allow read/write access for group? */
name|Pshm
operator|=
name|sm_shmstart
argument_list|(
name|ShmKey
argument_list|,
name|shms
argument_list|,
name|SHM_R
operator||
name|SHM_W
operator||
operator|(
name|SHM_R
operator|>>
literal|3
operator|)
operator||
operator|(
name|SHM_W
operator|>>
literal|3
operator|)
argument_list|,
operator|&
name|ShmId
argument_list|,
name|owner
argument_list|)
expr_stmt|;
name|save_errno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|Pshm
operator|!=
name|NULL
operator|||
operator|!
name|sm_file_exists
argument_list|(
name|save_errno
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|++
name|count
operator|>=
literal|3
condition|)
block|{
if|#
directive|if
name|_FFR_SELECT_SHM
if|if
condition|(
name|keyselect
condition|)
block|{
operator|++
name|ShmKey
expr_stmt|;
comment|/* back where we started? */
if|if
condition|(
name|ShmKey
operator|==
name|SEL_SHM_KEY
condition|)
break|break;
continue|continue;
block|}
endif|#
directive|endif
comment|/* _FFR_SELECT_SHM */
break|break;
block|}
if|#
directive|if
name|_FFR_SELECT_SHM
comment|/* only sleep if we are at the first key */
if|if
condition|(
operator|!
name|keyselect
operator|||
name|ShmKey
operator|==
name|SEL_SHM_KEY
condition|)
endif|#
directive|endif
comment|/* _FFR_SELECT_SHM */
name|sleep
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Pshm
operator|!=
name|NULL
condition|)
block|{
name|int
modifier|*
name|p
decl_stmt|;
if|#
directive|if
name|_FFR_SELECT_SHM
if|if
condition|(
name|keyselect
condition|)
operator|(
name|void
operator|)
name|write_key_file
argument_list|(
name|ShmKeyFile
argument_list|,
operator|(
name|long
operator|)
name|ShmKey
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_SELECT_SHM */
if|if
condition|(
name|owner
operator|&&
name|RunAsUid
operator|!=
literal|0
condition|)
block|{
name|i
operator|=
name|sm_shmsetowner
argument_list|(
name|ShmId
argument_list|,
name|RunAsUid
argument_list|,
name|RunAsGid
argument_list|,
literal|0660
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"key=%ld, sm_shmsetowner=%d, RunAsUid=%d, RunAsGid=%d"
argument_list|,
operator|(
name|long
operator|)
name|ShmKey
argument_list|,
name|i
argument_list|,
name|RunAsUid
argument_list|,
name|RunAsGid
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
operator|(
name|int
operator|*
operator|)
name|Pshm
expr_stmt|;
if|if
condition|(
name|owner
condition|)
block|{
operator|*
name|p
operator|=
operator|(
name|int
operator|)
name|shms
expr_stmt|;
operator|*
operator|(
operator|(
name|pid_t
operator|*
operator|)
name|SHM_OFF_PID
argument_list|(
name|Pshm
argument_list|)
operator|)
operator|=
name|CurrentPid
expr_stmt|;
name|p
operator|=
operator|(
name|int
operator|*
operator|)
name|SHM_OFF_TAG
argument_list|(
name|Pshm
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|hash
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|p
operator|!=
operator|(
name|int
operator|)
name|shms
condition|)
block|{
name|save_errno
operator|=
name|EINVAL
expr_stmt|;
name|cleanup_shm
argument_list|(
name|false
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|p
operator|=
operator|(
name|int
operator|*
operator|)
name|SHM_OFF_TAG
argument_list|(
name|Pshm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
operator|(
name|int
operator|)
name|hash
condition|)
block|{
name|save_errno
operator|=
name|EINVAL
expr_stmt|;
name|cleanup_shm
argument_list|(
name|false
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* 			**  XXX how to check the pid? 			**  Read it from the pid-file? That does 			**  not need to exist. 			**  We could disable shm if we can't confirm 			**  that it is the right one. 			*/
block|}
name|PtrFileSys
operator|=
operator|(
name|FILESYS
operator|*
operator|)
name|OFF_FILE_SYS
argument_list|(
name|Pshm
argument_list|)
expr_stmt|;
name|PNumFileSys
operator|=
operator|(
name|int
operator|*
operator|)
name|OFF_NUM_FILE_SYS
argument_list|(
name|Pshm
argument_list|)
expr_stmt|;
name|QShm
operator|=
operator|(
name|QUEUE_SHM_T
operator|*
operator|)
name|OFF_QUEUE_SHM
argument_list|(
name|Pshm
argument_list|)
expr_stmt|;
name|PRSATmpCnt
operator|=
operator|(
name|int
operator|*
operator|)
name|OFF_RSA_TMP_CNT
argument_list|(
name|Pshm
argument_list|)
expr_stmt|;
operator|*
name|PRSATmpCnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|owner
condition|)
block|{
comment|/* initialize values in shared memory */
name|NumFileSys
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qn
condition|;
name|i
operator|++
control|)
name|QShm
index|[
name|i
index|]
operator|.
name|qs_entries
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|init_sem
argument_list|(
name|owner
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
label|:
if|if
condition|(
name|LogLevel
operator|>
operator|(
name|owner
condition|?
literal|8
else|:
literal|11
operator|)
condition|)
block|{
name|sm_syslog
argument_list|(
name|owner
condition|?
name|LOG_ERR
else|:
name|LOG_NOTICE
argument_list|,
name|NOQID
argument_list|,
literal|"can't %s shared memory, key=%ld: %s"
argument_list|,
name|owner
condition|?
literal|"initialize"
else|:
literal|"attach to"
argument_list|,
operator|(
name|long
operator|)
name|ShmKey
argument_list|,
name|sm_errstring
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SM_CONF_SHM */
end_comment

begin_comment
comment|/* **  SETUP_QUEUES -- setup all queue groups ** **	Parameters: **		owner -- owner of shared memory. ** **	Returns: **		none. ** #if SM_CONF_SHM **	Side Effects: **		attaches shared memory. #endif * SM_CONF_SHM * */
end_comment

begin_function
name|void
name|setup_queues
parameter_list|(
name|owner
parameter_list|)
name|bool
name|owner
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|qn
decl_stmt|,
name|len
decl_stmt|;
name|unsigned
name|int
name|hashval
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|char
name|basedir
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
comment|/* 	**  Determine basedir for all queue directories. 	**  All queue directories must be (first level) subdirectories 	**  of the basedir.  The basedir is the QueueDir 	**  without wildcards, but with trailing / 	*/
name|hashval
operator|=
literal|0
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|sm_strlcpy
argument_list|(
name|basedir
argument_list|,
name|QueueDir
argument_list|,
sizeof|sizeof
name|basedir
argument_list|)
expr_stmt|;
comment|/* Provide space for trailing '/' */
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
name|basedir
operator|-
literal|1
condition|)
block|{
name|syserr
argument_list|(
literal|"QueueDirectory: path too long: %d,  max %d"
argument_list|,
name|len
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
name|basedir
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_CONFIG
expr_stmt|;
return|return;
block|}
name|SM_ASSERT
argument_list|(
name|len
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|basedir
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|SM_LAST_DIR_DELIM
argument_list|(
name|basedir
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"QueueDirectory: can not wildcard relative path \"%s\""
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"setup_queues: \"%s\": Can not wildcard relative path.\n"
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_CONFIG
expr_stmt|;
return|return;
block|}
comment|/* cut off wildcard pattern */
operator|*
operator|++
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|cp
operator|-
name|basedir
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|SM_IS_DIR_DELIM
argument_list|(
name|basedir
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* append trailing slash since it is a directory */
name|basedir
index|[
name|len
index|]
operator|=
literal|'/'
expr_stmt|;
name|basedir
index|[
operator|++
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* len counts up to the last directory delimiter */
name|SM_ASSERT
argument_list|(
name|basedir
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|basedir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|syserr
argument_list|(
literal|"can not chdir(%s)"
argument_list|,
name|basedir
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_errno
operator|==
name|EACCES
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioerr
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Program mode requires special privileges, e.g., root or TrustedUser.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"setup_queues: \"%s\": %s\n"
argument_list|,
name|basedir
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_CONFIG
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|SM_CONF_SHM
name|hashval
operator|=
name|hash_q
argument_list|(
name|basedir
argument_list|,
name|hashval
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SM_CONF_SHM */
comment|/* initialize for queue runs */
name|DoQueueRun
operator|=
name|false
expr_stmt|;
name|now
operator|=
name|curtime
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NumQueue
operator|&&
name|Queue
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|Queue
index|[
name|i
index|]
operator|->
name|qg_nextrun
operator|=
name|now
expr_stmt|;
if|if
condition|(
name|UseMSP
operator|&&
name|OpMode
operator|!=
name|MD_TEST
condition|)
block|{
name|long
name|sff
init|=
name|SFF_CREAT
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
literal|"."
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"can not stat(%s)"
argument_list|,
name|basedir
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"setup_queues: \"%s\": %s\n"
argument_list|,
name|basedir
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_CONFIG
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|RunAsUid
operator|==
literal|0
condition|)
name|sff
operator||=
name|SFF_ROOTOK
expr_stmt|;
comment|/* 		**  Check queue directory permissions. 		**	Can we write to a group writable queue directory? 		*/
if|if
condition|(
name|bitset
argument_list|(
name|S_IWGRP
argument_list|,
name|QueueFileMode
argument_list|)
operator|&&
name|bitset
argument_list|(
name|S_IWGRP
argument_list|,
name|st
operator|.
name|st_mode
argument_list|)
operator|&&
name|safefile
argument_list|(
literal|" "
argument_list|,
name|RunAsUid
argument_list|,
name|RunAsGid
argument_list|,
name|RunAsUserName
argument_list|,
name|sff
argument_list|,
name|QueueFileMode
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"can not write to queue directory %s (RunAsGid=%d, required=%d)"
argument_list|,
name|basedir
argument_list|,
operator|(
name|int
operator|)
name|RunAsGid
argument_list|,
operator|(
name|int
operator|)
name|st
operator|.
name|st_gid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|S_IWOTH
operator||
name|S_IXOTH
argument_list|,
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|#
directive|if
name|_FFR_MSP_PARANOIA
name|syserr
argument_list|(
literal|"dangerous permissions=%o on queue directory %s"
argument_list|,
operator|(
name|int
operator|)
name|st
operator|.
name|st_mode
argument_list|,
name|basedir
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* _FFR_MSP_PARANOIA */
if|if
condition|(
name|LogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"dangerous permissions=%o on queue directory %s"
argument_list|,
operator|(
name|int
operator|)
name|st
operator|.
name|st_mode
argument_list|,
name|basedir
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_MSP_PARANOIA */
block|}
if|#
directive|if
name|_FFR_MSP_PARANOIA
if|if
condition|(
name|NumQueue
operator|>
literal|1
condition|)
name|syserr
argument_list|(
literal|"can not use multiple queues for MSP"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_MSP_PARANOIA */
block|}
comment|/* initial number of queue directories */
name|qn
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NumQueue
operator|&&
name|Queue
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|qn
operator|=
name|multiqueue_cache
argument_list|(
name|basedir
argument_list|,
name|len
argument_list|,
name|Queue
index|[
name|i
index|]
argument_list|,
name|qn
argument_list|,
operator|&
name|hashval
argument_list|)
expr_stmt|;
if|#
directive|if
name|SM_CONF_SHM
name|init_shm
argument_list|(
name|qn
argument_list|,
name|owner
argument_list|,
name|hashval
argument_list|)
expr_stmt|;
name|i
operator|=
name|filesys_setup
argument_list|(
name|owner
operator|||
name|ShmId
operator|==
name|SM_SHM_NO_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|FSF_NOT_FOUND
condition|)
block|{
comment|/* 		**  We didn't get the right filesystem data 		**  This may happen if we don't have the right shared memory. 		**  So let's do this without shared memory. 		*/
name|SM_ASSERT
argument_list|(
operator|!
name|owner
argument_list|)
expr_stmt|;
name|cleanup_shm
argument_list|(
name|false
argument_list|)
expr_stmt|;
comment|/* release shared memory */
name|i
operator|=
name|filesys_setup
argument_list|(
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"filesys_setup failed twice, result=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"shared memory does not contain expected data, ignored"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* SM_CONF_SHM */
name|i
operator|=
name|filesys_setup
argument_list|(
name|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SM_CONF_SHM */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|ExitStat
operator|=
name|EX_CONFIG
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|SM_CONF_SHM
end_if

begin_comment
comment|/* **  CLEANUP_SHM -- do some cleanup work for shared memory etc ** **	Parameters: **		owner -- owner of shared memory? ** **	Returns: **		none. ** **	Side Effects: **		detaches shared memory. */
end_comment

begin_function
name|void
name|cleanup_shm
parameter_list|(
name|owner
parameter_list|)
name|bool
name|owner
decl_stmt|;
block|{
if|if
condition|(
name|ShmId
operator|!=
name|SM_SHM_NO_ID
condition|)
block|{
if|if
condition|(
name|sm_shmstop
argument_list|(
name|Pshm
argument_list|,
name|ShmId
argument_list|,
name|owner
argument_list|)
operator|<
literal|0
operator|&&
name|LogLevel
operator|>
literal|8
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"sm_shmstop failed=%s"
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|Pshm
operator|=
name|NULL
expr_stmt|;
name|ShmId
operator|=
name|SM_SHM_NO_ID
expr_stmt|;
block|}
name|stop_sem
argument_list|(
name|owner
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SM_CONF_SHM */
end_comment

begin_comment
comment|/* **  CLEANUP_QUEUES -- do some cleanup work for queues ** **	Parameters: **		none. ** **	Returns: **		none. ** */
end_comment

begin_function
name|void
name|cleanup_queues
parameter_list|()
block|{
name|sync_queue_time
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  SET_DEF_QUEUEVAL -- set default values for a queue group. ** **	Parameters: **		qg -- queue group **		all -- set all values (true for default group)? ** **	Returns: **		none. ** **	Side Effects: **		sets default values for the queue group. */
end_comment

begin_function
name|void
name|set_def_queueval
parameter_list|(
name|qg
parameter_list|,
name|all
parameter_list|)
name|QUEUEGRP
modifier|*
name|qg
decl_stmt|;
name|bool
name|all
decl_stmt|;
block|{
if|if
condition|(
name|bitnset
argument_list|(
name|QD_DEFINED
argument_list|,
name|qg
operator|->
name|qg_flags
argument_list|)
condition|)
return|return;
if|if
condition|(
name|all
condition|)
name|qg
operator|->
name|qg_qdir
operator|=
name|QueueDir
expr_stmt|;
if|#
directive|if
name|_FFR_QUEUE_GROUP_SORTORDER
name|qg
operator|->
name|qg_sortorder
operator|=
name|QueueSortOrder
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_QUEUE_GROUP_SORTORDER */
name|qg
operator|->
name|qg_maxqrun
operator|=
name|all
condition|?
name|MaxRunnersPerQueue
else|:
operator|-
literal|1
expr_stmt|;
name|qg
operator|->
name|qg_nice
operator|=
name|NiceQueueRun
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  MAKEQUEUE -- define a new queue. ** **	Parameters: **		line -- description of queue.  This is in labeled fields. **			The fields are: **			   F -- the flags associated with the queue **			   I -- the interval between running the queue **			   J -- the maximum # of jobs in work list **			   [M -- the maximum # of jobs in a queue run] **			   N -- the niceness at which to run **			   P -- the path to the queue **			   S -- the queue sorting order **			   R -- number of parallel queue runners **			   r -- max recipients per envelope **			The first word is the canonical name of the queue. **		qdef -- this is a 'Q' definition from .cf ** **	Returns: **		none. ** **	Side Effects: **		enters the queue into the queue table. */
end_comment

begin_function
name|void
name|makequeue
parameter_list|(
name|line
parameter_list|,
name|qdef
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|bool
name|qdef
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|QUEUEGRP
modifier|*
name|qg
decl_stmt|;
specifier|register
name|STAB
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|fcode
decl_stmt|;
comment|/* allocate a queue and set up defaults */
name|qg
operator|=
operator|(
name|QUEUEGRP
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|qg
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qg
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
expr|*
name|qg
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|syserr
argument_list|(
literal|"name required for queue"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* collect the queue name */
for|for
control|(
name|p
operator|=
name|line
init|;
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|','
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|;
name|p
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|qg
operator|->
name|qg_name
operator|=
name|newstr
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* set default values, can be overridden below */
name|set_def_queueval
argument_list|(
name|qg
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* now scan through and assign info from the fields */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
specifier|auto
name|char
modifier|*
name|delimptr
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|(
operator|*
name|p
operator|==
literal|','
operator|||
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|)
condition|)
name|p
operator|++
expr_stmt|;
comment|/* p now points to field code */
name|fcode
operator|=
operator|*
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|'='
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'='
condition|)
block|{
name|syserr
argument_list|(
literal|"queue %s: `=' expected"
argument_list|,
name|qg
operator|->
name|qg_name
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
comment|/* p now points to the field body */
name|p
operator|=
name|munchstring
argument_list|(
name|p
argument_list|,
operator|&
name|delimptr
argument_list|,
literal|','
argument_list|)
expr_stmt|;
comment|/* install the field into the queue struct */
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
literal|'P'
case|:
comment|/* pathname */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|syserr
argument_list|(
literal|"queue %s: empty path name"
argument_list|,
name|qg
operator|->
name|qg_name
argument_list|)
expr_stmt|;
else|else
name|qg
operator|->
name|qg_qdir
operator|=
name|newstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* flags */
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|)
name|setbitn
argument_list|(
operator|*
name|p
argument_list|,
name|qg
operator|->
name|qg_flags
argument_list|)
expr_stmt|;
break|break;
comment|/* 			**  Do we need two intervals here: 			**  One for persistent queue runners, 			**  one for "normal" queue runs? 			*/
case|case
literal|'I'
case|:
comment|/* interval between running the queue */
name|qg
operator|->
name|qg_queueintvl
operator|=
name|convtime
argument_list|(
name|p
argument_list|,
literal|'m'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* run niceness */
name|qg
operator|->
name|qg_nice
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* maximum # of runners for the group */
name|i
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* can't have more runners than allowed total */
if|if
condition|(
name|MaxQueueChildren
operator|>
literal|0
operator|&&
name|i
operator|>
name|MaxQueueChildren
condition|)
block|{
name|qg
operator|->
name|qg_maxqrun
operator|=
name|MaxQueueChildren
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Q=%s: R=%d exceeds MaxQueueChildren=%d, set to MaxQueueChildren\n"
argument_list|,
name|qg
operator|->
name|qg_name
argument_list|,
name|i
argument_list|,
name|MaxQueueChildren
argument_list|)
expr_stmt|;
block|}
else|else
name|qg
operator|->
name|qg_maxqrun
operator|=
name|i
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
comment|/* maximum # of jobs in work list */
name|qg
operator|->
name|qg_maxlist
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* max recipients per envelope */
name|qg
operator|->
name|qg_maxrcpt
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|_FFR_QUEUE_GROUP_SORTORDER
case|case
literal|'S'
case|:
comment|/* queue sorting order */
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'h'
case|:
comment|/* Host first */
case|case
literal|'H'
case|:
name|qg
operator|->
name|qg_sortorder
operator|=
name|QSO_BYHOST
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* Priority order */
case|case
literal|'P'
case|:
name|qg
operator|->
name|qg_sortorder
operator|=
name|QSO_BYPRIORITY
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* Submission time */
case|case
literal|'T'
case|:
name|qg
operator|->
name|qg_sortorder
operator|=
name|QSO_BYTIME
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* File name */
case|case
literal|'F'
case|:
name|qg
operator|->
name|qg_sortorder
operator|=
name|QSO_BYFILENAME
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* Modification time */
case|case
literal|'M'
case|:
name|qg
operator|->
name|qg_sortorder
operator|=
name|QSO_BYMODTIME
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* Random */
case|case
literal|'R'
case|:
name|qg
operator|->
name|qg_sortorder
operator|=
name|QSO_RANDOM
expr_stmt|;
break|break;
if|#
directive|if
name|_FFR_RHS
case|case
literal|'s'
case|:
comment|/* Shuffled host name */
case|case
literal|'S'
case|:
name|qg
operator|->
name|qg_sortorder
operator|=
name|QSO_BYSHUFFLE
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* _FFR_RHS */
case|case
literal|'n'
case|:
comment|/* none */
case|case
literal|'N'
case|:
name|qg
operator|->
name|qg_sortorder
operator|=
name|QSO_NONE
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
literal|"Invalid queue sort order \"%s\""
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* _FFR_QUEUE_GROUP_SORTORDER */
default|default:
name|syserr
argument_list|(
literal|"Q%s: unknown queue equate %c="
argument_list|,
name|qg
operator|->
name|qg_name
argument_list|,
name|fcode
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|delimptr
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|HASNICE
if|if
condition|(
name|qg
operator|->
name|qg_nice
operator|!=
name|NiceQueueRun
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Q%s: Warning: N= set on system that doesn't support nice()\n"
argument_list|,
name|qg
operator|->
name|qg_name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !HASNICE */
comment|/* do some rationality checking */
if|if
condition|(
name|NumQueue
operator|>=
name|MAXQUEUEGROUPS
condition|)
block|{
name|syserr
argument_list|(
literal|"too many queue groups defined (%d max)"
argument_list|,
name|MAXQUEUEGROUPS
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|qg
operator|->
name|qg_qdir
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|QueueDir
operator|==
name|NULL
operator|||
operator|*
name|QueueDir
operator|==
literal|'\0'
condition|)
block|{
name|syserr
argument_list|(
literal|"QueueDir must be defined before queue groups"
argument_list|)
expr_stmt|;
return|return;
block|}
name|qg
operator|->
name|qg_qdir
operator|=
name|newstr
argument_list|(
name|QueueDir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qg
operator|->
name|qg_maxqrun
operator|>
literal|1
operator|&&
operator|!
name|bitnset
argument_list|(
name|QD_FORK
argument_list|,
name|qg
operator|->
name|qg_flags
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Warning: Q=%s: R=%d: multiple queue runners specified\n\tbut flag '%c' is not set\n"
argument_list|,
name|qg
operator|->
name|qg_name
argument_list|,
name|qg
operator|->
name|qg_maxqrun
argument_list|,
name|QD_FORK
argument_list|)
expr_stmt|;
block|}
comment|/* enter the queue into the symbol table */
if|if
condition|(
name|tTd
argument_list|(
literal|37
argument_list|,
literal|8
argument_list|)
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"Adding %s to stab, path: %s"
argument_list|,
name|qg
operator|->
name|qg_name
argument_list|,
name|qg
operator|->
name|qg_qdir
argument_list|)
expr_stmt|;
name|s
operator|=
name|stab
argument_list|(
name|qg
operator|->
name|qg_name
argument_list|,
name|ST_QUEUE
argument_list|,
name|ST_ENTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s_quegrp
operator|!=
name|NULL
condition|)
block|{
name|i
operator|=
name|s
operator|->
name|s_quegrp
operator|->
name|qg_index
expr_stmt|;
comment|/* XXX what about the pointers inside this struct? */
name|sm_free
argument_list|(
name|s
operator|->
name|s_quegrp
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
else|else
name|i
operator|=
name|NumQueue
operator|++
expr_stmt|;
name|Queue
index|[
name|i
index|]
operator|=
name|s
operator|->
name|s_quegrp
operator|=
name|qg
expr_stmt|;
name|qg
operator|->
name|qg_index
operator|=
name|i
expr_stmt|;
comment|/* set default value for max queue runners */
if|if
condition|(
name|qg
operator|->
name|qg_maxqrun
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|MaxRunnersPerQueue
operator|>
literal|0
condition|)
name|qg
operator|->
name|qg_maxqrun
operator|=
name|MaxRunnersPerQueue
expr_stmt|;
else|else
name|qg
operator|->
name|qg_maxqrun
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|qdef
condition|)
name|setbitn
argument_list|(
name|QD_DEFINED
argument_list|,
name|qg
operator|->
name|qg_flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* **  HASHFQN -- calculate a hash value for a fully qualified host name ** **	Arguments: **		fqn -- an all lower-case host.domain string **		buckets -- the number of buckets (queue directories) ** **	Returns: **		a bucket number (signed integer) **		-1 on error ** **	Contributed by Exactis.com, Inc. */
end_comment

begin_comment
unit|int hashfqn(fqn, buckets) 	register char *fqn; 	int buckets; { 	register char *p; 	register int h = 0, hash, cnt;  	if (fqn == NULL) 		return -1;
comment|/* 	**  A variation on the gdb hash 	**  This is the best as of Feb 19, 1996 --bcx 	*/
end_comment

begin_endif
unit|p = fqn; 	h = 0x238F13AF * strlen(p); 	for (cnt = 0; *p != 0; ++p, cnt++) 	{ 		h = (h + (*p<< (cnt * 5 % 24)))& 0x7FFFFFFF; 	} 	h = (1103515243 * h + 12345)& 0x7FFFFFFF; 	if (buckets< 2) 		hash = 0; 	else 		hash = (h % buckets);  	return hash; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* **  A structure for sorting Queue according to maxqrun without **	screwing up Queue itself. */
end_comment

begin_struct
struct|struct
name|sortqgrp
block|{
name|int
name|sg_idx
decl_stmt|;
comment|/* original index */
name|int
name|sg_maxqrun
decl_stmt|;
comment|/* max queue runners */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|sortqgrp
name|SORTQGRP_T
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|int
name|cmpidx
name|__P
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|cmpidx
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|const
name|void
modifier|*
name|a
decl_stmt|;
specifier|const
name|void
modifier|*
name|b
decl_stmt|;
block|{
comment|/* The sort is highest to lowest, so the comparison is reversed */
if|if
condition|(
operator|(
operator|(
name|SORTQGRP_T
operator|*
operator|)
name|a
operator|)
operator|->
name|sg_maxqrun
operator|<
operator|(
operator|(
name|SORTQGRP_T
operator|*
operator|)
name|b
operator|)
operator|->
name|sg_maxqrun
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|SORTQGRP_T
operator|*
operator|)
name|a
operator|)
operator|->
name|sg_maxqrun
operator|>
operator|(
operator|(
name|SORTQGRP_T
operator|*
operator|)
name|b
operator|)
operator|->
name|sg_maxqrun
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* **  MAKEWORKGROUP -- balance queue groups into work groups per MaxQueueChildren ** **  Take the now defined queue groups and assign them to work groups. **  This is done to balance out the number of concurrently active **  queue runners such that MaxQueueChildren is not exceeded. This may **  result in more than one queue group per work group. In such a case **  the number of running queue groups in that work group will have no **  more than the work group maximum number of runners (a "fair" portion **  of MaxQueueRunners). All queue groups within a work group will get a **  chance at running. ** **	Parameters: **		none. ** **	Returns: **		nothing. ** **	Side Effects: **		Sets up WorkGrp structure. */
end_comment

begin_function
name|void
name|makeworkgroups
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|total_runners
decl_stmt|,
name|dir
decl_stmt|,
name|h
decl_stmt|;
name|SORTQGRP_T
name|si
index|[
name|MAXQUEUEGROUPS
operator|+
literal|1
index|]
decl_stmt|;
name|total_runners
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|NumQueue
operator|==
literal|1
operator|&&
name|strcmp
argument_list|(
name|Queue
index|[
literal|0
index|]
operator|->
name|qg_name
argument_list|,
literal|"mqueue"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		**  There is only the "mqueue" queue group (a default) 		**  containing all of the queues. We want to provide to 		**  this queue group the maximum allowable queue runners. 		**  To match older behavior (8.10/8.11) we'll try for 		**  1 runner per queue capping it at MaxQueueChildren. 		**  So if there are N queues, then there will be N runners 		**  for the "mqueue" queue group (where N is kept less than 		**  MaxQueueChildren). 		*/
name|NumWorkGroups
operator|=
literal|1
expr_stmt|;
name|WorkGrp
index|[
literal|0
index|]
operator|.
name|wg_numqgrp
operator|=
literal|1
expr_stmt|;
name|WorkGrp
index|[
literal|0
index|]
operator|.
name|wg_qgs
operator|=
operator|(
name|QUEUEGRP
operator|*
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|QUEUEGRP
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|WorkGrp
index|[
literal|0
index|]
operator|.
name|wg_qgs
index|[
literal|0
index|]
operator|=
name|Queue
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|MaxQueueChildren
operator|>
literal|0
operator|&&
name|Queue
index|[
literal|0
index|]
operator|->
name|qg_numqueues
operator|>
name|MaxQueueChildren
condition|)
name|WorkGrp
index|[
literal|0
index|]
operator|.
name|wg_runners
operator|=
name|MaxQueueChildren
expr_stmt|;
else|else
name|WorkGrp
index|[
literal|0
index|]
operator|.
name|wg_runners
operator|=
name|Queue
index|[
literal|0
index|]
operator|->
name|qg_numqueues
expr_stmt|;
name|Queue
index|[
literal|0
index|]
operator|->
name|qg_wgrp
operator|=
literal|0
expr_stmt|;
comment|/* can't have more runners than allowed total */
if|if
condition|(
name|MaxQueueChildren
operator|>
literal|0
operator|&&
name|Queue
index|[
literal|0
index|]
operator|->
name|qg_maxqrun
operator|>
name|MaxQueueChildren
condition|)
name|Queue
index|[
literal|0
index|]
operator|->
name|qg_maxqrun
operator|=
name|MaxQueueChildren
expr_stmt|;
name|WorkGrp
index|[
literal|0
index|]
operator|.
name|wg_maxact
operator|=
name|Queue
index|[
literal|0
index|]
operator|->
name|qg_maxqrun
expr_stmt|;
name|WorkGrp
index|[
literal|0
index|]
operator|.
name|wg_lowqintvl
operator|=
name|Queue
index|[
literal|0
index|]
operator|->
name|qg_queueintvl
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NumQueue
condition|;
name|i
operator|++
control|)
block|{
name|si
index|[
name|i
index|]
operator|.
name|sg_maxqrun
operator|=
name|Queue
index|[
name|i
index|]
operator|->
name|qg_maxqrun
expr_stmt|;
name|si
index|[
name|i
index|]
operator|.
name|sg_idx
operator|=
name|i
expr_stmt|;
block|}
name|qsort
argument_list|(
name|si
argument_list|,
name|NumQueue
argument_list|,
sizeof|sizeof
argument_list|(
name|si
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|cmpidx
argument_list|)
expr_stmt|;
name|NumWorkGroups
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NumQueue
condition|;
name|i
operator|++
control|)
block|{
name|total_runners
operator|+=
name|si
index|[
name|i
index|]
operator|.
name|sg_maxqrun
expr_stmt|;
if|if
condition|(
name|MaxQueueChildren
operator|<=
literal|0
operator|||
name|total_runners
operator|<=
name|MaxQueueChildren
condition|)
name|NumWorkGroups
operator|++
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|NumWorkGroups
operator|<
literal|1
condition|)
name|NumWorkGroups
operator|=
literal|1
expr_stmt|;
comment|/* gotta have one at least */
elseif|else
if|if
condition|(
name|NumWorkGroups
operator|>
name|MAXWORKGROUPS
condition|)
name|NumWorkGroups
operator|=
name|MAXWORKGROUPS
expr_stmt|;
comment|/* the limit */
comment|/* 	**  We now know the number of work groups to pack the queue groups 	**  into. The queue groups in 'Queue' are sorted from highest 	**  to lowest for the number of runners per queue group. 	**  We put the queue groups with the largest number of runners 	**  into work groups first. Then the smaller ones are fitted in 	**  where it looks best. 	*/
name|j
operator|=
literal|0
expr_stmt|;
name|dir
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NumQueue
condition|;
name|i
operator|++
control|)
block|{
comment|/* a to-and-fro packing scheme, continue from last position */
if|if
condition|(
name|j
operator|>=
name|NumWorkGroups
condition|)
block|{
name|dir
operator|=
operator|-
literal|1
expr_stmt|;
name|j
operator|=
name|NumWorkGroups
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|j
operator|<
literal|0
condition|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
name|dir
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|WorkGrp
index|[
name|j
index|]
operator|.
name|wg_qgs
operator|==
name|NULL
condition|)
name|WorkGrp
index|[
name|j
index|]
operator|.
name|wg_qgs
operator|=
operator|(
name|QUEUEGRP
operator|*
operator|*
operator|)
name|sm_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|QUEUEGRP
operator|*
argument_list|)
operator|*
operator|(
name|WorkGrp
index|[
name|j
index|]
operator|.
name|wg_numqgrp
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
else|else
name|WorkGrp
index|[
name|j
index|]
operator|.
name|wg_qgs
operator|=
operator|(
name|QUEUEGRP
operator|*
operator|*
operator|)
name|sm_realloc
argument_list|(
name|WorkGrp
index|[
name|j
index|]
operator|.
name|wg_qgs
argument_list|,
sizeof|sizeof
argument_list|(
name|QUEUEGRP
operator|*
argument_list|)
operator|*
operator|(
name|WorkGrp
index|[
name|j
index|]
operator|.
name|wg_numqgrp
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|WorkGrp
index|[
name|j
index|]
operator|.
name|wg_qgs
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"!cannot allocate memory for work queues, need %d bytes"
argument_list|,
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|QUEUEGRP
operator|*
argument_list|)
operator|*
operator|(
name|WorkGrp
index|[
name|j
index|]
operator|.
name|wg_numqgrp
operator|+
literal|1
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|h
operator|=
name|si
index|[
name|i
index|]
operator|.
name|sg_idx
expr_stmt|;
name|WorkGrp
index|[
name|j
index|]
operator|.
name|wg_qgs
index|[
name|WorkGrp
index|[
name|j
index|]
operator|.
name|wg_numqgrp
index|]
operator|=
name|Queue
index|[
name|h
index|]
expr_stmt|;
name|WorkGrp
index|[
name|j
index|]
operator|.
name|wg_numqgrp
operator|++
expr_stmt|;
name|WorkGrp
index|[
name|j
index|]
operator|.
name|wg_runners
operator|+=
name|Queue
index|[
name|h
index|]
operator|->
name|qg_maxqrun
expr_stmt|;
name|Queue
index|[
name|h
index|]
operator|->
name|qg_wgrp
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|WorkGrp
index|[
name|j
index|]
operator|.
name|wg_maxact
operator|==
literal|0
condition|)
block|{
comment|/* can't have more runners than allowed total */
if|if
condition|(
name|MaxQueueChildren
operator|>
literal|0
operator|&&
name|Queue
index|[
name|h
index|]
operator|->
name|qg_maxqrun
operator|>
name|MaxQueueChildren
condition|)
name|Queue
index|[
name|h
index|]
operator|->
name|qg_maxqrun
operator|=
name|MaxQueueChildren
expr_stmt|;
name|WorkGrp
index|[
name|j
index|]
operator|.
name|wg_maxact
operator|=
name|Queue
index|[
name|h
index|]
operator|->
name|qg_maxqrun
expr_stmt|;
block|}
comment|/* 		**  XXX: must wg_lowqintvl be the GCD? 		**  qg1: 2m, qg2: 3m, minimum: 2m, when do queue runs for 		**  qg2 occur? 		*/
comment|/* keep track of the lowest interval for a persistent runner */
if|if
condition|(
name|Queue
index|[
name|h
index|]
operator|->
name|qg_queueintvl
operator|>
literal|0
operator|&&
name|WorkGrp
index|[
name|j
index|]
operator|.
name|wg_lowqintvl
operator|<
name|Queue
index|[
name|h
index|]
operator|->
name|qg_queueintvl
condition|)
name|WorkGrp
index|[
name|j
index|]
operator|.
name|wg_lowqintvl
operator|=
name|Queue
index|[
name|h
index|]
operator|->
name|qg_queueintvl
expr_stmt|;
name|j
operator|+=
name|dir
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|9
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NumWorkGroups
condition|;
name|i
operator|++
control|)
block|{
name|sm_dprintf
argument_list|(
literal|"Workgroup[%d]="
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|WorkGrp
index|[
name|i
index|]
operator|.
name|wg_numqgrp
condition|;
name|j
operator|++
control|)
block|{
name|sm_dprintf
argument_list|(
literal|"%s, "
argument_list|,
name|WorkGrp
index|[
name|i
index|]
operator|.
name|wg_qgs
index|[
name|j
index|]
operator|->
name|qg_name
argument_list|)
expr_stmt|;
block|}
name|sm_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* **  DUP_DF -- duplicate envelope data file ** **	Copy the data file from the 'old' envelope to the 'new' envelope **	in the most efficient way possible. ** **	Create a hard link from the 'old' data file to the 'new' data file. **	If the old and new queue directories are on different file systems, **	then the new data file link is created in the old queue directory, **	and the new queue file will contain a 'd' record pointing to the **	directory containing the new data file. ** **	Parameters: **		old -- old envelope. **		new -- new envelope. ** **	Results: **		Returns true on success, false on failure. ** **	Side Effects: **		On success, the new data file is created. **		On fatal failure, EF_FATALERRS is set in old->e_flags. */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|dup_df
name|__P
argument_list|(
operator|(
name|ENVELOPE
operator|*
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bool
name|dup_df
parameter_list|(
name|old
parameter_list|,
name|new
parameter_list|)
name|ENVELOPE
modifier|*
name|old
decl_stmt|;
name|ENVELOPE
modifier|*
name|new
decl_stmt|;
block|{
name|int
name|ofs
decl_stmt|,
name|nfs
decl_stmt|,
name|r
decl_stmt|;
name|char
name|opath
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|npath
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|EF_HAS_DF
argument_list|,
name|old
operator|->
name|e_flags
argument_list|)
condition|)
block|{
comment|/* 		**  this can happen if: SuperSafe != True 		**  and a bounce mail is sent that is split. 		*/
name|queueup
argument_list|(
name|old
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|SM_REQUIRE
argument_list|(
name|ISVALIDQGRP
argument_list|(
name|old
operator|->
name|e_qgrp
argument_list|)
operator|&&
name|ISVALIDQDIR
argument_list|(
name|old
operator|->
name|e_qdir
argument_list|)
argument_list|)
expr_stmt|;
name|SM_REQUIRE
argument_list|(
name|ISVALIDQGRP
argument_list|(
name|new
operator|->
name|e_qgrp
argument_list|)
operator|&&
name|ISVALIDQDIR
argument_list|(
name|new
operator|->
name|e_qdir
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|opath
argument_list|,
name|queuename
argument_list|(
name|old
argument_list|,
name|DATAFL_LETTER
argument_list|)
argument_list|,
sizeof|sizeof
name|opath
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|npath
argument_list|,
name|queuename
argument_list|(
name|new
argument_list|,
name|DATAFL_LETTER
argument_list|)
argument_list|,
sizeof|sizeof
name|npath
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|->
name|e_dfp
operator|!=
name|NULL
condition|)
block|{
name|r
operator|=
name|sm_io_setinfo
argument_list|(
name|old
operator|->
name|e_dfp
argument_list|,
name|SM_BF_COMMIT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINVAL
condition|)
block|{
name|syserr
argument_list|(
literal|"@can't commit %s"
argument_list|,
name|opath
argument_list|)
expr_stmt|;
name|old
operator|->
name|e_flags
operator||=
name|EF_FATALERRS
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
comment|/* 	**  Attempt to create a hard link, if we think both old and new 	**  are on the same file system, otherwise copy the file. 	** 	**  Don't waste time attempting a hard link unless old and new 	**  are on the same file system. 	*/
name|SM_REQUIRE
argument_list|(
name|ISVALIDQGRP
argument_list|(
name|old
operator|->
name|e_dfqgrp
argument_list|)
operator|&&
name|ISVALIDQDIR
argument_list|(
name|old
operator|->
name|e_dfqdir
argument_list|)
argument_list|)
expr_stmt|;
name|SM_REQUIRE
argument_list|(
name|ISVALIDQGRP
argument_list|(
name|new
operator|->
name|e_dfqgrp
argument_list|)
operator|&&
name|ISVALIDQDIR
argument_list|(
name|new
operator|->
name|e_dfqdir
argument_list|)
argument_list|)
expr_stmt|;
name|ofs
operator|=
name|Queue
index|[
name|old
operator|->
name|e_dfqgrp
index|]
operator|->
name|qg_qpaths
index|[
name|old
operator|->
name|e_dfqdir
index|]
operator|.
name|qp_fsysidx
expr_stmt|;
name|nfs
operator|=
name|Queue
index|[
name|new
operator|->
name|e_dfqgrp
index|]
operator|->
name|qg_qpaths
index|[
name|new
operator|->
name|e_dfqdir
index|]
operator|.
name|qp_fsysidx
expr_stmt|;
if|if
condition|(
name|FILE_SYS_DEV
argument_list|(
name|ofs
argument_list|)
operator|==
name|FILE_SYS_DEV
argument_list|(
name|nfs
argument_list|)
condition|)
block|{
if|if
condition|(
name|link
argument_list|(
name|opath
argument_list|,
name|npath
argument_list|)
operator|==
literal|0
condition|)
block|{
name|new
operator|->
name|e_flags
operator||=
name|EF_HAS_DF
expr_stmt|;
name|SYNC_DIR
argument_list|(
name|npath
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
goto|goto
name|error
goto|;
block|}
comment|/* 	**  Can't link across queue directories, so try to create a hard 	**  link in the same queue directory as the old df file. 	**  The qf file will refer to the new df file using a 'd' record. 	*/
name|new
operator|->
name|e_dfqgrp
operator|=
name|old
operator|->
name|e_dfqgrp
expr_stmt|;
name|new
operator|->
name|e_dfqdir
operator|=
name|old
operator|->
name|e_dfqdir
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|npath
argument_list|,
name|queuename
argument_list|(
name|new
argument_list|,
name|DATAFL_LETTER
argument_list|)
argument_list|,
sizeof|sizeof
name|npath
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
name|opath
argument_list|,
name|npath
argument_list|)
operator|==
literal|0
condition|)
block|{
name|new
operator|->
name|e_flags
operator||=
name|EF_HAS_DF
expr_stmt|;
name|SYNC_DIR
argument_list|(
name|npath
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|error
label|:
if|if
condition|(
name|LogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|old
operator|->
name|e_id
argument_list|,
literal|"dup_df: can't link %s to %s, error=%s, envelope splitting failed"
argument_list|,
name|opath
argument_list|,
name|npath
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* **  SPLIT_ENV -- Allocate a new envelope based on a given envelope. ** **	Parameters: **		e -- envelope. **		sendqueue -- sendqueue for new envelope. **		qgrp -- index of queue group. **		qdir -- queue directory. ** **	Results: **		new envelope. ** */
end_comment

begin_decl_stmt
specifier|static
name|ENVELOPE
modifier|*
name|split_env
name|__P
argument_list|(
operator|(
name|ENVELOPE
operator|*
operator|,
name|ADDRESS
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|ENVELOPE
modifier|*
name|split_env
parameter_list|(
name|e
parameter_list|,
name|sendqueue
parameter_list|,
name|qgrp
parameter_list|,
name|qdir
parameter_list|)
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|ADDRESS
modifier|*
name|sendqueue
decl_stmt|;
name|int
name|qgrp
decl_stmt|;
name|int
name|qdir
decl_stmt|;
block|{
name|ENVELOPE
modifier|*
name|ee
decl_stmt|;
name|ee
operator|=
operator|(
name|ENVELOPE
operator|*
operator|)
name|sm_rpool_malloc_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
sizeof|sizeof
expr|*
name|ee
argument_list|)
expr_stmt|;
name|STRUCTCOPY
argument_list|(
operator|*
name|e
argument_list|,
operator|*
name|ee
argument_list|)
expr_stmt|;
name|ee
operator|->
name|e_message
operator|=
name|NULL
expr_stmt|;
comment|/* XXX use original message? */
name|ee
operator|->
name|e_id
operator|=
name|NULL
expr_stmt|;
name|assign_queueid
argument_list|(
name|ee
argument_list|)
expr_stmt|;
name|ee
operator|->
name|e_sendqueue
operator|=
name|sendqueue
expr_stmt|;
name|ee
operator|->
name|e_flags
operator|&=
operator|~
operator|(
name|EF_INQUEUE
operator||
name|EF_CLRQUEUE
operator||
name|EF_FATALERRS
operator||
name|EF_SENDRECEIPT
operator||
name|EF_RET_PARAM
operator||
name|EF_HAS_DF
operator|)
expr_stmt|;
name|ee
operator|->
name|e_flags
operator||=
name|EF_NORECEIPT
expr_stmt|;
comment|/* XXX really? */
name|ee
operator|->
name|e_from
operator|.
name|q_state
operator|=
name|QS_SENDER
expr_stmt|;
name|ee
operator|->
name|e_dfp
operator|=
name|NULL
expr_stmt|;
name|ee
operator|->
name|e_lockfp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
condition|)
name|ee
operator|->
name|e_xfp
operator|=
name|sm_io_dup
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|)
expr_stmt|;
comment|/* failed to dup e->e_xfp, start a new transcript */
if|if
condition|(
name|ee
operator|->
name|e_xfp
operator|==
name|NULL
condition|)
name|openxscript
argument_list|(
name|ee
argument_list|)
expr_stmt|;
name|ee
operator|->
name|e_qgrp
operator|=
name|ee
operator|->
name|e_dfqgrp
operator|=
name|qgrp
expr_stmt|;
name|ee
operator|->
name|e_qdir
operator|=
name|ee
operator|->
name|e_dfqdir
operator|=
name|qdir
expr_stmt|;
name|ee
operator|->
name|e_errormode
operator|=
name|EM_MAIL
expr_stmt|;
name|ee
operator|->
name|e_statmsg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_quarmsg
operator|!=
name|NULL
condition|)
name|ee
operator|->
name|e_quarmsg
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|ee
operator|->
name|e_rpool
argument_list|,
name|e
operator|->
name|e_quarmsg
argument_list|)
expr_stmt|;
comment|/* 	**  XXX Not sure if this copying is necessary. 	**  sendall() does this copying, but I (dm) don't know if that is 	**  because of the storage management discipline we were using 	**  before rpools were introduced, or if it is because these lists 	**  can be modified later. 	*/
name|ee
operator|->
name|e_header
operator|=
name|copyheader
argument_list|(
name|e
operator|->
name|e_header
argument_list|,
name|ee
operator|->
name|e_rpool
argument_list|)
expr_stmt|;
name|ee
operator|->
name|e_errorqueue
operator|=
name|copyqueue
argument_list|(
name|e
operator|->
name|e_errorqueue
argument_list|,
name|ee
operator|->
name|e_rpool
argument_list|)
expr_stmt|;
return|return
name|ee
return|;
block|}
end_function

begin_comment
comment|/* return values from split functions, check also below! */
end_comment

begin_define
define|#
directive|define
name|SM_SPLIT_FAIL
value|(0)
end_define

begin_define
define|#
directive|define
name|SM_SPLIT_NONE
value|(1)
end_define

begin_define
define|#
directive|define
name|SM_SPLIT_NEW
parameter_list|(
name|n
parameter_list|)
value|(1 + (n))
end_define

begin_comment
comment|/* **  SPLIT_ACROSS_QUEUE_GROUPS ** **	This function splits an envelope across multiple queue groups **	based on the queue group of each recipient. ** **	Parameters: **		e -- envelope. ** **	Results: **		SM_SPLIT_FAIL on failure **		SM_SPLIT_NONE if no splitting occurred, **		or 1 + the number of additional envelopes created. ** **	Side Effects: **		On success, e->e_sibling points to a list of zero or more **		additional envelopes, and the associated data files exist **		on disk.  But the queue files are not created. ** **		On failure, e->e_sibling is not changed. **		The order of recipients in e->e_sendqueue is permuted. **		Abandoned data files for additional envelopes that failed **		to be created may exist on disk. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|q_qgrp_compare
name|__P
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|e_filesys_compare
name|__P
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|q_qgrp_compare
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
specifier|const
name|void
modifier|*
name|p1
decl_stmt|;
specifier|const
name|void
modifier|*
name|p2
decl_stmt|;
block|{
name|ADDRESS
modifier|*
modifier|*
name|pq1
init|=
operator|(
name|ADDRESS
operator|*
operator|*
operator|)
name|p1
decl_stmt|;
name|ADDRESS
modifier|*
modifier|*
name|pq2
init|=
operator|(
name|ADDRESS
operator|*
operator|*
operator|)
name|p2
decl_stmt|;
return|return
operator|(
operator|*
name|pq1
operator|)
operator|->
name|q_qgrp
operator|-
operator|(
operator|*
name|pq2
operator|)
operator|->
name|q_qgrp
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|e_filesys_compare
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
specifier|const
name|void
modifier|*
name|p1
decl_stmt|;
specifier|const
name|void
modifier|*
name|p2
decl_stmt|;
block|{
name|ENVELOPE
modifier|*
modifier|*
name|pe1
init|=
operator|(
name|ENVELOPE
operator|*
operator|*
operator|)
name|p1
decl_stmt|;
name|ENVELOPE
modifier|*
modifier|*
name|pe2
init|=
operator|(
name|ENVELOPE
operator|*
operator|*
operator|)
name|p2
decl_stmt|;
name|int
name|fs1
decl_stmt|,
name|fs2
decl_stmt|;
name|fs1
operator|=
name|Queue
index|[
operator|(
operator|*
name|pe1
operator|)
operator|->
name|e_qgrp
index|]
operator|->
name|qg_qpaths
index|[
operator|(
operator|*
name|pe1
operator|)
operator|->
name|e_qdir
index|]
operator|.
name|qp_fsysidx
expr_stmt|;
name|fs2
operator|=
name|Queue
index|[
operator|(
operator|*
name|pe2
operator|)
operator|->
name|e_qgrp
index|]
operator|->
name|qg_qpaths
index|[
operator|(
operator|*
name|pe2
operator|)
operator|->
name|e_qdir
index|]
operator|.
name|qp_fsysidx
expr_stmt|;
if|if
condition|(
name|FILE_SYS_DEV
argument_list|(
name|fs1
argument_list|)
operator|<
name|FILE_SYS_DEV
argument_list|(
name|fs2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|FILE_SYS_DEV
argument_list|(
name|fs1
argument_list|)
operator|>
name|FILE_SYS_DEV
argument_list|(
name|fs2
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|split_across_queue_groups
parameter_list|(
name|e
parameter_list|)
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|naddrs
decl_stmt|,
name|nsplits
decl_stmt|,
name|i
decl_stmt|;
name|bool
name|changed
decl_stmt|;
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
name|ADDRESS
modifier|*
name|q
decl_stmt|,
modifier|*
modifier|*
name|addrs
decl_stmt|;
name|ENVELOPE
modifier|*
name|ee
decl_stmt|,
modifier|*
name|es
decl_stmt|;
name|ENVELOPE
modifier|*
name|splits
index|[
name|MAXQUEUEGROUPS
index|]
decl_stmt|;
name|char
name|pvpbuf
index|[
name|PSBUFSIZE
index|]
decl_stmt|;
name|SM_REQUIRE
argument_list|(
name|ISVALIDQGRP
argument_list|(
name|e
operator|->
name|e_qgrp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Count addresses and assign queue groups. */
name|naddrs
operator|=
literal|0
expr_stmt|;
name|changed
operator|=
name|false
expr_stmt|;
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|QS_IS_DEAD
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
condition|)
continue|continue;
operator|++
name|naddrs
expr_stmt|;
comment|/* bad addresses and those already sent stay put */
if|if
condition|(
name|QS_IS_BADADDR
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
operator|||
name|QS_IS_SENT
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
condition|)
name|q
operator|->
name|q_qgrp
operator|=
name|e
operator|->
name|e_qgrp
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ISVALIDQGRP
argument_list|(
name|q
operator|->
name|q_qgrp
argument_list|)
condition|)
block|{
comment|/* call ruleset which should return a queue group */
name|i
operator|=
name|rscap
argument_list|(
name|RS_QUEUEGROUP
argument_list|,
name|q
operator|->
name|q_user
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
operator|&
name|pvp
argument_list|,
name|pvpbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pvpbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|EX_OK
operator|&&
name|pvp
operator|!=
name|NULL
operator|&&
name|pvp
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
operator|(
name|pvp
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|&
literal|0377
operator|)
operator|==
name|CANONNET
operator|&&
name|pvp
index|[
literal|1
index|]
operator|!=
name|NULL
operator|&&
name|pvp
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|i
operator|=
name|name2qid
argument_list|(
name|pvp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISVALIDQGRP
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|q
operator|->
name|q_qgrp
operator|=
name|i
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|20
argument_list|,
literal|4
argument_list|)
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"queue group name %s -> %d"
argument_list|,
name|pvp
index|[
literal|1
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|LogLevel
operator|>
literal|10
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"can't find queue group name %s, selection ignored"
argument_list|,
name|pvp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|->
name|q_mailer
operator|!=
name|NULL
operator|&&
name|ISVALIDQGRP
argument_list|(
name|q
operator|->
name|q_mailer
operator|->
name|m_qgrp
argument_list|)
condition|)
block|{
name|changed
operator|=
name|true
expr_stmt|;
name|q
operator|->
name|q_qgrp
operator|=
name|q
operator|->
name|q_mailer
operator|->
name|m_qgrp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISVALIDQGRP
argument_list|(
name|e
operator|->
name|e_qgrp
argument_list|)
condition|)
name|q
operator|->
name|q_qgrp
operator|=
name|e
operator|->
name|e_qgrp
expr_stmt|;
else|else
name|q
operator|->
name|q_qgrp
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* only one address? nothing to split. */
if|if
condition|(
name|naddrs
operator|<=
literal|1
operator|&&
operator|!
name|changed
condition|)
return|return
name|SM_SPLIT_NONE
return|;
comment|/* sort the addresses by queue group */
name|addrs
operator|=
name|sm_rpool_malloc_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|naddrs
operator|*
sizeof|sizeof
argument_list|(
name|ADDRESS
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|q
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|QS_IS_DEAD
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
condition|)
continue|continue;
name|addrs
index|[
name|i
operator|++
index|]
operator|=
name|q
expr_stmt|;
block|}
name|qsort
argument_list|(
name|addrs
argument_list|,
name|naddrs
argument_list|,
sizeof|sizeof
argument_list|(
name|ADDRESS
operator|*
argument_list|)
argument_list|,
name|q_qgrp_compare
argument_list|)
expr_stmt|;
comment|/* split into multiple envelopes, by queue group */
name|nsplits
operator|=
literal|0
expr_stmt|;
name|es
operator|=
name|NULL
expr_stmt|;
name|e
operator|->
name|e_sendqueue
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|naddrs
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|==
name|naddrs
operator|-
literal|1
operator|||
name|addrs
index|[
name|i
index|]
operator|->
name|q_qgrp
operator|!=
name|addrs
index|[
name|i
operator|+
literal|1
index|]
operator|->
name|q_qgrp
condition|)
name|addrs
index|[
name|i
index|]
operator|->
name|q_next
operator|=
name|NULL
expr_stmt|;
else|else
name|addrs
index|[
name|i
index|]
operator|->
name|q_next
operator|=
name|addrs
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
comment|/* same queue group as original envelope? */
if|if
condition|(
name|addrs
index|[
name|i
index|]
operator|->
name|q_qgrp
operator|==
name|e
operator|->
name|e_qgrp
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|e_sendqueue
operator|==
name|NULL
condition|)
name|e
operator|->
name|e_sendqueue
operator|=
name|addrs
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
comment|/* different queue group than original envelope */
if|if
condition|(
name|es
operator|==
name|NULL
operator|||
name|addrs
index|[
name|i
index|]
operator|->
name|q_qgrp
operator|!=
name|es
operator|->
name|e_qgrp
condition|)
block|{
name|ee
operator|=
name|split_env
argument_list|(
name|e
argument_list|,
name|addrs
index|[
name|i
index|]
argument_list|,
name|addrs
index|[
name|i
index|]
operator|->
name|q_qgrp
argument_list|,
name|NOQDIR
argument_list|)
expr_stmt|;
name|es
operator|=
name|ee
expr_stmt|;
name|splits
index|[
name|nsplits
operator|++
index|]
operator|=
name|ee
expr_stmt|;
block|}
block|}
comment|/* no splits? return right now. */
if|if
condition|(
name|nsplits
operator|<=
literal|0
condition|)
return|return
name|SM_SPLIT_NONE
return|;
comment|/* assign a queue directory to each additional envelope */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsplits
condition|;
operator|++
name|i
control|)
block|{
name|es
operator|=
name|splits
index|[
name|i
index|]
expr_stmt|;
if|#
directive|if
literal|0
block|es->e_qdir = pickqdir(Queue[es->e_qgrp], es->e_msgsize, es);
endif|#
directive|endif
comment|/* 0 */
if|if
condition|(
operator|!
name|setnewqueue
argument_list|(
name|es
argument_list|)
condition|)
goto|goto
name|failure
goto|;
block|}
comment|/* sort the additional envelopes by queue file system */
name|qsort
argument_list|(
name|splits
argument_list|,
name|nsplits
argument_list|,
sizeof|sizeof
argument_list|(
name|ENVELOPE
operator|*
argument_list|)
argument_list|,
name|e_filesys_compare
argument_list|)
expr_stmt|;
comment|/* create data files for each additional envelope */
if|if
condition|(
operator|!
name|dup_df
argument_list|(
name|e
argument_list|,
name|splits
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nsplits
condition|;
operator|++
name|i
control|)
block|{
comment|/* copy or link to the previous data file */
if|if
condition|(
operator|!
name|dup_df
argument_list|(
name|splits
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|splits
index|[
name|i
index|]
argument_list|)
condition|)
goto|goto
name|failure
goto|;
block|}
comment|/* success: prepend the new envelopes to the e->e_sibling list */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsplits
condition|;
operator|++
name|i
control|)
block|{
name|es
operator|=
name|splits
index|[
name|i
index|]
expr_stmt|;
name|es
operator|->
name|e_sibling
operator|=
name|e
operator|->
name|e_sibling
expr_stmt|;
name|e
operator|->
name|e_sibling
operator|=
name|es
expr_stmt|;
block|}
return|return
name|SM_SPLIT_NEW
argument_list|(
name|nsplits
argument_list|)
return|;
comment|/* failure: clean up */
name|failure
label|:
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|queuename
argument_list|(
name|splits
index|[
name|j
index|]
argument_list|,
name|DATAFL_LETTER
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|e_sendqueue
operator|=
name|addrs
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|naddrs
operator|-
literal|1
condition|;
operator|++
name|i
control|)
name|addrs
index|[
name|i
index|]
operator|->
name|q_next
operator|=
name|addrs
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|addrs
index|[
name|naddrs
operator|-
literal|1
index|]
operator|->
name|q_next
operator|=
name|NULL
expr_stmt|;
return|return
name|SM_SPLIT_FAIL
return|;
block|}
end_function

begin_comment
comment|/* **  SPLIT_WITHIN_QUEUE ** **	Split an envelope with multiple recipients into several **	envelopes within the same queue directory, if the number of **	recipients exceeds the limit for the queue group. ** **	Parameters: **		e -- envelope. ** **	Results: **		SM_SPLIT_FAIL on failure **		SM_SPLIT_NONE if no splitting occurred, **		or 1 + the number of additional envelopes created. */
end_comment

begin_define
define|#
directive|define
name|SPLIT_LOG_LEVEL
value|8
end_define

begin_decl_stmt
specifier|static
name|int
name|split_within_queue
name|__P
argument_list|(
operator|(
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|split_within_queue
parameter_list|(
name|e
parameter_list|)
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|maxrcpt
decl_stmt|,
name|nrcpt
decl_stmt|,
name|ndead
decl_stmt|,
name|nsplit
decl_stmt|,
name|i
decl_stmt|;
name|int
name|j
decl_stmt|,
name|l
decl_stmt|;
name|char
modifier|*
name|lsplits
decl_stmt|;
name|ADDRESS
modifier|*
name|q
decl_stmt|,
modifier|*
modifier|*
name|addrs
decl_stmt|;
name|ENVELOPE
modifier|*
name|ee
decl_stmt|,
modifier|*
name|firstsibling
decl_stmt|;
if|if
condition|(
operator|!
name|ISVALIDQGRP
argument_list|(
name|e
operator|->
name|e_qgrp
argument_list|)
operator|||
name|bitset
argument_list|(
name|EF_SPLIT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
return|return
name|SM_SPLIT_NONE
return|;
comment|/* don't bother if there is no recipient limit */
name|maxrcpt
operator|=
name|Queue
index|[
name|e
operator|->
name|e_qgrp
index|]
operator|->
name|qg_maxrcpt
expr_stmt|;
if|if
condition|(
name|maxrcpt
operator|<=
literal|0
condition|)
return|return
name|SM_SPLIT_NONE
return|;
comment|/* count recipients */
name|nrcpt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|QS_IS_DEAD
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
condition|)
continue|continue;
operator|++
name|nrcpt
expr_stmt|;
block|}
if|if
condition|(
name|nrcpt
operator|<=
name|maxrcpt
condition|)
return|return
name|SM_SPLIT_NONE
return|;
comment|/* 	**  Preserve the recipient list 	**  so that we can restore it in case of error. 	**  (But we discard dead addresses.) 	*/
name|addrs
operator|=
name|sm_rpool_malloc_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|nrcpt
operator|*
sizeof|sizeof
argument_list|(
name|ADDRESS
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|q
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|QS_IS_DEAD
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
condition|)
continue|continue;
name|addrs
index|[
name|i
operator|++
index|]
operator|=
name|q
expr_stmt|;
block|}
comment|/* 	**  Partition the recipient list so that bad and sent addresses 	**  come first. These will go with the original envelope, and 	**  do not count towards the maxrcpt limit. 	**  addrs[] does not contain QS_IS_DEAD() addresses. 	*/
name|ndead
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrcpt
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|QS_IS_BADADDR
argument_list|(
name|addrs
index|[
name|i
index|]
operator|->
name|q_state
argument_list|)
operator|||
name|QS_IS_SENT
argument_list|(
name|addrs
index|[
name|i
index|]
operator|->
name|q_state
argument_list|)
operator|||
name|QS_IS_DEAD
argument_list|(
name|addrs
index|[
name|i
index|]
operator|->
name|q_state
argument_list|)
condition|)
comment|/* for paranoia's sake */
block|{
if|if
condition|(
name|i
operator|>
name|ndead
condition|)
block|{
name|ADDRESS
modifier|*
name|tmp
init|=
name|addrs
index|[
name|i
index|]
decl_stmt|;
name|addrs
index|[
name|i
index|]
operator|=
name|addrs
index|[
name|ndead
index|]
expr_stmt|;
name|addrs
index|[
name|ndead
index|]
operator|=
name|tmp
expr_stmt|;
block|}
operator|++
name|ndead
expr_stmt|;
block|}
block|}
comment|/* Check if no splitting required. */
if|if
condition|(
name|nrcpt
operator|-
name|ndead
operator|<=
name|maxrcpt
condition|)
return|return
name|SM_SPLIT_NONE
return|;
comment|/* fix links */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrcpt
operator|-
literal|1
condition|;
operator|++
name|i
control|)
name|addrs
index|[
name|i
index|]
operator|->
name|q_next
operator|=
name|addrs
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|addrs
index|[
name|nrcpt
operator|-
literal|1
index|]
operator|->
name|q_next
operator|=
name|NULL
expr_stmt|;
name|e
operator|->
name|e_sendqueue
operator|=
name|addrs
index|[
literal|0
index|]
expr_stmt|;
comment|/* prepare buffer for logging */
if|if
condition|(
name|LogLevel
operator|>
name|SPLIT_LOG_LEVEL
condition|)
block|{
name|l
operator|=
name|MAXLINE
expr_stmt|;
name|lsplits
operator|=
name|sm_malloc
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsplits
operator|!=
name|NULL
condition|)
operator|*
name|lsplits
operator|=
literal|'\0'
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* get rid of stupid compiler warnings */
name|lsplits
operator|=
name|NULL
expr_stmt|;
name|j
operator|=
name|l
operator|=
literal|0
expr_stmt|;
block|}
comment|/* split the envelope */
name|firstsibling
operator|=
name|e
operator|->
name|e_sibling
expr_stmt|;
name|i
operator|=
name|maxrcpt
operator|+
name|ndead
expr_stmt|;
name|nsplit
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|addrs
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|q_next
operator|=
name|NULL
expr_stmt|;
name|ee
operator|=
name|split_env
argument_list|(
name|e
argument_list|,
name|addrs
index|[
name|i
index|]
argument_list|,
name|e
operator|->
name|e_qgrp
argument_list|,
name|e
operator|->
name|e_qdir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dup_df
argument_list|(
name|e
argument_list|,
name|ee
argument_list|)
condition|)
block|{
name|ee
operator|=
name|firstsibling
expr_stmt|;
while|while
condition|(
name|ee
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|queuename
argument_list|(
name|ee
argument_list|,
name|DATAFL_LETTER
argument_list|)
argument_list|)
expr_stmt|;
name|ee
operator|=
name|ee
operator|->
name|e_sibling
expr_stmt|;
block|}
comment|/* Error.  Restore e's sibling& recipient lists. */
name|e
operator|->
name|e_sibling
operator|=
name|firstsibling
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrcpt
operator|-
literal|1
condition|;
operator|++
name|i
control|)
name|addrs
index|[
name|i
index|]
operator|->
name|q_next
operator|=
name|addrs
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|lsplits
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|lsplits
argument_list|)
expr_stmt|;
return|return
name|SM_SPLIT_FAIL
return|;
block|}
comment|/* prepend the new envelope to e->e_sibling */
name|ee
operator|->
name|e_sibling
operator|=
name|e
operator|->
name|e_sibling
expr_stmt|;
name|e
operator|->
name|e_sibling
operator|=
name|ee
expr_stmt|;
operator|++
name|nsplit
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
name|SPLIT_LOG_LEVEL
operator|&&
name|lsplits
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|j
operator|>=
name|l
operator|-
name|strlen
argument_list|(
name|ee
operator|->
name|e_id
argument_list|)
operator|-
literal|3
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|l
operator|+=
name|MAXLINE
expr_stmt|;
name|p
operator|=
name|sm_realloc
argument_list|(
name|lsplits
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* let's try to get this done */
name|sm_free
argument_list|(
name|lsplits
argument_list|)
expr_stmt|;
name|lsplits
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|lsplits
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|lsplits
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|j
operator|==
literal|0
condition|)
name|j
operator|+=
name|sm_strlcat
argument_list|(
name|lsplits
operator|+
name|j
argument_list|,
name|ee
operator|->
name|e_id
argument_list|,
name|l
operator|-
name|j
argument_list|)
expr_stmt|;
else|else
name|j
operator|+=
name|sm_strlcat2
argument_list|(
name|lsplits
operator|+
name|j
argument_list|,
literal|"; "
argument_list|,
name|ee
operator|->
name|e_id
argument_list|,
name|l
operator|-
name|j
argument_list|)
expr_stmt|;
name|SM_ASSERT
argument_list|(
name|j
operator|<
name|l
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nrcpt
operator|-
name|i
operator|<=
name|maxrcpt
condition|)
break|break;
name|i
operator|+=
name|maxrcpt
expr_stmt|;
block|}
if|if
condition|(
name|LogLevel
operator|>
name|SPLIT_LOG_LEVEL
operator|&&
name|lsplits
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nsplit
operator|>
literal|0
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"split: maxrcpts=%d, rcpts=%d, count=%d, id%s=%s"
argument_list|,
name|maxrcpt
argument_list|,
name|nrcpt
operator|-
name|ndead
argument_list|,
name|nsplit
argument_list|,
name|nsplit
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|lsplits
argument_list|)
expr_stmt|;
block|}
name|sm_free
argument_list|(
name|lsplits
argument_list|)
expr_stmt|;
block|}
return|return
name|SM_SPLIT_NEW
argument_list|(
name|nsplit
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  SPLIT_BY_RECIPIENT ** **	Split an envelope with multiple recipients into multiple **	envelopes as required by the sendmail configuration. ** **	Parameters: **		e -- envelope. ** **	Results: **		Returns true on success, false on failure. ** **	Side Effects: **		see split_across_queue_groups(), split_within_queue(e) */
end_comment

begin_function
name|bool
name|split_by_recipient
parameter_list|(
name|e
parameter_list|)
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|split
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|l
decl_stmt|;
name|char
modifier|*
name|lsplits
decl_stmt|;
name|ENVELOPE
modifier|*
name|ee
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|firstsibling
decl_stmt|;
if|if
condition|(
name|OpMode
operator|==
name|SM_VERIFY
operator|||
operator|!
name|ISVALIDQGRP
argument_list|(
name|e
operator|->
name|e_qgrp
argument_list|)
operator|||
name|bitset
argument_list|(
name|EF_SPLIT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
return|return
name|true
return|;
name|n
operator|=
name|split_across_queue_groups
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|SM_SPLIT_FAIL
condition|)
return|return
name|false
return|;
name|firstsibling
operator|=
name|ee
operator|=
name|e
operator|->
name|e_sibling
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|1
operator|&&
name|LogLevel
operator|>
name|SPLIT_LOG_LEVEL
condition|)
block|{
name|l
operator|=
name|MAXLINE
expr_stmt|;
name|lsplits
operator|=
name|sm_malloc
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsplits
operator|!=
name|NULL
condition|)
operator|*
name|lsplits
operator|=
literal|'\0'
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* get rid of stupid compiler warnings */
name|lsplits
operator|=
name|NULL
expr_stmt|;
name|j
operator|=
name|l
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|next
operator|=
name|ee
operator|->
name|e_sibling
expr_stmt|;
if|if
condition|(
name|split_within_queue
argument_list|(
name|ee
argument_list|)
operator|==
name|SM_SPLIT_FAIL
condition|)
block|{
name|e
operator|->
name|e_sibling
operator|=
name|firstsibling
expr_stmt|;
return|return
name|false
return|;
block|}
name|ee
operator|->
name|e_flags
operator||=
name|EF_SPLIT
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
name|SPLIT_LOG_LEVEL
operator|&&
name|lsplits
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|j
operator|>=
name|l
operator|-
name|strlen
argument_list|(
name|ee
operator|->
name|e_id
argument_list|)
operator|-
literal|3
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|l
operator|+=
name|MAXLINE
expr_stmt|;
name|p
operator|=
name|sm_realloc
argument_list|(
name|lsplits
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* let's try to get this done */
name|sm_free
argument_list|(
name|lsplits
argument_list|)
expr_stmt|;
name|lsplits
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|lsplits
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|lsplits
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|j
operator|==
literal|0
condition|)
name|j
operator|+=
name|sm_strlcat
argument_list|(
name|lsplits
operator|+
name|j
argument_list|,
name|ee
operator|->
name|e_id
argument_list|,
name|l
operator|-
name|j
argument_list|)
expr_stmt|;
else|else
name|j
operator|+=
name|sm_strlcat2
argument_list|(
name|lsplits
operator|+
name|j
argument_list|,
literal|"; "
argument_list|,
name|ee
operator|->
name|e_id
argument_list|,
name|l
operator|-
name|j
argument_list|)
expr_stmt|;
name|SM_ASSERT
argument_list|(
name|j
operator|<
name|l
argument_list|)
expr_stmt|;
block|}
block|}
name|ee
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|LogLevel
operator|>
name|SPLIT_LOG_LEVEL
operator|&&
name|lsplits
operator|!=
name|NULL
operator|&&
name|n
operator|>
literal|1
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"split: count=%d, id%s=%s"
argument_list|,
name|n
operator|-
literal|1
argument_list|,
name|n
operator|>
literal|2
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|lsplits
argument_list|)
expr_stmt|;
name|sm_free
argument_list|(
name|lsplits
argument_list|)
expr_stmt|;
block|}
name|split
operator|=
name|split_within_queue
argument_list|(
name|e
argument_list|)
operator|!=
name|SM_SPLIT_FAIL
expr_stmt|;
if|if
condition|(
name|split
condition|)
name|e
operator|->
name|e_flags
operator||=
name|EF_SPLIT
expr_stmt|;
return|return
name|split
return|;
block|}
end_function

begin_comment
comment|/* **  QUARANTINE_QUEUE_ITEM -- {un,}quarantine a single envelope ** **	Add/remove quarantine reason and requeue appropriately. ** **	Parameters: **		qgrp -- queue group for the item **		qdir -- queue directory in the given queue group **		e -- envelope information for the item **		reason -- quarantine reason, NULL means unquarantine. ** **	Results: **		true if item changed, false otherwise ** **	Side Effects: **		Changes quarantine tag in queue file and renames it. */
end_comment

begin_function
specifier|static
name|bool
name|quarantine_queue_item
parameter_list|(
name|qgrp
parameter_list|,
name|qdir
parameter_list|,
name|e
parameter_list|,
name|reason
parameter_list|)
name|int
name|qgrp
decl_stmt|;
name|int
name|qdir
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|reason
decl_stmt|;
block|{
name|bool
name|dirty
init|=
name|false
decl_stmt|;
name|bool
name|failing
init|=
name|false
decl_stmt|;
name|bool
name|foundq
init|=
name|false
decl_stmt|;
name|bool
name|finished
init|=
name|false
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|oldtype
decl_stmt|;
name|int
name|newtype
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
name|MODE_T
name|oldumask
init|=
literal|0
decl_stmt|;
name|SM_FILE_T
modifier|*
name|oldqfp
decl_stmt|,
modifier|*
name|tempqfp
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
name|char
name|oldqf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|tempqf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|newqf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|oldtype
operator|=
name|queue_letter
argument_list|(
name|e
argument_list|,
name|ANYQFL_LETTER
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|oldqf
argument_list|,
name|queuename
argument_list|(
name|e
argument_list|,
name|ANYQFL_LETTER
argument_list|)
argument_list|,
sizeof|sizeof
name|oldqf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|tempqf
argument_list|,
name|queuename
argument_list|(
name|e
argument_list|,
name|NEWQFL_LETTER
argument_list|)
argument_list|,
sizeof|sizeof
name|tempqf
argument_list|)
expr_stmt|;
comment|/* 	**  Instead of duplicating all the open 	**  and lock code here, tell readqf() to 	**  do that work and return the open 	**  file pointer in e_lockfp.  Note that 	**  we must release the locks properly when 	**  we are done. 	*/
if|if
condition|(
operator|!
name|readqf
argument_list|(
name|e
argument_list|,
name|true
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Skipping %s\n"
argument_list|,
name|qid_printname
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|oldqfp
operator|=
name|e
operator|->
name|e_lockfp
expr_stmt|;
comment|/* open the new queue file */
name|flags
operator|=
name|O_CREAT
operator||
name|O_WRONLY
operator||
name|O_EXCL
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|S_IWGRP
argument_list|,
name|QueueFileMode
argument_list|)
condition|)
name|oldumask
operator|=
name|umask
argument_list|(
literal|002
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|tempqf
argument_list|,
name|flags
argument_list|,
name|QueueFileMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|S_IWGRP
argument_list|,
name|QueueFileMode
argument_list|)
condition|)
operator|(
name|void
operator|)
name|umask
argument_list|(
name|oldumask
argument_list|)
expr_stmt|;
name|RELEASE_QUEUE
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Skipping %s: Could not open %s: %s\n"
argument_list|,
name|qid_printname
argument_list|(
name|e
argument_list|)
argument_list|,
name|tempqf
argument_list|,
name|sm_errstring
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|oldqfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|lockfile
argument_list|(
name|fd
argument_list|,
name|tempqf
argument_list|,
name|NULL
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Skipping %s: Could not lock %s\n"
argument_list|,
name|qid_printname
argument_list|(
name|e
argument_list|)
argument_list|,
name|tempqf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|oldqfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|tempqfp
operator|=
name|sm_io_open
argument_list|(
name|SmFtStdiofd
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|fd
argument_list|,
name|SM_IO_WRONLY_B
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempqfp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Skipping %s: Could not lock %s\n"
argument_list|,
name|qid_printname
argument_list|(
name|e
argument_list|)
argument_list|,
name|tempqf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|oldqfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Copy the data over, changing the quarantine reason */
while|while
condition|(
operator|(
name|bp
operator|=
name|fgetfolded
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|oldqfp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|4
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"+++++ %s\n"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bp
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'q'
case|:
comment|/* quarantine reason */
name|foundq
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|reason
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|Verbose
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s: Removed quarantine of \"%s\"\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"unquarantine"
argument_list|)
expr_stmt|;
name|dirty
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|reason
argument_list|,
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|Verbose
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s: Already quarantined with \"%s\"\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tempqfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"q%s\n"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Verbose
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s: Quarantine changed from \"%s\" to \"%s\"\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
operator|&
name|bp
index|[
literal|1
index|]
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tempqfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"q%s\n"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"quarantine=%s"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|dirty
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
comment|/* 			**  If we are quarantining an unquarantined item, 			**  need to put in a new 'q' line before it's 			**  too late. 			*/
if|if
condition|(
operator|!
name|foundq
operator|&&
name|reason
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|Verbose
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s: Quarantined with \"%s\"\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tempqfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"q%s\n"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"quarantine=%s"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|foundq
operator|=
name|true
expr_stmt|;
name|dirty
operator|=
name|true
expr_stmt|;
block|}
comment|/* Copy the line to the new file */
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tempqfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s\n"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|finished
operator|=
name|true
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
comment|/* Copy the line to the new file */
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|tempqfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s\n"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Make sure we read the whole old file */
name|errno
operator|=
name|sm_io_error
argument_list|(
name|tempqfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
operator|&&
name|errno
operator|!=
name|SM_IO_EOF
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Skipping %s: Error reading %s: %s\n"
argument_list|,
name|qid_printname
argument_list|(
name|e
argument_list|)
argument_list|,
name|oldqf
argument_list|,
name|sm_errstring
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
name|failing
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|failing
operator|&&
operator|!
name|finished
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Skipping %s: Incomplete file: %s\n"
argument_list|,
name|qid_printname
argument_list|(
name|e
argument_list|)
argument_list|,
name|oldqf
argument_list|)
expr_stmt|;
name|failing
operator|=
name|true
expr_stmt|;
block|}
comment|/* Check if we actually changed anything or we can just bail now */
if|if
condition|(
operator|!
name|dirty
condition|)
block|{
comment|/* pretend we failed, even though we technically didn't */
name|failing
operator|=
name|true
expr_stmt|;
block|}
comment|/* Make sure we wrote things out safely */
if|if
condition|(
operator|!
name|failing
operator|&&
operator|(
name|sm_io_flush
argument_list|(
name|tempqfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|SuperSafe
operator|==
name|SAFE_REALLY
operator|||
name|SuperSafe
operator|==
name|SAFE_REALLY_POSTMILTER
operator|||
name|SuperSafe
operator|==
name|SAFE_INTERACTIVE
operator|)
operator|&&
name|fsync
argument_list|(
name|sm_io_getinfo
argument_list|(
name|tempqfp
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|errno
operator|=
name|sm_io_error
argument_list|(
name|tempqfp
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Skipping %s: Error writing %s: %s\n"
argument_list|,
name|qid_printname
argument_list|(
name|e
argument_list|)
argument_list|,
name|tempqf
argument_list|,
name|sm_errstring
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
name|failing
operator|=
name|true
expr_stmt|;
block|}
comment|/* Figure out the new filename */
name|newtype
operator|=
operator|(
name|reason
operator|==
name|NULL
condition|?
name|NORMQF_LETTER
else|:
name|QUARQF_LETTER
operator|)
expr_stmt|;
if|if
condition|(
name|oldtype
operator|==
name|newtype
condition|)
block|{
comment|/* going to rename tempqf to oldqf */
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|newqf
argument_list|,
name|oldqf
argument_list|,
sizeof|sizeof
name|newqf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* going to rename tempqf to new name based on newtype */
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|newqf
argument_list|,
name|queuename
argument_list|(
name|e
argument_list|,
name|newtype
argument_list|)
argument_list|,
sizeof|sizeof
name|newqf
argument_list|)
expr_stmt|;
block|}
name|save_errno
operator|=
literal|0
expr_stmt|;
comment|/* rename tempqf to newqf */
if|if
condition|(
operator|!
name|failing
operator|&&
name|rename
argument_list|(
name|tempqf
argument_list|,
name|newqf
argument_list|)
operator|<
literal|0
condition|)
name|save_errno
operator|=
operator|(
name|errno
operator|==
literal|0
operator|)
condition|?
name|EINVAL
else|:
name|errno
expr_stmt|;
comment|/* Check rename() success */
if|if
condition|(
operator|!
name|failing
operator|&&
name|save_errno
operator|!=
literal|0
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"quarantine_queue_item: rename(%s, %s): %s"
argument_list|,
name|tempqf
argument_list|,
name|newqf
argument_list|,
name|sm_errstring
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Error renaming %s to %s: %s\n"
argument_list|,
name|tempqf
argument_list|,
name|newqf
argument_list|,
name|sm_errstring
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldtype
operator|==
name|newtype
condition|)
block|{
comment|/* 			**  Bail here since we don't know the state of 			**  the filesystem and may need to keep tempqf 			**  for the user to rescue us. 			*/
name|RELEASE_QUEUE
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
name|syserr
argument_list|(
literal|"!452 Error renaming control file %s"
argument_list|,
name|tempqf
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
else|else
block|{
comment|/* remove new file (if rename() half completed) */
if|if
condition|(
name|xunlink
argument_list|(
name|newqf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Error removing %s: %s\n"
argument_list|,
name|newqf
argument_list|,
name|sm_errstring
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* tempqf removed below */
name|failing
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* If changing file types, need to remove old type */
if|if
condition|(
operator|!
name|failing
operator|&&
name|oldtype
operator|!=
name|newtype
condition|)
block|{
if|if
condition|(
name|xunlink
argument_list|(
name|oldqf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Error removing %s: %s\n"
argument_list|,
name|oldqf
argument_list|,
name|sm_errstring
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* see if anything above failed */
if|if
condition|(
name|failing
condition|)
block|{
comment|/* Something failed: remove new file, old file still there */
operator|(
name|void
operator|)
name|xunlink
argument_list|(
name|tempqf
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  fsync() after file operations to make sure metadata is 	**  written to disk on filesystems in which renames are 	**  not guaranteed.  It's ok if they fail, mail won't be lost. 	*/
if|if
condition|(
name|SuperSafe
operator|!=
name|SAFE_NO
condition|)
block|{
comment|/* for soft-updates */
operator|(
name|void
operator|)
name|fsync
argument_list|(
name|sm_io_getinfo
argument_list|(
name|tempqfp
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|failing
condition|)
block|{
comment|/* for soft-updates */
operator|(
name|void
operator|)
name|fsync
argument_list|(
name|sm_io_getinfo
argument_list|(
name|oldqfp
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* for other odd filesystems */
name|SYNC_DIR
argument_list|(
name|tempqf
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
comment|/* Close up shop */
name|RELEASE_QUEUE
expr_stmt|;
if|if
condition|(
name|tempqfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|tempqfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldqfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|oldqfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
comment|/* All went well */
return|return
operator|!
name|failing
return|;
block|}
end_function

begin_comment
comment|/* **  QUARANTINE_QUEUE -- {un,}quarantine matching items in the queue ** **	Read all matching queue items, add/remove quarantine **	reason, and requeue appropriately. ** **	Parameters: **		reason -- quarantine reason, "." means unquarantine. **		qgrplimit -- limit to single queue group unless NOQGRP ** **	Results: **		none. ** **	Side Effects: **		Lots of changes to the queue. */
end_comment

begin_function
name|void
name|quarantine_queue
parameter_list|(
name|reason
parameter_list|,
name|qgrplimit
parameter_list|)
name|char
modifier|*
name|reason
decl_stmt|;
name|int
name|qgrplimit
decl_stmt|;
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|int
name|qgrp
decl_stmt|;
comment|/* Convert internal representation of unquarantine */
if|if
condition|(
name|reason
operator|!=
name|NULL
operator|&&
name|reason
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|reason
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|reason
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|reason
operator|!=
name|NULL
condition|)
block|{
comment|/* clean it */
name|reason
operator|=
name|newstr
argument_list|(
name|denlstring
argument_list|(
name|reason
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|qgrp
operator|=
literal|0
init|;
name|qgrp
operator|<
name|NumQueue
operator|&&
name|Queue
index|[
name|qgrp
index|]
operator|!=
name|NULL
condition|;
name|qgrp
operator|++
control|)
block|{
name|int
name|qdir
decl_stmt|;
if|if
condition|(
name|qgrplimit
operator|!=
name|NOQGRP
operator|&&
name|qgrplimit
operator|!=
name|qgrp
condition|)
continue|continue;
for|for
control|(
name|qdir
operator|=
literal|0
init|;
name|qdir
operator|<
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_numqueues
condition|;
name|qdir
operator|++
control|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|nrequests
decl_stmt|;
if|if
condition|(
name|StopRequest
condition|)
name|stop_sendmail
argument_list|()
expr_stmt|;
name|nrequests
operator|=
name|gatherq
argument_list|(
name|qgrp
argument_list|,
name|qdir
argument_list|,
name|true
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* first see if there is anything */
if|if
condition|(
name|nrequests
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|Verbose
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s: no matches\n"
argument_list|,
name|qid_printqueue
argument_list|(
name|qgrp
argument_list|,
name|qdir
argument_list|)
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|Verbose
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Processing %s:\n"
argument_list|,
name|qid_printqueue
argument_list|(
name|qgrp
argument_list|,
name|qdir
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WorkListCount
condition|;
name|i
operator|++
control|)
block|{
name|ENVELOPE
name|e
decl_stmt|;
if|if
condition|(
name|StopRequest
condition|)
name|stop_sendmail
argument_list|()
expr_stmt|;
comment|/* setup envelope */
name|clearenvelope
argument_list|(
operator|&
name|e
argument_list|,
name|true
argument_list|,
name|sm_rpool_new_x
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|.
name|e_id
operator|=
name|WorkList
index|[
name|i
index|]
operator|.
name|w_name
operator|+
literal|2
expr_stmt|;
name|e
operator|.
name|e_qgrp
operator|=
name|qgrp
expr_stmt|;
name|e
operator|.
name|e_qdir
operator|=
name|qdir
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|70
argument_list|,
literal|101
argument_list|)
condition|)
block|{
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Would do %s\n"
argument_list|,
name|e
operator|.
name|e_id
argument_list|)
expr_stmt|;
name|changed
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|quarantine_queue_item
argument_list|(
name|qgrp
argument_list|,
name|qdir
argument_list|,
operator|&
name|e
argument_list|,
name|reason
argument_list|)
condition|)
name|changed
operator|++
expr_stmt|;
comment|/* clean up */
name|sm_rpool_free
argument_list|(
name|e
operator|.
name|e_rpool
argument_list|)
expr_stmt|;
name|e
operator|.
name|e_rpool
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|WorkList
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|WorkList
argument_list|)
expr_stmt|;
comment|/* XXX */
name|WorkList
operator|=
name|NULL
expr_stmt|;
name|WorkListSize
operator|=
literal|0
expr_stmt|;
name|WorkListCount
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Verbose
condition|)
block|{
if|if
condition|(
name|changed
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"No changes\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%d change%s\n"
argument_list|,
name|changed
argument_list|,
name|changed
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

