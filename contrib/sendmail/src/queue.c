begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.  *	All rights reserved.  * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_include
include|#
directive|include
file|<sendmail.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
name|QUEUE
end_if

begin_decl_stmt
specifier|static
name|char
name|id
index|[]
init|=
literal|"@(#)$Id: queue.c,v 8.343.4.62 2001/07/20 00:53:01 gshapiro Exp $ (with queueing)"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* QUEUE */
end_comment

begin_decl_stmt
specifier|static
name|char
name|id
index|[]
init|=
literal|"@(#)$Id: queue.c,v 8.343.4.62 2001/07/20 00:53:01 gshapiro Exp $ (without queueing)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* QUEUE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! lint */
end_comment

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_if
if|#
directive|if
name|QUEUE
end_if

begin_if
if|#
directive|if
name|_FFR_QUEUEDELAY
end_if

begin_define
define|#
directive|define
name|QF_VERSION
value|5
end_define

begin_comment
comment|/* version number of this queue format */
end_comment

begin_decl_stmt
specifier|static
name|time_t
name|queuedelay
name|__P
argument_list|(
operator|(
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* _FFR_QUEUEDELAY */
end_comment

begin_define
define|#
directive|define
name|QF_VERSION
value|4
end_define

begin_comment
comment|/* version number of this queue format */
end_comment

begin_define
define|#
directive|define
name|queuedelay
parameter_list|(
name|e
parameter_list|)
value|MinQueueAge
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_QUEUEDELAY */
end_comment

begin_comment
comment|/* **  Work queue. */
end_comment

begin_struct
struct|struct
name|work
block|{
name|char
modifier|*
name|w_name
decl_stmt|;
comment|/* name of control file */
name|char
modifier|*
name|w_host
decl_stmt|;
comment|/* name of recipient host */
name|bool
name|w_lock
decl_stmt|;
comment|/* is message locked? */
name|bool
name|w_tooyoung
decl_stmt|;
comment|/* is it too young to run? */
name|long
name|w_pri
decl_stmt|;
comment|/* priority of message, see below */
name|time_t
name|w_ctime
decl_stmt|;
comment|/* creation time of message */
name|struct
name|work
modifier|*
name|w_next
decl_stmt|;
comment|/* next in queue */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|work
name|WORK
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|WORK
modifier|*
name|WorkQ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* queue of things to be done */
end_comment

begin_decl_stmt
specifier|static
name|void
name|grow_wlist
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|orderq
name|__P
argument_list|(
operator|(
name|int
operator|,
name|bool
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|printctladdr
name|__P
argument_list|(
operator|(
name|ADDRESS
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|print_single_queue
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|readqf
name|__P
argument_list|(
operator|(
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|runqueueevent
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|run_single_queue
name|__P
argument_list|(
operator|(
name|int
operator|,
name|bool
operator|,
name|bool
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|strrev
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ADDRESS
modifier|*
name|setctluser
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|workcmpf0
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|workcmpf1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|workcmpf2
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|workcmpf3
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|workcmpf4
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* **  Current qf file field assignments: ** **	A	AUTH= parameter **	B	body type **	C	controlling user **	D	data file name **	E	error recipient **	F	flag bits **	G	queue delay algorithm **	H	header **	I	data file's inode number **	K	time of last delivery attempt **	L	Solaris Content-Length: header (obsolete) **	M	message (obsolete) **	N	number of delivery attempts **	P	message priority **	Q	original recipient (ORCPT=) **	R	recipient **	S	sender **	T	init time **	V	queue file version **	X	character set (_FFR_SAVE_CHARSET) **	Y	current delay **	Z	original envelope id from ESMTP **	$	define macro **	.	terminate file */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **  QUEUEUP -- queue a message up for future transmission. ** **	Parameters: **		e -- the envelope to queue up. **		announce -- if TRUE, tell when you are queueing up. ** **	Returns: **		none. ** **	Side Effects: **		The current request are saved in a control file. **		The queue file is left locked. */
end_comment

begin_define
define|#
directive|define
name|TEMPQF_LETTER
value|'T'
end_define

begin_define
define|#
directive|define
name|LOSEQF_LETTER
value|'Q'
end_define

begin_function
name|void
name|queueup
parameter_list|(
name|e
parameter_list|,
name|announce
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|bool
name|announce
decl_stmt|;
block|{
name|char
modifier|*
name|qf
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|tfp
decl_stmt|;
specifier|register
name|HDR
modifier|*
name|h
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
name|int
name|tfd
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bool
name|newid
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|MAILER
name|nullmailer
decl_stmt|;
name|MCI
name|mcibuf
decl_stmt|;
name|char
name|tf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
comment|/* 	**  Create control file. 	*/
name|newid
operator|=
operator|(
name|e
operator|->
name|e_id
operator|==
name|NULL
operator|)
operator|||
operator|!
name|bitset
argument_list|(
name|EF_INQUEUE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
expr_stmt|;
comment|/* if newid, queuename will create a locked qf file in e->lockfp */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|tf
argument_list|,
name|queuename
argument_list|(
name|e
argument_list|,
literal|'t'
argument_list|)
argument_list|,
sizeof|sizeof
name|tf
argument_list|)
expr_stmt|;
name|tfp
operator|=
name|e
operator|->
name|e_lockfp
expr_stmt|;
if|if
condition|(
name|tfp
operator|==
name|NULL
condition|)
name|newid
operator|=
name|FALSE
expr_stmt|;
comment|/* if newid, just write the qf file directly (instead of tf file) */
if|if
condition|(
operator|!
name|newid
condition|)
block|{
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|O_CREAT
operator||
name|O_WRONLY
operator||
name|O_EXCL
expr_stmt|;
comment|/* get a locked tf file */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tfd
operator|<
literal|0
condition|)
block|{
if|#
directive|if
name|_FFR_QUEUE_FILE_MODE
name|MODE_T
name|oldumask
decl_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|S_IWGRP
argument_list|,
name|QueueFileMode
argument_list|)
condition|)
name|oldumask
operator|=
name|umask
argument_list|(
literal|002
argument_list|)
expr_stmt|;
name|tfd
operator|=
name|open
argument_list|(
name|tf
argument_list|,
name|flags
argument_list|,
name|QueueFileMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|S_IWGRP
argument_list|,
name|QueueFileMode
argument_list|)
condition|)
operator|(
name|void
operator|)
name|umask
argument_list|(
name|oldumask
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* _FFR_QUEUE_FILE_MODE */
name|tfd
operator|=
name|open
argument_list|(
name|tf
argument_list|,
name|flags
argument_list|,
name|FileMode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_QUEUE_FILE_MODE */
if|if
condition|(
name|tfd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
break|break;
if|if
condition|(
name|LogLevel
operator|>
literal|0
operator|&&
operator|(
name|i
operator|%
literal|32
operator|)
operator|==
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ALERT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"queueup: cannot create %s, uid=%d: %s"
argument_list|,
name|tf
argument_list|,
name|geteuid
argument_list|()
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tfd
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|lockfile
argument_list|(
name|tfd
argument_list|,
name|tf
argument_list|,
name|NULL
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|LogLevel
operator|>
literal|0
operator|&&
operator|(
name|i
operator|%
literal|32
operator|)
operator|==
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ALERT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"queueup: cannot lock %s: %s"
argument_list|,
name|tf
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|%
literal|32
operator|)
operator|==
literal|31
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|tfd
argument_list|)
expr_stmt|;
name|tfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|i
operator|%
literal|32
operator|)
operator|==
literal|31
condition|)
block|{
comment|/* save the old temp file away */
operator|(
name|void
operator|)
name|rename
argument_list|(
name|tf
argument_list|,
name|queuename
argument_list|(
name|e
argument_list|,
name|TEMPQF_LETTER
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|sleep
argument_list|(
name|i
operator|%
literal|32
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tfd
operator|<
literal|0
operator|||
operator|(
name|tfp
operator|=
name|fdopen
argument_list|(
name|tfd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|printopenfds
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
name|syserr
argument_list|(
literal|"!queueup: cannot create queue temp file %s, uid=%d"
argument_list|,
name|tf
argument_list|,
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|1
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"\n>>>>> queueing %s/qf%s%s>>>>>\n"
argument_list|,
name|qid_printqueue
argument_list|(
name|e
operator|->
name|e_queuedir
argument_list|)
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|newid
condition|?
literal|" (new id)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|"  e_flags="
argument_list|)
expr_stmt|;
name|printenvflags
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|32
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|"  sendq="
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|e
operator|->
name|e_sendqueue
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|9
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|"  tfp="
argument_list|)
expr_stmt|;
name|dumpfd
argument_list|(
name|fileno
argument_list|(
name|tfp
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"  lockfp="
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_lockfp
operator|==
name|NULL
condition|)
name|dprintf
argument_list|(
literal|"NULL\n"
argument_list|)
expr_stmt|;
else|else
name|dumpfd
argument_list|(
name|fileno
argument_list|(
name|e
operator|->
name|e_lockfp
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  If there is no data file yet, create one. 	*/
if|if
condition|(
name|bitset
argument_list|(
name|EF_HAS_DF
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|!=
name|NULL
operator|&&
name|bfcommit
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"!queueup: cannot commit data file %s, uid=%d"
argument_list|,
name|queuename
argument_list|(
name|e
argument_list|,
literal|'d'
argument_list|)
argument_list|,
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|dfd
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|dfp
init|=
name|NULL
decl_stmt|;
name|char
name|dfname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|!=
name|NULL
operator|&&
name|bftest
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"committing over bf file"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|dfname
argument_list|,
name|queuename
argument_list|(
name|e
argument_list|,
literal|'d'
argument_list|)
argument_list|,
sizeof|sizeof
name|dfname
argument_list|)
expr_stmt|;
if|#
directive|if
name|_FFR_QUEUE_FILE_MODE
block|{
name|MODE_T
name|oldumask
decl_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|S_IWGRP
argument_list|,
name|QueueFileMode
argument_list|)
condition|)
name|oldumask
operator|=
name|umask
argument_list|(
literal|002
argument_list|)
expr_stmt|;
name|dfd
operator|=
name|open
argument_list|(
name|dfname
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
name|QueueFileMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|S_IWGRP
argument_list|,
name|QueueFileMode
argument_list|)
condition|)
operator|(
name|void
operator|)
name|umask
argument_list|(
name|oldumask
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* _FFR_QUEUE_FILE_MODE */
name|dfd
operator|=
name|open
argument_list|(
name|dfname
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
name|FileMode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_QUEUE_FILE_MODE */
if|if
condition|(
name|dfd
operator|<
literal|0
operator|||
operator|(
name|dfp
operator|=
name|fdopen
argument_list|(
name|dfd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"!queueup: cannot create data temp file %s, uid=%d"
argument_list|,
name|dfname
argument_list|,
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|dfd
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|<
literal|0
condition|)
name|e
operator|->
name|e_dfino
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|e
operator|->
name|e_dfdev
operator|=
name|stbuf
operator|.
name|st_dev
expr_stmt|;
name|e
operator|->
name|e_dfino
operator|=
name|stbuf
operator|.
name|st_ino
expr_stmt|;
block|}
name|e
operator|->
name|e_flags
operator||=
name|EF_HAS_DF
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mcibuf
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|mcibuf
argument_list|)
expr_stmt|;
name|mcibuf
operator|.
name|mci_out
operator|=
name|dfp
expr_stmt|;
name|mcibuf
operator|.
name|mci_mailer
operator|=
name|FileMailer
expr_stmt|;
call|(
modifier|*
name|e
operator|->
name|e_putbody
call|)
argument_list|(
operator|&
name|mcibuf
argument_list|,
name|e
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|dfp
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"!queueup: cannot save data temp file %s, uid=%d"
argument_list|,
name|dfname
argument_list|,
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_putbody
operator|=
name|putbody
expr_stmt|;
block|}
comment|/* 	**  Output future work requests. 	**	Priority and creation time should be first, since 	**	they are required by orderq. 	*/
comment|/* output queue version number (must be first!) */
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"V%d\n"
argument_list|,
name|QF_VERSION
argument_list|)
expr_stmt|;
comment|/* output creation time */
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"T%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|e
operator|->
name|e_ctime
argument_list|)
expr_stmt|;
comment|/* output last delivery time */
if|#
directive|if
name|_FFR_QUEUEDELAY
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"K%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|e
operator|->
name|e_dtime
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"G%d\n"
argument_list|,
name|e
operator|->
name|e_queuealg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"Y%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|e
operator|->
name|e_queuedelay
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|64
argument_list|)
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"queue alg: %d delay %ld next: %ld (now: %ld)\n"
argument_list|,
name|e
operator|->
name|e_queuealg
argument_list|,
name|e
operator|->
name|e_queuedelay
argument_list|,
name|e
operator|->
name|e_dtime
argument_list|,
name|curtime
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* _FFR_QUEUEDELAY */
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"K%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|e
operator|->
name|e_dtime
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_QUEUEDELAY */
comment|/* output number of delivery attempts */
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"N%d\n"
argument_list|,
name|e
operator|->
name|e_ntries
argument_list|)
expr_stmt|;
comment|/* output message priority */
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"P%ld\n"
argument_list|,
name|e
operator|->
name|e_msgpriority
argument_list|)
expr_stmt|;
comment|/* output inode number of data file */
comment|/* XXX should probably include device major/minor too */
if|if
condition|(
name|e
operator|->
name|e_dfino
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/*CONSTCOND*/
if|if
condition|(
sizeof|sizeof
name|e
operator|->
name|e_dfino
operator|>
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"I%ld/%ld/%s\n"
argument_list|,
operator|(
name|long
operator|)
name|major
argument_list|(
name|e
operator|->
name|e_dfdev
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|minor
argument_list|(
name|e
operator|->
name|e_dfdev
argument_list|)
argument_list|,
name|quad_to_string
argument_list|(
name|e
operator|->
name|e_dfino
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"I%ld/%ld/%lu\n"
argument_list|,
operator|(
name|long
operator|)
name|major
argument_list|(
name|e
operator|->
name|e_dfdev
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|minor
argument_list|(
name|e
operator|->
name|e_dfdev
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|e
operator|->
name|e_dfino
argument_list|)
expr_stmt|;
block|}
comment|/* output body type */
if|if
condition|(
name|e
operator|->
name|e_bodytype
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"B%s\n"
argument_list|,
name|denlstring
argument_list|(
name|e
operator|->
name|e_bodytype
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|_FFR_SAVE_CHARSET
if|if
condition|(
name|e
operator|->
name|e_charset
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"X%s\n"
argument_list|,
name|denlstring
argument_list|(
name|e
operator|->
name|e_charset
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_SAVE_CHARSET */
comment|/* message from envelope, if it exists */
if|if
condition|(
name|e
operator|->
name|e_message
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"M%s\n"
argument_list|,
name|denlstring
argument_list|(
name|e
operator|->
name|e_message
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* send various flag bits through */
name|p
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|EF_WARNING
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
literal|'w'
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|EF_RESPONSE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
literal|'r'
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|EF_HAS8BIT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
literal|'8'
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|EF_DELETE_BCC
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
literal|'b'
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|EF_RET_PARAM
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
literal|'d'
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|EF_NO_BODY_RETN
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
literal|'n'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"F%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* save $={persistentMacros} macro values */
name|queueup_macros
argument_list|(
name|macid
argument_list|(
literal|"{persistentMacros}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|tfp
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* output name of sender */
if|if
condition|(
name|bitnset
argument_list|(
name|M_UDBENVELOPE
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|->
name|m_flags
argument_list|)
condition|)
name|p
operator|=
name|e
operator|->
name|e_sender
expr_stmt|;
else|else
name|p
operator|=
name|e
operator|->
name|e_from
operator|.
name|q_paddr
expr_stmt|;
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"S%s\n"
argument_list|,
name|denlstring
argument_list|(
name|p
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* output ESMTP-supplied "original" information */
if|if
condition|(
name|e
operator|->
name|e_envid
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"Z%s\n"
argument_list|,
name|denlstring
argument_list|(
name|e
operator|->
name|e_envid
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* output AUTH= parameter */
if|if
condition|(
name|e
operator|->
name|e_auth_param
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"A%s\n"
argument_list|,
name|denlstring
argument_list|(
name|e
operator|->
name|e_auth_param
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* output list of recipient addresses */
name|printctladdr
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
operator|!
name|QS_IS_UNDELIVERED
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
condition|)
continue|continue;
name|printctladdr
argument_list|(
name|q
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|q_orcpt
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"Q%s\n"
argument_list|,
name|denlstring
argument_list|(
name|q
operator|->
name|q_orcpt
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'R'
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|QPRIMARY
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'P'
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|QHASNOTIFY
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'N'
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|QPINGONSUCCESS
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'S'
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|QPINGONFAILURE
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'F'
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|QPINGONDELAY
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'D'
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|q_alias
operator|!=
name|NULL
operator|&&
name|bitset
argument_list|(
name|QALIAS
argument_list|,
name|q
operator|->
name|q_alias
operator|->
name|q_flags
argument_list|)
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'A'
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|':'
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"%s\n"
argument_list|,
name|denlstring
argument_list|(
name|q
operator|->
name|q_paddr
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|announce
condition|)
block|{
name|e
operator|->
name|e_to
operator|=
name|q
operator|->
name|q_paddr
expr_stmt|;
name|message
argument_list|(
literal|"queued"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|logdelivery
argument_list|(
name|q
operator|->
name|q_mailer
argument_list|,
name|NULL
argument_list|,
name|q
operator|->
name|q_status
argument_list|,
literal|"queued"
argument_list|,
name|NULL
argument_list|,
operator|(
name|time_t
operator|)
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|"queueing "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|q
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	**  Output headers for this message. 	**	Expand macros completely here.  Queue run will deal with 	**	everything as absolute headers. 	**		All headers that must be relative to the recipient 	**		can be cracked later. 	**	We set up a "null mailer" -- i.e., a mailer that will have 	**	no effect on the addresses as they are output. 	*/
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|nullmailer
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|nullmailer
argument_list|)
expr_stmt|;
name|nullmailer
operator|.
name|m_re_rwset
operator|=
name|nullmailer
operator|.
name|m_rh_rwset
operator|=
name|nullmailer
operator|.
name|m_se_rwset
operator|=
name|nullmailer
operator|.
name|m_sh_rwset
operator|=
operator|-
literal|1
expr_stmt|;
name|nullmailer
operator|.
name|m_eol
operator|=
literal|"\n"
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mcibuf
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|mcibuf
argument_list|)
expr_stmt|;
name|mcibuf
operator|.
name|mci_mailer
operator|=
operator|&
name|nullmailer
expr_stmt|;
name|mcibuf
operator|.
name|mci_out
operator|=
name|tfp
expr_stmt|;
name|define
argument_list|(
literal|'g'
argument_list|,
literal|"\201f"
argument_list|,
name|e
argument_list|)
expr_stmt|;
for|for
control|(
name|h
operator|=
name|e
operator|->
name|e_header
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|h_link
control|)
block|{
if|if
condition|(
name|h
operator|->
name|h_value
operator|==
name|NULL
condition|)
continue|continue;
comment|/* don't output resent headers on non-resent messages */
if|if
condition|(
name|bitset
argument_list|(
name|H_RESENT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_RESENT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
continue|continue;
comment|/* expand macros; if null, don't output header at all */
if|if
condition|(
name|bitset
argument_list|(
name|H_DEFAULT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|expand
argument_list|(
name|h
operator|->
name|h_value
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
block|}
comment|/* output this header */
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"H?"
argument_list|)
expr_stmt|;
comment|/* output conditional macro if present */
if|if
condition|(
name|h
operator|->
name|h_macro
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|bitset
argument_list|(
literal|0200
argument_list|,
name|h
operator|->
name|h_macro
argument_list|)
condition|)
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"${%s}"
argument_list|,
name|macname
argument_list|(
name|bitidx
argument_list|(
name|h
operator|->
name|h_macro
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"$%c"
argument_list|,
name|h
operator|->
name|h_macro
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|bitzerop
argument_list|(
name|h
operator|->
name|h_mflags
argument_list|)
operator|&&
name|bitset
argument_list|(
name|H_CHECK
operator||
name|H_ACHECK
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
comment|/* if conditional, output the set of conditions */
for|for
control|(
name|j
operator|=
literal|'\0'
init|;
name|j
operator|<=
literal|'\177'
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|bitnset
argument_list|(
name|j
argument_list|,
name|h
operator|->
name|h_mflags
argument_list|)
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
name|j
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'?'
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
comment|/* output the header: expand macros, convert addresses */
if|if
condition|(
name|bitset
argument_list|(
name|H_DEFAULT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|H_BINDLATE
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|h
operator|->
name|h_field
argument_list|,
name|denlstring
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|H_FROM
operator||
name|H_RCPT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|H_BINDLATE
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
block|{
name|bool
name|oldstyle
init|=
name|bitset
argument_list|(
name|EF_OLDSTYLE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|savetrace
init|=
name|TrafficLogFile
decl_stmt|;
name|TrafficLogFile
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|H_FROM
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
name|oldstyle
operator|=
name|FALSE
expr_stmt|;
name|commaize
argument_list|(
name|h
argument_list|,
name|h
operator|->
name|h_value
argument_list|,
name|oldstyle
argument_list|,
operator|&
name|mcibuf
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|TrafficLogFile
operator|=
name|savetrace
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|h
operator|->
name|h_field
argument_list|,
name|denlstring
argument_list|(
name|h
operator|->
name|h_value
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	**  Clean up. 	** 	**	Write a terminator record -- this is to prevent 	**	scurrilous crackers from appending any data. 	*/
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|tfp
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|SuperSafe
operator|&&
name|fsync
argument_list|(
name|fileno
argument_list|(
name|tfp
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
operator|||
name|ferror
argument_list|(
name|tfp
argument_list|)
condition|)
block|{
if|if
condition|(
name|newid
condition|)
name|syserr
argument_list|(
literal|"!552 Error writing control file %s"
argument_list|,
name|tf
argument_list|)
expr_stmt|;
else|else
name|syserr
argument_list|(
literal|"!452 Error writing control file %s"
argument_list|,
name|tf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|newid
condition|)
block|{
comment|/* rename (locked) tf to be (locked) qf */
name|qf
operator|=
name|queuename
argument_list|(
name|e
argument_list|,
literal|'q'
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|tf
argument_list|,
name|qf
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"cannot rename(%s, %s), uid=%d"
argument_list|,
name|tf
argument_list|,
name|qf
argument_list|,
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* 		**  fsync() after renaming to make sure 		**  metadata is written to disk on 		**  filesystems in which renames are 		**  not guaranteed such as softupdates. 		*/
if|if
condition|(
name|tfd
operator|>=
literal|0
operator|&&
name|SuperSafe
operator|&&
name|fsync
argument_list|(
name|tfd
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"!queueup: cannot fsync queue temp file %s"
argument_list|,
name|tf
argument_list|)
expr_stmt|;
comment|/* close and unlock old (locked) qf */
if|if
condition|(
name|e
operator|->
name|e_lockfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
operator|->
name|e_lockfp
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_lockfp
operator|=
name|tfp
expr_stmt|;
block|}
else|else
name|qf
operator|=
name|tf
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_INQUEUE
expr_stmt|;
comment|/* save log info */
if|if
condition|(
name|LogLevel
operator|>
literal|79
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"queueup, qf=%s"
argument_list|,
name|qf
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|1
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"<<<<< done queueing %s<<<<<\n\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|printctladdr
parameter_list|(
name|a
parameter_list|,
name|tfp
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
name|FILE
modifier|*
name|tfp
decl_stmt|;
block|{
name|char
modifier|*
name|user
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
specifier|static
name|ADDRESS
modifier|*
name|lastctladdr
init|=
name|NULL
decl_stmt|;
specifier|static
name|uid_t
name|lastuid
decl_stmt|;
comment|/* initialization */
if|if
condition|(
name|a
operator|==
name|NULL
operator|||
name|a
operator|->
name|q_alias
operator|==
name|NULL
operator|||
name|tfp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|lastctladdr
operator|!=
name|NULL
operator|&&
name|tfp
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"C\n"
argument_list|)
expr_stmt|;
name|lastctladdr
operator|=
name|NULL
expr_stmt|;
name|lastuid
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* find the active uid */
name|q
operator|=
name|getctladdr
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
name|user
operator|=
name|NULL
expr_stmt|;
name|uid
operator|=
literal|0
expr_stmt|;
name|gid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|user
operator|=
name|q
operator|->
name|q_ruser
operator|!=
name|NULL
condition|?
name|q
operator|->
name|q_ruser
else|:
name|q
operator|->
name|q_user
expr_stmt|;
name|uid
operator|=
name|q
operator|->
name|q_uid
expr_stmt|;
name|gid
operator|=
name|q
operator|->
name|q_gid
expr_stmt|;
block|}
name|a
operator|=
name|a
operator|->
name|q_alias
expr_stmt|;
comment|/* check to see if this is the same as last time */
if|if
condition|(
name|lastctladdr
operator|!=
name|NULL
operator|&&
name|uid
operator|==
name|lastuid
operator|&&
name|strcmp
argument_list|(
name|lastctladdr
operator|->
name|q_paddr
argument_list|,
name|a
operator|->
name|q_paddr
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|lastuid
operator|=
name|uid
expr_stmt|;
name|lastctladdr
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|uid
operator|==
literal|0
operator|||
name|user
operator|==
name|NULL
operator|||
name|user
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"C"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"C%s:%ld:%ld"
argument_list|,
name|denlstring
argument_list|(
name|user
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|uid
argument_list|,
operator|(
name|long
operator|)
name|gid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|":%s\n"
argument_list|,
name|denlstring
argument_list|(
name|a
operator|->
name|q_paddr
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  RUNQUEUE -- run the jobs in the queue. ** **	Gets the stuff out of the queue in some presumably logical **	order and processes them. ** **	Parameters: **		forkflag -- TRUE if the queue scanning should be done in **			a child process.  We double-fork so it is not our **			child and we don't have to clean up after it. **			FALSE can be ignored if we have multiple queues. **		verbose -- if TRUE, print out status information. ** **	Returns: **		TRUE if the queue run successfully began. ** **	Side Effects: **		runs things in the mail queue. */
end_comment

begin_decl_stmt
specifier|static
name|ENVELOPE
name|QueueEnvelope
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the queue run envelope */
end_comment

begin_decl_stmt
name|int
name|NumQueues
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of queues */
end_comment

begin_decl_stmt
specifier|static
name|time_t
name|LastQueueTime
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last time a queue ID assigned */
end_comment

begin_decl_stmt
specifier|static
name|pid_t
name|LastQueuePid
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last PID which had a queue ID */
end_comment

begin_struct
struct|struct
name|qpaths_s
block|{
name|char
modifier|*
name|qp_name
decl_stmt|;
comment|/* name of queue dir */
name|short
name|qp_subdirs
decl_stmt|;
comment|/* use subdirs? */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|qpaths_s
name|QPATHS
typedef|;
end_typedef

begin_comment
comment|/* values for qp_supdirs */
end_comment

begin_define
define|#
directive|define
name|QP_NOSUB
value|0x0000
end_define

begin_comment
comment|/* No subdirectories */
end_comment

begin_define
define|#
directive|define
name|QP_SUBDF
value|0x0001
end_define

begin_comment
comment|/* "df" subdirectory */
end_comment

begin_define
define|#
directive|define
name|QP_SUBQF
value|0x0002
end_define

begin_comment
comment|/* "qf" subdirectory */
end_comment

begin_define
define|#
directive|define
name|QP_SUBXF
value|0x0004
end_define

begin_comment
comment|/* "xf" subdirectory */
end_comment

begin_decl_stmt
specifier|static
name|QPATHS
modifier|*
name|QPaths
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of queue directories */
end_comment

begin_function
name|bool
name|runqueue
parameter_list|(
name|forkflag
parameter_list|,
name|verbose
parameter_list|)
name|bool
name|forkflag
decl_stmt|;
name|bool
name|verbose
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|bool
name|ret
init|=
name|TRUE
decl_stmt|;
specifier|static
name|int
name|curnum
init|=
literal|0
decl_stmt|;
name|DoQueueRun
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|forkflag
operator|&&
name|NumQueues
operator|>
literal|1
operator|&&
operator|!
name|verbose
condition|)
name|forkflag
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NumQueues
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		**  Pick up where we left off, in case we 		**  used up all the children last time 		**  without finishing. 		*/
name|ret
operator|=
name|run_single_queue
argument_list|(
name|curnum
argument_list|,
name|forkflag
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
comment|/* 		**  Failure means a message was printed for ETRN 		**  and subsequent queues are likely to fail as well. 		*/
if|if
condition|(
operator|!
name|ret
condition|)
break|break;
if|if
condition|(
operator|++
name|curnum
operator|>=
name|NumQueues
condition|)
name|curnum
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|QueueIntvl
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|setevent
argument_list|(
name|QueueIntvl
argument_list|,
name|runqueueevent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  RUN_SINGLE_QUEUE -- run the jobs in a single queue. ** **	Gets the stuff out of the queue in some presumably logical **	order and processes them. ** **	Parameters: **		queuedir -- queue to process **		forkflag -- TRUE if the queue scanning should be done in **			a child process.  We double-fork so it is not our **			child and we don't have to clean up after it. **		verbose -- if TRUE, print out status information. ** **	Returns: **		TRUE if the queue run successfully began. ** **	Side Effects: **		runs things in the mail queue. */
end_comment

begin_function
specifier|static
name|bool
name|run_single_queue
parameter_list|(
name|queuedir
parameter_list|,
name|forkflag
parameter_list|,
name|verbose
parameter_list|)
name|int
name|queuedir
decl_stmt|;
name|bool
name|forkflag
decl_stmt|;
name|bool
name|verbose
decl_stmt|;
block|{
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|int
name|njobs
decl_stmt|;
name|int
name|sequenceno
init|=
literal|0
decl_stmt|;
name|time_t
name|current_la_time
decl_stmt|,
name|now
decl_stmt|;
specifier|extern
name|ENVELOPE
name|BlankEnvelope
decl_stmt|;
comment|/* 	**  If no work will ever be selected, don't even bother reading 	**  the queue. 	*/
name|CurrentLA
operator|=
name|sm_getla
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* get load average */
name|current_la_time
operator|=
name|curtime
argument_list|()
expr_stmt|;
if|if
condition|(
name|shouldqueue
argument_list|(
name|WkRecipFact
argument_list|,
name|current_la_time
argument_list|)
condition|)
block|{
name|char
modifier|*
name|msg
init|=
literal|"Skipping queue run -- load average too high"
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
name|message
argument_list|(
literal|"458 %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"runqueue: %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* 	**  See if we already have too many children. 	*/
if|if
condition|(
name|forkflag
operator|&&
name|QueueIntvl
operator|!=
literal|0
operator|&&
name|MaxChildren
operator|>
literal|0
operator|&&
name|CurChildren
operator|>=
name|MaxChildren
condition|)
block|{
name|char
modifier|*
name|msg
init|=
literal|"Skipping queue run -- too many children"
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
name|message
argument_list|(
literal|"458 %s (%d)\n"
argument_list|,
name|msg
argument_list|,
name|CurChildren
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"runqueue: %s (%d)"
argument_list|,
name|msg
argument_list|,
name|CurChildren
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* 	**  See if we want to go off and do other useful work. 	*/
if|if
condition|(
name|forkflag
condition|)
block|{
name|pid_t
name|pid
decl_stmt|;
operator|(
name|void
operator|)
name|blocksignal
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGCHLD
argument_list|,
name|reapchild
argument_list|)
expr_stmt|;
name|pid
operator|=
name|dofork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
literal|"Skipping queue run -- fork() failed"
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
init|=
name|errstring
argument_list|(
name|errno
argument_list|)
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
name|message
argument_list|(
literal|"458 %s: %s\n"
argument_list|,
name|msg
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"runqueue: %s: %s"
argument_list|,
name|msg
argument_list|,
name|err
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|releasesignal
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|pid
operator|!=
literal|0
condition|)
block|{
comment|/* parent -- pick up intermediate zombie */
operator|(
name|void
operator|)
name|blocksignal
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
name|proc_list_add
argument_list|(
name|pid
argument_list|,
literal|"Queue runner"
argument_list|,
name|PROC_QUEUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|releasesignal
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|releasesignal
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* child -- clean up signals */
comment|/* Reset global flags */
name|RestartRequest
operator|=
name|NULL
expr_stmt|;
name|ShutdownRequest
operator|=
name|NULL
expr_stmt|;
name|PendingSignal
operator|=
literal|0
expr_stmt|;
name|clrcontrol
argument_list|()
expr_stmt|;
name|proc_list_clear
argument_list|()
expr_stmt|;
comment|/* Add parent process as first child item */
name|proc_list_add
argument_list|(
name|getpid
argument_list|()
argument_list|,
literal|"Queue runner child process"
argument_list|,
name|PROC_QUEUE_CHILD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|releasesignal
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGTERM
argument_list|,
name|intsig
argument_list|)
expr_stmt|;
block|}
name|sm_setproctitle
argument_list|(
name|TRUE
argument_list|,
name|CurEnv
argument_list|,
literal|"running queue: %s"
argument_list|,
name|qid_printqueue
argument_list|(
name|queuedir
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|69
operator|||
name|tTd
argument_list|(
literal|63
argument_list|,
literal|99
argument_list|)
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|NOQID
argument_list|,
literal|"runqueue %s, pid=%d, forkflag=%d"
argument_list|,
name|qid_printqueue
argument_list|(
name|queuedir
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|,
name|forkflag
argument_list|)
expr_stmt|;
comment|/* 	**  Release any resources used by the daemon code. 	*/
if|#
directive|if
name|DAEMON
name|clrdaemon
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DAEMON */
comment|/* force it to run expensive jobs */
name|NoConnect
operator|=
name|FALSE
expr_stmt|;
comment|/* drop privileges */
if|if
condition|(
name|geteuid
argument_list|()
operator|==
operator|(
name|uid_t
operator|)
literal|0
condition|)
operator|(
name|void
operator|)
name|drop_privileges
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 	**  Create ourselves an envelope 	*/
name|CurEnv
operator|=
operator|&
name|QueueEnvelope
expr_stmt|;
name|e
operator|=
name|newenvelope
argument_list|(
operator|&
name|QueueEnvelope
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator|=
name|BlankEnvelope
operator|.
name|e_flags
expr_stmt|;
name|e
operator|->
name|e_parent
operator|=
name|NULL
expr_stmt|;
comment|/* make sure we have disconnected from parent */
if|if
condition|(
name|forkflag
condition|)
block|{
name|disconnect
argument_list|(
literal|1
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|QuickAbort
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* 	**  If we are running part of the queue, always ignore stored 	**  host status. 	*/
if|if
condition|(
name|QueueLimitId
operator|!=
name|NULL
operator|||
name|QueueLimitSender
operator|!=
name|NULL
operator|||
name|QueueLimitRecipient
operator|!=
name|NULL
condition|)
block|{
name|IgnoreHostStatus
operator|=
name|TRUE
expr_stmt|;
name|MinQueueAge
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	**  Start making passes through the queue. 	**	First, read and sort the entire queue. 	**	Then, process the work in that order. 	**		But if you take too long, start over. 	*/
comment|/* order the existing work requests */
name|njobs
operator|=
name|orderq
argument_list|(
name|queuedir
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* process them once at a time */
while|while
condition|(
name|WorkQ
operator|!=
name|NULL
condition|)
block|{
name|WORK
modifier|*
name|w
init|=
name|WorkQ
decl_stmt|;
name|WorkQ
operator|=
name|WorkQ
operator|->
name|w_next
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
comment|/* 		**  Ignore jobs that are too expensive for the moment. 		** 		**	Get new load average every 30 seconds. 		*/
name|now
operator|=
name|curtime
argument_list|()
expr_stmt|;
if|if
condition|(
name|current_la_time
operator|<
name|now
operator|-
literal|30
condition|)
block|{
name|CurrentLA
operator|=
name|sm_getla
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|current_la_time
operator|=
name|now
expr_stmt|;
block|}
if|if
condition|(
name|shouldqueue
argument_list|(
name|WkRecipFact
argument_list|,
name|current_la_time
argument_list|)
condition|)
block|{
name|char
modifier|*
name|msg
init|=
literal|"Aborting queue run: load average too high"
decl_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|message
argument_list|(
literal|"%s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"runqueue: %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
block|}
name|sequenceno
operator|++
expr_stmt|;
if|if
condition|(
name|shouldqueue
argument_list|(
name|w
operator|->
name|w_pri
argument_list|,
name|w
operator|->
name|w_ctime
argument_list|)
condition|)
block|{
if|if
condition|(
name|Verbose
condition|)
name|message
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|QueueSortOrder
operator|==
name|QSO_BYPRIORITY
condition|)
block|{
if|if
condition|(
name|Verbose
condition|)
name|message
argument_list|(
literal|"Skipping %s/%s (sequence %d of %d) and flushing rest of queue"
argument_list|,
name|qid_printqueue
argument_list|(
name|queuedir
argument_list|)
argument_list|,
name|w
operator|->
name|w_name
operator|+
literal|2
argument_list|,
name|sequenceno
argument_list|,
name|njobs
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"runqueue: Flushing queue from %s/%s (pri %ld, LA %d, %d of %d)"
argument_list|,
name|qid_printqueue
argument_list|(
name|queuedir
argument_list|)
argument_list|,
name|w
operator|->
name|w_name
operator|+
literal|2
argument_list|,
name|w
operator|->
name|w_pri
argument_list|,
name|CurrentLA
argument_list|,
name|sequenceno
argument_list|,
name|njobs
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|Verbose
condition|)
name|message
argument_list|(
literal|"Skipping %s/%s (sequence %d of %d)"
argument_list|,
name|qid_printqueue
argument_list|(
name|queuedir
argument_list|)
argument_list|,
name|w
operator|->
name|w_name
operator|+
literal|2
argument_list|,
name|sequenceno
argument_list|,
name|njobs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pid_t
name|pid
decl_stmt|;
if|if
condition|(
name|Verbose
condition|)
block|{
name|message
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"Running %s/%s (sequence %d of %d)"
argument_list|,
name|qid_printqueue
argument_list|(
name|queuedir
argument_list|)
argument_list|,
name|w
operator|->
name|w_name
operator|+
literal|2
argument_list|,
name|sequenceno
argument_list|,
name|njobs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|63
argument_list|,
literal|100
argument_list|)
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|NOQID
argument_list|,
literal|"runqueue %s dowork(%s)"
argument_list|,
name|qid_printqueue
argument_list|(
name|queuedir
argument_list|)
argument_list|,
name|w
operator|->
name|w_name
operator|+
literal|2
argument_list|)
expr_stmt|;
name|pid
operator|=
name|dowork
argument_list|(
name|queuedir
argument_list|,
name|w
operator|->
name|w_name
operator|+
literal|2
argument_list|,
name|ForkQueueRuns
argument_list|,
name|FALSE
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pid
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|waitfor
argument_list|(
name|pid
argument_list|)
expr_stmt|;
block|}
name|sm_free
argument_list|(
name|w
operator|->
name|w_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|w_host
condition|)
name|sm_free
argument_list|(
name|w
operator|->
name|w_host
argument_list|)
expr_stmt|;
name|sm_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|w
argument_list|)
expr_stmt|;
block|}
comment|/* exit without the usual cleanup */
name|e
operator|->
name|e_id
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|forkflag
condition|)
name|finis
argument_list|(
name|TRUE
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* **  RUNQUEUEEVENT -- stub for use in setevent ** **	Parameters: **		none. ** **	Returns: **		none. ** **	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD **		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE **		DOING. */
end_comment

begin_function
specifier|static
name|void
name|runqueueevent
parameter_list|()
block|{
name|DoQueueRun
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  ORDERQ -- order the work queue. ** **	Parameters: **		queuedir -- the index of the queue directory. **		doall -- if set, include everything in the queue (even **			the jobs that cannot be run because the load **			average is too high).  Otherwise, exclude those **			jobs. ** **	Returns: **		The number of request in the queue (not necessarily **		the number of requests in WorkQ however). ** **	Side Effects: **		Sets WorkQ to the queue of available work, in order. */
end_comment

begin_define
define|#
directive|define
name|NEED_P
value|001
end_define

begin_define
define|#
directive|define
name|NEED_T
value|002
end_define

begin_define
define|#
directive|define
name|NEED_R
value|004
end_define

begin_define
define|#
directive|define
name|NEED_S
value|010
end_define

begin_define
define|#
directive|define
name|NEED_H
value|020
end_define

begin_decl_stmt
specifier|static
name|WORK
modifier|*
name|WorkList
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|WorkListSize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|orderq
parameter_list|(
name|queuedir
parameter_list|,
name|doall
parameter_list|)
name|int
name|queuedir
decl_stmt|;
name|bool
name|doall
decl_stmt|;
block|{
specifier|register
name|struct
name|dirent
modifier|*
name|d
decl_stmt|;
specifier|register
name|WORK
modifier|*
name|w
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|DIR
modifier|*
name|f
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|wn
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|wc
decl_stmt|;
name|QUEUE_CHAR
modifier|*
name|check
decl_stmt|;
name|char
name|qd
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|qf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
name|queuedir
operator|==
name|NOQDIR
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|qd
argument_list|,
literal|"."
argument_list|,
sizeof|sizeof
name|qd
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|qd
argument_list|,
sizeof|sizeof
name|qd
argument_list|,
literal|"%s%s"
argument_list|,
name|QPaths
index|[
name|queuedir
index|]
operator|.
name|qp_name
argument_list|,
operator|(
name|bitset
argument_list|(
name|QP_SUBQF
argument_list|,
name|QPaths
index|[
name|queuedir
index|]
operator|.
name|qp_subdirs
argument_list|)
condition|?
literal|"/qf"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|"orderq:\n"
argument_list|)
expr_stmt|;
name|check
operator|=
name|QueueLimitId
expr_stmt|;
while|while
condition|(
name|check
operator|!=
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
literal|"\tQueueLimitId = %s\n"
argument_list|,
name|check
operator|->
name|queue_match
argument_list|)
expr_stmt|;
name|check
operator|=
name|check
operator|->
name|queue_next
expr_stmt|;
block|}
name|check
operator|=
name|QueueLimitSender
expr_stmt|;
while|while
condition|(
name|check
operator|!=
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
literal|"\tQueueLimitSender = %s\n"
argument_list|,
name|check
operator|->
name|queue_match
argument_list|)
expr_stmt|;
name|check
operator|=
name|check
operator|->
name|queue_next
expr_stmt|;
block|}
name|check
operator|=
name|QueueLimitRecipient
expr_stmt|;
while|while
condition|(
name|check
operator|!=
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
literal|"\tQueueLimitRecipient = %s\n"
argument_list|,
name|check
operator|->
name|queue_match
argument_list|)
expr_stmt|;
name|check
operator|=
name|check
operator|->
name|queue_next
expr_stmt|;
block|}
block|}
comment|/* clear out old WorkQ */
for|for
control|(
name|w
operator|=
name|WorkQ
init|;
name|w
operator|!=
name|NULL
condition|;
control|)
block|{
specifier|register
name|WORK
modifier|*
name|nw
init|=
name|w
operator|->
name|w_next
decl_stmt|;
name|WorkQ
operator|=
name|nw
expr_stmt|;
name|sm_free
argument_list|(
name|w
operator|->
name|w_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|w_host
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|w
operator|->
name|w_host
argument_list|)
expr_stmt|;
name|sm_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|w
argument_list|)
expr_stmt|;
name|w
operator|=
name|nw
expr_stmt|;
block|}
comment|/* open the queue directory */
name|f
operator|=
name|opendir
argument_list|(
name|qd
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"orderq: cannot open \"%s\""
argument_list|,
name|qid_printqueue
argument_list|(
name|queuedir
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	**  Read the work directory. 	*/
while|while
condition|(
operator|(
name|d
operator|=
name|readdir
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|FILE
modifier|*
name|cf
decl_stmt|;
name|int
name|qfver
init|=
literal|0
decl_stmt|;
name|char
name|lbuf
index|[
name|MAXNAME
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|50
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"orderq: checking %s\n"
argument_list|,
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
comment|/* is this an interesting entry? */
if|if
condition|(
name|d
operator|->
name|d_name
index|[
literal|0
index|]
operator|!=
literal|'q'
operator|||
name|d
operator|->
name|d_name
index|[
literal|1
index|]
operator|!=
literal|'f'
condition|)
continue|continue;
if|if
condition|(
name|strlen
argument_list|(
name|d
operator|->
name|d_name
argument_list|)
operator|>=
name|MAXQFNAME
condition|)
block|{
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"orderq: %s too long, %d max characters\n"
argument_list|,
name|d
operator|->
name|d_name
argument_list|,
name|MAXQFNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ALERT
argument_list|,
name|NOQID
argument_list|,
literal|"orderq: %s too long, %d max characters"
argument_list|,
name|d
operator|->
name|d_name
argument_list|,
name|MAXQFNAME
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|check
operator|=
name|QueueLimitId
expr_stmt|;
while|while
condition|(
name|check
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcontainedin
argument_list|(
name|check
operator|->
name|queue_match
argument_list|,
name|d
operator|->
name|d_name
argument_list|)
condition|)
break|break;
else|else
name|check
operator|=
name|check
operator|->
name|queue_next
expr_stmt|;
block|}
if|if
condition|(
name|QueueLimitId
operator|!=
name|NULL
operator|&&
name|check
operator|==
name|NULL
condition|)
continue|continue;
comment|/* grow work list if necessary */
if|if
condition|(
operator|++
name|wn
operator|>=
name|MaxQueueRun
operator|&&
name|MaxQueueRun
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|wn
operator|==
name|MaxQueueRun
operator|&&
name|LogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"WorkList for %s maxed out at %d"
argument_list|,
name|qid_printqueue
argument_list|(
name|queuedir
argument_list|)
argument_list|,
name|MaxQueueRun
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|wn
operator|>=
name|WorkListSize
condition|)
block|{
name|grow_wlist
argument_list|(
name|queuedir
argument_list|)
expr_stmt|;
if|if
condition|(
name|wn
operator|>=
name|WorkListSize
condition|)
continue|continue;
block|}
name|w
operator|=
operator|&
name|WorkList
index|[
name|wn
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|qf
argument_list|,
sizeof|sizeof
name|qf
argument_list|,
literal|"%s/%s"
argument_list|,
name|qd
argument_list|,
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|qf
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"orderq: can't stat %s/%s"
argument_list|,
name|qid_printqueue
argument_list|(
name|queuedir
argument_list|)
argument_list|,
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|wn
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|S_IFREG
argument_list|,
name|sbuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* Yikes!  Skip it or we will hang on open! */
name|syserr
argument_list|(
literal|"orderq: %s/%s is not a regular file"
argument_list|,
name|qid_printqueue
argument_list|(
name|queuedir
argument_list|)
argument_list|,
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|wn
operator|--
expr_stmt|;
continue|continue;
block|}
comment|/* avoid work if possible */
if|if
condition|(
name|QueueSortOrder
operator|==
name|QSO_BYFILENAME
operator|&&
name|QueueLimitSender
operator|==
name|NULL
operator|&&
name|QueueLimitRecipient
operator|==
name|NULL
condition|)
block|{
name|w
operator|->
name|w_name
operator|=
name|newstr
argument_list|(
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|w
operator|->
name|w_host
operator|=
name|NULL
expr_stmt|;
name|w
operator|->
name|w_lock
operator|=
name|w
operator|->
name|w_tooyoung
operator|=
name|FALSE
expr_stmt|;
name|w
operator|->
name|w_pri
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|w_ctime
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* open control file */
name|cf
operator|=
name|fopen
argument_list|(
name|qf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cf
operator|==
name|NULL
condition|)
block|{
comment|/* this may be some random person sending hir msgs */
comment|/* syserr("orderq: cannot open %s", cbuf); */
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|2
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"orderq: cannot open %s: %s\n"
argument_list|,
name|d
operator|->
name|d_name
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|wn
operator|--
expr_stmt|;
continue|continue;
block|}
name|w
operator|->
name|w_name
operator|=
name|newstr
argument_list|(
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|w
operator|->
name|w_host
operator|=
name|NULL
expr_stmt|;
name|w
operator|->
name|w_lock
operator|=
operator|!
name|lockfile
argument_list|(
name|fileno
argument_list|(
name|cf
argument_list|)
argument_list|,
name|w
operator|->
name|w_name
argument_list|,
name|NULL
argument_list|,
name|LOCK_SH
operator||
name|LOCK_NB
argument_list|)
expr_stmt|;
name|w
operator|->
name|w_tooyoung
operator|=
name|FALSE
expr_stmt|;
comment|/* make sure jobs in creation don't clog queue */
name|w
operator|->
name|w_pri
operator|=
literal|0x7fffffff
expr_stmt|;
name|w
operator|->
name|w_ctime
operator|=
literal|0
expr_stmt|;
comment|/* extract useful information */
name|i
operator|=
name|NEED_P
operator||
name|NEED_T
expr_stmt|;
if|if
condition|(
name|QueueSortOrder
operator|==
name|QSO_BYHOST
condition|)
block|{
comment|/* need w_host set for host sort order */
name|i
operator||=
name|NEED_H
expr_stmt|;
block|}
if|if
condition|(
name|QueueLimitSender
operator|!=
name|NULL
condition|)
name|i
operator||=
name|NEED_S
expr_stmt|;
if|if
condition|(
name|QueueLimitRecipient
operator|!=
name|NULL
condition|)
name|i
operator||=
name|NEED_R
expr_stmt|;
while|while
condition|(
name|i
operator|!=
literal|0
operator|&&
name|fgets
argument_list|(
name|lbuf
argument_list|,
sizeof|sizeof
name|lbuf
argument_list|,
name|cf
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|c
decl_stmt|;
name|time_t
name|age
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|lbuf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
comment|/* flush rest of overly long line */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|cf
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
continue|continue;
block|}
switch|switch
condition|(
name|lbuf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'V'
case|:
name|qfver
operator|=
name|atoi
argument_list|(
operator|&
name|lbuf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|w
operator|->
name|w_pri
operator|=
name|atol
argument_list|(
operator|&
name|lbuf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|&=
operator|~
name|NEED_P
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|w
operator|->
name|w_ctime
operator|=
name|atol
argument_list|(
operator|&
name|lbuf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|&=
operator|~
name|NEED_T
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
if|if
condition|(
name|w
operator|->
name|w_host
operator|==
name|NULL
operator|&&
operator|(
name|p
operator|=
name|strrchr
argument_list|(
operator|&
name|lbuf
index|[
literal|1
index|]
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|w
operator|->
name|w_host
operator|=
name|strrev
argument_list|(
operator|&
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|makelower
argument_list|(
name|w
operator|->
name|w_host
argument_list|)
expr_stmt|;
name|i
operator|&=
operator|~
name|NEED_H
expr_stmt|;
block|}
if|if
condition|(
name|QueueLimitRecipient
operator|==
name|NULL
condition|)
block|{
name|i
operator|&=
operator|~
name|NEED_R
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|qfver
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|strchr
argument_list|(
operator|&
name|lbuf
index|[
literal|1
index|]
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
operator|&
name|lbuf
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
name|p
operator|=
operator|&
name|lbuf
index|[
literal|1
index|]
expr_stmt|;
name|check
operator|=
name|QueueLimitRecipient
expr_stmt|;
while|while
condition|(
name|check
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcontainedin
argument_list|(
name|check
operator|->
name|queue_match
argument_list|,
name|p
argument_list|)
condition|)
break|break;
else|else
name|check
operator|=
name|check
operator|->
name|queue_next
expr_stmt|;
block|}
if|if
condition|(
name|check
operator|!=
name|NULL
condition|)
name|i
operator|&=
operator|~
name|NEED_R
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|check
operator|=
name|QueueLimitSender
expr_stmt|;
while|while
condition|(
name|check
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcontainedin
argument_list|(
name|check
operator|->
name|queue_match
argument_list|,
operator|&
name|lbuf
index|[
literal|1
index|]
argument_list|)
condition|)
break|break;
else|else
name|check
operator|=
name|check
operator|->
name|queue_next
expr_stmt|;
block|}
if|if
condition|(
name|check
operator|!=
name|NULL
condition|)
name|i
operator|&=
operator|~
name|NEED_S
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|age
operator|=
name|curtime
argument_list|()
operator|-
operator|(
name|time_t
operator|)
name|atol
argument_list|(
operator|&
name|lbuf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|age
operator|>=
literal|0
operator|&&
name|MinQueueAge
operator|>
literal|0
operator|&&
name|age
operator|<
name|MinQueueAge
condition|)
name|w
operator|->
name|w_tooyoung
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
if|if
condition|(
name|atol
argument_list|(
operator|&
name|lbuf
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
name|w
operator|->
name|w_tooyoung
operator|=
name|FALSE
expr_stmt|;
break|break;
if|#
directive|if
name|_FFR_QUEUEDELAY
comment|/* 			  case 'G': 				queuealg = atoi(lbuf[1]); 				break; 			  case 'Y': 				queuedelay = (time_t) atol(&lbuf[1]); 				break; */
endif|#
directive|endif
comment|/* _FFR_QUEUEDELAY */
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|cf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|doall
operator|&&
name|shouldqueue
argument_list|(
name|w
operator|->
name|w_pri
argument_list|,
name|w
operator|->
name|w_ctime
argument_list|)
operator|)
operator|||
name|bitset
argument_list|(
name|NEED_R
operator||
name|NEED_S
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* don't even bother sorting this job in */
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|49
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"skipping %s (%x)\n"
argument_list|,
name|w
operator|->
name|w_name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sm_free
argument_list|(
name|w
operator|->
name|w_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|w_host
condition|)
name|sm_free
argument_list|(
name|w
operator|->
name|w_host
argument_list|)
expr_stmt|;
name|wn
operator|--
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|wn
operator|++
expr_stmt|;
name|WorkQ
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|WorkList
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|wc
operator|=
name|min
argument_list|(
name|wn
argument_list|,
name|WorkListSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc
operator|>
name|MaxQueueRun
operator|&&
name|MaxQueueRun
operator|>
literal|0
condition|)
name|wc
operator|=
name|MaxQueueRun
expr_stmt|;
if|if
condition|(
name|QueueSortOrder
operator|==
name|QSO_BYHOST
condition|)
block|{
comment|/* 		**  Sort the work directory for the first time, 		**  based on host name, lock status, and priority. 		*/
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|WorkList
argument_list|,
name|wc
argument_list|,
sizeof|sizeof
expr|*
name|WorkList
argument_list|,
name|workcmpf1
argument_list|)
expr_stmt|;
comment|/* 		**  If one message to host is locked, "lock" all messages 		**  to that host. 		*/
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|wc
condition|)
block|{
if|if
condition|(
operator|!
name|WorkList
index|[
name|i
index|]
operator|.
name|w_lock
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
name|w
operator|=
operator|&
name|WorkList
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|++
name|i
operator|<
name|wc
condition|)
block|{
if|if
condition|(
name|WorkList
index|[
name|i
index|]
operator|.
name|w_host
operator|==
name|NULL
operator|&&
name|w
operator|->
name|w_host
operator|==
name|NULL
condition|)
name|WorkList
index|[
name|i
index|]
operator|.
name|w_lock
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|WorkList
index|[
name|i
index|]
operator|.
name|w_host
operator|!=
name|NULL
operator|&&
name|w
operator|->
name|w_host
operator|!=
name|NULL
operator|&&
name|sm_strcasecmp
argument_list|(
name|WorkList
index|[
name|i
index|]
operator|.
name|w_host
argument_list|,
name|w
operator|->
name|w_host
argument_list|)
operator|==
literal|0
condition|)
name|WorkList
index|[
name|i
index|]
operator|.
name|w_lock
operator|=
name|TRUE
expr_stmt|;
else|else
break|break;
block|}
block|}
comment|/* 		**  Sort the work directory for the second time, 		**  based on lock status, host name, and priority. 		*/
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|WorkList
argument_list|,
name|wc
argument_list|,
sizeof|sizeof
expr|*
name|WorkList
argument_list|,
name|workcmpf2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QueueSortOrder
operator|==
name|QSO_BYTIME
condition|)
block|{
comment|/* 		**  Simple sort based on submission time only. 		*/
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|WorkList
argument_list|,
name|wc
argument_list|,
sizeof|sizeof
expr|*
name|WorkList
argument_list|,
name|workcmpf3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QueueSortOrder
operator|==
name|QSO_BYFILENAME
condition|)
block|{
comment|/* 		**  Sort based on qf filename. 		*/
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|WorkList
argument_list|,
name|wc
argument_list|,
sizeof|sizeof
expr|*
name|WorkList
argument_list|,
name|workcmpf4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		**  Simple sort based on queue priority only. 		*/
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|WorkList
argument_list|,
name|wc
argument_list|,
sizeof|sizeof
expr|*
name|WorkList
argument_list|,
name|workcmpf0
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Convert the work list into canonical form. 	**	Should be turning it into a list of envelopes here perhaps. 	*/
for|for
control|(
name|i
operator|=
name|wc
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|w
operator|=
operator|(
name|WORK
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|w
argument_list|)
expr_stmt|;
name|w
operator|->
name|w_name
operator|=
name|WorkList
index|[
name|i
index|]
operator|.
name|w_name
expr_stmt|;
name|w
operator|->
name|w_host
operator|=
name|WorkList
index|[
name|i
index|]
operator|.
name|w_host
expr_stmt|;
name|w
operator|->
name|w_lock
operator|=
name|WorkList
index|[
name|i
index|]
operator|.
name|w_lock
expr_stmt|;
name|w
operator|->
name|w_tooyoung
operator|=
name|WorkList
index|[
name|i
index|]
operator|.
name|w_tooyoung
expr_stmt|;
name|w
operator|->
name|w_pri
operator|=
name|WorkList
index|[
name|i
index|]
operator|.
name|w_pri
expr_stmt|;
name|w
operator|->
name|w_ctime
operator|=
name|WorkList
index|[
name|i
index|]
operator|.
name|w_ctime
expr_stmt|;
name|w
operator|->
name|w_next
operator|=
name|WorkQ
expr_stmt|;
name|WorkQ
operator|=
name|w
expr_stmt|;
block|}
if|if
condition|(
name|WorkList
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|WorkList
argument_list|)
expr_stmt|;
name|WorkList
operator|=
name|NULL
expr_stmt|;
name|WorkListSize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|1
argument_list|)
condition|)
block|{
for|for
control|(
name|w
operator|=
name|WorkQ
init|;
name|w
operator|!=
name|NULL
condition|;
name|w
operator|=
name|w
operator|->
name|w_next
control|)
block|{
if|if
condition|(
name|w
operator|->
name|w_host
operator|!=
name|NULL
condition|)
name|dprintf
argument_list|(
literal|"%22s: pri=%ld %s\n"
argument_list|,
name|w
operator|->
name|w_name
argument_list|,
name|w
operator|->
name|w_pri
argument_list|,
name|w
operator|->
name|w_host
argument_list|)
expr_stmt|;
else|else
name|dprintf
argument_list|(
literal|"%32s: pri=%ld\n"
argument_list|,
name|w
operator|->
name|w_name
argument_list|,
name|w
operator|->
name|w_pri
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|wn
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  GROW_WLIST -- make the work list larger ** **	Parameters: **		queuedir -- the index for the queue directory. ** **	Returns: **		none. ** **	Side Effects: **		Adds another QUEUESEGSIZE entries to WorkList if possible. **		It can fail if there isn't enough memory, so WorkListSize **		should be checked again upon return. */
end_comment

begin_function
specifier|static
name|void
name|grow_wlist
parameter_list|(
name|queuedir
parameter_list|)
name|int
name|queuedir
decl_stmt|;
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|1
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"grow_wlist: WorkListSize=%d\n"
argument_list|,
name|WorkListSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|WorkList
operator|==
name|NULL
condition|)
block|{
name|WorkList
operator|=
operator|(
name|WORK
operator|*
operator|)
name|xalloc
argument_list|(
operator|(
sizeof|sizeof
expr|*
name|WorkList
operator|)
operator|*
operator|(
name|QUEUESEGSIZE
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|WorkListSize
operator|=
name|QUEUESEGSIZE
expr_stmt|;
block|}
else|else
block|{
name|int
name|newsize
init|=
name|WorkListSize
operator|+
name|QUEUESEGSIZE
decl_stmt|;
name|WORK
modifier|*
name|newlist
init|=
operator|(
name|WORK
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|WorkList
argument_list|,
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|WORK
argument_list|)
operator|*
operator|(
name|newsize
operator|+
literal|1
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|newlist
operator|!=
name|NULL
condition|)
block|{
name|WorkListSize
operator|=
name|newsize
expr_stmt|;
name|WorkList
operator|=
name|newlist
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|1
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"grew WorkList for %s to %d"
argument_list|,
name|qid_printqueue
argument_list|(
name|queuedir
argument_list|)
argument_list|,
name|WorkListSize
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|LogLevel
operator|>
literal|0
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_ALERT
argument_list|,
name|NOQID
argument_list|,
literal|"FAILED to grow WorkList for %s to %d"
argument_list|,
name|qid_printqueue
argument_list|(
name|queuedir
argument_list|)
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|1
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"grow_wlist: WorkListSize now %d\n"
argument_list|,
name|WorkListSize
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  WORKCMPF0 -- simple priority-only compare function. ** **	Parameters: **		a -- the first argument. **		b -- the second argument. ** **	Returns: **		-1 if a< b **		 0 if a == b **		+1 if a> b ** **	Side Effects: **		none. */
end_comment

begin_function
specifier|static
name|int
name|workcmpf0
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|WORK
modifier|*
name|a
decl_stmt|;
specifier|register
name|WORK
modifier|*
name|b
decl_stmt|;
block|{
name|long
name|pa
init|=
name|a
operator|->
name|w_pri
decl_stmt|;
name|long
name|pb
init|=
name|b
operator|->
name|w_pri
decl_stmt|;
if|if
condition|(
name|pa
operator|==
name|pb
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|pa
operator|>
name|pb
condition|)
return|return
literal|1
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  WORKCMPF1 -- first compare function for ordering work based on host name. ** **	Sorts on host name, lock status, and priority in that order. ** **	Parameters: **		a -- the first argument. **		b -- the second argument. ** **	Returns: **<0 if a< b **		 0 if a == b **>0 if a> b ** **	Side Effects: **		none. */
end_comment

begin_function
specifier|static
name|int
name|workcmpf1
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|WORK
modifier|*
name|a
decl_stmt|;
specifier|register
name|WORK
modifier|*
name|b
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* host name */
if|if
condition|(
name|a
operator|->
name|w_host
operator|!=
name|NULL
operator|&&
name|b
operator|->
name|w_host
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|w_host
operator|==
name|NULL
operator|&&
name|b
operator|->
name|w_host
operator|!=
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|w_host
operator|!=
name|NULL
operator|&&
name|b
operator|->
name|w_host
operator|!=
name|NULL
operator|&&
operator|(
name|i
operator|=
name|sm_strcasecmp
argument_list|(
name|a
operator|->
name|w_host
argument_list|,
name|b
operator|->
name|w_host
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|i
return|;
comment|/* lock status */
if|if
condition|(
name|a
operator|->
name|w_lock
operator|!=
name|b
operator|->
name|w_lock
condition|)
return|return
name|b
operator|->
name|w_lock
operator|-
name|a
operator|->
name|w_lock
return|;
comment|/* job priority */
return|return
name|workcmpf0
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  WORKCMPF2 -- second compare function for ordering work based on host name. ** **	Sorts on lock status, host name, and priority in that order. ** **	Parameters: **		a -- the first argument. **		b -- the second argument. ** **	Returns: **<0 if a< b **		 0 if a == b **>0 if a> b ** **	Side Effects: **		none. */
end_comment

begin_function
specifier|static
name|int
name|workcmpf2
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|WORK
modifier|*
name|a
decl_stmt|;
specifier|register
name|WORK
modifier|*
name|b
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* lock status */
if|if
condition|(
name|a
operator|->
name|w_lock
operator|!=
name|b
operator|->
name|w_lock
condition|)
return|return
name|a
operator|->
name|w_lock
operator|-
name|b
operator|->
name|w_lock
return|;
comment|/* host name */
if|if
condition|(
name|a
operator|->
name|w_host
operator|!=
name|NULL
operator|&&
name|b
operator|->
name|w_host
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|w_host
operator|==
name|NULL
operator|&&
name|b
operator|->
name|w_host
operator|!=
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|w_host
operator|!=
name|NULL
operator|&&
name|b
operator|->
name|w_host
operator|!=
name|NULL
operator|&&
operator|(
name|i
operator|=
name|sm_strcasecmp
argument_list|(
name|a
operator|->
name|w_host
argument_list|,
name|b
operator|->
name|w_host
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|i
return|;
comment|/* job priority */
return|return
name|workcmpf0
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  WORKCMPF3 -- simple submission-time-only compare function. ** **	Parameters: **		a -- the first argument. **		b -- the second argument. ** **	Returns: **		-1 if a< b **		 0 if a == b **		+1 if a> b ** **	Side Effects: **		none. */
end_comment

begin_function
specifier|static
name|int
name|workcmpf3
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|WORK
modifier|*
name|a
decl_stmt|;
specifier|register
name|WORK
modifier|*
name|b
decl_stmt|;
block|{
if|if
condition|(
name|a
operator|->
name|w_ctime
operator|>
name|b
operator|->
name|w_ctime
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|w_ctime
operator|<
name|b
operator|->
name|w_ctime
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  WORKCMPF4 -- compare based on file name ** **	Parameters: **		a -- the first argument. **		b -- the second argument. ** **	Returns: **		-1 if a< b **		 0 if a == b **		+1 if a> b ** **	Side Effects: **		none. */
end_comment

begin_function
specifier|static
name|int
name|workcmpf4
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|WORK
modifier|*
name|a
decl_stmt|;
specifier|register
name|WORK
modifier|*
name|b
decl_stmt|;
block|{
return|return
name|strcmp
argument_list|(
name|a
operator|->
name|w_name
argument_list|,
name|b
operator|->
name|w_name
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  STRREV -- reverse string ** **	Returns a pointer to a new string that is the reverse of **	the string pointed to by fwd.  The space for the new **	string is obtained using xalloc(). ** **	Parameters: **		fwd -- the string to reverse. ** **	Returns: **		the reversed string. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|strrev
parameter_list|(
name|fwd
parameter_list|)
name|char
modifier|*
name|fwd
decl_stmt|;
block|{
name|char
modifier|*
name|rev
init|=
name|NULL
decl_stmt|;
name|int
name|len
decl_stmt|,
name|cnt
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|fwd
argument_list|)
expr_stmt|;
name|rev
operator|=
name|xalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|len
condition|;
operator|++
name|cnt
control|)
name|rev
index|[
name|cnt
index|]
operator|=
name|fwd
index|[
name|len
operator|-
name|cnt
operator|-
literal|1
index|]
expr_stmt|;
name|rev
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|rev
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  DOWORK -- do a work request. ** **	Parameters: **		queuedir -- the index of the queue directory for the job. **		id -- the ID of the job to run. **		forkflag -- if set, run this in background. **		requeueflag -- if set, reinstantiate the queue quickly. **			This is used when expanding aliases in the queue. **			If forkflag is also set, it doesn't wait for the **			child. **		e - the envelope in which to run it. ** **	Returns: **		process id of process that is running the queue job. ** **	Side Effects: **		The work request is satisfied if possible. */
end_comment

begin_function
name|pid_t
name|dowork
parameter_list|(
name|queuedir
parameter_list|,
name|id
parameter_list|,
name|forkflag
parameter_list|,
name|requeueflag
parameter_list|,
name|e
parameter_list|)
name|int
name|queuedir
decl_stmt|;
name|char
modifier|*
name|id
decl_stmt|;
name|bool
name|forkflag
decl_stmt|;
name|bool
name|requeueflag
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|pid_t
name|pid
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|1
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"dowork(%s/%s)\n"
argument_list|,
name|qid_printqueue
argument_list|(
name|queuedir
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* 	**  Fork for work. 	*/
if|if
condition|(
name|forkflag
condition|)
block|{
comment|/* 		**  Since the delivery may happen in a child and the 		**  parent does not wait, the parent may close the 		**  maps thereby removing any shared memory used by 		**  the map.  Therefore, close the maps now so the 		**  child will dynamically open them if necessary. 		*/
name|closemaps
argument_list|()
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"dowork: cannot fork"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
block|{
comment|/* parent -- clean out connection cache */
name|mci_flush
argument_list|(
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* child -- error messages to the transcript */
name|QuickAbort
operator|=
name|OnlyOneError
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
name|pid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* 		**  CHILD 		**	Lock the control file to avoid duplicate deliveries. 		**		Then run the file as though we had just read it. 		**	We save an idea of the temporary name so we 		**		can recover on interrupt. 		*/
comment|/* Reset global flags */
name|RestartRequest
operator|=
name|NULL
expr_stmt|;
name|ShutdownRequest
operator|=
name|NULL
expr_stmt|;
name|PendingSignal
operator|=
literal|0
expr_stmt|;
comment|/* set basic modes, etc. */
operator|(
name|void
operator|)
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|clearstats
argument_list|()
expr_stmt|;
name|clearenvelope
argument_list|(
name|e
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_QUEUERUN
operator||
name|EF_GLOBALERRS
expr_stmt|;
name|set_delivery_mode
argument_list|(
name|SM_DELIVER
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_errormode
operator|=
name|EM_MAIL
expr_stmt|;
name|e
operator|->
name|e_id
operator|=
name|id
expr_stmt|;
name|e
operator|->
name|e_queuedir
operator|=
name|queuedir
expr_stmt|;
name|GrabTo
operator|=
name|UseErrorsTo
operator|=
name|FALSE
expr_stmt|;
name|ExitStat
operator|=
name|EX_OK
expr_stmt|;
if|if
condition|(
name|forkflag
condition|)
block|{
name|disconnect
argument_list|(
literal|1
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|OpMode
operator|=
name|MD_QUEUERUN
expr_stmt|;
block|}
name|sm_setproctitle
argument_list|(
name|TRUE
argument_list|,
name|e
argument_list|,
literal|"%s: from queue"
argument_list|,
name|qid_printname
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|76
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"dowork, pid=%d"
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* don't use the headers from sendmail.cf... */
name|e
operator|->
name|e_header
operator|=
name|NULL
expr_stmt|;
comment|/* read the queue control file -- return if locked */
if|if
condition|(
operator|!
name|readqf
argument_list|(
name|e
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|4
argument_list|)
operator|&&
name|e
operator|->
name|e_id
operator|!=
name|NULL
condition|)
name|dprintf
argument_list|(
literal|"readqf(%s) failed\n"
argument_list|,
name|qid_printname
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_id
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|forkflag
condition|)
name|finis
argument_list|(
name|FALSE
argument_list|,
name|EX_OK
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
name|e
operator|->
name|e_flags
operator||=
name|EF_INQUEUE
expr_stmt|;
name|eatheader
argument_list|(
name|e
argument_list|,
name|requeueflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|requeueflag
condition|)
name|queueup
argument_list|(
name|e
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* do the delivery */
name|sendall
argument_list|(
name|e
argument_list|,
name|SM_DELIVER
argument_list|)
expr_stmt|;
comment|/* finish up and exit */
if|if
condition|(
name|forkflag
condition|)
name|finis
argument_list|(
name|TRUE
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
else|else
name|dropenvelope
argument_list|(
name|e
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|e_id
operator|=
name|NULL
expr_stmt|;
return|return
name|pid
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  READQF -- read queue file and set up environment. ** **	Parameters: **		e -- the envelope of the job to run. ** **	Returns: **		TRUE if it successfully read the queue file. **		FALSE otherwise. ** **	Side Effects: **		The queue file is returned locked. */
end_comment

begin_function
specifier|static
name|bool
name|readqf
parameter_list|(
name|e
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|qfp
decl_stmt|;
name|ADDRESS
modifier|*
name|ctladdr
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|,
name|stf
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
name|int
name|qfver
init|=
literal|0
decl_stmt|;
name|long
name|hdrsize
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|orcpt
init|=
name|NULL
decl_stmt|;
name|bool
name|nomore
init|=
name|FALSE
decl_stmt|;
name|MODE_T
name|qsafe
decl_stmt|;
name|char
name|qf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
comment|/* 	**  Read and process the file. 	*/
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|qf
argument_list|,
name|queuename
argument_list|(
name|e
argument_list|,
literal|'q'
argument_list|)
argument_list|,
sizeof|sizeof
name|qf
argument_list|)
expr_stmt|;
name|qfp
operator|=
name|fopen
argument_list|(
name|qf
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qfp
operator|==
name|NULL
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|8
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"readqf(%s): fopen failure (%s)\n"
argument_list|,
name|qf
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|syserr
argument_list|(
literal|"readqf: no control file %s"
argument_list|,
name|qf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|lockfile
argument_list|(
name|fileno
argument_list|(
name|qfp
argument_list|)
argument_list|,
name|qf
argument_list|,
name|NULL
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
condition|)
block|{
comment|/* being processed by another queuer */
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"%s: locked\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|8
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"%s: locked\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|19
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"locked"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|qfp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* 	**  Prevent locking race condition. 	** 	**  Process A: readqf(): qfp = fopen(qffile) 	**  Process B: queueup(): rename(tf, qf) 	**  Process B: unlocks(tf) 	**  Process A: lockfile(qf); 	** 	**  Process A (us) has the old qf file (before the rename deleted 	**  the directory entry) and will be delivering based on old data. 	**  This can lead to multiple deliveries of the same recipients. 	** 	**  Catch this by checking if the underlying qf file has changed 	**  *after* acquiring our lock and if so, act as though the file 	**  was still locked (i.e., just return like the lockfile() case 	**  above. 	*/
if|if
condition|(
name|stat
argument_list|(
name|qf
argument_list|,
operator|&
name|stf
argument_list|)
operator|<
literal|0
operator|||
name|fstat
argument_list|(
name|fileno
argument_list|(
name|qfp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* must have been being processed by someone else */
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|8
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"readqf(%s): [f]stat failure (%s)\n"
argument_list|,
name|qf
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|qfp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|st
operator|.
name|st_nlink
operator|!=
name|stf
operator|.
name|st_nlink
operator|||
name|st
operator|.
name|st_dev
operator|!=
name|stf
operator|.
name|st_dev
operator|||
name|st
operator|.
name|st_ino
operator|!=
name|stf
operator|.
name|st_ino
operator|||
if|#
directive|if
name|HAS_ST_GEN
operator|&&
literal|0
comment|/* AFS returns garbage in st_gen */
name|st
operator|.
name|st_gen
operator|!=
name|stf
operator|.
name|st_gen
operator|||
endif|#
directive|endif
comment|/* HAS_ST_GEN&& 0 */
name|st
operator|.
name|st_uid
operator|!=
name|stf
operator|.
name|st_uid
operator|||
name|st
operator|.
name|st_gid
operator|!=
name|stf
operator|.
name|st_gid
operator|||
name|st
operator|.
name|st_size
operator|!=
name|stf
operator|.
name|st_size
condition|)
block|{
comment|/* changed after opened */
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"%s: changed\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|8
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"%s: changed\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|19
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"changed"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|qfp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* 	**  Check the queue file for plausibility to avoid attacks. 	*/
name|qsafe
operator|=
name|S_IWOTH
operator||
name|S_IWGRP
expr_stmt|;
if|#
directive|if
name|_FFR_QUEUE_FILE_MODE
if|if
condition|(
name|bitset
argument_list|(
name|S_IWGRP
argument_list|,
name|QueueFileMode
argument_list|)
condition|)
name|qsafe
operator|&=
operator|~
name|S_IWGRP
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_QUEUE_FILE_MODE */
if|if
condition|(
operator|(
name|st
operator|.
name|st_uid
operator|!=
name|geteuid
argument_list|()
operator|&&
name|st
operator|.
name|st_uid
operator|!=
name|TrustedUid
operator|&&
name|geteuid
argument_list|()
operator|!=
name|RealUid
operator|)
operator|||
name|bitset
argument_list|(
name|qsafe
argument_list|,
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|0
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_ALERT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"bogus queue file, uid=%d, mode=%o"
argument_list|,
name|st
operator|.
name|st_uid
argument_list|,
name|st
operator|.
name|st_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|8
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"readqf(%s): bogus file\n"
argument_list|,
name|qf
argument_list|)
expr_stmt|;
name|loseqfile
argument_list|(
name|e
argument_list|,
literal|"bogus file uid in mqueue"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|qfp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|st
operator|.
name|st_size
operator|==
literal|0
condition|)
block|{
comment|/* must be a bogus file -- if also old, just remove it */
if|if
condition|(
name|st
operator|.
name|st_ctime
operator|+
literal|10
operator|*
literal|60
operator|<
name|curtime
argument_list|()
condition|)
block|{
operator|(
name|void
operator|)
name|xunlink
argument_list|(
name|queuename
argument_list|(
name|e
argument_list|,
literal|'d'
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xunlink
argument_list|(
name|queuename
argument_list|(
name|e
argument_list|,
literal|'q'
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|qfp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|st
operator|.
name|st_nlink
operator|==
literal|0
condition|)
block|{
comment|/* 		**  Race condition -- we got a file just as it was being 		**  unlinked.  Just assume it is zero length. 		*/
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|qfp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* good file -- save this lock */
name|e
operator|->
name|e_lockfp
operator|=
name|qfp
expr_stmt|;
comment|/* do basic system initialization */
name|initsys
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'i'
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|LineNumber
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_GLOBALERRS
expr_stmt|;
name|OpMode
operator|=
name|MD_QUEUERUN
expr_stmt|;
name|ctladdr
operator|=
name|NULL
expr_stmt|;
name|e
operator|->
name|e_dfino
operator|=
operator|-
literal|1
expr_stmt|;
name|e
operator|->
name|e_msgsize
operator|=
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|_FFR_QUEUEDELAY
name|e
operator|->
name|e_queuealg
operator|=
name|QD_LINEAR
expr_stmt|;
name|e
operator|->
name|e_queuedelay
operator|=
operator|(
name|time_t
operator|)
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_QUEUEDELAY */
while|while
condition|(
operator|(
name|bp
operator|=
name|fgetfolded
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|qfp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|u_long
name|qflags
decl_stmt|;
name|ADDRESS
modifier|*
name|q
decl_stmt|;
name|int
name|mid
decl_stmt|;
name|time_t
name|now
decl_stmt|;
specifier|auto
name|char
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|4
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"+++++ %s\n"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nomore
condition|)
block|{
comment|/* hack attack */
name|syserr
argument_list|(
literal|"SECURITY ALERT: extra data in qf: %s"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|qfp
argument_list|)
expr_stmt|;
name|loseqfile
argument_list|(
name|e
argument_list|,
literal|"bogus queue line"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
switch|switch
condition|(
name|bp
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'V'
case|:
comment|/* queue file version number */
name|qfver
operator|=
name|atoi
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|qfver
operator|<=
name|QF_VERSION
condition|)
break|break;
name|syserr
argument_list|(
literal|"Version number in qf (%d) greater than max (%d)"
argument_list|,
name|qfver
argument_list|,
name|QF_VERSION
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|qfp
argument_list|)
expr_stmt|;
name|loseqfile
argument_list|(
name|e
argument_list|,
literal|"unsupported qf file version"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
case|case
literal|'C'
case|:
comment|/* specify controlling user */
name|ctladdr
operator|=
name|setctluser
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|,
name|qfver
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
comment|/* original recipient */
name|orcpt
operator|=
name|newstr
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* specify recipient */
name|p
operator|=
name|bp
expr_stmt|;
name|qflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|qfver
operator|>=
literal|1
condition|)
block|{
comment|/* get flag bits */
while|while
condition|(
operator|*
operator|++
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'N'
case|:
name|qflags
operator||=
name|QHASNOTIFY
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|qflags
operator||=
name|QPINGONSUCCESS
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|qflags
operator||=
name|QPINGONFAILURE
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|qflags
operator||=
name|QPINGONDELAY
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|qflags
operator||=
name|QPRIMARY
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
if|if
condition|(
name|ctladdr
operator|!=
name|NULL
condition|)
name|ctladdr
operator|->
name|q_flags
operator||=
name|QALIAS
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
name|qflags
operator||=
name|QPRIMARY
expr_stmt|;
name|q
operator|=
name|parseaddr
argument_list|(
operator|++
name|p
argument_list|,
name|NULLADDR
argument_list|,
name|RF_COPYALL
argument_list|,
literal|'\0'
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
block|{
name|q
operator|->
name|q_alias
operator|=
name|ctladdr
expr_stmt|;
if|if
condition|(
name|qfver
operator|>=
literal|1
condition|)
name|q
operator|->
name|q_flags
operator|&=
operator|~
name|Q_PINGFLAGS
expr_stmt|;
name|q
operator|->
name|q_flags
operator||=
name|qflags
expr_stmt|;
name|q
operator|->
name|q_orcpt
operator|=
name|orcpt
expr_stmt|;
operator|(
name|void
operator|)
name|recipient
argument_list|(
name|q
argument_list|,
operator|&
name|e
operator|->
name|e_sendqueue
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|orcpt
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* specify error recipient */
comment|/* no longer used */
break|break;
case|case
literal|'H'
case|:
comment|/* header */
operator|(
name|void
operator|)
name|chompheader
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|,
name|CHHDR_QUEUE
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|hdrsize
operator|+=
name|strlen
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* Solaris Content-Length: */
case|case
literal|'M'
case|:
comment|/* message */
comment|/* ignore this; we want a new message next time */
break|break;
case|case
literal|'S'
case|:
comment|/* sender */
name|setsender
argument_list|(
name|newstr
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|e
argument_list|,
name|NULL
argument_list|,
literal|'\0'
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* body type */
name|e
operator|->
name|e_bodytype
operator|=
name|newstr
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|_FFR_SAVE_CHARSET
case|case
literal|'X'
case|:
comment|/* character set */
name|e
operator|->
name|e_charset
operator|=
name|newstr
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* _FFR_SAVE_CHARSET */
case|case
literal|'D'
case|:
comment|/* data file name */
comment|/* obsolete -- ignore */
break|break;
case|case
literal|'T'
case|:
comment|/* init time */
name|e
operator|->
name|e_ctime
operator|=
name|atol
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* data file's inode number */
comment|/* regenerated below */
break|break;
case|case
literal|'K'
case|:
comment|/* time of last delivery attempt */
name|e
operator|->
name|e_dtime
operator|=
name|atol
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|_FFR_QUEUEDELAY
case|case
literal|'G'
case|:
comment|/* queue delay algorithm */
name|e
operator|->
name|e_queuealg
operator|=
name|atoi
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
comment|/* current delay */
name|e
operator|->
name|e_queuedelay
operator|=
operator|(
name|time_t
operator|)
name|atol
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* _FFR_QUEUEDELAY */
case|case
literal|'N'
case|:
comment|/* number of delivery attempts */
name|e
operator|->
name|e_ntries
operator|=
name|atoi
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* if this has been tried recently, let it be */
name|now
operator|=
name|curtime
argument_list|()
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_ntries
operator|>
literal|0
operator|&&
name|e
operator|->
name|e_dtime
operator|<=
name|now
operator|&&
name|now
operator|<
name|e
operator|->
name|e_dtime
operator|+
name|queuedelay
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|char
modifier|*
name|howlong
decl_stmt|;
name|howlong
operator|=
name|pintvl
argument_list|(
name|now
operator|-
name|e
operator|->
name|e_dtime
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"%s: too young (%s)\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|howlong
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|8
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"%s: too young (%s)\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|howlong
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|19
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"too young (%s)"
argument_list|,
name|howlong
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_id
operator|=
name|NULL
expr_stmt|;
name|unlockqueue
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|define
argument_list|(
name|macid
argument_list|(
literal|"{ntries}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|#
directive|if
name|NAMED_BIND
comment|/* adjust BIND parameters immediately */
if|if
condition|(
name|e
operator|->
name|e_ntries
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|retry
operator|=
name|TimeOuts
operator|.
name|res_retry
index|[
name|RES_TO_FIRST
index|]
expr_stmt|;
name|_res
operator|.
name|retrans
operator|=
name|TimeOuts
operator|.
name|res_retrans
index|[
name|RES_TO_FIRST
index|]
expr_stmt|;
block|}
else|else
block|{
name|_res
operator|.
name|retry
operator|=
name|TimeOuts
operator|.
name|res_retry
index|[
name|RES_TO_NORMAL
index|]
expr_stmt|;
name|_res
operator|.
name|retrans
operator|=
name|TimeOuts
operator|.
name|res_retrans
index|[
name|RES_TO_NORMAL
index|]
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NAMED_BIND */
break|break;
case|case
literal|'P'
case|:
comment|/* message priority */
name|e
operator|->
name|e_msgpriority
operator|=
name|atol
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
operator|+
name|WkTimeFact
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* flag bits */
if|if
condition|(
name|strncmp
argument_list|(
name|bp
argument_list|,
literal|"From "
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* we are being spoofed! */
name|syserr
argument_list|(
literal|"SECURITY ALERT: bogus qf line %s"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|qfp
argument_list|)
expr_stmt|;
name|loseqfile
argument_list|(
name|e
argument_list|,
literal|"bogus queue line"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
for|for
control|(
name|p
operator|=
operator|&
name|bp
index|[
literal|1
index|]
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'w'
case|:
comment|/* warning sent */
name|e
operator|->
name|e_flags
operator||=
name|EF_WARNING
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* response */
name|e
operator|->
name|e_flags
operator||=
name|EF_RESPONSE
expr_stmt|;
break|break;
case|case
literal|'8'
case|:
comment|/* has 8 bit data */
name|e
operator|->
name|e_flags
operator||=
name|EF_HAS8BIT
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* delete Bcc: header */
name|e
operator|->
name|e_flags
operator||=
name|EF_DELETE_BCC
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* envelope has DSN RET= */
name|e
operator|->
name|e_flags
operator||=
name|EF_RET_PARAM
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* don't return body */
name|e
operator|->
name|e_flags
operator||=
name|EF_NO_BODY_RETN
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
literal|'Z'
case|:
comment|/* original envelope id from ESMTP */
name|e
operator|->
name|e_envid
operator|=
name|newstr
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{dsn_envid}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
comment|/* AUTH= parameter */
name|e
operator|->
name|e_auth_param
operator|=
name|newstr
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
comment|/* define macro */
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|mid
operator|=
name|macid
argument_list|(
operator|&
name|bp
index|[
literal|1
index|]
argument_list|,
operator|&
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|==
literal|0
condition|)
break|break;
name|p
operator|=
name|newstr
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|define
argument_list|(
name|mid
argument_list|,
name|p
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* 				**  HACK ALERT: Unfortunately, 8.10 and 				**  8.11 reused the ${if_addr} and 				**  ${if_family} macros for both the incoming 				**  interface address/family (getrequests()) 				**  and the outgoing interface address/family 				**  (makeconnection()).  In order for D_BINDIF 				**  to work properly, have to preserve the 				**  incoming information in the queue file for 				**  later delivery attempts.  The original 				**  information is stored in the envelope 				**  in readqf() so it can be stored in 				**  queueup_macros().  This should be fixed 				**  in 8.12. 				*/
if|if
condition|(
name|strcmp
argument_list|(
name|macname
argument_list|(
name|mid
argument_list|)
argument_list|,
literal|"if_addr"
argument_list|)
operator|==
literal|0
condition|)
name|e
operator|->
name|e_if_macros
index|[
name|EIF_ADDR
index|]
operator|=
name|p
expr_stmt|;
block|}
break|break;
case|case
literal|'.'
case|:
comment|/* terminate file */
name|nomore
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
literal|"readqf: %s: line %d: bad line \"%s\""
argument_list|,
name|qf
argument_list|,
name|LineNumber
argument_list|,
name|shortenstring
argument_list|(
name|bp
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|qfp
argument_list|)
expr_stmt|;
name|loseqfile
argument_list|(
name|e
argument_list|,
literal|"unrecognized line"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|bp
operator|!=
name|buf
condition|)
name|sm_free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  If we haven't read any lines, this queue file is empty. 	**  Arrange to remove it without referencing any null pointers. 	*/
if|if
condition|(
name|LineNumber
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_CLRQUEUE
operator||
name|EF_FATALERRS
operator||
name|EF_RESPONSE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* possibly set ${dsn_ret} macro */
if|if
condition|(
name|bitset
argument_list|(
name|EF_RET_PARAM
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|EF_NO_BODY_RETN
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|define
argument_list|(
name|macid
argument_list|(
literal|"{dsn_ret}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"hdrs"
argument_list|,
name|e
argument_list|)
expr_stmt|;
else|else
name|define
argument_list|(
name|macid
argument_list|(
literal|"{dsn_ret}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"full"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Arrange to read the data file. 	*/
name|p
operator|=
name|queuename
argument_list|(
name|e
argument_list|,
literal|'d'
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_dfp
operator|=
name|fopen
argument_list|(
name|p
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"readqf: cannot open %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e
operator|->
name|e_flags
operator||=
name|EF_HAS_DF
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|e
operator|->
name|e_msgsize
operator|=
name|st
operator|.
name|st_size
operator|+
name|hdrsize
expr_stmt|;
name|e
operator|->
name|e_dfdev
operator|=
name|st
operator|.
name|st_dev
expr_stmt|;
name|e
operator|->
name|e_dfino
operator|=
name|st
operator|.
name|st_ino
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  PRTSTR -- print a string, "unprintable" characters are shown as \oct ** **	Parameters: **		s -- string to print **		ml -- maximum length of output ** **	Returns: **		none. ** **	Side Effects: **		Prints a string on stdout. */
end_comment

begin_function
specifier|static
name|void
name|prtstr
parameter_list|(
name|s
parameter_list|,
name|ml
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|ml
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
name|ml
operator|--
operator|>
literal|0
operator|&&
operator|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|ml
operator|--
operator|>
literal|0
condition|)
block|{
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isascii
argument_list|(
name|c
argument_list|)
operator|&&
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|ml
operator|-=
literal|3
operator|)
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"\\%03o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  PRINTQUEUE -- print out a representation of the mail queue ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		Prints a listing of the mail queue on the standard output. */
end_comment

begin_function
name|void
name|printqueue
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|nrequests
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NumQueues
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|StopRequest
condition|)
name|stop_sendmail
argument_list|()
expr_stmt|;
name|nrequests
operator|+=
name|print_single_queue
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NumQueues
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"\t\tTotal Requests: %d\n"
argument_list|,
name|nrequests
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  PRINT_SINGLE_QUEUE -- print out a representation of a single mail queue ** **	Parameters: **		queuedir -- queue directory ** **	Returns: **		number of entries ** **	Side Effects: **		Prints a listing of the mail queue on the standard output. */
end_comment

begin_function
specifier|static
name|int
name|print_single_queue
parameter_list|(
name|queuedir
parameter_list|)
name|int
name|queuedir
decl_stmt|;
block|{
specifier|register
name|WORK
modifier|*
name|w
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|nrequests
decl_stmt|;
name|char
name|qd
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|qddf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
if|if
condition|(
name|queuedir
operator|==
name|NOQDIR
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|qd
argument_list|,
literal|"."
argument_list|,
sizeof|sizeof
name|qd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|qddf
argument_list|,
literal|"."
argument_list|,
sizeof|sizeof
name|qddf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|qd
argument_list|,
sizeof|sizeof
name|qd
argument_list|,
literal|"%s%s"
argument_list|,
name|QPaths
index|[
name|queuedir
index|]
operator|.
name|qp_name
argument_list|,
operator|(
name|bitset
argument_list|(
name|QP_SUBQF
argument_list|,
name|QPaths
index|[
name|queuedir
index|]
operator|.
name|qp_subdirs
argument_list|)
condition|?
literal|"/qf"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|qddf
argument_list|,
sizeof|sizeof
name|qddf
argument_list|,
literal|"%s%s"
argument_list|,
name|QPaths
index|[
name|queuedir
index|]
operator|.
name|qp_name
argument_list|,
operator|(
name|bitset
argument_list|(
name|QP_SUBDF
argument_list|,
name|QPaths
index|[
name|queuedir
index|]
operator|.
name|qp_subdirs
argument_list|)
condition|?
literal|"/df"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Check for permission to print the queue 	*/
if|if
condition|(
name|bitset
argument_list|(
name|PRIV_RESTRICTMAILQ
argument_list|,
name|PrivacyFlags
argument_list|)
operator|&&
name|RealUid
operator|!=
literal|0
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
ifdef|#
directive|ifdef
name|NGROUPS_MAX
name|int
name|n
decl_stmt|;
specifier|extern
name|GIDSET_T
name|InitialGidSet
index|[
name|NGROUPS_MAX
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* NGROUPS_MAX */
if|if
condition|(
name|stat
argument_list|(
name|qd
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"Cannot stat %s"
argument_list|,
name|qid_printqueue
argument_list|(
name|queuedir
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|NGROUPS_MAX
name|n
operator|=
name|NGROUPS_MAX
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|InitialGidSet
index|[
name|n
index|]
operator|==
name|st
operator|.
name|st_gid
condition|)
break|break;
block|}
if|if
condition|(
name|n
operator|<
literal|0
operator|&&
name|RealGid
operator|!=
name|st
operator|.
name|st_gid
condition|)
else|#
directive|else
comment|/* NGROUPS_MAX */
if|if
condition|(
name|RealGid
operator|!=
name|st
operator|.
name|st_gid
condition|)
endif|#
directive|endif
comment|/* NGROUPS_MAX */
block|{
name|usrerr
argument_list|(
literal|"510 You are not permitted to see the queue"
argument_list|)
expr_stmt|;
name|setstat
argument_list|(
name|EX_NOPERM
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* 	**  Read and order the queue. 	*/
name|nrequests
operator|=
name|orderq
argument_list|(
name|queuedir
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 	**  Print the work list that we have read. 	*/
comment|/* first see if there is anything */
if|if
condition|(
name|nrequests
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s is empty\n"
argument_list|,
name|qid_printqueue
argument_list|(
name|queuedir
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|CurrentLA
operator|=
name|sm_getla
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* get load average */
name|printf
argument_list|(
literal|"\t\t%s (%d request%s"
argument_list|,
name|qid_printqueue
argument_list|(
name|queuedir
argument_list|)
argument_list|,
name|nrequests
argument_list|,
name|nrequests
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|MaxQueueRun
operator|>
literal|0
operator|&&
name|nrequests
operator|>
name|MaxQueueRun
condition|)
name|printf
argument_list|(
literal|", only %d printed"
argument_list|,
name|MaxQueueRun
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|")\n----Q-ID---- --Size-- -Priority- ---Q-Time--- ---------Sender/Recipient--------\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|")\n----Q-ID---- --Size-- -----Q-Time----- ------------Sender/Recipient------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|w
operator|=
name|WorkQ
init|;
name|w
operator|!=
name|NULL
condition|;
name|w
operator|=
name|w
operator|->
name|w_next
control|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
specifier|auto
name|time_t
name|submittime
init|=
literal|0
decl_stmt|;
name|long
name|dfsize
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|int
name|qfver
decl_stmt|;
name|char
name|statmsg
index|[
name|MAXLINE
index|]
decl_stmt|;
name|char
name|bodytype
index|[
name|MAXNAME
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|qf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
name|StopRequest
condition|)
name|stop_sendmail
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%12s"
argument_list|,
name|w
operator|->
name|w_name
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|qf
argument_list|,
sizeof|sizeof
name|qf
argument_list|,
literal|"%s/%s"
argument_list|,
name|qd
argument_list|,
name|w
operator|->
name|w_name
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|qf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|" (job completed)\n"
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|w
operator|->
name|w_name
index|[
literal|0
index|]
operator|=
literal|'d'
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|qf
argument_list|,
sizeof|sizeof
name|qf
argument_list|,
literal|"%s/%s"
argument_list|,
name|qddf
argument_list|,
name|w
operator|->
name|w_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|qf
argument_list|,
operator|&
name|st
argument_list|)
operator|>=
literal|0
condition|)
name|dfsize
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
else|else
name|dfsize
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|w_lock
condition|)
name|printf
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|w
operator|->
name|w_tooyoung
condition|)
name|printf
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|shouldqueue
argument_list|(
name|w
operator|->
name|w_pri
argument_list|,
name|w
operator|->
name|w_ctime
argument_list|)
condition|)
name|printf
argument_list|(
literal|"X"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|statmsg
index|[
literal|0
index|]
operator|=
name|bodytype
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|qfver
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|f
argument_list|)
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|StopRequest
condition|)
name|stop_sendmail
argument_list|()
expr_stmt|;
name|fixcrlf
argument_list|(
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'V'
case|:
comment|/* queue file version */
name|qfver
operator|=
name|atoi
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* error message */
if|if
condition|(
operator|(
name|i
operator|=
name|strlen
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
operator|)
operator|>=
sizeof|sizeof
name|statmsg
condition|)
name|i
operator|=
sizeof|sizeof
name|statmsg
operator|-
literal|1
expr_stmt|;
name|memmove
argument_list|(
name|statmsg
argument_list|,
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|statmsg
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* body type */
if|if
condition|(
operator|(
name|i
operator|=
name|strlen
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
operator|)
operator|>=
sizeof|sizeof
name|bodytype
condition|)
name|i
operator|=
sizeof|sizeof
name|bodytype
operator|-
literal|1
expr_stmt|;
name|memmove
argument_list|(
name|bodytype
argument_list|,
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bodytype
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* sender name */
if|if
condition|(
name|Verbose
condition|)
block|{
name|printf
argument_list|(
literal|"%8ld %10ld%c%.12s "
argument_list|,
name|dfsize
argument_list|,
name|w
operator|->
name|w_pri
argument_list|,
name|bitset
argument_list|(
name|EF_WARNING
argument_list|,
name|flags
argument_list|)
condition|?
literal|'+'
else|:
literal|' '
argument_list|,
name|ctime
argument_list|(
operator|&
name|submittime
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|prtstr
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
literal|78
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%8ld %.16s "
argument_list|,
name|dfsize
argument_list|,
name|ctime
argument_list|(
operator|&
name|submittime
argument_list|)
argument_list|)
expr_stmt|;
name|prtstr
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
literal|40
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|statmsg
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|||
name|bodytype
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"\n    %10.10s"
argument_list|,
name|bodytype
argument_list|)
expr_stmt|;
if|if
condition|(
name|statmsg
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|printf
argument_list|(
literal|"   (%.*s)"
argument_list|,
name|Verbose
condition|?
literal|100
else|:
literal|60
argument_list|,
name|statmsg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'C'
case|:
comment|/* controlling user */
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"\n\t\t\t\t      (---%.74s---)"
argument_list|,
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* recipient name */
name|p
operator|=
operator|&
name|buf
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|qfver
operator|>=
literal|1
condition|)
block|{
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
break|break;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Verbose
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t\t\t\t\t      "
argument_list|)
expr_stmt|;
name|prtstr
argument_list|(
name|p
argument_list|,
literal|73
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\n\t\t\t\t       "
argument_list|)
expr_stmt|;
name|prtstr
argument_list|(
name|p
argument_list|,
literal|40
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'T'
case|:
comment|/* creation time */
name|submittime
operator|=
name|atol
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* flag bits */
for|for
control|(
name|p
operator|=
operator|&
name|buf
index|[
literal|1
index|]
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'w'
case|:
name|flags
operator||=
name|EF_WARNING
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|submittime
operator|==
operator|(
name|time_t
operator|)
literal|0
condition|)
name|printf
argument_list|(
literal|" (no control file)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
return|return
name|nrequests
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  QUEUENAME -- build a file name in the queue directory for this envelope. ** **	Parameters: **		e -- envelope to build it in/from. **		type -- the file type, used as the first character **			of the file name. ** **	Returns: **		a pointer to the queue name (in a static buffer). ** **	Side Effects: **		If no id code is already assigned, queuename() will **		assign an id code with assign_queueid().  If no queue **		directory is assigned, one will be set with setnewqueue(). */
end_comment

begin_function
name|char
modifier|*
name|queuename
parameter_list|(
name|e
parameter_list|,
name|type
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|sub
init|=
literal|""
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
comment|/* Assign an ID if needed */
if|if
condition|(
name|e
operator|->
name|e_id
operator|==
name|NULL
condition|)
name|assign_queueid
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* Assign a queue directory if needed */
if|if
condition|(
name|e
operator|->
name|e_queuedir
operator|==
name|NOQDIR
condition|)
name|setnewqueue
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_queuedir
operator|==
name|NOQDIR
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"%cf%s"
argument_list|,
name|type
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'d'
case|:
if|if
condition|(
name|bitset
argument_list|(
name|QP_SUBDF
argument_list|,
name|QPaths
index|[
name|e
operator|->
name|e_queuedir
index|]
operator|.
name|qp_subdirs
argument_list|)
condition|)
name|sub
operator|=
literal|"/df"
expr_stmt|;
break|break;
case|case
name|TEMPQF_LETTER
case|:
case|case
literal|'t'
case|:
case|case
name|LOSEQF_LETTER
case|:
case|case
literal|'q'
case|:
if|if
condition|(
name|bitset
argument_list|(
name|QP_SUBQF
argument_list|,
name|QPaths
index|[
name|e
operator|->
name|e_queuedir
index|]
operator|.
name|qp_subdirs
argument_list|)
condition|)
name|sub
operator|=
literal|"/qf"
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
name|bitset
argument_list|(
name|QP_SUBXF
argument_list|,
name|QPaths
index|[
name|e
operator|->
name|e_queuedir
index|]
operator|.
name|qp_subdirs
argument_list|)
condition|)
name|sub
operator|=
literal|"/xf"
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"%s%s/%cf%s"
argument_list|,
name|QPaths
index|[
name|e
operator|->
name|e_queuedir
index|]
operator|.
name|qp_name
argument_list|,
name|sub
argument_list|,
name|type
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|7
argument_list|,
literal|2
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"queuename: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  ASSIGN_QUEUEID -- assign a queue ID for this envelope. ** **	Assigns an id code if one does not already exist. **	This code assumes that nothing will remain in the queue for **	longer than 60 years.  It is critical that files with the given **	name not already exist in the queue. **	Also initializes e_queuedir to NOQDIR. ** **	Parameters: **		e -- envelope to set it in. ** **	Returns: **		none. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|QueueIdChars
index|[]
init|=
literal|"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwx"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|QIC_LEN
value|60
end_define

begin_function
name|void
name|assign_queueid
parameter_list|(
name|e
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|pid_t
name|pid
init|=
name|getpid
argument_list|()
decl_stmt|;
specifier|static
name|char
name|cX
init|=
literal|0
decl_stmt|;
specifier|static
name|long
name|random_offset
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|char
name|idbuf
index|[
name|MAXQFNAME
operator|-
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|e_id
operator|!=
name|NULL
condition|)
return|return;
comment|/* see if we need to get a new base time/pid */
if|if
condition|(
name|cX
operator|>=
name|QIC_LEN
operator|||
name|LastQueueTime
operator|==
literal|0
operator|||
name|LastQueuePid
operator|!=
name|pid
condition|)
block|{
name|time_t
name|then
init|=
name|LastQueueTime
decl_stmt|;
comment|/* if the first time through, pick a random offset */
if|if
condition|(
name|LastQueueTime
operator|==
literal|0
condition|)
name|random_offset
operator|=
name|get_random
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|LastQueueTime
operator|=
name|curtime
argument_list|()
operator|)
operator|==
name|then
operator|&&
name|LastQueuePid
operator|==
name|pid
condition|)
block|{
operator|(
name|void
operator|)
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|LastQueuePid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|cX
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|7
argument_list|,
literal|50
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"assign_queueid: random_offset = %ld (%d)\n"
argument_list|,
name|random_offset
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cX
operator|+
name|random_offset
argument_list|)
operator|%
name|QIC_LEN
argument_list|)
expr_stmt|;
name|tm
operator|=
name|gmtime
argument_list|(
operator|&
name|LastQueueTime
argument_list|)
expr_stmt|;
name|idbuf
index|[
literal|0
index|]
operator|=
name|QueueIdChars
index|[
name|tm
operator|->
name|tm_year
operator|%
name|QIC_LEN
index|]
expr_stmt|;
name|idbuf
index|[
literal|1
index|]
operator|=
name|QueueIdChars
index|[
name|tm
operator|->
name|tm_mon
index|]
expr_stmt|;
name|idbuf
index|[
literal|2
index|]
operator|=
name|QueueIdChars
index|[
name|tm
operator|->
name|tm_mday
index|]
expr_stmt|;
name|idbuf
index|[
literal|3
index|]
operator|=
name|QueueIdChars
index|[
name|tm
operator|->
name|tm_hour
index|]
expr_stmt|;
name|idbuf
index|[
literal|4
index|]
operator|=
name|QueueIdChars
index|[
name|tm
operator|->
name|tm_min
index|]
expr_stmt|;
name|idbuf
index|[
literal|5
index|]
operator|=
name|QueueIdChars
index|[
name|tm
operator|->
name|tm_sec
index|]
expr_stmt|;
name|idbuf
index|[
literal|6
index|]
operator|=
name|QueueIdChars
index|[
operator|(
operator|(
name|int
operator|)
name|cX
operator|++
operator|+
name|random_offset
operator|)
operator|%
name|QIC_LEN
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
operator|&
name|idbuf
index|[
literal|7
index|]
argument_list|,
sizeof|sizeof
name|idbuf
operator|-
literal|7
argument_list|,
literal|"%05d"
argument_list|,
operator|(
name|int
operator|)
name|LastQueuePid
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_id
operator|=
name|newstr
argument_list|(
name|idbuf
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'i'
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_queuedir
operator|=
name|NOQDIR
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|7
argument_list|,
literal|1
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"assign_queueid: assigned id %s, e=%lx\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
operator|(
name|u_long
operator|)
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|93
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"assigned id"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  SYNC_QUEUE_TIME -- Assure exclusive PID in any given second ** **	Make sure one PID can't be used by two processes in any one second. ** **		If the system rotates PIDs fast enough, may get the **		same pid in the same second for two distinct processes. **		This will interfere with the queue file naming system. ** **	Parameters: **		none ** **	Returns: **		none */
end_comment

begin_function
name|void
name|sync_queue_time
parameter_list|()
block|{
if|#
directive|if
name|FAST_PID_RECYCLE
if|if
condition|(
name|OpMode
operator|!=
name|MD_TEST
operator|&&
name|OpMode
operator|!=
name|MD_VERIFY
operator|&&
name|LastQueueTime
operator|>
literal|0
operator|&&
name|LastQueuePid
operator|==
name|getpid
argument_list|()
operator|&&
name|curtime
argument_list|()
operator|==
name|LastQueueTime
condition|)
operator|(
name|void
operator|)
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FAST_PID_RECYCLE */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  UNLOCKQUEUE -- unlock the queue entry for a specified envelope ** **	Parameters: **		e -- the envelope to unlock. ** **	Returns: **		none ** **	Side Effects: **		unlocks the queue for `e'. */
end_comment

begin_function
name|void
name|unlockqueue
parameter_list|(
name|e
parameter_list|)
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|51
argument_list|,
literal|4
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"unlockqueue(%s)\n"
argument_list|,
name|e
operator|->
name|e_id
operator|==
name|NULL
condition|?
literal|"NOQUEUE"
else|:
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
comment|/* if there is a lock file in the envelope, close it */
if|if
condition|(
name|e
operator|->
name|e_lockfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
operator|->
name|e_lockfp
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_lockfp
operator|=
name|NULL
expr_stmt|;
comment|/* don't create a queue id if we don't already have one */
if|if
condition|(
name|e
operator|->
name|e_id
operator|==
name|NULL
condition|)
return|return;
comment|/* remove the transcript */
if|if
condition|(
name|LogLevel
operator|>
literal|87
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"unlock"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tTd
argument_list|(
literal|51
argument_list|,
literal|104
argument_list|)
condition|)
name|xunlink
argument_list|(
name|queuename
argument_list|(
name|e
argument_list|,
literal|'x'
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  SETCTLUSER -- create a controlling address ** **	Create a fake "address" given only a local login name; this is **	used as a "controlling user" for future recipient addresses. ** **	Parameters: **		user -- the user name of the controlling user. **		qfver -- the version stamp of this qf file. ** **	Returns: **		An address descriptor for the controlling user. ** **	Side Effects: **		none. */
end_comment

begin_function
specifier|static
name|ADDRESS
modifier|*
name|setctluser
parameter_list|(
name|user
parameter_list|,
name|qfver
parameter_list|)
name|char
modifier|*
name|user
decl_stmt|;
name|int
name|qfver
decl_stmt|;
block|{
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 	**  See if this clears our concept of controlling user. 	*/
if|if
condition|(
name|user
operator|==
name|NULL
operator|||
operator|*
name|user
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
comment|/* 	**  Set up addr fields for controlling user. 	*/
name|a
operator|=
operator|(
name|ADDRESS
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|a
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
expr|*
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|user
operator|==
literal|'\0'
condition|)
block|{
name|p
operator|=
name|NULL
expr_stmt|;
name|a
operator|->
name|q_user
operator|=
name|newstr
argument_list|(
name|DefUser
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|user
operator|==
literal|':'
condition|)
block|{
name|p
operator|=
operator|&
name|user
index|[
literal|1
index|]
expr_stmt|;
name|a
operator|->
name|q_user
operator|=
name|newstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|strtok
argument_list|(
name|user
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_user
operator|=
name|newstr
argument_list|(
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|qfver
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|a
operator|->
name|q_uid
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|a
operator|->
name|q_gid
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|o
decl_stmt|;
name|a
operator|->
name|q_flags
operator||=
name|QGOODUID
expr_stmt|;
comment|/* if there is another ':': restore it */
if|if
condition|(
operator|(
name|o
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|o
operator|>
name|p
condition|)
name|o
index|[
operator|-
literal|1
index|]
operator|=
literal|':'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|pw
operator|=
name|sm_getpwnam
argument_list|(
name|user
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|pw
operator|->
name|pw_dir
operator|==
literal|'\0'
condition|)
name|a
operator|->
name|q_home
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
condition|)
name|a
operator|->
name|q_home
operator|=
literal|""
expr_stmt|;
else|else
name|a
operator|->
name|q_home
operator|=
name|newstr
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_uid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
name|a
operator|->
name|q_gid
operator|=
name|pw
operator|->
name|pw_gid
expr_stmt|;
name|a
operator|->
name|q_flags
operator||=
name|QGOODUID
expr_stmt|;
block|}
block|}
name|a
operator|->
name|q_flags
operator||=
name|QPRIMARY
expr_stmt|;
comment|/* flag as a "ctladdr" */
name|a
operator|->
name|q_mailer
operator|=
name|LocalMailer
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|a
operator|->
name|q_paddr
operator|=
name|newstr
argument_list|(
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
else|else
name|a
operator|->
name|q_paddr
operator|=
name|newstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  LOSEQFILE -- save the qf as Qf and try to let someone know ** **	Parameters: **		e -- the envelope (e->e_id will be used). **		why -- reported to whomever can hear. ** **	Returns: **		none. */
end_comment

begin_function
name|void
name|loseqfile
parameter_list|(
name|e
parameter_list|,
name|why
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|why
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
operator|||
name|e
operator|->
name|e_id
operator|==
name|NULL
condition|)
return|return;
name|p
operator|=
name|queuename
argument_list|(
name|e
argument_list|,
literal|'q'
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|>=
operator|(
name|SIZE_T
operator|)
sizeof|sizeof
name|buf
condition|)
return|return;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|p
operator|=
name|queuename
argument_list|(
name|e
argument_list|,
name|LOSEQF_LETTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|buf
argument_list|,
name|p
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"cannot rename(%s, %s), uid=%d"
argument_list|,
name|buf
argument_list|,
name|p
argument_list|,
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|LogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ALERT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Losing %s: %s"
argument_list|,
name|buf
argument_list|,
name|why
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  QID_PRINTNAME -- create externally printable version of queue id ** **	Parameters: **		e -- the envelope. ** **	Returns: **		a printable version */
end_comment

begin_function
name|char
modifier|*
name|qid_printname
parameter_list|(
name|e
parameter_list|)
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|char
modifier|*
name|id
decl_stmt|;
specifier|static
name|char
name|idbuf
index|[
name|MAXQFNAME
operator|+
literal|34
index|]
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
return|return
literal|""
return|;
if|if
condition|(
name|e
operator|->
name|e_id
operator|==
name|NULL
condition|)
name|id
operator|=
literal|""
expr_stmt|;
else|else
name|id
operator|=
name|e
operator|->
name|e_id
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_queuedir
operator|==
name|NOQDIR
condition|)
return|return
name|id
return|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|idbuf
argument_list|,
sizeof|sizeof
name|idbuf
argument_list|,
literal|"%.32s/%s"
argument_list|,
name|QPaths
index|[
name|e
operator|->
name|e_queuedir
index|]
operator|.
name|qp_name
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|idbuf
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  QID_PRINTQUEUE -- create full version of queue directory for df files ** **	Parameters: **		queuedir -- the short version of the queue directory ** **	Returns: **		the full pathname to the queue (static) */
end_comment

begin_function
name|char
modifier|*
name|qid_printqueue
parameter_list|(
name|queuedir
parameter_list|)
name|int
name|queuedir
decl_stmt|;
block|{
name|char
modifier|*
name|subdir
decl_stmt|;
specifier|static
name|char
name|dir
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
name|queuedir
operator|==
name|NOQDIR
condition|)
return|return
name|QueueDir
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|QPaths
index|[
name|queuedir
index|]
operator|.
name|qp_name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
name|subdir
operator|=
name|NULL
expr_stmt|;
else|else
name|subdir
operator|=
name|QPaths
index|[
name|queuedir
index|]
operator|.
name|qp_name
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|dir
argument_list|,
sizeof|sizeof
name|dir
argument_list|,
literal|"%s%s%s%s"
argument_list|,
name|QueueDir
argument_list|,
name|subdir
operator|==
name|NULL
condition|?
literal|""
else|:
literal|"/"
argument_list|,
name|subdir
operator|==
name|NULL
condition|?
literal|""
else|:
name|subdir
argument_list|,
operator|(
name|bitset
argument_list|(
name|QP_SUBDF
argument_list|,
name|QPaths
index|[
name|queuedir
index|]
operator|.
name|qp_subdirs
argument_list|)
condition|?
literal|"/df"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
return|return
name|dir
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  SETNEWQUEUE -- Sets a new queue directory ** **	Assign a queue directory to an envelope and store the directory **	in e->e_queuedir.  The queue is chosen at random. ** **	This routine may be improved in the future to allow for more **	elaborate queueing schemes.  Suggestions and code contributions **	are welcome. ** **	Parameters: **		e -- envelope to assign a queue for. ** **	Returns: **		none. */
end_comment

begin_function
name|void
name|setnewqueue
parameter_list|(
name|e
parameter_list|)
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|idx
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|20
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"setnewqueue: called\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_queuedir
operator|!=
name|NOQDIR
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|20
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"setnewqueue: e_queuedir already assigned (%s)\n"
argument_list|,
name|qid_printqueue
argument_list|(
name|e
operator|->
name|e_queuedir
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|NumQueues
operator|<=
literal|1
condition|)
name|idx
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|#
directive|if
name|RANDOMSHIFT
comment|/* lower bits are not random "enough", select others */
name|idx
operator|=
operator|(
name|get_random
argument_list|()
operator|>>
name|RANDOMSHIFT
operator|)
operator|%
name|NumQueues
expr_stmt|;
else|#
directive|else
comment|/* RANDOMSHIFT */
name|idx
operator|=
name|get_random
argument_list|()
operator|%
name|NumQueues
expr_stmt|;
endif|#
directive|endif
comment|/* RANDOMSHIFT */
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|15
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"setnewqueue: get_random() %% %d = %d\n"
argument_list|,
name|NumQueues
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|e_queuedir
operator|=
name|idx
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|3
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"setnewqueue: Assigned queue directory %s\n"
argument_list|,
name|qid_printqueue
argument_list|(
name|e
operator|->
name|e_queuedir
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  CHKQDIR -- check a queue directory ** **	Parameters: **		name -- name of queue directory **		sff -- flags for safefile() ** **	Returns: **		is it a queue directory? */
end_comment

begin_function
specifier|static
name|bool
name|chkqdir
parameter_list|(
name|name
parameter_list|,
name|sff
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|long
name|sff
decl_stmt|;
block|{
name|struct
name|stat
name|statb
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* skip over . and .. directories */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|)
condition|)
return|return
name|FALSE
return|;
if|#
directive|if
name|HASLSTAT
if|if
condition|(
name|lstat
argument_list|(
name|name
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
comment|/* HASLSTAT */
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
comment|/* HASLSTAT */
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|2
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"multiqueue_cache: stat(\"%s\"): %s\n"
argument_list|,
name|name
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|#
directive|if
name|HASLSTAT
if|if
condition|(
name|S_ISLNK
argument_list|(
name|statb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* 		**  For a symlink we need to make sure the 		**  target is a directory 		*/
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|2
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"multiqueue_cache: stat(\"%s\"): %s\n"
argument_list|,
name|name
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
endif|#
directive|endif
comment|/* HASLSTAT */
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|statb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|2
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"multiqueue_cache: \"%s\": Not a directory\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Print a warning if unsafe (but still use it) */
name|i
operator|=
name|safedirpath
argument_list|(
name|name
argument_list|,
name|RunAsUid
argument_list|,
name|RunAsGid
argument_list|,
name|NULL
argument_list|,
name|sff
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
name|tTd
argument_list|(
literal|41
argument_list|,
literal|2
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"multiqueue_cache: \"%s\": Not safe: %s\n"
argument_list|,
name|name
argument_list|,
name|errstring
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  MULTIQUEUE_CACHE -- cache a list of paths to queues. ** **	Each potential queue is checked as the cache is built. **	Thereafter, each is blindly trusted. **	Note that we can be called again after a timeout to rebuild **	(although code for that is not ready yet). ** **	Parameters: **		none ** **	Returns: **		none */
end_comment

begin_function
name|void
name|multiqueue_cache
parameter_list|()
block|{
specifier|register
name|DIR
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|dirent
modifier|*
name|d
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|int
name|slotsleft
init|=
literal|0
decl_stmt|;
name|long
name|sff
init|=
name|SFF_ANYFILE
decl_stmt|;
name|char
name|qpath
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|subdir
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|20
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"multiqueue_cache: called\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NumQueues
operator|!=
literal|0
operator|&&
name|QPaths
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NumQueues
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|QPaths
index|[
name|i
index|]
operator|.
name|qp_name
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|QPaths
index|[
name|i
index|]
operator|.
name|qp_name
argument_list|)
expr_stmt|;
block|}
name|sm_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|QPaths
argument_list|)
expr_stmt|;
name|QPaths
operator|=
name|NULL
expr_stmt|;
name|NumQueues
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If running as root, allow safedirpath() checks to use privs */
if|if
condition|(
name|RunAsUid
operator|==
literal|0
condition|)
name|sff
operator||=
name|SFF_ROOTOK
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|qpath
argument_list|,
sizeof|sizeof
name|qpath
argument_list|,
literal|"%s"
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|qpath
argument_list|)
operator|-
literal|1
expr_stmt|;
name|cp
operator|=
operator|&
name|qpath
index|[
name|len
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'*'
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|qpath
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"QueueDirectory: can not wildcard relative path"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|2
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"multiqueue_cache: \"%s\": Can not wildcard relative path.\n"
argument_list|,
name|qpath
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_CONFIG
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cp
operator|==
name|qpath
condition|)
block|{
comment|/* 			**  Special case of top level wildcard, like /foo* 			*/
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|qpath
operator|+
literal|1
argument_list|,
sizeof|sizeof
name|qpath
operator|-
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|qpath
argument_list|)
expr_stmt|;
operator|++
name|cp
expr_stmt|;
block|}
operator|*
operator|(
name|cp
operator|++
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|2
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"multiqueue_cache: prefix=\"%s\"\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|QueueDir
operator|=
name|newstr
argument_list|(
name|qpath
argument_list|)
expr_stmt|;
comment|/* 		**  XXX Should probably wrap this whole loop in a timeout 		**  in case some wag decides to NFS mount the queues. 		*/
comment|/* test path to get warning messages */
name|i
operator|=
name|safedirpath
argument_list|(
name|QueueDir
argument_list|,
name|RunAsUid
argument_list|,
name|RunAsGid
argument_list|,
name|NULL
argument_list|,
name|sff
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
name|tTd
argument_list|(
literal|41
argument_list|,
literal|2
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"multiqueue_cache: \"%s\": Not safe: %s\n"
argument_list|,
name|QueueDir
argument_list|,
name|errstring
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|QueueDir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"can not chdir(%s)"
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|2
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"multiqueue_cache: \"%s\": %s\n"
argument_list|,
name|qpath
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_CONFIG
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|dp
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"can not opendir(%s)"
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|2
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"multiqueue_cache: opendir(\"%s\"): %s\n"
argument_list|,
name|QueueDir
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_CONFIG
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|d
operator|=
name|readdir
argument_list|(
name|dp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|d
operator|->
name|d_name
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|5
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"multiqueue_cache: \"%s\", skipped\n"
argument_list|,
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|chkqdir
argument_list|(
name|d
operator|->
name|d_name
argument_list|,
name|sff
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|QPaths
operator|==
name|NULL
condition|)
block|{
name|slotsleft
operator|=
literal|20
expr_stmt|;
name|QPaths
operator|=
operator|(
name|QPATHS
operator|*
operator|)
name|xalloc
argument_list|(
operator|(
sizeof|sizeof
expr|*
name|QPaths
operator|)
operator|*
name|slotsleft
argument_list|)
expr_stmt|;
name|NumQueues
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|slotsleft
operator|<
literal|1
condition|)
block|{
name|QPaths
operator|=
operator|(
name|QPATHS
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|QPaths
argument_list|,
operator|(
sizeof|sizeof
expr|*
name|QPaths
operator|)
operator|*
operator|(
name|NumQueues
operator|+
literal|10
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|QPaths
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return;
block|}
name|slotsleft
operator|+=
literal|10
expr_stmt|;
block|}
comment|/* check subdirs */
name|QPaths
index|[
name|NumQueues
index|]
operator|.
name|qp_subdirs
operator|=
name|QP_NOSUB
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|subdir
argument_list|,
sizeof|sizeof
name|subdir
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|qpath
argument_list|,
name|d
operator|->
name|d_name
argument_list|,
literal|"qf"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chkqdir
argument_list|(
name|subdir
argument_list|,
name|sff
argument_list|)
condition|)
name|QPaths
index|[
name|NumQueues
index|]
operator|.
name|qp_subdirs
operator||=
name|QP_SUBQF
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|subdir
argument_list|,
sizeof|sizeof
name|subdir
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|qpath
argument_list|,
name|d
operator|->
name|d_name
argument_list|,
literal|"df"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chkqdir
argument_list|(
name|subdir
argument_list|,
name|sff
argument_list|)
condition|)
name|QPaths
index|[
name|NumQueues
index|]
operator|.
name|qp_subdirs
operator||=
name|QP_SUBDF
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|subdir
argument_list|,
sizeof|sizeof
name|subdir
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|qpath
argument_list|,
name|d
operator|->
name|d_name
argument_list|,
literal|"xf"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chkqdir
argument_list|(
name|subdir
argument_list|,
name|sff
argument_list|)
condition|)
name|QPaths
index|[
name|NumQueues
index|]
operator|.
name|qp_subdirs
operator||=
name|QP_SUBXF
expr_stmt|;
comment|/* assert(strlen(d->d_name)< MAXPATHLEN - 14) */
comment|/* maybe even - 17 (subdirs) */
name|QPaths
index|[
name|NumQueues
index|]
operator|.
name|qp_name
operator|=
name|newstr
argument_list|(
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|2
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"multiqueue_cache: %d: \"%s\" cached (%x).\n"
argument_list|,
name|NumQueues
argument_list|,
name|d
operator|->
name|d_name
argument_list|,
name|QPaths
index|[
name|NumQueues
index|]
operator|.
name|qp_subdirs
argument_list|)
expr_stmt|;
name|NumQueues
operator|++
expr_stmt|;
name|slotsleft
operator|--
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NumQueues
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'*'
operator|&&
name|tTd
argument_list|(
literal|41
argument_list|,
literal|2
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"multiqueue_cache: \"%s\": No wildcard suffix character\n"
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
name|QPaths
operator|=
operator|(
name|QPATHS
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|QPaths
argument_list|)
expr_stmt|;
name|QPaths
index|[
literal|0
index|]
operator|.
name|qp_name
operator|=
name|newstr
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|QPaths
index|[
literal|0
index|]
operator|.
name|qp_subdirs
operator|=
name|QP_NOSUB
expr_stmt|;
name|NumQueues
operator|=
literal|1
expr_stmt|;
comment|/* test path to get warning messages */
operator|(
name|void
operator|)
name|safedirpath
argument_list|(
name|QueueDir
argument_list|,
name|RunAsUid
argument_list|,
name|RunAsGid
argument_list|,
name|NULL
argument_list|,
name|sff
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|QueueDir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"can not chdir(%s)"
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|41
argument_list|,
literal|2
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"multiqueue_cache: \"%s\": %s\n"
argument_list|,
name|QueueDir
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_CONFIG
expr_stmt|;
block|}
comment|/* check subdirs */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|subdir
argument_list|,
sizeof|sizeof
name|subdir
argument_list|,
literal|"%s/qf"
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
if|if
condition|(
name|chkqdir
argument_list|(
name|subdir
argument_list|,
name|sff
argument_list|)
condition|)
name|QPaths
index|[
literal|0
index|]
operator|.
name|qp_subdirs
operator||=
name|QP_SUBQF
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|subdir
argument_list|,
sizeof|sizeof
name|subdir
argument_list|,
literal|"%s/df"
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
if|if
condition|(
name|chkqdir
argument_list|(
name|subdir
argument_list|,
name|sff
argument_list|)
condition|)
name|QPaths
index|[
literal|0
index|]
operator|.
name|qp_subdirs
operator||=
name|QP_SUBDF
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|subdir
argument_list|,
sizeof|sizeof
name|subdir
argument_list|,
literal|"%s/xf"
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
if|if
condition|(
name|chkqdir
argument_list|(
name|subdir
argument_list|,
name|sff
argument_list|)
condition|)
name|QPaths
index|[
literal|0
index|]
operator|.
name|qp_subdirs
operator||=
name|QP_SUBXF
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_escape
end_escape

begin_comment
comment|/* **  HASHFQN -- calculate a hash value for a fully qualified host name ** **	Arguments: **		fqn -- an all lower-case host.domain string **		buckets -- the number of buckets (queue directories) ** **	Returns: **		a bucket number (signed integer) **		-1 on error ** **	Contributed by Exactis.com, Inc. */
end_comment

begin_define
unit|int hashfqn(fqn, buckets) 	register char *fqn; 	int buckets; { 	register char *p; 	register int h = 0, hash, cnt;
define|#
directive|define
name|WATERINC
value|(1000)
end_define

begin_comment
unit|if (fqn == NULL) 		return -1;
comment|/* 	**  A variation on the gdb hash 	**  This is the best as of Feb 19, 1996 --bcx 	*/
end_comment

begin_endif
unit|p = fqn; 	h = 0x238F13AF * strlen(p); 	for (cnt = 0; *p != 0; ++p, cnt++) 	{ 		h = (h + (*p<< (cnt * 5 % 24)))& 0x7FFFFFFF; 	} 	h = (1103515243 * h + 12345)& 0x7FFFFFFF; 	if (buckets< 2) 		hash = 0; 	else 		hash = (h % buckets);  	return hash; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_if
if|#
directive|if
name|_FFR_QUEUEDELAY
end_if

begin_escape
end_escape

begin_comment
comment|/* **  QUEUEDELAY -- compute queue delay time ** **	Parameters: **		e -- the envelope to queue up. ** **	Returns: **		queue delay time ** **	Side Effects: **		may change e_queuedelay */
end_comment

begin_function
specifier|static
name|time_t
name|queuedelay
parameter_list|(
name|e
parameter_list|)
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|time_t
name|qd
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|e_queuealg
operator|==
name|QD_EXP
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|e_queuedelay
operator|==
literal|0
condition|)
name|e
operator|->
name|e_queuedelay
operator|=
name|QueueInitDelay
expr_stmt|;
else|else
block|{
name|e
operator|->
name|e_queuedelay
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_queuedelay
operator|>
name|QueueMaxDelay
condition|)
name|e
operator|->
name|e_queuedelay
operator|=
name|QueueMaxDelay
expr_stmt|;
block|}
name|qd
operator|=
name|e
operator|->
name|e_queuedelay
expr_stmt|;
block|}
else|else
name|qd
operator|=
name|MinQueueAge
expr_stmt|;
return|return
name|qd
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_QUEUEDELAY */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* QUEUE */
end_comment

end_unit

