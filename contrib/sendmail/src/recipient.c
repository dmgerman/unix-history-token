begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998-2003, 2006 Sendmail, Inc. and its suppliers.  *	All rights reserved.  * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_include
include|#
directive|include
file|<sendmail.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: recipient.c,v 8.348 2007/03/19 21:33:09 ca Exp $"
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|void
name|includetimeout
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ADDRESS
modifier|*
name|self_reference
name|__P
argument_list|(
operator|(
name|ADDRESS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sortexpensive
name|__P
argument_list|(
operator|(
name|ADDRESS
operator|*
operator|,
name|ADDRESS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sortbysignature
name|__P
argument_list|(
operator|(
name|ADDRESS
operator|*
operator|,
name|ADDRESS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sorthost
name|__P
argument_list|(
operator|(
name|ADDRESS
operator|*
operator|,
name|ADDRESS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|int
name|sortfn_t
name|__P
typedef|((
name|ADDRESS
modifier|*
typedef|,
name|ADDRESS
modifier|*
typedef|));
end_typedef

begin_comment
comment|/* **  SORTHOST -- strcmp()-like func for host portion of an ADDRESS ** **	Parameters: **		xx -- first ADDRESS **		yy -- second ADDRESS ** **	Returns: **<0 when xx->q_host is less than yy->q_host **>0 when xx->q_host is greater than yy->q_host **		0 when equal */
end_comment

begin_function
specifier|static
name|int
name|sorthost
parameter_list|(
name|xx
parameter_list|,
name|yy
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|xx
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|yy
decl_stmt|;
block|{
if|#
directive|if
name|_FFR_HOST_SORT_REVERSE
comment|/* XXX maybe compare hostnames from the end? */
return|return
name|sm_strrevcasecmp
argument_list|(
name|xx
operator|->
name|q_host
argument_list|,
name|yy
operator|->
name|q_host
argument_list|)
return|;
else|#
directive|else
comment|/* _FFR_HOST_SORT_REVERSE */
return|return
name|sm_strcasecmp
argument_list|(
name|xx
operator|->
name|q_host
argument_list|,
name|yy
operator|->
name|q_host
argument_list|)
return|;
endif|#
directive|endif
comment|/* _FFR_HOST_SORT_REVERSE */
block|}
end_function

begin_comment
comment|/* **  SORTEXPENSIVE -- strcmp()-like func for expensive mailers ** **  The mailer has been noted already as "expensive" for 'xx'. This **  will give a result relative to 'yy'. Expensive mailers get rated **  "greater than" non-expensive mailers because during the delivery phase **  it will get queued -- no use it getting in the way of less expensive **  recipients. We avoid an MX RR lookup when both 'xx' and 'yy' are **  expensive since an MX RR lookup happens when extracted from the queue **  later. ** **	Parameters: **		xx -- first ADDRESS **		yy -- second ADDRESS ** **	Returns: **<0 when xx->q_host is less than yy->q_host and both are **			expensive **>0 when xx->q_host is greater than yy->q_host, or when **			'yy' is non-expensive **		0 when equal (by expense and q_host) */
end_comment

begin_function
specifier|static
name|int
name|sortexpensive
parameter_list|(
name|xx
parameter_list|,
name|yy
parameter_list|)
name|ADDRESS
modifier|*
name|xx
decl_stmt|;
name|ADDRESS
modifier|*
name|yy
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|M_EXPENSIVE
argument_list|,
name|yy
operator|->
name|q_mailer
operator|->
name|m_flags
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* xx should go later */
if|#
directive|if
name|_FFR_HOST_SORT_REVERSE
comment|/* XXX maybe compare hostnames from the end? */
return|return
name|sm_strrevcasecmp
argument_list|(
name|xx
operator|->
name|q_host
argument_list|,
name|yy
operator|->
name|q_host
argument_list|)
return|;
else|#
directive|else
comment|/* _FFR_HOST_SORT_REVERSE */
return|return
name|sm_strcasecmp
argument_list|(
name|xx
operator|->
name|q_host
argument_list|,
name|yy
operator|->
name|q_host
argument_list|)
return|;
endif|#
directive|endif
comment|/* _FFR_HOST_SORT_REVERSE */
block|}
end_function

begin_comment
comment|/* **  SORTBYSIGNATURE -- a strcmp()-like func for q_mailer and q_host in ADDRESS ** **	Parameters: **		xx -- first ADDRESS **		yy -- second ADDRESS ** **	Returns: **		0 when the "signature"'s are same **<0 when xx->q_signature is less than yy->q_signature **>0 when xx->q_signature is greater than yy->q_signature ** **	Side Effect: **		May set ADDRESS pointer for q_signature if not already set. */
end_comment

begin_function
specifier|static
name|int
name|sortbysignature
parameter_list|(
name|xx
parameter_list|,
name|yy
parameter_list|)
name|ADDRESS
modifier|*
name|xx
decl_stmt|;
name|ADDRESS
modifier|*
name|yy
decl_stmt|;
block|{
specifier|register
name|int
name|ret
decl_stmt|;
comment|/* Let's avoid redoing the signature over and over again */
if|if
condition|(
name|xx
operator|->
name|q_signature
operator|==
name|NULL
condition|)
name|xx
operator|->
name|q_signature
operator|=
name|hostsignature
argument_list|(
name|xx
operator|->
name|q_mailer
argument_list|,
name|xx
operator|->
name|q_host
argument_list|)
expr_stmt|;
if|if
condition|(
name|yy
operator|->
name|q_signature
operator|==
name|NULL
condition|)
name|yy
operator|->
name|q_signature
operator|=
name|hostsignature
argument_list|(
name|yy
operator|->
name|q_mailer
argument_list|,
name|yy
operator|->
name|q_host
argument_list|)
expr_stmt|;
name|ret
operator|=
name|strcmp
argument_list|(
name|xx
operator|->
name|q_signature
argument_list|,
name|yy
operator|->
name|q_signature
argument_list|)
expr_stmt|;
comment|/* 	**  If the two signatures are the same then we will return a sort 	**  value based on 'q_user'. But note that we have reversed xx and yy 	**  on purpose. This additional compare helps reduce the number of 	**  sameaddr() calls and loops in recipient() for the case when 	**  the rcpt list has been provided already in-order. 	*/
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
return|return
name|strcmp
argument_list|(
name|yy
operator|->
name|q_user
argument_list|,
name|xx
operator|->
name|q_user
argument_list|)
return|;
else|else
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* **  SENDTOLIST -- Designate a send list. ** **	The parameter is a comma-separated list of people to send to. **	This routine arranges to send to all of them. ** **	Parameters: **		list -- the send list. **		ctladdr -- the address template for the person to **			send to -- effective uid/gid are important. **			This is typically the alias that caused this **			expansion. **		sendq -- a pointer to the head of a queue to put **			these people into. **		aliaslevel -- the current alias nesting depth -- to **			diagnose loops. **		e -- the envelope in which to add these recipients. ** **	Returns: **		The number of addresses actually on the list. */
end_comment

begin_comment
comment|/* q_flags bits inherited from ctladdr */
end_comment

begin_define
define|#
directive|define
name|QINHERITEDBITS
value|(QPINGONSUCCESS|QPINGONFAILURE|QPINGONDELAY|QHASNOTIFY)
end_define

begin_function
name|int
name|sendtolist
parameter_list|(
name|list
parameter_list|,
name|ctladdr
parameter_list|,
name|sendq
parameter_list|,
name|aliaslevel
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|list
decl_stmt|;
name|ADDRESS
modifier|*
name|ctladdr
decl_stmt|;
name|ADDRESS
modifier|*
modifier|*
name|sendq
decl_stmt|;
name|int
name|aliaslevel
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|SM_NONVOLATILE
name|al
decl_stmt|;
comment|/* list of addresses to send to */
name|SM_NONVOLATILE
name|char
name|delimiter
decl_stmt|;
comment|/* the address delimiter */
name|SM_NONVOLATILE
name|int
name|naddrs
decl_stmt|;
name|SM_NONVOLATILE
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|endp
decl_stmt|;
name|char
modifier|*
name|oldto
init|=
name|e
operator|->
name|e_to
decl_stmt|;
name|char
modifier|*
name|SM_NONVOLATILE
name|bufp
decl_stmt|;
name|char
name|buf
index|[
name|MAXNAME
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"sendtolist: null list"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|25
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"sendto: %s\n   ctladdr="
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|ctladdr
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
comment|/* heuristic to determine old versus new style addresses */
if|if
condition|(
name|ctladdr
operator|==
name|NULL
operator|&&
operator|(
name|strchr
argument_list|(
name|list
argument_list|,
literal|','
argument_list|)
operator|!=
name|NULL
operator|||
name|strchr
argument_list|(
name|list
argument_list|,
literal|';'
argument_list|)
operator|!=
name|NULL
operator|||
name|strchr
argument_list|(
name|list
argument_list|,
literal|'<'
argument_list|)
operator|!=
name|NULL
operator|||
name|strchr
argument_list|(
name|list
argument_list|,
literal|'('
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_OLDSTYLE
expr_stmt|;
name|delimiter
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|EF_OLDSTYLE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|||
name|ctladdr
operator|!=
name|NULL
condition|)
name|delimiter
operator|=
literal|','
expr_stmt|;
name|al
operator|=
name|NULL
expr_stmt|;
name|naddrs
operator|=
literal|0
expr_stmt|;
comment|/* make sure we have enough space to copy the string */
name|i
operator|=
name|strlen
argument_list|(
name|list
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|bufp
operator|=
name|buf
expr_stmt|;
name|i
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|bufp
operator|=
name|sm_malloc_x
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|endp
operator|=
name|bufp
operator|+
name|i
expr_stmt|;
name|SM_TRY
block|{
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|bufp
argument_list|,
name|denlstring
argument_list|(
name|list
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{addr_type}"
argument_list|)
argument_list|,
literal|"e r"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|bufp
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
control|)
block|{
specifier|auto
name|char
modifier|*
name|delimptr
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
name|SM_ASSERT
argument_list|(
name|p
operator|<
name|endp
argument_list|)
expr_stmt|;
comment|/* parse the address */
while|while
condition|(
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|||
operator|*
name|p
operator|==
literal|','
condition|)
name|p
operator|++
expr_stmt|;
name|SM_ASSERT
argument_list|(
name|p
operator|<
name|endp
argument_list|)
expr_stmt|;
name|a
operator|=
name|parseaddr
argument_list|(
name|p
argument_list|,
name|NULLADDR
argument_list|,
name|RF_COPYALL
argument_list|,
name|delimiter
argument_list|,
operator|&
name|delimptr
argument_list|,
name|e
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|p
operator|=
name|delimptr
expr_stmt|;
name|SM_ASSERT
argument_list|(
name|p
operator|<
name|endp
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
continue|continue;
name|a
operator|->
name|q_next
operator|=
name|al
expr_stmt|;
name|a
operator|->
name|q_alias
operator|=
name|ctladdr
expr_stmt|;
comment|/* arrange to inherit attributes from parent */
if|if
condition|(
name|ctladdr
operator|!=
name|NULL
condition|)
block|{
name|ADDRESS
modifier|*
name|b
decl_stmt|;
comment|/* self reference test */
if|if
condition|(
name|sameaddr
argument_list|(
name|ctladdr
argument_list|,
name|a
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"sendtolist: QSELFREF "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|ctladdr
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|ctladdr
operator|->
name|q_flags
operator||=
name|QSELFREF
expr_stmt|;
block|}
comment|/* check for address loops */
name|b
operator|=
name|self_reference
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|!=
name|NULL
condition|)
block|{
name|b
operator|->
name|q_flags
operator||=
name|QSELFREF
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"sendtolist: QSELFREF "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|b
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|!=
name|b
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"sendtolist: QS_DONTSEND "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|a
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|a
operator|->
name|q_state
operator|=
name|QS_DONTSEND
expr_stmt|;
name|b
operator|->
name|q_flags
operator||=
name|a
operator|->
name|q_flags
operator|&
name|QNOTREMOTE
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* full name */
if|if
condition|(
name|a
operator|->
name|q_fullname
operator|==
name|NULL
condition|)
name|a
operator|->
name|q_fullname
operator|=
name|ctladdr
operator|->
name|q_fullname
expr_stmt|;
comment|/* various flag bits */
name|a
operator|->
name|q_flags
operator|&=
operator|~
name|QINHERITEDBITS
expr_stmt|;
name|a
operator|->
name|q_flags
operator||=
name|ctladdr
operator|->
name|q_flags
operator|&
name|QINHERITEDBITS
expr_stmt|;
comment|/* DSN recipient information */
name|a
operator|->
name|q_finalrcpt
operator|=
name|ctladdr
operator|->
name|q_finalrcpt
expr_stmt|;
name|a
operator|->
name|q_orcpt
operator|=
name|ctladdr
operator|->
name|q_orcpt
expr_stmt|;
block|}
name|al
operator|=
name|a
expr_stmt|;
block|}
comment|/* arrange to send to everyone on the local send list */
while|while
condition|(
name|al
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|ADDRESS
modifier|*
name|a
init|=
name|al
decl_stmt|;
name|al
operator|=
name|a
operator|->
name|q_next
expr_stmt|;
name|a
operator|=
name|recipient
argument_list|(
name|a
argument_list|,
name|sendq
argument_list|,
name|aliaslevel
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|naddrs
operator|++
expr_stmt|;
block|}
block|}
name|SM_FINALLY
block|{
name|e
operator|->
name|e_to
operator|=
name|oldto
expr_stmt|;
if|if
condition|(
name|bufp
operator|!=
name|buf
condition|)
name|sm_free
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{addr_type}"
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|SM_END_TRY
return|return
name|naddrs
return|;
block|}
end_function

begin_if
if|#
directive|if
name|MILTER
end_if

begin_comment
comment|/* **  REMOVEFROMLIST -- Remove addresses from a send list. ** **	The parameter is a comma-separated list of recipients to remove. **	Note that it only deletes matching addresses.  If those addresses **	have been expanded already in the sendq, it won't mark the **	expanded recipients as QS_REMOVED. ** **	Parameters: **		list -- the list to remove. **		sendq -- a pointer to the head of a queue to remove **			these addresses from. **		e -- the envelope in which to remove these recipients. ** **	Returns: **		The number of addresses removed from the list. ** */
end_comment

begin_function
name|int
name|removefromlist
parameter_list|(
name|list
parameter_list|,
name|sendq
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|list
decl_stmt|;
name|ADDRESS
modifier|*
modifier|*
name|sendq
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|SM_NONVOLATILE
name|char
name|delimiter
decl_stmt|;
comment|/* the address delimiter */
name|SM_NONVOLATILE
name|int
name|naddrs
decl_stmt|;
name|SM_NONVOLATILE
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|oldto
init|=
name|e
operator|->
name|e_to
decl_stmt|;
name|char
modifier|*
name|SM_NONVOLATILE
name|bufp
decl_stmt|;
name|char
name|buf
index|[
name|MAXNAME
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"removefromlist: null list"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|25
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"removefromlist: %s\n"
argument_list|,
name|list
argument_list|)
expr_stmt|;
comment|/* heuristic to determine old versus new style addresses */
if|if
condition|(
name|strchr
argument_list|(
name|list
argument_list|,
literal|','
argument_list|)
operator|!=
name|NULL
operator|||
name|strchr
argument_list|(
name|list
argument_list|,
literal|';'
argument_list|)
operator|!=
name|NULL
operator|||
name|strchr
argument_list|(
name|list
argument_list|,
literal|'<'
argument_list|)
operator|!=
name|NULL
operator|||
name|strchr
argument_list|(
name|list
argument_list|,
literal|'('
argument_list|)
operator|!=
name|NULL
condition|)
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_OLDSTYLE
expr_stmt|;
name|delimiter
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|EF_OLDSTYLE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|delimiter
operator|=
literal|','
expr_stmt|;
name|naddrs
operator|=
literal|0
expr_stmt|;
comment|/* make sure we have enough space to copy the string */
name|i
operator|=
name|strlen
argument_list|(
name|list
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|bufp
operator|=
name|buf
expr_stmt|;
name|i
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|bufp
operator|=
name|sm_malloc_x
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|SM_TRY
block|{
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|bufp
argument_list|,
name|denlstring
argument_list|(
name|list
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{addr_type}"
argument_list|)
argument_list|,
literal|"e r"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|bufp
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
control|)
block|{
name|ADDRESS
name|a
decl_stmt|;
comment|/* parsed address to be removed */
name|ADDRESS
modifier|*
name|q
decl_stmt|;
name|ADDRESS
modifier|*
modifier|*
name|pq
decl_stmt|;
name|char
modifier|*
name|delimptr
decl_stmt|;
comment|/* parse the address */
while|while
condition|(
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|||
operator|*
name|p
operator|==
literal|','
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|parseaddr
argument_list|(
name|p
argument_list|,
operator|&
name|a
argument_list|,
name|RF_COPYALL
operator||
name|RF_RM_ADDR
argument_list|,
name|delimiter
argument_list|,
operator|&
name|delimptr
argument_list|,
name|e
argument_list|,
name|true
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|p
operator|=
name|delimptr
expr_stmt|;
continue|continue;
block|}
name|p
operator|=
name|delimptr
expr_stmt|;
for|for
control|(
name|pq
operator|=
name|sendq
init|;
operator|(
name|q
operator|=
operator|*
name|pq
operator|)
operator|!=
name|NULL
condition|;
name|pq
operator|=
operator|&
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
operator|!
name|QS_IS_DEAD
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
operator|&&
operator|(
name|sameaddr
argument_list|(
name|q
argument_list|,
operator|&
name|a
argument_list|)
operator|||
name|strcmp
argument_list|(
name|q
operator|->
name|q_paddr
argument_list|,
name|a
operator|.
name|q_paddr
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|25
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"removefromlist: QS_REMOVED "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
operator|&
name|a
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|q
operator|->
name|q_state
operator|=
name|QS_REMOVED
expr_stmt|;
name|naddrs
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|SM_FINALLY
block|{
name|e
operator|->
name|e_to
operator|=
name|oldto
expr_stmt|;
if|if
condition|(
name|bufp
operator|!=
name|buf
condition|)
name|sm_free
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{addr_type}"
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|SM_END_TRY
return|return
name|naddrs
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MILTER */
end_comment

begin_comment
comment|/* **  RECIPIENT -- Designate a message recipient **	Saves the named person for future mailing (after some checks). ** **	Parameters: **		new -- the (preparsed) address header for the recipient. **		sendq -- a pointer to the head of a queue to put the **			recipient in.  Duplicate suppression is done **			in this queue. **		aliaslevel -- the current alias nesting depth. **		e -- the current envelope. ** **	Returns: **		The actual address in the queue.  This will be "a" if **		the address is not a duplicate, else the original address. ** */
end_comment

begin_function
name|ADDRESS
modifier|*
name|recipient
parameter_list|(
name|new
parameter_list|,
name|sendq
parameter_list|,
name|aliaslevel
parameter_list|,
name|e
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|new
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
modifier|*
name|sendq
decl_stmt|;
name|int
name|aliaslevel
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
name|ADDRESS
modifier|*
modifier|*
name|pq
decl_stmt|;
name|ADDRESS
modifier|*
modifier|*
name|prev
decl_stmt|;
specifier|register
name|struct
name|mailer
modifier|*
name|m
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|buflen
decl_stmt|;
name|bool
name|quoted
decl_stmt|;
comment|/* set if the addr has a quote bit */
name|bool
name|insert
decl_stmt|;
name|int
name|findusercount
decl_stmt|;
name|bool
name|initialdontsend
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
name|buf0
index|[
name|MAXNAME
operator|+
literal|1
index|]
decl_stmt|;
comment|/* unquoted image of the user name */
name|sortfn_t
modifier|*
name|sortfn
decl_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
name|quoted
operator|=
name|false
expr_stmt|;
name|insert
operator|=
name|false
expr_stmt|;
name|findusercount
operator|=
literal|0
expr_stmt|;
name|initialdontsend
operator|=
name|QS_IS_DEAD
argument_list|(
name|new
operator|->
name|q_state
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|new
operator|->
name|q_paddr
expr_stmt|;
name|m
operator|=
name|new
operator|->
name|q_mailer
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|aliaslevel
operator|==
literal|0
condition|)
name|new
operator|->
name|q_flags
operator||=
name|QPRIMARY
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|26
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"\nrecipient (%d): "
argument_list|,
name|aliaslevel
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|new
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
comment|/* if this is primary, use it as original recipient */
if|if
condition|(
name|new
operator|->
name|q_alias
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|e_origrcpt
operator|==
name|NULL
condition|)
name|e
operator|->
name|e_origrcpt
operator|=
name|new
operator|->
name|q_paddr
expr_stmt|;
elseif|else
if|if
condition|(
name|e
operator|->
name|e_origrcpt
operator|!=
name|new
operator|->
name|q_paddr
condition|)
name|e
operator|->
name|e_origrcpt
operator|=
literal|""
expr_stmt|;
block|}
comment|/* find parent recipient for finalrcpt and orcpt */
for|for
control|(
name|q
operator|=
name|new
init|;
name|q
operator|->
name|q_alias
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_alias
control|)
continue|continue;
comment|/* find final recipient DSN address */
if|if
condition|(
name|new
operator|->
name|q_finalrcpt
operator|==
name|NULL
operator|&&
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|!=
name|NULL
condition|)
block|{
name|char
name|frbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|p
operator|=
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|->
name|m_addrtype
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
literal|"rfc822"
expr_stmt|;
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|p
argument_list|,
literal|"rfc822"
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|frbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|frbuf
argument_list|)
argument_list|,
literal|"%s; %.800s"
argument_list|,
name|q
operator|->
name|q_mailer
operator|->
name|m_addrtype
argument_list|,
name|q
operator|->
name|q_user
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|q
operator|->
name|q_user
argument_list|,
literal|'@'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|frbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|frbuf
argument_list|)
argument_list|,
literal|"%s; %.800s"
argument_list|,
name|p
argument_list|,
name|q
operator|->
name|q_user
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|q
operator|->
name|q_paddr
argument_list|,
literal|'@'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|qp
decl_stmt|;
name|bool
name|b
decl_stmt|;
name|qp
operator|=
name|q
operator|->
name|q_paddr
expr_stmt|;
comment|/* strip brackets from address */
name|b
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|*
name|qp
operator|==
literal|'<'
condition|)
block|{
name|b
operator|=
name|qp
index|[
name|strlen
argument_list|(
name|qp
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'>'
expr_stmt|;
if|if
condition|(
name|b
condition|)
name|qp
index|[
name|strlen
argument_list|(
name|qp
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|qp
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|frbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|frbuf
argument_list|)
argument_list|,
literal|"%s; %.800s"
argument_list|,
name|p
argument_list|,
name|qp
argument_list|)
expr_stmt|;
comment|/* undo damage */
if|if
condition|(
name|b
condition|)
name|qp
index|[
name|strlen
argument_list|(
name|qp
argument_list|)
index|]
operator|=
literal|'>'
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|frbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|frbuf
argument_list|)
argument_list|,
literal|"%s; %.700s@%.100s"
argument_list|,
name|p
argument_list|,
name|q
operator|->
name|q_user
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
block|}
name|new
operator|->
name|q_finalrcpt
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|frbuf
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|_FFR_GEN_ORCPT
comment|/* set ORCPT DSN arg if not already set */
if|if
condition|(
name|new
operator|->
name|q_orcpt
operator|==
name|NULL
condition|)
block|{
comment|/* check for an existing ORCPT */
if|if
condition|(
name|q
operator|->
name|q_orcpt
operator|!=
name|NULL
condition|)
name|new
operator|->
name|q_orcpt
operator|=
name|q
operator|->
name|q_orcpt
expr_stmt|;
else|else
block|{
comment|/* make our own */
name|bool
name|b
init|=
name|false
decl_stmt|;
name|char
modifier|*
name|qp
decl_stmt|;
name|char
name|obuf
index|[
name|MAXLINE
index|]
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|!=
name|NULL
condition|)
name|p
operator|=
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|->
name|m_addrtype
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
literal|"rfc822"
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|obuf
argument_list|,
sizeof|sizeof
argument_list|(
name|obuf
argument_list|)
argument_list|,
literal|2
argument_list|,
name|p
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
name|qp
operator|=
name|q
operator|->
name|q_paddr
expr_stmt|;
comment|/* FFR: Needs to strip comments from stdin addrs */
comment|/* strip brackets from address */
if|if
condition|(
operator|*
name|qp
operator|==
literal|'<'
condition|)
block|{
name|b
operator|=
name|qp
index|[
name|strlen
argument_list|(
name|qp
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'>'
expr_stmt|;
if|if
condition|(
name|b
condition|)
name|qp
index|[
name|strlen
argument_list|(
name|qp
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|qp
operator|++
expr_stmt|;
block|}
name|p
operator|=
name|xtextify
argument_list|(
name|denlstring
argument_list|(
name|qp
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm_strlcat
argument_list|(
name|obuf
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|obuf
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|obuf
argument_list|)
condition|)
block|{
comment|/* if too big, don't use it */
name|obuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* undo damage */
if|if
condition|(
name|b
condition|)
name|qp
index|[
name|strlen
argument_list|(
name|qp
argument_list|)
index|]
operator|=
literal|'>'
expr_stmt|;
if|if
condition|(
name|obuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|new
operator|->
name|q_orcpt
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* _FFR_GEN_ORCPT */
comment|/* break aliasing loops */
if|if
condition|(
name|aliaslevel
operator|>
name|MaxAliasRecursion
condition|)
block|{
name|new
operator|->
name|q_state
operator|=
name|QS_BADADDR
expr_stmt|;
name|new
operator|->
name|q_status
operator|=
literal|"5.4.6"
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|q_alias
operator|!=
name|NULL
condition|)
block|{
name|new
operator|->
name|q_alias
operator|->
name|q_state
operator|=
name|QS_BADADDR
expr_stmt|;
name|new
operator|->
name|q_alias
operator|->
name|q_status
operator|=
literal|"5.4.6"
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|SuprErrs
operator|||
operator|!
name|LogUsrErrs
operator|)
operator|&&
name|LogLevel
operator|>
literal|0
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"aliasing/forwarding loop broken: %s (%d aliases deep; %d max)"
argument_list|,
name|FileName
operator|!=
name|NULL
condition|?
name|FileName
else|:
literal|""
argument_list|,
name|aliaslevel
argument_list|,
name|MaxAliasRecursion
argument_list|)
expr_stmt|;
block|}
name|usrerrenh
argument_list|(
name|new
operator|->
name|q_status
argument_list|,
literal|"554 aliasing/forwarding loop broken (%d aliases deep; %d max)"
argument_list|,
name|aliaslevel
argument_list|,
name|MaxAliasRecursion
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
comment|/* 	**  Finish setting up address structure. 	*/
comment|/* get unquoted user for file, program or user.name check */
name|i
operator|=
name|strlen
argument_list|(
name|new
operator|->
name|q_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
sizeof|sizeof
argument_list|(
name|buf0
argument_list|)
condition|)
block|{
name|buflen
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|buf
operator|=
name|xalloc
argument_list|(
name|buflen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
name|buf0
expr_stmt|;
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|buf0
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|buf
argument_list|,
name|new
operator|->
name|q_user
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|!
name|quoted
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
name|quoted
operator|=
name|true
expr_stmt|;
block|}
name|stripquotes
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* check for direct mailing to restricted mailers */
if|if
condition|(
name|m
operator|==
name|ProgMailer
condition|)
block|{
if|if
condition|(
name|new
operator|->
name|q_alias
operator|==
name|NULL
operator|||
name|UseMSP
operator|||
name|bitset
argument_list|(
name|EF_UNSAFE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|new
operator|->
name|q_state
operator|=
name|QS_BADADDR
expr_stmt|;
name|new
operator|->
name|q_status
operator|=
literal|"5.7.1"
expr_stmt|;
name|usrerrenh
argument_list|(
name|new
operator|->
name|q_status
argument_list|,
literal|"550 Cannot mail directly to programs"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|QBOGUSSHELL
argument_list|,
name|new
operator|->
name|q_alias
operator|->
name|q_flags
argument_list|)
condition|)
block|{
name|new
operator|->
name|q_state
operator|=
name|QS_BADADDR
expr_stmt|;
name|new
operator|->
name|q_status
operator|=
literal|"5.7.1"
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|q_alias
operator|->
name|q_ruser
operator|==
name|NULL
condition|)
name|usrerrenh
argument_list|(
name|new
operator|->
name|q_status
argument_list|,
literal|"550 UID %d is an unknown user: cannot mail to programs"
argument_list|,
name|new
operator|->
name|q_alias
operator|->
name|q_uid
argument_list|)
expr_stmt|;
else|else
name|usrerrenh
argument_list|(
name|new
operator|->
name|q_status
argument_list|,
literal|"550 User %s@%s doesn't have a valid shell for mailing to programs"
argument_list|,
name|new
operator|->
name|q_alias
operator|->
name|q_ruser
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|QUNSAFEADDR
argument_list|,
name|new
operator|->
name|q_alias
operator|->
name|q_flags
argument_list|)
condition|)
block|{
name|new
operator|->
name|q_state
operator|=
name|QS_BADADDR
expr_stmt|;
name|new
operator|->
name|q_status
operator|=
literal|"5.7.1"
expr_stmt|;
name|new
operator|->
name|q_rstatus
operator|=
literal|"550 Unsafe for mailing to programs"
expr_stmt|;
name|usrerrenh
argument_list|(
name|new
operator|->
name|q_status
argument_list|,
literal|"550 Address %s is unsafe for mailing to programs"
argument_list|,
name|new
operator|->
name|q_alias
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	**  Look up this person in the recipient list. 	**	If they are there already, return, otherwise continue. 	**	If the list is empty, just add it.  Notice the cute 	**	hack to make from addresses suppress things correctly: 	**	the QS_DUPLICATE state will be set in the send list. 	**	[Please note: the emphasis is on "hack."] 	*/
name|prev
operator|=
name|NULL
expr_stmt|;
comment|/* 	**  If this message is going to the queue or FastSplit is set 	**  and it is the first try and the envelope hasn't split, then we 	**  avoid doing an MX RR lookup now because one will be done when the 	**  message is extracted from the queue later. It can go to the queue 	**  because all messages are going to the queue or this mailer of 	**  the current recipient is marked expensive. 	*/
if|if
condition|(
name|UseMSP
operator|||
name|WILL_BE_QUEUED
argument_list|(
name|e
operator|->
name|e_sendmode
argument_list|)
operator|||
operator|(
operator|!
name|bitset
argument_list|(
name|EF_SPLIT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
name|e
operator|->
name|e_ntries
operator|==
literal|0
operator|&&
name|FastSplit
operator|>
literal|0
operator|)
condition|)
name|sortfn
operator|=
name|sorthost
expr_stmt|;
elseif|else
if|if
condition|(
name|NoConnect
operator|&&
name|bitnset
argument_list|(
name|M_EXPENSIVE
argument_list|,
name|new
operator|->
name|q_mailer
operator|->
name|m_flags
argument_list|)
condition|)
name|sortfn
operator|=
name|sortexpensive
expr_stmt|;
else|else
name|sortfn
operator|=
name|sortbysignature
expr_stmt|;
for|for
control|(
name|pq
operator|=
name|sendq
init|;
operator|(
name|q
operator|=
operator|*
name|pq
operator|)
operator|!=
name|NULL
condition|;
name|pq
operator|=
operator|&
name|q
operator|->
name|q_next
control|)
block|{
comment|/* 		**  If address is "less than" it should be inserted now. 		**  If address is "greater than" current comparison it'll 		**  insert later in the list; so loop again (if possible). 		**  If address is "equal" (different equal than sameaddr() 		**  call) then check if sameaddr() will be true. 		**  Because this list is now sorted, it'll mean fewer 		**  comparisons and fewer loops which is important for more 		**  recipients. 		*/
name|i
operator|=
call|(
modifier|*
name|sortfn
call|)
argument_list|(
name|new
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
comment|/* equal */
block|{
comment|/* 			**  Sortbysignature() has said that the two have 			**  equal MX RR's and the same user. Calling sameaddr() 			**  now checks if the two hosts are as identical as the 			**  MX RR's are (which might not be the case) 			**  before saying these are the identical addresses. 			*/
if|if
condition|(
name|sameaddr
argument_list|(
name|q
argument_list|,
name|new
argument_list|)
operator|&&
operator|(
name|bitset
argument_list|(
name|QRCPTOK
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
operator|||
operator|!
name|bitset
argument_list|(
name|QPRIMARY
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|26
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"%s in sendq: "
argument_list|,
name|new
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|q
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QPRIMARY
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|QS_IS_DEAD
argument_list|(
name|new
operator|->
name|q_state
argument_list|)
condition|)
name|message
argument_list|(
literal|"duplicate suppressed"
argument_list|)
expr_stmt|;
else|else
name|q
operator|->
name|q_state
operator|=
name|QS_DUPLICATE
expr_stmt|;
name|q
operator|->
name|q_flags
operator||=
name|new
operator|->
name|q_flags
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|QSELFREF
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
operator|||
name|q
operator|->
name|q_state
operator|==
name|QS_REMOVED
condition|)
block|{
comment|/* 					**  If an earlier milter removed the 					**  address, a later one can still add 					**  it back. 					*/
name|q
operator|->
name|q_state
operator|=
name|new
operator|->
name|q_state
expr_stmt|;
name|q
operator|->
name|q_flags
operator||=
name|new
operator|->
name|q_flags
expr_stmt|;
block|}
name|new
operator|=
name|q
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|<
literal|0
condition|)
comment|/* less than */
block|{
name|insert
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|prev
operator|=
name|pq
expr_stmt|;
block|}
comment|/* pq should point to an address, never NULL */
name|SM_ASSERT
argument_list|(
name|pq
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* add address on list */
if|if
condition|(
name|insert
condition|)
block|{
comment|/* 		**  insert before 'pq'. Only possible when at least 1 		**  ADDRESS is in the list already. 		*/
name|new
operator|->
name|q_next
operator|=
operator|*
name|pq
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
operator|*
name|sendq
operator|=
name|new
expr_stmt|;
comment|/* To be the first ADDRESS */
else|else
operator|(
operator|*
name|prev
operator|)
operator|->
name|q_next
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
comment|/* 		**  Place in list at current 'pq' position. Possible 		**  when there are 0 or more ADDRESS's in the list. 		*/
name|new
operator|->
name|q_next
operator|=
name|NULL
expr_stmt|;
operator|*
name|pq
operator|=
name|new
expr_stmt|;
block|}
comment|/* added a new address: clear split flag */
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_SPLIT
expr_stmt|;
comment|/* 	**  Alias the name and handle special mailer types. 	*/
name|trylocaluser
label|:
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"at trylocaluser: "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|new
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|QS_IS_OK
argument_list|(
name|new
operator|->
name|q_state
argument_list|)
condition|)
block|{
if|if
condition|(
name|QS_IS_UNDELIVERED
argument_list|(
name|new
operator|->
name|q_state
argument_list|)
condition|)
name|e
operator|->
name|e_nrcpts
operator|++
expr_stmt|;
goto|goto
name|testselfdestruct
goto|;
block|}
if|if
condition|(
name|m
operator|==
name|InclMailer
condition|)
block|{
name|new
operator|->
name|q_state
operator|=
name|QS_INCLUDED
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|q_alias
operator|==
name|NULL
operator|||
name|UseMSP
operator|||
name|bitset
argument_list|(
name|EF_UNSAFE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|new
operator|->
name|q_state
operator|=
name|QS_BADADDR
expr_stmt|;
name|new
operator|->
name|q_status
operator|=
literal|"5.7.1"
expr_stmt|;
name|usrerrenh
argument_list|(
name|new
operator|->
name|q_status
argument_list|,
literal|"550 Cannot mail directly to :include:s"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|ret
decl_stmt|;
name|message
argument_list|(
literal|"including file %s"
argument_list|,
name|new
operator|->
name|q_user
argument_list|)
expr_stmt|;
name|ret
operator|=
name|include
argument_list|(
name|new
operator|->
name|q_user
argument_list|,
name|false
argument_list|,
name|new
argument_list|,
name|sendq
argument_list|,
name|aliaslevel
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|transienterror
argument_list|(
name|ret
argument_list|)
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|2
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"include %s: transient error: %s"
argument_list|,
name|shortenstring
argument_list|(
name|new
operator|->
name|q_user
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|,
name|sm_errstring
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|q_state
operator|=
name|QS_QUEUEUP
expr_stmt|;
name|usrerr
argument_list|(
literal|"451 4.2.4 Cannot open %s: %s"
argument_list|,
name|shortenstring
argument_list|(
name|new
operator|->
name|q_user
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|,
name|sm_errstring
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|new
operator|->
name|q_state
operator|=
name|QS_BADADDR
expr_stmt|;
name|new
operator|->
name|q_status
operator|=
literal|"5.2.4"
expr_stmt|;
name|usrerrenh
argument_list|(
name|new
operator|->
name|q_status
argument_list|,
literal|"550 Cannot open %s: %s"
argument_list|,
name|shortenstring
argument_list|(
name|new
operator|->
name|q_user
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|,
name|sm_errstring
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|m
operator|==
name|FileMailer
condition|)
block|{
comment|/* check if allowed */
if|if
condition|(
name|new
operator|->
name|q_alias
operator|==
name|NULL
operator|||
name|UseMSP
operator|||
name|bitset
argument_list|(
name|EF_UNSAFE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|new
operator|->
name|q_state
operator|=
name|QS_BADADDR
expr_stmt|;
name|new
operator|->
name|q_status
operator|=
literal|"5.7.1"
expr_stmt|;
name|usrerrenh
argument_list|(
name|new
operator|->
name|q_status
argument_list|,
literal|"550 Cannot mail directly to files"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|QBOGUSSHELL
argument_list|,
name|new
operator|->
name|q_alias
operator|->
name|q_flags
argument_list|)
condition|)
block|{
name|new
operator|->
name|q_state
operator|=
name|QS_BADADDR
expr_stmt|;
name|new
operator|->
name|q_status
operator|=
literal|"5.7.1"
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|q_alias
operator|->
name|q_ruser
operator|==
name|NULL
condition|)
name|usrerrenh
argument_list|(
name|new
operator|->
name|q_status
argument_list|,
literal|"550 UID %d is an unknown user: cannot mail to files"
argument_list|,
name|new
operator|->
name|q_alias
operator|->
name|q_uid
argument_list|)
expr_stmt|;
else|else
name|usrerrenh
argument_list|(
name|new
operator|->
name|q_status
argument_list|,
literal|"550 User %s@%s doesn't have a valid shell for mailing to files"
argument_list|,
name|new
operator|->
name|q_alias
operator|->
name|q_ruser
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|QUNSAFEADDR
argument_list|,
name|new
operator|->
name|q_alias
operator|->
name|q_flags
argument_list|)
condition|)
block|{
name|new
operator|->
name|q_state
operator|=
name|QS_BADADDR
expr_stmt|;
name|new
operator|->
name|q_status
operator|=
literal|"5.7.1"
expr_stmt|;
name|new
operator|->
name|q_rstatus
operator|=
literal|"550 Unsafe for mailing to files"
expr_stmt|;
name|usrerrenh
argument_list|(
name|new
operator|->
name|q_status
argument_list|,
literal|"550 Address %s is unsafe for mailing to files"
argument_list|,
name|new
operator|->
name|q_alias
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* try aliasing */
if|if
condition|(
operator|!
name|quoted
operator|&&
name|QS_IS_OK
argument_list|(
name|new
operator|->
name|q_state
argument_list|)
operator|&&
name|bitnset
argument_list|(
name|M_ALIASABLE
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|alias
argument_list|(
name|new
argument_list|,
name|sendq
argument_list|,
name|aliaslevel
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|#
directive|if
name|USERDB
comment|/* if not aliased, look it up in the user database */
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QNOTREMOTE
argument_list|,
name|new
operator|->
name|q_flags
argument_list|)
operator|&&
name|QS_IS_SENDABLE
argument_list|(
name|new
operator|->
name|q_state
argument_list|)
operator|&&
name|bitnset
argument_list|(
name|M_CHECKUDB
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|udbexpand
argument_list|(
name|new
argument_list|,
name|sendq
argument_list|,
name|aliaslevel
argument_list|,
name|e
argument_list|)
operator|==
name|EX_TEMPFAIL
condition|)
block|{
name|new
operator|->
name|q_state
operator|=
name|QS_QUEUEUP
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_message
operator|==
name|NULL
condition|)
name|e
operator|->
name|e_message
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
literal|"Deferred: user database error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|q_message
operator|==
name|NULL
condition|)
name|new
operator|->
name|q_message
operator|=
literal|"Deferred: user database error"
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"deferred: udbexpand: %s"
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"queued (user database error): %s"
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_nrcpts
operator|++
expr_stmt|;
goto|goto
name|testselfdestruct
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* USERDB */
comment|/* 	**  If we have a level two config file, then pass the name through 	**  Ruleset 5 before sending it off.  Ruleset 5 has the right 	**  to rewrite it to another mailer.  This gives us a hook 	**  after local aliasing has been done. 	*/
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"recipient: testing local?  cl=%d, rr5=%p\n\t"
argument_list|,
name|ConfigLevel
argument_list|,
name|RewriteRules
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|new
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ConfigLevel
operator|>=
literal|2
operator|&&
name|RewriteRules
index|[
literal|5
index|]
operator|!=
name|NULL
operator|&&
name|bitnset
argument_list|(
name|M_TRYRULESET5
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|QNOTREMOTE
argument_list|,
name|new
operator|->
name|q_flags
argument_list|)
operator|&&
name|QS_IS_OK
argument_list|(
name|new
operator|->
name|q_state
argument_list|)
condition|)
block|{
name|maplocaluser
argument_list|(
name|new
argument_list|,
name|sendq
argument_list|,
name|aliaslevel
operator|+
literal|1
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  If it didn't get rewritten to another mailer, go ahead 	**  and deliver it. 	*/
if|if
condition|(
name|QS_IS_OK
argument_list|(
name|new
operator|->
name|q_state
argument_list|)
operator|&&
name|bitnset
argument_list|(
name|M_HASPWENT
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
specifier|auto
name|bool
name|fuzzy
decl_stmt|;
name|SM_MBDB_T
name|user
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* warning -- finduser may trash buf */
name|status
operator|=
name|finduser
argument_list|(
name|buf
argument_list|,
operator|&
name|fuzzy
argument_list|,
operator|&
name|user
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|EX_TEMPFAIL
case|:
name|new
operator|->
name|q_state
operator|=
name|QS_QUEUEUP
expr_stmt|;
name|new
operator|->
name|q_status
operator|=
literal|"4.5.2"
expr_stmt|;
name|giveresponse
argument_list|(
name|EX_TEMPFAIL
argument_list|,
name|new
operator|->
name|q_status
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|new
operator|->
name|q_alias
argument_list|,
operator|(
name|time_t
operator|)
literal|0
argument_list|,
name|e
argument_list|,
name|new
argument_list|)
expr_stmt|;
break|break;
default|default:
name|new
operator|->
name|q_state
operator|=
name|QS_BADADDR
expr_stmt|;
name|new
operator|->
name|q_status
operator|=
literal|"5.1.1"
expr_stmt|;
name|new
operator|->
name|q_rstatus
operator|=
literal|"550 5.1.1 User unknown"
expr_stmt|;
name|giveresponse
argument_list|(
name|EX_NOUSER
argument_list|,
name|new
operator|->
name|q_status
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|new
operator|->
name|q_alias
argument_list|,
operator|(
name|time_t
operator|)
literal|0
argument_list|,
name|e
argument_list|,
name|new
argument_list|)
expr_stmt|;
break|break;
case|case
name|EX_OK
case|:
if|if
condition|(
name|fuzzy
condition|)
block|{
comment|/* name was a fuzzy match */
name|new
operator|->
name|q_user
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|user
operator|.
name|mbdb_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|findusercount
operator|++
operator|>
literal|3
condition|)
block|{
name|new
operator|->
name|q_state
operator|=
name|QS_BADADDR
expr_stmt|;
name|new
operator|->
name|q_status
operator|=
literal|"5.4.6"
expr_stmt|;
name|usrerrenh
argument_list|(
name|new
operator|->
name|q_status
argument_list|,
literal|"554 aliasing/forwarding loop for %s broken"
argument_list|,
name|user
operator|.
name|mbdb_name
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* see if it aliases */
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|buf
argument_list|,
name|user
operator|.
name|mbdb_name
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
goto|goto
name|trylocaluser
goto|;
block|}
if|if
condition|(
operator|*
name|user
operator|.
name|mbdb_homedir
operator|==
literal|'\0'
condition|)
name|new
operator|->
name|q_home
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|user
operator|.
name|mbdb_homedir
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
condition|)
name|new
operator|->
name|q_home
operator|=
literal|""
expr_stmt|;
else|else
name|new
operator|->
name|q_home
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|user
operator|.
name|mbdb_homedir
argument_list|)
expr_stmt|;
if|if
condition|(
name|user
operator|.
name|mbdb_uid
operator|!=
name|SM_NO_UID
condition|)
block|{
name|new
operator|->
name|q_uid
operator|=
name|user
operator|.
name|mbdb_uid
expr_stmt|;
name|new
operator|->
name|q_gid
operator|=
name|user
operator|.
name|mbdb_gid
expr_stmt|;
name|new
operator|->
name|q_flags
operator||=
name|QGOODUID
expr_stmt|;
block|}
name|new
operator|->
name|q_ruser
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|user
operator|.
name|mbdb_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|user
operator|.
name|mbdb_fullname
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|new
operator|->
name|q_fullname
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|user
operator|.
name|mbdb_fullname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|usershellok
argument_list|(
name|user
operator|.
name|mbdb_name
argument_list|,
name|user
operator|.
name|mbdb_shell
argument_list|)
condition|)
block|{
name|new
operator|->
name|q_flags
operator||=
name|QBOGUSSHELL
expr_stmt|;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|EF_VRFYONLY
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
comment|/* don't do any more now */
name|new
operator|->
name|q_state
operator|=
name|QS_VERIFIED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|quoted
condition|)
name|forward
argument_list|(
name|new
argument_list|,
name|sendq
argument_list|,
name|aliaslevel
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|QS_IS_DEAD
argument_list|(
name|new
operator|->
name|q_state
argument_list|)
condition|)
name|e
operator|->
name|e_nrcpts
operator|++
expr_stmt|;
name|testselfdestruct
label|:
name|new
operator|->
name|q_flags
operator||=
name|QTHISPASS
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|26
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"testselfdestruct: "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|new
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|26
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"SENDQ:\n"
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
operator|*
name|sendq
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"----\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|new
operator|->
name|q_alias
operator|==
name|NULL
operator|&&
name|new
operator|!=
operator|&
name|e
operator|->
name|e_from
operator|&&
name|QS_IS_DEAD
argument_list|(
name|new
operator|->
name|q_state
argument_list|)
condition|)
block|{
for|for
control|(
name|q
operator|=
operator|*
name|sendq
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
operator|!
name|QS_IS_DEAD
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
name|new
operator|->
name|q_state
operator|=
name|QS_BADADDR
expr_stmt|;
name|new
operator|->
name|q_status
operator|=
literal|"5.4.6"
expr_stmt|;
name|usrerrenh
argument_list|(
name|new
operator|->
name|q_status
argument_list|,
literal|"554 aliasing/forwarding loop broken"
argument_list|)
expr_stmt|;
block|}
block|}
name|done
label|:
name|new
operator|->
name|q_flags
operator||=
name|QTHISPASS
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|buf0
condition|)
name|sm_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* XXX leak if above code raises exception */
comment|/* 	**  If we are at the top level, check to see if this has 	**  expanded to exactly one address.  If so, it can inherit 	**  the primaryness of the address. 	** 	**  While we're at it, clear the QTHISPASS bits. 	*/
if|if
condition|(
name|aliaslevel
operator|==
literal|0
condition|)
block|{
name|int
name|nrcpts
init|=
literal|0
decl_stmt|;
name|ADDRESS
modifier|*
name|only
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|q
operator|=
operator|*
name|sendq
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|QTHISPASS
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
operator|&&
name|QS_IS_SENDABLE
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
condition|)
block|{
name|nrcpts
operator|++
expr_stmt|;
name|only
operator|=
name|q
expr_stmt|;
block|}
name|q
operator|->
name|q_flags
operator|&=
operator|~
name|QTHISPASS
expr_stmt|;
block|}
if|if
condition|(
name|nrcpts
operator|==
literal|1
condition|)
block|{
comment|/* check to see if this actually got a new owner */
name|q
operator|=
name|only
expr_stmt|;
while|while
condition|(
operator|(
name|q
operator|=
name|q
operator|->
name|q_alias
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|q_owner
operator|!=
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
name|only
operator|->
name|q_flags
operator||=
name|QPRIMARY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|initialdontsend
operator|&&
name|nrcpts
operator|>
literal|0
condition|)
block|{
comment|/* arrange for return receipt */
name|e
operator|->
name|e_flags
operator||=
name|EF_SENDRECEIPT
expr_stmt|;
name|new
operator|->
name|q_flags
operator||=
name|QEXPANDED
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
operator|&&
name|bitset
argument_list|(
name|QPINGONSUCCESS
argument_list|,
name|new
operator|->
name|q_flags
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s... expanded to multiple addresses\n"
argument_list|,
name|new
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
block|}
block|}
name|new
operator|->
name|q_flags
operator||=
name|QRCPTOK
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf0
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|e
operator|->
name|e_nrcpts
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{nrcpts}"
argument_list|)
argument_list|,
name|buf0
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* **  FINDUSER -- find the password entry for a user. ** **	This looks a lot like getpwnam, except that it may want to **	do some fancier pattern matching in /etc/passwd. ** **	This routine contains most of the time of many sendmail runs. **	It deserves to be optimized. ** **	Parameters: **		name -- the name to match against. **		fuzzyp -- an outarg that is set to true if this entry **			was found using the fuzzy matching algorithm; **			set to false otherwise. **		user -- structure to fill in if user is found ** **	Returns: **		On success, fill in *user, set *fuzzyp and return EX_OK. **		If the user was not found, return EX_NOUSER. **		On error, return EX_TEMPFAIL or EX_OSERR. ** **	Side Effects: **		may modify name. */
end_comment

begin_function
name|int
name|finduser
parameter_list|(
name|name
parameter_list|,
name|fuzzyp
parameter_list|,
name|user
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|bool
modifier|*
name|fuzzyp
decl_stmt|;
name|SM_MBDB_T
modifier|*
name|user
decl_stmt|;
block|{
if|#
directive|if
name|MATCHGECOS
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
endif|#
directive|endif
comment|/* MATCHGECOS */
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|bool
name|tryagain
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|4
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"finduser(%s): "
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|fuzzyp
operator|=
name|false
expr_stmt|;
if|#
directive|if
name|HESIOD
comment|/* DEC Hesiod getpwnam accepts numeric strings -- short circuit it */
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|4
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"failed (numeric input)\n"
argument_list|)
expr_stmt|;
return|return
name|EX_NOUSER
return|;
block|}
endif|#
directive|endif
comment|/* HESIOD */
comment|/* look up this login name using fast path */
name|status
operator|=
name|sm_mbdb_lookup
argument_list|(
name|name
argument_list|,
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|EX_NOUSER
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|4
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"%s (non-fuzzy)\n"
argument_list|,
name|sm_strexit
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
comment|/* try mapping it to lower case */
name|tryagain
operator|=
name|false
expr_stmt|;
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isupper
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
operator|*
name|p
operator|=
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|tryagain
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tryagain
operator|&&
operator|(
name|status
operator|=
name|sm_mbdb_lookup
argument_list|(
name|name
argument_list|,
name|user
argument_list|)
operator|)
operator|!=
name|EX_NOUSER
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|4
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"%s (lower case)\n"
argument_list|,
name|sm_strexit
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|fuzzyp
operator|=
name|true
expr_stmt|;
return|return
name|status
return|;
block|}
if|#
directive|if
name|MATCHGECOS
comment|/* see if fuzzy matching allowed */
if|if
condition|(
operator|!
name|MatchGecos
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|4
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"not found (fuzzy disabled)\n"
argument_list|)
expr_stmt|;
return|return
name|EX_NOUSER
return|;
block|}
comment|/* search for a matching full name instead */
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
operator|(
name|SpaceSub
operator|&
literal|0177
operator|)
operator|||
operator|*
name|p
operator|==
literal|'_'
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|setpwent
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|pw
operator|=
name|getpwent
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
name|buf
index|[
name|MAXNAME
operator|+
literal|1
index|]
decl_stmt|;
if|#
directive|if
literal|0
block|if (sm_strcasecmp(pw->pw_name, name) == 0) 		{ 			if (tTd(29, 4)) 				sm_dprintf("found (case wrapped)\n"); 			break; 		}
endif|#
directive|endif
comment|/* 0 */
name|sm_pwfullname
argument_list|(
name|pw
operator|->
name|pw_gecos
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|buf
argument_list|,
literal|' '
argument_list|)
operator|!=
name|NULL
operator|&&
name|sm_strcasecmp
argument_list|(
name|buf
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|4
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"fuzzy matches %s\n"
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"sending to login name %s"
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pw
operator|!=
name|NULL
condition|)
operator|*
name|fuzzyp
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|4
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"no fuzzy match found\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEC_OSF_BROKEN_GETPWENT
comment|/* DEC OSF/1 3.2 or earlier */
name|endpwent
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DEC_OSF_BROKEN_GETPWENT */
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
return|return
name|EX_NOUSER
return|;
name|sm_mbdb_frompw
argument_list|(
name|user
argument_list|,
name|pw
argument_list|)
expr_stmt|;
return|return
name|EX_OK
return|;
else|#
directive|else
comment|/* MATCHGECOS */
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|4
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"not found (fuzzy disabled)\n"
argument_list|)
expr_stmt|;
return|return
name|EX_NOUSER
return|;
endif|#
directive|endif
comment|/* MATCHGECOS */
block|}
end_function

begin_comment
comment|/* **  WRITABLE -- predicate returning if the file is writable. ** **	This routine must duplicate the algorithm in sys/fio.c. **	Unfortunately, we cannot use the access call since we **	won't necessarily be the real uid when we try to **	actually open the file. ** **	Notice that ANY file with ANY execute bit is automatically **	not writable.  This is also enforced by mailfile. ** **	Parameters: **		filename -- the file name to check. **		ctladdr -- the controlling address for this file. **		flags -- SFF_* flags to control the function. ** **	Returns: **		true -- if we will be able to write this file. **		false -- if we cannot write this file. ** **	Side Effects: **		none. */
end_comment

begin_function
name|bool
name|writable
parameter_list|(
name|filename
parameter_list|,
name|ctladdr
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|ADDRESS
modifier|*
name|ctladdr
decl_stmt|;
name|long
name|flags
decl_stmt|;
block|{
name|uid_t
name|euid
init|=
literal|0
decl_stmt|;
name|gid_t
name|egid
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|user
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|44
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"writable(%s, 0x%lx)\n"
argument_list|,
name|filename
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 	**  File does exist -- check that it is writable. 	*/
if|if
condition|(
name|geteuid
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|euid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
name|egid
operator|=
name|getegid
argument_list|()
expr_stmt|;
name|user
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctladdr
operator|!=
name|NULL
condition|)
block|{
name|euid
operator|=
name|ctladdr
operator|->
name|q_uid
expr_stmt|;
name|egid
operator|=
name|ctladdr
operator|->
name|q_gid
expr_stmt|;
name|user
operator|=
name|ctladdr
operator|->
name|q_user
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|SFF_RUNASREALUID
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|euid
operator|=
name|RealUid
expr_stmt|;
name|egid
operator|=
name|RealGid
expr_stmt|;
name|user
operator|=
name|RealUserName
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FileMailer
operator|!=
name|NULL
operator|&&
operator|!
name|bitset
argument_list|(
name|SFF_ROOTOK
argument_list|,
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|FileMailer
operator|->
name|m_uid
operator|==
name|NO_UID
condition|)
block|{
name|euid
operator|=
name|DefUid
expr_stmt|;
name|user
operator|=
name|DefUser
expr_stmt|;
block|}
else|else
block|{
name|euid
operator|=
name|FileMailer
operator|->
name|m_uid
expr_stmt|;
name|user
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|FileMailer
operator|->
name|m_gid
operator|==
name|NO_GID
condition|)
name|egid
operator|=
name|DefGid
expr_stmt|;
else|else
name|egid
operator|=
name|FileMailer
operator|->
name|m_gid
expr_stmt|;
block|}
else|else
block|{
name|euid
operator|=
name|egid
operator|=
literal|0
expr_stmt|;
name|user
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|SFF_ROOTOK
argument_list|,
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|euid
operator|==
literal|0
condition|)
block|{
name|euid
operator|=
name|DefUid
expr_stmt|;
name|user
operator|=
name|DefUser
expr_stmt|;
block|}
if|if
condition|(
name|egid
operator|==
literal|0
condition|)
name|egid
operator|=
name|DefGid
expr_stmt|;
block|}
if|if
condition|(
name|geteuid
argument_list|()
operator|==
literal|0
operator|&&
operator|(
name|ctladdr
operator|==
name|NULL
operator|||
operator|!
name|bitset
argument_list|(
name|QGOODUID
argument_list|,
name|ctladdr
operator|->
name|q_flags
argument_list|)
operator|)
condition|)
name|flags
operator||=
name|SFF_SETUIDOK
expr_stmt|;
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|DBS_FILEDELIVERYTOSYMLINK
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
name|flags
operator||=
name|SFF_NOSLINK
expr_stmt|;
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|DBS_FILEDELIVERYTOHARDLINK
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
name|flags
operator||=
name|SFF_NOHLINK
expr_stmt|;
name|errno
operator|=
name|safefile
argument_list|(
name|filename
argument_list|,
name|euid
argument_list|,
name|egid
argument_list|,
name|user
argument_list|,
name|flags
argument_list|,
name|S_IWRITE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|errno
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* **  INCLUDE -- handle :include: specification. ** **	Parameters: **		fname -- filename to include. **		forwarding -- if true, we are reading a .forward file. **			if false, it's a :include: file. **		ctladdr -- address template to use to fill in these **			addresses -- effective user/group id are **			the important things. **		sendq -- a pointer to the head of the send queue **			to put these addresses in. **		aliaslevel -- the alias nesting depth. **		e -- the current envelope. ** **	Returns: **		open error status ** **	Side Effects: **		reads the :include: file and sends to everyone **		listed in that file. ** **	Security Note: **		If you have restricted chown (that is, you can't **		give a file away), it is reasonable to allow programs **		and files called from this :include: file to be to be **		run as the owner of the :include: file.  This is bogus **		if there is any chance of someone giving away a file. **		We assume that pre-POSIX systems can give away files. ** **		There is an additional restriction that if you **		forward to a :include: file, it will not take on **		the ownership of the :include: file.  This may not **		be necessary, but shouldn't hurt. */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|CtxIncludeTimeout
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|include
parameter_list|(
name|fname
parameter_list|,
name|forwarding
parameter_list|,
name|ctladdr
parameter_list|,
name|sendq
parameter_list|,
name|aliaslevel
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|bool
name|forwarding
decl_stmt|;
name|ADDRESS
modifier|*
name|ctladdr
decl_stmt|;
name|ADDRESS
modifier|*
modifier|*
name|sendq
decl_stmt|;
name|int
name|aliaslevel
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|SM_FILE_T
modifier|*
specifier|volatile
name|fp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|oldto
init|=
name|e
operator|->
name|e_to
decl_stmt|;
name|char
modifier|*
name|oldfilename
init|=
name|FileName
decl_stmt|;
name|int
name|oldlinenumber
init|=
name|LineNumber
decl_stmt|;
specifier|register
name|SM_EVENT
modifier|*
name|ev
init|=
name|NULL
decl_stmt|;
name|int
name|nincludes
decl_stmt|;
name|int
name|mode
decl_stmt|;
specifier|volatile
name|bool
name|maxreached
init|=
name|false
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|ca
decl_stmt|;
specifier|volatile
name|uid_t
name|saveduid
decl_stmt|;
specifier|volatile
name|gid_t
name|savedgid
decl_stmt|;
specifier|volatile
name|uid_t
name|uid
decl_stmt|;
specifier|volatile
name|gid_t
name|gid
decl_stmt|;
name|char
modifier|*
specifier|volatile
name|user
decl_stmt|;
name|int
name|rval
init|=
literal|0
decl_stmt|;
specifier|volatile
name|long
name|sfflags
init|=
name|SFF_REGONLY
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|bool
name|safechown
init|=
name|false
decl_stmt|;
specifier|volatile
name|bool
name|safedir
init|=
name|false
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"include(%s)\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|4
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"   ruid=%d euid=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|14
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"ctladdr "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|ctladdr
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|9
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"include: old uid = %d/%d\n"
argument_list|,
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|forwarding
condition|)
block|{
name|sfflags
operator||=
name|SFF_MUSTOWN
operator||
name|SFF_ROOTOK
expr_stmt|;
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|DBS_GROUPWRITABLEFORWARDFILE
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
name|sfflags
operator||=
name|SFF_NOGWFILES
expr_stmt|;
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|DBS_WORLDWRITABLEFORWARDFILE
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
name|sfflags
operator||=
name|SFF_NOWWFILES
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|DBS_GROUPWRITABLEINCLUDEFILE
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
name|sfflags
operator||=
name|SFF_NOGWFILES
expr_stmt|;
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|DBS_WORLDWRITABLEINCLUDEFILE
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
name|sfflags
operator||=
name|SFF_NOWWFILES
expr_stmt|;
block|}
comment|/* 	**  If RunAsUser set, won't be able to run programs as user 	**  so mark them as unsafe unless the administrator knows better. 	*/
if|if
condition|(
operator|(
name|geteuid
argument_list|()
operator|!=
literal|0
operator|||
name|RunAsUid
operator|!=
literal|0
operator|)
operator|&&
operator|!
name|bitnset
argument_list|(
name|DBS_NONROOTSAFEADDR
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|4
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"include: not safe (euid=%d, RunAsUid=%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|RunAsUid
argument_list|)
expr_stmt|;
name|ctladdr
operator|->
name|q_flags
operator||=
name|QUNSAFEADDR
expr_stmt|;
block|}
name|ca
operator|=
name|getctladdr
argument_list|(
name|ctladdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ca
operator|==
name|NULL
operator|||
operator|(
name|ca
operator|->
name|q_uid
operator|==
name|DefUid
operator|&&
name|ca
operator|->
name|q_gid
operator|==
literal|0
operator|)
condition|)
block|{
name|uid
operator|=
name|DefUid
expr_stmt|;
name|gid
operator|=
name|DefGid
expr_stmt|;
name|user
operator|=
name|DefUser
expr_stmt|;
block|}
else|else
block|{
name|uid
operator|=
name|ca
operator|->
name|q_uid
expr_stmt|;
name|gid
operator|=
name|ca
operator|->
name|q_gid
expr_stmt|;
name|user
operator|=
name|ca
operator|->
name|q_user
expr_stmt|;
block|}
if|#
directive|if
name|MAILER_SETUID_METHOD
operator|!=
name|USE_SETUID
name|saveduid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
name|savedgid
operator|=
name|getegid
argument_list|()
expr_stmt|;
if|if
condition|(
name|saveduid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|DontInitGroups
condition|)
block|{
if|if
condition|(
name|initgroups
argument_list|(
name|user
argument_list|,
name|gid
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|rval
operator|=
name|EAGAIN
expr_stmt|;
name|syserr
argument_list|(
literal|"include: initgroups(%s, %d) failed"
argument_list|,
name|user
argument_list|,
name|gid
argument_list|)
expr_stmt|;
goto|goto
name|resetuid
goto|;
block|}
block|}
else|else
block|{
name|GIDSET_T
name|gidset
index|[
literal|1
index|]
decl_stmt|;
name|gidset
index|[
literal|0
index|]
operator|=
name|gid
expr_stmt|;
if|if
condition|(
name|setgroups
argument_list|(
literal|1
argument_list|,
name|gidset
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|rval
operator|=
name|EAGAIN
expr_stmt|;
name|syserr
argument_list|(
literal|"include: setgroups() failed"
argument_list|)
expr_stmt|;
goto|goto
name|resetuid
goto|;
block|}
block|}
if|if
condition|(
name|gid
operator|!=
literal|0
operator|&&
name|setgid
argument_list|(
name|gid
argument_list|)
operator|<
operator|-
literal|1
condition|)
block|{
name|rval
operator|=
name|EAGAIN
expr_stmt|;
name|syserr
argument_list|(
literal|"setgid(%d) failure"
argument_list|,
name|gid
argument_list|)
expr_stmt|;
goto|goto
name|resetuid
goto|;
block|}
if|if
condition|(
name|uid
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
name|MAILER_SETUID_METHOD
operator|==
name|USE_SETEUID
if|if
condition|(
name|seteuid
argument_list|(
name|uid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rval
operator|=
name|EAGAIN
expr_stmt|;
name|syserr
argument_list|(
literal|"seteuid(%d) failure (real=%d, eff=%d)"
argument_list|,
name|uid
argument_list|,
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|resetuid
goto|;
block|}
endif|#
directive|endif
comment|/* MAILER_SETUID_METHOD == USE_SETEUID */
if|#
directive|if
name|MAILER_SETUID_METHOD
operator|==
name|USE_SETREUID
if|if
condition|(
name|setreuid
argument_list|(
literal|0
argument_list|,
name|uid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rval
operator|=
name|EAGAIN
expr_stmt|;
name|syserr
argument_list|(
literal|"setreuid(0, %d) failure (real=%d, eff=%d)"
argument_list|,
name|uid
argument_list|,
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|resetuid
goto|;
block|}
endif|#
directive|endif
comment|/* MAILER_SETUID_METHOD == USE_SETREUID */
block|}
block|}
endif|#
directive|endif
comment|/* MAILER_SETUID_METHOD != USE_SETUID */
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|9
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"include: new uid = %d/%d\n"
argument_list|,
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* 	**  If home directory is remote mounted but server is down, 	**  this can hang or give errors; use a timeout to avoid this 	*/
if|if
condition|(
name|setjmp
argument_list|(
name|CtxIncludeTimeout
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ctladdr
operator|->
name|q_state
operator|=
name|QS_QUEUEUP
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* return pseudo-error code */
name|rval
operator|=
name|E_SM_OPENTIMEOUT
expr_stmt|;
goto|goto
name|resetuid
goto|;
block|}
if|if
condition|(
name|TimeOuts
operator|.
name|to_fileopen
operator|>
literal|0
condition|)
name|ev
operator|=
name|sm_setevent
argument_list|(
name|TimeOuts
operator|.
name|to_fileopen
argument_list|,
name|includetimeout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ev
operator|=
name|NULL
expr_stmt|;
comment|/* check for writable parent directory */
name|p
operator|=
name|strrchr
argument_list|(
name|fname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|int
name|ret
decl_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|ret
operator|=
name|safedirpath
argument_list|(
name|fname
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|,
name|user
argument_list|,
name|sfflags
operator||
name|SFF_SAFEDIRPATH
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
comment|/* in safe directory: relax chown& link rules */
name|safedir
operator|=
name|true
expr_stmt|;
name|sfflags
operator||=
name|SFF_NOPATHCHECK
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bitnset
argument_list|(
operator|(
name|forwarding
condition|?
name|DBS_FORWARDFILEINUNSAFEDIRPATH
else|:
name|DBS_INCLUDEFILEINUNSAFEDIRPATH
operator|)
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
name|sfflags
operator||=
name|SFF_NOPATHCHECK
expr_stmt|;
elseif|else
if|if
condition|(
name|bitnset
argument_list|(
operator|(
name|forwarding
condition|?
name|DBS_FORWARDFILEINGROUPWRITABLEDIRPATH
else|:
name|DBS_INCLUDEFILEINGROUPWRITABLEDIRPATH
operator|)
argument_list|,
name|DontBlameSendmail
argument_list|)
operator|&&
name|ret
operator|==
name|E_SM_GWDIR
condition|)
block|{
name|setbitn
argument_list|(
name|DBS_GROUPWRITABLEDIRPATHSAFE
argument_list|,
name|DontBlameSendmail
argument_list|)
expr_stmt|;
name|ret
operator|=
name|safedirpath
argument_list|(
name|fname
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|,
name|user
argument_list|,
name|sfflags
operator||
name|SFF_SAFEDIRPATH
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrbitn
argument_list|(
name|DBS_GROUPWRITABLEDIRPATHSAFE
argument_list|,
name|DontBlameSendmail
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|sfflags
operator||=
name|SFF_NOPATHCHECK
expr_stmt|;
else|else
name|sfflags
operator||=
name|SFF_SAFEDIRPATH
expr_stmt|;
block|}
else|else
name|sfflags
operator||=
name|SFF_SAFEDIRPATH
expr_stmt|;
if|if
condition|(
name|ret
operator|>
name|E_PSEUDOBASE
operator|&&
operator|!
name|bitnset
argument_list|(
operator|(
name|forwarding
condition|?
name|DBS_FORWARDFILEINUNSAFEDIRPATHSAFE
else|:
name|DBS_INCLUDEFILEINUNSAFEDIRPATHSAFE
operator|)
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|11
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%s: unsafe directory path, marked unsafe"
argument_list|,
name|shortenstring
argument_list|(
name|fname
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|)
expr_stmt|;
name|ctladdr
operator|->
name|q_flags
operator||=
name|QUNSAFEADDR
expr_stmt|;
block|}
block|}
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
block|}
comment|/* allow links only in unwritable directories */
if|if
condition|(
operator|!
name|safedir
operator|&&
operator|!
name|bitnset
argument_list|(
operator|(
name|forwarding
condition|?
name|DBS_LINKEDFORWARDFILEINWRITABLEDIR
else|:
name|DBS_LINKEDINCLUDEFILEINWRITABLEDIR
operator|)
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
name|sfflags
operator||=
name|SFF_NOLINK
expr_stmt|;
name|rval
operator|=
name|safefile
argument_list|(
name|fname
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|,
name|user
argument_list|,
name|sfflags
argument_list|,
name|S_IREAD
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|!=
literal|0
condition|)
block|{
comment|/* don't use this :include: file */
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|4
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"include: not safe (uid=%d): %s\n"
argument_list|,
operator|(
name|int
operator|)
name|uid
argument_list|,
name|sm_errstring
argument_list|(
name|rval
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fp
operator|=
name|sm_io_open
argument_list|(
name|SmFtStdio
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|fname
argument_list|,
name|SM_IO_RDONLY
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|rval
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|4
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"include: open: %s\n"
argument_list|,
name|sm_errstring
argument_list|(
name|rval
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|filechanged
argument_list|(
name|fname
argument_list|,
name|sm_io_getinfo
argument_list|(
name|fp
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
name|rval
operator|=
name|E_SM_FILECHANGE
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|4
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"include: file changed after open\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ev
operator|!=
name|NULL
condition|)
name|sm_clrevent
argument_list|(
name|ev
argument_list|)
expr_stmt|;
name|resetuid
label|:
if|#
directive|if
name|HASSETREUID
operator|||
name|USESETEUID
if|if
condition|(
name|saveduid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|uid
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
name|USESETEUID
if|if
condition|(
name|seteuid
argument_list|(
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"!seteuid(0) failure (real=%d, eff=%d)"
argument_list|,
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* USESETEUID */
if|if
condition|(
name|setreuid
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"!setreuid(-1, 0) failure (real=%d, eff=%d)"
argument_list|,
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|setreuid
argument_list|(
name|RealUid
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"!setreuid(%d, 0) failure (real=%d, eff=%d)"
argument_list|,
operator|(
name|int
operator|)
name|RealUid
argument_list|,
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USESETEUID */
block|}
if|if
condition|(
name|setgid
argument_list|(
name|savedgid
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"!setgid(%d) failure (real=%d eff=%d)"
argument_list|,
operator|(
name|int
operator|)
name|savedgid
argument_list|,
operator|(
name|int
operator|)
name|getgid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getegid
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HASSETREUID || USESETEUID */
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|9
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"include: reset uid = %d/%d\n"
argument_list|,
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|E_SM_OPENTIMEOUT
condition|)
name|usrerr
argument_list|(
literal|"451 4.4.1 open timeout on %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return
name|rval
return|;
if|if
condition|(
name|fstat
argument_list|(
name|sm_io_getinfo
argument_list|(
name|fp
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rval
operator|=
name|errno
expr_stmt|;
name|syserr
argument_list|(
literal|"Cannot fstat %s!"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|fp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
comment|/* if path was writable, check to avoid file giveaway tricks */
name|safechown
operator|=
name|chownsafe
argument_list|(
name|sm_io_getinfo
argument_list|(
name|fp
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|safedir
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|6
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"include: parent of %s is %s, chown is %ssafe\n"
argument_list|,
name|fname
argument_list|,
name|safedir
condition|?
literal|"safe"
else|:
literal|"dangerous"
argument_list|,
name|safechown
condition|?
literal|""
else|:
literal|"un"
argument_list|)
expr_stmt|;
comment|/* if no controlling user or coming from an alias delivery */
if|if
condition|(
name|safechown
operator|&&
operator|(
name|ca
operator|==
name|NULL
operator|||
operator|(
name|ca
operator|->
name|q_uid
operator|==
name|DefUid
operator|&&
name|ca
operator|->
name|q_gid
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|ctladdr
operator|->
name|q_uid
operator|=
name|st
operator|.
name|st_uid
expr_stmt|;
name|ctladdr
operator|->
name|q_gid
operator|=
name|st
operator|.
name|st_gid
expr_stmt|;
name|ctladdr
operator|->
name|q_flags
operator||=
name|QGOODUID
expr_stmt|;
block|}
if|if
condition|(
name|ca
operator|!=
name|NULL
operator|&&
name|ca
operator|->
name|q_uid
operator|==
name|st
operator|.
name|st_uid
condition|)
block|{
comment|/* optimization -- avoid getpwuid if we already have info */
name|ctladdr
operator|->
name|q_flags
operator||=
name|ca
operator|->
name|q_flags
operator|&
name|QBOGUSSHELL
expr_stmt|;
name|ctladdr
operator|->
name|q_ruser
operator|=
name|ca
operator|->
name|q_ruser
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|forwarding
condition|)
block|{
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|pw
operator|=
name|sm_getpwuid
argument_list|(
name|st
operator|.
name|st_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
block|{
name|ctladdr
operator|->
name|q_uid
operator|=
name|st
operator|.
name|st_uid
expr_stmt|;
name|ctladdr
operator|->
name|q_flags
operator||=
name|QBOGUSSHELL
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|sh
decl_stmt|;
name|ctladdr
operator|->
name|q_ruser
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|safechown
condition|)
name|sh
operator|=
name|pw
operator|->
name|pw_shell
expr_stmt|;
else|else
name|sh
operator|=
literal|"/SENDMAIL/ANY/SHELL/"
expr_stmt|;
if|if
condition|(
operator|!
name|usershellok
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|,
name|sh
argument_list|)
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|11
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%s: user %s has bad shell %s, marked %s"
argument_list|,
name|shortenstring
argument_list|(
name|fname
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
name|sh
argument_list|,
name|safechown
condition|?
literal|"bogus"
else|:
literal|"unsafe"
argument_list|)
expr_stmt|;
if|if
condition|(
name|safechown
condition|)
name|ctladdr
operator|->
name|q_flags
operator||=
name|QBOGUSSHELL
expr_stmt|;
else|else
name|ctladdr
operator|->
name|q_flags
operator||=
name|QUNSAFEADDR
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|bitset
argument_list|(
name|EF_VRFYONLY
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
comment|/* don't do any more now */
name|ctladdr
operator|->
name|q_state
operator|=
name|QS_VERIFIED
expr_stmt|;
name|e
operator|->
name|e_nrcpts
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|fp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
comment|/* 	**  Check to see if some bad guy can write this file 	** 	**	Group write checking could be more clever, e.g., 	**	guessing as to which groups are actually safe ("sys" 	**	may be; "user" probably is not). 	*/
name|mode
operator|=
name|S_IWOTH
expr_stmt|;
if|if
condition|(
operator|!
name|bitnset
argument_list|(
operator|(
name|forwarding
condition|?
name|DBS_GROUPWRITABLEFORWARDFILESAFE
else|:
name|DBS_GROUPWRITABLEINCLUDEFILESAFE
operator|)
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
name|mode
operator||=
name|S_IWGRP
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|mode
argument_list|,
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|6
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"include: %s is %s writable, marked unsafe\n"
argument_list|,
name|shortenstring
argument_list|(
name|fname
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|,
name|bitset
argument_list|(
name|S_IWOTH
argument_list|,
name|st
operator|.
name|st_mode
argument_list|)
condition|?
literal|"world"
else|:
literal|"group"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|11
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%s: %s writable %s file, marked unsafe"
argument_list|,
name|shortenstring
argument_list|(
name|fname
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|,
name|bitset
argument_list|(
name|S_IWOTH
argument_list|,
name|st
operator|.
name|st_mode
argument_list|)
condition|?
literal|"world"
else|:
literal|"group"
argument_list|,
name|forwarding
condition|?
literal|"forward"
else|:
literal|":include:"
argument_list|)
expr_stmt|;
name|ctladdr
operator|->
name|q_flags
operator||=
name|QUNSAFEADDR
expr_stmt|;
block|}
comment|/* read the file -- each line is a comma-separated list. */
name|FileName
operator|=
name|fname
expr_stmt|;
name|LineNumber
operator|=
literal|0
expr_stmt|;
name|ctladdr
operator|->
name|q_flags
operator|&=
operator|~
name|QSELFREF
expr_stmt|;
name|nincludes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sm_io_fgets
argument_list|(
name|fp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|!=
name|NULL
operator|&&
operator|!
name|maxreached
condition|)
block|{
name|fixcrlf
argument_list|(
name|buf
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|LineNumber
operator|++
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'#'
operator|||
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/*<sp>#@# introduces a comment anywhere */
comment|/* for Japanese character sets */
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|(
name|p
operator|=
name|strchr
argument_list|(
operator|++
name|p
argument_list|,
literal|'#'
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'@'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'#'
operator|&&
name|isascii
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
operator|&&
name|isspace
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
operator|&&
operator|(
name|p
index|[
literal|3
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|isascii
argument_list|(
name|p
index|[
literal|3
index|]
argument_list|)
operator|&&
name|isspace
argument_list|(
name|p
index|[
literal|3
index|]
argument_list|)
operator|)
operator|)
condition|)
block|{
operator|--
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|>
name|buf
operator|&&
name|isascii
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
operator|&&
name|isspace
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|--
name|p
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
name|message
argument_list|(
literal|"%s to %s"
argument_list|,
name|forwarding
condition|?
literal|"forwarding"
else|:
literal|"sending"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|forwarding
operator|&&
name|LogLevel
operator|>
literal|10
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"forward %.200s => %s"
argument_list|,
name|oldto
argument_list|,
name|shortenstring
argument_list|(
name|buf
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|)
expr_stmt|;
name|nincludes
operator|+=
name|sendtolist
argument_list|(
name|buf
argument_list|,
name|ctladdr
argument_list|,
name|sendq
argument_list|,
name|aliaslevel
operator|+
literal|1
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|forwarding
operator|&&
name|MaxForwardEntries
operator|>
literal|0
operator|&&
name|nincludes
operator|>=
name|MaxForwardEntries
condition|)
block|{
comment|/* just stop reading and processing further entries */
if|#
directive|if
literal|0
comment|/* additional: (?) */
block|ctladdr->q_state = QS_DONTSEND;
endif|#
directive|endif
comment|/* 0 */
name|syserr
argument_list|(
literal|"Attempt to forward to more than %d addresses (in %s)!"
argument_list|,
name|MaxForwardEntries
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|maxreached
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sm_io_error
argument_list|(
name|fp
argument_list|)
operator|&&
name|tTd
argument_list|(
literal|27
argument_list|,
literal|3
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"include: read error: %s\n"
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nincludes
operator|>
literal|0
operator|&&
operator|!
name|bitset
argument_list|(
name|QSELFREF
argument_list|,
name|ctladdr
operator|->
name|q_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|aliaslevel
operator|<=
name|MaxAliasRecursion
operator|||
name|ctladdr
operator|->
name|q_state
operator|!=
name|QS_BADADDR
condition|)
block|{
name|ctladdr
operator|->
name|q_state
operator|=
name|QS_DONTSEND
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"include: QS_DONTSEND "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|ctladdr
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|fp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
name|FileName
operator|=
name|oldfilename
expr_stmt|;
name|LineNumber
operator|=
name|oldlinenumber
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|oldto
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|includetimeout
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
comment|/* 	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD 	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE 	**	DOING. 	*/
name|errno
operator|=
name|ETIMEDOUT
expr_stmt|;
name|longjmp
argument_list|(
name|CtxIncludeTimeout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  SENDTOARGV -- send to an argument vector. ** **	Parameters: **		argv -- argument vector to send to. **		e -- the current envelope. ** **	Returns: **		none. ** **	Side Effects: **		puts all addresses on the argument vector onto the **			send queue. */
end_comment

begin_function
name|void
name|sendtoargv
parameter_list|(
name|argv
parameter_list|,
name|e
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|argv
operator|++
operator|)
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sendtolist
argument_list|(
name|p
argument_list|,
name|NULLADDR
argument_list|,
operator|&
name|e
operator|->
name|e_sendqueue
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  GETCTLADDR -- get controlling address from an address header. ** **	If none, get one corresponding to the effective userid. ** **	Parameters: **		a -- the address to find the controller of. ** **	Returns: **		the controlling address. */
end_comment

begin_function
name|ADDRESS
modifier|*
name|getctladdr
parameter_list|(
name|a
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
block|{
while|while
condition|(
name|a
operator|!=
name|NULL
operator|&&
operator|!
name|bitset
argument_list|(
name|QGOODUID
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
name|a
operator|=
name|a
operator|->
name|q_alias
expr_stmt|;
return|return
name|a
return|;
block|}
end_function

begin_comment
comment|/* **  SELF_REFERENCE -- check to see if an address references itself ** **	The check is done through a chain of aliases.  If it is part of **	a loop, break the loop at the "best" address, that is, the one **	that exists as a real user. ** **	This is to handle the case of: **		awc:		Andrew.Chang **		Andrew.Chang:	awc@mail.server **	which is a problem only on mail.server. ** **	Parameters: **		a -- the address to check. ** **	Returns: **		The address that should be retained. */
end_comment

begin_function
specifier|static
name|ADDRESS
modifier|*
name|self_reference
parameter_list|(
name|a
parameter_list|)
name|ADDRESS
modifier|*
name|a
decl_stmt|;
block|{
name|ADDRESS
modifier|*
name|b
decl_stmt|;
comment|/* top entry in self ref loop */
name|ADDRESS
modifier|*
name|c
decl_stmt|;
comment|/* entry that point to a real mail box */
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"self_reference(%s)\n"
argument_list|,
name|a
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
name|a
operator|->
name|q_alias
init|;
name|b
operator|!=
name|NULL
condition|;
name|b
operator|=
name|b
operator|->
name|q_alias
control|)
block|{
if|if
condition|(
name|sameaddr
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"\t... no self ref\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 	**  Pick the first address that resolved to a real mail box 	**  i.e has a mbdb entry.  The returned value will be marked 	**  QSELFREF in recipient(), which in turn will disable alias() 	**  from marking it as QS_IS_DEAD(), which mean it will be used 	**  as a deliverable address. 	** 	**  The 2 key thing to note here are: 	**	1) we are in a recursive call sequence: 	**		alias->sendtolist->recipient->alias 	**	2) normally, when we return back to alias(), the address 	**	   will be marked QS_EXPANDED, since alias() assumes the 	**	   expanded form will be used instead of the current address. 	**	   This behaviour is turned off if the address is marked 	**	   QSELFREF.  We set QSELFREF when we return to recipient(). 	*/
name|c
operator|=
name|a
expr_stmt|;
while|while
condition|(
name|c
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"  %s"
argument_list|,
name|c
operator|->
name|q_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitnset
argument_list|(
name|M_HASPWENT
argument_list|,
name|c
operator|->
name|q_mailer
operator|->
name|m_flags
argument_list|)
condition|)
block|{
name|SM_MBDB_T
name|user
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"\t... getpwnam(%s)... "
argument_list|,
name|c
operator|->
name|q_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm_mbdb_lookup
argument_list|(
name|c
operator|->
name|q_user
argument_list|,
operator|&
name|user
argument_list|)
operator|==
name|EX_OK
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"found\n"
argument_list|)
expr_stmt|;
comment|/* ought to cache results here */
if|if
condition|(
name|sameaddr
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
condition|)
return|return
name|b
return|;
else|else
return|return
name|c
return|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"failed\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* if local delivery, compare usernames */
if|if
condition|(
name|bitnset
argument_list|(
name|M_LOCALMAILER
argument_list|,
name|c
operator|->
name|q_mailer
operator|->
name|m_flags
argument_list|)
operator|&&
name|b
operator|->
name|q_mailer
operator|==
name|c
operator|->
name|q_mailer
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"\t... local match (%s)\n"
argument_list|,
name|c
operator|->
name|q_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|sameaddr
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
condition|)
return|return
name|b
return|;
else|else
return|return
name|c
return|;
block|}
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|c
operator|=
name|c
operator|->
name|q_alias
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"\t... cannot break loop for \"%s\"\n"
argument_list|,
name|a
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

end_unit

