begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2006 Sendmail, Inc. and its suppliers.  *	All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_include
include|#
directive|include
file|<sendmail.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: tls.c,v 8.107 2006/10/12 21:35:11 ca Exp $"
argument_list|)
end_macro

begin_if
if|#
directive|if
name|STARTTLS
end_if

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|<openssl/bio.h>
end_include

begin_include
include|#
directive|include
file|<openssl/pem.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HASURANDOMDEV
end_ifndef

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HASURANDOMDEV */
end_comment

begin_if
if|#
directive|if
operator|!
name|TLS_NO_RSA
end_if

begin_decl_stmt
specifier|static
name|RSA
modifier|*
name|rsa_tmp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* temporary RSA key */
end_comment

begin_decl_stmt
specifier|static
name|RSA
modifier|*
name|tmp_rsa_key
name|__P
argument_list|(
operator|(
name|SSL
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !TLS_NO_RSA */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OPENSSL_VERSION_NUMBER
argument_list|)
operator|||
name|OPENSSL_VERSION_NUMBER
operator|<
literal|0x00907000L
end_if

begin_decl_stmt
specifier|static
name|int
name|tls_verify_cb
name|__P
argument_list|(
operator|(
name|X509_STORE_CTX
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !defined() || OPENSSL_VERSION_NUMBER< 0x00907000L */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tls_verify_cb
name|__P
argument_list|(
operator|(
name|X509_STORE_CTX
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined() || OPENSSL_VERSION_NUMBER< 0x00907000L */
end_comment

begin_if
if|#
directive|if
name|OPENSSL_VERSION_NUMBER
operator|>
literal|0x00907000L
end_if

begin_decl_stmt
specifier|static
name|int
name|x509_verify_cb
name|__P
argument_list|(
operator|(
name|int
operator|,
name|X509_STORE_CTX
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL_VERSION_NUMBER> 0x00907000L */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OPENSSL_VERSION_NUMBER
argument_list|)
operator|||
name|OPENSSL_VERSION_NUMBER
operator|<
literal|0x00907000L
end_if

begin_define
define|#
directive|define
name|CONST097
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !defined() || OPENSSL_VERSION_NUMBER< 0x00907000L */
end_comment

begin_define
define|#
directive|define
name|CONST097
value|const
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined() || OPENSSL_VERSION_NUMBER< 0x00907000L */
end_comment

begin_decl_stmt
specifier|static
name|void
name|apps_ssl_info_cb
name|__P
argument_list|(
operator|(
name|CONST097
name|SSL
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|tls_ok_f
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|tls_safe_f
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|long
operator|,
name|bool
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tls_verify_log
name|__P
argument_list|(
operator|(
name|int
operator|,
name|X509_STORE_CTX
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|NO_DH
end_if

begin_decl_stmt
specifier|static
name|DH
modifier|*
name|get_dh512
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|dh512_p
index|[]
init|=
block|{
literal|0xDA
block|,
literal|0x58
block|,
literal|0x3C
block|,
literal|0x16
block|,
literal|0xD9
block|,
literal|0x85
block|,
literal|0x22
block|,
literal|0x89
block|,
literal|0xD0
block|,
literal|0xE4
block|,
literal|0xAF
block|,
literal|0x75
block|,
literal|0x6F
block|,
literal|0x4C
block|,
literal|0xCA
block|,
literal|0x92
block|,
literal|0xDD
block|,
literal|0x4B
block|,
literal|0xE5
block|,
literal|0x33
block|,
literal|0xB8
block|,
literal|0x04
block|,
literal|0xFB
block|,
literal|0x0F
block|,
literal|0xED
block|,
literal|0x94
block|,
literal|0xEF
block|,
literal|0x9C
block|,
literal|0x8A
block|,
literal|0x44
block|,
literal|0x03
block|,
literal|0xED
block|,
literal|0x57
block|,
literal|0x46
block|,
literal|0x50
block|,
literal|0xD3
block|,
literal|0x69
block|,
literal|0x99
block|,
literal|0xDB
block|,
literal|0x29
block|,
literal|0xD7
block|,
literal|0x76
block|,
literal|0x27
block|,
literal|0x6B
block|,
literal|0xA2
block|,
literal|0xD3
block|,
literal|0xD4
block|,
literal|0x12
block|,
literal|0xE2
block|,
literal|0x18
block|,
literal|0xF4
block|,
literal|0xDD
block|,
literal|0x1E
block|,
literal|0x08
block|,
literal|0x4C
block|,
literal|0xF6
block|,
literal|0xD8
block|,
literal|0x00
block|,
literal|0x3E
block|,
literal|0x7C
block|,
literal|0x47
block|,
literal|0x74
block|,
literal|0xE8
block|,
literal|0x33
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|dh512_g
index|[]
init|=
block|{
literal|0x02
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|DH
modifier|*
name|get_dh512
parameter_list|()
block|{
name|DH
modifier|*
name|dh
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|dh
operator|=
name|DH_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|dh
operator|->
name|p
operator|=
name|BN_bin2bn
argument_list|(
name|dh512_p
argument_list|,
sizeof|sizeof
argument_list|(
name|dh512_p
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dh
operator|->
name|g
operator|=
name|BN_bin2bn
argument_list|(
name|dh512_g
argument_list|,
sizeof|sizeof
argument_list|(
name|dh512_g
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dh
operator|->
name|p
operator|==
name|NULL
operator|)
operator|||
operator|(
name|dh
operator|->
name|g
operator|==
name|NULL
operator|)
condition|)
return|return
name|NULL
return|;
return|return
name|dh
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !NO_DH */
end_comment

begin_comment
comment|/* **  TLS_RAND_INIT -- initialize STARTTLS random generator ** **	Parameters: **		randfile -- name of file with random data **		logl -- loglevel ** **	Returns: **		success/failure ** **	Side Effects: **		initializes PRNG for tls library. */
end_comment

begin_define
define|#
directive|define
name|MIN_RAND_BYTES
value|128
end_define

begin_comment
comment|/* 1024 bits */
end_comment

begin_define
define|#
directive|define
name|RF_OK
value|0
end_define

begin_comment
comment|/* randfile OK */
end_comment

begin_define
define|#
directive|define
name|RF_MISS
value|1
end_define

begin_comment
comment|/* randfile == NULL || *randfile == '\0' */
end_comment

begin_define
define|#
directive|define
name|RF_UNKNOWN
value|2
end_define

begin_comment
comment|/* unknown prefix for randfile */
end_comment

begin_define
define|#
directive|define
name|RI_NONE
value|0
end_define

begin_comment
comment|/* no init yet */
end_comment

begin_define
define|#
directive|define
name|RI_SUCCESS
value|1
end_define

begin_comment
comment|/* init was successful */
end_comment

begin_define
define|#
directive|define
name|RI_FAIL
value|2
end_define

begin_comment
comment|/* init failed */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|tls_rand_init
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bool
name|tls_rand_init
parameter_list|(
name|randfile
parameter_list|,
name|logl
parameter_list|)
name|char
modifier|*
name|randfile
decl_stmt|;
name|int
name|logl
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|HASURANDOMDEV
comment|/* not required if /dev/urandom exists, OpenSSL does it internally */
name|bool
name|ok
decl_stmt|;
name|int
name|randdef
decl_stmt|;
specifier|static
name|int
name|done
init|=
name|RI_NONE
decl_stmt|;
comment|/* 	**  initialize PRNG 	*/
comment|/* did we try this before? if yes: return old value */
if|if
condition|(
name|done
operator|!=
name|RI_NONE
condition|)
return|return
name|done
operator|==
name|RI_SUCCESS
return|;
comment|/* set default values */
name|ok
operator|=
name|false
expr_stmt|;
name|done
operator|=
name|RI_FAIL
expr_stmt|;
name|randdef
operator|=
operator|(
name|randfile
operator|==
name|NULL
operator|||
operator|*
name|randfile
operator|==
literal|'\0'
operator|)
condition|?
name|RF_MISS
else|:
name|RF_OK
expr_stmt|;
if|#
directive|if
name|EGD
if|if
condition|(
name|randdef
operator|==
name|RF_OK
operator|&&
name|sm_strncasecmp
argument_list|(
name|randfile
argument_list|,
literal|"egd:"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|randfile
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|RAND_egd
argument_list|(
name|randfile
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS: RAND_egd(%s) failed: random number generator not seeded"
argument_list|,
name|randfile
argument_list|)
expr_stmt|;
block|}
else|else
name|ok
operator|=
name|true
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* EGD */
if|if
condition|(
name|randdef
operator|==
name|RF_OK
operator|&&
name|sm_strncasecmp
argument_list|(
name|randfile
argument_list|,
literal|"file:"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|fd
decl_stmt|;
name|long
name|sff
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|randfile
operator|+=
literal|5
expr_stmt|;
name|sff
operator|=
name|SFF_SAFEDIRPATH
operator||
name|SFF_NOWLINK
operator||
name|SFF_NOGWFILES
operator||
name|SFF_NOWWFILES
operator||
name|SFF_NOGRFILES
operator||
name|SFF_NOWRFILES
operator||
name|SFF_MUSTOWN
operator||
name|SFF_ROOTOK
operator||
name|SFF_OPENASROOT
expr_stmt|;
if|if
condition|(
name|DontLockReadFiles
condition|)
name|sff
operator||=
name|SFF_NOLOCK
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|safeopen
argument_list|(
name|randfile
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
name|sff
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
name|logl
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS: can't fstat(%s)"
argument_list|,
name|randfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bool
name|use
decl_stmt|,
name|problem
decl_stmt|;
name|use
operator|=
name|true
expr_stmt|;
name|problem
operator|=
name|false
expr_stmt|;
comment|/* max. age of file: 10 minutes */
if|if
condition|(
name|st
operator|.
name|st_mtime
operator|+
literal|600
operator|<
name|curtime
argument_list|()
condition|)
block|{
name|use
operator|=
name|bitnset
argument_list|(
name|DBS_INSUFFICIENTENTROPY
argument_list|,
name|DontBlameSendmail
argument_list|)
expr_stmt|;
name|problem
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
name|logl
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS: RandFile %s too old: %s"
argument_list|,
name|randfile
argument_list|,
name|use
condition|?
literal|"unsafe"
else|:
literal|"unusable"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|use
operator|&&
name|st
operator|.
name|st_size
operator|<
name|MIN_RAND_BYTES
condition|)
block|{
name|use
operator|=
name|bitnset
argument_list|(
name|DBS_INSUFFICIENTENTROPY
argument_list|,
name|DontBlameSendmail
argument_list|)
expr_stmt|;
name|problem
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
name|logl
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS: size(%s)< %d: %s"
argument_list|,
name|randfile
argument_list|,
name|MIN_RAND_BYTES
argument_list|,
name|use
condition|?
literal|"unsafe"
else|:
literal|"unusable"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|use
condition|)
name|ok
operator|=
name|RAND_load_file
argument_list|(
name|randfile
argument_list|,
operator|-
literal|1
argument_list|)
operator|>=
name|MIN_RAND_BYTES
expr_stmt|;
if|if
condition|(
name|use
operator|&&
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
name|logl
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS: RAND_load_file(%s) failed: random number generator not seeded"
argument_list|,
name|randfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|problem
condition|)
name|ok
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|ok
operator|||
name|bitnset
argument_list|(
name|DBS_INSUFFICIENTENTROPY
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
block|{
comment|/* add this even if fstat() failed */
name|RAND_seed
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|st
argument_list|,
sizeof|sizeof
argument_list|(
name|st
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LogLevel
operator|>
name|logl
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS: Warning: safeopen(%s) failed"
argument_list|,
name|randfile
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|randdef
operator|==
name|RF_OK
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
name|logl
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS: Error: no proper random file definition %s"
argument_list|,
name|randfile
argument_list|)
expr_stmt|;
name|randdef
operator|=
name|RF_UNKNOWN
expr_stmt|;
block|}
if|if
condition|(
name|randdef
operator|==
name|RF_MISS
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
name|logl
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS: Error: missing random file definition"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
operator|&&
name|bitnset
argument_list|(
name|DBS_INSUFFICIENTENTROPY
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|long
name|r
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
name|MIN_RAND_BYTES
index|]
decl_stmt|;
comment|/* assert((MIN_RAND_BYTES % sizeof(long)) == 0); */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
control|)
block|{
name|r
operator|=
name|get_random
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|buf
operator|+
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|r
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RAND_seed
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
name|logl
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS: Warning: random number generator not properly seeded"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|true
expr_stmt|;
block|}
name|done
operator|=
name|ok
condition|?
name|RI_SUCCESS
else|:
name|RI_FAIL
expr_stmt|;
return|return
name|ok
return|;
else|#
directive|else
comment|/* ! HASURANDOMDEV */
return|return
name|true
return|;
endif|#
directive|endif
comment|/* ! HASURANDOMDEV */
block|}
end_function

begin_comment
comment|/* **  INIT_TLS_LIBRARY -- Calls functions which setup TLS library for global use. ** **	Parameters: **		none. ** **	Returns: **		succeeded? */
end_comment

begin_function
name|bool
name|init_tls_library
parameter_list|()
block|{
comment|/* basic TLS initialization, ignore result for now */
name|SSL_library_init
argument_list|()
expr_stmt|;
name|SSL_load_error_strings
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* this is currently a macro for SSL_library_init */
block|SSLeay_add_ssl_algorithms();
endif|#
directive|endif
comment|/* 0 */
return|return
name|tls_rand_init
argument_list|(
name|RandFile
argument_list|,
literal|7
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  TLS_SET_VERIFY -- request client certificate? ** **	Parameters: **		ctx -- TLS context **		ssl -- TLS structure **		vrfy -- require certificate? ** **	Returns: **		none. ** **	Side Effects: **		Sets verification state for TLS ** # if TLS_VRFY_PER_CTX **	Notice: **		This is per TLS context, not per TLS structure; **		the former is global, the latter per connection. **		It would be nice to do this per connection, but this **		doesn't work in the current TLS libraries :-( # endif * TLS_VRFY_PER_CTX * */
end_comment

begin_function
name|void
name|tls_set_verify
parameter_list|(
name|ctx
parameter_list|,
name|ssl
parameter_list|,
name|vrfy
parameter_list|)
name|SSL_CTX
modifier|*
name|ctx
decl_stmt|;
name|SSL
modifier|*
name|ssl
decl_stmt|;
name|bool
name|vrfy
decl_stmt|;
block|{
if|#
directive|if
operator|!
name|TLS_VRFY_PER_CTX
name|SSL_set_verify
argument_list|(
name|ssl
argument_list|,
name|vrfy
condition|?
name|SSL_VERIFY_PEER
else|:
name|SSL_VERIFY_NONE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !TLS_VRFY_PER_CTX */
name|SSL_CTX_set_verify
argument_list|(
name|ctx
argument_list|,
name|vrfy
condition|?
name|SSL_VERIFY_PEER
else|:
name|SSL_VERIFY_NONE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !TLS_VRFY_PER_CTX */
block|}
end_function

begin_comment
comment|/* **  status in initialization **  these flags keep track of the status of the initialization **  i.e., whether a file exists (_EX) and whether it can be used (_OK) **  [due to permissions] */
end_comment

begin_define
define|#
directive|define
name|TLS_S_NONE
value|0x00000000
end_define

begin_comment
comment|/* none yet */
end_comment

begin_define
define|#
directive|define
name|TLS_S_CERT_EX
value|0x00000001
end_define

begin_comment
comment|/* cert file exists */
end_comment

begin_define
define|#
directive|define
name|TLS_S_CERT_OK
value|0x00000002
end_define

begin_comment
comment|/* cert file is ok */
end_comment

begin_define
define|#
directive|define
name|TLS_S_KEY_EX
value|0x00000004
end_define

begin_comment
comment|/* key file exists */
end_comment

begin_define
define|#
directive|define
name|TLS_S_KEY_OK
value|0x00000008
end_define

begin_comment
comment|/* key file is ok */
end_comment

begin_define
define|#
directive|define
name|TLS_S_CERTP_EX
value|0x00000010
end_define

begin_comment
comment|/* CA cert path exists */
end_comment

begin_define
define|#
directive|define
name|TLS_S_CERTP_OK
value|0x00000020
end_define

begin_comment
comment|/* CA cert path is ok */
end_comment

begin_define
define|#
directive|define
name|TLS_S_CERTF_EX
value|0x00000040
end_define

begin_comment
comment|/* CA cert file exists */
end_comment

begin_define
define|#
directive|define
name|TLS_S_CERTF_OK
value|0x00000080
end_define

begin_comment
comment|/* CA cert file is ok */
end_comment

begin_define
define|#
directive|define
name|TLS_S_CRLF_EX
value|0x00000100
end_define

begin_comment
comment|/* CRL file exists */
end_comment

begin_define
define|#
directive|define
name|TLS_S_CRLF_OK
value|0x00000200
end_define

begin_comment
comment|/* CRL file is ok */
end_comment

begin_if
if|#
directive|if
name|_FFR_TLS_1
end_if

begin_define
define|#
directive|define
name|TLS_S_CERT2_EX
value|0x00001000
end_define

begin_comment
comment|/* 2nd cert file exists */
end_comment

begin_define
define|#
directive|define
name|TLS_S_CERT2_OK
value|0x00002000
end_define

begin_comment
comment|/* 2nd cert file is ok */
end_comment

begin_define
define|#
directive|define
name|TLS_S_KEY2_EX
value|0x00004000
end_define

begin_comment
comment|/* 2nd key file exists */
end_comment

begin_define
define|#
directive|define
name|TLS_S_KEY2_OK
value|0x00008000
end_define

begin_comment
comment|/* 2nd key file is ok */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_TLS_1 */
end_comment

begin_define
define|#
directive|define
name|TLS_S_DH_OK
value|0x00200000
end_define

begin_comment
comment|/* DH cert is ok */
end_comment

begin_define
define|#
directive|define
name|TLS_S_DHPAR_EX
value|0x00400000
end_define

begin_comment
comment|/* DH param file exists */
end_comment

begin_define
define|#
directive|define
name|TLS_S_DHPAR_OK
value|0x00800000
end_define

begin_comment
comment|/* DH param file is ok to use */
end_comment

begin_comment
comment|/* Type of variable */
end_comment

begin_define
define|#
directive|define
name|TLS_T_OTHER
value|0
end_define

begin_define
define|#
directive|define
name|TLS_T_SRV
value|1
end_define

begin_define
define|#
directive|define
name|TLS_T_CLT
value|2
end_define

begin_comment
comment|/* **  TLS_OK_F -- can var be an absolute filename? ** **	Parameters: **		var -- filename **		fn -- what is the filename used for? **		type -- type of variable ** **	Returns: **		ok? */
end_comment

begin_function
specifier|static
name|bool
name|tls_ok_f
parameter_list|(
name|var
parameter_list|,
name|fn
parameter_list|,
name|type
parameter_list|)
name|char
modifier|*
name|var
decl_stmt|;
name|char
modifier|*
name|fn
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
comment|/* must be absolute pathname */
if|if
condition|(
name|var
operator|!=
name|NULL
operator|&&
operator|*
name|var
operator|==
literal|'/'
condition|)
return|return
name|true
return|;
if|if
condition|(
name|LogLevel
operator|>
literal|12
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS: %s%s missing"
argument_list|,
name|type
operator|==
name|TLS_T_SRV
condition|?
literal|"Server"
else|:
operator|(
name|type
operator|==
name|TLS_T_CLT
condition|?
literal|"Client"
else|:
literal|""
operator|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* **  TLS_SAFE_F -- is a file safe to use? ** **	Parameters: **		var -- filename **		sff -- flags for safefile() **		srv -- server side? ** **	Returns: **		ok? */
end_comment

begin_function
specifier|static
name|bool
name|tls_safe_f
parameter_list|(
name|var
parameter_list|,
name|sff
parameter_list|,
name|srv
parameter_list|)
name|char
modifier|*
name|var
decl_stmt|;
name|long
name|sff
decl_stmt|;
name|bool
name|srv
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|safefile
argument_list|(
name|var
argument_list|,
name|RunAsUid
argument_list|,
name|RunAsGid
argument_list|,
name|RunAsUserName
argument_list|,
name|sff
argument_list|,
name|S_IRUSR
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|LogLevel
operator|>
literal|7
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=%s: file %s unsafe: %s"
argument_list|,
name|srv
condition|?
literal|"server"
else|:
literal|"client"
argument_list|,
name|var
argument_list|,
name|sm_errstring
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* **  TLS_OK_F -- macro to simplify calls to tls_ok_f ** **	Parameters: **		var -- filename **		fn -- what is the filename used for? **		req -- is the file required? **		st -- status bit to set if ok **		type -- type of variable ** **	Side Effects: **		uses r, ok; may change ok and status. ** */
end_comment

begin_define
define|#
directive|define
name|TLS_OK_F
parameter_list|(
name|var
parameter_list|,
name|fn
parameter_list|,
name|req
parameter_list|,
name|st
parameter_list|,
name|type
parameter_list|)
value|if (ok) \ 	{ \ 		r = tls_ok_f(var, fn, type); \ 		if (r) \ 			status |= st; \ 		else if (req) \ 			ok = false; \ 	}
end_define

begin_comment
comment|/* **  TLS_UNR -- macro to return whether a file should be unreadable ** **	Parameters: **		bit -- flag to test **		req -- flags ** **	Returns: **		0/SFF_NORFILES */
end_comment

begin_define
define|#
directive|define
name|TLS_UNR
parameter_list|(
name|bit
parameter_list|,
name|req
parameter_list|)
value|(bitset(bit, req) ? SFF_NORFILES : 0)
end_define

begin_define
define|#
directive|define
name|TLS_OUNR
parameter_list|(
name|bit
parameter_list|,
name|req
parameter_list|)
value|(bitset(bit, req) ? SFF_NOWRFILES : 0)
end_define

begin_define
define|#
directive|define
name|TLS_KEYSFF
parameter_list|(
name|req
parameter_list|)
define|\
value|(bitnset(DBS_GROUPREADABLEKEYFILE, DontBlameSendmail) ?	\ 		TLS_OUNR(TLS_I_KEY_OUNR, req) :			\ 		TLS_UNR(TLS_I_KEY_UNR, req))
end_define

begin_comment
comment|/* **  TLS_SAFE_F -- macro to simplify calls to tls_safe_f ** **	Parameters: **		var -- filename **		sff -- flags for safefile() **		req -- is the file required? **		ex -- does the file exist? **		st -- status bit to set if ok **		srv -- server side? ** **	Side Effects: **		uses r, ok, ex; may change ok and status. ** */
end_comment

begin_define
define|#
directive|define
name|TLS_SAFE_F
parameter_list|(
name|var
parameter_list|,
name|sff
parameter_list|,
name|req
parameter_list|,
name|ex
parameter_list|,
name|st
parameter_list|,
name|srv
parameter_list|)
value|if (ex&& ok) \ 	{ \ 		r = tls_safe_f(var, sff, srv); \ 		if (r) \ 			status |= st;	\ 		else if (req) \ 			ok = false;	\ 	}
end_define

begin_comment
comment|/* **  INITTLS -- initialize TLS ** **	Parameters: **		ctx -- pointer to context **		req -- requirements for initialization (see sendmail.h) **		srv -- server side? **		certfile -- filename of certificate **		keyfile -- filename of private key **		cacertpath -- path to CAs **		cacertfile -- file with CA(s) **		dhparam -- parameters for DH ** **	Returns: **		succeeded? */
end_comment

begin_comment
comment|/* **  The session_id_context identifies the service that created a session. **  This information is used to distinguish between multiple TLS-based **  servers running on the same server. We use the name of the mail system. **  Note: the session cache is not persistent. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|server_session_id_context
index|[]
init|=
literal|"sendmail8"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0.9.8a and b have a problem with SSL_OP_TLS_BLOCK_PADDING_BUG */
end_comment

begin_if
if|#
directive|if
operator|(
name|OPENSSL_VERSION_NUMBER
operator|>=
literal|0x0090800fL
operator|)
end_if

begin_define
define|#
directive|define
name|SM_SSL_OP_TLS_BLOCK_PADDING_BUG
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SM_SSL_OP_TLS_BLOCK_PADDING_BUG
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|bool
name|inittls
parameter_list|(
name|ctx
parameter_list|,
name|req
parameter_list|,
name|srv
parameter_list|,
name|certfile
parameter_list|,
name|keyfile
parameter_list|,
name|cacertpath
parameter_list|,
name|cacertfile
parameter_list|,
name|dhparam
parameter_list|)
name|SSL_CTX
modifier|*
modifier|*
name|ctx
decl_stmt|;
name|unsigned
name|long
name|req
decl_stmt|;
name|bool
name|srv
decl_stmt|;
name|char
modifier|*
name|certfile
decl_stmt|,
decl|*
name|keyfile
decl_stmt|,
modifier|*
name|cacertpath
decl_stmt|,
modifier|*
name|cacertfile
decl_stmt|,
modifier|*
name|dhparam
decl_stmt|;
end_function

begin_block
block|{
if|#
directive|if
operator|!
name|NO_DH
specifier|static
name|DH
modifier|*
name|dh
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* !NO_DH */
name|int
name|r
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|long
name|sff
decl_stmt|,
name|status
decl_stmt|,
name|options
decl_stmt|;
name|char
modifier|*
name|who
decl_stmt|;
if|#
directive|if
name|_FFR_TLS_1
name|char
modifier|*
name|cf2
decl_stmt|,
modifier|*
name|kf2
decl_stmt|;
endif|#
directive|endif
comment|/* _FFR_TLS_1 */
if|#
directive|if
name|SM_CONF_SHM
specifier|extern
name|int
name|ShmId
decl_stmt|;
endif|#
directive|endif
comment|/* SM_CONF_SHM */
if|#
directive|if
name|OPENSSL_VERSION_NUMBER
operator|>
literal|0x00907000L
name|BIO
modifier|*
name|crl_file
decl_stmt|;
name|X509_CRL
modifier|*
name|crl
decl_stmt|;
name|X509_STORE
modifier|*
name|store
decl_stmt|;
endif|#
directive|endif
comment|/* OPENSSL_VERSION_NUMBER> 0x00907000L */
if|#
directive|if
name|SM_SSL_OP_TLS_BLOCK_PADDING_BUG
name|long
name|rt_version
decl_stmt|;
name|STACK_OF
argument_list|(
name|SSL_COMP
argument_list|)
operator|*
name|comp_methods
expr_stmt|;
endif|#
directive|endif
name|status
operator|=
name|TLS_S_NONE
expr_stmt|;
name|who
operator|=
name|srv
condition|?
literal|"server"
else|:
literal|"client"
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"STARTTLS=%s, inittls: ctx == NULL"
argument_list|,
name|who
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|SM_ASSERT
argument_list|(
name|ctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* already initialized? (we could re-init...) */
if|if
condition|(
operator|*
name|ctx
operator|!=
name|NULL
condition|)
return|return
name|true
return|;
name|ok
operator|=
name|true
expr_stmt|;
if|#
directive|if
name|_FFR_TLS_1
comment|/* 	**  look for a second filename: it must be separated by a ',' 	**  no blanks allowed (they won't be skipped). 	**  we change a global variable here! this change will be undone 	**  before return from the function but only if it returns true. 	**  this isn't a problem since in a failure case this function 	**  won't be called again with the same (overwritten) values. 	**  otherwise each return must be replaced with a goto endinittls. 	*/
name|cf2
operator|=
name|NULL
expr_stmt|;
name|kf2
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|certfile
operator|!=
name|NULL
operator|&&
operator|(
name|cf2
operator|=
name|strchr
argument_list|(
name|certfile
argument_list|,
literal|','
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cf2
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|keyfile
operator|!=
name|NULL
operator|&&
operator|(
name|kf2
operator|=
name|strchr
argument_list|(
name|keyfile
argument_list|,
literal|','
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|kf2
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _FFR_TLS_1 */
comment|/* 	**  Check whether files/paths are defined 	*/
name|TLS_OK_F
argument_list|(
name|certfile
argument_list|,
literal|"CertFile"
argument_list|,
name|bitset
argument_list|(
name|TLS_I_CERT_EX
argument_list|,
name|req
argument_list|)
argument_list|,
name|TLS_S_CERT_EX
argument_list|,
name|srv
condition|?
name|TLS_T_SRV
else|:
name|TLS_T_CLT
argument_list|)
expr_stmt|;
name|TLS_OK_F
argument_list|(
name|keyfile
argument_list|,
literal|"KeyFile"
argument_list|,
name|bitset
argument_list|(
name|TLS_I_KEY_EX
argument_list|,
name|req
argument_list|)
argument_list|,
name|TLS_S_KEY_EX
argument_list|,
name|srv
condition|?
name|TLS_T_SRV
else|:
name|TLS_T_CLT
argument_list|)
expr_stmt|;
name|TLS_OK_F
argument_list|(
name|cacertpath
argument_list|,
literal|"CACertPath"
argument_list|,
name|bitset
argument_list|(
name|TLS_I_CERTP_EX
argument_list|,
name|req
argument_list|)
argument_list|,
name|TLS_S_CERTP_EX
argument_list|,
name|TLS_T_OTHER
argument_list|)
expr_stmt|;
name|TLS_OK_F
argument_list|(
name|cacertfile
argument_list|,
literal|"CACertFile"
argument_list|,
name|bitset
argument_list|(
name|TLS_I_CERTF_EX
argument_list|,
name|req
argument_list|)
argument_list|,
name|TLS_S_CERTF_EX
argument_list|,
name|TLS_T_OTHER
argument_list|)
expr_stmt|;
if|#
directive|if
name|OPENSSL_VERSION_NUMBER
operator|>
literal|0x00907000L
name|TLS_OK_F
argument_list|(
name|CRLFile
argument_list|,
literal|"CRLFile"
argument_list|,
name|bitset
argument_list|(
name|TLS_I_CRLF_EX
argument_list|,
name|req
argument_list|)
argument_list|,
name|TLS_S_CRLF_EX
argument_list|,
name|TLS_T_OTHER
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL_VERSION_NUMBER> 0x00907000L */
if|#
directive|if
name|_FFR_TLS_1
comment|/* 	**  if the second file is specified it must exist 	**  XXX: it is possible here to define only one of those files 	*/
if|if
condition|(
name|cf2
operator|!=
name|NULL
condition|)
block|{
name|TLS_OK_F
argument_list|(
name|cf2
argument_list|,
literal|"CertFile"
argument_list|,
name|bitset
argument_list|(
name|TLS_I_CERT_EX
argument_list|,
name|req
argument_list|)
argument_list|,
name|TLS_S_CERT2_EX
argument_list|,
name|srv
condition|?
name|TLS_T_SRV
else|:
name|TLS_T_CLT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kf2
operator|!=
name|NULL
condition|)
block|{
name|TLS_OK_F
argument_list|(
name|kf2
argument_list|,
literal|"KeyFile"
argument_list|,
name|bitset
argument_list|(
name|TLS_I_KEY_EX
argument_list|,
name|req
argument_list|)
argument_list|,
name|TLS_S_KEY2_EX
argument_list|,
name|srv
condition|?
name|TLS_T_SRV
else|:
name|TLS_T_CLT
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _FFR_TLS_1 */
comment|/* 	**  valid values for dhparam are (only the first char is checked) 	**  none	no parameters: don't use DH 	**  512		generate 512 bit parameters (fixed) 	**  1024	generate 1024 bit parameters 	**  /file/name	read parameters from /file/name 	**  default is: 1024 for server, 512 for client (OK? XXX) 	*/
if|if
condition|(
name|bitset
argument_list|(
name|TLS_I_TRY_DH
argument_list|,
name|req
argument_list|)
condition|)
block|{
if|if
condition|(
name|dhparam
operator|!=
name|NULL
condition|)
block|{
name|char
name|c
init|=
operator|*
name|dhparam
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'1'
condition|)
name|req
operator||=
name|TLS_I_DH1024
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'5'
condition|)
name|req
operator||=
name|TLS_I_DH512
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'n'
operator|&&
name|c
operator|!=
literal|'N'
operator|&&
name|c
operator|!=
literal|'/'
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|12
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=%s, error: illegal value '%s' for DHParam"
argument_list|,
name|who
argument_list|,
name|dhparam
argument_list|)
expr_stmt|;
name|dhparam
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dhparam
operator|==
name|NULL
condition|)
name|dhparam
operator|=
name|srv
condition|?
literal|"1"
else|:
literal|"5"
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|dhparam
operator|==
literal|'/'
condition|)
block|{
name|TLS_OK_F
argument_list|(
name|dhparam
argument_list|,
literal|"DHParameters"
argument_list|,
name|bitset
argument_list|(
name|TLS_I_DHPAR_EX
argument_list|,
name|req
argument_list|)
argument_list|,
name|TLS_S_DHPAR_EX
argument_list|,
name|TLS_T_OTHER
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|ok
return|;
comment|/* certfile etc. must be "safe". */
name|sff
operator|=
name|SFF_REGONLY
operator||
name|SFF_SAFEDIRPATH
operator||
name|SFF_NOWLINK
operator||
name|SFF_NOGWFILES
operator||
name|SFF_NOWWFILES
operator||
name|SFF_MUSTOWN
operator||
name|SFF_ROOTOK
operator||
name|SFF_OPENASROOT
expr_stmt|;
if|if
condition|(
name|DontLockReadFiles
condition|)
name|sff
operator||=
name|SFF_NOLOCK
expr_stmt|;
name|TLS_SAFE_F
argument_list|(
name|certfile
argument_list|,
name|sff
operator||
name|TLS_UNR
argument_list|(
name|TLS_I_CERT_UNR
argument_list|,
name|req
argument_list|)
argument_list|,
name|bitset
argument_list|(
name|TLS_I_CERT_EX
argument_list|,
name|req
argument_list|)
argument_list|,
name|bitset
argument_list|(
name|TLS_S_CERT_EX
argument_list|,
name|status
argument_list|)
argument_list|,
name|TLS_S_CERT_OK
argument_list|,
name|srv
argument_list|)
expr_stmt|;
name|TLS_SAFE_F
argument_list|(
name|keyfile
argument_list|,
name|sff
operator||
name|TLS_KEYSFF
argument_list|(
name|req
argument_list|)
argument_list|,
name|bitset
argument_list|(
name|TLS_I_KEY_EX
argument_list|,
name|req
argument_list|)
argument_list|,
name|bitset
argument_list|(
name|TLS_S_KEY_EX
argument_list|,
name|status
argument_list|)
argument_list|,
name|TLS_S_KEY_OK
argument_list|,
name|srv
argument_list|)
expr_stmt|;
name|TLS_SAFE_F
argument_list|(
name|cacertfile
argument_list|,
name|sff
operator||
name|TLS_UNR
argument_list|(
name|TLS_I_CERTF_UNR
argument_list|,
name|req
argument_list|)
argument_list|,
name|bitset
argument_list|(
name|TLS_I_CERTF_EX
argument_list|,
name|req
argument_list|)
argument_list|,
name|bitset
argument_list|(
name|TLS_S_CERTF_EX
argument_list|,
name|status
argument_list|)
argument_list|,
name|TLS_S_CERTF_OK
argument_list|,
name|srv
argument_list|)
expr_stmt|;
name|TLS_SAFE_F
argument_list|(
name|dhparam
argument_list|,
name|sff
operator||
name|TLS_UNR
argument_list|(
name|TLS_I_DHPAR_UNR
argument_list|,
name|req
argument_list|)
argument_list|,
name|bitset
argument_list|(
name|TLS_I_DHPAR_EX
argument_list|,
name|req
argument_list|)
argument_list|,
name|bitset
argument_list|(
name|TLS_S_DHPAR_EX
argument_list|,
name|status
argument_list|)
argument_list|,
name|TLS_S_DHPAR_OK
argument_list|,
name|srv
argument_list|)
expr_stmt|;
if|#
directive|if
name|OPENSSL_VERSION_NUMBER
operator|>
literal|0x00907000L
name|TLS_SAFE_F
argument_list|(
name|CRLFile
argument_list|,
name|sff
operator||
name|TLS_UNR
argument_list|(
name|TLS_I_CRLF_UNR
argument_list|,
name|req
argument_list|)
argument_list|,
name|bitset
argument_list|(
name|TLS_I_CRLF_EX
argument_list|,
name|req
argument_list|)
argument_list|,
name|bitset
argument_list|(
name|TLS_S_CRLF_EX
argument_list|,
name|status
argument_list|)
argument_list|,
name|TLS_S_CRLF_OK
argument_list|,
name|srv
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OPENSSL_VERSION_NUMBER> 0x00907000L */
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|ok
return|;
if|#
directive|if
name|_FFR_TLS_1
if|if
condition|(
name|cf2
operator|!=
name|NULL
condition|)
block|{
name|TLS_SAFE_F
argument_list|(
name|cf2
argument_list|,
name|sff
operator||
name|TLS_UNR
argument_list|(
name|TLS_I_CERT_UNR
argument_list|,
name|req
argument_list|)
argument_list|,
name|bitset
argument_list|(
name|TLS_I_CERT_EX
argument_list|,
name|req
argument_list|)
argument_list|,
name|bitset
argument_list|(
name|TLS_S_CERT2_EX
argument_list|,
name|status
argument_list|)
argument_list|,
name|TLS_S_CERT2_OK
argument_list|,
name|srv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kf2
operator|!=
name|NULL
condition|)
block|{
name|TLS_SAFE_F
argument_list|(
name|kf2
argument_list|,
name|sff
operator||
name|TLS_KEYSFF
argument_list|(
name|req
argument_list|)
argument_list|,
name|bitset
argument_list|(
name|TLS_I_KEY_EX
argument_list|,
name|req
argument_list|)
argument_list|,
name|bitset
argument_list|(
name|TLS_S_KEY2_EX
argument_list|,
name|status
argument_list|)
argument_list|,
name|TLS_S_KEY2_OK
argument_list|,
name|srv
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _FFR_TLS_1 */
comment|/* create a method and a new context */
if|if
condition|(
operator|(
operator|*
name|ctx
operator|=
name|SSL_CTX_new
argument_list|(
name|srv
condition|?
name|SSLv23_server_method
argument_list|()
else|:
name|SSLv23_client_method
argument_list|()
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|7
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=%s, error: SSL_CTX_new(SSLv23_%s_method()) failed"
argument_list|,
name|who
argument_list|,
name|who
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|tlslogerr
argument_list|(
name|who
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|#
directive|if
name|OPENSSL_VERSION_NUMBER
operator|>
literal|0x00907000L
if|if
condition|(
name|CRLFile
operator|!=
name|NULL
condition|)
block|{
comment|/* get a pointer to the current certificate validation store */
name|store
operator|=
name|SSL_CTX_get_cert_store
argument_list|(
operator|*
name|ctx
argument_list|)
expr_stmt|;
comment|/* does not fail */
name|crl_file
operator|=
name|BIO_new
argument_list|(
name|BIO_s_file_internal
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|crl_file
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|BIO_read_filename
argument_list|(
name|crl_file
argument_list|,
name|CRLFile
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|crl
operator|=
name|PEM_read_bio_X509_CRL
argument_list|(
name|crl_file
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|BIO_free
argument_list|(
name|crl_file
argument_list|)
expr_stmt|;
name|X509_STORE_add_crl
argument_list|(
name|store
argument_list|,
name|crl
argument_list|)
expr_stmt|;
name|X509_CRL_free
argument_list|(
name|crl
argument_list|)
expr_stmt|;
name|X509_STORE_set_flags
argument_list|(
name|store
argument_list|,
name|X509_V_FLAG_CRL_CHECK
operator||
name|X509_V_FLAG_CRL_CHECK_ALL
argument_list|)
expr_stmt|;
name|X509_STORE_set_verify_cb_func
argument_list|(
name|store
argument_list|,
name|x509_verify_cb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=%s, error: PEM_read_bio_X509_CRL(%s)=failed"
argument_list|,
name|who
argument_list|,
name|CRLFile
argument_list|)
expr_stmt|;
block|}
comment|/* avoid memory leaks */
name|BIO_free
argument_list|(
name|crl_file
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=%s, error: BIO_new=failed"
argument_list|,
name|who
argument_list|)
expr_stmt|;
block|}
else|else
name|store
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|_FFR_CRLPATH
if|if
condition|(
name|CRLPath
operator|!=
name|NULL
operator|&&
name|store
operator|!=
name|NULL
condition|)
block|{
name|X509_LOOKUP
modifier|*
name|lookup
decl_stmt|;
name|lookup
operator|=
name|X509_STORE_add_lookup
argument_list|(
name|store
argument_list|,
name|X509_LOOKUP_hash_dir
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=%s, error: X509_STORE_add_lookup(hash)=failed"
argument_list|,
name|who
argument_list|,
name|CRLFile
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
name|X509_LOOKUP_add_dir
argument_list|(
name|lookup
argument_list|,
name|CRLPath
argument_list|,
name|X509_FILETYPE_PEM
argument_list|)
expr_stmt|;
name|X509_STORE_set_flags
argument_list|(
name|store
argument_list|,
name|X509_V_FLAG_CRL_CHECK
operator||
name|X509_V_FLAG_CRL_CHECK_ALL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _FFR_CRLPATH */
endif|#
directive|endif
comment|/* OPENSSL_VERSION_NUMBER> 0x00907000L */
if|#
directive|if
name|TLS_NO_RSA
comment|/* turn off backward compatibility, required for no-rsa */
name|SSL_CTX_set_options
argument_list|(
operator|*
name|ctx
argument_list|,
name|SSL_OP_NO_SSLv2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TLS_NO_RSA */
if|#
directive|if
operator|!
name|TLS_NO_RSA
comment|/* 	**  Create a temporary RSA key 	**  XXX  Maybe we shouldn't create this always (even though it 	**  is only at startup). 	**  It is a time-consuming operation and it is not always necessary. 	**  maybe we should do it only on demand... 	*/
if|if
condition|(
name|bitset
argument_list|(
name|TLS_I_RSA_TMP
argument_list|,
name|req
argument_list|)
if|#
directive|if
name|SM_CONF_SHM
operator|&&
name|ShmId
operator|!=
name|SM_SHM_NO_ID
operator|&&
operator|(
name|rsa_tmp
operator|=
name|RSA_generate_key
argument_list|(
name|RSA_KEYLENGTH
argument_list|,
name|RSA_F4
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
else|#
directive|else
comment|/* SM_CONF_SHM */
operator|&&
literal|0
comment|/* no shared memory: no need to generate key now */
endif|#
directive|endif
comment|/* SM_CONF_SHM */
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|7
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=%s, error: RSA_generate_key failed"
argument_list|,
name|who
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|tlslogerr
argument_list|(
name|who
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
endif|#
directive|endif
comment|/* !TLS_NO_RSA */
comment|/* 	**  load private key 	**  XXX change this for DSA-only version 	*/
if|if
condition|(
name|bitset
argument_list|(
name|TLS_S_KEY_OK
argument_list|,
name|status
argument_list|)
operator|&&
name|SSL_CTX_use_PrivateKey_file
argument_list|(
operator|*
name|ctx
argument_list|,
name|keyfile
argument_list|,
name|SSL_FILETYPE_PEM
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|7
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=%s, error: SSL_CTX_use_PrivateKey_file(%s) failed"
argument_list|,
name|who
argument_list|,
name|keyfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|tlslogerr
argument_list|(
name|who
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|TLS_I_USE_KEY
argument_list|,
name|req
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* get the certificate file */
if|if
condition|(
name|bitset
argument_list|(
name|TLS_S_CERT_OK
argument_list|,
name|status
argument_list|)
operator|&&
name|SSL_CTX_use_certificate_file
argument_list|(
operator|*
name|ctx
argument_list|,
name|certfile
argument_list|,
name|SSL_FILETYPE_PEM
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|7
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=%s, error: SSL_CTX_use_certificate_file(%s) failed"
argument_list|,
name|who
argument_list|,
name|certfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|tlslogerr
argument_list|(
name|who
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|TLS_I_USE_CERT
argument_list|,
name|req
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* check the private key */
if|if
condition|(
name|bitset
argument_list|(
name|TLS_S_KEY_OK
argument_list|,
name|status
argument_list|)
operator|&&
operator|(
name|r
operator|=
name|SSL_CTX_check_private_key
argument_list|(
operator|*
name|ctx
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
comment|/* Private key does not match the certificate public key */
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=%s, error: SSL_CTX_check_private_key failed(%s): %d"
argument_list|,
name|who
argument_list|,
name|keyfile
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|tlslogerr
argument_list|(
name|who
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|TLS_I_USE_KEY
argument_list|,
name|req
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|#
directive|if
name|_FFR_TLS_1
comment|/* XXX this code is pretty much duplicated from above! */
comment|/* load private key */
if|if
condition|(
name|bitset
argument_list|(
name|TLS_S_KEY2_OK
argument_list|,
name|status
argument_list|)
operator|&&
name|SSL_CTX_use_PrivateKey_file
argument_list|(
operator|*
name|ctx
argument_list|,
name|kf2
argument_list|,
name|SSL_FILETYPE_PEM
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|7
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=%s, error: SSL_CTX_use_PrivateKey_file(%s) failed"
argument_list|,
name|who
argument_list|,
name|kf2
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|tlslogerr
argument_list|(
name|who
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* get the certificate file */
if|if
condition|(
name|bitset
argument_list|(
name|TLS_S_CERT2_OK
argument_list|,
name|status
argument_list|)
operator|&&
name|SSL_CTX_use_certificate_file
argument_list|(
operator|*
name|ctx
argument_list|,
name|cf2
argument_list|,
name|SSL_FILETYPE_PEM
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|7
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=%s, error: SSL_CTX_use_certificate_file(%s) failed"
argument_list|,
name|who
argument_list|,
name|cf2
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|tlslogerr
argument_list|(
name|who
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* also check the private key */
if|if
condition|(
name|bitset
argument_list|(
name|TLS_S_KEY2_OK
argument_list|,
name|status
argument_list|)
operator|&&
operator|(
name|r
operator|=
name|SSL_CTX_check_private_key
argument_list|(
operator|*
name|ctx
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
comment|/* Private key does not match the certificate public key */
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=%s, error: SSL_CTX_check_private_key 2 failed: %d"
argument_list|,
name|who
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|tlslogerr
argument_list|(
name|who
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* _FFR_TLS_1 */
comment|/* SSL_CTX_set_quiet_shutdown(*ctx, 1); violation of standard? */
name|options
operator|=
name|SSL_OP_ALL
expr_stmt|;
comment|/* bug compatibility? */
if|#
directive|if
name|SM_SSL_OP_TLS_BLOCK_PADDING_BUG
comment|/* 	**  In OpenSSL 0.9.8[ab], enabling zlib compression breaks the 	**  padding bug work-around, leading to false positives and 	**  failed connections. We may not interoperate with systems 	**  with the bug, but this is better than breaking on all 0.9.8[ab] 	**  systems that have zlib support enabled. 	**  Note: this checks the runtime version of the library, not 	**  just the compile time version. 	*/
name|rt_version
operator|=
name|SSLeay
argument_list|()
expr_stmt|;
if|if
condition|(
name|rt_version
operator|>=
literal|0x00908000L
operator|&&
name|rt_version
operator|<=
literal|0x0090802fL
condition|)
block|{
name|comp_methods
operator|=
name|SSL_COMP_get_compression_methods
argument_list|()
expr_stmt|;
if|if
condition|(
name|comp_methods
operator|!=
name|NULL
operator|&&
name|sk_SSL_COMP_num
argument_list|(
name|comp_methods
argument_list|)
operator|>
literal|0
condition|)
name|options
operator|&=
operator|~
name|SSL_OP_TLS_BLOCK_PADDING_BUG
expr_stmt|;
block|}
endif|#
directive|endif
name|SSL_CTX_set_options
argument_list|(
operator|*
name|ctx
argument_list|,
name|options
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|NO_DH
comment|/* Diffie-Hellman initialization */
if|if
condition|(
name|bitset
argument_list|(
name|TLS_I_TRY_DH
argument_list|,
name|req
argument_list|)
condition|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|TLS_S_DHPAR_OK
argument_list|,
name|status
argument_list|)
condition|)
block|{
name|BIO
modifier|*
name|bio
decl_stmt|;
if|if
condition|(
operator|(
name|bio
operator|=
name|BIO_new_file
argument_list|(
name|dhparam
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dh
operator|=
name|PEM_read_bio_DHparams
argument_list|(
name|bio
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|BIO_free
argument_list|(
name|bio
argument_list|)
expr_stmt|;
if|if
condition|(
name|dh
operator|==
name|NULL
operator|&&
name|LogLevel
operator|>
literal|7
condition|)
block|{
name|unsigned
name|long
name|err
decl_stmt|;
name|err
operator|=
name|ERR_get_error
argument_list|()
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=%s, error: cannot read DH parameters(%s): %s"
argument_list|,
name|who
argument_list|,
name|dhparam
argument_list|,
name|ERR_error_string
argument_list|(
name|err
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|tlslogerr
argument_list|(
name|who
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=%s, error: BIO_new_file(%s) failed"
argument_list|,
name|who
argument_list|,
name|dhparam
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|tlslogerr
argument_list|(
name|who
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|dh
operator|==
name|NULL
operator|&&
name|bitset
argument_list|(
name|TLS_I_DH1024
argument_list|,
name|req
argument_list|)
condition|)
block|{
name|DSA
modifier|*
name|dsa
decl_stmt|;
comment|/* this takes a while! (7-130s on a 450MHz AMD K6-2) */
name|dsa
operator|=
name|DSA_generate_parameters
argument_list|(
literal|1024
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dh
operator|=
name|DSA_dup_DH
argument_list|(
name|dsa
argument_list|)
expr_stmt|;
name|DSA_free
argument_list|(
name|dsa
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dh
operator|==
name|NULL
operator|&&
name|bitset
argument_list|(
name|TLS_I_DH512
argument_list|,
name|req
argument_list|)
condition|)
name|dh
operator|=
name|get_dh512
argument_list|()
expr_stmt|;
if|if
condition|(
name|dh
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
block|{
name|unsigned
name|long
name|err
decl_stmt|;
name|err
operator|=
name|ERR_get_error
argument_list|()
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=%s, error: cannot read or set DH parameters(%s): %s"
argument_list|,
name|who
argument_list|,
name|dhparam
argument_list|,
name|ERR_error_string
argument_list|(
name|err
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|TLS_I_REQ_DH
argument_list|,
name|req
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
name|SSL_CTX_set_tmp_dh
argument_list|(
operator|*
name|ctx
argument_list|,
name|dh
argument_list|)
expr_stmt|;
comment|/* important to avoid small subgroup attacks */
name|SSL_CTX_set_options
argument_list|(
operator|*
name|ctx
argument_list|,
name|SSL_OP_SINGLE_DH_USE
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|13
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=%s, Diffie-Hellman init, key=%d bit (%c)"
argument_list|,
name|who
argument_list|,
literal|8
operator|*
name|DH_size
argument_list|(
name|dh
argument_list|)
argument_list|,
operator|*
name|dhparam
argument_list|)
expr_stmt|;
name|DH_free
argument_list|(
name|dh
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* !NO_DH */
comment|/* XXX do we need this cache here? */
if|if
condition|(
name|bitset
argument_list|(
name|TLS_I_CACHE
argument_list|,
name|req
argument_list|)
condition|)
block|{
name|SSL_CTX_sess_set_cache_size
argument_list|(
operator|*
name|ctx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SSL_CTX_set_timeout
argument_list|(
operator|*
name|ctx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SSL_CTX_set_session_id_context
argument_list|(
operator|*
name|ctx
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|server_session_id_context
argument_list|,
sizeof|sizeof
argument_list|(
name|server_session_id_context
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SSL_CTX_set_session_cache_mode
argument_list|(
operator|*
name|ctx
argument_list|,
name|SSL_SESS_CACHE_SERVER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|SSL_CTX_set_session_cache_mode
argument_list|(
operator|*
name|ctx
argument_list|,
name|SSL_SESS_CACHE_OFF
argument_list|)
expr_stmt|;
block|}
comment|/* load certificate locations and default CA paths */
if|if
condition|(
name|bitset
argument_list|(
name|TLS_S_CERTP_EX
argument_list|,
name|status
argument_list|)
operator|&&
name|bitset
argument_list|(
name|TLS_S_CERTF_EX
argument_list|,
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|SSL_CTX_load_verify_locations
argument_list|(
operator|*
name|ctx
argument_list|,
name|cacertfile
argument_list|,
name|cacertpath
argument_list|)
operator|)
operator|==
literal|1
condition|)
block|{
if|#
directive|if
operator|!
name|TLS_NO_RSA
if|if
condition|(
name|bitset
argument_list|(
name|TLS_I_RSA_TMP
argument_list|,
name|req
argument_list|)
condition|)
name|SSL_CTX_set_tmp_rsa_callback
argument_list|(
operator|*
name|ctx
argument_list|,
name|tmp_rsa_key
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !TLS_NO_RSA */
comment|/* 			**  We have to install our own verify callback: 			**  SSL_VERIFY_PEER requests a client cert but even 			**  though *FAIL_IF* isn't set, the connection 			**  will be aborted if the client presents a cert 			**  that is not "liked" (can't be verified?) by 			**  the TLS library :-( 			*/
comment|/* 			**  XXX currently we could call tls_set_verify() 			**  but we hope that that function will later on 			**  only set the mode per connection. 			*/
name|SSL_CTX_set_verify
argument_list|(
operator|*
name|ctx
argument_list|,
name|bitset
argument_list|(
name|TLS_I_NO_VRFY
argument_list|,
name|req
argument_list|)
condition|?
name|SSL_VERIFY_NONE
else|:
name|SSL_VERIFY_PEER
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* install verify callback */
name|SSL_CTX_set_cert_verify_callback
argument_list|(
operator|*
name|ctx
argument_list|,
name|tls_verify_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SSL_CTX_set_client_CA_list
argument_list|(
operator|*
name|ctx
argument_list|,
name|SSL_load_client_CA_file
argument_list|(
name|cacertfile
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			**  can't load CA data; do we care? 			**  the data is necessary to authenticate the client, 			**  which in turn would be necessary 			**  if we want to allow relaying based on it. 			*/
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=%s, error: load verify locs %s, %s failed: %d"
argument_list|,
name|who
argument_list|,
name|cacertpath
argument_list|,
name|cacertfile
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|tlslogerr
argument_list|(
name|who
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|TLS_I_VRFY_LOC
argument_list|,
name|req
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
comment|/* XXX: make this dependent on an option? */
if|if
condition|(
name|tTd
argument_list|(
literal|96
argument_list|,
literal|9
argument_list|)
condition|)
name|SSL_CTX_set_info_callback
argument_list|(
operator|*
name|ctx
argument_list|,
name|apps_ssl_info_cb
argument_list|)
expr_stmt|;
if|#
directive|if
name|_FFR_TLS_1
comment|/* install our own cipher list */
if|if
condition|(
name|CipherList
operator|!=
name|NULL
operator|&&
operator|*
name|CipherList
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|SSL_CTX_set_cipher_list
argument_list|(
operator|*
name|ctx
argument_list|,
name|CipherList
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|7
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=%s, error: SSL_CTX_set_cipher_list(%s) failed, list ignored"
argument_list|,
name|who
argument_list|,
name|CipherList
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|tlslogerr
argument_list|(
name|who
argument_list|)
expr_stmt|;
block|}
comment|/* failure if setting to this list is required? */
block|}
block|}
endif|#
directive|endif
comment|/* _FFR_TLS_1 */
if|if
condition|(
name|LogLevel
operator|>
literal|12
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=%s, init=%d"
argument_list|,
name|who
argument_list|,
name|ok
argument_list|)
expr_stmt|;
if|#
directive|if
name|_FFR_TLS_1
if|#
directive|if
literal|0
comment|/* 	**  this label is required if we want to have a "clean" exit 	**  see the comments above at the initialization of cf2 	*/
block|endinittls:
endif|#
directive|endif
comment|/* 0 */
comment|/* undo damage to global variables */
if|if
condition|(
name|cf2
operator|!=
name|NULL
condition|)
operator|*
operator|--
name|cf2
operator|=
literal|','
expr_stmt|;
if|if
condition|(
name|kf2
operator|!=
name|NULL
condition|)
operator|*
operator|--
name|kf2
operator|=
literal|','
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_TLS_1 */
return|return
name|ok
return|;
block|}
end_block

begin_comment
comment|/* **  TLS_GET_INFO -- get information about TLS connection ** **	Parameters: **		ssl -- TLS connection structure **		srv -- server or client **		host -- hostname of other side **		mac -- macro storage **		certreq -- did we ask for a cert? ** **	Returns: **		result of authentication. ** **	Side Effects: **		sets macros: {cipher}, {tls_version}, {verify}, **		{cipher_bits}, {alg_bits}, {cert}, {cert_subject}, **		{cert_issuer}, {cn_subject}, {cn_issuer} */
end_comment

begin_function
name|int
name|tls_get_info
parameter_list|(
name|ssl
parameter_list|,
name|srv
parameter_list|,
name|host
parameter_list|,
name|mac
parameter_list|,
name|certreq
parameter_list|)
name|SSL
modifier|*
name|ssl
decl_stmt|;
name|bool
name|srv
decl_stmt|;
name|char
modifier|*
name|host
decl_stmt|;
name|MACROS_T
modifier|*
name|mac
decl_stmt|;
name|bool
name|certreq
decl_stmt|;
block|{
name|SSL_CIPHER
modifier|*
name|c
decl_stmt|;
name|int
name|b
decl_stmt|,
name|r
decl_stmt|;
name|long
name|verifyok
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|who
decl_stmt|;
name|char
name|bitstr
index|[
literal|16
index|]
decl_stmt|;
name|X509
modifier|*
name|cert
decl_stmt|;
name|c
operator|=
name|SSL_get_current_cipher
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
comment|/* cast is just workaround for compiler warning */
name|macdefine
argument_list|(
name|mac
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{cipher}"
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|SSL_CIPHER_get_name
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|=
name|SSL_CIPHER_get_bits
argument_list|(
name|c
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|bitstr
argument_list|,
sizeof|sizeof
argument_list|(
name|bitstr
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
name|mac
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{cipher_bits}"
argument_list|)
argument_list|,
name|bitstr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|bitstr
argument_list|,
sizeof|sizeof
argument_list|(
name|bitstr
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
name|mac
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{alg_bits}"
argument_list|)
argument_list|,
name|bitstr
argument_list|)
expr_stmt|;
name|s
operator|=
name|SSL_CIPHER_get_version
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|s
operator|=
literal|"UNKNOWN"
expr_stmt|;
name|macdefine
argument_list|(
name|mac
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{tls_version}"
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|who
operator|=
name|srv
condition|?
literal|"server"
else|:
literal|"client"
expr_stmt|;
name|cert
operator|=
name|SSL_get_peer_certificate
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
name|verifyok
operator|=
name|SSL_get_verify_result
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|14
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=%s, get_verify: %ld get_peer: 0x%lx"
argument_list|,
name|who
argument_list|,
name|verifyok
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|cert
argument_list|)
expr_stmt|;
if|if
condition|(
name|cert
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|n
decl_stmt|;
name|unsigned
name|char
name|md
index|[
name|EVP_MAX_MD_SIZE
index|]
decl_stmt|;
name|char
name|buf
index|[
name|MAXNAME
index|]
decl_stmt|;
name|X509_NAME_oneline
argument_list|(
name|X509_get_subject_name
argument_list|(
name|cert
argument_list|)
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
name|mac
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{cert_subject}"
argument_list|)
argument_list|,
name|xtextify
argument_list|(
name|buf
argument_list|,
literal|"<>\")"
argument_list|)
argument_list|)
expr_stmt|;
name|X509_NAME_oneline
argument_list|(
name|X509_get_issuer_name
argument_list|(
name|cert
argument_list|)
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
name|mac
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{cert_issuer}"
argument_list|)
argument_list|,
name|xtextify
argument_list|(
name|buf
argument_list|,
literal|"<>\")"
argument_list|)
argument_list|)
expr_stmt|;
name|X509_NAME_get_text_by_NID
argument_list|(
name|X509_get_subject_name
argument_list|(
name|cert
argument_list|)
argument_list|,
name|NID_commonName
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
name|mac
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{cn_subject}"
argument_list|)
argument_list|,
name|xtextify
argument_list|(
name|buf
argument_list|,
literal|"<>\")"
argument_list|)
argument_list|)
expr_stmt|;
name|X509_NAME_get_text_by_NID
argument_list|(
name|X509_get_issuer_name
argument_list|(
name|cert
argument_list|)
argument_list|,
name|NID_commonName
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
name|mac
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{cn_issuer}"
argument_list|)
argument_list|,
name|xtextify
argument_list|(
name|buf
argument_list|,
literal|"<>\")"
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|X509_digest
argument_list|(
name|cert
argument_list|,
name|EVP_md5
argument_list|()
argument_list|,
name|md
argument_list|,
operator|&
name|n
argument_list|)
operator|!=
literal|0
operator|&&
name|n
operator|>
literal|0
condition|)
block|{
name|char
name|md5h
index|[
name|EVP_MAX_MD_SIZE
operator|*
literal|3
index|]
decl_stmt|;
specifier|static
specifier|const
name|char
name|hexcodes
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
name|SM_ASSERT
argument_list|(
operator|(
name|n
operator|*
literal|3
operator|)
operator|+
literal|2
operator|<
sizeof|sizeof
argument_list|(
name|md5h
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
operator|(
name|int
operator|)
name|n
condition|;
name|r
operator|++
control|)
block|{
name|md5h
index|[
name|r
operator|*
literal|3
index|]
operator|=
name|hexcodes
index|[
operator|(
name|md
index|[
name|r
index|]
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
index|]
expr_stmt|;
name|md5h
index|[
operator|(
name|r
operator|*
literal|3
operator|)
operator|+
literal|1
index|]
operator|=
name|hexcodes
index|[
operator|(
name|md
index|[
name|r
index|]
operator|&
literal|0x0f
operator|)
index|]
expr_stmt|;
name|md5h
index|[
operator|(
name|r
operator|*
literal|3
operator|)
operator|+
literal|2
index|]
operator|=
literal|':'
expr_stmt|;
block|}
name|md5h
index|[
operator|(
name|n
operator|*
literal|3
operator|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|macdefine
argument_list|(
name|mac
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{cert_md5}"
argument_list|)
argument_list|,
name|md5h
argument_list|)
expr_stmt|;
block|}
else|else
name|macdefine
argument_list|(
name|mac
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{cert_md5}"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|macdefine
argument_list|(
name|mac
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{cert_subject}"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
name|mac
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{cert_issuer}"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
name|mac
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{cn_subject}"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
name|mac
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{cn_issuer}"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
name|mac
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{cert_md5}"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|verifyok
condition|)
block|{
case|case
name|X509_V_OK
case|:
if|if
condition|(
name|cert
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
literal|"OK"
expr_stmt|;
name|r
operator|=
name|TLS_AUTH_OK
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|certreq
condition|?
literal|"NO"
else|:
literal|"NOT"
operator|,
name|r
operator|=
name|TLS_AUTH_NO
expr_stmt|;
block|}
break|break;
default|default:
name|s
operator|=
literal|"FAIL"
expr_stmt|;
name|r
operator|=
name|TLS_AUTH_FAIL
expr_stmt|;
break|break;
block|}
name|macdefine
argument_list|(
name|mac
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{verify}"
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cert
operator|!=
name|NULL
condition|)
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
comment|/* do some logging */
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
block|{
name|char
modifier|*
name|vers
decl_stmt|,
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|,
modifier|*
name|cbits
decl_stmt|,
modifier|*
name|algbits
decl_stmt|;
name|vers
operator|=
name|macget
argument_list|(
name|mac
argument_list|,
name|macid
argument_list|(
literal|"{tls_version}"
argument_list|)
argument_list|)
expr_stmt|;
name|cbits
operator|=
name|macget
argument_list|(
name|mac
argument_list|,
name|macid
argument_list|(
literal|"{cipher_bits}"
argument_list|)
argument_list|)
expr_stmt|;
name|algbits
operator|=
name|macget
argument_list|(
name|mac
argument_list|,
name|macid
argument_list|(
literal|"{alg_bits}"
argument_list|)
argument_list|)
expr_stmt|;
name|s1
operator|=
name|macget
argument_list|(
name|mac
argument_list|,
name|macid
argument_list|(
literal|"{verify}"
argument_list|)
argument_list|)
expr_stmt|;
name|s2
operator|=
name|macget
argument_list|(
name|mac
argument_list|,
name|macid
argument_list|(
literal|"{cipher}"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX: maybe cut off ident info? */
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=%s, relay=%.100s, version=%.16s, verify=%.16s, cipher=%.64s, bits=%.6s/%.6s"
argument_list|,
name|who
argument_list|,
name|host
operator|==
name|NULL
condition|?
literal|"local"
else|:
name|host
argument_list|,
name|vers
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
comment|/* sm_snprintf() can deal with NULL */
name|algbits
operator|==
name|NULL
condition|?
literal|"0"
else|:
name|algbits
argument_list|,
name|cbits
operator|==
name|NULL
condition|?
literal|"0"
else|:
name|cbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|11
condition|)
block|{
comment|/* 			**  Maybe run xuntextify on the strings? 			**  That is easier to read but makes it maybe a bit 			**  more complicated to figure out the right values 			**  for the access map... 			*/
name|s1
operator|=
name|macget
argument_list|(
name|mac
argument_list|,
name|macid
argument_list|(
literal|"{cert_subject}"
argument_list|)
argument_list|)
expr_stmt|;
name|s2
operator|=
name|macget
argument_list|(
name|mac
argument_list|,
name|macid
argument_list|(
literal|"{cert_issuer}"
argument_list|)
argument_list|)
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=%s, cert-subject=%.256s, cert-issuer=%.256s, verifymsg=%s"
argument_list|,
name|who
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
name|X509_verify_cert_error_string
argument_list|(
name|verifyok
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* **  ENDTLS -- shutdown secure connection ** **	Parameters: **		ssl -- SSL connection information. **		side -- server/client (for logging). ** **	Returns: **		success? (EX_* code) */
end_comment

begin_function
name|int
name|endtls
parameter_list|(
name|ssl
parameter_list|,
name|side
parameter_list|)
name|SSL
modifier|*
name|ssl
decl_stmt|;
name|char
modifier|*
name|side
decl_stmt|;
block|{
name|int
name|ret
init|=
name|EX_OK
decl_stmt|;
if|if
condition|(
name|ssl
operator|!=
name|NULL
condition|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|SSL_shutdown
argument_list|(
name|ssl
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|11
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=%s, SSL_shutdown failed: %d"
argument_list|,
name|side
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|tlslogerr
argument_list|(
name|side
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|EX_SOFTWARE
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OPENSSL_VERSION_NUMBER
argument_list|)
operator|||
name|OPENSSL_VERSION_NUMBER
operator|>
literal|0x0090602fL
comment|/* 		**  Bug in OpenSSL (at least up to 0.9.6b): 		**  From: Lutz.Jaenicke@aet.TU-Cottbus.DE 		**  Message-ID:<20010723152244.A13122@serv01.aet.tu-cottbus.de> 		**  To: openssl-users@openssl.org 		**  Subject: Re: SSL_shutdown() woes (fwd) 		** 		**  The side sending the shutdown alert first will 		**  not care about the answer of the peer but will 		**  immediately return with a return value of "0" 		**  (ssl/s3_lib.c:ssl3_shutdown()). SSL_get_error will evaluate 		**  the value of "0" and as the shutdown alert of the peer was 		**  not received (actually, the program did not even wait for 		**  the answer), an SSL_ERROR_SYSCALL is flagged, because this 		**  is the default rule in case everything else does not apply. 		** 		**  For your server the problem is different, because it 		**  receives the shutdown first (setting SSL_RECEIVED_SHUTDOWN), 		**  then sends its response (SSL_SENT_SHUTDOWN), so for the 		**  server the shutdown was successfull. 		** 		**  As is by know, you would have to call SSL_shutdown() once 		**  and ignore an SSL_ERROR_SYSCALL returned. Then call 		**  SSL_shutdown() again to actually get the server's response. 		** 		**  In the last discussion, Bodo Moeller concluded that a 		**  rewrite of the shutdown code would be necessary, but 		**  probably with another API, as the change would not be 		**  compatible to the way it is now.  Things do not become 		**  easier as other programs do not follow the shutdown 		**  guidelines anyway, so that a lot error conditions and 		**  compitibility issues would have to be caught. 		** 		**  For now the recommondation is to ignore the error message. 		*/
elseif|else
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|15
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=%s, SSL_shutdown not done"
argument_list|,
name|side
argument_list|)
expr_stmt|;
name|tlslogerr
argument_list|(
name|side
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|EX_SOFTWARE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !defined(OPENSSL_VERSION_NUMBER) || OPENSSL_VERSION_NUMBER> 0x0090602fL */
name|SSL_free
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
name|ssl
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|TLS_NO_RSA
end_if

begin_comment
comment|/* **  TMP_RSA_KEY -- return temporary RSA key ** **	Parameters: **		s -- TLS connection structure **		export -- **		keylength -- ** **	Returns: **		temporary RSA key. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_RSA_TMP_CNT
end_ifndef

begin_define
define|#
directive|define
name|MAX_RSA_TMP_CNT
value|1000
end_define

begin_comment
comment|/* XXX better value? */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! MAX_RSA_TMP_CNT */
end_comment

begin_comment
comment|/* ARGUSED0 */
end_comment

begin_function
specifier|static
name|RSA
modifier|*
name|tmp_rsa_key
parameter_list|(
name|s
parameter_list|,
name|export
parameter_list|,
name|keylength
parameter_list|)
name|SSL
modifier|*
name|s
decl_stmt|;
name|int
name|export
decl_stmt|;
name|int
name|keylength
decl_stmt|;
block|{
if|#
directive|if
name|SM_CONF_SHM
specifier|extern
name|int
name|ShmId
decl_stmt|;
specifier|extern
name|int
modifier|*
name|PRSATmpCnt
decl_stmt|;
if|if
condition|(
name|ShmId
operator|!=
name|SM_SHM_NO_ID
operator|&&
name|rsa_tmp
operator|!=
name|NULL
operator|&&
operator|++
operator|(
operator|*
name|PRSATmpCnt
operator|)
operator|<
name|MAX_RSA_TMP_CNT
condition|)
return|return
name|rsa_tmp
return|;
endif|#
directive|endif
comment|/* SM_CONF_SHM */
if|if
condition|(
name|rsa_tmp
operator|!=
name|NULL
condition|)
name|RSA_free
argument_list|(
name|rsa_tmp
argument_list|)
expr_stmt|;
name|rsa_tmp
operator|=
name|RSA_generate_key
argument_list|(
name|RSA_KEYLENGTH
argument_list|,
name|RSA_F4
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsa_tmp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=server, tmp_rsa_key: RSA_generate_key failed!"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|SM_CONF_SHM
if|#
directive|if
literal|0
comment|/* 		**  XXX we can't (yet) share the new key... 		**	The RSA structure contains pointers hence it can't be 		**	easily kept in shared memory.  It must be transformed 		**	into a continous memory region first, then stored, 		**	and later read out again (each time re-transformed). 		*/
block|if (ShmId != SM_SHM_NO_ID) 			*PRSATmpCnt = 0;
endif|#
directive|endif
comment|/* 0 */
endif|#
directive|endif
comment|/* SM_CONF_SHM */
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=server, tmp_rsa_key: new temp RSA key"
argument_list|)
expr_stmt|;
block|}
return|return
name|rsa_tmp
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !TLS_NO_RSA */
end_comment

begin_comment
comment|/* **  APPS_SSL_INFO_CB -- info callback for TLS connections ** **	Parameters: **		s -- TLS connection structure **		where -- state in handshake **		ret -- return code of last operation ** **	Returns: **		none. */
end_comment

begin_function
specifier|static
name|void
name|apps_ssl_info_cb
parameter_list|(
name|s
parameter_list|,
name|where
parameter_list|,
name|ret
parameter_list|)
name|CONST097
name|SSL
modifier|*
name|s
decl_stmt|;
name|int
name|where
decl_stmt|;
name|int
name|ret
decl_stmt|;
block|{
name|int
name|w
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|BIO
modifier|*
name|bio_err
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|14
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS: info_callback where=0x%x, ret=%d"
argument_list|,
name|where
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|w
operator|=
name|where
operator|&
operator|~
name|SSL_ST_MASK
expr_stmt|;
if|if
condition|(
name|bio_err
operator|==
name|NULL
condition|)
name|bio_err
operator|=
name|BIO_new_fp
argument_list|(
name|stderr
argument_list|,
name|BIO_NOCLOSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|SSL_ST_CONNECT
argument_list|,
name|w
argument_list|)
condition|)
name|str
operator|=
literal|"SSL_connect"
expr_stmt|;
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|SSL_ST_ACCEPT
argument_list|,
name|w
argument_list|)
condition|)
name|str
operator|=
literal|"SSL_accept"
expr_stmt|;
else|else
name|str
operator|=
literal|"undefined"
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|SSL_CB_LOOP
argument_list|,
name|where
argument_list|)
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|12
condition|)
name|sm_syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS: %s:%s"
argument_list|,
name|str
argument_list|,
name|SSL_state_string_long
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|SSL_CB_ALERT
argument_list|,
name|where
argument_list|)
condition|)
block|{
name|str
operator|=
name|bitset
argument_list|(
name|SSL_CB_READ
argument_list|,
name|where
argument_list|)
condition|?
literal|"read"
else|:
literal|"write"
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|12
condition|)
name|sm_syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS: SSL3 alert %s:%s:%s"
argument_list|,
name|str
argument_list|,
name|SSL_alert_type_string_long
argument_list|(
name|ret
argument_list|)
argument_list|,
name|SSL_alert_desc_string_long
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|SSL_CB_EXIT
argument_list|,
name|where
argument_list|)
condition|)
block|{
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|7
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS: %s:failed in %s"
argument_list|,
name|str
argument_list|,
name|SSL_state_string_long
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|7
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS: %s:error in %s"
argument_list|,
name|str
argument_list|,
name|SSL_state_string_long
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* **  TLS_VERIFY_LOG -- log verify error for TLS certificates ** **	Parameters: **		ok -- verify ok? **		ctx -- x509 context ** **	Returns: **		0 -- fatal error **		1 -- ok */
end_comment

begin_function
specifier|static
name|int
name|tls_verify_log
parameter_list|(
name|ok
parameter_list|,
name|ctx
parameter_list|,
name|name
parameter_list|)
name|int
name|ok
decl_stmt|;
name|X509_STORE_CTX
modifier|*
name|ctx
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|SSL
modifier|*
name|ssl
decl_stmt|;
name|X509
modifier|*
name|cert
decl_stmt|;
name|int
name|reason
decl_stmt|,
name|depth
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
name|cert
operator|=
name|X509_STORE_CTX_get_current_cert
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|reason
operator|=
name|X509_STORE_CTX_get_error
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|depth
operator|=
name|X509_STORE_CTX_get_error_depth
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|ssl
operator|=
operator|(
name|SSL
operator|*
operator|)
name|X509_STORE_CTX_get_ex_data
argument_list|(
name|ctx
argument_list|,
name|SSL_get_ex_data_X509_STORE_CTX_idx
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssl
operator|==
name|NULL
condition|)
block|{
comment|/* internal error */
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS: internal error: tls_verify_cb: ssl == NULL"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|X509_NAME_oneline
argument_list|(
name|X509_get_subject_name
argument_list|(
name|cert
argument_list|)
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS: %s cert verify: depth=%d %s, state=%d, reason=%s"
argument_list|,
name|name
argument_list|,
name|depth
argument_list|,
name|buf
argument_list|,
name|ok
argument_list|,
name|X509_verify_cert_error_string
argument_list|(
name|reason
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* **  TLS_VERIFY_CB -- verify callback for TLS certificates ** **	Parameters: **		ctx -- x509 context ** **	Returns: **		accept connection? **		currently: always yes. */
end_comment

begin_function
specifier|static
name|int
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OPENSSL_VERSION_NUMBER
argument_list|)
operator|||
name|OPENSSL_VERSION_NUMBER
operator|<
literal|0x00907000L
name|tls_verify_cb
parameter_list|(
name|ctx
parameter_list|)
name|X509_STORE_CTX
modifier|*
name|ctx
decl_stmt|;
else|#
directive|else
comment|/* !defined() || OPENSSL_VERSION_NUMBER< 0x00907000L */
function|tls_verify_cb
parameter_list|(
name|ctx
parameter_list|,
name|unused
parameter_list|)
name|X509_STORE_CTX
modifier|*
name|ctx
decl_stmt|;
name|void
modifier|*
name|unused
decl_stmt|;
endif|#
directive|endif
comment|/* !defined() || OPENSSL_VERSION_NUMBER< 0x00907000L */
block|{
name|int
name|ok
decl_stmt|;
name|ok
operator|=
name|X509_verify_cert
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|13
condition|)
return|return
name|tls_verify_log
argument_list|(
name|ok
argument_list|,
name|ctx
argument_list|,
literal|"TLS"
argument_list|)
return|;
return|return
literal|1
return|;
comment|/* override it */
block|}
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/* **  TLSLOGERR -- log the errors from the TLS error stack ** **	Parameters: **		who -- server/client (for logging). ** **	Returns: **		none. */
end_comment

begin_function
name|void
name|tlslogerr
parameter_list|(
name|who
parameter_list|)
specifier|const
name|char
modifier|*
name|who
decl_stmt|;
block|{
name|unsigned
name|long
name|l
decl_stmt|;
name|int
name|line
decl_stmt|,
name|flags
decl_stmt|;
name|unsigned
name|long
name|es
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|,
modifier|*
name|data
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
define|#
directive|define
name|CP
value|(const char **)
name|es
operator|=
name|CRYPTO_thread_id
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|l
operator|=
name|ERR_get_error_line_data
argument_list|(
name|CP
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|,
name|CP
operator|&
name|data
argument_list|,
operator|&
name|flags
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=%s: %lu:%s:%s:%d:%s"
argument_list|,
name|who
argument_list|,
name|es
argument_list|,
name|ERR_error_string
argument_list|(
name|l
argument_list|,
name|buf
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|bitset
argument_list|(
name|ERR_TXT_STRING
argument_list|,
name|flags
argument_list|)
condition|?
name|data
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|OPENSSL_VERSION_NUMBER
operator|>
literal|0x00907000L
end_if

begin_comment
comment|/* **  X509_VERIFY_CB -- verify callback ** **	Parameters: **		ctx -- x509 context ** **	Returns: **		accept connection? **		currently: always yes. */
end_comment

begin_function
specifier|static
name|int
name|x509_verify_cb
parameter_list|(
name|ok
parameter_list|,
name|ctx
parameter_list|)
name|int
name|ok
decl_stmt|;
name|X509_STORE_CTX
modifier|*
name|ctx
decl_stmt|;
block|{
if|if
condition|(
name|ok
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|13
condition|)
name|tls_verify_log
argument_list|(
name|ok
argument_list|,
name|ctx
argument_list|,
literal|"x509"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|error
operator|==
name|X509_V_ERR_UNABLE_TO_GET_CRL
condition|)
block|{
name|ctx
operator|->
name|error
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
comment|/* override it */
block|}
block|}
return|return
name|ok
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL_VERSION_NUMBER> 0x00907000L */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STARTTLS */
end_comment

end_unit

