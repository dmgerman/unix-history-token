begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.  *	All rights reserved.  * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.\n\ 	All rights reserved.\n\      Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.\n\      Copyright (c) 1988, 1993\n\ 	The Regents of the University of California.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|id
index|[]
init|=
literal|"@(#)$Id: main.c,v 8.485.4.65 2001/07/20 00:53:00 gshapiro Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! lint */
end_comment

begin_define
define|#
directive|define
name|_DEFINE
end_define

begin_include
include|#
directive|include
file|<sendmail.h>
end_include

begin_if
if|#
directive|if
name|NETINET
operator|||
name|NETINET6
end_if

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NETINET || NETINET6 */
end_comment

begin_decl_stmt
specifier|static
name|SIGFUNC_DECL
name|intindebug
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SIGFUNC_DECL
name|quiesce
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SIGUSR1
end_ifdef

begin_decl_stmt
specifier|static
name|SIGFUNC_DECL
name|sigusr1
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIGUSR1 */
end_comment

begin_decl_stmt
specifier|static
name|SIGFUNC_DECL
name|term_daemon
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_class
name|__P
argument_list|(
operator|(
name|STAB
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obsolete
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|testmodeline
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  SENDMAIL -- Post mail to a set of destinations. ** **	This is the basic mail router.  All user mail programs should **	call this routine to actually deliver mail.  Sendmail in **	turn calls a bunch of mail servers that do the real work of **	delivering the mail. ** **	Sendmail is driven by settings read in from /etc/mail/sendmail.cf **	(read by readcf.c). ** **	Usage: **		/usr/lib/sendmail [flags] addr ... ** **		See the associated documentation for details. ** **	Author: **		Eric Allman, UCB/INGRES (until 10/81). **			     Britton-Lee, Inc., purveyors of fine **				database computers (11/81 - 10/88). **			     International Computer Science Institute **				(11/88 - 9/89). **			     UCB/Mammoth Project (10/89 - 7/95). **			     InReference, Inc. (8/95 - 1/97). **			     Sendmail, Inc. (1/98 - present). **		The support of the my employers is gratefully acknowledged. **			Few of them (Britton-Lee in particular) have had **			anything to gain from my involvement in this project. */
end_comment

begin_decl_stmt
name|int
name|NextMailer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "free" index into Mailer struct */
end_comment

begin_decl_stmt
name|char
modifier|*
name|FullName
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sender's full name */
end_comment

begin_decl_stmt
name|ENVELOPE
name|BlankEnvelope
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a "blank" envelope */
end_comment

begin_decl_stmt
specifier|static
name|ENVELOPE
name|MainEnvelope
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the envelope around the basic letter */
end_comment

begin_decl_stmt
name|ADDRESS
name|NullAddress
init|=
comment|/* a null address */
block|{
literal|""
block|,
literal|""
block|,
name|NULL
block|,
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|CommandLineArgs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* command line args for pid file */
end_comment

begin_decl_stmt
name|bool
name|Warn_Q_option
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* warn about Q option use */
end_comment

begin_decl_stmt
specifier|static
name|int
name|MissingFds
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bit map of fds missing on startup */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NGROUPS_MAX
end_ifdef

begin_decl_stmt
name|GIDSET_T
name|InitialGidSet
index|[
name|NGROUPS_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NGROUPS_MAX */
end_comment

begin_if
if|#
directive|if
name|DAEMON
operator|&&
operator|!
name|SMTP
end_if

begin_expr_stmt
name|ERROR
operator|%
operator|%
operator|%
operator|%
name|Cannot
name|have
name|DAEMON
name|mode
name|without
name|SMTP
operator|%
operator|%
operator|%
operator|%
name|ERROR
endif|#
directive|endif
comment|/* DAEMON&& !SMTP */
if|#
directive|if
name|SMTP
operator|&&
operator|!
name|QUEUE
name|ERROR
operator|%
operator|%
operator|%
operator|%
name|Cannot
name|have
name|SMTP
name|mode
name|without
name|QUEUE
operator|%
operator|%
operator|%
operator|%
name|ERROR
endif|#
directive|endif
comment|/* SMTP&& !QUEUE */
define|#
directive|define
name|MAXCONFIGLEVEL
value|9
comment|/* highest config version level known */
if|#
directive|if
name|SASL
specifier|static
name|sasl_callback_t
name|srvcallbacks
index|[]
operator|=
block|{
block|{
name|SASL_CB_VERIFYFILE
block|,
operator|&
name|safesaslfile
block|,
name|NULL
block|}
block|,
block|{
name|SASL_CB_PROXY_POLICY
block|,
operator|&
name|proxy_policy
block|,
name|NULL
block|}
block|,
block|{
name|SASL_CB_LIST_END
block|,
name|NULL
block|,
name|NULL
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SASL */
end_comment

begin_decl_stmt
name|int
name|SubmitMode
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|envp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
specifier|extern
name|char
name|Version
index|[]
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|,
modifier|*
name|from
decl_stmt|;
name|STAB
modifier|*
name|st
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|dp
decl_stmt|;
name|bool
name|safecf
init|=
name|TRUE
decl_stmt|;
name|BITMAP256
modifier|*
name|p_flags
init|=
name|NULL
decl_stmt|;
comment|/* daemon flags */
name|bool
name|warn_C_flag
init|=
name|FALSE
decl_stmt|;
name|bool
name|auth
init|=
name|TRUE
decl_stmt|;
comment|/* whether to set e_auth_param */
name|char
name|warn_f_flag
init|=
literal|'\0'
decl_stmt|;
name|bool
name|run_in_foreground
init|=
name|FALSE
decl_stmt|;
comment|/* -bD mode */
specifier|static
name|bool
name|reenter
init|=
name|FALSE
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|nullserver
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|authinfo
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|sysloglabel
init|=
name|NULL
decl_stmt|;
comment|/* label for syslog */
name|bool
name|forged
decl_stmt|;
name|struct
name|stat
name|traf_st
decl_stmt|;
comment|/* for TrafficLog FIFO check */
name|char
name|jbuf
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
comment|/* holds MyHostName */
specifier|static
name|char
name|rnamebuf
index|[
name|MAXNAME
index|]
decl_stmt|;
comment|/* holds RealUserName */
name|char
modifier|*
name|emptyenviron
index|[
literal|1
index|]
decl_stmt|;
if|#
directive|if
name|STARTTLS
name|bool
name|tls_ok
decl_stmt|;
endif|#
directive|endif
comment|/* STARTTLS */
name|QUEUE_CHAR
modifier|*
name|new
decl_stmt|;
specifier|extern
name|int
name|DtableSize
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
specifier|extern
name|int
name|opterr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
comment|/* 	**  Check to see if we reentered. 	**	This would normally happen if e_putheader or e_putbody 	**	were NULL when invoked. 	*/
if|if
condition|(
name|reenter
condition|)
block|{
name|syserr
argument_list|(
literal|"main: reentered!"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|reenter
operator|=
name|TRUE
expr_stmt|;
comment|/* avoid null pointer dereferences */
name|TermEscape
operator|.
name|te_rv_on
operator|=
name|TermEscape
operator|.
name|te_rv_off
operator|=
literal|""
expr_stmt|;
comment|/* 	**  Seed the random number generator. 	**  Used for queue file names, picking a queue directory, and 	**  MX randomization. 	*/
name|seed_random
argument_list|()
expr_stmt|;
comment|/* do machine-dependent initializations */
name|init_md
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* in 4.4BSD, the table can be huge; impose a reasonable limit */
name|DtableSize
operator|=
name|getdtsize
argument_list|()
expr_stmt|;
if|if
condition|(
name|DtableSize
operator|>
literal|256
condition|)
name|DtableSize
operator|=
literal|256
expr_stmt|;
comment|/* 	**  Be sure we have enough file descriptors. 	**	But also be sure that 0, 1,& 2 are open. 	*/
name|fill_fd
argument_list|(
name|STDIN_FILENO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fill_fd
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fill_fd
argument_list|(
name|STDERR_FILENO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|i
operator|=
name|DtableSize
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|!=
name|STDIN_FILENO
operator|&&
name|i
operator|!=
name|STDOUT_FILENO
operator|&&
name|i
operator|!=
name|STDERR_FILENO
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|LOG
ifdef|#
directive|ifdef
name|LOG_MAIL
name|openlog
argument_list|(
literal|"sendmail"
argument_list|,
name|LOG_PID
argument_list|,
name|LOG_MAIL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* LOG_MAIL */
name|openlog
argument_list|(
literal|"sendmail"
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOG_MAIL */
endif|#
directive|endif
comment|/* LOG */
if|if
condition|(
name|MissingFds
operator|!=
literal|0
condition|)
block|{
name|char
name|mbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|mbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
literal|1
operator|<<
name|STDIN_FILENO
argument_list|,
name|MissingFds
argument_list|)
condition|)
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|mbuf
argument_list|,
literal|", stdin"
argument_list|,
sizeof|sizeof
name|mbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
literal|1
operator|<<
name|STDOUT_FILENO
argument_list|,
name|MissingFds
argument_list|)
condition|)
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|mbuf
argument_list|,
literal|", stdout"
argument_list|,
sizeof|sizeof
name|mbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
literal|1
operator|<<
name|STDERR_FILENO
argument_list|,
name|MissingFds
argument_list|)
condition|)
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|mbuf
argument_list|,
literal|", stderr"
argument_list|,
sizeof|sizeof
name|mbuf
argument_list|)
expr_stmt|;
name|syserr
argument_list|(
literal|"File descriptors missing on startup: %s"
argument_list|,
operator|&
name|mbuf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* reset status from syserr() calls for missing file descriptors */
name|Errors
operator|=
literal|0
expr_stmt|;
name|ExitStat
operator|=
name|EX_OK
expr_stmt|;
name|SubmitMode
operator|=
name|SUBMIT_UNKNOWN
expr_stmt|;
if|#
directive|if
name|XDEBUG
name|checkfd012
argument_list|(
literal|"after openlog"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XDEBUG */
name|tTsetup
argument_list|(
name|tTdvect
argument_list|,
sizeof|sizeof
name|tTdvect
argument_list|,
literal|"0-99.1"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NGROUPS_MAX
comment|/* save initial group set for future checks */
name|i
operator|=
name|getgroups
argument_list|(
name|NGROUPS_MAX
argument_list|,
name|InitialGidSet
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|InitialGidSet
index|[
literal|0
index|]
operator|=
operator|(
name|GID_T
operator|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|NGROUPS_MAX
condition|)
name|InitialGidSet
index|[
name|i
operator|++
index|]
operator|=
name|InitialGidSet
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* NGROUPS_MAX */
comment|/* drop group id privileges (RunAsUser not yet set) */
name|dp
operator|=
name|drop_privileges
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|setstat
argument_list|(
name|dp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGUSR1
comment|/* Only allow root (or non-set-*-ID binaries) to use SIGUSR1 */
if|if
condition|(
name|getuid
argument_list|()
operator|==
literal|0
operator|||
operator|(
name|getuid
argument_list|()
operator|==
name|geteuid
argument_list|()
operator|&&
name|getgid
argument_list|()
operator|==
name|getegid
argument_list|()
operator|)
condition|)
block|{
comment|/* arrange to dump state on user-1 signal */
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGUSR1
argument_list|,
name|sigusr1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SIGUSR1 */
comment|/* initialize for setproctitle */
name|initsetproctitle
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
expr_stmt|;
comment|/* Handle any non-getoptable constructions. */
name|obsolete
argument_list|(
name|argv
argument_list|)
expr_stmt|;
comment|/* 	**  Do a quick prescan of the argument list. 	*/
if|#
directive|if
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|||
name|defined
argument_list|(
name|_AIX3
argument_list|)
define|#
directive|define
name|OPTIONS
value|"B:b:C:cd:e:F:f:Gh:IiL:M:mN:nO:o:p:q:R:r:sTtUV:vX:x"
endif|#
directive|endif
comment|/* defined(__osf__) || defined(_AIX3) */
if|#
directive|if
name|defined
argument_list|(
name|sony_news
argument_list|)
define|#
directive|define
name|OPTIONS
value|"B:b:C:cd:E:e:F:f:Gh:IiJ:L:M:mN:nO:o:p:q:R:r:sTtUV:vX:"
endif|#
directive|endif
comment|/* defined(sony_news) */
ifndef|#
directive|ifndef
name|OPTIONS
define|#
directive|define
name|OPTIONS
value|"B:b:C:cd:e:F:f:Gh:IiL:M:mN:nO:o:p:q:R:r:sTtUV:vX:"
endif|#
directive|endif
comment|/* ! OPTIONS */
name|opterr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|j
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|OPTIONS
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|j
condition|)
block|{
case|case
literal|'d'
case|:
comment|/* hack attack -- see if should use ANSI mode */
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"ANSI"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TermEscape
operator|.
name|te_rv_on
operator|=
literal|"\033[7m"
expr_stmt|;
name|TermEscape
operator|.
name|te_rv_off
operator|=
literal|"\033[0m"
expr_stmt|;
break|break;
block|}
name|tTflag
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|stdout
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
comment|/* relay (gateway) submission */
name|SubmitMode
operator||=
name|SUBMIT_MTA
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|j
operator|=
name|min
argument_list|(
name|strlen
argument_list|(
name|optarg
argument_list|)
argument_list|,
literal|24
argument_list|)
operator|+
literal|1
expr_stmt|;
name|sysloglabel
operator|=
name|xalloc
argument_list|(
name|j
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|sysloglabel
argument_list|,
name|optarg
argument_list|,
name|j
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/* initial (user) submission */
name|SubmitMode
operator||=
name|SUBMIT_MSA
expr_stmt|;
break|break;
block|}
block|}
name|opterr
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|LOG
if|if
condition|(
name|sysloglabel
operator|!=
name|NULL
condition|)
block|{
comment|/* Sanitize the string */
for|for
control|(
name|p
operator|=
name|sysloglabel
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|!
name|isprint
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'%'
condition|)
operator|*
name|p
operator|=
literal|'*'
expr_stmt|;
block|}
name|closelog
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG_MAIL
name|openlog
argument_list|(
name|sysloglabel
argument_list|,
name|LOG_PID
argument_list|,
name|LOG_MAIL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* LOG_MAIL */
name|openlog
argument_list|(
name|sysloglabel
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOG_MAIL */
block|}
endif|#
directive|endif
comment|/* LOG */
comment|/* set up the blank envelope */
name|BlankEnvelope
operator|.
name|e_puthdr
operator|=
name|putheader
expr_stmt|;
name|BlankEnvelope
operator|.
name|e_putbody
operator|=
name|putbody
expr_stmt|;
name|BlankEnvelope
operator|.
name|e_xfp
operator|=
name|NULL
expr_stmt|;
name|STRUCTCOPY
argument_list|(
name|NullAddress
argument_list|,
name|BlankEnvelope
operator|.
name|e_from
argument_list|)
expr_stmt|;
name|CurEnv
operator|=
operator|&
name|BlankEnvelope
expr_stmt|;
name|STRUCTCOPY
argument_list|(
name|NullAddress
argument_list|,
name|MainEnvelope
operator|.
name|e_from
argument_list|)
expr_stmt|;
comment|/* 	**  Set default values for variables. 	**	These cannot be in initialized data space. 	*/
name|setdefaults
argument_list|(
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
name|RealUid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|RealGid
operator|=
name|getgid
argument_list|()
expr_stmt|;
name|pw
operator|=
name|sm_getpwuid
argument_list|(
name|RealUid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|rnamebuf
argument_list|,
sizeof|sizeof
name|rnamebuf
argument_list|,
literal|"%s"
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|rnamebuf
argument_list|,
sizeof|sizeof
name|rnamebuf
argument_list|,
literal|"Unknown UID %d"
argument_list|,
operator|(
name|int
operator|)
name|RealUid
argument_list|)
expr_stmt|;
name|RealUserName
operator|=
name|rnamebuf
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|101
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|"Version %s\n"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|FALSE
argument_list|,
name|EX_OK
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  if running non-setuid binary as non-root, pretend 	**  we are the RunAsUid 	*/
if|if
condition|(
name|RealUid
operator|!=
literal|0
operator|&&
name|geteuid
argument_list|()
operator|==
name|RealUid
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|47
argument_list|,
literal|1
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"Non-setuid binary: RunAsUid = RealUid = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|RealUid
argument_list|)
expr_stmt|;
name|RunAsUid
operator|=
name|RealUid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|geteuid
argument_list|()
operator|!=
literal|0
condition|)
name|RunAsUid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
if|if
condition|(
name|RealUid
operator|!=
literal|0
operator|&&
name|getegid
argument_list|()
operator|==
name|RealGid
condition|)
name|RunAsGid
operator|=
name|RealGid
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|47
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|"main: e/ruid = %d/%d e/rgid = %d/%d\n"
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getegid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"main: RunAsUser = %d:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|RunAsUid
argument_list|,
operator|(
name|int
operator|)
name|RunAsGid
argument_list|)
expr_stmt|;
block|}
comment|/* save command line arguments */
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|av
operator|=
name|argv
init|;
operator|*
name|av
operator|!=
name|NULL
condition|;
control|)
name|j
operator|+=
name|strlen
argument_list|(
operator|*
name|av
operator|++
argument_list|)
operator|+
literal|1
expr_stmt|;
name|SaveArgv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|argc
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|CommandLineArgs
operator|=
name|xalloc
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|p
operator|=
name|CommandLineArgs
expr_stmt|;
for|for
control|(
name|av
operator|=
name|argv
operator|,
name|i
operator|=
literal|0
init|;
operator|*
name|av
operator|!=
name|NULL
condition|;
control|)
block|{
name|int
name|h
decl_stmt|;
name|SaveArgv
index|[
name|i
operator|++
index|]
operator|=
name|newstr
argument_list|(
operator|*
name|av
argument_list|)
expr_stmt|;
if|if
condition|(
name|av
operator|!=
name|argv
condition|)
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|p
argument_list|,
operator|*
name|av
operator|++
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|h
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|h
expr_stmt|;
name|j
operator|-=
name|h
operator|+
literal|1
expr_stmt|;
block|}
name|SaveArgv
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|int
name|ll
decl_stmt|;
specifier|extern
name|char
modifier|*
name|CompileOptions
index|[]
decl_stmt|;
name|dprintf
argument_list|(
literal|"Version %s\n Compiled with:"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
name|av
operator|=
name|CompileOptions
expr_stmt|;
name|ll
operator|=
literal|7
expr_stmt|;
while|while
condition|(
operator|*
name|av
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ll
operator|+
name|strlen
argument_list|(
operator|*
name|av
argument_list|)
operator|>
literal|63
condition|)
block|{
name|dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ll
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ll
operator|==
literal|0
condition|)
name|dprintf
argument_list|(
literal|"\t\t"
argument_list|)
expr_stmt|;
else|else
name|dprintf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"%s"
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
name|ll
operator|+=
name|strlen
argument_list|(
operator|*
name|av
operator|++
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|int
name|ll
decl_stmt|;
specifier|extern
name|char
modifier|*
name|OsCompileOptions
index|[]
decl_stmt|;
name|dprintf
argument_list|(
literal|"    OS Defines:"
argument_list|)
expr_stmt|;
name|av
operator|=
name|OsCompileOptions
expr_stmt|;
name|ll
operator|=
literal|7
expr_stmt|;
while|while
condition|(
operator|*
name|av
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ll
operator|+
name|strlen
argument_list|(
operator|*
name|av
argument_list|)
operator|>
literal|63
condition|)
block|{
name|dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ll
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ll
operator|==
literal|0
condition|)
name|dprintf
argument_list|(
literal|"\t\t"
argument_list|)
expr_stmt|;
else|else
name|dprintf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"%s"
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
name|ll
operator|+=
name|strlen
argument_list|(
operator|*
name|av
operator|++
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_PATH_UNIX
name|dprintf
argument_list|(
literal|"Kernel symbols:\t%s\n"
argument_list|,
name|_PATH_UNIX
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _PATH_UNIX */
name|dprintf
argument_list|(
literal|" Def Conf file:\t%s\n"
argument_list|,
name|getcfname
argument_list|()
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"  Def Pid file:\t%s\n"
argument_list|,
name|PidFile
argument_list|)
expr_stmt|;
block|}
name|InChannel
operator|=
name|stdin
expr_stmt|;
name|OutChannel
operator|=
name|stdout
expr_stmt|;
comment|/* clear sendmail's environment */
name|ExternalEnviron
operator|=
name|environ
expr_stmt|;
name|emptyenviron
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|environ
operator|=
name|emptyenviron
expr_stmt|;
comment|/* 	**  restore any original TZ setting until TimeZoneSpec has been 	**  determined - or early log messages may get bogus time stamps 	*/
if|if
condition|(
operator|(
name|p
operator|=
name|getextenv
argument_list|(
literal|"TZ"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|tz
decl_stmt|;
name|int
name|tzlen
decl_stmt|;
name|tzlen
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|4
expr_stmt|;
name|tz
operator|=
name|xalloc
argument_list|(
name|tzlen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|tz
argument_list|,
name|tzlen
argument_list|,
literal|"TZ=%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putenv
argument_list|(
name|tz
argument_list|)
expr_stmt|;
block|}
comment|/* prime the child environment */
name|setuserenv
argument_list|(
literal|"AGENT"
argument_list|,
literal|"sendmail"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|OldUmask
operator|=
name|umask
argument_list|(
literal|022
argument_list|)
expr_stmt|;
name|OpMode
operator|=
name|MD_DELIVER
expr_stmt|;
name|FullName
operator|=
name|getextenv
argument_list|(
literal|"NAME"
argument_list|)
expr_stmt|;
comment|/* 	**  Initialize name server if it is going to be used. 	*/
if|#
directive|if
name|NAMED_BIND
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|RES_INIT
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
operator|(
name|void
operator|)
name|res_init
argument_list|()
expr_stmt|;
comment|/* 	**  hack to avoid crashes when debugging for the resolver is 	**  turned on and sfio is used 	*/
if|if
condition|(
name|tTd
argument_list|(
literal|8
argument_list|,
literal|8
argument_list|)
condition|)
if|#
directive|if
operator|!
name|SFIO
operator|||
name|SFIO_STDIO_COMPAT
name|_res
operator|.
name|options
operator||=
name|RES_DEBUG
expr_stmt|;
else|#
directive|else
comment|/* !SFIO || SFIO_STDIO_COMPAT */
name|dprintf
argument_list|(
literal|"RES_DEBUG not available due to SFIO\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !SFIO || SFIO_STDIO_COMPAT */
else|else
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_DEBUG
expr_stmt|;
ifdef|#
directive|ifdef
name|RES_NOALIASES
name|_res
operator|.
name|options
operator||=
name|RES_NOALIASES
expr_stmt|;
endif|#
directive|endif
comment|/* RES_NOALIASES */
name|TimeOuts
operator|.
name|res_retry
index|[
name|RES_TO_DEFAULT
index|]
operator|=
name|_res
operator|.
name|retry
expr_stmt|;
name|TimeOuts
operator|.
name|res_retry
index|[
name|RES_TO_FIRST
index|]
operator|=
name|_res
operator|.
name|retry
expr_stmt|;
name|TimeOuts
operator|.
name|res_retry
index|[
name|RES_TO_NORMAL
index|]
operator|=
name|_res
operator|.
name|retry
expr_stmt|;
name|TimeOuts
operator|.
name|res_retrans
index|[
name|RES_TO_DEFAULT
index|]
operator|=
name|_res
operator|.
name|retrans
expr_stmt|;
name|TimeOuts
operator|.
name|res_retrans
index|[
name|RES_TO_FIRST
index|]
operator|=
name|_res
operator|.
name|retrans
expr_stmt|;
name|TimeOuts
operator|.
name|res_retrans
index|[
name|RES_TO_NORMAL
index|]
operator|=
name|_res
operator|.
name|retrans
expr_stmt|;
endif|#
directive|endif
comment|/* NAMED_BIND */
name|errno
operator|=
literal|0
expr_stmt|;
name|from
operator|=
name|NULL
expr_stmt|;
comment|/* initialize some macros, etc. */
name|initmacros
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
name|init_vendor_macros
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* version */
name|define
argument_list|(
literal|'v'
argument_list|,
name|Version
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* hostname */
name|hp
operator|=
name|myhostname
argument_list|(
name|jbuf
argument_list|,
sizeof|sizeof
name|jbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|jbuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|struct
name|utsname
name|utsname
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"canonical name: %s\n"
argument_list|,
name|jbuf
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'w'
argument_list|,
name|newstr
argument_list|(
name|jbuf
argument_list|)
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* must be new string */
name|define
argument_list|(
literal|'j'
argument_list|,
name|newstr
argument_list|(
name|jbuf
argument_list|)
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'w'
argument_list|,
name|jbuf
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|jbuf
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|define
argument_list|(
literal|'m'
argument_list|,
name|newstr
argument_list|(
operator|&
name|p
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|strchr
argument_list|(
operator|&
name|p
index|[
literal|1
index|]
argument_list|,
literal|'.'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"\ta.k.a.: %s\n"
argument_list|,
name|jbuf
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'w'
argument_list|,
name|jbuf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'.'
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|uname
argument_list|(
operator|&
name|utsname
argument_list|)
operator|>=
literal|0
condition|)
name|p
operator|=
name|utsname
operator|.
name|nodename
expr_stmt|;
else|else
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|22
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"uname failed (%s)\n"
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|makelower
argument_list|(
name|jbuf
argument_list|)
expr_stmt|;
name|p
operator|=
name|jbuf
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|" UUCP nodename: %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|newstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'k'
argument_list|,
name|p
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'k'
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'w'
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|av
operator|=
name|hp
operator|->
name|h_aliases
init|;
name|av
operator|!=
name|NULL
operator|&&
operator|*
name|av
operator|!=
name|NULL
condition|;
name|av
operator|++
control|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"\ta.k.a.: %s\n"
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'w'
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|NETINET
operator|||
name|NETINET6
for|for
control|(
name|i
operator|=
literal|0
init|;
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
name|NETINET6
name|char
modifier|*
name|addr
decl_stmt|;
name|char
name|buf6
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|struct
name|in6_addr
name|ia6
decl_stmt|;
endif|#
directive|endif
comment|/* NETINET6 */
if|#
directive|if
name|NETINET
name|struct
name|in_addr
name|ia
decl_stmt|;
endif|#
directive|endif
comment|/* NETINET */
name|char
name|ipbuf
index|[
literal|103
index|]
decl_stmt|;
name|ipbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|hp
operator|->
name|h_addrtype
condition|)
block|{
if|#
directive|if
name|NETINET
case|case
name|AF_INET
case|:
if|if
condition|(
name|hp
operator|->
name|h_length
operator|!=
name|INADDRSZ
condition|)
break|break;
name|memmove
argument_list|(
operator|&
name|ia
argument_list|,
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
argument_list|,
name|INADDRSZ
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|ipbuf
argument_list|,
sizeof|sizeof
name|ipbuf
argument_list|,
literal|"[%.100s]"
argument_list|,
name|inet_ntoa
argument_list|(
name|ia
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|hp
operator|->
name|h_length
operator|!=
name|IN6ADDRSZ
condition|)
break|break;
name|memmove
argument_list|(
operator|&
name|ia6
argument_list|,
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
argument_list|,
name|IN6ADDRSZ
argument_list|)
expr_stmt|;
name|addr
operator|=
name|anynet_ntop
argument_list|(
operator|&
name|ia6
argument_list|,
name|buf6
argument_list|,
sizeof|sizeof
name|buf6
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|ipbuf
argument_list|,
sizeof|sizeof
name|ipbuf
argument_list|,
literal|"[%.100s]"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET6 */
block|}
if|if
condition|(
name|ipbuf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"\ta.k.a.: %s\n"
argument_list|,
name|ipbuf
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'w'
argument_list|,
name|ipbuf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NETINET || NETINET6 */
if|#
directive|if
name|_FFR_FREEHOSTENT
operator|&&
name|NETINET6
name|freehostent
argument_list|(
name|hp
argument_list|)
expr_stmt|;
name|hp
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_FREEHOSTENT&& NETINET6 */
block|}
comment|/* current time */
name|define
argument_list|(
literal|'b'
argument_list|,
name|arpadate
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* current load average */
name|CurrentLA
operator|=
name|sm_getla
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
name|QueueLimitRecipient
operator|=
operator|(
name|QUEUE_CHAR
operator|*
operator|)
name|NULL
expr_stmt|;
name|QueueLimitSender
operator|=
operator|(
name|QUEUE_CHAR
operator|*
operator|)
name|NULL
expr_stmt|;
name|QueueLimitId
operator|=
operator|(
name|QUEUE_CHAR
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* 	**  Crack argv. 	*/
name|av
operator|=
name|argv
expr_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
operator|*
name|av
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|++
operator|==
name|NULL
condition|)
name|p
operator|=
operator|*
name|av
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"newaliases"
argument_list|)
operator|==
literal|0
condition|)
name|OpMode
operator|=
name|MD_INITALIAS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"mailq"
argument_list|)
operator|==
literal|0
condition|)
name|OpMode
operator|=
name|MD_PRINT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"smtpd"
argument_list|)
operator|==
literal|0
condition|)
name|OpMode
operator|=
name|MD_DAEMON
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"hoststat"
argument_list|)
operator|==
literal|0
condition|)
name|OpMode
operator|=
name|MD_HOSTSTAT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"purgestat"
argument_list|)
operator|==
literal|0
condition|)
name|OpMode
operator|=
name|MD_PURGESTAT
expr_stmt|;
name|optind
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|j
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|OPTIONS
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|j
condition|)
block|{
case|case
literal|'b'
case|:
comment|/* operations mode */
switch|switch
condition|(
name|j
operator|=
operator|*
name|optarg
condition|)
block|{
case|case
name|MD_DAEMON
case|:
case|case
name|MD_FGDAEMON
case|:
if|#
directive|if
operator|!
name|DAEMON
name|usrerr
argument_list|(
literal|"Daemon mode not implemented"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* !DAEMON */
case|case
name|MD_SMTP
case|:
if|#
directive|if
operator|!
name|SMTP
name|usrerr
argument_list|(
literal|"I don't speak SMTP"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* !SMTP */
case|case
name|MD_INITALIAS
case|:
case|case
name|MD_DELIVER
case|:
case|case
name|MD_VERIFY
case|:
case|case
name|MD_TEST
case|:
case|case
name|MD_PRINT
case|:
case|case
name|MD_HOSTSTAT
case|:
case|case
name|MD_PURGESTAT
case|:
case|case
name|MD_ARPAFTP
case|:
name|OpMode
operator|=
name|j
expr_stmt|;
break|break;
case|case
name|MD_FREEZE
case|:
name|usrerr
argument_list|(
literal|"Frozen configurations unsupported"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
default|default:
name|usrerr
argument_list|(
literal|"Invalid operation mode %c"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'B'
case|:
comment|/* body type */
name|CurEnv
operator|->
name|e_bodytype
operator|=
name|newstr
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* select configuration file (already done) */
if|if
condition|(
name|RealUid
operator|!=
literal|0
condition|)
name|warn_C_flag
operator|=
name|TRUE
expr_stmt|;
name|ConfFile
operator|=
name|newstr
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|dp
operator|=
name|drop_privileges
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|setstat
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|safecf
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* debugging -- already done */
break|break;
case|case
literal|'f'
case|:
comment|/* from address */
case|case
literal|'r'
case|:
comment|/* obsolete -f flag */
if|if
condition|(
name|from
operator|!=
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"More than one \"from\" person"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
block|}
name|from
operator|=
name|newstr
argument_list|(
name|denlstring
argument_list|(
name|optarg
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|RealUserName
argument_list|,
name|from
argument_list|)
operator|!=
literal|0
condition|)
name|warn_f_flag
operator|=
name|j
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* set full name */
name|FullName
operator|=
name|newstr
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
comment|/* relay (gateway) submission */
comment|/* already set */
break|break;
case|case
literal|'h'
case|:
comment|/* hop count */
name|CurEnv
operator|->
name|e_hopcount
operator|=
operator|(
name|short
operator|)
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ep
condition|)
block|{
name|usrerr
argument_list|(
literal|"Bad hop count (%s)"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
block|}
break|break;
case|case
literal|'L'
case|:
comment|/* program label */
comment|/* already set */
break|break;
case|case
literal|'n'
case|:
comment|/* don't alias */
name|NoAlias
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* delivery status notifications */
name|DefaultNotify
operator||=
name|QHASNOTIFY
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{dsn_notify}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|optarg
argument_list|)
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"never"
argument_list|)
operator|==
literal|0
condition|)
break|break;
for|for
control|(
name|p
operator|=
name|optarg
init|;
name|p
operator|!=
name|NULL
condition|;
name|optarg
operator|=
name|p
control|)
block|{
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"success"
argument_list|)
operator|==
literal|0
condition|)
name|DefaultNotify
operator||=
name|QPINGONSUCCESS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"failure"
argument_list|)
operator|==
literal|0
condition|)
name|DefaultNotify
operator||=
name|QPINGONFAILURE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"delay"
argument_list|)
operator|==
literal|0
condition|)
name|DefaultNotify
operator||=
name|QPINGONDELAY
expr_stmt|;
else|else
block|{
name|usrerr
argument_list|(
literal|"Invalid -N argument"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'o'
case|:
comment|/* set option */
name|setoption
argument_list|(
operator|*
name|optarg
argument_list|,
name|optarg
operator|+
literal|1
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
comment|/* set option (long form) */
name|setoption
argument_list|(
literal|' '
argument_list|,
name|optarg
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* set protocol */
name|p
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|ep
operator|=
name|xalloc
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cleanstrcpy
argument_list|(
name|ep
argument_list|,
name|p
argument_list|,
name|MAXNAME
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'s'
argument_list|,
name|ep
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|optarg
operator|!=
literal|'\0'
condition|)
block|{
name|ep
operator|=
name|xalloc
argument_list|(
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cleanstrcpy
argument_list|(
name|ep
argument_list|,
name|optarg
argument_list|,
name|MAXNAME
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'r'
argument_list|,
name|ep
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'q'
case|:
comment|/* run queue files at intervals */
if|#
directive|if
name|QUEUE
comment|/* sanity check */
if|if
condition|(
name|OpMode
operator|!=
name|MD_DELIVER
operator|&&
name|OpMode
operator|!=
name|MD_DAEMON
operator|&&
name|OpMode
operator|!=
name|MD_FGDAEMON
operator|&&
name|OpMode
operator|!=
name|MD_PRINT
operator|&&
name|OpMode
operator|!=
name|MD_QUEUERUN
condition|)
block|{
name|usrerr
argument_list|(
literal|"Can not use -q with -b%c"
argument_list|,
name|OpMode
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
block|}
comment|/* don't override -bd, -bD or -bp */
if|if
condition|(
name|OpMode
operator|==
name|MD_DELIVER
condition|)
name|OpMode
operator|=
name|MD_QUEUERUN
expr_stmt|;
name|FullName
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|optarg
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'I'
case|:
name|new
operator|=
operator|(
name|QUEUE_CHAR
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|queue_match
operator|=
name|newstr
argument_list|(
operator|&
name|optarg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|new
operator|->
name|queue_next
operator|=
name|QueueLimitId
expr_stmt|;
name|QueueLimitId
operator|=
name|new
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|new
operator|=
operator|(
name|QUEUE_CHAR
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|queue_match
operator|=
name|newstr
argument_list|(
operator|&
name|optarg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|new
operator|->
name|queue_next
operator|=
name|QueueLimitRecipient
expr_stmt|;
name|QueueLimitRecipient
operator|=
name|new
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|new
operator|=
operator|(
name|QUEUE_CHAR
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|queue_match
operator|=
name|newstr
argument_list|(
operator|&
name|optarg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|new
operator|->
name|queue_next
operator|=
name|QueueLimitSender
expr_stmt|;
name|QueueLimitSender
operator|=
name|new
expr_stmt|;
break|break;
default|default:
name|i
operator|=
name|Errors
expr_stmt|;
name|QueueIntvl
operator|=
name|convtime
argument_list|(
name|optarg
argument_list|,
literal|'m'
argument_list|)
expr_stmt|;
comment|/* check for bad conversion */
if|if
condition|(
name|i
operator|<
name|Errors
condition|)
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
block|}
else|#
directive|else
comment|/* QUEUE */
name|usrerr
argument_list|(
literal|"I don't know about queues"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
endif|#
directive|endif
comment|/* QUEUE */
break|break;
case|case
literal|'R'
case|:
comment|/* DSN RET: what to return */
if|if
condition|(
name|bitset
argument_list|(
name|EF_RET_PARAM
argument_list|,
name|CurEnv
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"Duplicate -R flag"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
block|}
name|CurEnv
operator|->
name|e_flags
operator||=
name|EF_RET_PARAM
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"hdrs"
argument_list|)
operator|==
literal|0
condition|)
name|CurEnv
operator|->
name|e_flags
operator||=
name|EF_NO_BODY_RETN
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"full"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"Invalid -R value"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
block|}
name|define
argument_list|(
name|macid
argument_list|(
literal|"{dsn_ret}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|optarg
argument_list|)
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* read recipients from message */
name|GrabTo
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/* initial (user) submission */
comment|/* already set */
break|break;
case|case
literal|'V'
case|:
comment|/* DSN ENVID: set "original" envelope id */
if|if
condition|(
operator|!
name|xtextok
argument_list|(
name|optarg
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"Invalid syntax in -V flag"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
block|}
else|else
block|{
name|CurEnv
operator|->
name|e_envid
operator|=
name|newstr
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{dsn_envid}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|optarg
argument_list|)
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'X'
case|:
comment|/* traffic log file */
name|dp
operator|=
name|drop_privileges
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|setstat
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|optarg
argument_list|,
operator|&
name|traf_st
argument_list|)
operator|==
literal|0
operator|&&
name|S_ISFIFO
argument_list|(
name|traf_st
operator|.
name|st_mode
argument_list|)
condition|)
name|TrafficLogFile
operator|=
name|fopen
argument_list|(
name|optarg
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
else|else
name|TrafficLogFile
operator|=
name|fopen
argument_list|(
name|optarg
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TrafficLogFile
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"cannot open %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_CANTCREAT
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|HASSETVBUF
operator|(
name|void
operator|)
name|setvbuf
argument_list|(
name|TrafficLogFile
argument_list|,
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* HASSETVBUF */
operator|(
name|void
operator|)
name|setlinebuf
argument_list|(
name|TrafficLogFile
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HASSETVBUF */
break|break;
comment|/* compatibility flags */
case|case
literal|'c'
case|:
comment|/* connect to non-local mailers */
case|case
literal|'i'
case|:
comment|/* don't let dot stop me */
case|case
literal|'m'
case|:
comment|/* send to me too */
case|case
literal|'T'
case|:
comment|/* set timeout interval */
case|case
literal|'v'
case|:
comment|/* give blow-by-blow description */
name|setoption
argument_list|(
name|j
argument_list|,
literal|"T"
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* error message disposition */
case|case
literal|'M'
case|:
comment|/* define macro */
name|setoption
argument_list|(
name|j
argument_list|,
name|optarg
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* save From lines in headers */
name|setoption
argument_list|(
literal|'f'
argument_list|,
literal|"T"
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DBM
case|case
literal|'I'
case|:
comment|/* initialize alias DBM file */
name|OpMode
operator|=
name|MD_INITALIAS
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* DBM */
if|#
directive|if
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|||
name|defined
argument_list|(
name|_AIX3
argument_list|)
case|case
literal|'x'
case|:
comment|/* random flag that OSF/1& AIX mailx passes */
break|break;
endif|#
directive|endif
comment|/* defined(__osf__) || defined(_AIX3) */
if|#
directive|if
name|defined
argument_list|(
name|sony_news
argument_list|)
case|case
literal|'E'
case|:
case|case
literal|'J'
case|:
comment|/* ignore flags for Japanese code conversion 				   implemented on Sony NEWS */
break|break;
endif|#
directive|endif
comment|/* defined(sony_news) */
default|default:
name|finis
argument_list|(
name|TRUE
argument_list|,
name|EX_USAGE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|av
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|SUBMIT_MTA
argument_list|,
name|SubmitMode
argument_list|)
operator|&&
name|bitset
argument_list|(
name|SUBMIT_MSA
argument_list|,
name|SubmitMode
argument_list|)
condition|)
block|{
comment|/* sanity check */
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* reset to avoid bogus error messages */
name|syserr
argument_list|(
literal|"Cannot use both -G and -U together"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|SUBMIT_MTA
argument_list|,
name|SubmitMode
argument_list|)
condition|)
name|define
argument_list|(
name|macid
argument_list|(
literal|"{daemon_flags}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"CC f"
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|SUBMIT_MSA
argument_list|,
name|SubmitMode
argument_list|)
condition|)
block|{
name|define
argument_list|(
name|macid
argument_list|(
literal|"{daemon_flags}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"c u"
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* check for wrong OpMode */
if|if
condition|(
name|OpMode
operator|!=
name|MD_DELIVER
operator|&&
name|OpMode
operator|!=
name|MD_SMTP
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* reset to avoid bogus error msgs */
name|syserr
argument_list|(
literal|"Cannot use -U and -b%c"
argument_list|,
name|OpMode
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|#
directive|if
name|_FFR_DEFAULT_SUBMIT_TO_MSA
name|define
argument_list|(
name|macid
argument_list|(
literal|"{daemon_flags}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"c u"
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* _FFR_DEFAULT_SUBMIT_TO_MSA */
comment|/* EMPTY */
endif|#
directive|endif
comment|/* _FFR_DEFAULT_SUBMIT_TO_MSA */
block|}
comment|/* 	**  Do basic initialization. 	**	Read system control file. 	**	Extract special fields for local use. 	*/
comment|/* set up ${opMode} for use in config file */
block|{
name|char
name|mbuf
index|[
literal|2
index|]
decl_stmt|;
name|mbuf
index|[
literal|0
index|]
operator|=
name|OpMode
expr_stmt|;
name|mbuf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|define
argument_list|(
name|MID_OPMODE
argument_list|,
name|newstr
argument_list|(
name|mbuf
argument_list|)
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|XDEBUG
name|checkfd012
argument_list|(
literal|"before readcf"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XDEBUG */
name|vendor_pre_defaults
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
name|readcf
argument_list|(
name|getcfname
argument_list|()
argument_list|,
name|safecf
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|ConfigFileRead
operator|=
name|TRUE
expr_stmt|;
name|vendor_post_defaults
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* Remove the ability for a normal user to send signals */
if|if
condition|(
name|RealUid
operator|!=
literal|0
operator|&&
name|RealUid
operator|!=
name|geteuid
argument_list|()
condition|)
block|{
name|uid_t
name|new_uid
init|=
name|geteuid
argument_list|()
decl_stmt|;
if|#
directive|if
name|HASSETREUID
comment|/* 		**  Since we can differentiate between uid and euid, 		**  make the uid a different user so the real user 		**  can't send signals.  However, it doesn't need to be 		**  root (euid has root). 		*/
if|if
condition|(
name|new_uid
operator|==
literal|0
condition|)
name|new_uid
operator|=
name|DefUid
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|47
argument_list|,
literal|5
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"Changing real uid to %d\n"
argument_list|,
operator|(
name|int
operator|)
name|new_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|setreuid
argument_list|(
name|new_uid
argument_list|,
name|geteuid
argument_list|()
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"main: setreuid(%d, %d) failed"
argument_list|,
operator|(
name|int
operator|)
name|new_uid
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|FALSE
argument_list|,
name|EX_OSERR
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|47
argument_list|,
literal|10
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"Now running as e/ruid %d:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* HASSETREUID */
comment|/* 		**  Have to change both effective and real so need to 		**  change them both to effective to keep privs. 		*/
if|if
condition|(
name|tTd
argument_list|(
literal|47
argument_list|,
literal|5
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"Changing uid to %d\n"
argument_list|,
operator|(
name|int
operator|)
name|new_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|setuid
argument_list|(
name|new_uid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"main: setuid(%d) failed"
argument_list|,
operator|(
name|int
operator|)
name|new_uid
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|FALSE
argument_list|,
name|EX_OSERR
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|47
argument_list|,
literal|10
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"Now running as e/ruid %d:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HASSETREUID */
block|}
comment|/* set up the basic signal handlers */
if|if
condition|(
name|setsignal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGINT
argument_list|,
name|intsig
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGTERM
argument_list|,
name|intsig
argument_list|)
expr_stmt|;
comment|/* Enforce use of local time (null string overrides this) */
if|if
condition|(
name|TimeZoneSpec
operator|==
name|NULL
condition|)
name|unsetenv
argument_list|(
literal|"TZ"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TimeZoneSpec
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|setuserenv
argument_list|(
literal|"TZ"
argument_list|,
name|TimeZoneSpec
argument_list|)
expr_stmt|;
else|else
name|setuserenv
argument_list|(
literal|"TZ"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tzset
argument_list|()
expr_stmt|;
comment|/* avoid denial-of-service attacks */
name|resetlimits
argument_list|()
expr_stmt|;
if|if
condition|(
name|OpMode
operator|!=
name|MD_DAEMON
operator|&&
name|OpMode
operator|!=
name|MD_FGDAEMON
condition|)
block|{
comment|/* drop privileges -- daemon mode done after socket/bind */
name|dp
operator|=
name|drop_privileges
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|setstat
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|NAMED_BIND
name|_res
operator|.
name|retry
operator|=
name|TimeOuts
operator|.
name|res_retry
index|[
name|RES_TO_DEFAULT
index|]
expr_stmt|;
name|_res
operator|.
name|retrans
operator|=
name|TimeOuts
operator|.
name|res_retrans
index|[
name|RES_TO_DEFAULT
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* NAMED_BIND */
comment|/* 	**  Find our real host name for future logging. 	*/
name|authinfo
operator|=
name|getauthinfo
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|forged
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'_'
argument_list|,
name|authinfo
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* suppress error printing if errors mailed back or whatever */
if|if
condition|(
name|CurEnv
operator|->
name|e_errormode
operator|!=
name|EM_PRINT
condition|)
name|HoldErrs
operator|=
name|TRUE
expr_stmt|;
comment|/* set up the $=m class now, after .cf has a chance to redefine $m */
name|expand
argument_list|(
literal|"\201m"
argument_list|,
name|jbuf
argument_list|,
sizeof|sizeof
name|jbuf
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
if|if
condition|(
name|jbuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|setclass
argument_list|(
literal|'m'
argument_list|,
name|jbuf
argument_list|)
expr_stmt|;
comment|/* probe interfaces and locate any additional names */
if|if
condition|(
operator|!
name|DontProbeInterfaces
condition|)
name|load_if_names
argument_list|()
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|"\n============ SYSTEM IDENTITY (after readcf) ============"
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"\n      (short domain name) $w = "
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|macvalue
argument_list|(
literal|'w'
argument_list|,
name|CurEnv
argument_list|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"\n  (canonical domain name) $j = "
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|macvalue
argument_list|(
literal|'j'
argument_list|,
name|CurEnv
argument_list|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"\n         (subdomain name) $m = "
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|macvalue
argument_list|(
literal|'m'
argument_list|,
name|CurEnv
argument_list|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"\n              (node name) $k = "
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|macvalue
argument_list|(
literal|'k'
argument_list|,
name|CurEnv
argument_list|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"\n========================================================\n\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Do more command line checking -- these are things that 	**  have to modify the results of reading the config file. 	*/
comment|/* process authorization warnings from command line */
if|if
condition|(
name|warn_C_flag
condition|)
name|auth_warning
argument_list|(
name|CurEnv
argument_list|,
literal|"Processed by %s with -C %s"
argument_list|,
name|RealUserName
argument_list|,
name|ConfFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|Warn_Q_option
operator|&&
operator|!
name|wordinclass
argument_list|(
name|RealUserName
argument_list|,
literal|'t'
argument_list|)
condition|)
name|auth_warning
argument_list|(
name|CurEnv
argument_list|,
literal|"Processed from queue %s"
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
comment|/* check body type for legality */
if|if
condition|(
name|CurEnv
operator|->
name|e_bodytype
operator|==
name|NULL
condition|)
comment|/* EMPTY */
comment|/* nothing */
empty_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|CurEnv
operator|->
name|e_bodytype
argument_list|,
literal|"7BIT"
argument_list|)
operator|==
literal|0
condition|)
name|SevenBitInput
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|CurEnv
operator|->
name|e_bodytype
argument_list|,
literal|"8BITMIME"
argument_list|)
operator|==
literal|0
condition|)
name|SevenBitInput
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|usrerr
argument_list|(
literal|"Illegal body type %s"
argument_list|,
name|CurEnv
operator|->
name|e_bodytype
argument_list|)
expr_stmt|;
name|CurEnv
operator|->
name|e_bodytype
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* tweak default DSN notifications */
if|if
condition|(
name|DefaultNotify
operator|==
literal|0
condition|)
name|DefaultNotify
operator|=
name|QPINGONFAILURE
operator||
name|QPINGONDELAY
expr_stmt|;
comment|/* be sure we don't pick up bogus HOSTALIASES environment variable */
if|if
condition|(
name|OpMode
operator|==
name|MD_QUEUERUN
operator|&&
name|RealUid
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|unsetenv
argument_list|(
literal|"HOSTALIASES"
argument_list|)
expr_stmt|;
comment|/* check for sane configuration level */
if|if
condition|(
name|ConfigLevel
operator|>
name|MAXCONFIGLEVEL
condition|)
block|{
name|syserr
argument_list|(
literal|"Warning: .cf version level (%d) exceeds sendmail version %s functionality (%d)"
argument_list|,
name|ConfigLevel
argument_list|,
name|Version
argument_list|,
name|MAXCONFIGLEVEL
argument_list|)
expr_stmt|;
block|}
comment|/* need MCI cache to have persistence */
if|if
condition|(
name|HostStatDir
operator|!=
name|NULL
operator|&&
name|MaxMciCache
operator|==
literal|0
condition|)
block|{
name|HostStatDir
operator|=
name|NULL
expr_stmt|;
name|printf
argument_list|(
literal|"Warning: HostStatusDirectory disabled with ConnectionCacheSize = 0\n"
argument_list|)
expr_stmt|;
block|}
comment|/* need HostStatusDir in order to have SingleThreadDelivery */
if|if
condition|(
name|SingleThreadDelivery
operator|&&
name|HostStatDir
operator|==
name|NULL
condition|)
block|{
name|SingleThreadDelivery
operator|=
name|FALSE
expr_stmt|;
name|printf
argument_list|(
literal|"Warning: HostStatusDirectory required for SingleThreadDelivery\n"
argument_list|)
expr_stmt|;
block|}
comment|/* check for permissions */
if|if
condition|(
operator|(
name|OpMode
operator|==
name|MD_DAEMON
operator|||
name|OpMode
operator|==
name|MD_FGDAEMON
operator|||
name|OpMode
operator|==
name|MD_PURGESTAT
operator|)
operator|&&
name|RealUid
operator|!=
literal|0
operator|&&
name|RealUid
operator|!=
name|TrustedUid
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|1
condition|)
name|sm_syslog
argument_list|(
name|LOG_ALERT
argument_list|,
name|NOQID
argument_list|,
literal|"user %d attempted to %s"
argument_list|,
name|RealUid
argument_list|,
name|OpMode
operator|!=
name|MD_PURGESTAT
condition|?
literal|"run daemon"
else|:
literal|"purge host status"
argument_list|)
expr_stmt|;
name|usrerr
argument_list|(
literal|"Permission denied"
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|FALSE
argument_list|,
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|OpMode
operator|==
name|MD_INITALIAS
operator|&&
name|RealUid
operator|!=
literal|0
operator|&&
name|RealUid
operator|!=
name|TrustedUid
operator|&&
operator|!
name|wordinclass
argument_list|(
name|RealUserName
argument_list|,
literal|'t'
argument_list|)
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|1
condition|)
name|sm_syslog
argument_list|(
name|LOG_ALERT
argument_list|,
name|NOQID
argument_list|,
literal|"user %d attempted to rebuild the alias map"
argument_list|,
name|RealUid
argument_list|)
expr_stmt|;
name|usrerr
argument_list|(
literal|"Permission denied"
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|FALSE
argument_list|,
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|MeToo
condition|)
name|BlankEnvelope
operator|.
name|e_flags
operator||=
name|EF_METOO
expr_stmt|;
switch|switch
condition|(
name|OpMode
condition|)
block|{
case|case
name|MD_TEST
case|:
comment|/* don't have persistent host status in test mode */
name|HostStatDir
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|Verbose
operator|==
literal|0
condition|)
name|Verbose
operator|=
literal|2
expr_stmt|;
name|CurEnv
operator|->
name|e_errormode
operator|=
name|EM_PRINT
expr_stmt|;
name|HoldErrs
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|MD_VERIFY
case|:
name|CurEnv
operator|->
name|e_errormode
operator|=
name|EM_PRINT
expr_stmt|;
name|HoldErrs
operator|=
name|FALSE
expr_stmt|;
comment|/* arrange to exit cleanly on hangup signal */
if|if
condition|(
name|setsignal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|==
operator|(
name|sigfunc_t
operator|)
name|SIG_DFL
condition|)
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGHUP
argument_list|,
name|intsig
argument_list|)
expr_stmt|;
break|break;
case|case
name|MD_FGDAEMON
case|:
name|run_in_foreground
operator|=
name|TRUE
expr_stmt|;
name|OpMode
operator|=
name|MD_DAEMON
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MD_DAEMON
case|:
name|vendor_daemon_setup
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* remove things that don't make sense in daemon mode */
name|FullName
operator|=
name|NULL
expr_stmt|;
name|GrabTo
operator|=
name|FALSE
expr_stmt|;
comment|/* arrange to restart on hangup signal */
if|if
condition|(
name|SaveArgv
index|[
literal|0
index|]
operator|==
name|NULL
operator|||
name|SaveArgv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"daemon invoked without full pathname; kill -1 won't work"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGTERM
argument_list|,
name|term_daemon
argument_list|)
expr_stmt|;
break|break;
case|case
name|MD_INITALIAS
case|:
name|Verbose
operator|=
literal|2
expr_stmt|;
name|CurEnv
operator|->
name|e_errormode
operator|=
name|EM_PRINT
expr_stmt|;
name|HoldErrs
operator|=
name|FALSE
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
comment|/* arrange to exit cleanly on hangup signal */
if|if
condition|(
name|setsignal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|==
operator|(
name|sigfunc_t
operator|)
name|SIG_DFL
condition|)
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGHUP
argument_list|,
name|intsig
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* special considerations for FullName */
if|if
condition|(
name|FullName
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|full
init|=
name|NULL
decl_stmt|;
comment|/* full names can't have newlines */
if|if
condition|(
name|strchr
argument_list|(
name|FullName
argument_list|,
literal|'\n'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|full
operator|=
name|newstr
argument_list|(
name|denlstring
argument_list|(
name|FullName
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|FullName
operator|=
name|full
expr_stmt|;
block|}
comment|/* check for characters that may have to be quoted */
if|if
condition|(
operator|!
name|rfc822_string
argument_list|(
name|FullName
argument_list|)
condition|)
block|{
comment|/* 			**  Quote a full name with special characters 			**  as a comment so crackaddr() doesn't destroy 			**  the name portion of the address. 			*/
name|FullName
operator|=
name|addquotes
argument_list|(
name|FullName
argument_list|)
expr_stmt|;
if|if
condition|(
name|full
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|full
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* do heuristic mode adjustment */
if|if
condition|(
name|Verbose
condition|)
block|{
comment|/* turn off noconnect option */
name|setoption
argument_list|(
literal|'c'
argument_list|,
literal|"F"
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* turn on interactive delivery */
name|setoption
argument_list|(
literal|'d'
argument_list|,
literal|""
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VENDOR_CODE
comment|/* check for vendor mismatch */
if|if
condition|(
name|VendorCode
operator|!=
name|VENDOR_CODE
condition|)
block|{
name|message
argument_list|(
literal|"Warning: .cf file vendor code mismatch: sendmail expects vendor %s, .cf file vendor is %s"
argument_list|,
name|getvendor
argument_list|(
name|VENDOR_CODE
argument_list|)
argument_list|,
name|getvendor
argument_list|(
name|VendorCode
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* VENDOR_CODE */
comment|/* check for out of date configuration level */
if|if
condition|(
name|ConfigLevel
operator|<
name|MAXCONFIGLEVEL
condition|)
block|{
name|message
argument_list|(
literal|"Warning: .cf file is out of date: sendmail %s supports version %d, .cf file is version %d"
argument_list|,
name|Version
argument_list|,
name|MAXCONFIGLEVEL
argument_list|,
name|ConfigLevel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ConfigLevel
operator|<
literal|3
condition|)
name|UseErrorsTo
operator|=
name|TRUE
expr_stmt|;
comment|/* set options that were previous macros */
if|if
condition|(
name|SmtpGreeting
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ConfigLevel
operator|<
literal|7
operator|&&
operator|(
name|p
operator|=
name|macvalue
argument_list|(
literal|'e'
argument_list|,
name|CurEnv
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|SmtpGreeting
operator|=
name|newstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|SmtpGreeting
operator|=
literal|"\201j Sendmail \201v ready at \201b"
expr_stmt|;
block|}
if|if
condition|(
name|UnixFromLine
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ConfigLevel
operator|<
literal|7
operator|&&
operator|(
name|p
operator|=
name|macvalue
argument_list|(
literal|'l'
argument_list|,
name|CurEnv
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|UnixFromLine
operator|=
name|newstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|UnixFromLine
operator|=
literal|"From \201g  \201d"
expr_stmt|;
block|}
name|SmtpError
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* our name for SMTP codes */
name|expand
argument_list|(
literal|"\201j"
argument_list|,
name|jbuf
argument_list|,
sizeof|sizeof
name|jbuf
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
if|if
condition|(
name|jbuf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|MyHostName
operator|=
name|newstr
argument_list|(
literal|"localhost"
argument_list|)
expr_stmt|;
else|else
name|MyHostName
operator|=
name|jbuf
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|MyHostName
argument_list|,
literal|'.'
argument_list|)
operator|==
name|NULL
condition|)
name|message
argument_list|(
literal|"WARNING: local host name (%s) is not qualified; fix $j in config file"
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
comment|/* make certain that this name is part of the $=w class */
name|setclass
argument_list|(
literal|'w'
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
comment|/* the indices of built-in mailers */
name|st
operator|=
name|stab
argument_list|(
literal|"local"
argument_list|,
name|ST_MAILER
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|!=
name|NULL
condition|)
name|LocalMailer
operator|=
name|st
operator|->
name|s_mailer
expr_stmt|;
elseif|else
if|if
condition|(
name|OpMode
operator|!=
name|MD_TEST
operator|||
operator|!
name|warn_C_flag
condition|)
name|syserr
argument_list|(
literal|"No local mailer defined"
argument_list|)
expr_stmt|;
name|st
operator|=
name|stab
argument_list|(
literal|"prog"
argument_list|,
name|ST_MAILER
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"No prog mailer defined"
argument_list|)
expr_stmt|;
else|else
block|{
name|ProgMailer
operator|=
name|st
operator|->
name|s_mailer
expr_stmt|;
name|clrbitn
argument_list|(
name|M_MUSER
argument_list|,
name|ProgMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
block|}
name|st
operator|=
name|stab
argument_list|(
literal|"*file*"
argument_list|,
name|ST_MAILER
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"No *file* mailer defined"
argument_list|)
expr_stmt|;
else|else
block|{
name|FileMailer
operator|=
name|st
operator|->
name|s_mailer
expr_stmt|;
name|clrbitn
argument_list|(
name|M_MUSER
argument_list|,
name|FileMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
block|}
name|st
operator|=
name|stab
argument_list|(
literal|"*include*"
argument_list|,
name|ST_MAILER
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"No *include* mailer defined"
argument_list|)
expr_stmt|;
else|else
name|InclMailer
operator|=
name|st
operator|->
name|s_mailer
expr_stmt|;
if|if
condition|(
name|ConfigLevel
operator|<
literal|6
condition|)
block|{
comment|/* heuristic tweaking of local mailer for back compat */
if|if
condition|(
name|LocalMailer
operator|!=
name|NULL
condition|)
block|{
name|setbitn
argument_list|(
name|M_ALIASABLE
argument_list|,
name|LocalMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
name|setbitn
argument_list|(
name|M_HASPWENT
argument_list|,
name|LocalMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
name|setbitn
argument_list|(
name|M_TRYRULESET5
argument_list|,
name|LocalMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
name|setbitn
argument_list|(
name|M_CHECKINCLUDE
argument_list|,
name|LocalMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
name|setbitn
argument_list|(
name|M_CHECKPROG
argument_list|,
name|LocalMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
name|setbitn
argument_list|(
name|M_CHECKFILE
argument_list|,
name|LocalMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
name|setbitn
argument_list|(
name|M_CHECKUDB
argument_list|,
name|LocalMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ProgMailer
operator|!=
name|NULL
condition|)
name|setbitn
argument_list|(
name|M_RUNASRCPT
argument_list|,
name|ProgMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|FileMailer
operator|!=
name|NULL
condition|)
name|setbitn
argument_list|(
name|M_RUNASRCPT
argument_list|,
name|FileMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ConfigLevel
operator|<
literal|7
condition|)
block|{
if|if
condition|(
name|LocalMailer
operator|!=
name|NULL
condition|)
name|setbitn
argument_list|(
name|M_VRFY250
argument_list|,
name|LocalMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ProgMailer
operator|!=
name|NULL
condition|)
name|setbitn
argument_list|(
name|M_VRFY250
argument_list|,
name|ProgMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|FileMailer
operator|!=
name|NULL
condition|)
name|setbitn
argument_list|(
name|M_VRFY250
argument_list|,
name|FileMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
block|}
comment|/* MIME Content-Types that cannot be transfer encoded */
name|setclass
argument_list|(
literal|'n'
argument_list|,
literal|"multipart/signed"
argument_list|)
expr_stmt|;
comment|/* MIME message/xxx subtypes that can be treated as messages */
name|setclass
argument_list|(
literal|'s'
argument_list|,
literal|"rfc822"
argument_list|)
expr_stmt|;
comment|/* MIME Content-Transfer-Encodings that can be encoded */
name|setclass
argument_list|(
literal|'e'
argument_list|,
literal|"7bit"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'e'
argument_list|,
literal|"8bit"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'e'
argument_list|,
literal|"binary"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_B_CLASS
comment|/* MIME Content-Types that should be treated as binary */
name|setclass
argument_list|(
literal|'b'
argument_list|,
literal|"image"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'b'
argument_list|,
literal|"audio"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'b'
argument_list|,
literal|"video"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'b'
argument_list|,
literal|"application/octet-stream"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_B_CLASS */
comment|/* MIME headers which have fields to check for overflow */
name|setclass
argument_list|(
name|macid
argument_list|(
literal|"{checkMIMEFieldHeaders}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"content-disposition"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
name|macid
argument_list|(
literal|"{checkMIMEFieldHeaders}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"content-type"
argument_list|)
expr_stmt|;
comment|/* MIME headers to check for length overflow */
name|setclass
argument_list|(
name|macid
argument_list|(
literal|"{checkMIMETextHeaders}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"content-description"
argument_list|)
expr_stmt|;
comment|/* MIME headers to check for overflow and rebalance */
name|setclass
argument_list|(
name|macid
argument_list|(
literal|"{checkMIMEHeaders}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"content-disposition"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
name|macid
argument_list|(
literal|"{checkMIMEHeaders}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"content-id"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
name|macid
argument_list|(
literal|"{checkMIMEHeaders}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"content-transfer-encoding"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
name|macid
argument_list|(
literal|"{checkMIMEHeaders}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"content-type"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
name|macid
argument_list|(
literal|"{checkMIMEHeaders}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"mime-version"
argument_list|)
expr_stmt|;
comment|/* Macros to save in the qf file -- don't remove any */
name|setclass
argument_list|(
name|macid
argument_list|(
literal|"{persistentMacros}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
name|macid
argument_list|(
literal|"{persistentMacros}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"s"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
name|macid
argument_list|(
literal|"{persistentMacros}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"_"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
name|macid
argument_list|(
literal|"{persistentMacros}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"{if_addr}"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
name|macid
argument_list|(
literal|"{persistentMacros}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"{daemon_flags}"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
name|macid
argument_list|(
literal|"{persistentMacros}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"{client_flags}"
argument_list|)
expr_stmt|;
comment|/* operate in queue directory */
if|if
condition|(
name|QueueDir
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|OpMode
operator|!=
name|MD_TEST
condition|)
block|{
name|syserr
argument_list|(
literal|"QueueDirectory (Q) option must be set"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_CONFIG
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		**  If multiple queues wildcarded, use one for 		**  the daemon's home. Note that this preconditions 		**  a wildcarded QueueDir to a real pathname. 		*/
if|if
condition|(
name|OpMode
operator|!=
name|MD_TEST
condition|)
name|multiqueue_cache
argument_list|()
expr_stmt|;
block|}
comment|/* check host status directory for validity */
if|if
condition|(
name|HostStatDir
operator|!=
name|NULL
operator|&&
operator|!
name|path_is_dir
argument_list|(
name|HostStatDir
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
comment|/* cannot use this value */
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"Cannot use HostStatusDirectory = %s: %s\n"
argument_list|,
name|HostStatDir
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|HostStatDir
operator|=
name|NULL
expr_stmt|;
block|}
if|#
directive|if
name|QUEUE
if|if
condition|(
name|OpMode
operator|==
name|MD_QUEUERUN
operator|&&
name|RealUid
operator|!=
literal|0
operator|&&
name|bitset
argument_list|(
name|PRIV_RESTRICTQRUN
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
comment|/* check to see if we own the queue directory */
if|if
condition|(
name|stat
argument_list|(
literal|"."
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"main: cannot stat %s"
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
if|if
condition|(
name|stbuf
operator|.
name|st_uid
operator|!=
name|RealUid
condition|)
block|{
comment|/* nope, really a botch */
name|usrerr
argument_list|(
literal|"You do not have permission to process the queue"
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|FALSE
argument_list|,
name|EX_NOPERM
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* QUEUE */
if|#
directive|if
name|_FFR_MILTER
comment|/* sanity checks on milter filters */
if|if
condition|(
name|OpMode
operator|==
name|MD_DAEMON
operator|||
name|OpMode
operator|==
name|MD_SMTP
condition|)
name|milter_parse_list
argument_list|(
name|InputFilterList
argument_list|,
name|InputFilters
argument_list|,
name|MAXFILTERS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_MILTER */
comment|/* if we've had errors so far, exit now */
if|if
condition|(
name|ExitStat
operator|!=
name|EX_OK
operator|&&
name|OpMode
operator|!=
name|MD_TEST
condition|)
name|finis
argument_list|(
name|FALSE
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
if|#
directive|if
name|XDEBUG
name|checkfd012
argument_list|(
literal|"before main() initmaps"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XDEBUG */
comment|/* 	**  Do operation-mode-dependent initialization. 	*/
switch|switch
condition|(
name|OpMode
condition|)
block|{
case|case
name|MD_PRINT
case|:
comment|/* print the queue */
if|#
directive|if
name|QUEUE
name|dropenvelope
argument_list|(
name|CurEnv
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGPIPE
argument_list|,
name|quiesce
argument_list|)
expr_stmt|;
name|printqueue
argument_list|()
expr_stmt|;
name|finis
argument_list|(
name|FALSE
argument_list|,
name|EX_OK
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* QUEUE */
name|usrerr
argument_list|(
literal|"No queue to print"
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|FALSE
argument_list|,
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* QUEUE */
break|break;
case|case
name|MD_HOSTSTAT
case|:
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGPIPE
argument_list|,
name|quiesce
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mci_traverse_persistent
argument_list|(
name|mci_print_persistent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|FALSE
argument_list|,
name|EX_OK
argument_list|)
expr_stmt|;
break|break;
case|case
name|MD_PURGESTAT
case|:
operator|(
name|void
operator|)
name|mci_traverse_persistent
argument_list|(
name|mci_purge_persistent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|FALSE
argument_list|,
name|EX_OK
argument_list|)
expr_stmt|;
break|break;
case|case
name|MD_INITALIAS
case|:
comment|/* initialize maps */
name|initmaps
argument_list|()
expr_stmt|;
name|finis
argument_list|(
name|FALSE
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
break|break;
case|case
name|MD_SMTP
case|:
case|case
name|MD_DAEMON
case|:
comment|/* reset DSN parameters */
name|DefaultNotify
operator|=
name|QPINGONFAILURE
operator||
name|QPINGONDELAY
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{dsn_notify}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|CurEnv
operator|->
name|e_envid
operator|=
name|NULL
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{dsn_envid}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|CurEnv
operator|->
name|e_flags
operator|&=
operator|~
operator|(
name|EF_RET_PARAM
operator||
name|EF_NO_BODY_RETN
operator|)
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{dsn_ret}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* don't open maps for daemon -- done below in child */
break|break;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|15
argument_list|)
condition|)
block|{
comment|/* print configuration table (or at least part of it) */
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|90
argument_list|)
condition|)
name|printrules
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXMAILERS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Mailer
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|printmailer
argument_list|(
name|Mailer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	**  Switch to the main envelope. 	*/
name|CurEnv
operator|=
name|newenvelope
argument_list|(
operator|&
name|MainEnvelope
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|MainEnvelope
operator|.
name|e_flags
operator|=
name|BlankEnvelope
operator|.
name|e_flags
expr_stmt|;
comment|/* 	**  If test mode, read addresses from stdin and process. 	*/
if|if
condition|(
name|OpMode
operator|==
name|MD_TEST
condition|)
block|{
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
if|#
directive|if
name|_FFR_TESTMODE_DROP_PRIVS
name|dp
operator|=
name|drop_privileges
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|EX_OK
condition|)
block|{
name|CurEnv
operator|->
name|e_id
operator|=
name|NULL
expr_stmt|;
name|finis
argument_list|(
name|TRUE
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _FFR_TESTMODE_DROP_PRIVS */
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
name|Verbose
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
block|{
name|printf
argument_list|(
literal|"ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Enter<ruleset><address>\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setjmp
argument_list|(
name|TopFrame
argument_list|)
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGINT
argument_list|,
name|intindebug
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|Verbose
operator|==
literal|2
condition|)
name|printf
argument_list|(
literal|"> "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
name|testmodeline
argument_list|(
literal|"/quit"
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|Verbose
operator|<
literal|2
condition|)
name|printf
argument_list|(
literal|"> %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|testmodeline
argument_list|(
name|buf
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|SMTP
if|#
directive|if
name|STARTTLS
name|tls_ok
operator|=
name|init_tls_library
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* STARTTLS */
endif|#
directive|endif
comment|/* SMTP */
if|#
directive|if
name|QUEUE
comment|/* 	**  If collecting stuff from the queue, go start doing that. 	*/
if|if
condition|(
name|OpMode
operator|==
name|MD_QUEUERUN
operator|&&
name|QueueIntvl
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|SMTP
if|#
directive|if
name|STARTTLS
if|if
condition|(
name|tls_ok
condition|)
block|{
comment|/* init TLS for client, ignore result for now */
operator|(
name|void
operator|)
name|initclttls
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* STARTTLS */
endif|#
directive|endif
comment|/* SMTP */
operator|(
name|void
operator|)
name|runqueue
argument_list|(
name|FALSE
argument_list|,
name|Verbose
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|TRUE
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* QUEUE */
if|#
directive|if
name|SASL
if|if
condition|(
name|OpMode
operator|==
name|MD_SMTP
operator|||
name|OpMode
operator|==
name|MD_DAEMON
condition|)
block|{
comment|/* give a syserr or just disable AUTH ? */
if|if
condition|(
operator|(
name|i
operator|=
name|sasl_server_init
argument_list|(
name|srvcallbacks
argument_list|,
literal|"Sendmail"
argument_list|)
operator|)
operator|!=
name|SASL_OK
condition|)
name|syserr
argument_list|(
literal|"!sasl_server_init failed! [%s]"
argument_list|,
name|sasl_errstring
argument_list|(
name|i
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SASL */
comment|/* 	**  If a daemon, wait for a request. 	**	getrequests will always return in a child. 	**	If we should also be processing the queue, start 	**		doing it in background. 	**	We check for any errors that might have happened 	**		during startup. 	*/
if|if
condition|(
name|OpMode
operator|==
name|MD_DAEMON
operator|||
name|QueueIntvl
operator|!=
literal|0
condition|)
block|{
name|char
name|dtype
index|[
literal|200
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|run_in_foreground
operator|&&
operator|!
name|tTd
argument_list|(
literal|99
argument_list|,
literal|100
argument_list|)
condition|)
block|{
comment|/* put us in background */
name|i
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"daemon: cannot fork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|finis
argument_list|(
name|FALSE
argument_list|,
name|EX_OK
argument_list|)
expr_stmt|;
comment|/* disconnect from our controlling tty */
name|disconnect
argument_list|(
literal|2
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
name|dtype
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|OpMode
operator|==
name|MD_DAEMON
condition|)
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|dtype
argument_list|,
literal|"+SMTP"
argument_list|,
sizeof|sizeof
name|dtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|QueueIntvl
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|dtype
argument_list|,
literal|"+queueing@"
argument_list|,
sizeof|sizeof
name|dtype
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|dtype
argument_list|,
name|pintvl
argument_list|(
name|QueueIntvl
argument_list|,
name|TRUE
argument_list|)
argument_list|,
sizeof|sizeof
name|dtype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|dtype
argument_list|,
literal|"+debugging"
argument_list|,
sizeof|sizeof
name|dtype
argument_list|)
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"starting daemon (%s): %s"
argument_list|,
name|Version
argument_list|,
name|dtype
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XLA
name|xla_create_file
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* XLA */
comment|/* save daemon type in a macro for possible PidFile use */
name|define
argument_list|(
name|macid
argument_list|(
literal|"{daemon_info}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|dtype
operator|+
literal|1
argument_list|)
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
comment|/* save queue interval in a macro for possible PidFile use */
name|define
argument_list|(
name|macid
argument_list|(
literal|"{queue_interval}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|pintvl
argument_list|(
name|QueueIntvl
argument_list|,
name|TRUE
argument_list|)
argument_list|)
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
if|#
directive|if
name|QUEUE
if|if
condition|(
name|QueueIntvl
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|runqueue
argument_list|(
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|OpMode
operator|!=
name|MD_DAEMON
condition|)
block|{
comment|/* write the pid to file */
name|log_sendmail_pid
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGTERM
argument_list|,
name|term_daemon
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|(
name|void
operator|)
name|pause
argument_list|()
expr_stmt|;
if|if
condition|(
name|ShutdownRequest
operator|!=
name|NULL
condition|)
name|shutdown_daemon
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|DoQueueRun
condition|)
operator|(
name|void
operator|)
name|runqueue
argument_list|(
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* QUEUE */
name|dropenvelope
argument_list|(
name|CurEnv
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|#
directive|if
name|DAEMON
if|#
directive|if
name|STARTTLS
comment|/* init TLS for server, ignore result for now */
operator|(
name|void
operator|)
name|initsrvtls
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* STARTTLS */
name|p_flags
operator|=
name|getrequests
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* drop privileges */
operator|(
name|void
operator|)
name|drop_privileges
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* at this point we are in a child: reset state */
operator|(
name|void
operator|)
name|newenvelope
argument_list|(
name|CurEnv
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* 		**  Get authentication data 		*/
name|authinfo
operator|=
name|getauthinfo
argument_list|(
name|fileno
argument_list|(
name|InChannel
argument_list|)
argument_list|,
operator|&
name|forged
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'_'
argument_list|,
name|authinfo
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DAEMON */
block|}
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
block|{
comment|/* log connection information */
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NULL
argument_list|,
literal|"connect from %.100s"
argument_list|,
name|authinfo
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|SMTP
comment|/* 	**  If running SMTP protocol, start collecting and executing 	**  commands.  This will never return. 	*/
if|if
condition|(
name|OpMode
operator|==
name|MD_SMTP
operator|||
name|OpMode
operator|==
name|MD_DAEMON
condition|)
block|{
name|char
name|pbuf
index|[
literal|20
index|]
decl_stmt|;
comment|/* 		**  Save some macros for check_* rulesets. 		*/
if|if
condition|(
name|forged
condition|)
block|{
name|char
name|ipbuf
index|[
literal|103
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|ipbuf
argument_list|,
sizeof|sizeof
name|ipbuf
argument_list|,
literal|"[%.100s]"
argument_list|,
name|anynet_ntoa
argument_list|(
operator|&
name|RealHostAddr
argument_list|)
argument_list|)
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{client_name}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|ipbuf
argument_list|)
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{client_resolve}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"FORGED"
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
block|}
else|else
name|define
argument_list|(
name|macid
argument_list|(
literal|"{client_name}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|RealHostName
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{client_addr}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|anynet_ntoa
argument_list|(
operator|&
name|RealHostAddr
argument_list|)
argument_list|)
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_getla
argument_list|(
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|RealHostAddr
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
if|#
directive|if
name|NETINET
case|case
name|AF_INET
case|:
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pbuf
argument_list|,
sizeof|sizeof
name|pbuf
argument_list|,
literal|"%d"
argument_list|,
name|RealHostAddr
operator|.
name|sin
operator|.
name|sin_port
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET6
case|case
name|AF_INET6
case|:
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pbuf
argument_list|,
sizeof|sizeof
name|pbuf
argument_list|,
literal|"%d"
argument_list|,
name|RealHostAddr
operator|.
name|sin6
operator|.
name|sin6_port
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET6 */
default|default:
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pbuf
argument_list|,
sizeof|sizeof
name|pbuf
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
break|break;
block|}
name|define
argument_list|(
name|macid
argument_list|(
literal|"{client_port}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|pbuf
argument_list|)
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
if|if
condition|(
name|OpMode
operator|==
name|MD_DAEMON
condition|)
block|{
comment|/* validate the connection */
name|HoldErrs
operator|=
name|TRUE
expr_stmt|;
name|nullserver
operator|=
name|validate_connection
argument_list|(
operator|&
name|RealHostAddr
argument_list|,
name|RealHostName
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|HoldErrs
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_flags
operator|==
name|NULL
condition|)
block|{
name|p_flags
operator|=
operator|(
name|BITMAP256
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|p_flags
argument_list|)
expr_stmt|;
name|clrbitmap
argument_list|(
name|p_flags
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|STARTTLS
if|if
condition|(
name|OpMode
operator|==
name|MD_SMTP
condition|)
operator|(
name|void
operator|)
name|initsrvtls
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* STARTTLS */
name|smtp
argument_list|(
name|nullserver
argument_list|,
operator|*
name|p_flags
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SMTP */
name|clearenvelope
argument_list|(
name|CurEnv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|OpMode
operator|==
name|MD_VERIFY
condition|)
block|{
name|set_delivery_mode
argument_list|(
name|SM_VERIFY
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|PostMasterCopy
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* interactive -- all errors are global */
name|CurEnv
operator|->
name|e_flags
operator||=
name|EF_GLOBALERRS
operator||
name|EF_LOGSENDER
expr_stmt|;
block|}
comment|/* 	**  Do basic system initialization and set the sender 	*/
name|initsys
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{ntries}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"0"
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|setsender
argument_list|(
name|from
argument_list|,
name|CurEnv
argument_list|,
name|NULL
argument_list|,
literal|'\0'
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_f_flag
operator|!=
literal|'\0'
operator|&&
operator|!
name|wordinclass
argument_list|(
name|RealUserName
argument_list|,
literal|'t'
argument_list|)
operator|&&
operator|(
operator|!
name|bitnset
argument_list|(
name|M_LOCALMAILER
argument_list|,
name|CurEnv
operator|->
name|e_from
operator|.
name|q_mailer
operator|->
name|m_flags
argument_list|)
operator|||
name|strcmp
argument_list|(
name|CurEnv
operator|->
name|e_from
operator|.
name|q_user
argument_list|,
name|RealUserName
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|auth_warning
argument_list|(
name|CurEnv
argument_list|,
literal|"%s set sender to %s using -%c"
argument_list|,
name|RealUserName
argument_list|,
name|from
argument_list|,
name|warn_f_flag
argument_list|)
expr_stmt|;
if|#
directive|if
name|SASL
name|auth
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
comment|/* SASL */
block|}
if|if
condition|(
name|auth
condition|)
block|{
name|char
modifier|*
name|fv
decl_stmt|;
comment|/* set the initial sender for AUTH= to $f@$j */
name|fv
operator|=
name|macvalue
argument_list|(
literal|'f'
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
if|if
condition|(
name|fv
operator|==
name|NULL
operator|||
operator|*
name|fv
operator|==
literal|'\0'
condition|)
name|CurEnv
operator|->
name|e_auth_param
operator|=
name|NULL
expr_stmt|;
else|else
block|{
if|if
condition|(
name|strchr
argument_list|(
name|fv
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
name|fv
argument_list|)
operator|+
name|strlen
argument_list|(
name|macvalue
argument_list|(
literal|'j'
argument_list|,
name|CurEnv
argument_list|)
argument_list|)
operator|+
literal|2
expr_stmt|;
name|p
operator|=
name|xalloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
literal|"%s@%s"
argument_list|,
name|fv
argument_list|,
name|macvalue
argument_list|(
literal|'j'
argument_list|,
name|CurEnv
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|=
name|newstr
argument_list|(
name|fv
argument_list|)
expr_stmt|;
name|CurEnv
operator|->
name|e_auth_param
operator|=
name|newstr
argument_list|(
name|xtextify
argument_list|(
name|p
argument_list|,
literal|"="
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|macvalue
argument_list|(
literal|'s'
argument_list|,
name|CurEnv
argument_list|)
operator|==
name|NULL
condition|)
name|define
argument_list|(
literal|'s'
argument_list|,
name|RealHostName
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|av
operator|==
name|NULL
operator|&&
operator|!
name|GrabTo
condition|)
block|{
name|CurEnv
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
name|CurEnv
operator|->
name|e_flags
operator||=
name|EF_GLOBALERRS
expr_stmt|;
name|HoldErrs
operator|=
name|FALSE
expr_stmt|;
name|SuperSafe
operator|=
name|FALSE
expr_stmt|;
name|usrerr
argument_list|(
literal|"Recipient names must be specified"
argument_list|)
expr_stmt|;
comment|/* collect body for UUCP return */
if|if
condition|(
name|OpMode
operator|!=
name|MD_VERIFY
condition|)
name|collect
argument_list|(
name|InChannel
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|TRUE
argument_list|,
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Scan argv and deliver the message to everyone. 	*/
name|sendtoargv
argument_list|(
name|av
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* if we have had errors sofar, arrange a meaningful exit stat */
if|if
condition|(
name|Errors
operator|>
literal|0
operator|&&
name|ExitStat
operator|==
name|EX_OK
condition|)
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
if|#
directive|if
name|_FFR_FIX_DASHT
comment|/* 	**  If using -t, force not sending to argv recipients, even 	**  if they are mentioned in the headers. 	*/
if|if
condition|(
name|GrabTo
condition|)
block|{
name|ADDRESS
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|CurEnv
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
name|q
operator|->
name|q_state
operator|=
name|QS_REMOVED
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _FFR_FIX_DASHT */
comment|/* 	**  Read the input mail. 	*/
name|CurEnv
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|OpMode
operator|!=
name|MD_VERIFY
operator|||
name|GrabTo
condition|)
block|{
name|int
name|savederrors
init|=
name|Errors
decl_stmt|;
name|long
name|savedflags
init|=
name|CurEnv
operator|->
name|e_flags
operator|&
name|EF_FATALERRS
decl_stmt|;
name|CurEnv
operator|->
name|e_flags
operator||=
name|EF_GLOBALERRS
expr_stmt|;
name|CurEnv
operator|->
name|e_flags
operator|&=
operator|~
name|EF_FATALERRS
expr_stmt|;
name|Errors
operator|=
literal|0
expr_stmt|;
name|buffer_errors
argument_list|()
expr_stmt|;
name|collect
argument_list|(
name|InChannel
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* header checks failed */
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
block|{
comment|/* Log who the mail would have gone to */
if|if
condition|(
name|LogLevel
operator|>
literal|8
operator|&&
name|CurEnv
operator|->
name|e_message
operator|!=
name|NULL
operator|&&
operator|!
name|GrabTo
condition|)
block|{
name|ADDRESS
modifier|*
name|a
decl_stmt|;
for|for
control|(
name|a
operator|=
name|CurEnv
operator|->
name|e_sendqueue
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|q_next
control|)
block|{
if|if
condition|(
operator|!
name|QS_IS_UNDELIVERED
argument_list|(
name|a
operator|->
name|q_state
argument_list|)
condition|)
continue|continue;
name|CurEnv
operator|->
name|e_to
operator|=
name|a
operator|->
name|q_paddr
expr_stmt|;
name|logdelivery
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|CurEnv
operator|->
name|e_message
argument_list|,
name|NULL
argument_list|,
operator|(
name|time_t
operator|)
literal|0
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
name|CurEnv
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
block|}
name|flush_errors
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|TRUE
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
operator|-
literal|1
return|;
block|}
comment|/* bail out if message too large */
if|if
condition|(
name|bitset
argument_list|(
name|EF_CLRQUEUE
argument_list|,
name|CurEnv
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|finis
argument_list|(
name|TRUE
argument_list|,
name|ExitStat
operator|!=
name|EX_OK
condition|?
name|ExitStat
else|:
name|EX_DATAERR
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
operator|-
literal|1
return|;
block|}
name|Errors
operator|=
name|savederrors
expr_stmt|;
name|CurEnv
operator|->
name|e_flags
operator||=
name|savedflags
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"From person = \"%s\"\n"
argument_list|,
name|CurEnv
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|)
expr_stmt|;
comment|/* 	**  Actually send everything. 	**	If verifying, just ack. 	*/
name|CurEnv
operator|->
name|e_from
operator|.
name|q_state
operator|=
name|QS_SENDER
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|1
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|"main: QS_SENDER "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
operator|&
name|CurEnv
operator|->
name|e_from
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|CurEnv
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
name|CurrentLA
operator|=
name|sm_getla
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
name|GrabTo
operator|=
name|FALSE
expr_stmt|;
if|#
directive|if
name|NAMED_BIND
name|_res
operator|.
name|retry
operator|=
name|TimeOuts
operator|.
name|res_retry
index|[
name|RES_TO_FIRST
index|]
expr_stmt|;
name|_res
operator|.
name|retrans
operator|=
name|TimeOuts
operator|.
name|res_retrans
index|[
name|RES_TO_FIRST
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* NAMED_BIND */
name|sendall
argument_list|(
name|CurEnv
argument_list|,
name|SM_DEFAULT
argument_list|)
expr_stmt|;
comment|/* 	**  All done. 	**	Don't send return error message if in VERIFY mode. 	*/
name|finis
argument_list|(
name|TRUE
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|ExitStat
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  QUIESCE -- signal handler for SIGPIPE ** **	Parameters: **		sig -- incoming signal. ** **	Returns: **		none. ** **	Side Effects: **		Sets StopRequest which should cause the mailq/hoststatus **		display to stop. ** **	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD **		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE **		DOING. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|SIGFUNC_DECL
name|quiesce
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|FIX_SYSV_SIGNAL
argument_list|(
name|sig
argument_list|,
name|quiesce
argument_list|)
expr_stmt|;
name|StopRequest
operator|=
name|TRUE
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
name|SIGFUNC_RETURN
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  STOP_SENDMAIL -- Stop the running program ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		exits. */
end_comment

begin_function
name|void
name|stop_sendmail
parameter_list|()
block|{
comment|/* reset uid for process accounting */
name|endpwent
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|RealUid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  INTINDEBUG -- signal handler for SIGINT in -bt mode ** **	Parameters: **		sig -- incoming signal. ** **	Returns: **		none. ** **	Side Effects: **		longjmps back to test mode loop. ** **	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD **		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE **		DOING. ** **	XXX: More work is needed for this signal handler. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|SIGFUNC_DECL
name|intindebug
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|FIX_SYSV_SIGNAL
argument_list|(
name|sig
argument_list|,
name|intindebug
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
name|CHECK_CRITICAL
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
name|longjmp
argument_list|(
name|TopFrame
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|SIGFUNC_RETURN
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  FINIS -- Clean up and exit. ** **	Parameters: **		drop -- whether or not to drop CurEnv envelope **		exitstat -- exit status to use for exit() call ** **	Returns: **		never ** **	Side Effects: **		exits sendmail */
end_comment

begin_function
name|void
name|finis
parameter_list|(
name|drop
parameter_list|,
name|exitstat
parameter_list|)
name|bool
name|drop
decl_stmt|;
specifier|volatile
name|int
name|exitstat
decl_stmt|;
block|{
comment|/* Still want to process new timeouts added below */
name|clear_events
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|releasesignal
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|"\n====finis: stat %d e_id=%s e_flags="
argument_list|,
name|exitstat
argument_list|,
name|CurEnv
operator|->
name|e_id
operator|==
name|NULL
condition|?
literal|"NOQUEUE"
else|:
name|CurEnv
operator|->
name|e_id
argument_list|)
expr_stmt|;
name|printenvflags
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|2
argument_list|,
literal|9
argument_list|)
condition|)
name|printopenfds
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* if we fail in finis(), just exit */
if|if
condition|(
name|setjmp
argument_list|(
name|TopFrame
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* failed -- just give it up */
goto|goto
name|forceexit
goto|;
block|}
comment|/* clean up temp files */
name|CurEnv
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|drop
condition|)
block|{
if|if
condition|(
name|CurEnv
operator|->
name|e_id
operator|!=
name|NULL
condition|)
name|dropenvelope
argument_list|(
name|CurEnv
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|poststats
argument_list|(
name|StatFile
argument_list|)
expr_stmt|;
block|}
comment|/* flush any cached connections */
name|mci_flush
argument_list|(
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* close maps belonging to this pid */
name|closemaps
argument_list|()
expr_stmt|;
if|#
directive|if
name|USERDB
comment|/* close UserDatabase */
name|_udbx_close
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* USERDB */
ifdef|#
directive|ifdef
name|XLA
comment|/* clean up extended load average stuff */
name|xla_all_end
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* XLA */
comment|/* and exit */
name|forceexit
label|:
if|if
condition|(
name|LogLevel
operator|>
literal|78
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"finis, pid=%d"
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|exitstat
operator|==
name|EX_TEMPFAIL
operator|||
name|CurEnv
operator|->
name|e_errormode
operator|==
name|EM_BERKNET
condition|)
name|exitstat
operator|=
name|EX_OK
expr_stmt|;
name|sync_queue_time
argument_list|()
expr_stmt|;
comment|/* reset uid for process accounting */
name|endpwent
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|RealUid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exitstat
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  TERM_DEAMON -- SIGTERM handler for the daemon ** **	Parameters: **		sig -- signal number. ** **	Returns: **		none. ** **	Side Effects: **		Sets ShutdownRequest which will hopefully trigger **		the daemon to exit. ** **	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD **		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE **		DOING. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|SIGFUNC_DECL
name|term_daemon
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|FIX_SYSV_SIGNAL
argument_list|(
name|sig
argument_list|,
name|term_daemon
argument_list|)
expr_stmt|;
name|ShutdownRequest
operator|=
literal|"signal"
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
name|SIGFUNC_RETURN
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  SHUTDOWN_DAEMON -- Performs a clean shutdown of the daemon ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		closes control socket, exits. */
end_comment

begin_function
name|void
name|shutdown_daemon
parameter_list|()
block|{
name|char
modifier|*
name|reason
decl_stmt|;
name|allsignals
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|reason
operator|=
name|ShutdownRequest
expr_stmt|;
name|ShutdownRequest
operator|=
name|NULL
expr_stmt|;
name|PendingSignal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|79
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"interrupt (%s)"
argument_list|,
name|reason
operator|==
name|NULL
condition|?
literal|"implicit call"
else|:
name|reason
argument_list|)
expr_stmt|;
name|FileName
operator|=
name|NULL
expr_stmt|;
name|closecontrolsocket
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XLA
name|xla_all_end
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* XLA */
name|finis
argument_list|(
name|FALSE
argument_list|,
name|EX_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  INTSIG -- clean up on interrupt ** **	This just arranges to exit.  It pessimizes in that it **	may resend a message. ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		Unlocks the current job. ** **	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD **		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE **		DOING. ** **		XXX: More work is needed for this signal handler. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|SIGFUNC_DECL
name|intsig
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|bool
name|drop
init|=
name|FALSE
decl_stmt|;
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|FIX_SYSV_SIGNAL
argument_list|(
name|sig
argument_list|,
name|intsig
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
name|CHECK_CRITICAL
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|allsignals
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|!=
literal|0
operator|&&
name|LogLevel
operator|>
literal|79
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"interrupt"
argument_list|)
expr_stmt|;
name|FileName
operator|=
name|NULL
expr_stmt|;
comment|/* Clean-up on aborted stdin message submission */
if|if
condition|(
name|CurEnv
operator|->
name|e_id
operator|!=
name|NULL
operator|&&
operator|(
name|OpMode
operator|==
name|MD_SMTP
operator|||
name|OpMode
operator|==
name|MD_DELIVER
operator|||
name|OpMode
operator|==
name|MD_ARPAFTP
operator|)
condition|)
block|{
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
comment|/* don't return an error indication */
name|CurEnv
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
name|CurEnv
operator|->
name|e_flags
operator|&=
operator|~
name|EF_FATALERRS
expr_stmt|;
name|CurEnv
operator|->
name|e_flags
operator||=
name|EF_CLRQUEUE
expr_stmt|;
comment|/* 		**  Spin through the addresses and 		**  mark them dead to prevent bounces 		*/
for|for
control|(
name|q
operator|=
name|CurEnv
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
name|q
operator|->
name|q_state
operator|=
name|QS_DONTSEND
expr_stmt|;
comment|/* and don't try to deliver the partial message either */
if|if
condition|(
name|InChild
condition|)
name|ExitStat
operator|=
name|EX_QUIT
expr_stmt|;
name|drop
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OpMode
operator|!=
name|MD_TEST
condition|)
name|unlockqueue
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|drop
argument_list|,
name|EX_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  INITMACROS -- initialize the macro system ** **	This just involves defining some macros that are actually **	used internally as metasymbols to be themselves. ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		initializes several macros to be themselves. */
end_comment

begin_decl_stmt
name|struct
name|metamac
name|MetaMacros
index|[]
init|=
block|{
comment|/* LHS pattern matching characters */
block|{
literal|'*'
block|,
name|MATCHZANY
block|}
block|,
block|{
literal|'+'
block|,
name|MATCHANY
block|}
block|,
block|{
literal|'-'
block|,
name|MATCHONE
block|}
block|,
block|{
literal|'='
block|,
name|MATCHCLASS
block|}
block|,
block|{
literal|'~'
block|,
name|MATCHNCLASS
block|}
block|,
comment|/* these are RHS metasymbols */
block|{
literal|'#'
block|,
name|CANONNET
block|}
block|,
block|{
literal|'@'
block|,
name|CANONHOST
block|}
block|,
block|{
literal|':'
block|,
name|CANONUSER
block|}
block|,
block|{
literal|'>'
block|,
name|CALLSUBR
block|}
block|,
comment|/* the conditional operations */
block|{
literal|'?'
block|,
name|CONDIF
block|}
block|,
block|{
literal|'|'
block|,
name|CONDELSE
block|}
block|,
block|{
literal|'.'
block|,
name|CONDFI
block|}
block|,
comment|/* the hostname lookup characters */
block|{
literal|'['
block|,
name|HOSTBEGIN
block|}
block|,
block|{
literal|']'
block|,
name|HOSTEND
block|}
block|,
block|{
literal|'('
block|,
name|LOOKUPBEGIN
block|}
block|,
block|{
literal|')'
block|,
name|LOOKUPEND
block|}
block|,
comment|/* miscellaneous control characters */
block|{
literal|'&'
block|,
name|MACRODEXPAND
block|}
block|,
block|{
literal|'\0'
block|,
literal|'\0'
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MACBINDING
parameter_list|(
name|name
parameter_list|,
name|mid
parameter_list|)
define|\
value|stab(name, ST_MACRO, ST_ENTER)->s_macro = mid; \ 		MacroName[mid] = name;
end_define

begin_function
name|void
name|initmacros
parameter_list|(
name|e
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|struct
name|metamac
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
name|buf
index|[
literal|5
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|MacroName
index|[
name|MAXMACROID
operator|+
literal|1
index|]
decl_stmt|;
for|for
control|(
name|m
operator|=
name|MetaMacros
init|;
name|m
operator|->
name|metaname
operator|!=
literal|'\0'
condition|;
name|m
operator|++
control|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|m
operator|->
name|metaval
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|define
argument_list|(
name|m
operator|->
name|metaname
argument_list|,
name|newstr
argument_list|(
name|buf
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
name|MATCHREPL
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|'0'
init|;
name|c
operator|<=
literal|'9'
condition|;
name|c
operator|++
control|)
block|{
name|buf
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|define
argument_list|(
name|c
argument_list|,
name|newstr
argument_list|(
name|buf
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|/* set defaults for some macros sendmail will use later */
name|define
argument_list|(
literal|'n'
argument_list|,
literal|"MAILER-DAEMON"
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* set up external names for some internal macros */
name|MACBINDING
argument_list|(
literal|"opMode"
argument_list|,
name|MID_OPMODE
argument_list|)
expr_stmt|;
comment|/*XXX should probably add equivalents for all short macros here XXX*/
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  DISCONNECT -- remove our connection with any foreground process ** **	Parameters: **		droplev -- how "deeply" we should drop the line. **			0 -- ignore signals, mail back errors, make sure **			     output goes to stdout. **			1 -- also, make stdout go to /dev/null. **			2 -- also, disconnect from controlling terminal **			     (only for daemon mode). **		e -- the current envelope. ** **	Returns: **		none ** **	Side Effects: **		Trys to insure that we are immune to vagaries of **		the controlling tty. */
end_comment

begin_function
name|void
name|disconnect
parameter_list|(
name|droplev
parameter_list|,
name|e
parameter_list|)
name|int
name|droplev
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|52
argument_list|,
literal|1
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"disconnect: In %d Out %d, e=%lx\n"
argument_list|,
name|fileno
argument_list|(
name|InChannel
argument_list|)
argument_list|,
name|fileno
argument_list|(
name|OutChannel
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|52
argument_list|,
literal|100
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|"don't\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|LogLevel
operator|>
literal|93
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"disconnect level %d"
argument_list|,
name|droplev
argument_list|)
expr_stmt|;
comment|/* be sure we don't get nasty signals */
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* we can't communicate with our caller, so.... */
name|HoldErrs
operator|=
name|TRUE
expr_stmt|;
name|CurEnv
operator|->
name|e_errormode
operator|=
name|EM_MAIL
expr_stmt|;
name|Verbose
operator|=
literal|0
expr_stmt|;
name|DisConnected
operator|=
name|TRUE
expr_stmt|;
comment|/* all input from /dev/null */
if|if
condition|(
name|InChannel
operator|!=
name|stdin
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|InChannel
argument_list|)
expr_stmt|;
name|InChannel
operator|=
name|stdin
expr_stmt|;
block|}
if|if
condition|(
name|freopen
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"disconnect: freopen(\"/dev/null\") failed: %s"
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* output to the transcript */
if|if
condition|(
name|OutChannel
operator|!=
name|stdout
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|OutChannel
argument_list|)
expr_stmt|;
name|OutChannel
operator|=
name|stdout
expr_stmt|;
block|}
if|if
condition|(
name|droplev
operator|>
literal|0
condition|)
block|{
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_WRONLY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"disconnect: open(\"/dev/null\") failed: %s"
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|fd
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|fd
argument_list|,
name|STDERR_FILENO
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
comment|/* drop our controlling TTY completely if possible */
if|if
condition|(
name|droplev
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|setsid
argument_list|()
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
name|XDEBUG
name|checkfd012
argument_list|(
literal|"disconnect"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XDEBUG */
if|if
condition|(
name|LogLevel
operator|>
literal|71
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"in background, pid=%d"
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obsolete
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ap
decl_stmt|;
specifier|register
name|char
modifier|*
name|op
decl_stmt|;
while|while
condition|(
operator|(
name|ap
operator|=
operator|*
operator|++
name|argv
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Return if "--" or not an option of any form. */
if|if
condition|(
name|ap
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|ap
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
return|return;
comment|/* skip over options that do have a value */
name|op
operator|=
name|strchr
argument_list|(
name|OPTIONS
argument_list|,
name|ap
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|!=
name|NULL
operator|&&
operator|*
operator|++
name|op
operator|==
literal|':'
operator|&&
name|ap
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|&&
name|ap
index|[
literal|1
index|]
operator|!=
literal|'d'
operator|&&
if|#
directive|if
name|defined
argument_list|(
name|sony_news
argument_list|)
name|ap
index|[
literal|1
index|]
operator|!=
literal|'E'
operator|&&
name|ap
index|[
literal|1
index|]
operator|!=
literal|'J'
operator|&&
endif|#
directive|endif
comment|/* defined(sony_news) */
name|argv
index|[
literal|1
index|]
operator|!=
name|NULL
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
name|argv
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* If -C doesn't have an argument, use sendmail.cf. */
define|#
directive|define
name|__DEFPATH
value|"sendmail.cf"
if|if
condition|(
name|ap
index|[
literal|1
index|]
operator|==
literal|'C'
operator|&&
name|ap
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|argv
operator|=
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|__DEFPATH
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|__DEFPATH
argument_list|)
operator|+
literal|2
argument_list|,
literal|"-C%s"
argument_list|,
name|__DEFPATH
argument_list|)
expr_stmt|;
block|}
comment|/* If -q doesn't have an argument, run it once. */
if|if
condition|(
name|ap
index|[
literal|1
index|]
operator|==
literal|'q'
operator|&&
name|ap
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
operator|*
name|argv
operator|=
literal|"-q0"
expr_stmt|;
comment|/* if -d doesn't have an argument, use 0-99.1 */
if|if
condition|(
name|ap
index|[
literal|1
index|]
operator|==
literal|'d'
operator|&&
name|ap
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
operator|*
name|argv
operator|=
literal|"-d0-99.1"
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sony_news
argument_list|)
comment|/* if -E doesn't have an argument, use -EC */
if|if
condition|(
name|ap
index|[
literal|1
index|]
operator|==
literal|'E'
operator|&&
name|ap
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
operator|*
name|argv
operator|=
literal|"-EC"
expr_stmt|;
comment|/* if -J doesn't have an argument, use -JJ */
if|if
condition|(
name|ap
index|[
literal|1
index|]
operator|==
literal|'J'
operator|&&
name|ap
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
operator|*
name|argv
operator|=
literal|"-JJ"
expr_stmt|;
endif|#
directive|endif
comment|/* defined(sony_news) */
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  AUTH_WARNING -- specify authorization warning ** **	Parameters: **		e -- the current envelope. **		msg -- the text of the message. **		args -- arguments to the message. ** **	Returns: **		none. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|auth_warning
parameter_list|(
specifier|register
name|ENVELOPE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
comment|/* __STDC__ */
function|auth_warning
parameter_list|(
name|e
parameter_list|,
name|msg
parameter_list|,
name|va_alist
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
function|va_dcl
endif|#
directive|endif
comment|/* __STDC__ */
block|{
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|VA_LOCAL_DECL
if|if
condition|(
name|bitset
argument_list|(
name|PRIV_AUTHWARNINGS
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|char
name|hostbuf
index|[
literal|48
index|]
decl_stmt|;
if|if
condition|(
name|hostbuf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|hp
operator|=
name|myhostname
argument_list|(
name|hostbuf
argument_list|,
sizeof|sizeof
name|hostbuf
argument_list|)
expr_stmt|;
if|#
directive|if
name|_FFR_FREEHOSTENT
operator|&&
name|NETINET6
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
block|{
name|freehostent
argument_list|(
name|hp
argument_list|)
expr_stmt|;
name|hp
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _FFR_FREEHOSTENT&& NETINET6 */
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"%s: "
argument_list|,
name|hostbuf
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
index|]
expr_stmt|;
name|VA_START
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|p
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|p
argument_list|)
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_END
expr_stmt|;
name|addheader
argument_list|(
literal|"X-Authentication-Warning"
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
operator|&
name|e
operator|->
name|e_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|3
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Authentication-Warning: %.400s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  GETEXTENV -- get from external environment ** **	Parameters: **		envar -- the name of the variable to retrieve ** **	Returns: **		The value, if any. */
end_comment

begin_function
name|char
modifier|*
name|getextenv
parameter_list|(
name|envar
parameter_list|)
specifier|const
name|char
modifier|*
name|envar
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
name|int
name|l
decl_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|envar
argument_list|)
expr_stmt|;
for|for
control|(
name|envp
operator|=
name|ExternalEnviron
init|;
operator|*
name|envp
operator|!=
name|NULL
condition|;
name|envp
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|envp
argument_list|,
name|envar
argument_list|,
name|l
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|*
name|envp
operator|)
index|[
name|l
index|]
operator|==
literal|'='
condition|)
return|return
operator|&
operator|(
operator|*
name|envp
operator|)
index|[
name|l
operator|+
literal|1
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  SETUSERENV -- set an environment in the propogated environment ** **	Parameters: **		envar -- the name of the environment variable. **		value -- the value to which it should be set.  If **			null, this is extracted from the incoming **			environment.  If that is not set, the call **			to setuserenv is ignored. ** **	Returns: **		none. */
end_comment

begin_function
name|void
name|setuserenv
parameter_list|(
name|envar
parameter_list|,
name|value
parameter_list|)
specifier|const
name|char
modifier|*
name|envar
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
name|char
modifier|*
modifier|*
name|evp
init|=
name|UserEnviron
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
name|value
operator|=
name|getextenv
argument_list|(
name|envar
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
return|return;
block|}
name|i
operator|=
name|strlen
argument_list|(
name|envar
argument_list|)
operator|+
literal|1
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
name|i
operator|+
literal|1
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|xalloc
argument_list|(
name|l
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
literal|"%s=%s"
argument_list|,
name|envar
argument_list|,
name|value
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|evp
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
operator|*
name|evp
argument_list|,
name|p
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
name|evp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|evp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|evp
operator|++
operator|=
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|evp
operator|<
operator|&
name|UserEnviron
index|[
name|MAXUSERENVIRON
index|]
condition|)
block|{
operator|*
name|evp
operator|++
operator|=
name|p
expr_stmt|;
operator|*
name|evp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* make sure it is in our environment as well */
if|if
condition|(
name|putenv
argument_list|(
name|p
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"setuserenv: putenv(%s) failed"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  DUMPSTATE -- dump state ** **	For debugging. */
end_comment

begin_function
name|void
name|dumpstate
parameter_list|(
name|when
parameter_list|)
name|char
modifier|*
name|when
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|j
init|=
name|macvalue
argument_list|(
literal|'j'
argument_list|,
name|CurEnv
argument_list|)
decl_stmt|;
name|int
name|rs
decl_stmt|;
specifier|extern
name|int
name|NextMacroId
decl_stmt|;
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"--- dumping state on %s: $j = %s ---"
argument_list|,
name|when
argument_list|,
name|j
operator|==
name|NULL
condition|?
literal|"<NULL>"
else|:
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|wordinclass
argument_list|(
name|j
argument_list|,
literal|'w'
argument_list|)
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"*** $j not in $=w ***"
argument_list|)
expr_stmt|;
block|}
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"CurChildren = %d"
argument_list|,
name|CurChildren
argument_list|)
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"NextMacroId = %d (Max %d)\n"
argument_list|,
name|NextMacroId
argument_list|,
name|MAXMACROID
argument_list|)
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"--- open file descriptors: ---"
argument_list|)
expr_stmt|;
name|printopenfds
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"--- connection cache: ---"
argument_list|)
expr_stmt|;
name|mci_dump_all
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|rs
operator|=
name|strtorwset
argument_list|(
literal|"debug_dumpstate"
argument_list|,
name|NULL
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|>
literal|0
condition|)
block|{
name|int
name|status
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
name|char
modifier|*
name|pv
index|[
name|MAXATOM
operator|+
literal|1
index|]
decl_stmt|;
name|pv
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|status
operator|=
name|rewrite
argument_list|(
name|pv
argument_list|,
name|rs
argument_list|,
literal|0
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"--- ruleset debug_dumpstate returns stat %d, pv: ---"
argument_list|,
name|status
argument_list|)
expr_stmt|;
for|for
control|(
name|pvp
operator|=
name|pv
init|;
operator|*
name|pvp
operator|!=
name|NULL
condition|;
name|pvp
operator|++
control|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"%s"
argument_list|,
operator|*
name|pvp
argument_list|)
expr_stmt|;
block|}
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"--- end of state dump ---"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SIGUSR1
end_ifdef

begin_escape
end_escape

begin_comment
comment|/* **  SIGUSR1 -- Signal a request to dump state. ** **	Parameters: **		sig -- calling signal. ** **	Returns: **		none. ** **	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD **		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE **		DOING. ** **		XXX: More work is needed for this signal handler. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|SIGFUNC_DECL
name|sigusr1
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|FIX_SYSV_SIGNAL
argument_list|(
name|sig
argument_list|,
name|sigusr1
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
name|CHECK_CRITICAL
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|dumpstate
argument_list|(
literal|"user signal"
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
name|SIGFUNC_RETURN
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIGUSR1 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **  DROP_PRIVILEGES -- reduce privileges to those of the RunAsUser option ** **	Parameters: **		to_real_uid -- if set, drop to the real uid instead **			of the RunAsUser. ** **	Returns: **		EX_OSERR if the setuid failed. **		EX_OK otherwise. */
end_comment

begin_function
name|int
name|drop_privileges
parameter_list|(
name|to_real_uid
parameter_list|)
name|bool
name|to_real_uid
decl_stmt|;
block|{
name|int
name|rval
init|=
name|EX_OK
decl_stmt|;
name|GIDSET_T
name|emptygidset
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|47
argument_list|,
literal|1
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"drop_privileges(%d): Real[UG]id=%d:%d, RunAs[UG]id=%d:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|to_real_uid
argument_list|,
operator|(
name|int
operator|)
name|RealUid
argument_list|,
operator|(
name|int
operator|)
name|RealGid
argument_list|,
operator|(
name|int
operator|)
name|RunAsUid
argument_list|,
operator|(
name|int
operator|)
name|RunAsGid
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_real_uid
condition|)
block|{
name|RunAsUserName
operator|=
name|RealUserName
expr_stmt|;
name|RunAsUid
operator|=
name|RealUid
expr_stmt|;
name|RunAsGid
operator|=
name|RealGid
expr_stmt|;
block|}
comment|/* make sure no one can grab open descriptors for secret files */
name|endpwent
argument_list|()
expr_stmt|;
comment|/* reset group permissions; these can be set later */
name|emptygidset
index|[
literal|0
index|]
operator|=
operator|(
name|to_real_uid
operator|||
name|RunAsGid
operator|!=
literal|0
operator|)
condition|?
name|RunAsGid
else|:
name|getegid
argument_list|()
expr_stmt|;
if|if
condition|(
name|setgroups
argument_list|(
literal|1
argument_list|,
name|emptygidset
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|geteuid
argument_list|()
operator|==
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"drop_privileges: setgroups(1, %d) failed"
argument_list|,
operator|(
name|int
operator|)
name|emptygidset
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|rval
operator|=
name|EX_OSERR
expr_stmt|;
block|}
comment|/* reset primary group and user id */
if|if
condition|(
operator|(
name|to_real_uid
operator|||
name|RunAsGid
operator|!=
literal|0
operator|)
operator|&&
name|setgid
argument_list|(
name|RunAsGid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"drop_privileges: setgid(%d) failed"
argument_list|,
operator|(
name|int
operator|)
name|RunAsGid
argument_list|)
expr_stmt|;
name|rval
operator|=
name|EX_OSERR
expr_stmt|;
block|}
if|if
condition|(
name|to_real_uid
operator|||
name|RunAsUid
operator|!=
literal|0
condition|)
block|{
name|uid_t
name|euid
init|=
name|geteuid
argument_list|()
decl_stmt|;
if|if
condition|(
name|setuid
argument_list|(
name|RunAsUid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"drop_privileges: setuid(%d) failed"
argument_list|,
operator|(
name|int
operator|)
name|RunAsUid
argument_list|)
expr_stmt|;
name|rval
operator|=
name|EX_OSERR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RunAsUid
operator|!=
literal|0
operator|&&
name|setuid
argument_list|(
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			**  Believe it or not, the Linux capability model 			**  allows a non-root process to override setuid() 			**  on a process running as root and prevent that 			**  process from dropping privileges. 			*/
name|syserr
argument_list|(
literal|"drop_privileges: setuid(0) succeeded (when it should not)"
argument_list|)
expr_stmt|;
name|rval
operator|=
name|EX_OSERR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RunAsUid
operator|!=
name|euid
operator|&&
name|setuid
argument_list|(
name|euid
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			**  Some operating systems will keep the saved-uid 			**  if a non-root effective-uid calls setuid(real-uid) 			**  making it possible to set it back again later. 			*/
name|syserr
argument_list|(
literal|"drop_privileges: Unable to drop non-root set-user-id privileges"
argument_list|)
expr_stmt|;
name|rval
operator|=
name|EX_OSERR
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|47
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|"drop_privileges: e/ruid = %d/%d e/rgid = %d/%d\n"
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getegid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"drop_privileges: RunAsUser = %d:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|RunAsUid
argument_list|,
operator|(
name|int
operator|)
name|RunAsGid
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|47
argument_list|,
literal|10
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"drop_privileges: rval = %d\n"
argument_list|,
name|rval
argument_list|)
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  FILL_FD -- make sure a file descriptor has been properly allocated ** **	Used to make sure that stdin/out/err are allocated on startup ** **	Parameters: **		fd -- the file descriptor to be filled. **		where -- a string used for logging.  If NULL, this is **			being called on startup, and logging should **			not be done. ** **	Returns: **		none */
end_comment

begin_function
name|void
name|fill_fd
parameter_list|(
name|fd
parameter_list|,
name|where
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|>=
literal|0
operator|||
name|errno
operator|!=
name|EBADF
condition|)
return|return;
if|if
condition|(
name|where
operator|!=
name|NULL
condition|)
name|syserr
argument_list|(
literal|"fill_fd: %s: fd %d not open"
argument_list|,
name|where
argument_list|,
name|fd
argument_list|)
expr_stmt|;
else|else
name|MissingFds
operator||=
literal|1
operator|<<
name|fd
expr_stmt|;
name|i
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|fd
operator|==
literal|0
condition|?
name|O_RDONLY
else|:
name|O_WRONLY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"!fill_fd: %s: cannot open /dev/null"
argument_list|,
name|where
operator|==
name|NULL
condition|?
literal|"startup"
else|:
name|where
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|!=
name|i
condition|)
block|{
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|i
argument_list|,
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  TESTMODELINE -- process a test mode input line ** **	Parameters: **		line -- the input line. **		e -- the current environment. **	Syntax: **		#  a comment **		.X process X as a configuration line **		=X dump a configuration item (such as mailers) **		$X dump a macro or class **		/X try an activity **		X  normal process through rule set X */
end_comment

begin_function
specifier|static
name|void
name|testmodeline
parameter_list|(
name|line
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
specifier|auto
name|char
modifier|*
name|delimptr
decl_stmt|;
name|int
name|mid
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rs
decl_stmt|;
name|STAB
modifier|*
name|map
decl_stmt|;
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
name|struct
name|rewrite
modifier|*
name|rw
decl_stmt|;
name|ADDRESS
name|a
decl_stmt|;
specifier|static
name|int
name|tryflags
init|=
name|RF_COPYNONE
decl_stmt|;
name|char
name|exbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
specifier|extern
name|u_char
name|TokTypeNoC
index|[]
decl_stmt|;
if|#
directive|if
name|_FFR_ADDR_TYPE
name|define
argument_list|(
name|macid
argument_list|(
literal|"{addr_type}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"e r"
argument_list|,
name|e
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_ADDR_TYPE */
comment|/* skip leading spaces */
while|while
condition|(
operator|*
name|line
operator|==
literal|' '
condition|)
name|line
operator|++
expr_stmt|;
switch|switch
condition|(
name|line
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'#'
case|:
case|case
literal|'\0'
case|:
return|return;
case|case
literal|'?'
case|:
name|help
argument_list|(
literal|"-bt"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'.'
case|:
comment|/* config-style settings */
switch|switch
condition|(
name|line
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'D'
case|:
name|mid
operator|=
name|macid
argument_list|(
operator|&
name|line
index|[
literal|2
index|]
argument_list|,
operator|&
name|delimptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|==
literal|0
condition|)
return|return;
name|translate_dollars
argument_list|(
name|delimptr
argument_list|)
expr_stmt|;
name|define
argument_list|(
name|mid
argument_list|,
name|newstr
argument_list|(
name|delimptr
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
name|line
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
comment|/* not to call syserr() */
return|return;
name|mid
operator|=
name|macid
argument_list|(
operator|&
name|line
index|[
literal|2
index|]
argument_list|,
operator|&
name|delimptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|==
literal|0
condition|)
return|return;
name|translate_dollars
argument_list|(
name|delimptr
argument_list|)
expr_stmt|;
name|expand
argument_list|(
name|delimptr
argument_list|,
name|exbuf
argument_list|,
sizeof|sizeof
name|exbuf
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|p
operator|=
name|exbuf
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
specifier|register
name|char
modifier|*
name|wd
decl_stmt|;
name|char
name|delim
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
name|wd
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|)
name|p
operator|++
expr_stmt|;
name|delim
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|wd
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|setclass
argument_list|(
name|mid
argument_list|,
name|wd
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|delim
expr_stmt|;
block|}
break|break;
case|case
literal|'\0'
case|:
name|printf
argument_list|(
literal|"Usage: .[DC]macro value(s)\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown \".\" command %s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
case|case
literal|'='
case|:
comment|/* config-style settings */
switch|switch
condition|(
name|line
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'S'
case|:
comment|/* dump rule set */
name|rs
operator|=
name|strtorwset
argument_list|(
operator|&
name|line
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Undefined ruleset %s\n"
argument_list|,
operator|&
name|line
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|rw
operator|=
name|RewriteRules
index|[
name|rs
index|]
expr_stmt|;
if|if
condition|(
name|rw
operator|==
name|NULL
condition|)
return|return;
do|do
block|{
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'R'
argument_list|)
expr_stmt|;
name|s
operator|=
name|rw
operator|->
name|r_lhs
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
name|NULL
condition|)
block|{
name|xputs
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|s
operator|=
name|rw
operator|->
name|r_rhs
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
name|NULL
condition|)
block|{
name|xputs
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|rw
operator|=
name|rw
operator|->
name|r_next
operator|)
operator|!=
name|NULL
condition|)
do|;
break|break;
case|case
literal|'M'
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXMAILERS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Mailer
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|printmailer
argument_list|(
name|Mailer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'\0'
case|:
name|printf
argument_list|(
literal|"Usage: =Sruleset or =M\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown \"=\" command %s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
case|case
literal|'-'
case|:
comment|/* set command-line-like opts */
switch|switch
condition|(
name|line
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'d'
case|:
name|tTflag
argument_list|(
operator|&
name|line
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
name|printf
argument_list|(
literal|"Usage: -d{debug arguments}\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown \"-\" command %s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
case|case
literal|'$'
case|:
if|if
condition|(
name|line
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
block|{
name|mid
operator|=
name|macid
argument_list|(
operator|&
name|line
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|!=
literal|0
condition|)
name|stabapply
argument_list|(
name|dump_class
argument_list|,
name|mid
argument_list|)
expr_stmt|;
return|return;
block|}
name|mid
operator|=
name|macid
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|==
literal|0
condition|)
return|return;
name|p
operator|=
name|macvalue
argument_list|(
name|mid
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"Undefined\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|xputs
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'/'
case|:
comment|/* miscellaneous commands */
name|p
operator|=
operator|&
name|line
index|[
name|strlen
argument_list|(
name|line
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
operator|--
name|p
operator|>=
name|line
operator|&&
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|strpbrk
argument_list|(
name|line
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|p
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"Usage: /[canon|map|mx|parse|try|tryflags]\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcasecmp
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|,
literal|"quit"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|CurEnv
operator|->
name|e_id
operator|=
name|NULL
expr_stmt|;
name|finis
argument_list|(
name|TRUE
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcasecmp
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|,
literal|"mx"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|NAMED_BIND
comment|/* look up MX records */
name|int
name|nmx
decl_stmt|;
specifier|auto
name|int
name|rcode
decl_stmt|;
name|char
modifier|*
name|mxhosts
index|[
name|MAXMXHOSTS
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"Usage: /mx address\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|nmx
operator|=
name|getmxrr
argument_list|(
name|p
argument_list|,
name|mxhosts
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
operator|&
name|rcode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"getmxrr(%s) returns %d value(s):\n"
argument_list|,
name|p
argument_list|,
name|nmx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmx
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"\t%s\n"
argument_list|,
name|mxhosts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* NAMED_BIND */
name|printf
argument_list|(
literal|"No MX code compiled in\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NAMED_BIND */
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|,
literal|"canon"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|host
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"Usage: /canon address\n"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|strlcpy
argument_list|(
name|host
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|host
argument_list|)
operator|>=
sizeof|sizeof
name|host
condition|)
block|{
name|printf
argument_list|(
literal|"Name too long\n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|getcanonname
argument_list|(
name|host
argument_list|,
sizeof|sizeof
name|host
argument_list|,
name|HasWildcardMX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"getcanonname(%s) returns %s\n"
argument_list|,
name|p
argument_list|,
name|host
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|,
literal|"map"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|auto
name|int
name|rcode
init|=
name|EX_OK
decl_stmt|;
name|char
modifier|*
name|av
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"Usage: /map mapname key\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
operator|!=
literal|'\0'
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|q
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|q
argument_list|)
operator|)
condition|;
name|q
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"No key specified\n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|map
operator|=
name|stab
argument_list|(
name|p
argument_list|,
name|ST_MAP
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Map named \"%s\" not found\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|MF_OPEN
argument_list|,
name|map
operator|->
name|s_map
operator|.
name|map_mflags
argument_list|)
operator|&&
operator|!
name|openmap
argument_list|(
operator|&
operator|(
name|map
operator|->
name|s_map
operator|)
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Map named \"%s\" not open\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"map_lookup: %s (%s) "
argument_list|,
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|av
index|[
literal|0
index|]
operator|=
name|q
expr_stmt|;
name|av
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
call|(
modifier|*
name|map
operator|->
name|s_map
operator|.
name|map_class
operator|->
name|map_lookup
call|)
argument_list|(
operator|&
name|map
operator|->
name|s_map
argument_list|,
name|q
argument_list|,
name|av
argument_list|,
operator|&
name|rcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"no match (%d)\n"
argument_list|,
name|rcode
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"returns %s (%d)\n"
argument_list|,
name|p
argument_list|,
name|rcode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|,
literal|"try"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|MAILER
modifier|*
name|m
decl_stmt|;
name|STAB
modifier|*
name|st
decl_stmt|;
specifier|auto
name|int
name|rcode
init|=
name|EX_OK
decl_stmt|;
name|q
operator|=
name|strpbrk
argument_list|(
name|p
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|q
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|q
argument_list|)
condition|)
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|==
name|NULL
operator|||
operator|*
name|q
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"Usage: /try mailer address\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|st
operator|=
name|stab
argument_list|(
name|p
argument_list|,
name|ST_MAILER
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Unknown mailer %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|m
operator|=
name|st
operator|->
name|s_mailer
expr_stmt|;
name|printf
argument_list|(
literal|"Trying %s %s address %s for mailer %s\n"
argument_list|,
name|bitset
argument_list|(
name|RF_HEADERADDR
argument_list|,
name|tryflags
argument_list|)
condition|?
literal|"header"
else|:
literal|"envelope"
argument_list|,
name|bitset
argument_list|(
name|RF_SENDERADDR
argument_list|,
name|tryflags
argument_list|)
condition|?
literal|"sender"
else|:
literal|"recipient"
argument_list|,
name|q
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|remotename
argument_list|(
name|q
argument_list|,
name|m
argument_list|,
name|tryflags
argument_list|,
operator|&
name|rcode
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Rcode = %d, addr = %s\n"
argument_list|,
name|rcode
argument_list|,
name|p
operator|==
name|NULL
condition|?
literal|"<NULL>"
else|:
name|p
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|,
literal|"tryflags"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"Usage: /tryflags [Hh|Ee][Ss|Rr]\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'H'
case|:
case|case
literal|'h'
case|:
name|tryflags
operator||=
name|RF_HEADERADDR
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
name|tryflags
operator|&=
operator|~
name|RF_HEADERADDR
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
name|tryflags
operator||=
name|RF_SENDERADDR
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
case|case
literal|'r'
case|:
name|tryflags
operator|&=
operator|~
name|RF_SENDERADDR
expr_stmt|;
break|break;
block|}
block|}
if|#
directive|if
name|_FFR_ADDR_TYPE
name|exbuf
index|[
literal|0
index|]
operator|=
name|bitset
argument_list|(
name|RF_HEADERADDR
argument_list|,
name|tryflags
argument_list|)
condition|?
literal|'h'
else|:
literal|'e'
expr_stmt|;
name|exbuf
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|exbuf
index|[
literal|2
index|]
operator|=
name|bitset
argument_list|(
name|RF_SENDERADDR
argument_list|,
name|tryflags
argument_list|)
condition|?
literal|'s'
else|:
literal|'r'
expr_stmt|;
name|exbuf
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{addr_type}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|exbuf
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_ADDR_TYPE */
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|,
literal|"parse"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"Usage: /parse address\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|q
operator|=
name|crackaddr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Cracked address = "
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nParsing %s %s address\n"
argument_list|,
name|bitset
argument_list|(
name|RF_HEADERADDR
argument_list|,
name|tryflags
argument_list|)
condition|?
literal|"header"
else|:
literal|"envelope"
argument_list|,
name|bitset
argument_list|(
name|RF_SENDERADDR
argument_list|,
name|tryflags
argument_list|)
condition|?
literal|"sender"
else|:
literal|"recipient"
argument_list|)
expr_stmt|;
if|if
condition|(
name|parseaddr
argument_list|(
name|p
argument_list|,
operator|&
name|a
argument_list|,
name|tryflags
argument_list|,
literal|'\0'
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"Cannot parse\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|.
name|q_host
operator|!=
name|NULL
operator|&&
name|a
operator|.
name|q_host
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|printf
argument_list|(
literal|"mailer %s, host %s, user %s\n"
argument_list|,
name|a
operator|.
name|q_mailer
operator|->
name|m_name
argument_list|,
name|a
operator|.
name|q_host
argument_list|,
name|a
operator|.
name|q_user
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"mailer %s, user %s\n"
argument_list|,
name|a
operator|.
name|q_mailer
operator|->
name|m_name
argument_list|,
name|a
operator|.
name|q_user
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Unknown \"/\" command %s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
for|for
control|(
name|p
operator|=
name|line
init|;
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"No address!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|invalidaddr
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
return|return;
do|do
block|{
specifier|register
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
name|char
name|pvpbuf
index|[
name|PSBUFSIZE
index|]
decl_stmt|;
name|pvp
operator|=
name|prescan
argument_list|(
operator|++
name|p
argument_list|,
literal|','
argument_list|,
name|pvpbuf
argument_list|,
sizeof|sizeof
name|pvpbuf
argument_list|,
operator|&
name|delimptr
argument_list|,
name|ConfigLevel
operator|>=
literal|9
condition|?
name|TokTypeNoC
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
continue|continue;
name|p
operator|=
name|q
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|status
decl_stmt|;
name|rs
operator|=
name|strtorwset
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Undefined ruleset %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
name|status
operator|=
name|rewrite
argument_list|(
name|pvp
argument_list|,
name|rs
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|EX_OK
condition|)
name|printf
argument_list|(
literal|"== Ruleset %s (%d) status %d\n"
argument_list|,
name|p
argument_list|,
name|rs
argument_list|,
name|status
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|++
operator|!=
literal|','
condition|)
continue|continue;
block|}
block|}
do|while
condition|(
operator|*
operator|(
name|p
operator|=
name|delimptr
operator|)
operator|!=
literal|'\0'
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_class
parameter_list|(
name|s
parameter_list|,
name|id
parameter_list|)
specifier|register
name|STAB
modifier|*
name|s
decl_stmt|;
name|int
name|id
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|->
name|s_type
operator|!=
name|ST_CLASS
condition|)
return|return;
if|if
condition|(
name|bitnset
argument_list|(
name|bitidx
argument_list|(
name|id
argument_list|)
argument_list|,
name|s
operator|->
name|s_class
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|s
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

