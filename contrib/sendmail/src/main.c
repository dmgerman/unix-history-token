begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998-2006 Sendmail, Inc. and its suppliers.  *	All rights reserved.  * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_define
define|#
directive|define
name|_DEFINE
end_define

begin_include
include|#
directive|include
file|<sendmail.h>
end_include

begin_include
include|#
directive|include
file|<sm/sendmail.h>
end_include

begin_include
include|#
directive|include
file|<sm/xtrap.h>
end_include

begin_include
include|#
directive|include
file|<sm/signal.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_macro
name|SM_UNUSED
argument_list|(
argument|static char copyright[]
argument_list|)
end_macro

begin_expr_stmt
operator|=
literal|"@(#) Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.\n\ 	All rights reserved.\n\      Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.\n\      Copyright (c) 1988, 1993\n\ 	The Regents of the University of California.  All rights reserved.\n"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! lint */
end_comment

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: main.c,v 8.962 2006/12/19 19:47:37 ca Exp $"
argument_list|)
end_macro

begin_if
if|#
directive|if
name|NETINET
operator|||
name|NETINET6
end_if

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NETINET || NETINET6 */
end_comment

begin_comment
comment|/* for getcfname() */
end_comment

begin_include
include|#
directive|include
file|<sendmail/pathnames.h>
end_include

begin_decl_stmt
specifier|static
name|SM_DEBUG_T
name|DebugNoPRestart
init|=
name|SM_DEBUG_INITIALIZER
argument_list|(
literal|"no_persistent_restart"
argument_list|,
literal|"@(#)$Debug: no_persistent_restart - don't restart, log only $"
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_class
name|__P
argument_list|(
operator|(
name|STAB
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|obsolete
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|testmodeline
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|getextenv
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sm_printoptions
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SIGFUNC_DECL
name|intindebug
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SIGFUNC_DECL
name|sighup
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SIGFUNC_DECL
name|sigpipe
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SIGFUNC_DECL
name|sigterm
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SIGUSR1
end_ifdef

begin_decl_stmt
specifier|static
name|SIGFUNC_DECL
name|sigusr1
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIGUSR1 */
end_comment

begin_comment
comment|/* **  SENDMAIL -- Post mail to a set of destinations. ** **	This is the basic mail router.  All user mail programs should **	call this routine to actually deliver mail.  Sendmail in **	turn calls a bunch of mail servers that do the real work of **	delivering the mail. ** **	Sendmail is driven by settings read in from /etc/mail/sendmail.cf **	(read by readcf.c). ** **	Usage: **		/usr/lib/sendmail [flags] addr ... ** **		See the associated documentation for details. ** **	Authors: **		Eric Allman, UCB/INGRES (until 10/81). **			     Britton-Lee, Inc., purveyors of fine **				database computers (11/81 - 10/88). **			     International Computer Science Institute **				(11/88 - 9/89). **			     UCB/Mammoth Project (10/89 - 7/95). **			     InReference, Inc. (8/95 - 1/97). **			     Sendmail, Inc. (1/98 - present). **		The support of my employers is gratefully acknowledged. **			Few of them (Britton-Lee in particular) have had **			anything to gain from my involvement in this project. ** **		Gregory Neil Shapiro, **			Worcester Polytechnic Institute	(until 3/98). **			Sendmail, Inc. (3/98 - present). ** **		Claus Assmann, **			Sendmail, Inc. (12/98 - present). */
end_comment

begin_decl_stmt
name|char
modifier|*
name|FullName
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sender's full name */
end_comment

begin_decl_stmt
name|ENVELOPE
name|BlankEnvelope
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a "blank" envelope */
end_comment

begin_decl_stmt
specifier|static
name|ENVELOPE
name|MainEnvelope
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the envelope around the basic letter */
end_comment

begin_decl_stmt
name|ADDRESS
name|NullAddress
init|=
comment|/* a null address */
block|{
literal|""
block|,
literal|""
block|,
name|NULL
block|,
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|CommandLineArgs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* command line args for pid file */
end_comment

begin_decl_stmt
name|bool
name|Warn_Q_option
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* warn about Q option use */
end_comment

begin_decl_stmt
specifier|static
name|int
name|MissingFds
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bit map of fds missing on startup */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Mbdb
init|=
literal|"pw"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mailbox database defaults to /etc/passwd */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NGROUPS_MAX
end_ifdef

begin_decl_stmt
name|GIDSET_T
name|InitialGidSet
index|[
name|NGROUPS_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NGROUPS_MAX */
end_comment

begin_define
define|#
directive|define
name|MAXCONFIGLEVEL
value|10
end_define

begin_comment
comment|/* highest config version level known */
end_comment

begin_if
if|#
directive|if
name|SASL
end_if

begin_decl_stmt
specifier|static
name|sasl_callback_t
name|srvcallbacks
index|[]
init|=
block|{
block|{
name|SASL_CB_VERIFYFILE
block|,
operator|&
name|safesaslfile
block|,
name|NULL
block|}
block|,
block|{
name|SASL_CB_PROXY_POLICY
block|,
operator|&
name|proxy_policy
block|,
name|NULL
block|}
block|,
block|{
name|SASL_CB_LIST_END
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SASL */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|SubmitMode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|SyslogPrefixLen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* estimated length of syslog prefix */
end_comment

begin_define
define|#
directive|define
name|PIDLEN
value|6
end_define

begin_comment
comment|/* pid length for computing SyslogPrefixLen */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SL_FUDGE
end_ifndef

begin_define
define|#
directive|define
name|SL_FUDGE
value|10
end_define

begin_comment
comment|/* fudge offset for SyslogPrefixLen */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! SL_FUDGE */
end_comment

begin_define
define|#
directive|define
name|SLDLL
value|8
end_define

begin_comment
comment|/* est. length of default syslog label */
end_comment

begin_comment
comment|/* Some options are dangerous to allow users to use in non-submit mode */
end_comment

begin_define
define|#
directive|define
name|CHECK_AGAINST_OPMODE
parameter_list|(
name|cmd
parameter_list|)
define|\
value|{									\ 	if (extraprivs&&						\ 	    OpMode != MD_DELIVER&& OpMode != MD_SMTP&&		\ 	    OpMode != MD_ARPAFTP&&					\ 	    OpMode != MD_VERIFY&& OpMode != MD_TEST)			\ 	{								\ 		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,		\ 				     "WARNING: Ignoring submission mode -%c option (not in submission mode)\n", \ 		       (cmd));						\ 		break;							\ 	}								\ 	if (extraprivs&& queuerun)					\ 	{								\ 		(void) sm_io_fprintf(smioout, SM_TIME_DEFAULT,		\ 				     "WARNING: Ignoring submission mode -%c option with -q\n", \ 		       (cmd));						\ 		break;							\ 	}								\ }
end_define

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|envp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
specifier|extern
name|char
name|Version
index|[]
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|,
modifier|*
name|from
decl_stmt|;
name|STAB
modifier|*
name|st
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|dp
decl_stmt|;
name|int
name|fill_errno
decl_stmt|;
name|int
name|qgrp
init|=
name|NOQGRP
decl_stmt|;
comment|/* queue group to process */
name|bool
name|safecf
init|=
name|true
decl_stmt|;
name|BITMAP256
modifier|*
name|p_flags
init|=
name|NULL
decl_stmt|;
comment|/* daemon flags */
name|bool
name|warn_C_flag
init|=
name|false
decl_stmt|;
name|bool
name|auth
init|=
name|true
decl_stmt|;
comment|/* whether to set e_auth_param */
name|char
name|warn_f_flag
init|=
literal|'\0'
decl_stmt|;
name|bool
name|run_in_foreground
init|=
name|false
decl_stmt|;
comment|/* -bD mode */
name|bool
name|queuerun
init|=
name|false
decl_stmt|,
name|debug
init|=
name|false
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|nullserver
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|authinfo
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|sysloglabel
init|=
name|NULL
decl_stmt|;
comment|/* label for syslog */
name|char
modifier|*
name|conffile
init|=
name|NULL
decl_stmt|;
comment|/* name of .cf file */
name|char
modifier|*
name|queuegroup
init|=
name|NULL
decl_stmt|;
comment|/* queue group to process */
name|char
modifier|*
name|quarantining
init|=
name|NULL
decl_stmt|;
comment|/* quarantine queue items? */
name|bool
name|extraprivs
decl_stmt|;
name|bool
name|forged
decl_stmt|,
name|negate
decl_stmt|;
name|bool
name|queuepersistent
init|=
name|false
decl_stmt|;
comment|/* queue runner process runs forever */
name|bool
name|foregroundqueue
init|=
name|false
decl_stmt|;
comment|/* queue run in foreground */
name|bool
name|save_val
decl_stmt|;
comment|/* to save some bool var. */
name|int
name|cftype
decl_stmt|;
comment|/* which cf file to use? */
name|SM_FILE_T
modifier|*
name|smdebug
decl_stmt|;
specifier|static
name|time_t
name|starttime
init|=
literal|0
decl_stmt|;
comment|/* when was process started */
name|struct
name|stat
name|traf_st
decl_stmt|;
comment|/* for TrafficLog FIFO check */
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|char
name|jbuf
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
comment|/* holds MyHostName */
specifier|static
name|char
name|rnamebuf
index|[
name|MAXNAME
index|]
decl_stmt|;
comment|/* holds RealUserName */
name|char
modifier|*
name|emptyenviron
index|[
literal|1
index|]
decl_stmt|;
if|#
directive|if
name|STARTTLS
name|bool
name|tls_ok
decl_stmt|;
endif|#
directive|endif
comment|/* STARTTLS */
name|QUEUE_CHAR
modifier|*
name|new
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
specifier|extern
name|int
name|DtableSize
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
specifier|extern
name|int
name|opterr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
if|#
directive|if
name|SASL
specifier|extern
name|void
name|sm_sasl_init
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* SASL */
if|#
directive|if
name|USE_ENVIRON
name|envp
operator|=
name|environ
expr_stmt|;
endif|#
directive|endif
comment|/* USE_ENVIRON */
comment|/* turn off profiling */
name|SM_PROF
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* install default exception handler */
name|sm_exc_newthread
argument_list|(
name|fatal_error
argument_list|)
expr_stmt|;
comment|/* set the default in/out channel so errors reported to screen */
name|InChannel
operator|=
name|smioin
expr_stmt|;
name|OutChannel
operator|=
name|smioout
expr_stmt|;
comment|/* 	**  Check to see if we reentered. 	**	This would normally happen if e_putheader or e_putbody 	**	were NULL when invoked. 	*/
if|if
condition|(
name|starttime
operator|!=
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"main: reentered!"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|starttime
operator|=
name|curtime
argument_list|()
expr_stmt|;
comment|/* avoid null pointer dereferences */
name|TermEscape
operator|.
name|te_rv_on
operator|=
name|TermEscape
operator|.
name|te_under_on
operator|=
name|TermEscape
operator|.
name|te_normal
operator|=
literal|""
expr_stmt|;
name|RealUid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|RealGid
operator|=
name|getgid
argument_list|()
expr_stmt|;
comment|/* Check if sendmail is running with extra privs */
name|extraprivs
operator|=
operator|(
name|RealUid
operator|!=
literal|0
operator|&&
operator|(
name|geteuid
argument_list|()
operator|!=
name|getuid
argument_list|()
operator|||
name|getegid
argument_list|()
operator|!=
name|getgid
argument_list|()
operator|)
operator|)
expr_stmt|;
name|CurrentPid
operator|=
name|getpid
argument_list|()
expr_stmt|;
comment|/* get whatever .cf file is right for the opmode */
name|cftype
operator|=
name|SM_GET_RIGHT_CF
expr_stmt|;
comment|/* in 4.4BSD, the table can be huge; impose a reasonable limit */
name|DtableSize
operator|=
name|getdtsize
argument_list|()
expr_stmt|;
if|if
condition|(
name|DtableSize
operator|>
literal|256
condition|)
name|DtableSize
operator|=
literal|256
expr_stmt|;
comment|/* 	**  Be sure we have enough file descriptors. 	**	But also be sure that 0, 1,& 2 are open. 	*/
comment|/* reset errno and fill_errno; the latter is used way down below */
name|errno
operator|=
name|fill_errno
operator|=
literal|0
expr_stmt|;
name|fill_fd
argument_list|(
name|STDIN_FILENO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|fill_errno
operator|=
name|errno
expr_stmt|;
name|fill_fd
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|fill_errno
operator|=
name|errno
expr_stmt|;
name|fill_fd
argument_list|(
name|STDERR_FILENO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|fill_errno
operator|=
name|errno
expr_stmt|;
name|sm_closefrom
argument_list|(
name|STDERR_FILENO
operator|+
literal|1
argument_list|,
name|DtableSize
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|smdebug
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|LOG
ifndef|#
directive|ifndef
name|SM_LOG_STR
define|#
directive|define
name|SM_LOG_STR
value|"sendmail"
endif|#
directive|endif
comment|/* ! SM_LOG_STR */
ifdef|#
directive|ifdef
name|LOG_MAIL
name|openlog
argument_list|(
name|SM_LOG_STR
argument_list|,
name|LOG_PID
argument_list|,
name|LOG_MAIL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* LOG_MAIL */
name|openlog
argument_list|(
name|SM_LOG_STR
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOG_MAIL */
endif|#
directive|endif
comment|/* LOG */
comment|/* 	**  Seed the random number generator. 	**  Used for queue file names, picking a queue directory, and 	**  MX randomization. 	*/
name|seed_random
argument_list|()
expr_stmt|;
comment|/* do machine-dependent initializations */
name|init_md
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|SyslogPrefixLen
operator|=
name|PIDLEN
operator|+
operator|(
name|MAXQFNAME
operator|-
literal|3
operator|)
operator|+
name|SL_FUDGE
operator|+
name|SLDLL
expr_stmt|;
comment|/* reset status from syserr() calls for missing file descriptors */
name|Errors
operator|=
literal|0
expr_stmt|;
name|ExitStat
operator|=
name|EX_OK
expr_stmt|;
name|SubmitMode
operator|=
name|SUBMIT_UNKNOWN
expr_stmt|;
if|#
directive|if
name|XDEBUG
name|checkfd012
argument_list|(
literal|"after openlog"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XDEBUG */
name|tTsetup
argument_list|(
name|tTdvect
argument_list|,
sizeof|sizeof
argument_list|(
name|tTdvect
argument_list|)
argument_list|,
literal|"0-99.1,*_trace_*.1"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NGROUPS_MAX
comment|/* save initial group set for future checks */
name|i
operator|=
name|getgroups
argument_list|(
name|NGROUPS_MAX
argument_list|,
name|InitialGidSet
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
name|InitialGidSet
index|[
literal|0
index|]
operator|=
operator|(
name|GID_T
operator|)
operator|-
literal|1
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|<
name|NGROUPS_MAX
condition|)
name|InitialGidSet
index|[
name|i
operator|++
index|]
operator|=
name|InitialGidSet
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* NGROUPS_MAX */
comment|/* drop group id privileges (RunAsUser not yet set) */
name|dp
operator|=
name|drop_privileges
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|setstat
argument_list|(
name|dp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGUSR1
comment|/* Only allow root (or non-set-*-ID binaries) to use SIGUSR1 */
if|if
condition|(
operator|!
name|extraprivs
condition|)
block|{
comment|/* arrange to dump state on user-1 signal */
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGUSR1
argument_list|,
name|sigusr1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ignore user-1 signal */
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGUSR1
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SIGUSR1 */
comment|/* initialize for setproctitle */
name|initsetproctitle
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|envp
argument_list|)
expr_stmt|;
comment|/* Handle any non-getoptable constructions. */
name|obsolete
argument_list|(
name|argv
argument_list|)
expr_stmt|;
comment|/* 	**  Do a quick prescan of the argument list. 	*/
comment|/* find initial opMode */
name|OpMode
operator|=
name|MD_DELIVER
expr_stmt|;
name|av
operator|=
name|argv
expr_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
operator|*
name|av
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|++
operator|==
name|NULL
condition|)
name|p
operator|=
operator|*
name|av
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"newaliases"
argument_list|)
operator|==
literal|0
condition|)
name|OpMode
operator|=
name|MD_INITALIAS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"mailq"
argument_list|)
operator|==
literal|0
condition|)
name|OpMode
operator|=
name|MD_PRINT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"smtpd"
argument_list|)
operator|==
literal|0
condition|)
name|OpMode
operator|=
name|MD_DAEMON
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"hoststat"
argument_list|)
operator|==
literal|0
condition|)
name|OpMode
operator|=
name|MD_HOSTSTAT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"purgestat"
argument_list|)
operator|==
literal|0
condition|)
name|OpMode
operator|=
name|MD_PURGESTAT
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|||
name|defined
argument_list|(
name|_AIX3
argument_list|)
define|#
directive|define
name|OPTIONS
value|"A:B:b:C:cD:d:e:F:f:Gh:IiL:M:mN:nO:o:p:Q:q:R:r:sTtV:vX:x"
endif|#
directive|endif
comment|/* defined(__osf__) || defined(_AIX3) */
if|#
directive|if
name|defined
argument_list|(
name|sony_news
argument_list|)
define|#
directive|define
name|OPTIONS
value|"A:B:b:C:cD:d:E:e:F:f:Gh:IiJ:L:M:mN:nO:o:p:Q:q:R:r:sTtV:vX:"
endif|#
directive|endif
comment|/* defined(sony_news) */
ifndef|#
directive|ifndef
name|OPTIONS
define|#
directive|define
name|OPTIONS
value|"A:B:b:C:cD:d:e:F:f:Gh:IiL:M:mN:nO:o:p:Q:q:R:r:sTtV:vX:"
endif|#
directive|endif
comment|/* ! OPTIONS */
comment|/* Set to 0 to allow -b; need to check optarg before using it! */
name|opterr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|j
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|OPTIONS
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|j
condition|)
block|{
case|case
literal|'b'
case|:
comment|/* operations mode */
name|j
operator|=
operator|(
name|optarg
operator|==
name|NULL
operator|)
condition|?
literal|' '
else|:
operator|*
name|optarg
expr_stmt|;
switch|switch
condition|(
name|j
condition|)
block|{
case|case
name|MD_DAEMON
case|:
case|case
name|MD_FGDAEMON
case|:
case|case
name|MD_SMTP
case|:
case|case
name|MD_INITALIAS
case|:
case|case
name|MD_DELIVER
case|:
case|case
name|MD_VERIFY
case|:
case|case
name|MD_TEST
case|:
case|case
name|MD_PRINT
case|:
case|case
name|MD_PRINTNQE
case|:
case|case
name|MD_HOSTSTAT
case|:
case|case
name|MD_PURGESTAT
case|:
case|case
name|MD_ARPAFTP
case|:
name|OpMode
operator|=
name|j
expr_stmt|;
break|break;
case|case
name|MD_FREEZE
case|:
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Frozen configurations unsupported\n"
argument_list|)
expr_stmt|;
return|return
name|EX_USAGE
return|;
default|default:
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Invalid operation mode %c\n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
return|return
name|EX_USAGE
return|;
block|}
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|debug
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|syserr
argument_list|(
literal|"-D file must be before -d"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
block|}
name|dp
operator|=
name|drop_privileges
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|setstat
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|smdebug
operator|=
name|sm_io_open
argument_list|(
name|SmFtStdio
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|optarg
argument_list|,
name|SM_IO_APPEND
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|smdebug
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"cannot open %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_CANTCREAT
expr_stmt|;
break|break;
block|}
name|sm_debug_setfile
argument_list|(
name|smdebug
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|debug
operator|=
name|true
expr_stmt|;
name|tTflag
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_setvbuf
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|SM_IO_NBF
argument_list|,
name|SM_IO_BUFSIZ
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
comment|/* relay (gateway) submission */
name|SubmitMode
operator|=
name|SUBMIT_MTA
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
if|if
condition|(
name|optarg
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"option requires an argument -- '%c'"
argument_list|,
operator|(
name|char
operator|)
name|j
argument_list|)
expr_stmt|;
return|return
name|EX_USAGE
return|;
block|}
name|j
operator|=
name|SM_MIN
argument_list|(
name|strlen
argument_list|(
name|optarg
argument_list|)
argument_list|,
literal|32
argument_list|)
operator|+
literal|1
expr_stmt|;
name|sysloglabel
operator|=
name|xalloc
argument_list|(
name|j
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|sysloglabel
argument_list|,
name|optarg
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|SyslogPrefixLen
operator|=
name|PIDLEN
operator|+
operator|(
name|MAXQFNAME
operator|-
literal|3
operator|)
operator|+
name|SL_FUDGE
operator|+
name|j
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
case|case
literal|'q'
case|:
comment|/* just check if it is there */
name|queuerun
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
name|opterr
operator|=
literal|1
expr_stmt|;
comment|/* Don't leak queue information via debug flags */
if|if
condition|(
name|extraprivs
operator|&&
name|queuerun
operator|&&
name|debug
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"WARNING: Can not use -d with -q.  Disabling debugging.\n"
argument_list|)
expr_stmt|;
name|sm_debug_close
argument_list|()
expr_stmt|;
name|sm_debug_setfile
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|tTdvect
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|tTdvect
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|LOG
if|if
condition|(
name|sysloglabel
operator|!=
name|NULL
condition|)
block|{
comment|/* Sanitize the string */
for|for
control|(
name|p
operator|=
name|sysloglabel
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|!
name|isprint
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'%'
condition|)
operator|*
name|p
operator|=
literal|'*'
expr_stmt|;
block|}
name|closelog
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG_MAIL
name|openlog
argument_list|(
name|sysloglabel
argument_list|,
name|LOG_PID
argument_list|,
name|LOG_MAIL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* LOG_MAIL */
name|openlog
argument_list|(
name|sysloglabel
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOG_MAIL */
block|}
endif|#
directive|endif
comment|/* LOG */
comment|/* set up the blank envelope */
name|BlankEnvelope
operator|.
name|e_puthdr
operator|=
name|putheader
expr_stmt|;
name|BlankEnvelope
operator|.
name|e_putbody
operator|=
name|putbody
expr_stmt|;
name|BlankEnvelope
operator|.
name|e_xfp
operator|=
name|NULL
expr_stmt|;
name|STRUCTCOPY
argument_list|(
name|NullAddress
argument_list|,
name|BlankEnvelope
operator|.
name|e_from
argument_list|)
expr_stmt|;
name|CurEnv
operator|=
operator|&
name|BlankEnvelope
expr_stmt|;
name|STRUCTCOPY
argument_list|(
name|NullAddress
argument_list|,
name|MainEnvelope
operator|.
name|e_from
argument_list|)
expr_stmt|;
comment|/* 	**  Set default values for variables. 	**	These cannot be in initialized data space. 	*/
name|setdefaults
argument_list|(
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
name|initmacros
argument_list|(
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
comment|/* reset macro */
name|set_op_mode
argument_list|(
name|OpMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|OpMode
operator|==
name|MD_DAEMON
condition|)
name|DaemonPid
operator|=
name|CurrentPid
expr_stmt|;
comment|/* needed for finis() to work */
name|pw
operator|=
name|sm_getpwuid
argument_list|(
name|RealUid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|rnamebuf
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
sizeof|sizeof
argument_list|(
name|rnamebuf
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|rnamebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|rnamebuf
argument_list|)
argument_list|,
literal|"Unknown UID %d"
argument_list|,
operator|(
name|int
operator|)
name|RealUid
argument_list|)
expr_stmt|;
name|RealUserName
operator|=
name|rnamebuf
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|101
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"Version %s\n"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|false
argument_list|,
name|true
argument_list|,
name|EX_OK
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* 	**  if running non-set-user-ID binary as non-root, pretend 	**  we are the RunAsUid 	*/
if|if
condition|(
name|RealUid
operator|!=
literal|0
operator|&&
name|geteuid
argument_list|()
operator|==
name|RealUid
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|47
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"Non-set-user-ID binary: RunAsUid = RealUid = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|RealUid
argument_list|)
expr_stmt|;
name|RunAsUid
operator|=
name|RealUid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|geteuid
argument_list|()
operator|!=
literal|0
condition|)
name|RunAsUid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
name|EffGid
operator|=
name|getegid
argument_list|()
expr_stmt|;
if|if
condition|(
name|RealUid
operator|!=
literal|0
operator|&&
name|EffGid
operator|==
name|RealGid
condition|)
name|RunAsGid
operator|=
name|RealGid
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|47
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"main: e/ruid = %d/%d e/rgid = %d/%d\n"
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getegid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"main: RunAsUser = %d:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|RunAsUid
argument_list|,
operator|(
name|int
operator|)
name|RunAsGid
argument_list|)
expr_stmt|;
block|}
comment|/* save command line arguments */
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|av
operator|=
name|argv
init|;
operator|*
name|av
operator|!=
name|NULL
condition|;
control|)
name|j
operator|+=
name|strlen
argument_list|(
operator|*
name|av
operator|++
argument_list|)
operator|+
literal|1
expr_stmt|;
name|SaveArgv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|argc
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|CommandLineArgs
operator|=
name|xalloc
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|p
operator|=
name|CommandLineArgs
expr_stmt|;
for|for
control|(
name|av
operator|=
name|argv
operator|,
name|i
operator|=
literal|0
init|;
operator|*
name|av
operator|!=
name|NULL
condition|;
control|)
block|{
name|int
name|h
decl_stmt|;
name|SaveArgv
index|[
name|i
operator|++
index|]
operator|=
name|newstr
argument_list|(
operator|*
name|av
argument_list|)
expr_stmt|;
if|if
condition|(
name|av
operator|!=
name|argv
condition|)
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|p
argument_list|,
operator|*
name|av
operator|++
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|h
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|h
expr_stmt|;
name|j
operator|-=
name|h
operator|+
literal|1
expr_stmt|;
block|}
name|SaveArgv
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
specifier|extern
name|char
modifier|*
name|CompileOptions
index|[]
decl_stmt|;
name|sm_dprintf
argument_list|(
literal|"Version %s\n Compiled with:"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
name|sm_printoptions
argument_list|(
name|CompileOptions
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|10
argument_list|)
condition|)
block|{
specifier|extern
name|char
modifier|*
name|OsCompileOptions
index|[]
decl_stmt|;
name|sm_dprintf
argument_list|(
literal|"    OS Defines:"
argument_list|)
expr_stmt|;
name|sm_printoptions
argument_list|(
name|OsCompileOptions
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_PATH_UNIX
name|sm_dprintf
argument_list|(
literal|"Kernel symbols:\t%s\n"
argument_list|,
name|_PATH_UNIX
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _PATH_UNIX */
name|sm_dprintf
argument_list|(
literal|"     Conf file:\t%s (default for MSP)\n"
argument_list|,
name|getcfname
argument_list|(
name|OpMode
argument_list|,
name|SubmitMode
argument_list|,
name|SM_GET_SUBMIT_CF
argument_list|,
name|conffile
argument_list|)
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"     Conf file:\t%s (default for MTA)\n"
argument_list|,
name|getcfname
argument_list|(
name|OpMode
argument_list|,
name|SubmitMode
argument_list|,
name|SM_GET_SENDMAIL_CF
argument_list|,
name|conffile
argument_list|)
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"      Pid file:\t%s (default)\n"
argument_list|,
name|PidFile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|12
argument_list|)
condition|)
block|{
specifier|extern
name|char
modifier|*
name|SmCompileOptions
index|[]
decl_stmt|;
name|sm_dprintf
argument_list|(
literal|" libsm Defines:"
argument_list|)
expr_stmt|;
name|sm_printoptions
argument_list|(
name|SmCompileOptions
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|13
argument_list|)
condition|)
block|{
specifier|extern
name|char
modifier|*
name|FFRCompileOptions
index|[]
decl_stmt|;
name|sm_dprintf
argument_list|(
literal|"   FFR Defines:"
argument_list|)
expr_stmt|;
name|sm_printoptions
argument_list|(
name|FFRCompileOptions
argument_list|)
expr_stmt|;
block|}
comment|/* clear sendmail's environment */
name|ExternalEnviron
operator|=
name|environ
expr_stmt|;
name|emptyenviron
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|environ
operator|=
name|emptyenviron
expr_stmt|;
comment|/* 	**  restore any original TZ setting until TimeZoneSpec has been 	**  determined - or early log messages may get bogus time stamps 	*/
if|if
condition|(
operator|(
name|p
operator|=
name|getextenv
argument_list|(
literal|"TZ"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|tz
decl_stmt|;
name|int
name|tzlen
decl_stmt|;
comment|/* XXX check for reasonable length? */
name|tzlen
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|4
expr_stmt|;
name|tz
operator|=
name|xalloc
argument_list|(
name|tzlen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|tz
argument_list|,
name|tzlen
argument_list|,
literal|2
argument_list|,
literal|"TZ="
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* XXX check return code? */
operator|(
name|void
operator|)
name|putenv
argument_list|(
name|tz
argument_list|)
expr_stmt|;
block|}
comment|/* prime the child environment */
name|sm_setuserenv
argument_list|(
literal|"AGENT"
argument_list|,
literal|"sendmail"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|OldUmask
operator|=
name|umask
argument_list|(
literal|022
argument_list|)
expr_stmt|;
name|FullName
operator|=
name|getextenv
argument_list|(
literal|"NAME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|FullName
operator|!=
name|NULL
condition|)
name|FullName
operator|=
name|newstr
argument_list|(
name|FullName
argument_list|)
expr_stmt|;
comment|/* 	**  Initialize name server if it is going to be used. 	*/
if|#
directive|if
name|NAMED_BIND
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|RES_INIT
argument_list|,
name|_res
operator|.
name|options
argument_list|)
condition|)
operator|(
name|void
operator|)
name|res_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|8
argument_list|,
literal|8
argument_list|)
condition|)
name|_res
operator|.
name|options
operator||=
name|RES_DEBUG
expr_stmt|;
else|else
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_DEBUG
expr_stmt|;
ifdef|#
directive|ifdef
name|RES_NOALIASES
name|_res
operator|.
name|options
operator||=
name|RES_NOALIASES
expr_stmt|;
endif|#
directive|endif
comment|/* RES_NOALIASES */
name|TimeOuts
operator|.
name|res_retry
index|[
name|RES_TO_DEFAULT
index|]
operator|=
name|_res
operator|.
name|retry
expr_stmt|;
name|TimeOuts
operator|.
name|res_retry
index|[
name|RES_TO_FIRST
index|]
operator|=
name|_res
operator|.
name|retry
expr_stmt|;
name|TimeOuts
operator|.
name|res_retry
index|[
name|RES_TO_NORMAL
index|]
operator|=
name|_res
operator|.
name|retry
expr_stmt|;
name|TimeOuts
operator|.
name|res_retrans
index|[
name|RES_TO_DEFAULT
index|]
operator|=
name|_res
operator|.
name|retrans
expr_stmt|;
name|TimeOuts
operator|.
name|res_retrans
index|[
name|RES_TO_FIRST
index|]
operator|=
name|_res
operator|.
name|retrans
expr_stmt|;
name|TimeOuts
operator|.
name|res_retrans
index|[
name|RES_TO_NORMAL
index|]
operator|=
name|_res
operator|.
name|retrans
expr_stmt|;
endif|#
directive|endif
comment|/* NAMED_BIND */
name|errno
operator|=
literal|0
expr_stmt|;
name|from
operator|=
name|NULL
expr_stmt|;
comment|/* initialize some macros, etc. */
name|init_vendor_macros
argument_list|(
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
comment|/* version */
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'v'
argument_list|,
name|Version
argument_list|)
expr_stmt|;
comment|/* hostname */
name|hp
operator|=
name|myhostname
argument_list|(
name|jbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|jbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|jbuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|struct
name|utsname
name|utsname
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"Canonical name: %s\n"
argument_list|,
name|jbuf
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
literal|'w'
argument_list|,
name|jbuf
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
literal|'j'
argument_list|,
name|jbuf
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'w'
argument_list|,
name|jbuf
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|jbuf
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
literal|'m'
argument_list|,
operator|&
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|uname
argument_list|(
operator|&
name|utsname
argument_list|)
operator|>=
literal|0
condition|)
name|p
operator|=
name|utsname
operator|.
name|nodename
expr_stmt|;
else|else
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|22
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"uname failed (%s)\n"
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|makelower
argument_list|(
name|jbuf
argument_list|)
expr_stmt|;
name|p
operator|=
name|jbuf
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|" UUCP nodename: %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
literal|'k'
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'k'
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'w'
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|av
operator|=
name|hp
operator|->
name|h_aliases
init|;
name|av
operator|!=
name|NULL
operator|&&
operator|*
name|av
operator|!=
name|NULL
condition|;
name|av
operator|++
control|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"\ta.k.a.: %s\n"
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'w'
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|NETINET
operator|||
name|NETINET6
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|>=
literal|0
operator|&&
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
name|NETINET6
name|char
modifier|*
name|addr
decl_stmt|;
name|char
name|buf6
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|struct
name|in6_addr
name|ia6
decl_stmt|;
endif|#
directive|endif
comment|/* NETINET6 */
if|#
directive|if
name|NETINET
name|struct
name|in_addr
name|ia
decl_stmt|;
endif|#
directive|endif
comment|/* NETINET */
name|char
name|ipbuf
index|[
literal|103
index|]
decl_stmt|;
name|ipbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|hp
operator|->
name|h_addrtype
condition|)
block|{
if|#
directive|if
name|NETINET
case|case
name|AF_INET
case|:
if|if
condition|(
name|hp
operator|->
name|h_length
operator|!=
name|INADDRSZ
condition|)
break|break;
name|memmove
argument_list|(
operator|&
name|ia
argument_list|,
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
argument_list|,
name|INADDRSZ
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|ipbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|ipbuf
argument_list|)
argument_list|,
literal|"[%.100s]"
argument_list|,
name|inet_ntoa
argument_list|(
name|ia
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|hp
operator|->
name|h_length
operator|!=
name|IN6ADDRSZ
condition|)
break|break;
name|memmove
argument_list|(
operator|&
name|ia6
argument_list|,
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
argument_list|,
name|IN6ADDRSZ
argument_list|)
expr_stmt|;
name|addr
operator|=
name|anynet_ntop
argument_list|(
operator|&
name|ia6
argument_list|,
name|buf6
argument_list|,
sizeof|sizeof
argument_list|(
name|buf6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|ipbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|ipbuf
argument_list|)
argument_list|,
literal|"[%.100s]"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET6 */
block|}
if|if
condition|(
name|ipbuf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"\ta.k.a.: %s\n"
argument_list|,
name|ipbuf
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'w'
argument_list|,
name|ipbuf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NETINET || NETINET6 */
if|#
directive|if
name|NETINET6
name|freehostent
argument_list|(
name|hp
argument_list|)
expr_stmt|;
name|hp
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* NETINET6 */
block|}
comment|/* current time */
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
literal|'b'
argument_list|,
name|arpadate
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* current load average */
name|sm_getla
argument_list|()
expr_stmt|;
name|QueueLimitRecipient
operator|=
operator|(
name|QUEUE_CHAR
operator|*
operator|)
name|NULL
expr_stmt|;
name|QueueLimitSender
operator|=
operator|(
name|QUEUE_CHAR
operator|*
operator|)
name|NULL
expr_stmt|;
name|QueueLimitId
operator|=
operator|(
name|QUEUE_CHAR
operator|*
operator|)
name|NULL
expr_stmt|;
name|QueueLimitQuarantine
operator|=
operator|(
name|QUEUE_CHAR
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* 	**  Crack argv. 	*/
name|optind
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|j
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|OPTIONS
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|j
condition|)
block|{
case|case
literal|'b'
case|:
comment|/* operations mode */
comment|/* already done */
break|break;
case|case
literal|'A'
case|:
comment|/* use Alternate sendmail/submit.cf */
name|cftype
operator|=
name|optarg
index|[
literal|0
index|]
operator|==
literal|'c'
condition|?
name|SM_GET_SUBMIT_CF
else|:
name|SM_GET_SENDMAIL_CF
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* body type */
name|CHECK_AGAINST_OPMODE
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|BlankEnvelope
operator|.
name|e_bodytype
operator|=
name|newstr
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* select configuration file (already done) */
if|if
condition|(
name|RealUid
operator|!=
literal|0
condition|)
name|warn_C_flag
operator|=
name|true
expr_stmt|;
name|conffile
operator|=
name|newstr
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|dp
operator|=
name|drop_privileges
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|setstat
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|safecf
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
case|case
literal|'d'
case|:
comment|/* debugging */
comment|/* already done */
break|break;
case|case
literal|'f'
case|:
comment|/* from address */
case|case
literal|'r'
case|:
comment|/* obsolete -f flag */
name|CHECK_AGAINST_OPMODE
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|!=
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"More than one \"from\" person"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|optarg
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|from
operator|=
name|newstr
argument_list|(
literal|"<>"
argument_list|)
expr_stmt|;
else|else
name|from
operator|=
name|newstr
argument_list|(
name|denlstring
argument_list|(
name|optarg
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|RealUserName
argument_list|,
name|from
argument_list|)
operator|!=
literal|0
condition|)
name|warn_f_flag
operator|=
name|j
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* set full name */
name|CHECK_AGAINST_OPMODE
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|FullName
operator|=
name|newstr
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
comment|/* relay (gateway) submission */
comment|/* already set */
name|CHECK_AGAINST_OPMODE
argument_list|(
name|j
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* hop count */
name|CHECK_AGAINST_OPMODE
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|BlankEnvelope
operator|.
name|e_hopcount
operator|=
operator|(
name|short
operator|)
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|BlankEnvelope
operator|.
name|e_hopcount
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
literal|'c'
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ep
condition|)
block|{
name|usrerr
argument_list|(
literal|"Bad hop count (%s)"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
block|}
break|break;
case|case
literal|'L'
case|:
comment|/* program label */
comment|/* already set */
break|break;
case|case
literal|'n'
case|:
comment|/* don't alias */
name|CHECK_AGAINST_OPMODE
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|NoAlias
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* delivery status notifications */
name|CHECK_AGAINST_OPMODE
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|DefaultNotify
operator||=
name|QHASNOTIFY
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{dsn_notify}"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"never"
argument_list|)
operator|==
literal|0
condition|)
break|break;
for|for
control|(
name|p
operator|=
name|optarg
init|;
name|p
operator|!=
name|NULL
condition|;
name|optarg
operator|=
name|p
control|)
block|{
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"success"
argument_list|)
operator|==
literal|0
condition|)
name|DefaultNotify
operator||=
name|QPINGONSUCCESS
expr_stmt|;
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"failure"
argument_list|)
operator|==
literal|0
condition|)
name|DefaultNotify
operator||=
name|QPINGONFAILURE
expr_stmt|;
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"delay"
argument_list|)
operator|==
literal|0
condition|)
name|DefaultNotify
operator||=
name|QPINGONDELAY
expr_stmt|;
else|else
block|{
name|usrerr
argument_list|(
literal|"Invalid -N argument"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'o'
case|:
comment|/* set option */
name|setoption
argument_list|(
operator|*
name|optarg
argument_list|,
name|optarg
operator|+
literal|1
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
comment|/* set option (long form) */
name|setoption
argument_list|(
literal|' '
argument_list|,
name|optarg
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* set protocol */
name|CHECK_AGAINST_OPMODE
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ep
operator|=
name|sm_malloc_x
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|cleanstrcpy
argument_list|(
name|ep
argument_list|,
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_HEAP
argument_list|,
literal|'s'
argument_list|,
name|ep
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|optarg
operator|!=
literal|'\0'
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ep
operator|=
name|sm_malloc_x
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|cleanstrcpy
argument_list|(
name|ep
argument_list|,
name|optarg
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_HEAP
argument_list|,
literal|'r'
argument_list|,
name|ep
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'Q'
case|:
comment|/* change quarantining on queued items */
comment|/* sanity check */
if|if
condition|(
name|OpMode
operator|!=
name|MD_DELIVER
operator|&&
name|OpMode
operator|!=
name|MD_QUEUERUN
condition|)
block|{
name|usrerr
argument_list|(
literal|"Can not use -Q with -b%c"
argument_list|,
name|OpMode
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|OpMode
operator|==
name|MD_DELIVER
condition|)
name|set_op_mode
argument_list|(
name|MD_QUEUERUN
argument_list|)
expr_stmt|;
name|FullName
operator|=
name|NULL
expr_stmt|;
name|quarantining
operator|=
name|newstr
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* run queue files at intervals */
comment|/* sanity check */
if|if
condition|(
name|OpMode
operator|!=
name|MD_DELIVER
operator|&&
name|OpMode
operator|!=
name|MD_DAEMON
operator|&&
name|OpMode
operator|!=
name|MD_FGDAEMON
operator|&&
name|OpMode
operator|!=
name|MD_PRINT
operator|&&
name|OpMode
operator|!=
name|MD_PRINTNQE
operator|&&
name|OpMode
operator|!=
name|MD_QUEUERUN
condition|)
block|{
name|usrerr
argument_list|(
literal|"Can not use -q with -b%c"
argument_list|,
name|OpMode
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
block|}
comment|/* don't override -bd, -bD or -bp */
if|if
condition|(
name|OpMode
operator|==
name|MD_DELIVER
condition|)
name|set_op_mode
argument_list|(
name|MD_QUEUERUN
argument_list|)
expr_stmt|;
name|FullName
operator|=
name|NULL
expr_stmt|;
name|negate
operator|=
name|optarg
index|[
literal|0
index|]
operator|==
literal|'!'
expr_stmt|;
if|if
condition|(
name|negate
condition|)
block|{
comment|/* negate meaning of pattern match */
name|optarg
operator|++
expr_stmt|;
comment|/* skip '!' for next switch */
block|}
switch|switch
condition|(
name|optarg
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'G'
case|:
comment|/* Limit by queue group name */
if|if
condition|(
name|negate
condition|)
block|{
name|usrerr
argument_list|(
literal|"Can not use -q!G"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|queuegroup
operator|!=
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"Can not use multiple -qG options"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
block|}
name|queuegroup
operator|=
name|newstr
argument_list|(
operator|&
name|optarg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* Limit by ID */
name|new
operator|=
operator|(
name|QUEUE_CHAR
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|queue_match
operator|=
name|newstr
argument_list|(
operator|&
name|optarg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|new
operator|->
name|queue_negate
operator|=
name|negate
expr_stmt|;
name|new
operator|->
name|queue_next
operator|=
name|QueueLimitId
expr_stmt|;
name|QueueLimitId
operator|=
name|new
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* Limit by recipient */
name|new
operator|=
operator|(
name|QUEUE_CHAR
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|queue_match
operator|=
name|newstr
argument_list|(
operator|&
name|optarg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|new
operator|->
name|queue_negate
operator|=
name|negate
expr_stmt|;
name|new
operator|->
name|queue_next
operator|=
name|QueueLimitRecipient
expr_stmt|;
name|QueueLimitRecipient
operator|=
name|new
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* Limit by sender */
name|new
operator|=
operator|(
name|QUEUE_CHAR
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|queue_match
operator|=
name|newstr
argument_list|(
operator|&
name|optarg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|new
operator|->
name|queue_negate
operator|=
name|negate
expr_stmt|;
name|new
operator|->
name|queue_next
operator|=
name|QueueLimitSender
expr_stmt|;
name|QueueLimitSender
operator|=
name|new
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* foreground queue run */
name|foregroundqueue
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
comment|/* Limit by quarantine message */
if|if
condition|(
name|optarg
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|new
operator|=
operator|(
name|QUEUE_CHAR
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|queue_match
operator|=
name|newstr
argument_list|(
operator|&
name|optarg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|new
operator|->
name|queue_negate
operator|=
name|negate
expr_stmt|;
name|new
operator|->
name|queue_next
operator|=
name|QueueLimitQuarantine
expr_stmt|;
name|QueueLimitQuarantine
operator|=
name|new
expr_stmt|;
block|}
name|QueueMode
operator|=
name|QM_QUARANTINE
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* act on lost items */
name|QueueMode
operator|=
name|QM_LOST
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* Persistent queue */
name|queuepersistent
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|QueueIntvl
operator|==
literal|0
condition|)
name|QueueIntvl
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|optarg
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
break|break;
operator|++
name|optarg
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
name|i
operator|=
name|Errors
expr_stmt|;
name|QueueIntvl
operator|=
name|convtime
argument_list|(
name|optarg
argument_list|,
literal|'m'
argument_list|)
expr_stmt|;
if|if
condition|(
name|QueueIntvl
operator|<
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"Invalid -q value"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
block|}
comment|/* check for bad conversion */
if|if
condition|(
name|i
operator|<
name|Errors
condition|)
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'R'
case|:
comment|/* DSN RET: what to return */
name|CHECK_AGAINST_OPMODE
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|EF_RET_PARAM
argument_list|,
name|BlankEnvelope
operator|.
name|e_flags
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"Duplicate -R flag"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
block|}
name|BlankEnvelope
operator|.
name|e_flags
operator||=
name|EF_RET_PARAM
expr_stmt|;
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"hdrs"
argument_list|)
operator|==
literal|0
condition|)
name|BlankEnvelope
operator|.
name|e_flags
operator||=
name|EF_NO_BODY_RETN
expr_stmt|;
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"full"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"Invalid -R value"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
block|}
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{dsn_ret}"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* read recipients from message */
name|CHECK_AGAINST_OPMODE
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|GrabTo
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
comment|/* DSN ENVID: set "original" envelope id */
name|CHECK_AGAINST_OPMODE
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xtextok
argument_list|(
name|optarg
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"Invalid syntax in -V flag"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
block|}
else|else
block|{
name|BlankEnvelope
operator|.
name|e_envid
operator|=
name|newstr
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{dsn_envid}"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'X'
case|:
comment|/* traffic log file */
name|dp
operator|=
name|drop_privileges
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|setstat
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|optarg
argument_list|,
operator|&
name|traf_st
argument_list|)
operator|==
literal|0
operator|&&
name|S_ISFIFO
argument_list|(
name|traf_st
operator|.
name|st_mode
argument_list|)
condition|)
name|TrafficLogFile
operator|=
name|sm_io_open
argument_list|(
name|SmFtStdio
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|optarg
argument_list|,
name|SM_IO_WRONLY
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|TrafficLogFile
operator|=
name|sm_io_open
argument_list|(
name|SmFtStdio
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|optarg
argument_list|,
name|SM_IO_APPEND
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|TrafficLogFile
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"cannot open %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_CANTCREAT
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|sm_io_setvbuf
argument_list|(
name|TrafficLogFile
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|NULL
argument_list|,
name|SM_IO_LBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/* compatibility flags */
case|case
literal|'c'
case|:
comment|/* connect to non-local mailers */
case|case
literal|'i'
case|:
comment|/* don't let dot stop me */
case|case
literal|'m'
case|:
comment|/* send to me too */
case|case
literal|'T'
case|:
comment|/* set timeout interval */
case|case
literal|'v'
case|:
comment|/* give blow-by-blow description */
name|setoption
argument_list|(
name|j
argument_list|,
literal|"T"
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* error message disposition */
case|case
literal|'M'
case|:
comment|/* define macro */
name|setoption
argument_list|(
name|j
argument_list|,
name|optarg
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* save From lines in headers */
name|setoption
argument_list|(
literal|'f'
argument_list|,
literal|"T"
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DBM
case|case
literal|'I'
case|:
comment|/* initialize alias DBM file */
name|set_op_mode
argument_list|(
name|MD_INITALIAS
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* DBM */
if|#
directive|if
name|defined
argument_list|(
name|__osf__
argument_list|)
operator|||
name|defined
argument_list|(
name|_AIX3
argument_list|)
case|case
literal|'x'
case|:
comment|/* random flag that OSF/1& AIX mailx passes */
break|break;
endif|#
directive|endif
comment|/* defined(__osf__) || defined(_AIX3) */
if|#
directive|if
name|defined
argument_list|(
name|sony_news
argument_list|)
case|case
literal|'E'
case|:
case|case
literal|'J'
case|:
comment|/* ignore flags for Japanese code conversion 				   implemented on Sony NEWS */
break|break;
endif|#
directive|endif
comment|/* defined(sony_news) */
default|default:
name|finis
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|EX_USAGE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
break|break;
block|}
block|}
comment|/* if we've had errors so far, exit now */
if|if
condition|(
operator|(
name|ExitStat
operator|!=
name|EX_OK
operator|&&
name|OpMode
operator|!=
name|MD_TEST
operator|)
operator|||
name|ExitStat
operator|==
name|EX_OSERR
condition|)
block|{
name|finis
argument_list|(
name|false
argument_list|,
name|true
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|bitset
argument_list|(
name|SUBMIT_MTA
argument_list|,
name|SubmitMode
argument_list|)
condition|)
block|{
comment|/* If set daemon_flags on command line, don't reset it */
if|if
condition|(
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{daemon_flags}"
argument_list|)
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
operator|==
name|NULL
condition|)
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{daemon_flags}"
argument_list|)
argument_list|,
literal|"CC f"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OpMode
operator|==
name|MD_DELIVER
operator|||
name|OpMode
operator|==
name|MD_SMTP
condition|)
block|{
name|SubmitMode
operator|=
name|SUBMIT_MSA
expr_stmt|;
comment|/* If set daemon_flags on command line, don't reset it */
if|if
condition|(
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{daemon_flags}"
argument_list|)
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
operator|==
name|NULL
condition|)
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{daemon_flags}"
argument_list|)
argument_list|,
literal|"c u"
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Do basic initialization. 	**	Read system control file. 	**	Extract special fields for local use. 	*/
if|#
directive|if
name|XDEBUG
name|checkfd012
argument_list|(
literal|"before readcf"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XDEBUG */
name|vendor_pre_defaults
argument_list|(
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
name|readcf
argument_list|(
name|getcfname
argument_list|(
name|OpMode
argument_list|,
name|SubmitMode
argument_list|,
name|cftype
argument_list|,
name|conffile
argument_list|)
argument_list|,
name|safecf
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_USE_SUN_NSSWITCH_
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_USE_DEC_SVC_CONF_
argument_list|)
name|ConfigFileRead
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(_USE_SUN_NSSWITCH_)&& !defined(_USE_DEC_SVC_CONF_) */
name|vendor_post_defaults
argument_list|(
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
comment|/* now we can complain about missing fds */
if|if
condition|(
name|MissingFds
operator|!=
literal|0
operator|&&
name|LogLevel
operator|>
literal|8
condition|)
block|{
name|char
name|mbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|mbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
literal|1
operator|<<
name|STDIN_FILENO
argument_list|,
name|MissingFds
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|mbuf
argument_list|,
literal|", stdin"
argument_list|,
sizeof|sizeof
argument_list|(
name|mbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
literal|1
operator|<<
name|STDOUT_FILENO
argument_list|,
name|MissingFds
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|mbuf
argument_list|,
literal|", stdout"
argument_list|,
sizeof|sizeof
argument_list|(
name|mbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
literal|1
operator|<<
name|STDERR_FILENO
argument_list|,
name|MissingFds
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|mbuf
argument_list|,
literal|", stderr"
argument_list|,
sizeof|sizeof
argument_list|(
name|mbuf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Notice: fill_errno is from high above: fill_fd() */
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"File descriptors missing on startup: %s; %s"
argument_list|,
operator|&
name|mbuf
index|[
literal|2
index|]
argument_list|,
name|sm_errstring
argument_list|(
name|fill_errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the ability for a normal user to send signals */
if|if
condition|(
name|RealUid
operator|!=
literal|0
operator|&&
name|RealUid
operator|!=
name|geteuid
argument_list|()
condition|)
block|{
name|uid_t
name|new_uid
init|=
name|geteuid
argument_list|()
decl_stmt|;
if|#
directive|if
name|HASSETREUID
comment|/* 		**  Since we can differentiate between uid and euid, 		**  make the uid a different user so the real user 		**  can't send signals.  However, it doesn't need to be 		**  root (euid has root). 		*/
if|if
condition|(
name|new_uid
operator|==
literal|0
condition|)
name|new_uid
operator|=
name|DefUid
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|47
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"Changing real uid to %d\n"
argument_list|,
operator|(
name|int
operator|)
name|new_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|setreuid
argument_list|(
name|new_uid
argument_list|,
name|geteuid
argument_list|()
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"main: setreuid(%d, %d) failed"
argument_list|,
operator|(
name|int
operator|)
name|new_uid
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|false
argument_list|,
name|true
argument_list|,
name|EX_OSERR
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|47
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"Now running as e/ruid %d:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* HASSETREUID */
comment|/* 		**  Have to change both effective and real so need to 		**  change them both to effective to keep privs. 		*/
if|if
condition|(
name|tTd
argument_list|(
literal|47
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"Changing uid to %d\n"
argument_list|,
operator|(
name|int
operator|)
name|new_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|setuid
argument_list|(
name|new_uid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"main: setuid(%d) failed"
argument_list|,
operator|(
name|int
operator|)
name|new_uid
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|false
argument_list|,
name|true
argument_list|,
name|EX_OSERR
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|47
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"Now running as e/ruid %d:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HASSETREUID */
block|}
if|#
directive|if
name|NAMED_BIND
if|if
condition|(
name|FallbackMX
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|getfallbackmxrr
argument_list|(
name|FallbackMX
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NAMED_BIND */
if|if
condition|(
name|SuperSafe
operator|==
name|SAFE_INTERACTIVE
operator|&&
name|CurEnv
operator|->
name|e_sendmode
operator|!=
name|SM_DELIVER
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"WARNING: SuperSafe=interactive should only be used with\n         DeliveryMode=interactive\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|UseMSP
operator|&&
operator|(
name|OpMode
operator|==
name|MD_DAEMON
operator|||
name|OpMode
operator|==
name|MD_FGDAEMON
operator|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"Mail submission program cannot be used as daemon"
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|false
argument_list|,
name|true
argument_list|,
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|OpMode
operator|==
name|MD_DELIVER
operator|||
name|OpMode
operator|==
name|MD_SMTP
operator|||
name|OpMode
operator|==
name|MD_QUEUERUN
operator|||
name|OpMode
operator|==
name|MD_ARPAFTP
operator|||
name|OpMode
operator|==
name|MD_DAEMON
operator|||
name|OpMode
operator|==
name|MD_FGDAEMON
condition|)
name|makeworkgroups
argument_list|()
expr_stmt|;
comment|/* set up the basic signal handlers */
if|if
condition|(
name|sm_signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGINT
argument_list|,
name|intsig
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGTERM
argument_list|,
name|intsig
argument_list|)
expr_stmt|;
comment|/* Enforce use of local time (null string overrides this) */
if|if
condition|(
name|TimeZoneSpec
operator|==
name|NULL
condition|)
name|unsetenv
argument_list|(
literal|"TZ"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TimeZoneSpec
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|sm_setuserenv
argument_list|(
literal|"TZ"
argument_list|,
name|TimeZoneSpec
argument_list|)
expr_stmt|;
else|else
name|sm_setuserenv
argument_list|(
literal|"TZ"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tzset
argument_list|()
expr_stmt|;
comment|/* initialize mailbox database */
name|i
operator|=
name|sm_mbdb_initialize
argument_list|(
name|Mbdb
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|EX_OK
condition|)
block|{
name|usrerr
argument_list|(
literal|"Can't initialize mailbox database \"%s\": %s"
argument_list|,
name|Mbdb
argument_list|,
name|sm_strexit
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|i
expr_stmt|;
block|}
comment|/* avoid denial-of-service attacks */
name|resetlimits
argument_list|()
expr_stmt|;
if|if
condition|(
name|OpMode
operator|==
name|MD_TEST
condition|)
block|{
comment|/* can't be done after readcf if RunAs* is used */
name|dp
operator|=
name|drop_privileges
argument_list|(
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|EX_OK
condition|)
block|{
name|finis
argument_list|(
name|false
argument_list|,
name|true
argument_list|,
name|dp
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
elseif|else
if|if
condition|(
name|OpMode
operator|!=
name|MD_DAEMON
operator|&&
name|OpMode
operator|!=
name|MD_FGDAEMON
condition|)
block|{
comment|/* drop privileges -- daemon mode done after socket/bind */
name|dp
operator|=
name|drop_privileges
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|setstat
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|EX_OK
operator|&&
name|UseMSP
operator|&&
operator|(
name|geteuid
argument_list|()
operator|==
literal|0
operator|||
name|getuid
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"Mail submission program must have RunAsUser set to non root user"
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|false
argument_list|,
name|true
argument_list|,
name|EX_CONFIG
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
if|#
directive|if
name|NAMED_BIND
name|_res
operator|.
name|retry
operator|=
name|TimeOuts
operator|.
name|res_retry
index|[
name|RES_TO_DEFAULT
index|]
expr_stmt|;
name|_res
operator|.
name|retrans
operator|=
name|TimeOuts
operator|.
name|res_retrans
index|[
name|RES_TO_DEFAULT
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* NAMED_BIND */
comment|/* 	**  Find our real host name for future logging. 	*/
name|authinfo
operator|=
name|getauthinfo
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|forged
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
literal|'_'
argument_list|,
name|authinfo
argument_list|)
expr_stmt|;
comment|/* suppress error printing if errors mailed back or whatever */
if|if
condition|(
name|BlankEnvelope
operator|.
name|e_errormode
operator|!=
name|EM_PRINT
condition|)
name|HoldErrs
operator|=
name|true
expr_stmt|;
comment|/* set up the $=m class now, after .cf has a chance to redefine $m */
name|expand
argument_list|(
literal|"\201m"
argument_list|,
name|jbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|jbuf
argument_list|)
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
if|if
condition|(
name|jbuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|setclass
argument_list|(
literal|'m'
argument_list|,
name|jbuf
argument_list|)
expr_stmt|;
comment|/* probe interfaces and locate any additional names */
if|if
condition|(
name|DontProbeInterfaces
operator|!=
name|DPI_PROBENONE
condition|)
name|load_if_names
argument_list|()
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|char
name|pidpath
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
comment|/* Now we know which .cf file we use */
name|sm_dprintf
argument_list|(
literal|"     Conf file:\t%s (selected)\n"
argument_list|,
name|getcfname
argument_list|(
name|OpMode
argument_list|,
name|SubmitMode
argument_list|,
name|cftype
argument_list|,
name|conffile
argument_list|)
argument_list|)
expr_stmt|;
name|expand
argument_list|(
name|PidFile
argument_list|,
name|pidpath
argument_list|,
sizeof|sizeof
argument_list|(
name|pidpath
argument_list|)
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"      Pid file:\t%s (selected)\n"
argument_list|,
name|pidpath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"\n============ SYSTEM IDENTITY (after readcf) ============"
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"\n      (short domain name) $w = "
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|macvalue
argument_list|(
literal|'w'
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"\n  (canonical domain name) $j = "
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|macvalue
argument_list|(
literal|'j'
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"\n         (subdomain name) $m = "
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|macvalue
argument_list|(
literal|'m'
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"\n              (node name) $k = "
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|macvalue
argument_list|(
literal|'k'
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"\n========================================================\n\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Do more command line checking -- these are things that 	**  have to modify the results of reading the config file. 	*/
comment|/* process authorization warnings from command line */
if|if
condition|(
name|warn_C_flag
condition|)
name|auth_warning
argument_list|(
operator|&
name|BlankEnvelope
argument_list|,
literal|"Processed by %s with -C %s"
argument_list|,
name|RealUserName
argument_list|,
name|conffile
argument_list|)
expr_stmt|;
if|if
condition|(
name|Warn_Q_option
operator|&&
operator|!
name|wordinclass
argument_list|(
name|RealUserName
argument_list|,
literal|'t'
argument_list|)
condition|)
name|auth_warning
argument_list|(
operator|&
name|BlankEnvelope
argument_list|,
literal|"Processed from queue %s"
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysloglabel
operator|!=
name|NULL
operator|&&
operator|!
name|wordinclass
argument_list|(
name|RealUserName
argument_list|,
literal|'t'
argument_list|)
operator|&&
name|RealUid
operator|!=
literal|0
operator|&&
name|RealUid
operator|!=
name|TrustedUid
operator|&&
name|LogLevel
operator|>
literal|1
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"user %d changed syslog label"
argument_list|,
operator|(
name|int
operator|)
name|RealUid
argument_list|)
expr_stmt|;
comment|/* check body type for legality */
name|i
operator|=
name|check_bodytype
argument_list|(
name|BlankEnvelope
operator|.
name|e_bodytype
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|BODYTYPE_ILLEGAL
condition|)
block|{
name|usrerr
argument_list|(
literal|"Illegal body type %s"
argument_list|,
name|BlankEnvelope
operator|.
name|e_bodytype
argument_list|)
expr_stmt|;
name|BlankEnvelope
operator|.
name|e_bodytype
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|!=
name|BODYTYPE_NONE
condition|)
name|SevenBitInput
operator|=
operator|(
name|i
operator|==
name|BODYTYPE_7BIT
operator|)
expr_stmt|;
comment|/* tweak default DSN notifications */
if|if
condition|(
name|DefaultNotify
operator|==
literal|0
condition|)
name|DefaultNotify
operator|=
name|QPINGONFAILURE
operator||
name|QPINGONDELAY
expr_stmt|;
comment|/* check for sane configuration level */
if|if
condition|(
name|ConfigLevel
operator|>
name|MAXCONFIGLEVEL
condition|)
block|{
name|syserr
argument_list|(
literal|"Warning: .cf version level (%d) exceeds sendmail version %s functionality (%d)"
argument_list|,
name|ConfigLevel
argument_list|,
name|Version
argument_list|,
name|MAXCONFIGLEVEL
argument_list|)
expr_stmt|;
block|}
comment|/* need MCI cache to have persistence */
if|if
condition|(
name|HostStatDir
operator|!=
name|NULL
operator|&&
name|MaxMciCache
operator|==
literal|0
condition|)
block|{
name|HostStatDir
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Warning: HostStatusDirectory disabled with ConnectionCacheSize = 0\n"
argument_list|)
expr_stmt|;
block|}
comment|/* need HostStatusDir in order to have SingleThreadDelivery */
if|if
condition|(
name|SingleThreadDelivery
operator|&&
name|HostStatDir
operator|==
name|NULL
condition|)
block|{
name|SingleThreadDelivery
operator|=
name|false
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Warning: HostStatusDirectory required for SingleThreadDelivery\n"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|_FFR_MEMSTAT
name|j
operator|=
name|sm_memstat_open
argument_list|()
expr_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
operator|&&
operator|(
name|RefuseLowMem
operator|>
literal|0
operator|||
name|QueueLowMem
operator|>
literal|0
operator|)
operator|&&
name|LogLevel
operator|>
literal|4
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"cannot get memory statistics, settings ignored, error=%d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _FFR_MEMSTAT */
comment|/* check for permissions */
if|if
condition|(
name|RealUid
operator|!=
literal|0
operator|&&
name|RealUid
operator|!=
name|TrustedUid
condition|)
block|{
name|char
modifier|*
name|action
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|OpMode
condition|)
block|{
case|case
name|MD_QUEUERUN
case|:
if|if
condition|(
name|quarantining
operator|!=
name|NULL
condition|)
name|action
operator|=
literal|"quarantine jobs"
expr_stmt|;
else|else
block|{
comment|/* Normal users can do a single queue run */
if|if
condition|(
name|QueueIntvl
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* but not persistent queue runners */
if|if
condition|(
name|action
operator|==
name|NULL
condition|)
name|action
operator|=
literal|"start a queue runner daemon"
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MD_PURGESTAT
case|:
if|if
condition|(
name|action
operator|==
name|NULL
condition|)
name|action
operator|=
literal|"purge host status"
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MD_DAEMON
case|:
case|case
name|MD_FGDAEMON
case|:
if|if
condition|(
name|action
operator|==
name|NULL
condition|)
name|action
operator|=
literal|"run daemon"
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|65
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"Deny user %d attempt to %s\n"
argument_list|,
operator|(
name|int
operator|)
name|RealUid
argument_list|,
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|1
condition|)
name|sm_syslog
argument_list|(
name|LOG_ALERT
argument_list|,
name|NOQID
argument_list|,
literal|"user %d attempted to %s"
argument_list|,
operator|(
name|int
operator|)
name|RealUid
argument_list|,
name|action
argument_list|)
expr_stmt|;
name|HoldErrs
operator|=
name|false
expr_stmt|;
name|usrerr
argument_list|(
literal|"Permission denied (real uid not trusted)"
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|false
argument_list|,
name|true
argument_list|,
name|EX_USAGE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
break|break;
case|case
name|MD_VERIFY
case|:
if|if
condition|(
name|bitset
argument_list|(
name|PRIV_RESTRICTEXPAND
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
block|{
comment|/* 				**  If -bv and RestrictExpand, 				**  drop privs to prevent normal 				**  users from reading private 				**  aliases/forwards/:include:s 				*/
if|if
condition|(
name|tTd
argument_list|(
literal|65
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"Drop privs for user %d attempt to expand (RestrictExpand)\n"
argument_list|,
operator|(
name|int
operator|)
name|RealUid
argument_list|)
expr_stmt|;
name|dp
operator|=
name|drop_privileges
argument_list|(
name|true
argument_list|)
expr_stmt|;
comment|/* Fake address safety */
if|if
condition|(
name|tTd
argument_list|(
literal|65
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"Faking DontBlameSendmail=NonRootSafeAddr\n"
argument_list|)
expr_stmt|;
name|setbitn
argument_list|(
name|DBS_NONROOTSAFEADDR
argument_list|,
name|DontBlameSendmail
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|EX_OK
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|65
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"Failed to drop privs for user %d attempt to expand, exiting\n"
argument_list|,
operator|(
name|int
operator|)
name|RealUid
argument_list|)
expr_stmt|;
name|CurEnv
operator|->
name|e_id
operator|=
name|NULL
expr_stmt|;
name|finis
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|dp
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
break|break;
case|case
name|MD_TEST
case|:
case|case
name|MD_PRINT
case|:
case|case
name|MD_PRINTNQE
case|:
case|case
name|MD_FREEZE
case|:
case|case
name|MD_HOSTSTAT
case|:
comment|/* Nothing special to check */
break|break;
case|case
name|MD_INITALIAS
case|:
if|if
condition|(
operator|!
name|wordinclass
argument_list|(
name|RealUserName
argument_list|,
literal|'t'
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|65
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"Deny user %d attempt to rebuild the alias map\n"
argument_list|,
operator|(
name|int
operator|)
name|RealUid
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|1
condition|)
name|sm_syslog
argument_list|(
name|LOG_ALERT
argument_list|,
name|NOQID
argument_list|,
literal|"user %d attempted to rebuild the alias map"
argument_list|,
operator|(
name|int
operator|)
name|RealUid
argument_list|)
expr_stmt|;
name|HoldErrs
operator|=
name|false
expr_stmt|;
name|usrerr
argument_list|(
literal|"Permission denied (real uid not trusted)"
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|false
argument_list|,
name|true
argument_list|,
name|EX_USAGE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|UseMSP
condition|)
block|{
name|HoldErrs
operator|=
name|false
expr_stmt|;
name|usrerr
argument_list|(
literal|"User %d cannot rebuild aliases in mail submission program"
argument_list|,
operator|(
name|int
operator|)
name|RealUid
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|false
argument_list|,
name|true
argument_list|,
name|EX_USAGE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* FALLTHROUGH */
default|default:
if|if
condition|(
name|bitset
argument_list|(
name|PRIV_RESTRICTEXPAND
argument_list|,
name|PrivacyFlags
argument_list|)
operator|&&
name|Verbose
operator|!=
literal|0
condition|)
block|{
comment|/* 				**  If -v and RestrictExpand, reset 				**  Verbose to prevent normal users 				**  from seeing the expansion of 				**  aliases/forwards/:include:s 				*/
if|if
condition|(
name|tTd
argument_list|(
literal|65
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"Dropping verbosity for user %d (RestrictExpand)\n"
argument_list|,
operator|(
name|int
operator|)
name|RealUid
argument_list|)
expr_stmt|;
name|Verbose
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|MeToo
condition|)
name|BlankEnvelope
operator|.
name|e_flags
operator||=
name|EF_METOO
expr_stmt|;
switch|switch
condition|(
name|OpMode
condition|)
block|{
case|case
name|MD_TEST
case|:
comment|/* don't have persistent host status in test mode */
name|HostStatDir
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|Verbose
operator|==
literal|0
condition|)
name|Verbose
operator|=
literal|2
expr_stmt|;
name|BlankEnvelope
operator|.
name|e_errormode
operator|=
name|EM_PRINT
expr_stmt|;
name|HoldErrs
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|MD_VERIFY
case|:
name|BlankEnvelope
operator|.
name|e_errormode
operator|=
name|EM_PRINT
expr_stmt|;
name|HoldErrs
operator|=
name|false
expr_stmt|;
comment|/* arrange to exit cleanly on hangup signal */
if|if
condition|(
name|sm_signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|==
operator|(
name|sigfunc_t
operator|)
name|SIG_DFL
condition|)
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGHUP
argument_list|,
name|intsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|geteuid
argument_list|()
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Notice: -bv may give misleading output for non-privileged user\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MD_FGDAEMON
case|:
name|run_in_foreground
operator|=
name|true
expr_stmt|;
name|set_op_mode
argument_list|(
name|MD_DAEMON
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MD_DAEMON
case|:
name|vendor_daemon_setup
argument_list|(
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
comment|/* remove things that don't make sense in daemon mode */
name|FullName
operator|=
name|NULL
expr_stmt|;
name|GrabTo
operator|=
name|false
expr_stmt|;
comment|/* arrange to restart on hangup signal */
if|if
condition|(
name|SaveArgv
index|[
literal|0
index|]
operator|==
name|NULL
operator|||
name|SaveArgv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"daemon invoked without full pathname; kill -1 won't work"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MD_INITALIAS
case|:
name|Verbose
operator|=
literal|2
expr_stmt|;
name|BlankEnvelope
operator|.
name|e_errormode
operator|=
name|EM_PRINT
expr_stmt|;
name|HoldErrs
operator|=
name|false
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
comment|/* arrange to exit cleanly on hangup signal */
if|if
condition|(
name|sm_signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|==
operator|(
name|sigfunc_t
operator|)
name|SIG_DFL
condition|)
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGHUP
argument_list|,
name|intsig
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* special considerations for FullName */
if|if
condition|(
name|FullName
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|full
init|=
name|NULL
decl_stmt|;
comment|/* full names can't have newlines */
if|if
condition|(
name|strchr
argument_list|(
name|FullName
argument_list|,
literal|'\n'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|full
operator|=
name|newstr
argument_list|(
name|denlstring
argument_list|(
name|FullName
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
name|FullName
operator|=
name|full
expr_stmt|;
block|}
comment|/* check for characters that may have to be quoted */
if|if
condition|(
operator|!
name|rfc822_string
argument_list|(
name|FullName
argument_list|)
condition|)
block|{
comment|/* 			**  Quote a full name with special characters 			**  as a comment so crackaddr() doesn't destroy 			**  the name portion of the address. 			*/
name|FullName
operator|=
name|addquotes
argument_list|(
name|FullName
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|full
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|full
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
block|}
comment|/* do heuristic mode adjustment */
if|if
condition|(
name|Verbose
condition|)
block|{
comment|/* turn off noconnect option */
name|setoption
argument_list|(
literal|'c'
argument_list|,
literal|"F"
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
comment|/* turn on interactive delivery */
name|setoption
argument_list|(
literal|'d'
argument_list|,
literal|""
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VENDOR_CODE
comment|/* check for vendor mismatch */
if|if
condition|(
name|VendorCode
operator|!=
name|VENDOR_CODE
condition|)
block|{
name|message
argument_list|(
literal|"Warning: .cf file vendor code mismatch: sendmail expects vendor %s, .cf file vendor is %s"
argument_list|,
name|getvendor
argument_list|(
name|VENDOR_CODE
argument_list|)
argument_list|,
name|getvendor
argument_list|(
name|VendorCode
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* VENDOR_CODE */
comment|/* check for out of date configuration level */
if|if
condition|(
name|ConfigLevel
operator|<
name|MAXCONFIGLEVEL
condition|)
block|{
name|message
argument_list|(
literal|"Warning: .cf file is out of date: sendmail %s supports version %d, .cf file is version %d"
argument_list|,
name|Version
argument_list|,
name|MAXCONFIGLEVEL
argument_list|,
name|ConfigLevel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ConfigLevel
operator|<
literal|3
condition|)
name|UseErrorsTo
operator|=
name|true
expr_stmt|;
comment|/* set options that were previous macros */
if|if
condition|(
name|SmtpGreeting
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ConfigLevel
operator|<
literal|7
operator|&&
operator|(
name|p
operator|=
name|macvalue
argument_list|(
literal|'e'
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|SmtpGreeting
operator|=
name|newstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|SmtpGreeting
operator|=
literal|"\201j Sendmail \201v ready at \201b"
expr_stmt|;
block|}
if|if
condition|(
name|UnixFromLine
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ConfigLevel
operator|<
literal|7
operator|&&
operator|(
name|p
operator|=
name|macvalue
argument_list|(
literal|'l'
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|UnixFromLine
operator|=
name|newstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|UnixFromLine
operator|=
literal|"From \201g  \201d"
expr_stmt|;
block|}
name|SmtpError
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* our name for SMTP codes */
name|expand
argument_list|(
literal|"\201j"
argument_list|,
name|jbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|jbuf
argument_list|)
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
if|if
condition|(
name|jbuf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|PSTRSET
argument_list|(
name|MyHostName
argument_list|,
literal|"localhost"
argument_list|)
expr_stmt|;
else|else
name|PSTRSET
argument_list|(
name|MyHostName
argument_list|,
name|jbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|MyHostName
argument_list|,
literal|'.'
argument_list|)
operator|==
name|NULL
condition|)
name|message
argument_list|(
literal|"WARNING: local host name (%s) is not qualified; see cf/README: WHO AM I?"
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
comment|/* make certain that this name is part of the $=w class */
name|setclass
argument_list|(
literal|'w'
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
comment|/* fill in the structure of the *default* queue */
name|st
operator|=
name|stab
argument_list|(
literal|"mqueue"
argument_list|,
name|ST_QUEUE
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"No default queue (mqueue) defined"
argument_list|)
expr_stmt|;
else|else
name|set_def_queueval
argument_list|(
name|st
operator|->
name|s_quegrp
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* the indices of built-in mailers */
name|st
operator|=
name|stab
argument_list|(
literal|"local"
argument_list|,
name|ST_MAILER
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|!=
name|NULL
condition|)
name|LocalMailer
operator|=
name|st
operator|->
name|s_mailer
expr_stmt|;
elseif|else
if|if
condition|(
name|OpMode
operator|!=
name|MD_TEST
operator|||
operator|!
name|warn_C_flag
condition|)
name|syserr
argument_list|(
literal|"No local mailer defined"
argument_list|)
expr_stmt|;
name|st
operator|=
name|stab
argument_list|(
literal|"prog"
argument_list|,
name|ST_MAILER
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"No prog mailer defined"
argument_list|)
expr_stmt|;
else|else
block|{
name|ProgMailer
operator|=
name|st
operator|->
name|s_mailer
expr_stmt|;
name|clrbitn
argument_list|(
name|M_MUSER
argument_list|,
name|ProgMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
block|}
name|st
operator|=
name|stab
argument_list|(
literal|"*file*"
argument_list|,
name|ST_MAILER
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"No *file* mailer defined"
argument_list|)
expr_stmt|;
else|else
block|{
name|FileMailer
operator|=
name|st
operator|->
name|s_mailer
expr_stmt|;
name|clrbitn
argument_list|(
name|M_MUSER
argument_list|,
name|FileMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
block|}
name|st
operator|=
name|stab
argument_list|(
literal|"*include*"
argument_list|,
name|ST_MAILER
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"No *include* mailer defined"
argument_list|)
expr_stmt|;
else|else
name|InclMailer
operator|=
name|st
operator|->
name|s_mailer
expr_stmt|;
if|if
condition|(
name|ConfigLevel
operator|<
literal|6
condition|)
block|{
comment|/* heuristic tweaking of local mailer for back compat */
if|if
condition|(
name|LocalMailer
operator|!=
name|NULL
condition|)
block|{
name|setbitn
argument_list|(
name|M_ALIASABLE
argument_list|,
name|LocalMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
name|setbitn
argument_list|(
name|M_HASPWENT
argument_list|,
name|LocalMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
name|setbitn
argument_list|(
name|M_TRYRULESET5
argument_list|,
name|LocalMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
name|setbitn
argument_list|(
name|M_CHECKINCLUDE
argument_list|,
name|LocalMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
name|setbitn
argument_list|(
name|M_CHECKPROG
argument_list|,
name|LocalMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
name|setbitn
argument_list|(
name|M_CHECKFILE
argument_list|,
name|LocalMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
name|setbitn
argument_list|(
name|M_CHECKUDB
argument_list|,
name|LocalMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ProgMailer
operator|!=
name|NULL
condition|)
name|setbitn
argument_list|(
name|M_RUNASRCPT
argument_list|,
name|ProgMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|FileMailer
operator|!=
name|NULL
condition|)
name|setbitn
argument_list|(
name|M_RUNASRCPT
argument_list|,
name|FileMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ConfigLevel
operator|<
literal|7
condition|)
block|{
if|if
condition|(
name|LocalMailer
operator|!=
name|NULL
condition|)
name|setbitn
argument_list|(
name|M_VRFY250
argument_list|,
name|LocalMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ProgMailer
operator|!=
name|NULL
condition|)
name|setbitn
argument_list|(
name|M_VRFY250
argument_list|,
name|ProgMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|FileMailer
operator|!=
name|NULL
condition|)
name|setbitn
argument_list|(
name|M_VRFY250
argument_list|,
name|FileMailer
operator|->
name|m_flags
argument_list|)
expr_stmt|;
block|}
comment|/* MIME Content-Types that cannot be transfer encoded */
name|setclass
argument_list|(
literal|'n'
argument_list|,
literal|"multipart/signed"
argument_list|)
expr_stmt|;
comment|/* MIME message/xxx subtypes that can be treated as messages */
name|setclass
argument_list|(
literal|'s'
argument_list|,
literal|"rfc822"
argument_list|)
expr_stmt|;
comment|/* MIME Content-Transfer-Encodings that can be encoded */
name|setclass
argument_list|(
literal|'e'
argument_list|,
literal|"7bit"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'e'
argument_list|,
literal|"8bit"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'e'
argument_list|,
literal|"binary"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_B_CLASS
comment|/* MIME Content-Types that should be treated as binary */
name|setclass
argument_list|(
literal|'b'
argument_list|,
literal|"image"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'b'
argument_list|,
literal|"audio"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'b'
argument_list|,
literal|"video"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'b'
argument_list|,
literal|"application/octet-stream"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_B_CLASS */
comment|/* MIME headers which have fields to check for overflow */
name|setclass
argument_list|(
name|macid
argument_list|(
literal|"{checkMIMEFieldHeaders}"
argument_list|)
argument_list|,
literal|"content-disposition"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
name|macid
argument_list|(
literal|"{checkMIMEFieldHeaders}"
argument_list|)
argument_list|,
literal|"content-type"
argument_list|)
expr_stmt|;
comment|/* MIME headers to check for length overflow */
name|setclass
argument_list|(
name|macid
argument_list|(
literal|"{checkMIMETextHeaders}"
argument_list|)
argument_list|,
literal|"content-description"
argument_list|)
expr_stmt|;
comment|/* MIME headers to check for overflow and rebalance */
name|setclass
argument_list|(
name|macid
argument_list|(
literal|"{checkMIMEHeaders}"
argument_list|)
argument_list|,
literal|"content-disposition"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
name|macid
argument_list|(
literal|"{checkMIMEHeaders}"
argument_list|)
argument_list|,
literal|"content-id"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
name|macid
argument_list|(
literal|"{checkMIMEHeaders}"
argument_list|)
argument_list|,
literal|"content-transfer-encoding"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
name|macid
argument_list|(
literal|"{checkMIMEHeaders}"
argument_list|)
argument_list|,
literal|"content-type"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
name|macid
argument_list|(
literal|"{checkMIMEHeaders}"
argument_list|)
argument_list|,
literal|"mime-version"
argument_list|)
expr_stmt|;
comment|/* Macros to save in the queue file -- don't remove any */
name|setclass
argument_list|(
name|macid
argument_list|(
literal|"{persistentMacros}"
argument_list|)
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
name|macid
argument_list|(
literal|"{persistentMacros}"
argument_list|)
argument_list|,
literal|"s"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
name|macid
argument_list|(
literal|"{persistentMacros}"
argument_list|)
argument_list|,
literal|"_"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
name|macid
argument_list|(
literal|"{persistentMacros}"
argument_list|)
argument_list|,
literal|"{if_addr}"
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
name|macid
argument_list|(
literal|"{persistentMacros}"
argument_list|)
argument_list|,
literal|"{daemon_flags}"
argument_list|)
expr_stmt|;
comment|/* operate in queue directory */
if|if
condition|(
name|QueueDir
operator|==
name|NULL
operator|||
operator|*
name|QueueDir
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|OpMode
operator|!=
name|MD_TEST
condition|)
block|{
name|syserr
argument_list|(
literal|"QueueDirectory (Q) option must be set"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_CONFIG
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|OpMode
operator|!=
name|MD_TEST
condition|)
name|setup_queues
argument_list|(
name|OpMode
operator|==
name|MD_DAEMON
argument_list|)
expr_stmt|;
block|}
comment|/* check host status directory for validity */
if|if
condition|(
name|HostStatDir
operator|!=
name|NULL
operator|&&
operator|!
name|path_is_dir
argument_list|(
name|HostStatDir
argument_list|,
name|false
argument_list|)
condition|)
block|{
comment|/* cannot use this value */
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Warning: Cannot use HostStatusDirectory = %s: %s\n"
argument_list|,
name|HostStatDir
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|HostStatDir
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|OpMode
operator|==
name|MD_QUEUERUN
operator|&&
name|RealUid
operator|!=
literal|0
operator|&&
name|bitset
argument_list|(
name|PRIV_RESTRICTQRUN
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
comment|/* check to see if we own the queue directory */
if|if
condition|(
name|stat
argument_list|(
literal|"."
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"main: cannot stat %s"
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
if|if
condition|(
name|stbuf
operator|.
name|st_uid
operator|!=
name|RealUid
condition|)
block|{
comment|/* nope, really a botch */
name|HoldErrs
operator|=
name|false
expr_stmt|;
name|usrerr
argument_list|(
literal|"You do not have permission to process the queue"
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|false
argument_list|,
name|true
argument_list|,
name|EX_NOPERM
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
if|#
directive|if
name|MILTER
comment|/* sanity checks on milter filters */
if|if
condition|(
name|OpMode
operator|==
name|MD_DAEMON
operator|||
name|OpMode
operator|==
name|MD_SMTP
condition|)
block|{
name|milter_config
argument_list|(
name|InputFilterList
argument_list|,
name|InputFilters
argument_list|,
name|MAXFILTERS
argument_list|)
expr_stmt|;
name|setup_daemon_milters
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MILTER */
comment|/* Convert queuegroup string to qgrp number */
if|if
condition|(
name|queuegroup
operator|!=
name|NULL
condition|)
block|{
name|qgrp
operator|=
name|name2qid
argument_list|(
name|queuegroup
argument_list|)
expr_stmt|;
if|if
condition|(
name|qgrp
operator|==
name|NOQGRP
condition|)
block|{
name|HoldErrs
operator|=
name|false
expr_stmt|;
name|usrerr
argument_list|(
literal|"Queue group %s unknown"
argument_list|,
name|queuegroup
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|false
argument_list|,
name|true
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
comment|/* if we've had errors so far, exit now */
if|if
condition|(
name|ExitStat
operator|!=
name|EX_OK
operator|&&
name|OpMode
operator|!=
name|MD_TEST
condition|)
block|{
name|finis
argument_list|(
name|false
argument_list|,
name|true
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|#
directive|if
name|SASL
comment|/* sendmail specific SASL initialization */
name|sm_sasl_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* SASL */
if|#
directive|if
name|XDEBUG
name|checkfd012
argument_list|(
literal|"before main() initmaps"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XDEBUG */
comment|/* 	**  Do operation-mode-dependent initialization. 	*/
switch|switch
condition|(
name|OpMode
condition|)
block|{
case|case
name|MD_PRINT
case|:
comment|/* print the queue */
name|HoldErrs
operator|=
name|false
expr_stmt|;
name|dropenvelope
argument_list|(
operator|&
name|BlankEnvelope
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGPIPE
argument_list|,
name|sigpipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|qgrp
operator|!=
name|NOQGRP
condition|)
block|{
name|int
name|j
decl_stmt|;
comment|/* Selecting a particular queue group to run */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_numqueues
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|StopRequest
condition|)
name|stop_sendmail
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|print_single_queue
argument_list|(
name|qgrp
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
name|finis
argument_list|(
name|false
argument_list|,
name|true
argument_list|,
name|EX_OK
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|printqueue
argument_list|()
expr_stmt|;
name|finis
argument_list|(
name|false
argument_list|,
name|true
argument_list|,
name|EX_OK
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
break|break;
case|case
name|MD_PRINTNQE
case|:
comment|/* print number of entries in queue */
name|dropenvelope
argument_list|(
operator|&
name|BlankEnvelope
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGPIPE
argument_list|,
name|sigpipe
argument_list|)
expr_stmt|;
name|printnqe
argument_list|(
name|smioout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|false
argument_list|,
name|true
argument_list|,
name|EX_OK
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
break|break;
case|case
name|MD_QUEUERUN
case|:
comment|/* only handle quarantining here */
if|if
condition|(
name|quarantining
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|QueueMode
operator|!=
name|QM_QUARANTINE
operator|&&
name|QueueMode
operator|!=
name|QM_NORMAL
condition|)
block|{
name|HoldErrs
operator|=
name|false
expr_stmt|;
name|usrerr
argument_list|(
literal|"Can not use -Q with -q%c"
argument_list|,
name|QueueMode
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
name|finis
argument_list|(
name|false
argument_list|,
name|true
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|quarantine_queue
argument_list|(
name|quarantining
argument_list|,
name|qgrp
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|false
argument_list|,
name|true
argument_list|,
name|EX_OK
argument_list|)
expr_stmt|;
break|break;
case|case
name|MD_HOSTSTAT
case|:
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGPIPE
argument_list|,
name|sigpipe
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mci_traverse_persistent
argument_list|(
name|mci_print_persistent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|false
argument_list|,
name|true
argument_list|,
name|EX_OK
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
break|break;
case|case
name|MD_PURGESTAT
case|:
operator|(
name|void
operator|)
name|mci_traverse_persistent
argument_list|(
name|mci_purge_persistent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|false
argument_list|,
name|true
argument_list|,
name|EX_OK
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
break|break;
case|case
name|MD_INITALIAS
case|:
comment|/* initialize maps */
name|initmaps
argument_list|()
expr_stmt|;
name|finis
argument_list|(
name|false
argument_list|,
name|true
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
break|break;
case|case
name|MD_SMTP
case|:
case|case
name|MD_DAEMON
case|:
comment|/* reset DSN parameters */
name|DefaultNotify
operator|=
name|QPINGONFAILURE
operator||
name|QPINGONDELAY
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{dsn_notify}"
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|BlankEnvelope
operator|.
name|e_envid
operator|=
name|NULL
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{dsn_envid}"
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|BlankEnvelope
operator|.
name|e_flags
operator|&=
operator|~
operator|(
name|EF_RET_PARAM
operator||
name|EF_NO_BODY_RETN
operator|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{dsn_ret}"
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* don't open maps for daemon -- done below in child */
break|break;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|15
argument_list|)
condition|)
block|{
comment|/* print configuration table (or at least part of it) */
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|90
argument_list|)
condition|)
name|printrules
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXMAILERS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Mailer
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|printmailer
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|Mailer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	**  Switch to the main envelope. 	*/
name|CurEnv
operator|=
name|newenvelope
argument_list|(
operator|&
name|MainEnvelope
argument_list|,
operator|&
name|BlankEnvelope
argument_list|,
name|sm_rpool_new_x
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|MainEnvelope
operator|.
name|e_flags
operator|=
name|BlankEnvelope
operator|.
name|e_flags
expr_stmt|;
comment|/* 	**  If test mode, read addresses from stdin and process. 	*/
if|if
condition|(
name|OpMode
operator|==
name|MD_TEST
condition|)
block|{
if|if
condition|(
name|isatty
argument_list|(
name|sm_io_getinfo
argument_list|(
name|smioin
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|)
condition|)
name|Verbose
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Enter<ruleset><address>\n"
argument_list|)
expr_stmt|;
block|}
name|macdefine
argument_list|(
operator|&
operator|(
name|MainEnvelope
operator|.
name|e_macro
operator|)
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{addr_type}"
argument_list|)
argument_list|,
literal|"e r"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|SM_TRY
block|{
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGINT
argument_list|,
name|intindebug
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_releasesignal
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
operator|==
literal|2
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"> "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_flush
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm_io_fgets
argument_list|(
name|smioin
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
name|testmodeline
argument_list|(
literal|"/quit"
argument_list|,
operator|&
name|MainEnvelope
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|Verbose
operator|<
literal|2
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"> %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|testmodeline
argument_list|(
name|buf
argument_list|,
operator|&
name|MainEnvelope
argument_list|)
expr_stmt|;
block|}
name|SM_EXCEPT
argument_list|(
argument|exc
argument_list|,
literal|"[!F]*"
argument_list|)
block|{
comment|/* 				**  8.10 just prints \n on interrupt. 				**  I'm printing the exception here in case 				**  sendmail is extended to raise additional 				**  exceptions in this context. 				*/
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|sm_exc_print
argument_list|(
name|exc
argument_list|,
name|smioout
argument_list|)
expr_stmt|;
block|}
name|SM_END_TRY
block|}
block|}
if|#
directive|if
name|STARTTLS
name|tls_ok
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|OpMode
operator|==
name|MD_QUEUERUN
operator|||
name|OpMode
operator|==
name|MD_DELIVER
operator|||
name|OpMode
operator|==
name|MD_ARPAFTP
condition|)
block|{
comment|/* check whether STARTTLS is turned off for the client */
if|if
condition|(
name|chkclientmodifiers
argument_list|(
name|D_NOTLS
argument_list|)
condition|)
name|tls_ok
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OpMode
operator|==
name|MD_DAEMON
operator|||
name|OpMode
operator|==
name|MD_FGDAEMON
operator|||
name|OpMode
operator|==
name|MD_SMTP
condition|)
block|{
comment|/* check whether STARTTLS is turned off for the server */
if|if
condition|(
name|chkdaemonmodifiers
argument_list|(
name|D_NOTLS
argument_list|)
condition|)
name|tls_ok
operator|=
name|false
expr_stmt|;
block|}
else|else
comment|/* other modes don't need STARTTLS */
name|tls_ok
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|tls_ok
condition|)
block|{
comment|/* basic TLS initialization */
name|tls_ok
operator|=
name|init_tls_library
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tls_ok
operator|&&
operator|(
name|OpMode
operator|==
name|MD_QUEUERUN
operator|||
name|OpMode
operator|==
name|MD_DELIVER
operator|)
condition|)
block|{
comment|/* disable TLS for client */
name|setclttls
argument_list|(
name|false
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* STARTTLS */
comment|/* 	**  If collecting stuff from the queue, go start doing that. 	*/
if|if
condition|(
name|OpMode
operator|==
name|MD_QUEUERUN
operator|&&
name|QueueIntvl
operator|==
literal|0
condition|)
block|{
name|pid_t
name|pid
init|=
operator|-
literal|1
decl_stmt|;
if|#
directive|if
name|STARTTLS
comment|/* init TLS for client, ignore result for now */
operator|(
name|void
operator|)
name|initclttls
argument_list|(
name|tls_ok
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* STARTTLS */
comment|/* 		**  The parent process of the caller of runqueue() needs 		**  to stay around for a possible SIGTERM. The SIGTERM will 		**  tell this process that all of the queue runners children 		**  need to be sent SIGTERM as well. At the same time, we 		**  want to return control to the command line. So we do an 		**  extra fork(). 		*/
if|if
condition|(
name|Verbose
operator|||
name|foregroundqueue
operator|||
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|<=
literal|0
condition|)
block|{
comment|/* 			**  If the fork() failed we should still try to do 			**  the queue run. If it succeeded then the child 			**  is going to start the run and wait for all 			**  of the children to finish. 			*/
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* Reset global flags */
name|RestartRequest
operator|=
name|NULL
expr_stmt|;
name|ShutdownRequest
operator|=
name|NULL
expr_stmt|;
name|PendingSignal
operator|=
literal|0
expr_stmt|;
comment|/* disconnect from terminal */
name|disconnect
argument_list|(
literal|2
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
name|CurrentPid
operator|=
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
name|qgrp
operator|!=
name|NOQGRP
condition|)
block|{
name|int
name|rwgflags
init|=
name|RWG_NONE
decl_stmt|;
comment|/* 				**  To run a specific queue group mark it to 				**  be run, select the work group it's in and 				**  increment the work counter. 				*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NumQueue
operator|&&
name|Queue
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|Queue
index|[
name|i
index|]
operator|->
name|qg_nextrun
operator|=
operator|(
name|time_t
operator|)
operator|-
literal|1
expr_stmt|;
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_nextrun
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|rwgflags
operator||=
name|RWG_VERBOSE
expr_stmt|;
if|if
condition|(
name|queuepersistent
condition|)
name|rwgflags
operator||=
name|RWG_PERSISTENT
expr_stmt|;
name|rwgflags
operator||=
name|RWG_FORCE
expr_stmt|;
operator|(
name|void
operator|)
name|run_work_group
argument_list|(
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_wgrp
argument_list|,
name|rwgflags
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|runqueue
argument_list|(
name|false
argument_list|,
name|Verbose
argument_list|,
name|queuepersistent
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* set the title to make it easier to find */
name|sm_setproctitle
argument_list|(
name|true
argument_list|,
name|CurEnv
argument_list|,
literal|"Queue control"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
while|while
condition|(
name|CurChildren
operator|>
literal|0
condition|)
block|{
name|int
name|status
decl_stmt|;
name|pid_t
name|ret
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ret
operator|=
name|sm_wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ECHILD
condition|)
block|{
comment|/* 						**  Oops... something got messed 						**  up really bad. Waiting for 						**  non-existent children 						**  shouldn't happen. Let's get 						**  out of here. 						*/
name|CurChildren
operator|=
literal|0
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
comment|/* something is really really wrong */
if|if
condition|(
name|errno
operator|==
name|ECHILD
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"queue control process: lost all children: wait returned ECHILD"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Only drop when a child gives status */
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
condition|)
continue|continue;
name|proc_list_drop
argument_list|(
name|ret
argument_list|,
name|status
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|finis
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|#
directive|if
name|SASL
if|if
condition|(
name|OpMode
operator|==
name|MD_SMTP
operator|||
name|OpMode
operator|==
name|MD_DAEMON
condition|)
block|{
comment|/* check whether AUTH is turned off for the server */
if|if
condition|(
operator|!
name|chkdaemonmodifiers
argument_list|(
name|D_NOAUTH
argument_list|)
operator|&&
operator|(
name|i
operator|=
name|sasl_server_init
argument_list|(
name|srvcallbacks
argument_list|,
literal|"Sendmail"
argument_list|)
operator|)
operator|!=
name|SASL_OK
condition|)
name|syserr
argument_list|(
literal|"!sasl_server_init failed! [%s]"
argument_list|,
name|sasl_errstring
argument_list|(
name|i
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SASL */
if|if
condition|(
name|OpMode
operator|==
name|MD_SMTP
condition|)
block|{
name|proc_list_add
argument_list|(
name|CurrentPid
argument_list|,
literal|"Sendmail SMTP Agent"
argument_list|,
name|PROC_DAEMON
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* clean up background delivery children */
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGCHLD
argument_list|,
name|reapchild
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  If a daemon, wait for a request. 	**	getrequests will always return in a child. 	**	If we should also be processing the queue, start 	**		doing it in background. 	**	We check for any errors that might have happened 	**		during startup. 	*/
if|if
condition|(
name|OpMode
operator|==
name|MD_DAEMON
operator|||
name|QueueIntvl
operator|>
literal|0
condition|)
block|{
name|char
name|dtype
index|[
literal|200
index|]
decl_stmt|;
comment|/* avoid cleanup in finis(), DaemonPid will be set below */
name|DaemonPid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|run_in_foreground
operator|&&
operator|!
name|tTd
argument_list|(
literal|99
argument_list|,
literal|100
argument_list|)
condition|)
block|{
comment|/* put us in background */
name|i
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"daemon: cannot fork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|finis
argument_list|(
name|false
argument_list|,
name|true
argument_list|,
name|EX_OK
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* 			**  Initialize exception stack and default exception 			**  handler for child process. 			*/
comment|/* Reset global flags */
name|RestartRequest
operator|=
name|NULL
expr_stmt|;
name|RestartWorkGroup
operator|=
name|false
expr_stmt|;
name|ShutdownRequest
operator|=
name|NULL
expr_stmt|;
name|PendingSignal
operator|=
literal|0
expr_stmt|;
name|CurrentPid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|sm_exc_newthread
argument_list|(
name|fatal_error
argument_list|)
expr_stmt|;
comment|/* disconnect from our controlling tty */
name|disconnect
argument_list|(
literal|2
argument_list|,
operator|&
name|MainEnvelope
argument_list|)
expr_stmt|;
block|}
name|dtype
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|OpMode
operator|==
name|MD_DAEMON
condition|)
block|{
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|dtype
argument_list|,
literal|"+SMTP"
argument_list|,
sizeof|sizeof
argument_list|(
name|dtype
argument_list|)
argument_list|)
expr_stmt|;
name|DaemonPid
operator|=
name|CurrentPid
expr_stmt|;
block|}
if|if
condition|(
name|QueueIntvl
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sm_strlcat2
argument_list|(
name|dtype
argument_list|,
name|queuepersistent
condition|?
literal|"+persistent-queueing@"
else|:
literal|"+queueing@"
argument_list|,
name|pintvl
argument_list|(
name|QueueIntvl
argument_list|,
name|true
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|dtype
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|dtype
argument_list|,
literal|"+debugging"
argument_list|,
sizeof|sizeof
argument_list|(
name|dtype
argument_list|)
argument_list|)
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"starting daemon (%s): %s"
argument_list|,
name|Version
argument_list|,
name|dtype
operator|+
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|XLA
name|xla_create_file
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* XLA */
comment|/* save daemon type in a macro for possible PidFile use */
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{daemon_info}"
argument_list|)
argument_list|,
name|dtype
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* save queue interval in a macro for possible PidFile use */
name|macdefine
argument_list|(
operator|&
name|MainEnvelope
operator|.
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{queue_interval}"
argument_list|)
argument_list|,
name|pintvl
argument_list|(
name|QueueIntvl
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
comment|/* workaround: can't seem to release the signal in the parent */
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGHUP
argument_list|,
name|sighup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_releasesignal
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGTERM
argument_list|,
name|sigterm
argument_list|)
expr_stmt|;
if|if
condition|(
name|QueueIntvl
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|runqueue
argument_list|(
name|true
argument_list|,
name|false
argument_list|,
name|queuepersistent
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* 			**  If queuepersistent but not in daemon mode then 			**  we're going to do the queue runner monitoring here. 			**  If in daemon mode then the monitoring will happen 			**  elsewhere. 			*/
if|if
condition|(
name|OpMode
operator|!=
name|MD_DAEMON
operator|&&
name|queuepersistent
condition|)
block|{
comment|/* 				**  Write the pid to file 				**  XXX Overwrites sendmail.pid 				*/
name|log_sendmail_pid
argument_list|(
operator|&
name|MainEnvelope
argument_list|)
expr_stmt|;
comment|/* set the title to make it easier to find */
name|sm_setproctitle
argument_list|(
name|true
argument_list|,
name|CurEnv
argument_list|,
literal|"Queue control"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
while|while
condition|(
name|CurChildren
operator|>
literal|0
condition|)
block|{
name|int
name|status
decl_stmt|;
name|pid_t
name|ret
decl_stmt|;
name|int
name|group
decl_stmt|;
name|CHECK_RESTART
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ret
operator|=
name|sm_wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
comment|/* 						**  Waiting for non-existent 						**  children shouldn't happen. 						**  Let's get out of here if 						**  it occurs. 						*/
if|if
condition|(
name|errno
operator|==
name|ECHILD
condition|)
block|{
name|CurChildren
operator|=
literal|0
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
comment|/* something is really really wrong */
if|if
condition|(
name|errno
operator|==
name|ECHILD
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"persistent queue runner control process: lost all children: wait returned ECHILD"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
condition|)
continue|continue;
comment|/* Probe only on a child status */
name|proc_list_drop
argument_list|(
name|ret
argument_list|,
name|status
argument_list|,
operator|&
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|WCOREDUMP
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"persistent queue runner=%d core dumped, signal=%d"
argument_list|,
name|group
argument_list|,
name|WTERMSIG
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
comment|/* don't restart this */
name|mark_work_group_restart
argument_list|(
name|group
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"persistent queue runner=%d died, pid=%ld, signal=%d"
argument_list|,
name|group
argument_list|,
operator|(
name|long
operator|)
name|ret
argument_list|,
name|WTERMSIG
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 					**  When debugging active, don't 					**  restart the persistent queues. 					**  But do log this as info. 					*/
if|if
condition|(
name|sm_debug_active
argument_list|(
operator|&
name|DebugNoPRestart
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|NOQID
argument_list|,
literal|"persistent queue runner=%d, exited"
argument_list|,
name|group
argument_list|)
expr_stmt|;
name|mark_work_group_restart
argument_list|(
name|group
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|CHECK_RESTART
expr_stmt|;
block|}
name|finis
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|OpMode
operator|!=
name|MD_DAEMON
condition|)
block|{
name|char
name|qtype
index|[
literal|200
index|]
decl_stmt|;
comment|/* 				**  Write the pid to file 				**  XXX Overwrites sendmail.pid 				*/
name|log_sendmail_pid
argument_list|(
operator|&
name|MainEnvelope
argument_list|)
expr_stmt|;
comment|/* set the title to make it easier to find */
name|qtype
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|qtype
argument_list|,
sizeof|sizeof
argument_list|(
name|qtype
argument_list|)
argument_list|,
literal|4
argument_list|,
literal|"Queue runner@"
argument_list|,
name|pintvl
argument_list|(
name|QueueIntvl
argument_list|,
name|true
argument_list|)
argument_list|,
literal|" for "
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
name|sm_setproctitle
argument_list|(
name|true
argument_list|,
name|CurEnv
argument_list|,
name|qtype
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|(
name|void
operator|)
name|pause
argument_list|()
expr_stmt|;
name|CHECK_RESTART
expr_stmt|;
if|if
condition|(
name|doqueuerun
argument_list|()
condition|)
operator|(
name|void
operator|)
name|runqueue
argument_list|(
name|true
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|dropenvelope
argument_list|(
operator|&
name|MainEnvelope
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|#
directive|if
name|STARTTLS
comment|/* init TLS for server, ignore result for now */
operator|(
name|void
operator|)
name|initsrvtls
argument_list|(
name|tls_ok
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* STARTTLS */
name|nextreq
label|:
name|p_flags
operator|=
name|getrequests
argument_list|(
operator|&
name|MainEnvelope
argument_list|)
expr_stmt|;
comment|/* drop privileges */
operator|(
name|void
operator|)
name|drop_privileges
argument_list|(
name|false
argument_list|)
expr_stmt|;
comment|/* 		**  Get authentication data 		**  Set _ macro in BlankEnvelope before calling newenvelope(). 		*/
name|authinfo
operator|=
name|getauthinfo
argument_list|(
name|sm_io_getinfo
argument_list|(
name|InChannel
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|&
name|forged
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
literal|'_'
argument_list|,
name|authinfo
argument_list|)
expr_stmt|;
comment|/* at this point we are in a child: reset state */
name|sm_rpool_free
argument_list|(
name|MainEnvelope
operator|.
name|e_rpool
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|newenvelope
argument_list|(
operator|&
name|MainEnvelope
argument_list|,
operator|&
name|MainEnvelope
argument_list|,
name|sm_rpool_new_x
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
block|{
comment|/* log connection information */
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NULL
argument_list|,
literal|"connect from %s"
argument_list|,
name|authinfo
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  If running SMTP protocol, start collecting and executing 	**  commands.  This will never return. 	*/
if|if
condition|(
name|OpMode
operator|==
name|MD_SMTP
operator|||
name|OpMode
operator|==
name|MD_DAEMON
condition|)
block|{
name|char
name|pbuf
index|[
literal|20
index|]
decl_stmt|;
comment|/* 		**  Save some macros for check_* rulesets. 		*/
if|if
condition|(
name|forged
condition|)
block|{
name|char
name|ipbuf
index|[
literal|103
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|ipbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|ipbuf
argument_list|)
argument_list|,
literal|"[%.100s]"
argument_list|,
name|anynet_ntoa
argument_list|(
operator|&
name|RealHostAddr
argument_list|)
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{client_name}"
argument_list|)
argument_list|,
name|ipbuf
argument_list|)
expr_stmt|;
block|}
else|else
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{client_name}"
argument_list|)
argument_list|,
name|RealHostName
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{client_ptr}"
argument_list|)
argument_list|,
name|RealHostName
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{client_addr}"
argument_list|)
argument_list|,
name|anynet_ntoa
argument_list|(
operator|&
name|RealHostAddr
argument_list|)
argument_list|)
expr_stmt|;
name|sm_getla
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|RealHostAddr
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
if|#
directive|if
name|NETINET
case|case
name|AF_INET
case|:
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|pbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pbuf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|RealHostAddr
operator|.
name|sin
operator|.
name|sin_port
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET6
case|case
name|AF_INET6
case|:
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|pbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pbuf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|RealHostAddr
operator|.
name|sin6
operator|.
name|sin6_port
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET6 */
default|default:
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|pbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pbuf
argument_list|)
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
break|break;
block|}
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{client_port}"
argument_list|)
argument_list|,
name|pbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|OpMode
operator|==
name|MD_DAEMON
condition|)
block|{
name|ENVELOPE
modifier|*
name|saved_env
decl_stmt|;
comment|/* validate the connection */
name|HoldErrs
operator|=
name|true
expr_stmt|;
name|saved_env
operator|=
name|CurEnv
expr_stmt|;
name|CurEnv
operator|=
operator|&
name|BlankEnvelope
expr_stmt|;
name|nullserver
operator|=
name|validate_connection
argument_list|(
operator|&
name|RealHostAddr
argument_list|,
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{client_name}"
argument_list|)
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|EF_DISCARD
argument_list|,
name|BlankEnvelope
operator|.
name|e_flags
argument_list|)
condition|)
name|MainEnvelope
operator|.
name|e_flags
operator||=
name|EF_DISCARD
expr_stmt|;
name|CurEnv
operator|=
name|saved_env
expr_stmt|;
name|HoldErrs
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_flags
operator|==
name|NULL
condition|)
block|{
name|p_flags
operator|=
operator|(
name|BITMAP256
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p_flags
argument_list|)
argument_list|)
expr_stmt|;
name|clrbitmap
argument_list|(
name|p_flags
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|STARTTLS
if|if
condition|(
name|OpMode
operator|==
name|MD_SMTP
condition|)
operator|(
name|void
operator|)
name|initsrvtls
argument_list|(
name|tls_ok
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* STARTTLS */
comment|/* turn off profiling */
name|SM_PROF
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|smtp
argument_list|(
name|nullserver
argument_list|,
operator|*
name|p_flags
argument_list|,
operator|&
name|MainEnvelope
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|93
argument_list|,
literal|100
argument_list|)
condition|)
block|{
comment|/* turn off profiling */
name|SM_PROF
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|OpMode
operator|==
name|MD_DAEMON
condition|)
goto|goto
name|nextreq
goto|;
block|}
block|}
name|sm_rpool_free
argument_list|(
name|MainEnvelope
operator|.
name|e_rpool
argument_list|)
expr_stmt|;
name|clearenvelope
argument_list|(
operator|&
name|MainEnvelope
argument_list|,
name|false
argument_list|,
name|sm_rpool_new_x
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|OpMode
operator|==
name|MD_VERIFY
condition|)
block|{
name|set_delivery_mode
argument_list|(
name|SM_VERIFY
argument_list|,
operator|&
name|MainEnvelope
argument_list|)
expr_stmt|;
name|PostMasterCopy
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* interactive -- all errors are global */
name|MainEnvelope
operator|.
name|e_flags
operator||=
name|EF_GLOBALERRS
operator||
name|EF_LOGSENDER
expr_stmt|;
block|}
comment|/* 	**  Do basic system initialization and set the sender 	*/
name|initsys
argument_list|(
operator|&
name|MainEnvelope
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|MainEnvelope
operator|.
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{ntries}"
argument_list|)
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|MainEnvelope
operator|.
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{nrcpts}"
argument_list|)
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|setsender
argument_list|(
name|from
argument_list|,
operator|&
name|MainEnvelope
argument_list|,
name|NULL
argument_list|,
literal|'\0'
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_f_flag
operator|!=
literal|'\0'
operator|&&
operator|!
name|wordinclass
argument_list|(
name|RealUserName
argument_list|,
literal|'t'
argument_list|)
operator|&&
operator|(
operator|!
name|bitnset
argument_list|(
name|M_LOCALMAILER
argument_list|,
name|MainEnvelope
operator|.
name|e_from
operator|.
name|q_mailer
operator|->
name|m_flags
argument_list|)
operator|||
name|strcmp
argument_list|(
name|MainEnvelope
operator|.
name|e_from
operator|.
name|q_user
argument_list|,
name|RealUserName
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|auth_warning
argument_list|(
operator|&
name|MainEnvelope
argument_list|,
literal|"%s set sender to %s using -%c"
argument_list|,
name|RealUserName
argument_list|,
name|from
argument_list|,
name|warn_f_flag
argument_list|)
expr_stmt|;
if|#
directive|if
name|SASL
name|auth
operator|=
name|false
expr_stmt|;
endif|#
directive|endif
comment|/* SASL */
block|}
if|if
condition|(
name|auth
condition|)
block|{
name|char
modifier|*
name|fv
decl_stmt|;
comment|/* set the initial sender for AUTH= to $f@$j */
name|fv
operator|=
name|macvalue
argument_list|(
literal|'f'
argument_list|,
operator|&
name|MainEnvelope
argument_list|)
expr_stmt|;
if|if
condition|(
name|fv
operator|==
name|NULL
operator|||
operator|*
name|fv
operator|==
literal|'\0'
condition|)
name|MainEnvelope
operator|.
name|e_auth_param
operator|=
name|NULL
expr_stmt|;
else|else
block|{
if|if
condition|(
name|strchr
argument_list|(
name|fv
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
name|fv
argument_list|)
operator|+
name|strlen
argument_list|(
name|macvalue
argument_list|(
literal|'j'
argument_list|,
operator|&
name|MainEnvelope
argument_list|)
argument_list|)
operator|+
literal|2
expr_stmt|;
name|p
operator|=
name|sm_malloc_x
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
literal|3
argument_list|,
name|fv
argument_list|,
literal|"@"
argument_list|,
name|macvalue
argument_list|(
literal|'j'
argument_list|,
operator|&
name|MainEnvelope
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|=
name|sm_strdup_x
argument_list|(
name|fv
argument_list|)
expr_stmt|;
name|MainEnvelope
operator|.
name|e_auth_param
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|MainEnvelope
operator|.
name|e_rpool
argument_list|,
name|xtextify
argument_list|(
name|p
argument_list|,
literal|"="
argument_list|)
argument_list|)
expr_stmt|;
name|sm_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
block|}
if|if
condition|(
name|macvalue
argument_list|(
literal|'s'
argument_list|,
operator|&
name|MainEnvelope
argument_list|)
operator|==
name|NULL
condition|)
name|macdefine
argument_list|(
operator|&
name|MainEnvelope
operator|.
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'s'
argument_list|,
name|RealHostName
argument_list|)
expr_stmt|;
name|av
operator|=
name|argv
operator|+
name|optind
expr_stmt|;
if|if
condition|(
operator|*
name|av
operator|==
name|NULL
operator|&&
operator|!
name|GrabTo
condition|)
block|{
name|MainEnvelope
operator|.
name|e_to
operator|=
name|NULL
expr_stmt|;
name|MainEnvelope
operator|.
name|e_flags
operator||=
name|EF_GLOBALERRS
expr_stmt|;
name|HoldErrs
operator|=
name|false
expr_stmt|;
name|SuperSafe
operator|=
name|SAFE_NO
expr_stmt|;
name|usrerr
argument_list|(
literal|"Recipient names must be specified"
argument_list|)
expr_stmt|;
comment|/* collect body for UUCP return */
if|if
condition|(
name|OpMode
operator|!=
name|MD_VERIFY
condition|)
name|collect
argument_list|(
name|InChannel
argument_list|,
name|false
argument_list|,
name|NULL
argument_list|,
operator|&
name|MainEnvelope
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|EX_USAGE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* 	**  Scan argv and deliver the message to everyone. 	*/
name|save_val
operator|=
name|LogUsrErrs
expr_stmt|;
name|LogUsrErrs
operator|=
name|true
expr_stmt|;
name|sendtoargv
argument_list|(
name|av
argument_list|,
operator|&
name|MainEnvelope
argument_list|)
expr_stmt|;
name|LogUsrErrs
operator|=
name|save_val
expr_stmt|;
comment|/* if we have had errors sofar, arrange a meaningful exit stat */
if|if
condition|(
name|Errors
operator|>
literal|0
operator|&&
name|ExitStat
operator|==
name|EX_OK
condition|)
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
if|#
directive|if
name|_FFR_FIX_DASHT
comment|/* 	**  If using -t, force not sending to argv recipients, even 	**  if they are mentioned in the headers. 	*/
if|if
condition|(
name|GrabTo
condition|)
block|{
name|ADDRESS
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|MainEnvelope
operator|.
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
name|q
operator|->
name|q_state
operator|=
name|QS_REMOVED
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _FFR_FIX_DASHT */
comment|/* 	**  Read the input mail. 	*/
name|MainEnvelope
operator|.
name|e_to
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|OpMode
operator|!=
name|MD_VERIFY
operator|||
name|GrabTo
condition|)
block|{
name|int
name|savederrors
decl_stmt|;
name|unsigned
name|long
name|savedflags
decl_stmt|;
comment|/* 		**  workaround for compiler warning on Irix: 		**  do not initialize variable in the definition, but 		**  later on: 		**  warning(1548): transfer of control bypasses 		**  initialization of: 		**  variable "savederrors" (declared at line 2570) 		**  variable "savedflags" (declared at line 2571) 		**  goto giveup; 		*/
name|savederrors
operator|=
name|Errors
expr_stmt|;
name|savedflags
operator|=
name|MainEnvelope
operator|.
name|e_flags
operator|&
name|EF_FATALERRS
expr_stmt|;
name|MainEnvelope
operator|.
name|e_flags
operator||=
name|EF_GLOBALERRS
expr_stmt|;
name|MainEnvelope
operator|.
name|e_flags
operator|&=
operator|~
name|EF_FATALERRS
expr_stmt|;
name|Errors
operator|=
literal|0
expr_stmt|;
name|buffer_errors
argument_list|()
expr_stmt|;
name|collect
argument_list|(
name|InChannel
argument_list|,
name|false
argument_list|,
name|NULL
argument_list|,
operator|&
name|MainEnvelope
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* header checks failed */
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
block|{
name|giveup
label|:
if|if
condition|(
operator|!
name|GrabTo
condition|)
block|{
comment|/* Log who the mail would have gone to */
name|logundelrcpts
argument_list|(
operator|&
name|MainEnvelope
argument_list|,
name|MainEnvelope
operator|.
name|e_message
argument_list|,
literal|8
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|flush_errors
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
operator|-
literal|1
return|;
block|}
comment|/* bail out if message too large */
if|if
condition|(
name|bitset
argument_list|(
name|EF_CLRQUEUE
argument_list|,
name|MainEnvelope
operator|.
name|e_flags
argument_list|)
condition|)
block|{
name|finis
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|ExitStat
operator|!=
name|EX_OK
condition|?
name|ExitStat
else|:
name|EX_DATAERR
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
operator|-
literal|1
return|;
block|}
comment|/* set message size */
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%ld"
argument_list|,
name|MainEnvelope
operator|.
name|e_msgsize
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|MainEnvelope
operator|.
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{msg_size}"
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|Errors
operator|=
name|savederrors
expr_stmt|;
name|MainEnvelope
operator|.
name|e_flags
operator||=
name|savedflags
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"From person = \"%s\"\n"
argument_list|,
name|MainEnvelope
operator|.
name|e_from
operator|.
name|q_paddr
argument_list|)
expr_stmt|;
comment|/* Check if quarantining stats should be updated */
if|if
condition|(
name|MainEnvelope
operator|.
name|e_quarmsg
operator|!=
name|NULL
condition|)
name|markstats
argument_list|(
operator|&
name|MainEnvelope
argument_list|,
name|NULL
argument_list|,
name|STATS_QUARANTINE
argument_list|)
expr_stmt|;
comment|/* 	**  Actually send everything. 	**	If verifying, just ack. 	*/
if|if
condition|(
name|Errors
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|split_by_recipient
argument_list|(
operator|&
name|MainEnvelope
argument_list|)
operator|&&
name|bitset
argument_list|(
name|EF_FATALERRS
argument_list|,
name|MainEnvelope
operator|.
name|e_flags
argument_list|)
condition|)
goto|goto
name|giveup
goto|;
block|}
comment|/* make sure we deliver at least the first envelope */
name|i
operator|=
name|FastSplit
operator|>
literal|0
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|e
operator|=
operator|&
name|MainEnvelope
init|;
name|e
operator|!=
name|NULL
condition|;
name|e
operator|=
name|e
operator|->
name|e_sibling
operator|,
name|i
operator|++
control|)
block|{
name|ENVELOPE
modifier|*
name|next
decl_stmt|;
name|e
operator|->
name|e_from
operator|.
name|q_state
operator|=
name|QS_SENDER
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|1
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"main[%d]: QS_SENDER "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
operator|&
name|e
operator|->
name|e_from
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
name|sm_getla
argument_list|()
expr_stmt|;
name|GrabTo
operator|=
name|false
expr_stmt|;
if|#
directive|if
name|NAMED_BIND
name|_res
operator|.
name|retry
operator|=
name|TimeOuts
operator|.
name|res_retry
index|[
name|RES_TO_FIRST
index|]
expr_stmt|;
name|_res
operator|.
name|retrans
operator|=
name|TimeOuts
operator|.
name|res_retrans
index|[
name|RES_TO_FIRST
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* NAMED_BIND */
name|next
operator|=
name|e
operator|->
name|e_sibling
expr_stmt|;
name|e
operator|->
name|e_sibling
operator|=
name|NULL
expr_stmt|;
comment|/* after FastSplit envelopes: queue up */
name|sendall
argument_list|(
name|e
argument_list|,
name|i
operator|>=
name|FastSplit
condition|?
name|SM_QUEUE
else|:
name|SM_DEFAULT
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_sibling
operator|=
name|next
expr_stmt|;
block|}
comment|/* 	**  All done. 	**	Don't send return error message if in VERIFY mode. 	*/
name|finis
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|ExitStat
return|;
block|}
end_function

begin_comment
comment|/* **  STOP_SENDMAIL -- Stop the running program ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		exits. */
end_comment

begin_function
name|void
name|stop_sendmail
parameter_list|()
block|{
comment|/* reset uid for process accounting */
name|endpwent
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|RealUid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  FINIS -- Clean up and exit. ** **	Parameters: **		drop -- whether or not to drop CurEnv envelope **		cleanup -- call exit() or _exit()? **		exitstat -- exit status to use for exit() call ** **	Returns: **		never ** **	Side Effects: **		exits sendmail */
end_comment

begin_function
name|void
name|finis
parameter_list|(
name|drop
parameter_list|,
name|cleanup
parameter_list|,
name|exitstat
parameter_list|)
name|bool
name|drop
decl_stmt|;
name|bool
name|cleanup
decl_stmt|;
specifier|volatile
name|int
name|exitstat
decl_stmt|;
block|{
name|char
name|pidpath
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
comment|/* Still want to process new timeouts added below */
name|sm_clear_events
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|sm_releasesignal
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"\n====finis: stat %d e_id=%s e_flags="
argument_list|,
name|exitstat
argument_list|,
name|CurEnv
operator|->
name|e_id
operator|==
name|NULL
condition|?
literal|"NOQUEUE"
else|:
name|CurEnv
operator|->
name|e_id
argument_list|)
expr_stmt|;
name|printenvflags
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|2
argument_list|,
literal|9
argument_list|)
condition|)
name|printopenfds
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|SM_TRY
comment|/* 		**  Clean up.  This might raise E:mta.quickabort 		*/
comment|/* clean up temp files */
name|CurEnv
operator|->
name|e_to
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|drop
condition|)
block|{
if|if
condition|(
name|CurEnv
operator|->
name|e_id
operator|!=
name|NULL
condition|)
block|{
name|dropenvelope
argument_list|(
name|CurEnv
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|sm_rpool_free
argument_list|(
name|CurEnv
operator|->
name|e_rpool
argument_list|)
expr_stmt|;
name|CurEnv
operator|->
name|e_rpool
operator|=
name|NULL
expr_stmt|;
comment|/* these may have pointed to the rpool */
name|CurEnv
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
name|CurEnv
operator|->
name|e_message
operator|=
name|NULL
expr_stmt|;
name|CurEnv
operator|->
name|e_statmsg
operator|=
name|NULL
expr_stmt|;
name|CurEnv
operator|->
name|e_quarmsg
operator|=
name|NULL
expr_stmt|;
name|CurEnv
operator|->
name|e_bodytype
operator|=
name|NULL
expr_stmt|;
name|CurEnv
operator|->
name|e_id
operator|=
name|NULL
expr_stmt|;
name|CurEnv
operator|->
name|e_envid
operator|=
name|NULL
expr_stmt|;
name|CurEnv
operator|->
name|e_auth_param
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|poststats
argument_list|(
name|StatFile
argument_list|)
expr_stmt|;
block|}
comment|/* flush any cached connections */
name|mci_flush
argument_list|(
name|true
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* close maps belonging to this pid */
name|closemaps
argument_list|(
name|false
argument_list|)
expr_stmt|;
if|#
directive|if
name|USERDB
comment|/* close UserDatabase */
name|_udbx_close
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* USERDB */
if|#
directive|if
name|SASL
name|stop_sasl_client
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* SASL */
if|#
directive|if
name|XLA
comment|/* clean up extended load average stuff */
name|xla_all_end
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* XLA */
name|SM_FINALLY
comment|/* 		**  And exit. 		*/
if|if
condition|(
name|LogLevel
operator|>
literal|78
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"finis, pid=%d"
argument_list|,
operator|(
name|int
operator|)
name|CurrentPid
argument_list|)
expr_stmt|;
if|if
condition|(
name|exitstat
operator|==
name|EX_TEMPFAIL
operator|||
name|CurEnv
operator|->
name|e_errormode
operator|==
name|EM_BERKNET
condition|)
name|exitstat
operator|=
name|EX_OK
expr_stmt|;
comment|/* XXX clean up queues and related data structures */
name|cleanup_queues
argument_list|()
expr_stmt|;
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
if|#
directive|if
name|SM_CONF_SHM
name|cleanup_shm
argument_list|(
name|DaemonPid
operator|==
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SM_CONF_SHM */
comment|/* close locked pid file */
name|close_sendmail_pid
argument_list|()
expr_stmt|;
if|if
condition|(
name|DaemonPid
operator|==
name|pid
operator|||
name|PidFilePid
operator|==
name|pid
condition|)
block|{
comment|/* blow away the pid file */
name|expand
argument_list|(
name|PidFile
argument_list|,
name|pidpath
argument_list|,
sizeof|sizeof
argument_list|(
name|pidpath
argument_list|)
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|pidpath
argument_list|)
expr_stmt|;
block|}
comment|/* reset uid for process accounting */
name|endpwent
argument_list|()
expr_stmt|;
name|sm_mbdb_terminate
argument_list|()
expr_stmt|;
if|#
directive|if
name|_FFR_MEMSTAT
operator|(
name|void
operator|)
name|sm_memstat_close
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_MEMSTAT */
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|RealUid
argument_list|)
expr_stmt|;
if|#
directive|if
name|SM_HEAP_CHECK
comment|/* dump the heap, if we are checking for memory leaks */
if|if
condition|(
name|sm_debug_active
argument_list|(
operator|&
name|SmHeapCheck
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_heap_report
argument_list|(
name|smioout
argument_list|,
name|sm_debug_level
argument_list|(
operator|&
name|SmHeapCheck
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SM_HEAP_CHECK */
if|if
condition|(
name|sm_debug_active
argument_list|(
operator|&
name|SmXtrapReport
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"xtrap count = %d\n"
argument_list|,
name|SmXtrapCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleanup
condition|)
name|exit
argument_list|(
name|exitstat
argument_list|)
expr_stmt|;
else|else
name|_exit
argument_list|(
name|exitstat
argument_list|)
expr_stmt|;
name|SM_END_TRY
block|}
end_function

begin_comment
comment|/* **  INTINDEBUG -- signal handler for SIGINT in -bt mode ** **	Parameters: **		sig -- incoming signal. ** **	Returns: **		none. ** **	Side Effects: **		longjmps back to test mode loop. ** **	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD **		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE **		DOING. */
end_comment

begin_comment
comment|/* Type of an exception generated on SIGINT during address test mode.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|SM_EXC_TYPE_T
name|EtypeInterrupt
init|=
block|{
name|SmExcTypeMagic
block|,
literal|"S:mta.interrupt"
block|,
literal|""
block|,
name|sm_etype_printf
block|,
literal|"interrupt"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|SIGFUNC_DECL
name|intindebug
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|FIX_SYSV_SIGNAL
argument_list|(
name|sig
argument_list|,
name|intindebug
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
name|CHECK_CRITICAL
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
name|sm_exc_raisenew_x
argument_list|(
operator|&
name|EtypeInterrupt
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
name|SIGFUNC_RETURN
return|;
block|}
end_function

begin_comment
comment|/* **  SIGTERM -- SIGTERM handler for the daemon ** **	Parameters: **		sig -- signal number. ** **	Returns: **		none. ** **	Side Effects: **		Sets ShutdownRequest which will hopefully trigger **		the daemon to exit. ** **	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD **		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE **		DOING. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|SIGFUNC_DECL
name|sigterm
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|FIX_SYSV_SIGNAL
argument_list|(
name|sig
argument_list|,
name|sigterm
argument_list|)
expr_stmt|;
name|ShutdownRequest
operator|=
literal|"signal"
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
name|SIGFUNC_RETURN
return|;
block|}
end_function

begin_comment
comment|/* **  SIGHUP -- handle a SIGHUP signal ** **	Parameters: **		sig -- incoming signal. ** **	Returns: **		none. ** **	Side Effects: **		Sets RestartRequest which should cause the daemon **		to restart. ** **	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD **		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE **		DOING. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|SIGFUNC_DECL
name|sighup
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|FIX_SYSV_SIGNAL
argument_list|(
name|sig
argument_list|,
name|sighup
argument_list|)
expr_stmt|;
name|RestartRequest
operator|=
literal|"signal"
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
name|SIGFUNC_RETURN
return|;
block|}
end_function

begin_comment
comment|/* **  SIGPIPE -- signal handler for SIGPIPE ** **	Parameters: **		sig -- incoming signal. ** **	Returns: **		none. ** **	Side Effects: **		Sets StopRequest which should cause the mailq/hoststatus **		display to stop. ** **	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD **		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE **		DOING. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|SIGFUNC_DECL
name|sigpipe
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|FIX_SYSV_SIGNAL
argument_list|(
name|sig
argument_list|,
name|sigpipe
argument_list|)
expr_stmt|;
name|StopRequest
operator|=
name|true
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
name|SIGFUNC_RETURN
return|;
block|}
end_function

begin_comment
comment|/* **  INTSIG -- clean up on interrupt ** **	This just arranges to exit.  It pessimizes in that it **	may resend a message. ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		Unlocks the current job. ** **	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD **		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE **		DOING. ** **		XXX: More work is needed for this signal handler. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|SIGFUNC_DECL
name|intsig
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|bool
name|drop
init|=
name|false
decl_stmt|;
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|FIX_SYSV_SIGNAL
argument_list|(
name|sig
argument_list|,
name|intsig
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
name|CHECK_CRITICAL
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|sm_allsignals
argument_list|(
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|!=
literal|0
operator|&&
name|LogLevel
operator|>
literal|79
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"interrupt"
argument_list|)
expr_stmt|;
name|FileName
operator|=
name|NULL
expr_stmt|;
comment|/* Clean-up on aborted stdin message submission */
if|if
condition|(
name|CurEnv
operator|->
name|e_id
operator|!=
name|NULL
operator|&&
operator|(
name|OpMode
operator|==
name|MD_SMTP
operator|||
name|OpMode
operator|==
name|MD_DELIVER
operator|||
name|OpMode
operator|==
name|MD_ARPAFTP
operator|)
condition|)
block|{
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
comment|/* don't return an error indication */
name|CurEnv
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
name|CurEnv
operator|->
name|e_flags
operator|&=
operator|~
name|EF_FATALERRS
expr_stmt|;
name|CurEnv
operator|->
name|e_flags
operator||=
name|EF_CLRQUEUE
expr_stmt|;
comment|/* 		**  Spin through the addresses and 		**  mark them dead to prevent bounces 		*/
for|for
control|(
name|q
operator|=
name|CurEnv
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
name|q
operator|->
name|q_state
operator|=
name|QS_DONTSEND
expr_stmt|;
name|drop
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OpMode
operator|!=
name|MD_TEST
condition|)
block|{
name|unlockqueue
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
block|}
name|finis
argument_list|(
name|drop
argument_list|,
name|false
argument_list|,
name|EX_OK
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* **  DISCONNECT -- remove our connection with any foreground process ** **	Parameters: **		droplev -- how "deeply" we should drop the line. **			0 -- ignore signals, mail back errors, make sure **			     output goes to stdout. **			1 -- also, make stdout go to /dev/null. **			2 -- also, disconnect from controlling terminal **			     (only for daemon mode). **		e -- the current envelope. ** **	Returns: **		none ** **	Side Effects: **		Trys to insure that we are immune to vagaries of **		the controlling tty. */
end_comment

begin_function
name|void
name|disconnect
parameter_list|(
name|droplev
parameter_list|,
name|e
parameter_list|)
name|int
name|droplev
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|52
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"disconnect: In %d Out %d, e=%p\n"
argument_list|,
name|sm_io_getinfo
argument_list|(
name|InChannel
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|sm_io_getinfo
argument_list|(
name|OutChannel
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|52
argument_list|,
literal|100
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"don't\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|LogLevel
operator|>
literal|93
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"disconnect level %d"
argument_list|,
name|droplev
argument_list|)
expr_stmt|;
comment|/* be sure we don't get nasty signals */
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* we can't communicate with our caller, so.... */
name|HoldErrs
operator|=
name|true
expr_stmt|;
name|CurEnv
operator|->
name|e_errormode
operator|=
name|EM_MAIL
expr_stmt|;
name|Verbose
operator|=
literal|0
expr_stmt|;
name|DisConnected
operator|=
name|true
expr_stmt|;
comment|/* all input from /dev/null */
if|if
condition|(
name|InChannel
operator|!=
name|smioin
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|InChannel
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
name|InChannel
operator|=
name|smioin
expr_stmt|;
block|}
if|if
condition|(
name|sm_io_reopen
argument_list|(
name|SmFtStdio
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|SM_PATH_DEVNULL
argument_list|,
name|SM_IO_RDONLY
argument_list|,
name|NULL
argument_list|,
name|smioin
argument_list|)
operator|==
name|NULL
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"disconnect: sm_io_reopen(\"%s\") failed: %s"
argument_list|,
name|SM_PATH_DEVNULL
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	**  output to the transcript 	**	We also compare the fd numbers here since OutChannel 	**	might be a layer on top of smioout due to encryption 	**	(see sfsasl.c). 	*/
if|if
condition|(
name|OutChannel
operator|!=
name|smioout
operator|&&
name|sm_io_getinfo
argument_list|(
name|OutChannel
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
operator|!=
name|sm_io_getinfo
argument_list|(
name|smioout
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|OutChannel
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
name|OutChannel
operator|=
name|smioout
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 		**  Has smioout been closed? Reopen it. 		**	This shouldn't happen anymore, the code is here 		**	just as a reminder. 		*/
block|if (smioout->sm_magic == NULL&& 		    sm_io_reopen(SmFtStdio, SM_TIME_DEFAULT, SM_PATH_DEVNULL, 				 SM_IO_WRONLY, NULL, smioout) == NULL) 			sm_syslog(LOG_ERR, e->e_id, 				  "disconnect: sm_io_reopen(\"%s\") failed: %s", 				  SM_PATH_DEVNULL, sm_errstring(errno));
endif|#
directive|endif
comment|/* 0 */
block|}
if|if
condition|(
name|droplev
operator|>
literal|0
condition|)
block|{
name|fd
operator|=
name|open
argument_list|(
name|SM_PATH_DEVNULL
argument_list|,
name|O_WRONLY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"disconnect: open(\"%s\") failed: %s"
argument_list|,
name|SM_PATH_DEVNULL
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_io_flush
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|fd
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|fd
argument_list|,
name|STDERR_FILENO
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* drop our controlling TTY completely if possible */
if|if
condition|(
name|droplev
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|setsid
argument_list|()
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
name|XDEBUG
name|checkfd012
argument_list|(
literal|"disconnect"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XDEBUG */
if|if
condition|(
name|LogLevel
operator|>
literal|71
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"in background, pid=%d"
argument_list|,
operator|(
name|int
operator|)
name|CurrentPid
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obsolete
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ap
decl_stmt|;
specifier|register
name|char
modifier|*
name|op
decl_stmt|;
while|while
condition|(
operator|(
name|ap
operator|=
operator|*
operator|++
name|argv
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Return if "--" or not an option of any form. */
if|if
condition|(
name|ap
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|ap
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
return|return;
comment|/* Don't allow users to use "-Q." or "-Q ." */
if|if
condition|(
operator|(
name|ap
index|[
literal|1
index|]
operator|==
literal|'Q'
operator|&&
name|ap
index|[
literal|2
index|]
operator|==
literal|'.'
operator|)
operator|||
operator|(
name|ap
index|[
literal|1
index|]
operator|==
literal|'Q'
operator|&&
name|argv
index|[
literal|1
index|]
operator|!=
name|NULL
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Can not use -Q.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
comment|/* skip over options that do have a value */
name|op
operator|=
name|strchr
argument_list|(
name|OPTIONS
argument_list|,
name|ap
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|!=
name|NULL
operator|&&
operator|*
operator|++
name|op
operator|==
literal|':'
operator|&&
name|ap
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|&&
name|ap
index|[
literal|1
index|]
operator|!=
literal|'d'
operator|&&
if|#
directive|if
name|defined
argument_list|(
name|sony_news
argument_list|)
name|ap
index|[
literal|1
index|]
operator|!=
literal|'E'
operator|&&
name|ap
index|[
literal|1
index|]
operator|!=
literal|'J'
operator|&&
endif|#
directive|endif
comment|/* defined(sony_news) */
name|argv
index|[
literal|1
index|]
operator|!=
name|NULL
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
name|argv
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* If -C doesn't have an argument, use sendmail.cf. */
define|#
directive|define
name|__DEFPATH
value|"sendmail.cf"
if|if
condition|(
name|ap
index|[
literal|1
index|]
operator|==
literal|'C'
operator|&&
name|ap
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|argv
operator|=
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|__DEFPATH
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|__DEFPATH
argument_list|)
operator|+
literal|2
argument_list|,
literal|2
argument_list|,
literal|"-C"
argument_list|,
name|__DEFPATH
argument_list|)
expr_stmt|;
block|}
comment|/* If -q doesn't have an argument, run it once. */
if|if
condition|(
name|ap
index|[
literal|1
index|]
operator|==
literal|'q'
operator|&&
name|ap
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
operator|*
name|argv
operator|=
literal|"-q0"
expr_stmt|;
comment|/* If -Q doesn't have an argument, disable quarantining */
if|if
condition|(
name|ap
index|[
literal|1
index|]
operator|==
literal|'Q'
operator|&&
name|ap
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
operator|*
name|argv
operator|=
literal|"-Q."
expr_stmt|;
comment|/* if -d doesn't have an argument, use 0-99.1 */
if|if
condition|(
name|ap
index|[
literal|1
index|]
operator|==
literal|'d'
operator|&&
name|ap
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
operator|*
name|argv
operator|=
literal|"-d0-99.1"
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sony_news
argument_list|)
comment|/* if -E doesn't have an argument, use -EC */
if|if
condition|(
name|ap
index|[
literal|1
index|]
operator|==
literal|'E'
operator|&&
name|ap
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
operator|*
name|argv
operator|=
literal|"-EC"
expr_stmt|;
comment|/* if -J doesn't have an argument, use -JJ */
if|if
condition|(
name|ap
index|[
literal|1
index|]
operator|==
literal|'J'
operator|&&
name|ap
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
operator|*
name|argv
operator|=
literal|"-JJ"
expr_stmt|;
endif|#
directive|endif
comment|/* defined(sony_news) */
block|}
block|}
end_function

begin_comment
comment|/* **  AUTH_WARNING -- specify authorization warning ** **	Parameters: **		e -- the current envelope. **		msg -- the text of the message. **		args -- arguments to the message. ** **	Returns: **		none. */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|auth_warning
parameter_list|(
specifier|register
name|ENVELOPE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
comment|/* __STDC__ */
function|auth_warning
parameter_list|(
name|e
parameter_list|,
name|msg
parameter_list|,
name|va_alist
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
function|va_dcl
endif|#
directive|endif
comment|/* __STDC__ */
block|{
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|SM_VA_LOCAL_DECL
if|if
condition|(
name|bitset
argument_list|(
name|PRIV_AUTHWARNINGS
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|char
name|hostbuf
index|[
literal|48
index|]
decl_stmt|;
if|if
condition|(
name|hostbuf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|hp
operator|=
name|myhostname
argument_list|(
name|hostbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|hostbuf
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|NETINET6
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
block|{
name|freehostent
argument_list|(
name|hp
argument_list|)
expr_stmt|;
name|hp
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NETINET6 */
block|}
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|2
argument_list|,
name|hostbuf
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
index|]
expr_stmt|;
name|SM_VA_START
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_vsnprintf
argument_list|(
name|p
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|p
argument_list|)
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|SM_VA_END
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|addheader
argument_list|(
literal|"X-Authentication-Warning"
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|e
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|3
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Authentication-Warning: %.400s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  GETEXTENV -- get from external environment ** **	Parameters: **		envar -- the name of the variable to retrieve ** **	Returns: **		The value, if any. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|getextenv
parameter_list|(
name|envar
parameter_list|)
specifier|const
name|char
modifier|*
name|envar
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
name|int
name|l
decl_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|envar
argument_list|)
expr_stmt|;
for|for
control|(
name|envp
operator|=
name|ExternalEnviron
init|;
name|envp
operator|!=
name|NULL
operator|&&
operator|*
name|envp
operator|!=
name|NULL
condition|;
name|envp
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|envp
argument_list|,
name|envar
argument_list|,
name|l
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|*
name|envp
operator|)
index|[
name|l
index|]
operator|==
literal|'='
condition|)
return|return
operator|&
operator|(
operator|*
name|envp
operator|)
index|[
name|l
operator|+
literal|1
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  SM_SETUSERENV -- set an environment variable in the propagated environment ** **	Parameters: **		envar -- the name of the environment variable. **		value -- the value to which it should be set.  If **			null, this is extracted from the incoming **			environment.  If that is not set, the call **			to sm_setuserenv is ignored. ** **	Returns: **		none. */
end_comment

begin_function
name|void
name|sm_setuserenv
parameter_list|(
name|envar
parameter_list|,
name|value
parameter_list|)
specifier|const
name|char
modifier|*
name|envar
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
name|char
modifier|*
modifier|*
name|evp
init|=
name|UserEnviron
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
name|value
operator|=
name|getextenv
argument_list|(
name|envar
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
return|return;
block|}
comment|/* XXX enforce reasonable size? */
name|i
operator|=
name|strlen
argument_list|(
name|envar
argument_list|)
operator|+
literal|1
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
name|i
operator|+
literal|1
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|xalloc
argument_list|(
name|l
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
literal|3
argument_list|,
name|envar
argument_list|,
literal|"="
argument_list|,
name|value
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|evp
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
operator|*
name|evp
argument_list|,
name|p
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
name|evp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|evp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|evp
operator|++
operator|=
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|evp
operator|<
operator|&
name|UserEnviron
index|[
name|MAXUSERENVIRON
index|]
condition|)
block|{
operator|*
name|evp
operator|++
operator|=
name|p
expr_stmt|;
operator|*
name|evp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* make sure it is in our environment as well */
if|if
condition|(
name|putenv
argument_list|(
name|p
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"sm_setuserenv: putenv(%s) failed"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  DUMPSTATE -- dump state ** **	For debugging. */
end_comment

begin_function
name|void
name|dumpstate
parameter_list|(
name|when
parameter_list|)
name|char
modifier|*
name|when
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|j
init|=
name|macvalue
argument_list|(
literal|'j'
argument_list|,
name|CurEnv
argument_list|)
decl_stmt|;
name|int
name|rs
decl_stmt|;
specifier|extern
name|int
name|NextMacroId
decl_stmt|;
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"--- dumping state on %s: $j = %s ---"
argument_list|,
name|when
argument_list|,
name|j
operator|==
name|NULL
condition|?
literal|"<NULL>"
else|:
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|wordinclass
argument_list|(
name|j
argument_list|,
literal|'w'
argument_list|)
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"*** $j not in $=w ***"
argument_list|)
expr_stmt|;
block|}
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"CurChildren = %d"
argument_list|,
name|CurChildren
argument_list|)
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"NextMacroId = %d (Max %d)"
argument_list|,
name|NextMacroId
argument_list|,
name|MAXMACROID
argument_list|)
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"--- open file descriptors: ---"
argument_list|)
expr_stmt|;
name|printopenfds
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"--- connection cache: ---"
argument_list|)
expr_stmt|;
name|mci_dump_all
argument_list|(
name|smioout
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|rs
operator|=
name|strtorwset
argument_list|(
literal|"debug_dumpstate"
argument_list|,
name|NULL
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|>
literal|0
condition|)
block|{
name|int
name|status
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
name|char
modifier|*
name|pv
index|[
name|MAXATOM
operator|+
literal|1
index|]
decl_stmt|;
name|pv
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|status
operator|=
name|REWRITE
argument_list|(
name|pv
argument_list|,
name|rs
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"--- ruleset debug_dumpstate returns stat %d, pv: ---"
argument_list|,
name|status
argument_list|)
expr_stmt|;
for|for
control|(
name|pvp
operator|=
name|pv
init|;
operator|*
name|pvp
operator|!=
name|NULL
condition|;
name|pvp
operator|++
control|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"%s"
argument_list|,
operator|*
name|pvp
argument_list|)
expr_stmt|;
block|}
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"--- end of state dump ---"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SIGUSR1
end_ifdef

begin_comment
comment|/* **  SIGUSR1 -- Signal a request to dump state. ** **	Parameters: **		sig -- calling signal. ** **	Returns: **		none. ** **	NOTE:	THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD **		ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE **		DOING. ** **		XXX: More work is needed for this signal handler. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|SIGFUNC_DECL
name|sigusr1
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|FIX_SYSV_SIGNAL
argument_list|(
name|sig
argument_list|,
name|sigusr1
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
name|CHECK_CRITICAL
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|dumpstate
argument_list|(
literal|"user signal"
argument_list|)
expr_stmt|;
if|#
directive|if
name|SM_HEAP_CHECK
name|dumpstab
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* SM_HEAP_CHECK */
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
name|SIGFUNC_RETURN
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIGUSR1 */
end_comment

begin_comment
comment|/* **  DROP_PRIVILEGES -- reduce privileges to those of the RunAsUser option ** **	Parameters: **		to_real_uid -- if set, drop to the real uid instead **			of the RunAsUser. ** **	Returns: **		EX_OSERR if the setuid failed. **		EX_OK otherwise. */
end_comment

begin_function
name|int
name|drop_privileges
parameter_list|(
name|to_real_uid
parameter_list|)
name|bool
name|to_real_uid
decl_stmt|;
block|{
name|int
name|rval
init|=
name|EX_OK
decl_stmt|;
name|GIDSET_T
name|emptygidset
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|47
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"drop_privileges(%d): Real[UG]id=%d:%d, get[ug]id=%d:%d, gete[ug]id=%d:%d, RunAs[UG]id=%d:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|to_real_uid
argument_list|,
operator|(
name|int
operator|)
name|RealUid
argument_list|,
operator|(
name|int
operator|)
name|RealGid
argument_list|,
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getgid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getegid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|RunAsUid
argument_list|,
operator|(
name|int
operator|)
name|RunAsGid
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_real_uid
condition|)
block|{
name|RunAsUserName
operator|=
name|RealUserName
expr_stmt|;
name|RunAsUid
operator|=
name|RealUid
expr_stmt|;
name|RunAsGid
operator|=
name|RealGid
expr_stmt|;
name|EffGid
operator|=
name|RunAsGid
expr_stmt|;
block|}
comment|/* make sure no one can grab open descriptors for secret files */
name|endpwent
argument_list|()
expr_stmt|;
name|sm_mbdb_terminate
argument_list|()
expr_stmt|;
comment|/* reset group permissions; these can be set later */
name|emptygidset
index|[
literal|0
index|]
operator|=
operator|(
name|to_real_uid
operator|||
name|RunAsGid
operator|!=
literal|0
operator|)
condition|?
name|RunAsGid
else|:
name|getegid
argument_list|()
expr_stmt|;
comment|/* 	**  Notice:  on some OS (Linux...) the setgroups() call causes 	**	a logfile entry if sendmail is not run by root. 	**	However, it is unclear (no POSIX standard) whether 	**	setgroups() can only succeed if executed by root. 	**	So for now we keep it as it is; if you want to change it, use 	**  if (geteuid() == 0&& setgroups(1, emptygidset) == -1) 	*/
if|if
condition|(
name|setgroups
argument_list|(
literal|1
argument_list|,
name|emptygidset
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|geteuid
argument_list|()
operator|==
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"drop_privileges: setgroups(1, %d) failed"
argument_list|,
operator|(
name|int
operator|)
name|emptygidset
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|rval
operator|=
name|EX_OSERR
expr_stmt|;
block|}
comment|/* reset primary group id */
if|if
condition|(
name|to_real_uid
condition|)
block|{
comment|/* 		**  Drop gid to real gid. 		**  On some OS we must reset the effective[/real[/saved]] gid, 		**  and then use setgid() to finally drop all group privileges. 		**  Later on we check whether we can get back the 		**  effective gid. 		*/
if|#
directive|if
name|HASSETEGID
if|if
condition|(
name|setegid
argument_list|(
name|RunAsGid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"drop_privileges: setegid(%d) failed"
argument_list|,
operator|(
name|int
operator|)
name|RunAsGid
argument_list|)
expr_stmt|;
name|rval
operator|=
name|EX_OSERR
expr_stmt|;
block|}
else|#
directive|else
comment|/* HASSETEGID */
if|#
directive|if
name|HASSETREGID
if|if
condition|(
name|setregid
argument_list|(
name|RunAsGid
argument_list|,
name|RunAsGid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"drop_privileges: setregid(%d, %d) failed"
argument_list|,
operator|(
name|int
operator|)
name|RunAsGid
argument_list|,
operator|(
name|int
operator|)
name|RunAsGid
argument_list|)
expr_stmt|;
name|rval
operator|=
name|EX_OSERR
expr_stmt|;
block|}
else|#
directive|else
comment|/* HASSETREGID */
if|#
directive|if
name|HASSETRESGID
if|if
condition|(
name|setresgid
argument_list|(
name|RunAsGid
argument_list|,
name|RunAsGid
argument_list|,
name|RunAsGid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"drop_privileges: setresgid(%d, %d, %d) failed"
argument_list|,
operator|(
name|int
operator|)
name|RunAsGid
argument_list|,
operator|(
name|int
operator|)
name|RunAsGid
argument_list|,
operator|(
name|int
operator|)
name|RunAsGid
argument_list|)
expr_stmt|;
name|rval
operator|=
name|EX_OSERR
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HASSETRESGID */
endif|#
directive|endif
comment|/* HASSETREGID */
endif|#
directive|endif
comment|/* HASSETEGID */
block|}
if|if
condition|(
name|rval
operator|==
name|EX_OK
operator|&&
operator|(
name|to_real_uid
operator|||
name|RunAsGid
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|setgid
argument_list|(
name|RunAsGid
argument_list|)
operator|<
literal|0
operator|&&
operator|(
operator|!
name|UseMSP
operator|||
name|getegid
argument_list|()
operator|!=
name|RunAsGid
operator|)
condition|)
block|{
name|syserr
argument_list|(
literal|"drop_privileges: setgid(%d) failed"
argument_list|,
operator|(
name|int
operator|)
name|RunAsGid
argument_list|)
expr_stmt|;
name|rval
operator|=
name|EX_OSERR
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|EX_OK
operator|&&
name|getegid
argument_list|()
operator|!=
name|RunAsGid
condition|)
block|{
name|syserr
argument_list|(
literal|"drop_privileges: Unable to set effective gid=%d to RunAsGid=%d"
argument_list|,
operator|(
name|int
operator|)
name|getegid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|RunAsGid
argument_list|)
expr_stmt|;
name|rval
operator|=
name|EX_OSERR
expr_stmt|;
block|}
block|}
comment|/* fiddle with uid */
if|if
condition|(
name|to_real_uid
operator|||
name|RunAsUid
operator|!=
literal|0
condition|)
block|{
name|uid_t
name|euid
decl_stmt|;
comment|/* 		**  Try to setuid(RunAsUid). 		**  euid must be RunAsUid, 		**  ruid must be RunAsUid unless (e|r)uid wasn't 0 		**	and we didn't have to drop privileges to the real uid. 		*/
if|if
condition|(
name|setuid
argument_list|(
name|RunAsUid
argument_list|)
operator|<
literal|0
operator|||
name|geteuid
argument_list|()
operator|!=
name|RunAsUid
operator|||
operator|(
name|getuid
argument_list|()
operator|!=
name|RunAsUid
operator|&&
operator|(
name|to_real_uid
operator|||
name|geteuid
argument_list|()
operator|==
literal|0
operator|||
name|getuid
argument_list|()
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|#
directive|if
name|HASSETREUID
comment|/* 			**  if ruid != RunAsUid, euid == RunAsUid, then 			**  try resetting just the real uid, then using 			**  setuid() to drop the saved-uid as well. 			*/
if|if
condition|(
name|geteuid
argument_list|()
operator|==
name|RunAsUid
condition|)
block|{
if|if
condition|(
name|setreuid
argument_list|(
name|RunAsUid
argument_list|,
operator|-
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"drop_privileges: setreuid(%d, -1) failed"
argument_list|,
operator|(
name|int
operator|)
name|RunAsUid
argument_list|)
expr_stmt|;
name|rval
operator|=
name|EX_OSERR
expr_stmt|;
block|}
if|if
condition|(
name|setuid
argument_list|(
name|RunAsUid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"drop_privileges: second setuid(%d) attempt failed"
argument_list|,
operator|(
name|int
operator|)
name|RunAsUid
argument_list|)
expr_stmt|;
name|rval
operator|=
name|EX_OSERR
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* HASSETREUID */
block|{
name|syserr
argument_list|(
literal|"drop_privileges: setuid(%d) failed"
argument_list|,
operator|(
name|int
operator|)
name|RunAsUid
argument_list|)
expr_stmt|;
name|rval
operator|=
name|EX_OSERR
expr_stmt|;
block|}
block|}
name|euid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
if|if
condition|(
name|RunAsUid
operator|!=
literal|0
operator|&&
name|setuid
argument_list|(
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			**  Believe it or not, the Linux capability model 			**  allows a non-root process to override setuid() 			**  on a process running as root and prevent that 			**  process from dropping privileges. 			*/
name|syserr
argument_list|(
literal|"drop_privileges: setuid(0) succeeded (when it should not)"
argument_list|)
expr_stmt|;
name|rval
operator|=
name|EX_OSERR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RunAsUid
operator|!=
name|euid
operator|&&
name|setuid
argument_list|(
name|euid
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			**  Some operating systems will keep the saved-uid 			**  if a non-root effective-uid calls setuid(real-uid) 			**  making it possible to set it back again later. 			*/
name|syserr
argument_list|(
literal|"drop_privileges: Unable to drop non-root set-user-ID privileges"
argument_list|)
expr_stmt|;
name|rval
operator|=
name|EX_OSERR
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|to_real_uid
operator|||
name|RunAsGid
operator|!=
literal|0
operator|)
operator|&&
name|rval
operator|==
name|EX_OK
operator|&&
name|RunAsGid
operator|!=
name|EffGid
operator|&&
name|getuid
argument_list|()
operator|!=
literal|0
operator|&&
name|geteuid
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|setgid
argument_list|(
name|EffGid
argument_list|)
operator|==
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"drop_privileges: setgid(%d) succeeded (when it should not)"
argument_list|,
operator|(
name|int
operator|)
name|EffGid
argument_list|)
expr_stmt|;
name|rval
operator|=
name|EX_OSERR
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|47
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"drop_privileges: e/ruid = %d/%d e/rgid = %d/%d\n"
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getegid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"drop_privileges: RunAsUser = %d:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|RunAsUid
argument_list|,
operator|(
name|int
operator|)
name|RunAsGid
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|47
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"drop_privileges: rval = %d\n"
argument_list|,
name|rval
argument_list|)
expr_stmt|;
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* **  FILL_FD -- make sure a file descriptor has been properly allocated ** **	Used to make sure that stdin/out/err are allocated on startup ** **	Parameters: **		fd -- the file descriptor to be filled. **		where -- a string used for logging.  If NULL, this is **			being called on startup, and logging should **			not be done. ** **	Returns: **		none ** **	Side Effects: **		possibly changes MissingFds */
end_comment

begin_function
name|void
name|fill_fd
parameter_list|(
name|fd
parameter_list|,
name|where
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|>=
literal|0
operator|||
name|errno
operator|!=
name|EBADF
condition|)
return|return;
if|if
condition|(
name|where
operator|!=
name|NULL
condition|)
name|syserr
argument_list|(
literal|"fill_fd: %s: fd %d not open"
argument_list|,
name|where
argument_list|,
name|fd
argument_list|)
expr_stmt|;
else|else
name|MissingFds
operator||=
literal|1
operator|<<
name|fd
expr_stmt|;
name|i
operator|=
name|open
argument_list|(
name|SM_PATH_DEVNULL
argument_list|,
name|fd
operator|==
literal|0
condition|?
name|O_RDONLY
else|:
name|O_WRONLY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"!fill_fd: %s: cannot open %s"
argument_list|,
name|where
operator|==
name|NULL
condition|?
literal|"startup"
else|:
name|where
argument_list|,
name|SM_PATH_DEVNULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|!=
name|i
condition|)
block|{
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|i
argument_list|,
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  SM_PRINTOPTIONS -- print options ** **	Parameters: **		options -- array of options. ** **	Returns: **		none. */
end_comment

begin_function
specifier|static
name|void
name|sm_printoptions
parameter_list|(
name|options
parameter_list|)
name|char
modifier|*
modifier|*
name|options
decl_stmt|;
block|{
name|int
name|ll
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
name|av
operator|=
name|options
expr_stmt|;
name|ll
operator|=
literal|7
expr_stmt|;
while|while
condition|(
operator|*
name|av
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ll
operator|+
name|strlen
argument_list|(
operator|*
name|av
argument_list|)
operator|>
literal|63
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ll
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ll
operator|==
literal|0
condition|)
name|sm_dprintf
argument_list|(
literal|"\t\t"
argument_list|)
expr_stmt|;
else|else
name|sm_dprintf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"%s"
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
name|ll
operator|+=
name|strlen
argument_list|(
operator|*
name|av
operator|++
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|sm_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  TO8BIT -- convert \octal sequences in a test mode input line ** **	Parameters: **		str -- the input line. ** **	Returns: **		none. ** **	Side Effects: **		replaces \0octal in str with octal value. */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|to8bit
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bool
name|to8bit
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|,
modifier|*
name|in
decl_stmt|;
name|bool
name|changed
decl_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|in
operator|=
name|out
operator|=
name|str
expr_stmt|;
name|changed
operator|=
name|false
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
name|str
operator|++
operator|&
literal|0377
operator|)
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|oct
decl_stmt|,
name|nxtc
decl_stmt|;
operator|++
name|len
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
operator|(
name|nxtc
operator|=
operator|(
operator|*
name|str
operator|&
literal|0377
operator|)
operator|)
operator|==
literal|'0'
condition|)
block|{
name|oct
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|nxtc
operator|=
operator|(
operator|*
name|str
operator|&
literal|0377
operator|)
operator|)
operator|!=
literal|'\0'
operator|&&
name|isascii
argument_list|(
name|nxtc
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|nxtc
argument_list|)
condition|)
block|{
name|oct
operator|<<=
literal|3
expr_stmt|;
name|oct
operator|+=
name|nxtc
operator|-
literal|'0'
expr_stmt|;
operator|++
name|str
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|changed
operator|=
name|true
expr_stmt|;
name|c
operator|=
name|oct
expr_stmt|;
block|}
operator|*
name|out
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|out
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|quote_internal_chars
argument_list|(
name|in
argument_list|,
name|in
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|in
condition|)
name|sm_strlcpy
argument_list|(
name|in
argument_list|,
name|q
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* **  TESTMODELINE -- process a test mode input line ** **	Parameters: **		line -- the input line. **		e -- the current environment. **	Syntax: **		#  a comment **		.X process X as a configuration line **		=X dump a configuration item (such as mailers) **		$X dump a macro or class **		/X try an activity **		X  normal process through rule set X */
end_comment

begin_function
specifier|static
name|void
name|testmodeline
parameter_list|(
name|line
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
specifier|auto
name|char
modifier|*
name|delimptr
decl_stmt|;
name|int
name|mid
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rs
decl_stmt|;
name|STAB
modifier|*
name|map
decl_stmt|;
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
name|struct
name|rewrite
modifier|*
name|rw
decl_stmt|;
name|ADDRESS
name|a
decl_stmt|;
name|char
modifier|*
name|lbp
decl_stmt|;
specifier|auto
name|int
name|lbs
decl_stmt|;
specifier|static
name|int
name|tryflags
init|=
name|RF_COPYNONE
decl_stmt|;
name|char
name|exbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|char
name|lbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
specifier|extern
name|unsigned
name|char
name|TokTypeNoC
index|[]
decl_stmt|;
name|bool
name|eightbit
decl_stmt|;
comment|/* skip leading spaces */
while|while
condition|(
operator|*
name|line
operator|==
literal|' '
condition|)
name|line
operator|++
expr_stmt|;
name|lbp
operator|=
name|NULL
expr_stmt|;
name|eightbit
operator|=
name|false
expr_stmt|;
switch|switch
condition|(
name|line
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'#'
case|:
case|case
literal|'\0'
case|:
return|return;
case|case
literal|'?'
case|:
name|help
argument_list|(
literal|"-bt"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'.'
case|:
comment|/* config-style settings */
switch|switch
condition|(
name|line
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'D'
case|:
name|mid
operator|=
name|macid_parse
argument_list|(
operator|&
name|line
index|[
literal|2
index|]
argument_list|,
operator|&
name|delimptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|==
literal|0
condition|)
return|return;
name|lbs
operator|=
sizeof|sizeof
argument_list|(
name|lbuf
argument_list|)
expr_stmt|;
name|lbp
operator|=
name|translate_dollars
argument_list|(
name|delimptr
argument_list|,
name|lbuf
argument_list|,
operator|&
name|lbs
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|mid
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbp
operator|!=
name|lbuf
condition|)
name|SM_FREE
argument_list|(
name|lbp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
name|line
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
comment|/* not to call syserr() */
return|return;
name|mid
operator|=
name|macid_parse
argument_list|(
operator|&
name|line
index|[
literal|2
index|]
argument_list|,
operator|&
name|delimptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|==
literal|0
condition|)
return|return;
name|lbs
operator|=
sizeof|sizeof
argument_list|(
name|lbuf
argument_list|)
expr_stmt|;
name|lbp
operator|=
name|translate_dollars
argument_list|(
name|delimptr
argument_list|,
name|lbuf
argument_list|,
operator|&
name|lbs
argument_list|)
expr_stmt|;
name|expand
argument_list|(
name|lbp
argument_list|,
name|exbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|exbuf
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbp
operator|!=
name|lbuf
condition|)
name|SM_FREE
argument_list|(
name|lbp
argument_list|)
expr_stmt|;
name|p
operator|=
name|exbuf
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
specifier|register
name|char
modifier|*
name|wd
decl_stmt|;
name|char
name|delim
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
name|wd
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|)
name|p
operator|++
expr_stmt|;
name|delim
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|wd
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|setclass
argument_list|(
name|mid
argument_list|,
name|wd
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|delim
expr_stmt|;
block|}
break|break;
case|case
literal|'\0'
case|:
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Usage: .[DC]macro value(s)\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Unknown \".\" command %s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
case|case
literal|'='
case|:
comment|/* config-style settings */
switch|switch
condition|(
name|line
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'S'
case|:
comment|/* dump rule set */
name|rs
operator|=
name|strtorwset
argument_list|(
operator|&
name|line
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Undefined ruleset %s\n"
argument_list|,
operator|&
name|line
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|rw
operator|=
name|RewriteRules
index|[
name|rs
index|]
expr_stmt|;
if|if
condition|(
name|rw
operator|==
name|NULL
condition|)
return|return;
do|do
block|{
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|'R'
argument_list|)
expr_stmt|;
name|s
operator|=
name|rw
operator|->
name|r_lhs
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
name|NULL
condition|)
block|{
name|xputs
argument_list|(
name|smioout
argument_list|,
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
name|s
operator|=
name|rw
operator|->
name|r_rhs
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
name|NULL
condition|)
block|{
name|xputs
argument_list|(
name|smioout
argument_list|,
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|rw
operator|=
name|rw
operator|->
name|r_next
operator|)
operator|!=
name|NULL
condition|)
do|;
break|break;
case|case
literal|'M'
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXMAILERS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Mailer
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|printmailer
argument_list|(
name|smioout
argument_list|,
name|Mailer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'\0'
case|:
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Usage: =Sruleset or =M\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Unknown \"=\" command %s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
case|case
literal|'-'
case|:
comment|/* set command-line-like opts */
switch|switch
condition|(
name|line
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'d'
case|:
name|tTflag
argument_list|(
operator|&
name|line
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Usage: -d{debug arguments}\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Unknown \"-\" command %s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
case|case
literal|'$'
case|:
if|if
condition|(
name|line
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
block|{
name|mid
operator|=
name|macid
argument_list|(
operator|&
name|line
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|!=
literal|0
condition|)
name|stabapply
argument_list|(
name|dump_class
argument_list|,
name|mid
argument_list|)
expr_stmt|;
return|return;
block|}
name|mid
operator|=
name|macid
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|==
literal|0
condition|)
return|return;
name|p
operator|=
name|macvalue
argument_list|(
name|mid
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Undefined\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|xputs
argument_list|(
name|smioout
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'/'
case|:
comment|/* miscellaneous commands */
name|p
operator|=
operator|&
name|line
index|[
name|strlen
argument_list|(
name|line
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
operator|--
name|p
operator|>=
name|line
operator|&&
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|strpbrk
argument_list|(
name|line
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|p
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Usage: /[canon|map|mx|parse|try|tryflags]\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sm_strcasecmp
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|,
literal|"quit"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|CurEnv
operator|->
name|e_id
operator|=
name|NULL
expr_stmt|;
name|finis
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|sm_strcasecmp
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|,
literal|"mx"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|NAMED_BIND
comment|/* look up MX records */
name|int
name|nmx
decl_stmt|;
specifier|auto
name|int
name|rcode
decl_stmt|;
name|char
modifier|*
name|mxhosts
index|[
name|MAXMXHOSTS
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Usage: /mx address\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|nmx
operator|=
name|getmxrr
argument_list|(
name|p
argument_list|,
name|mxhosts
argument_list|,
name|NULL
argument_list|,
name|false
argument_list|,
operator|&
name|rcode
argument_list|,
name|true
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"getmxrr(%s) returns %d value(s):\n"
argument_list|,
name|p
argument_list|,
name|nmx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmx
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\t%s\n"
argument_list|,
name|mxhosts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* NAMED_BIND */
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"No MX code compiled in\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NAMED_BIND */
block|}
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|,
literal|"canon"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|host
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Usage: /canon address\n"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|sm_strlcpy
argument_list|(
name|host
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|host
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|host
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Name too long\n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|getcanonname
argument_list|(
name|host
argument_list|,
sizeof|sizeof
argument_list|(
name|host
argument_list|)
argument_list|,
operator|!
name|HasWildcardMX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"getcanonname(%s) returns %s\n"
argument_list|,
name|p
argument_list|,
name|host
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|,
literal|"map"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|auto
name|int
name|rcode
init|=
name|EX_OK
decl_stmt|;
name|char
modifier|*
name|av
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Usage: /map mapname key\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
operator|!=
literal|'\0'
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|q
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|q
argument_list|)
operator|)
condition|;
name|q
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"No key specified\n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|map
operator|=
name|stab
argument_list|(
name|p
argument_list|,
name|ST_MAP
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Map named \"%s\" not found\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|MF_OPEN
argument_list|,
name|map
operator|->
name|s_map
operator|.
name|map_mflags
argument_list|)
operator|&&
operator|!
name|openmap
argument_list|(
operator|&
operator|(
name|map
operator|->
name|s_map
operator|)
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Map named \"%s\" not open\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"map_lookup: %s (%s) "
argument_list|,
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|av
index|[
literal|0
index|]
operator|=
name|q
expr_stmt|;
name|av
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
call|(
modifier|*
name|map
operator|->
name|s_map
operator|.
name|map_class
operator|->
name|map_lookup
call|)
argument_list|(
operator|&
name|map
operator|->
name|s_map
argument_list|,
name|q
argument_list|,
name|av
argument_list|,
operator|&
name|rcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"no match (%d)\n"
argument_list|,
name|rcode
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"returns %s (%d)\n"
argument_list|,
name|p
argument_list|,
name|rcode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|,
literal|"try"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|MAILER
modifier|*
name|m
decl_stmt|;
name|STAB
modifier|*
name|st
decl_stmt|;
specifier|auto
name|int
name|rcode
init|=
name|EX_OK
decl_stmt|;
name|q
operator|=
name|strpbrk
argument_list|(
name|p
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|q
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|q
argument_list|)
condition|)
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|==
name|NULL
operator|||
operator|*
name|q
operator|==
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Usage: /try mailer address\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|st
operator|=
name|stab
argument_list|(
name|p
argument_list|,
name|ST_MAILER
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Unknown mailer %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|m
operator|=
name|st
operator|->
name|s_mailer
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Trying %s %s address %s for mailer %s\n"
argument_list|,
name|bitset
argument_list|(
name|RF_HEADERADDR
argument_list|,
name|tryflags
argument_list|)
condition|?
literal|"header"
else|:
literal|"envelope"
argument_list|,
name|bitset
argument_list|(
name|RF_SENDERADDR
argument_list|,
name|tryflags
argument_list|)
condition|?
literal|"sender"
else|:
literal|"recipient"
argument_list|,
name|q
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|remotename
argument_list|(
name|q
argument_list|,
name|m
argument_list|,
name|tryflags
argument_list|,
operator|&
name|rcode
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Rcode = %d, addr = %s\n"
argument_list|,
name|rcode
argument_list|,
name|p
operator|==
name|NULL
condition|?
literal|"<NULL>"
else|:
name|p
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|,
literal|"tryflags"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Usage: /tryflags [Hh|Ee][Ss|Rr]\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'H'
case|:
case|case
literal|'h'
case|:
name|tryflags
operator||=
name|RF_HEADERADDR
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
name|tryflags
operator|&=
operator|~
name|RF_HEADERADDR
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
name|tryflags
operator||=
name|RF_SENDERADDR
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
case|case
literal|'r'
case|:
name|tryflags
operator|&=
operator|~
name|RF_SENDERADDR
expr_stmt|;
break|break;
block|}
block|}
name|exbuf
index|[
literal|0
index|]
operator|=
name|bitset
argument_list|(
name|RF_HEADERADDR
argument_list|,
name|tryflags
argument_list|)
condition|?
literal|'h'
else|:
literal|'e'
expr_stmt|;
name|exbuf
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|exbuf
index|[
literal|2
index|]
operator|=
name|bitset
argument_list|(
name|RF_SENDERADDR
argument_list|,
name|tryflags
argument_list|)
condition|?
literal|'s'
else|:
literal|'r'
expr_stmt|;
name|exbuf
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{addr_type}"
argument_list|)
argument_list|,
name|exbuf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|,
literal|"parse"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Usage: /parse address\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|q
operator|=
name|crackaddr
argument_list|(
name|p
argument_list|,
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Cracked address = "
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|smioout
argument_list|,
name|q
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\nParsing %s %s address\n"
argument_list|,
name|bitset
argument_list|(
name|RF_HEADERADDR
argument_list|,
name|tryflags
argument_list|)
condition|?
literal|"header"
else|:
literal|"envelope"
argument_list|,
name|bitset
argument_list|(
name|RF_SENDERADDR
argument_list|,
name|tryflags
argument_list|)
condition|?
literal|"sender"
else|:
literal|"recipient"
argument_list|)
expr_stmt|;
if|if
condition|(
name|parseaddr
argument_list|(
name|p
argument_list|,
operator|&
name|a
argument_list|,
name|tryflags
argument_list|,
literal|'\0'
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
name|true
argument_list|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Cannot parse\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|.
name|q_host
operator|!=
name|NULL
operator|&&
name|a
operator|.
name|q_host
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"mailer %s, host %s, user %s\n"
argument_list|,
name|a
operator|.
name|q_mailer
operator|->
name|m_name
argument_list|,
name|a
operator|.
name|q_host
argument_list|,
name|a
operator|.
name|q_user
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"mailer %s, user %s\n"
argument_list|,
name|a
operator|.
name|q_mailer
operator|->
name|m_name
argument_list|,
name|a
operator|.
name|q_user
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|,
literal|"header"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|long
name|ul
decl_stmt|;
name|ul
operator|=
name|chompheader
argument_list|(
name|p
argument_list|,
name|CHHDR_CHECK
operator||
name|CHHDR_USER
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"ul = %lu\n"
argument_list|,
name|ul
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Unknown \"/\" command %s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_io_flush
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|p
operator|=
name|line
init|;
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"No address!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|23
argument_list|,
literal|101
argument_list|)
condition|)
name|eightbit
operator|=
name|to8bit
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|invalidaddr
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|)
condition|)
return|return;
do|do
block|{
specifier|register
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
name|char
name|pvpbuf
index|[
name|PSBUFSIZE
index|]
decl_stmt|;
name|pvp
operator|=
name|prescan
argument_list|(
operator|++
name|p
argument_list|,
literal|','
argument_list|,
name|pvpbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pvpbuf
argument_list|)
argument_list|,
operator|&
name|delimptr
argument_list|,
name|ConfigLevel
operator|>=
literal|9
condition|?
name|TokTypeNoC
else|:
name|ExtTokenTab
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
continue|continue;
name|p
operator|=
name|q
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|status
decl_stmt|;
name|rs
operator|=
name|strtorwset
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Undefined ruleset %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
name|status
operator|=
name|REWRITE
argument_list|(
name|pvp
argument_list|,
name|rs
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|EX_OK
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"== Ruleset %s (%d) status %d\n"
argument_list|,
name|p
argument_list|,
name|rs
argument_list|,
name|status
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|eightbit
condition|)
block|{
name|cataddr
argument_list|(
name|pvp
argument_list|,
name|NULL
argument_list|,
name|exbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|exbuf
argument_list|)
argument_list|,
literal|'\0'
argument_list|,
name|true
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"cataddr: %s\n"
argument_list|,
name|str2prt
argument_list|(
name|exbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|++
operator|!=
literal|','
condition|)
continue|continue;
block|}
block|}
do|while
condition|(
operator|*
operator|(
name|p
operator|=
name|delimptr
operator|)
operator|!=
literal|'\0'
condition|)
do|;
operator|(
name|void
operator|)
name|sm_io_flush
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_class
parameter_list|(
name|s
parameter_list|,
name|id
parameter_list|)
specifier|register
name|STAB
modifier|*
name|s
decl_stmt|;
name|int
name|id
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|->
name|s_symtype
operator|!=
name|ST_CLASS
condition|)
return|return;
if|if
condition|(
name|bitnset
argument_list|(
name|bitidx
argument_list|(
name|id
argument_list|)
argument_list|,
name|s
operator|->
name|s_class
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s\n"
argument_list|,
name|s
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  An exception type used to create QuickAbort exceptions. **  This is my first cut at converting QuickAbort from longjmp to exceptions. **  These exceptions have a single integer argument, which is the argument **  to longjmp in the original code (either 1 or 2).  I don't know the **  significance of 1 vs 2: the calls to setjmp don't care. */
end_comment

begin_decl_stmt
specifier|const
name|SM_EXC_TYPE_T
name|EtypeQuickAbort
init|=
block|{
name|SmExcTypeMagic
block|,
literal|"E:mta.quickabort"
block|,
literal|"i"
block|,
name|sm_etype_printf
block|,
literal|"quick abort %0"
block|, }
decl_stmt|;
end_decl_stmt

end_unit

