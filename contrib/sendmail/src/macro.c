begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998-2001, 2003, 2006 Sendmail, Inc. and its suppliers.  *	All rights reserved.  * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_include
include|#
directive|include
file|<sendmail.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: macro.c,v 8.102 2006/12/21 23:06:10 ca Exp $"
argument_list|)
end_macro

begin_include
include|#
directive|include
file|<sm/sendmail.h>
end_include

begin_if
if|#
directive|if
name|MAXMACROID
operator|!=
operator|(
name|BITMAPBITS
operator|-
literal|1
operator|)
end_if

begin_decl_stmt
name|ERROR
name|Read
name|the
name|comment
name|in
name|conf
operator|.
name|h
endif|#
directive|endif
comment|/* MAXMACROID != (BITMAPBITS - 1) */
specifier|static
name|char
modifier|*
name|MacroName
index|[
name|MAXMACROID
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* macro id to name table */
end_comment

begin_decl_stmt
name|int
name|NextMacroId
init|=
literal|0240
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* codes for long named macros */
end_comment

begin_comment
comment|/* see sendmail.h: Special characters in rewriting rules. */
end_comment

begin_comment
comment|/* **  INITMACROS -- initialize the macro system ** **	This just involves defining some macros that are actually **	used internally as metasymbols to be themselves. ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		initializes several macros to be themselves. */
end_comment

begin_decl_stmt
name|struct
name|metamac
name|MetaMacros
index|[]
init|=
block|{
comment|/* LHS pattern matching characters */
block|{
literal|'*'
block|,
name|MATCHZANY
block|}
block|,
block|{
literal|'+'
block|,
name|MATCHANY
block|}
block|,
block|{
literal|'-'
block|,
name|MATCHONE
block|}
block|,
block|{
literal|'='
block|,
name|MATCHCLASS
block|}
block|,
block|{
literal|'~'
block|,
name|MATCHNCLASS
block|}
block|,
comment|/* these are RHS metasymbols */
block|{
literal|'#'
block|,
name|CANONNET
block|}
block|,
block|{
literal|'@'
block|,
name|CANONHOST
block|}
block|,
block|{
literal|':'
block|,
name|CANONUSER
block|}
block|,
block|{
literal|'>'
block|,
name|CALLSUBR
block|}
block|,
comment|/* the conditional operations */
block|{
literal|'?'
block|,
name|CONDIF
block|}
block|,
block|{
literal|'|'
block|,
name|CONDELSE
block|}
block|,
block|{
literal|'.'
block|,
name|CONDFI
block|}
block|,
comment|/* the hostname lookup characters */
block|{
literal|'['
block|,
name|HOSTBEGIN
block|}
block|,
block|{
literal|']'
block|,
name|HOSTEND
block|}
block|,
block|{
literal|'('
block|,
name|LOOKUPBEGIN
block|}
block|,
block|{
literal|')'
block|,
name|LOOKUPEND
block|}
block|,
comment|/* miscellaneous control characters */
block|{
literal|'&'
block|,
name|MACRODEXPAND
block|}
block|,
block|{
literal|'\0'
block|,
literal|'\0'
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MACBINDING
parameter_list|(
name|name
parameter_list|,
name|mid
parameter_list|)
define|\
value|stab(name, ST_MACRO, ST_ENTER)->s_macro = mid; \ 		MacroName[mid] = name;
end_define

begin_function
name|void
name|initmacros
parameter_list|(
name|e
parameter_list|)
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|struct
name|metamac
modifier|*
name|m
decl_stmt|;
name|int
name|c
decl_stmt|;
name|char
name|buf
index|[
literal|5
index|]
decl_stmt|;
for|for
control|(
name|m
operator|=
name|MetaMacros
init|;
name|m
operator|->
name|metaname
operator|!=
literal|'\0'
condition|;
name|m
operator|++
control|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|m
operator|->
name|metaval
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|m
operator|->
name|metaname
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
name|MATCHREPL
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|'0'
init|;
name|c
operator|<=
literal|'9'
condition|;
name|c
operator|++
control|)
block|{
name|buf
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|c
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* set defaults for some macros sendmail will use later */
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'n'
argument_list|,
literal|"MAILER-DAEMON"
argument_list|)
expr_stmt|;
comment|/* set up external names for some internal macros */
name|MACBINDING
argument_list|(
literal|"opMode"
argument_list|,
name|MID_OPMODE
argument_list|)
expr_stmt|;
comment|/*XXX should probably add equivalents for all short macros here XXX*/
block|}
end_function

begin_comment
comment|/* **  EXPAND/DOEXPAND -- macro expand a string using $x escapes. ** **	After expansion, the expansion will be in external form (that is, **	there will be no sendmail metacharacters and METAQUOTEs will have **	been stripped out). ** **	Parameters: **		s -- the string to expand. **		buf -- the place to put the expansion. **		bufsize -- the size of the buffer. **		explevel -- the depth of expansion (doexpand only) **		e -- envelope in which to work. ** **	Returns: **		none. ** **	Side Effects: **		none. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|doexpand
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|size_t
operator|,
name|int
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|doexpand
parameter_list|(
name|s
parameter_list|,
name|buf
parameter_list|,
name|bufsize
parameter_list|,
name|explevel
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|bufsize
decl_stmt|;
name|int
name|explevel
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|char
modifier|*
name|xp
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|bool
name|skipping
decl_stmt|;
comment|/* set if conditionally skipping output */
name|bool
name|recurse
decl_stmt|;
comment|/* set if recursion required */
name|size_t
name|i
decl_stmt|;
name|int
name|skiplev
decl_stmt|;
comment|/* skipping nesting level */
name|int
name|iflev
decl_stmt|;
comment|/* if nesting level */
name|bool
name|quotenext
decl_stmt|;
comment|/* quote the following character */
name|char
name|xbuf
index|[
name|MACBUFSIZE
index|]
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|35
argument_list|,
literal|24
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"expand("
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|recurse
operator|=
name|false
expr_stmt|;
name|skipping
operator|=
name|false
expr_stmt|;
name|skiplev
operator|=
literal|0
expr_stmt|;
name|iflev
operator|=
literal|0
expr_stmt|;
name|quotenext
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|s
operator|=
literal|""
expr_stmt|;
for|for
control|(
name|xp
operator|=
name|xbuf
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
block|{
name|int
name|c
decl_stmt|;
comment|/* 		**  Check for non-ordinary (special?) character. 		**	'q' will be the interpolated quantity. 		*/
name|q
operator|=
name|NULL
expr_stmt|;
name|c
operator|=
operator|*
name|s
operator|&
literal|0377
expr_stmt|;
if|if
condition|(
name|quotenext
condition|)
block|{
name|quotenext
operator|=
name|false
expr_stmt|;
goto|goto
name|simpleinterpolate
goto|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CONDIF
case|:
comment|/* see if var set */
name|iflev
operator|++
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|s
operator|&
literal|0377
expr_stmt|;
if|if
condition|(
name|skipping
condition|)
name|skiplev
operator|++
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|mv
decl_stmt|;
name|mv
operator|=
name|macvalue
argument_list|(
name|c
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|skipping
operator|=
operator|(
name|mv
operator|==
name|NULL
operator|||
operator|*
name|mv
operator|==
literal|'\0'
operator|)
expr_stmt|;
block|}
continue|continue;
case|case
name|CONDELSE
case|:
comment|/* change state of skipping */
if|if
condition|(
name|iflev
operator|==
literal|0
condition|)
break|break;
comment|/* XXX: error */
if|if
condition|(
name|skiplev
operator|==
literal|0
condition|)
name|skipping
operator|=
operator|!
name|skipping
expr_stmt|;
continue|continue;
case|case
name|CONDFI
case|:
comment|/* stop skipping */
if|if
condition|(
name|iflev
operator|==
literal|0
condition|)
break|break;
comment|/* XXX: error */
name|iflev
operator|--
expr_stmt|;
if|if
condition|(
name|skiplev
operator|==
literal|0
condition|)
name|skipping
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|skipping
condition|)
name|skiplev
operator|--
expr_stmt|;
continue|continue;
case|case
name|MACROEXPAND
case|:
comment|/* macro interpolation */
name|c
operator|=
name|bitidx
argument_list|(
operator|*
operator|++
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\0'
condition|)
name|q
operator|=
name|macvalue
argument_list|(
name|c
argument_list|,
name|e
argument_list|)
expr_stmt|;
else|else
block|{
name|s
operator|--
expr_stmt|;
name|q
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
continue|continue;
break|break;
case|case
name|METAQUOTE
case|:
comment|/* next octet completely quoted */
name|quotenext
operator|=
name|true
expr_stmt|;
break|break;
block|}
comment|/* 		**  Interpolate q or output one character 		*/
name|simpleinterpolate
label|:
if|if
condition|(
name|skipping
operator|||
name|xp
operator|>=
operator|&
name|xbuf
index|[
sizeof|sizeof
argument_list|(
name|xbuf
argument_list|)
operator|-
literal|1
index|]
condition|)
continue|continue;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
operator|*
name|xp
operator|++
operator|=
name|c
expr_stmt|;
else|else
block|{
comment|/* copy to end of q or max space remaining in buf */
name|bool
name|hiderecurse
init|=
name|false
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|q
operator|++
operator|)
operator|!=
literal|'\0'
operator|&&
name|xp
operator|<
operator|&
name|xbuf
index|[
sizeof|sizeof
argument_list|(
name|xbuf
argument_list|)
operator|-
literal|1
index|]
condition|)
block|{
comment|/* check for any sendmail metacharacters */
if|if
condition|(
operator|!
name|hiderecurse
operator|&&
operator|(
name|c
operator|&
literal|0340
operator|)
operator|==
literal|0200
condition|)
name|recurse
operator|=
name|true
expr_stmt|;
operator|*
name|xp
operator|++
operator|=
name|c
expr_stmt|;
comment|/* give quoted characters a free ride */
name|hiderecurse
operator|=
operator|(
name|c
operator|&
literal|0377
operator|)
operator|==
name|METAQUOTE
expr_stmt|;
block|}
block|}
block|}
operator|*
name|xp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|35
argument_list|,
literal|28
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"expand(%d) ==> "
argument_list|,
name|explevel
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|xbuf
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* recurse as appropriate */
if|if
condition|(
name|recurse
condition|)
block|{
if|if
condition|(
name|explevel
operator|<
name|MaxMacroRecursion
condition|)
block|{
name|doexpand
argument_list|(
name|xbuf
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|,
name|explevel
operator|+
literal|1
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
name|syserr
argument_list|(
literal|"expand: recursion too deep (%d max)"
argument_list|,
name|MaxMacroRecursion
argument_list|)
expr_stmt|;
block|}
comment|/* copy results out */
if|if
condition|(
name|explevel
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|buf
argument_list|,
name|xbuf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* leave in internal form */
name|i
operator|=
name|xp
operator|-
name|xbuf
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|bufsize
condition|)
name|i
operator|=
name|bufsize
operator|-
literal|1
expr_stmt|;
name|memmove
argument_list|(
name|buf
argument_list|,
name|xbuf
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|35
argument_list|,
literal|24
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"expand ==> "
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|expand
parameter_list|(
name|s
parameter_list|,
name|buf
parameter_list|,
name|bufsize
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|bufsize
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|doexpand
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  MACDEFINE -- bind a macro name to a value ** **	Set a macro to a value, with fancy storage management. **	macdefine will make a copy of the value, if required, **	and will ensure that the storage for the previous value **	is not leaked. ** **	Parameters: **		mac -- Macro table. **		vclass -- storage class of 'value', ignored if value==NULL. **			A_HEAP	means that the value was allocated by **				malloc, and that macdefine owns the storage. **			A_TEMP	means that value points to temporary storage, **				and thus macdefine needs to make a copy. **			A_PERM	means that value points to storage that **				will remain allocated and unchanged for **				at least the lifetime of mac.  Use A_PERM if: **				-- value == NULL, **				-- value points to a string literal, **				-- value was allocated from mac->mac_rpool **				   or (in the case of an envelope macro) **				   from e->e_rpool, **				-- in the case of an envelope macro, **				   value is a string member of the envelope **				   such as e->e_sender. **		id -- Macro id.  This is a single character macro name **			such as 'g', or a value returned by macid(). **		value -- Macro value: either NULL, or a string. */
end_comment

begin_function
name|void
if|#
directive|if
name|SM_HEAP_CHECK
name|macdefine_tagged
parameter_list|(
name|mac
parameter_list|,
name|vclass
parameter_list|,
name|id
parameter_list|,
name|value
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|,
name|grp
parameter_list|)
else|#
directive|else
comment|/* SM_HEAP_CHECK */
function|macdefine
parameter_list|(
name|mac
parameter_list|,
name|vclass
parameter_list|,
name|id
parameter_list|,
name|value
parameter_list|)
endif|#
directive|endif
comment|/* SM_HEAP_CHECK */
name|MACROS_T
modifier|*
name|mac
decl_stmt|;
name|ARGCLASS_T
name|vclass
decl_stmt|;
name|int
name|id
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
if|#
directive|if
name|SM_HEAP_CHECK
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
name|int
name|grp
decl_stmt|;
endif|#
directive|endif
comment|/* SM_HEAP_CHECK */
block|{
name|char
modifier|*
name|newvalue
decl_stmt|;
if|if
condition|(
name|id
operator|<
literal|0
operator|||
name|id
operator|>
name|MAXMACROID
condition|)
return|return;
if|if
condition|(
name|tTd
argument_list|(
literal|35
argument_list|,
literal|9
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"%sdefine(%s as "
argument_list|,
name|mac
operator|->
name|mac_table
index|[
name|id
index|]
operator|==
name|NULL
condition|?
literal|""
else|:
literal|"re"
argument_list|,
name|macname
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mac
operator|->
name|mac_rpool
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|freeit
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|mac
operator|->
name|mac_table
index|[
name|id
index|]
operator|!=
name|NULL
operator|&&
name|bitnset
argument_list|(
name|id
argument_list|,
name|mac
operator|->
name|mac_allocated
argument_list|)
condition|)
name|freeit
operator|=
name|mac
operator|->
name|mac_table
index|[
name|id
index|]
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
operator|||
name|vclass
operator|==
name|A_HEAP
condition|)
block|{
name|sm_heap_checkptr_tagged
argument_list|(
name|value
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|newvalue
operator|=
name|value
expr_stmt|;
name|clrbitn
argument_list|(
name|id
argument_list|,
name|mac
operator|->
name|mac_allocated
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|SM_HEAP_CHECK
name|newvalue
operator|=
name|sm_strdup_tagged_x
argument_list|(
name|value
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SM_HEAP_CHECK */
name|newvalue
operator|=
name|sm_strdup_x
argument_list|(
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SM_HEAP_CHECK */
name|setbitn
argument_list|(
name|id
argument_list|,
name|mac
operator|->
name|mac_allocated
argument_list|)
expr_stmt|;
block|}
name|mac
operator|->
name|mac_table
index|[
name|id
index|]
operator|=
name|newvalue
expr_stmt|;
if|if
condition|(
name|freeit
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|freeit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|value
operator|==
name|NULL
operator|||
name|vclass
operator|==
name|A_PERM
condition|)
name|newvalue
operator|=
name|value
expr_stmt|;
else|else
name|newvalue
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|mac
operator|->
name|mac_rpool
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|mac
operator|->
name|mac_table
index|[
name|id
index|]
operator|=
name|newvalue
expr_stmt|;
if|if
condition|(
name|vclass
operator|==
name|A_HEAP
condition|)
name|sm_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|_FFR_RESET_MACRO_GLOBALS
switch|switch
condition|(
name|id
condition|)
block|{
case|case
literal|'j'
case|:
name|PSTRSET
argument_list|(
name|MyHostName
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* _FFR_RESET_MACRO_GLOBALS */
block|}
end_function

begin_comment
comment|/* **  MACSET -- set a named macro to a value (low level) ** **	No fancy storage management; the caller takes full responsibility. **	Often used with macget; see also macdefine. ** **	Parameters: **		mac -- Macro table. **		i -- Macro name, specified as an integer offset. **		value -- Macro value: either NULL, or a string. */
end_comment

begin_function
name|void
name|macset
parameter_list|(
name|mac
parameter_list|,
name|i
parameter_list|,
name|value
parameter_list|)
name|MACROS_T
modifier|*
name|mac
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|{
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|MAXMACROID
condition|)
return|return;
if|if
condition|(
name|tTd
argument_list|(
literal|35
argument_list|,
literal|9
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"macset(%s as "
argument_list|,
name|macname
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|mac
operator|->
name|mac_table
index|[
name|i
index|]
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  MACVALUE -- return uninterpreted value of a macro. ** **	Does fancy path searching. **	The low level counterpart is macget. ** **	Parameters: **		n -- the name of the macro. **		e -- envelope in which to start looking for the macro. ** **	Returns: **		The value of n. ** **	Side Effects: **		none. */
end_comment

begin_function
name|char
modifier|*
name|macvalue
parameter_list|(
name|n
parameter_list|,
name|e
parameter_list|)
name|int
name|n
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|n
operator|=
name|bitidx
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|!=
name|NULL
operator|&&
name|e
operator|->
name|e_mci
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|e
operator|->
name|e_mci
operator|->
name|mci_macro
operator|.
name|mac_table
index|[
name|n
index|]
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
return|return
name|p
return|;
block|}
while|while
condition|(
name|e
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|e
operator|->
name|e_macro
operator|.
name|mac_table
index|[
name|n
index|]
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
return|return
name|p
return|;
if|if
condition|(
name|e
operator|==
name|e
operator|->
name|e_parent
condition|)
break|break;
name|e
operator|=
name|e
operator|->
name|e_parent
expr_stmt|;
block|}
return|return
name|GlobalMacros
operator|.
name|mac_table
index|[
name|n
index|]
return|;
block|}
end_function

begin_comment
comment|/* **  MACNAME -- return the name of a macro given its internal id ** **	Parameter: **		n -- the id of the macro ** **	Returns: **		The name of n. ** **	Side Effects: **		none. ** **	WARNING: **		Not thread-safe. */
end_comment

begin_function
name|char
modifier|*
name|macname
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
specifier|static
name|char
name|mbuf
index|[
literal|2
index|]
decl_stmt|;
name|n
operator|=
operator|(
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|MAXMACROID
condition|)
return|return
literal|"***OUT OF RANGE MACRO***"
return|;
comment|/* if not ASCII printable, look up the name */
if|if
condition|(
name|n
operator|<=
literal|0x20
operator|||
name|n
operator|>
literal|0x7f
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|MacroName
index|[
name|n
index|]
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
return|return
name|p
return|;
return|return
literal|"***UNDEFINED MACRO***"
return|;
block|}
comment|/* if in the ASCII graphic range, just return the id directly */
name|mbuf
index|[
literal|0
index|]
operator|=
name|n
expr_stmt|;
name|mbuf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|mbuf
return|;
block|}
end_function

begin_comment
comment|/* **  MACID_PARSE -- return id of macro identified by its name ** **	Parameters: **		p -- pointer to name string -- either a single **			character or {name}. **		ep -- filled in with the pointer to the byte **			after the name. ** **	Returns: **		0 -- An error was detected. **		1..MAXMACROID -- The internal id code for this macro. ** **	Side Effects: **		If this is a new macro name, a new id is allocated. **		On error, syserr is called. */
end_comment

begin_function
name|int
name|macid_parse
parameter_list|(
name|p
parameter_list|,
name|ep
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
modifier|*
name|ep
decl_stmt|;
block|{
name|int
name|mid
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
name|char
name|mbuf
index|[
name|MAXMACNAMELEN
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|35
argument_list|,
literal|14
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"macid("
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|") => "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|||
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'{'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'}'
operator|)
condition|)
block|{
name|syserr
argument_list|(
literal|"Name required for macro/class"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
operator|*
name|ep
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|35
argument_list|,
literal|14
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"NULL\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|'{'
condition|)
block|{
comment|/* the macro is its own code */
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
operator|*
name|ep
operator|=
name|p
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|35
argument_list|,
literal|14
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
operator|*
name|p
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|xputs
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|bitidx
argument_list|(
operator|*
name|p
argument_list|)
return|;
block|}
name|bp
operator|=
name|mbuf
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|'}'
operator|&&
name|bp
operator|<
operator|&
name|mbuf
index|[
sizeof|sizeof
argument_list|(
name|mbuf
argument_list|)
operator|-
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
operator|)
condition|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|p
expr_stmt|;
else|else
name|syserr
argument_list|(
literal|"Invalid macro/class character %c"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|mid
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|syserr
argument_list|(
literal|"Unbalanced { on %s"
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
comment|/* missing } */
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|!=
literal|'}'
condition|)
block|{
name|syserr
argument_list|(
literal|"Macro/class name ({%s}) too long (%d chars max)"
argument_list|,
name|mbuf
argument_list|,
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|mbuf
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mbuf
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* ${x} == $x */
name|mid
operator|=
name|bitidx
argument_list|(
name|mbuf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
name|STAB
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|stab
argument_list|(
name|mbuf
argument_list|,
name|ST_MACRO
argument_list|,
name|ST_ENTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s_macro
operator|!=
literal|0
condition|)
name|mid
operator|=
name|s
operator|->
name|s_macro
expr_stmt|;
else|else
block|{
if|if
condition|(
name|NextMacroId
operator|>
name|MAXMACROID
condition|)
block|{
name|syserr
argument_list|(
literal|"Macro/class {%s}: too many long names"
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
name|s
operator|->
name|s_macro
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|MacroName
index|[
name|NextMacroId
index|]
operator|=
name|s
operator|->
name|s_name
expr_stmt|;
name|s
operator|->
name|s_macro
operator|=
name|mid
operator|=
name|NextMacroId
operator|++
expr_stmt|;
block|}
block|}
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
operator|*
name|ep
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|mid
operator|<
literal|0
operator|||
name|mid
operator|>
name|MAXMACROID
condition|)
block|{
name|syserr
argument_list|(
literal|"Unable to assign macro/class ID (mid = 0x%x)"
argument_list|,
name|mid
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|35
argument_list|,
literal|14
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"NULL\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|35
argument_list|,
literal|14
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"0x%x\n"
argument_list|,
name|mid
argument_list|)
expr_stmt|;
return|return
name|mid
return|;
block|}
end_function

begin_comment
comment|/* **  WORDINCLASS -- tell if a word is in a specific class ** **	Parameters: **		str -- the name of the word to look up. **		cl -- the class name. ** **	Returns: **		true if str can be found in cl. **		false otherwise. */
end_comment

begin_function
name|bool
name|wordinclass
parameter_list|(
name|str
parameter_list|,
name|cl
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|cl
decl_stmt|;
block|{
name|STAB
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|stab
argument_list|(
name|str
argument_list|,
name|ST_CLASS
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
return|return
name|s
operator|!=
name|NULL
operator|&&
name|bitnset
argument_list|(
name|bitidx
argument_list|(
name|cl
argument_list|)
argument_list|,
name|s
operator|->
name|s_class
argument_list|)
return|;
block|}
end_function

end_unit

