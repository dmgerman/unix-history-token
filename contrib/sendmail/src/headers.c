begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998-2004, 2006, 2007 Sendmail, Inc. and its suppliers.  *	All rights reserved.  * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_include
include|#
directive|include
file|<sendmail.h>
end_include

begin_include
include|#
directive|include
file|<sm/sendmail.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: headers.c,v 8.310 2007/02/07 22:44:35 ca Exp $"
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|HDR
modifier|*
name|allocheader
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|SM_RPOOL_T
operator|*
operator|,
name|bool
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|fix_mime_header
name|__P
argument_list|(
operator|(
name|HDR
operator|*
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|priencode
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|put_vanilla_header
name|__P
argument_list|(
operator|(
name|HDR
operator|*
operator|,
name|char
operator|*
operator|,
name|MCI
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  SETUPHEADERS -- initialize headers in symbol table ** **	Parameters: **		none ** **	Returns: **		none */
end_comment

begin_function
name|void
name|setupheaders
parameter_list|()
block|{
name|struct
name|hdrinfo
modifier|*
name|hi
decl_stmt|;
name|STAB
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|HdrInfo
init|;
name|hi
operator|->
name|hi_field
operator|!=
name|NULL
condition|;
name|hi
operator|++
control|)
block|{
name|s
operator|=
name|stab
argument_list|(
name|hi
operator|->
name|hi_field
argument_list|,
name|ST_HEADER
argument_list|,
name|ST_ENTER
argument_list|)
expr_stmt|;
name|s
operator|->
name|s_header
operator|.
name|hi_flags
operator|=
name|hi
operator|->
name|hi_flags
expr_stmt|;
name|s
operator|->
name|s_header
operator|.
name|hi_ruleset
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  DOCHOMPHEADER -- process and save a header line. ** **	Called by chompheader. ** **	Parameters: **		line -- header as a text line. **		pflag -- flags for chompheader() (from sendmail.h) **		hdrp -- a pointer to the place to save the header. **		e -- the envelope including this header. ** **	Returns: **		flags for this header. ** **	Side Effects: **		The header is saved on the header list. **		Contents of 'line' are destroyed. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hdrinfo
name|NormalHeader
init|=
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|dochompheader
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|HDR
operator|*
operator|*
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|long
name|dochompheader
parameter_list|(
name|line
parameter_list|,
name|pflag
parameter_list|,
name|hdrp
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|pflag
decl_stmt|;
name|HDR
modifier|*
modifier|*
name|hdrp
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|unsigned
name|char
name|mid
init|=
literal|'\0'
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|HDR
modifier|*
name|h
decl_stmt|;
name|HDR
modifier|*
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
name|fvalue
decl_stmt|;
name|bool
name|cond
init|=
name|false
decl_stmt|;
name|bool
name|dropfrom
decl_stmt|;
name|bool
name|headeronly
decl_stmt|;
name|STAB
modifier|*
name|s
decl_stmt|;
name|struct
name|hdrinfo
modifier|*
name|hi
decl_stmt|;
name|bool
name|nullheader
init|=
name|false
decl_stmt|;
name|BITMAP256
name|mopts
decl_stmt|;
name|headeronly
operator|=
name|hdrp
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|headeronly
condition|)
name|hdrp
operator|=
operator|&
name|e
operator|->
name|e_header
expr_stmt|;
comment|/* strip off options */
name|clrbitmap
argument_list|(
name|mopts
argument_list|)
expr_stmt|;
name|p
operator|=
name|line
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|pflag
argument_list|,
name|CHHDR_USER
argument_list|)
operator|&&
operator|*
name|p
operator|==
literal|'?'
condition|)
block|{
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|strchr
argument_list|(
operator|++
name|p
argument_list|,
literal|'?'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
goto|goto
name|hse
goto|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|&
literal|0377
expr_stmt|;
comment|/* possibly macro conditional */
if|if
condition|(
name|c
operator|==
name|MACROEXPAND
condition|)
block|{
comment|/* catch ?$? */
if|if
condition|(
operator|*
operator|++
name|p
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|q
operator|=
literal|'?'
expr_stmt|;
goto|goto
name|hse
goto|;
block|}
name|mid
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
operator|++
expr_stmt|;
comment|/* catch ?$abc? */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
operator|*
name|q
operator|=
literal|'?'
expr_stmt|;
goto|goto
name|hse
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
comment|/* catch ?$? */
if|if
condition|(
operator|*
operator|++
name|p
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|q
operator|=
literal|'?'
expr_stmt|;
goto|goto
name|hse
goto|;
block|}
name|mid
operator|=
operator|(
name|unsigned
name|char
operator|)
name|macid
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
literal|0200
argument_list|,
name|mid
argument_list|)
condition|)
block|{
name|p
operator|+=
name|strlen
argument_list|(
name|macname
argument_list|(
name|mid
argument_list|)
argument_list|)
operator|+
literal|2
expr_stmt|;
name|SM_ASSERT
argument_list|(
name|p
operator|<=
name|q
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|++
expr_stmt|;
comment|/* catch ?$abc? */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
operator|*
name|q
operator|=
literal|'?'
expr_stmt|;
goto|goto
name|hse
goto|;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
operator|*
name|q
operator|=
literal|'?'
expr_stmt|;
goto|goto
name|hse
goto|;
block|}
name|setbitn
argument_list|(
name|bitidx
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|mopts
argument_list|)
expr_stmt|;
name|cond
operator|=
name|true
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
name|p
operator|=
name|q
operator|+
literal|1
expr_stmt|;
block|}
comment|/* find canonical name */
name|fname
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isgraph
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
name|fvalue
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|':'
operator|||
name|fname
operator|==
name|fvalue
condition|)
block|{
name|hse
label|:
name|syserr
argument_list|(
literal|"553 5.3.0 header syntax error, line \"%s\""
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|fvalue
operator|=
literal|'\0'
expr_stmt|;
name|fvalue
operator|=
name|p
expr_stmt|;
comment|/* if the field is null, go ahead and use the default */
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|nullheader
operator|=
name|true
expr_stmt|;
comment|/* security scan: long field names are end-of-header */
if|if
condition|(
name|strlen
argument_list|(
name|fname
argument_list|)
operator|>
literal|100
condition|)
return|return
name|H_EOH
return|;
comment|/* check to see if it represents a ruleset call */
if|if
condition|(
name|bitset
argument_list|(
name|pflag
argument_list|,
name|CHHDR_DEF
argument_list|)
condition|)
block|{
name|char
name|hbuf
index|[
literal|50
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|expand
argument_list|(
name|fvalue
argument_list|,
name|hbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|hbuf
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|hbuf
init|;
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
control|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|p
operator|++
operator|&
literal|0377
operator|)
operator|==
name|CALLSUBR
condition|)
block|{
specifier|auto
name|char
modifier|*
name|endp
decl_stmt|;
name|bool
name|strc
decl_stmt|;
name|strc
operator|=
operator|*
name|p
operator|==
literal|'+'
expr_stmt|;
comment|/* strip comments? */
if|if
condition|(
name|strc
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|strtorwset
argument_list|(
name|p
argument_list|,
operator|&
name|endp
argument_list|,
name|ST_ENTER
argument_list|)
operator|>
literal|0
condition|)
block|{
operator|*
name|endp
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|stab
argument_list|(
name|fname
argument_list|,
name|ST_HEADER
argument_list|,
name|ST_ENTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
operator|&&
name|s
operator|->
name|s_header
operator|.
name|hi_ruleset
operator|!=
name|NULL
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"Warning: redefined ruleset for header=%s, old=%s, new=%s"
argument_list|,
name|fname
argument_list|,
name|s
operator|->
name|s_header
operator|.
name|hi_ruleset
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|s
operator|->
name|s_header
operator|.
name|hi_ruleset
operator|=
name|newstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strc
condition|)
name|s
operator|->
name|s_header
operator|.
name|hi_flags
operator||=
name|H_STRIPCOMM
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
block|}
comment|/* see if it is a known type */
name|s
operator|=
name|stab
argument_list|(
name|fname
argument_list|,
name|ST_HEADER
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|hi
operator|=
operator|&
name|s
operator|->
name|s_header
expr_stmt|;
else|else
name|hi
operator|=
operator|&
name|NormalHeader
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|31
argument_list|,
literal|9
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|sm_dprintf
argument_list|(
literal|"no header flags match\n"
argument_list|)
expr_stmt|;
else|else
name|sm_dprintf
argument_list|(
literal|"header match, flags=%lx, ruleset=%s\n"
argument_list|,
name|hi
operator|->
name|hi_flags
argument_list|,
name|hi
operator|->
name|hi_ruleset
operator|==
name|NULL
condition|?
literal|"<NULL>"
else|:
name|hi
operator|->
name|hi_ruleset
argument_list|)
expr_stmt|;
block|}
comment|/* see if this is a resent message */
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|pflag
argument_list|,
name|CHHDR_DEF
argument_list|)
operator|&&
operator|!
name|headeronly
operator|&&
name|bitset
argument_list|(
name|H_RESENT
argument_list|,
name|hi
operator|->
name|hi_flags
argument_list|)
condition|)
name|e
operator|->
name|e_flags
operator||=
name|EF_RESENT
expr_stmt|;
comment|/* if this is an Errors-To: header keep track of it now */
if|if
condition|(
name|UseErrorsTo
operator|&&
operator|!
name|bitset
argument_list|(
name|pflag
argument_list|,
name|CHHDR_DEF
argument_list|)
operator|&&
operator|!
name|headeronly
operator|&&
name|bitset
argument_list|(
name|H_ERRORSTO
argument_list|,
name|hi
operator|->
name|hi_flags
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sendtolist
argument_list|(
name|fvalue
argument_list|,
name|NULLADDR
argument_list|,
operator|&
name|e
operator|->
name|e_errorqueue
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* if this means "end of header" quit now */
if|if
condition|(
operator|!
name|headeronly
operator|&&
name|bitset
argument_list|(
name|H_EOH
argument_list|,
name|hi
operator|->
name|hi_flags
argument_list|)
condition|)
return|return
name|hi
operator|->
name|hi_flags
return|;
comment|/* 	**  Horrible hack to work around problem with Lotus Notes SMTP 	**  mail gateway, which generates From: headers with newlines in 	**  them and the<address> on the second line.  Although this is 	**  legal RFC 822, many MUAs don't handle this properly and thus 	**  never find the actual address. 	*/
if|if
condition|(
name|bitset
argument_list|(
name|H_FROM
argument_list|,
name|hi
operator|->
name|hi_flags
argument_list|)
operator|&&
name|SingleLineFromHeader
condition|)
block|{
while|while
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|fvalue
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
block|}
comment|/* 	**  If there is a check ruleset, verify it against the header. 	*/
if|if
condition|(
name|bitset
argument_list|(
name|pflag
argument_list|,
name|CHHDR_CHECK
argument_list|)
condition|)
block|{
name|int
name|rscheckflags
decl_stmt|;
name|char
modifier|*
name|rs
decl_stmt|;
name|rscheckflags
operator|=
name|RSF_COUNT
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|hi
operator|->
name|hi_flags
argument_list|,
name|H_FROM
operator||
name|H_RCPT
argument_list|)
condition|)
name|rscheckflags
operator||=
name|RSF_UNSTRUCTURED
expr_stmt|;
comment|/* no ruleset? look for default */
name|rs
operator|=
name|hi
operator|->
name|hi_ruleset
expr_stmt|;
if|if
condition|(
name|rs
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|stab
argument_list|(
literal|"*"
argument_list|,
name|ST_HEADER
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|rs
operator|=
operator|(
operator|&
name|s
operator|->
name|s_header
operator|)
operator|->
name|hi_ruleset
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
operator|(
operator|&
name|s
operator|->
name|s_header
operator|)
operator|->
name|hi_flags
argument_list|,
name|H_STRIPCOMM
argument_list|)
condition|)
name|rscheckflags
operator||=
name|RSF_RMCOMM
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|hi
operator|->
name|hi_flags
argument_list|,
name|H_STRIPCOMM
argument_list|)
condition|)
name|rscheckflags
operator||=
name|RSF_RMCOMM
expr_stmt|;
if|if
condition|(
name|rs
operator|!=
name|NULL
condition|)
block|{
name|int
name|l
decl_stmt|,
name|k
decl_stmt|;
name|char
name|qval
index|[
name|MAXNAME
index|]
decl_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
name|qval
index|[
name|l
operator|++
index|]
operator|=
literal|'"'
expr_stmt|;
comment|/* - 3 to avoid problems with " at the end */
comment|/* should be sizeof(qval), not MAXNAME */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|fvalue
index|[
name|k
index|]
operator|!=
literal|'\0'
operator|&&
name|l
operator|<
name|MAXNAME
operator|-
literal|3
condition|;
name|k
operator|++
control|)
block|{
switch|switch
condition|(
name|fvalue
index|[
name|k
index|]
condition|)
block|{
comment|/* XXX other control chars? */
case|case
literal|'\011'
case|:
comment|/* ht */
case|case
literal|'\012'
case|:
comment|/* nl */
case|case
literal|'\013'
case|:
comment|/* vt */
case|case
literal|'\014'
case|:
comment|/* np */
case|case
literal|'\015'
case|:
comment|/* cr */
name|qval
index|[
name|l
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
name|qval
index|[
name|l
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
name|qval
index|[
name|l
operator|++
index|]
operator|=
name|fvalue
index|[
name|k
index|]
expr_stmt|;
break|break;
block|}
block|}
name|qval
index|[
name|l
operator|++
index|]
operator|=
literal|'"'
expr_stmt|;
name|qval
index|[
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
name|k
operator|+=
name|strlen
argument_list|(
name|fvalue
operator|+
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|>=
name|MAXNAME
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Warning: truncated header '%s' before check with '%s' len=%d max=%d"
argument_list|,
name|fname
argument_list|,
name|rs
argument_list|,
name|k
argument_list|,
name|MAXNAME
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{currHeader}"
argument_list|)
argument_list|,
name|qval
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{hdr_name}"
argument_list|)
argument_list|,
name|fname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|qval
argument_list|,
sizeof|sizeof
argument_list|(
name|qval
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{hdrlen}"
argument_list|)
argument_list|,
name|qval
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|H_FROM
argument_list|,
name|hi
operator|->
name|hi_flags
argument_list|)
condition|)
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{addr_type}"
argument_list|)
argument_list|,
literal|"h s"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|H_RCPT
argument_list|,
name|hi
operator|->
name|hi_flags
argument_list|)
condition|)
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{addr_type}"
argument_list|)
argument_list|,
literal|"h r"
argument_list|)
expr_stmt|;
else|else
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{addr_type}"
argument_list|)
argument_list|,
literal|"h"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rscheck
argument_list|(
name|rs
argument_list|,
name|fvalue
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
name|rscheckflags
argument_list|,
literal|3
argument_list|,
name|NULL
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	**  Drop explicit From: if same as what we would generate. 	**  This is to make MH (which doesn't always give a full name) 	**  insert the full name information in all circumstances. 	*/
name|dropfrom
operator|=
name|false
expr_stmt|;
name|p
operator|=
literal|"resent-from"
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|EF_RESENT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|p
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|pflag
argument_list|,
name|CHHDR_DEF
argument_list|)
operator|&&
operator|!
name|headeronly
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_QUEUERUN
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
name|sm_strcasecmp
argument_list|(
name|fname
argument_list|,
name|p
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|31
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"comparing header from (%s) against default (%s or %s)\n"
argument_list|,
name|fvalue
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_user
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|e_from
operator|.
name|q_paddr
operator|!=
name|NULL
operator|&&
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|!=
name|NULL
operator|&&
name|bitnset
argument_list|(
name|M_LOCALMAILER
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|->
name|m_flags
argument_list|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|fvalue
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|fvalue
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_user
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|dropfrom
operator|=
name|true
expr_stmt|;
block|}
comment|/* delete default value for this header */
for|for
control|(
name|hp
operator|=
name|hdrp
init|;
operator|(
name|h
operator|=
operator|*
name|hp
operator|)
operator|!=
name|NULL
condition|;
name|hp
operator|=
operator|&
name|h
operator|->
name|h_link
control|)
block|{
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|fname
argument_list|,
name|h
operator|->
name|h_field
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|bitset
argument_list|(
name|H_USER
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|H_FORCE
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|nullheader
condition|)
block|{
comment|/* user-supplied value was null */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|dropfrom
condition|)
block|{
comment|/* make this look like the user entered it */
name|h
operator|->
name|h_flags
operator||=
name|H_USER
expr_stmt|;
return|return
name|hi
operator|->
name|hi_flags
return|;
block|}
name|h
operator|->
name|h_value
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|cond
condition|)
block|{
comment|/* copy conditions from default case */
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mopts
argument_list|,
operator|(
name|char
operator|*
operator|)
name|h
operator|->
name|h_mflags
argument_list|,
sizeof|sizeof
argument_list|(
name|mopts
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|h
operator|->
name|h_macro
operator|=
name|mid
expr_stmt|;
block|}
block|}
comment|/* create a new node */
name|h
operator|=
operator|(
name|HDR
operator|*
operator|)
name|sm_rpool_malloc_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|h
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_field
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_value
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|fvalue
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_link
operator|=
name|NULL
expr_stmt|;
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|h
operator|->
name|h_mflags
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mopts
argument_list|,
sizeof|sizeof
argument_list|(
name|mopts
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_macro
operator|=
name|mid
expr_stmt|;
operator|*
name|hp
operator|=
name|h
expr_stmt|;
name|h
operator|->
name|h_flags
operator|=
name|hi
operator|->
name|hi_flags
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|pflag
argument_list|,
name|CHHDR_USER
argument_list|)
operator|||
name|bitset
argument_list|(
name|pflag
argument_list|,
name|CHHDR_QUEUE
argument_list|)
condition|)
name|h
operator|->
name|h_flags
operator||=
name|H_USER
expr_stmt|;
comment|/* strip EOH flag if parsing MIME headers */
if|if
condition|(
name|headeronly
condition|)
name|h
operator|->
name|h_flags
operator|&=
operator|~
name|H_EOH
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|pflag
argument_list|,
name|CHHDR_DEF
argument_list|)
condition|)
name|h
operator|->
name|h_flags
operator||=
name|H_DEFAULT
expr_stmt|;
if|if
condition|(
name|cond
operator|||
name|mid
operator|!=
literal|'\0'
condition|)
name|h
operator|->
name|h_flags
operator||=
name|H_CHECK
expr_stmt|;
comment|/* hack to see if this is a new format message */
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|pflag
argument_list|,
name|CHHDR_DEF
argument_list|)
operator|&&
operator|!
name|headeronly
operator|&&
name|bitset
argument_list|(
name|H_RCPT
operator||
name|H_FROM
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
operator|(
name|strchr
argument_list|(
name|fvalue
argument_list|,
literal|','
argument_list|)
operator|!=
name|NULL
operator|||
name|strchr
argument_list|(
name|fvalue
argument_list|,
literal|'('
argument_list|)
operator|!=
name|NULL
operator|||
name|strchr
argument_list|(
name|fvalue
argument_list|,
literal|'<'
argument_list|)
operator|!=
name|NULL
operator|||
name|strchr
argument_list|(
name|fvalue
argument_list|,
literal|';'
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_OLDSTYLE
expr_stmt|;
block|}
return|return
name|h
operator|->
name|h_flags
return|;
block|}
end_function

begin_comment
comment|/* **  CHOMPHEADER -- process and save a header line. ** **	Called by collect, readcf, and readqf to deal with header lines. **	This is just a wrapper for dochompheader(). ** **	Parameters: **		line -- header as a text line. **		pflag -- flags for chompheader() (from sendmail.h) **		hdrp -- a pointer to the place to save the header. **		e -- the envelope including this header. ** **	Returns: **		flags for this header. ** **	Side Effects: **		The header is saved on the header list. **		Contents of 'line' are destroyed. */
end_comment

begin_function
name|unsigned
name|long
name|chompheader
parameter_list|(
name|line
parameter_list|,
name|pflag
parameter_list|,
name|hdrp
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|pflag
decl_stmt|;
name|HDR
modifier|*
modifier|*
name|hdrp
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|unsigned
name|long
name|rval
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|31
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"chompheader: "
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* quote this if user (not config file) input */
if|if
condition|(
name|bitset
argument_list|(
name|pflag
argument_list|,
name|CHHDR_USER
argument_list|)
condition|)
block|{
name|char
name|xbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|char
modifier|*
name|xbp
init|=
name|NULL
decl_stmt|;
name|int
name|xbufs
decl_stmt|;
name|xbufs
operator|=
sizeof|sizeof
argument_list|(
name|xbuf
argument_list|)
expr_stmt|;
name|xbp
operator|=
name|quote_internal_chars
argument_list|(
name|line
argument_list|,
name|xbuf
argument_list|,
operator|&
name|xbufs
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|31
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"chompheader: quoted: "
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|xbp
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|rval
operator|=
name|dochompheader
argument_list|(
name|xbp
argument_list|,
name|pflag
argument_list|,
name|hdrp
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|xbp
operator|!=
name|xbuf
condition|)
name|sm_free
argument_list|(
name|xbp
argument_list|)
expr_stmt|;
block|}
else|else
name|rval
operator|=
name|dochompheader
argument_list|(
name|line
argument_list|,
name|pflag
argument_list|,
name|hdrp
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* **  ALLOCHEADER -- allocate a header entry ** **	Parameters: **		field -- the name of the header field (will not be copied). **		value -- the value of the field (will be copied). **		flags -- flags to add to h_flags. **		rp -- resource pool for allocations **		space -- add leading space? ** **	Returns: **		Pointer to a newly allocated and populated HDR. ** **	Notes: **		o field and value must be in internal format, i.e., **		metacharacters must be "quoted", see quote_internal_chars(). **		o maybe add more flags to decide: **		  - what to copy (field/value) **		  - whether to convert value to an internal format */
end_comment

begin_function
specifier|static
name|HDR
modifier|*
name|allocheader
parameter_list|(
name|field
parameter_list|,
name|value
parameter_list|,
name|flags
parameter_list|,
name|rp
parameter_list|,
name|space
parameter_list|)
name|char
modifier|*
name|field
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|SM_RPOOL_T
modifier|*
name|rp
decl_stmt|;
name|bool
name|space
decl_stmt|;
block|{
name|HDR
modifier|*
name|h
decl_stmt|;
name|STAB
modifier|*
name|s
decl_stmt|;
comment|/* find info struct */
name|s
operator|=
name|stab
argument_list|(
name|field
argument_list|,
name|ST_HEADER
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
comment|/* allocate space for new header */
name|h
operator|=
operator|(
name|HDR
operator|*
operator|)
name|sm_rpool_malloc_x
argument_list|(
name|rp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|h
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_field
operator|=
name|field
expr_stmt|;
if|if
condition|(
name|space
condition|)
block|{
name|size_t
name|l
decl_stmt|;
name|char
modifier|*
name|n
decl_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|SM_ASSERT
argument_list|(
name|l
operator|+
literal|2
operator|>
name|l
argument_list|)
expr_stmt|;
name|n
operator|=
name|sm_rpool_malloc_x
argument_list|(
name|rp
argument_list|,
name|l
operator|+
literal|2
argument_list|)
expr_stmt|;
name|n
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
name|n
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sm_strlcpy
argument_list|(
name|n
operator|+
literal|1
argument_list|,
name|value
argument_list|,
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_value
operator|=
name|n
expr_stmt|;
block|}
else|else
name|h
operator|->
name|h_value
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|rp
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|h
operator|->
name|h_flags
operator||=
name|s
operator|->
name|s_header
operator|.
name|hi_flags
expr_stmt|;
name|clrbitmap
argument_list|(
name|h
operator|->
name|h_mflags
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_macro
operator|=
literal|'\0'
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_comment
comment|/* **  ADDHEADER -- add a header entry to the end of the queue. ** **	This bypasses the special checking of chompheader. ** **	Parameters: **		field -- the name of the header field (will not be copied). **		value -- the value of the field (will be copied). **		flags -- flags to add to h_flags. **		e -- envelope. **		space -- add leading space? ** **	Returns: **		none. ** **	Side Effects: **		adds the field on the list of headers for this envelope. ** **	Notes: field and value must be in internal format, i.e., **		metacharacters must be "quoted", see quote_internal_chars(). */
end_comment

begin_function
name|void
name|addheader
parameter_list|(
name|field
parameter_list|,
name|value
parameter_list|,
name|flags
parameter_list|,
name|e
parameter_list|,
name|space
parameter_list|)
name|char
modifier|*
name|field
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|bool
name|space
decl_stmt|;
block|{
specifier|register
name|HDR
modifier|*
name|h
decl_stmt|;
name|HDR
modifier|*
modifier|*
name|hp
decl_stmt|;
name|HDR
modifier|*
modifier|*
name|hdrlist
init|=
operator|&
name|e
operator|->
name|e_header
decl_stmt|;
comment|/* find current place in list -- keep back pointer? */
for|for
control|(
name|hp
operator|=
name|hdrlist
init|;
operator|(
name|h
operator|=
operator|*
name|hp
operator|)
operator|!=
name|NULL
condition|;
name|hp
operator|=
operator|&
name|h
operator|->
name|h_link
control|)
block|{
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|field
argument_list|,
name|h
operator|->
name|h_field
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* allocate space for new header */
name|h
operator|=
name|allocheader
argument_list|(
name|field
argument_list|,
name|value
argument_list|,
name|flags
argument_list|,
name|e
operator|->
name|e_rpool
argument_list|,
name|space
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_link
operator|=
operator|*
name|hp
expr_stmt|;
operator|*
name|hp
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  INSHEADER -- insert a header entry at the specified index **	This bypasses the special checking of chompheader. ** **	Parameters: **		idx -- index into the header list at which to insert **		field -- the name of the header field (will be copied). **		value -- the value of the field (will be copied). **		flags -- flags to add to h_flags. **		e -- envelope. **		space -- add leading space? ** **	Returns: **		none. ** **	Side Effects: **		inserts the field on the list of headers for this envelope. ** **	Notes: **		- field and value must be in internal format, i.e., **		metacharacters must be "quoted", see quote_internal_chars(). **		- the header list contains headers that might not be **		sent "out" (see putheader(): "skip"), hence there is no **		reliable way to insert a header at an exact position **		(except at the front or end). */
end_comment

begin_function
name|void
name|insheader
parameter_list|(
name|idx
parameter_list|,
name|field
parameter_list|,
name|value
parameter_list|,
name|flags
parameter_list|,
name|e
parameter_list|,
name|space
parameter_list|)
name|int
name|idx
decl_stmt|;
name|char
modifier|*
name|field
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|bool
name|space
decl_stmt|;
block|{
name|HDR
modifier|*
name|h
decl_stmt|,
modifier|*
name|srch
decl_stmt|,
modifier|*
name|last
init|=
name|NULL
decl_stmt|;
comment|/* allocate space for new header */
name|h
operator|=
name|allocheader
argument_list|(
name|field
argument_list|,
name|value
argument_list|,
name|flags
argument_list|,
name|e
operator|->
name|e_rpool
argument_list|,
name|space
argument_list|)
expr_stmt|;
comment|/* find insertion position */
for|for
control|(
name|srch
operator|=
name|e
operator|->
name|e_header
init|;
name|srch
operator|!=
name|NULL
operator|&&
name|idx
operator|>
literal|0
condition|;
name|srch
operator|=
name|srch
operator|->
name|h_link
operator|,
name|idx
operator|--
control|)
name|last
operator|=
name|srch
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_header
operator|==
name|NULL
condition|)
block|{
name|e
operator|->
name|e_header
operator|=
name|h
expr_stmt|;
name|h
operator|->
name|h_link
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|srch
operator|==
name|NULL
condition|)
block|{
name|SM_ASSERT
argument_list|(
name|last
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|last
operator|->
name|h_link
operator|=
name|h
expr_stmt|;
name|h
operator|->
name|h_link
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|h
operator|->
name|h_link
operator|=
name|srch
operator|->
name|h_link
expr_stmt|;
name|srch
operator|->
name|h_link
operator|=
name|h
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  HVALUE -- return value of a header. ** **	Only "real" fields (i.e., ones that have not been supplied **	as a default) are used. ** **	Parameters: **		field -- the field name. **		header -- the header list. ** **	Returns: **		pointer to the value part (internal format). **		NULL if not found. ** **	Side Effects: **		none. */
end_comment

begin_function
name|char
modifier|*
name|hvalue
parameter_list|(
name|field
parameter_list|,
name|header
parameter_list|)
name|char
modifier|*
name|field
decl_stmt|;
name|HDR
modifier|*
name|header
decl_stmt|;
block|{
specifier|register
name|HDR
modifier|*
name|h
decl_stmt|;
for|for
control|(
name|h
operator|=
name|header
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|h_link
control|)
block|{
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|H_DEFAULT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
name|sm_strcasecmp
argument_list|(
name|h
operator|->
name|h_field
argument_list|,
name|field
argument_list|)
operator|==
literal|0
condition|)
return|return
name|h
operator|->
name|h_value
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  ISHEADER -- predicate telling if argument is a header. ** **	A line is a header if it has a single word followed by **	optional white space followed by a colon. ** **	Header fields beginning with two dashes, although technically **	permitted by RFC822, are automatically rejected in order **	to make MIME work out.  Without this we could have a technically **	legal header such as ``--"foo:bar"'' that would also be a legal **	MIME separator. ** **	Parameters: **		h -- string to check for possible headerness. ** **	Returns: **		true if h is a header. **		false otherwise. ** **	Side Effects: **		none. */
end_comment

begin_function
name|bool
name|isheader
parameter_list|(
name|h
parameter_list|)
name|char
modifier|*
name|h
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
return|return
name|false
return|;
while|while
condition|(
operator|*
name|s
operator|>
literal|' '
operator|&&
operator|*
name|s
operator|!=
literal|':'
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|s
condition|)
return|return
name|false
return|;
comment|/* following technically violates RFC822 */
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
return|return
operator|(
operator|*
name|s
operator|==
literal|':'
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **  EATHEADER -- run through the stored header and extract info. ** **	Parameters: **		e -- the envelope to process. **		full -- if set, do full processing (e.g., compute **			message priority).  This should not be set **			when reading a queue file because some info **			needed to compute the priority is wrong. **		log -- call logsender()? ** **	Returns: **		none. ** **	Side Effects: **		Sets a bunch of global variables from information **			in the collected header. */
end_comment

begin_function
name|void
name|eatheader
parameter_list|(
name|e
parameter_list|,
name|full
parameter_list|,
name|log
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|bool
name|full
decl_stmt|;
name|bool
name|log
decl_stmt|;
block|{
specifier|register
name|HDR
modifier|*
name|h
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|hopcnt
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
comment|/* 	**  Set up macros for possible expansion in headers. 	*/
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'f'
argument_list|,
name|e
operator|->
name|e_sender
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'g'
argument_list|,
name|e
operator|->
name|e_sender
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_origrcpt
operator|!=
name|NULL
operator|&&
operator|*
name|e
operator|->
name|e_origrcpt
operator|!=
literal|'\0'
condition|)
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'u'
argument_list|,
name|e
operator|->
name|e_origrcpt
argument_list|)
expr_stmt|;
else|else
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'u'
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* full name of from person */
name|p
operator|=
name|hvalue
argument_list|(
literal|"full-name"
argument_list|,
name|e
operator|->
name|e_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|rfc822_string
argument_list|(
name|p
argument_list|)
condition|)
block|{
comment|/* 			**  Quote a full name with special characters 			**  as a comment so crackaddr() doesn't destroy 			**  the name portion of the address. 			*/
name|p
operator|=
name|addquotes
argument_list|(
name|p
argument_list|,
name|e
operator|->
name|e_rpool
argument_list|)
expr_stmt|;
block|}
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'x'
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|32
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"----- collected header -----\n"
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_msgid
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|h
operator|=
name|e
operator|->
name|e_header
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|h_link
control|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|32
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"%s:"
argument_list|,
name|h
operator|->
name|h_field
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|h_value
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|32
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"<NULL>\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* do early binding */
if|if
condition|(
name|bitset
argument_list|(
name|H_DEFAULT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|H_BINDLATE
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|32
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|h
operator|->
name|h_value
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|") "
argument_list|)
expr_stmt|;
block|}
name|expand
argument_list|(
name|h
operator|->
name|h_value
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
operator|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|' '
operator|||
name|buf
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|H_FROM
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
name|expand
argument_list|(
name|crackaddr
argument_list|(
name|buf
argument_list|,
name|e
argument_list|)
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_value
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_flags
operator|&=
operator|~
name|H_DEFAULT
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|32
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|xputs
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|h
operator|->
name|h_value
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* count the number of times it has been processed */
if|if
condition|(
name|bitset
argument_list|(
name|H_TRACE
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
name|hopcnt
operator|++
expr_stmt|;
comment|/* send to this person if we so desire */
if|if
condition|(
name|GrabTo
operator|&&
name|bitset
argument_list|(
name|H_RCPT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|H_DEFAULT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
operator|(
operator|!
name|bitset
argument_list|(
name|EF_RESENT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|||
name|bitset
argument_list|(
name|H_RESENT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
literal|0
block|int saveflags = e->e_flags;
endif|#
directive|endif
comment|/* 0 */
operator|(
name|void
operator|)
name|sendtolist
argument_list|(
name|denlstring
argument_list|(
name|h
operator|->
name|h_value
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
argument_list|,
name|NULLADDR
argument_list|,
operator|&
name|e
operator|->
name|e_sendqueue
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 			**  Change functionality so a fatal error on an 			**  address doesn't affect the entire envelope. 			*/
comment|/* delete fatal errors generated by this address */
block|if (!bitset(EF_FATALERRS, saveflags)) 				e->e_flags&= ~EF_FATALERRS;
endif|#
directive|endif
comment|/* 0 */
block|}
comment|/* save the message-id for logging */
name|p
operator|=
literal|"resent-message-id"
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|EF_RESENT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|p
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|h
operator|->
name|h_field
argument_list|,
name|p
argument_list|)
operator|==
literal|0
condition|)
block|{
name|e
operator|->
name|e_msgid
operator|=
name|h
operator|->
name|h_value
expr_stmt|;
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|e
operator|->
name|e_msgid
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|e
operator|->
name|e_msgid
argument_list|)
condition|)
name|e
operator|->
name|e_msgid
operator|++
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{msg_id}"
argument_list|)
argument_list|,
name|e
operator|->
name|e_msgid
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|32
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
comment|/* if we are just verifying (that is, sendmail -t -bv), drop out now */
if|if
condition|(
name|OpMode
operator|==
name|MD_VERIFY
condition|)
return|return;
comment|/* store hop count */
if|if
condition|(
name|hopcnt
operator|>
name|e
operator|->
name|e_hopcount
condition|)
block|{
name|e
operator|->
name|e_hopcount
operator|=
name|hopcnt
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|e
operator|->
name|e_hopcount
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
literal|'c'
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* message priority */
name|p
operator|=
name|hvalue
argument_list|(
literal|"precedence"
argument_list|,
name|e
operator|->
name|e_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|e
operator|->
name|e_class
operator|=
name|priencode
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_class
operator|<
literal|0
condition|)
name|e
operator|->
name|e_timeoutclass
operator|=
name|TOC_NONURGENT
expr_stmt|;
elseif|else
if|if
condition|(
name|e
operator|->
name|e_class
operator|>
literal|0
condition|)
name|e
operator|->
name|e_timeoutclass
operator|=
name|TOC_URGENT
expr_stmt|;
if|if
condition|(
name|full
condition|)
block|{
name|e
operator|->
name|e_msgpriority
operator|=
name|e
operator|->
name|e_msgsize
operator|-
name|e
operator|->
name|e_class
operator|*
name|WkClassFact
operator|+
name|e
operator|->
name|e_nrcpts
operator|*
name|WkRecipFact
expr_stmt|;
block|}
comment|/* check for DSN to properly set e_timeoutclass */
name|p
operator|=
name|hvalue
argument_list|(
literal|"content-type"
argument_list|,
name|e
operator|->
name|e_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|bool
name|oldsupr
decl_stmt|;
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
name|char
name|pvpbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
specifier|extern
name|unsigned
name|char
name|MimeTokenTab
index|[
literal|256
index|]
decl_stmt|;
comment|/* tokenize header */
name|oldsupr
operator|=
name|SuprErrs
expr_stmt|;
name|SuprErrs
operator|=
name|true
expr_stmt|;
name|pvp
operator|=
name|prescan
argument_list|(
name|p
argument_list|,
literal|'\0'
argument_list|,
name|pvpbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pvpbuf
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|MimeTokenTab
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|SuprErrs
operator|=
name|oldsupr
expr_stmt|;
comment|/* Check if multipart/report */
if|if
condition|(
name|pvp
operator|!=
name|NULL
operator|&&
name|pvp
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
name|pvp
index|[
literal|1
index|]
operator|!=
name|NULL
operator|&&
name|pvp
index|[
literal|2
index|]
operator|!=
name|NULL
operator|&&
name|sm_strcasecmp
argument_list|(
operator|*
name|pvp
operator|++
argument_list|,
literal|"multipart"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
operator|*
name|pvp
operator|++
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
operator|&&
name|sm_strcasecmp
argument_list|(
operator|*
name|pvp
operator|++
argument_list|,
literal|"report"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Look for report-type=delivery-status */
while|while
condition|(
operator|*
name|pvp
operator|!=
name|NULL
condition|)
block|{
comment|/* skip to semicolon separator */
while|while
condition|(
operator|*
name|pvp
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
operator|*
name|pvp
argument_list|,
literal|";"
argument_list|)
operator|!=
literal|0
condition|)
name|pvp
operator|++
expr_stmt|;
comment|/* skip semicolon */
if|if
condition|(
operator|*
name|pvp
operator|++
operator|==
name|NULL
operator|||
operator|*
name|pvp
operator|==
name|NULL
condition|)
break|break;
comment|/* look for report-type */
if|if
condition|(
name|sm_strcasecmp
argument_list|(
operator|*
name|pvp
operator|++
argument_list|,
literal|"report-type"
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* skip equal */
if|if
condition|(
operator|*
name|pvp
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
operator|*
name|pvp
argument_list|,
literal|"="
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* check value */
if|if
condition|(
operator|*
operator|++
name|pvp
operator|!=
name|NULL
operator|&&
name|sm_strcasecmp
argument_list|(
operator|*
name|pvp
argument_list|,
literal|"delivery-status"
argument_list|)
operator|==
literal|0
condition|)
name|e
operator|->
name|e_timeoutclass
operator|=
name|TOC_DSN
expr_stmt|;
comment|/* found report-type, no need to continue */
break|break;
block|}
block|}
block|}
comment|/* message timeout priority */
name|p
operator|=
name|hvalue
argument_list|(
literal|"priority"
argument_list|,
name|e
operator|->
name|e_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* (this should be in the configuration file) */
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|p
argument_list|,
literal|"urgent"
argument_list|)
operator|==
literal|0
condition|)
name|e
operator|->
name|e_timeoutclass
operator|=
name|TOC_URGENT
expr_stmt|;
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|p
argument_list|,
literal|"normal"
argument_list|)
operator|==
literal|0
condition|)
name|e
operator|->
name|e_timeoutclass
operator|=
name|TOC_NORMAL
expr_stmt|;
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|p
argument_list|,
literal|"non-urgent"
argument_list|)
operator|==
literal|0
condition|)
name|e
operator|->
name|e_timeoutclass
operator|=
name|TOC_NONURGENT
expr_stmt|;
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|EF_RESPONSE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|e
operator|->
name|e_timeoutclass
operator|=
name|TOC_DSN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|EF_RESPONSE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|e
operator|->
name|e_timeoutclass
operator|=
name|TOC_DSN
expr_stmt|;
comment|/* date message originated */
name|p
operator|=
name|hvalue
argument_list|(
literal|"posted-date"
argument_list|,
name|e
operator|->
name|e_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|hvalue
argument_list|(
literal|"date"
argument_list|,
name|e
operator|->
name|e_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'a'
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* check to see if this is a MIME message */
if|if
condition|(
operator|(
name|e
operator|->
name|e_bodytype
operator|!=
name|NULL
operator|&&
name|sm_strcasecmp
argument_list|(
name|e
operator|->
name|e_bodytype
argument_list|,
literal|"8BITMIME"
argument_list|)
operator|==
literal|0
operator|)
operator|||
name|hvalue
argument_list|(
literal|"MIME-Version"
argument_list|,
name|e
operator|->
name|e_header
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|e
operator|->
name|e_flags
operator||=
name|EF_IS_MIME
expr_stmt|;
if|if
condition|(
name|HasEightBits
condition|)
name|e
operator|->
name|e_bodytype
operator|=
literal|"8BITMIME"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p
operator|=
name|hvalue
argument_list|(
literal|"Content-Type"
argument_list|,
name|e
operator|->
name|e_header
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* this may be an RFC 1049 message */
name|p
operator|=
name|strpbrk
argument_list|(
name|p
argument_list|,
literal|";/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
operator|*
name|p
operator|==
literal|';'
condition|)
block|{
comment|/* yep, it is */
name|e
operator|->
name|e_flags
operator||=
name|EF_DONT_MIME
expr_stmt|;
block|}
block|}
comment|/* 	**  From person in antiquated ARPANET mode 	**	required by UK Grey Book e-mail gateways (sigh) 	*/
if|if
condition|(
name|OpMode
operator|==
name|MD_ARPAFTP
condition|)
block|{
specifier|register
name|struct
name|hdrinfo
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|HdrInfo
init|;
name|hi
operator|->
name|hi_field
operator|!=
name|NULL
condition|;
name|hi
operator|++
control|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|H_FROM
argument_list|,
name|hi
operator|->
name|hi_flags
argument_list|)
operator|&&
operator|(
operator|!
name|bitset
argument_list|(
name|H_RESENT
argument_list|,
name|hi
operator|->
name|hi_flags
argument_list|)
operator|||
name|bitset
argument_list|(
name|EF_RESENT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|)
operator|&&
operator|(
name|p
operator|=
name|hvalue
argument_list|(
name|hi
operator|->
name|hi_field
argument_list|,
name|e
operator|->
name|e_header
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|hi
operator|->
name|hi_field
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|32
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"eatheader: setsender(*%s == %s)\n"
argument_list|,
name|hi
operator|->
name|hi_field
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|setsender
argument_list|(
name|p
argument_list|,
name|e
argument_list|,
name|NULL
argument_list|,
literal|'\0'
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	**  Log collection information. 	*/
if|if
condition|(
name|log
operator|&&
name|bitset
argument_list|(
name|EF_LOGSENDER
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
name|LogLevel
operator|>
literal|4
condition|)
block|{
name|logsender
argument_list|(
name|e
argument_list|,
name|e
operator|->
name|e_msgid
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_LOGSENDER
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  LOGSENDER -- log sender information ** **	Parameters: **		e -- the envelope to log **		msgid -- the message id ** **	Returns: **		none */
end_comment

begin_function
name|void
name|logsender
parameter_list|(
name|e
parameter_list|,
name|msgid
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|msgid
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
modifier|*
name|sbp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|hbuf
index|[
name|MAXNAME
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|sbuf
index|[
name|MAXLINE
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|mbuf
index|[
name|MAXNAME
operator|+
literal|1
index|]
decl_stmt|;
comment|/* don't allow newlines in the message-id */
comment|/* XXX do we still need this? sm_syslog() replaces control chars */
if|if
condition|(
name|msgid
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|l
decl_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|msgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
sizeof|sizeof
argument_list|(
name|mbuf
argument_list|)
operator|-
literal|1
condition|)
name|l
operator|=
sizeof|sizeof
argument_list|(
name|mbuf
argument_list|)
operator|-
literal|1
expr_stmt|;
name|memmove
argument_list|(
name|mbuf
argument_list|,
name|msgid
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|mbuf
index|[
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|mbuf
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|EF_RESPONSE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|name
operator|=
literal|"[RESPONSE]"
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|name
operator|=
name|macvalue
argument_list|(
literal|'_'
argument_list|,
name|e
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
comment|/* EMPTY */
empty_stmt|;
elseif|else
if|if
condition|(
name|RealHostName
operator|==
name|NULL
condition|)
name|name
operator|=
literal|"localhost"
expr_stmt|;
elseif|else
if|if
condition|(
name|RealHostName
index|[
literal|0
index|]
operator|==
literal|'['
condition|)
name|name
operator|=
name|RealHostName
expr_stmt|;
else|else
block|{
name|name
operator|=
name|hbuf
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|hbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|hbuf
argument_list|)
argument_list|,
literal|"%.80s"
argument_list|,
name|RealHostName
argument_list|)
expr_stmt|;
if|if
condition|(
name|RealHostAddr
operator|.
name|sa
operator|.
name|sa_family
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
operator|&
name|hbuf
index|[
name|strlen
argument_list|(
name|hbuf
argument_list|)
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|p
argument_list|,
name|SPACELEFT
argument_list|(
name|hbuf
argument_list|,
name|p
argument_list|)
argument_list|,
literal|" (%.100s)"
argument_list|,
name|anynet_ntoa
argument_list|(
operator|&
name|RealHostAddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* some versions of syslog only take 5 printf args */
if|#
directive|if
operator|(
name|SYSLOG_BUFSIZE
operator|)
operator|>=
literal|256
name|sbp
operator|=
name|sbuf
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|sbp
argument_list|,
name|SPACELEFT
argument_list|(
name|sbuf
argument_list|,
name|sbp
argument_list|)
argument_list|,
literal|"from=%.200s, size=%ld, class=%d, nrcpts=%d"
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_paddr
operator|==
name|NULL
condition|?
literal|"<NONE>"
else|:
name|e
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|,
name|e
operator|->
name|e_msgsize
argument_list|,
name|e
operator|->
name|e_class
argument_list|,
name|e
operator|->
name|e_nrcpts
argument_list|)
expr_stmt|;
name|sbp
operator|+=
name|strlen
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgid
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|sbp
argument_list|,
name|SPACELEFT
argument_list|(
name|sbuf
argument_list|,
name|sbp
argument_list|)
argument_list|,
literal|", msgid=%.100s"
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
name|sbp
operator|+=
name|strlen
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|e_bodytype
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|sbp
argument_list|,
name|SPACELEFT
argument_list|(
name|sbuf
argument_list|,
name|sbp
argument_list|)
argument_list|,
literal|", bodytype=%.20s"
argument_list|,
name|e
operator|->
name|e_bodytype
argument_list|)
expr_stmt|;
name|sbp
operator|+=
name|strlen
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|macvalue
argument_list|(
literal|'r'
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|sbp
argument_list|,
name|SPACELEFT
argument_list|(
name|sbuf
argument_list|,
name|sbp
argument_list|)
argument_list|,
literal|", proto=%.20s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|sbp
operator|+=
name|strlen
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{daemon_name}"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|sbp
argument_list|,
name|SPACELEFT
argument_list|(
name|sbuf
argument_list|,
name|sbp
argument_list|)
argument_list|,
literal|", daemon=%.20s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|sbp
operator|+=
name|strlen
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
block|}
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%.850s, relay=%s"
argument_list|,
name|sbuf
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* (SYSLOG_BUFSIZE)>= 256 */
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"from=%s"
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_paddr
operator|==
name|NULL
condition|?
literal|"<NONE>"
else|:
name|shortenstring
argument_list|(
name|e
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|,
literal|83
argument_list|)
argument_list|)
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"size=%ld, class=%ld, nrcpts=%d"
argument_list|,
name|e
operator|->
name|e_msgsize
argument_list|,
name|e
operator|->
name|e_class
argument_list|,
name|e
operator|->
name|e_nrcpts
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgid
operator|!=
name|NULL
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"msgid=%s"
argument_list|,
name|shortenstring
argument_list|(
name|mbuf
argument_list|,
literal|83
argument_list|)
argument_list|)
expr_stmt|;
name|sbp
operator|=
name|sbuf
expr_stmt|;
operator|*
name|sbp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_bodytype
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|sbp
argument_list|,
name|SPACELEFT
argument_list|(
name|sbuf
argument_list|,
name|sbp
argument_list|)
argument_list|,
literal|"bodytype=%.20s, "
argument_list|,
name|e
operator|->
name|e_bodytype
argument_list|)
expr_stmt|;
name|sbp
operator|+=
name|strlen
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|macvalue
argument_list|(
literal|'r'
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|sbp
argument_list|,
name|SPACELEFT
argument_list|(
name|sbuf
argument_list|,
name|sbp
argument_list|)
argument_list|,
literal|"proto=%.20s, "
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|sbp
operator|+=
name|strlen
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
block|}
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%.400srelay=%s"
argument_list|,
name|sbuf
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (SYSLOG_BUFSIZE)>= 256 */
block|}
end_function

begin_comment
comment|/* **  PRIENCODE -- encode external priority names into internal values. ** **	Parameters: **		p -- priority in ascii. ** **	Returns: **		priority as a numeric level. ** **	Side Effects: **		none. */
end_comment

begin_function
specifier|static
name|int
name|priencode
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NumPriorities
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|p
argument_list|,
name|Priorities
index|[
name|i
index|]
operator|.
name|pri_name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|Priorities
index|[
name|i
index|]
operator|.
name|pri_val
return|;
block|}
comment|/* unknown priority */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* **  CRACKADDR -- parse an address and turn it into a macro ** **	This doesn't actually parse the address -- it just extracts **	it and replaces it with "$g".  The parse is totally ad hoc **	and isn't even guaranteed to leave something syntactically **	identical to what it started with.  However, it does leave **	something semantically identical if possible, else at least **	syntactically correct. ** **	For example, it changes "Real Name<real@example.com> (Comment)" **	to "Real Name<$g> (Comment)". ** **	This algorithm has been cleaned up to handle a wider range **	of cases -- notably quoted and backslash escaped strings. **	This modification makes it substantially better at preserving **	the original syntax. ** **	Parameters: **		addr -- the address to be cracked. **		e -- the current envelope. ** **	Returns: **		a pointer to the new version. ** **	Side Effects: **		none. ** **	Warning: **		The return value is saved in local storage and should **		be copied if it is to be reused. */
end_comment

begin_define
define|#
directive|define
name|SM_HAVE_ROOM
value|((bp< buflim)&& (buflim<= bufend))
end_define

begin_comment
comment|/* **  Append a character to bp if we have room. **  If not, punt and return $g. */
end_comment

begin_define
define|#
directive|define
name|SM_APPEND_CHAR
parameter_list|(
name|c
parameter_list|)
define|\
value|do							\ 	{							\ 		if (SM_HAVE_ROOM)				\ 			*bp++ = (c);				\ 		else						\ 			goto returng;				\ 	} while (0)
end_define

begin_if
if|#
directive|if
name|MAXNAME
operator|<
literal|10
end_if

begin_expr_stmt
name|ERROR
name|MAXNAME
name|must
name|be
name|at
name|least
literal|10
endif|#
directive|endif
comment|/* MAXNAME< 10 */
name|char
operator|*
name|crackaddr
argument_list|(
name|addr
argument_list|,
name|e
argument_list|)
specifier|register
name|char
operator|*
name|addr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|int
name|cmtlev
decl_stmt|;
comment|/* comment level in input string */
name|int
name|realcmtlev
decl_stmt|;
comment|/* comment level in output string */
name|int
name|anglelev
decl_stmt|;
comment|/* angle level in input string */
name|int
name|copylev
decl_stmt|;
comment|/* 0 == in address,>0 copying */
name|int
name|bracklev
decl_stmt|;
comment|/* bracket level for IPv6 addr check */
name|bool
name|addangle
decl_stmt|;
comment|/* put closing angle in output */
name|bool
name|qmode
decl_stmt|;
comment|/* quoting in original string? */
name|bool
name|realqmode
decl_stmt|;
comment|/* quoting in output string? */
name|bool
name|putgmac
init|=
name|false
decl_stmt|;
comment|/* already wrote $g */
name|bool
name|quoteit
init|=
name|false
decl_stmt|;
comment|/* need to quote next character */
name|bool
name|gotangle
init|=
name|false
decl_stmt|;
comment|/* found first '<' */
name|bool
name|gotcolon
init|=
name|false
decl_stmt|;
comment|/* found a ':' */
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|buflim
decl_stmt|;
name|char
modifier|*
name|bufhead
decl_stmt|;
name|char
modifier|*
name|addrhead
decl_stmt|;
name|char
modifier|*
name|bufend
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|MAXNAME
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|33
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"crackaddr(%s)\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|buflim
operator|=
name|bufend
operator|=
operator|&
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
name|bp
operator|=
name|bufhead
operator|=
name|buf
expr_stmt|;
comment|/* skip over leading spaces but preserve them */
while|while
condition|(
operator|*
name|addr
operator|!=
literal|'\0'
operator|&&
name|isascii
argument_list|(
operator|*
name|addr
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|addr
argument_list|)
condition|)
block|{
name|SM_APPEND_CHAR
argument_list|(
operator|*
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|++
expr_stmt|;
block|}
name|bufhead
operator|=
name|bp
expr_stmt|;
comment|/* 	**  Start by assuming we have no angle brackets.  This will be 	**  adjusted later if we find them. 	*/
name|p
operator|=
name|addrhead
operator|=
name|addr
expr_stmt|;
name|copylev
operator|=
name|anglelev
operator|=
name|cmtlev
operator|=
name|realcmtlev
operator|=
literal|0
expr_stmt|;
name|bracklev
operator|=
literal|0
expr_stmt|;
name|qmode
operator|=
name|realqmode
operator|=
name|addangle
operator|=
name|false
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
comment|/* 		**  Try to keep legal syntax using spare buffer space 		**  (maintained by buflim). 		*/
if|if
condition|(
name|copylev
operator|>
literal|0
condition|)
name|SM_APPEND_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* check for backslash escapes */
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
comment|/* arrange to quote the address */
if|if
condition|(
name|cmtlev
operator|<=
literal|0
operator|&&
operator|!
name|qmode
condition|)
name|quoteit
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
literal|'\0'
condition|)
block|{
comment|/* too far */
name|p
operator|--
expr_stmt|;
goto|goto
name|putg
goto|;
block|}
if|if
condition|(
name|copylev
operator|>
literal|0
condition|)
name|SM_APPEND_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
goto|goto
name|putg
goto|;
block|}
comment|/* check for quoted strings */
if|if
condition|(
name|c
operator|==
literal|'"'
operator|&&
name|cmtlev
operator|<=
literal|0
condition|)
block|{
name|qmode
operator|=
operator|!
name|qmode
expr_stmt|;
if|if
condition|(
name|copylev
operator|>
literal|0
operator|&&
name|SM_HAVE_ROOM
condition|)
block|{
if|if
condition|(
name|realqmode
condition|)
name|buflim
operator|--
expr_stmt|;
else|else
name|buflim
operator|++
expr_stmt|;
name|realqmode
operator|=
operator|!
name|realqmode
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|qmode
condition|)
goto|goto
name|putg
goto|;
comment|/* check for comments */
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
block|{
name|cmtlev
operator|++
expr_stmt|;
comment|/* allow space for closing paren */
if|if
condition|(
name|SM_HAVE_ROOM
condition|)
block|{
name|buflim
operator|--
expr_stmt|;
name|realcmtlev
operator|++
expr_stmt|;
if|if
condition|(
name|copylev
operator|++
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|bp
operator|!=
name|bufhead
condition|)
name|SM_APPEND_CHAR
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|SM_APPEND_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|cmtlev
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
block|{
name|cmtlev
operator|--
expr_stmt|;
name|copylev
operator|--
expr_stmt|;
if|if
condition|(
name|SM_HAVE_ROOM
condition|)
block|{
name|realcmtlev
operator|--
expr_stmt|;
name|buflim
operator|++
expr_stmt|;
block|}
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
block|{
comment|/* syntax error: unmatched ) */
if|if
condition|(
name|copylev
operator|>
literal|0
operator|&&
name|SM_HAVE_ROOM
operator|&&
name|bp
operator|>
name|bufhead
condition|)
name|bp
operator|--
expr_stmt|;
block|}
comment|/* count nesting on [ ... ] (for IPv6 domain literals) */
if|if
condition|(
name|c
operator|==
literal|'['
condition|)
name|bracklev
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|']'
condition|)
name|bracklev
operator|--
expr_stmt|;
comment|/* check for group: list; syntax */
if|if
condition|(
name|c
operator|==
literal|':'
operator|&&
name|anglelev
operator|<=
literal|0
operator|&&
name|bracklev
operator|<=
literal|0
operator|&&
operator|!
name|gotcolon
operator|&&
operator|!
name|ColonOkInAddr
condition|)
block|{
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
comment|/* 			**  Check for DECnet phase IV ``::'' (host::user) 			**  or DECnet phase V ``:.'' syntaxes.  The latter 			**  covers ``user@DEC:.tay.myhost'' and 			**  ``DEC:.tay.myhost::user'' syntaxes (bletch). 			*/
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
operator|||
operator|*
name|p
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|cmtlev
operator|<=
literal|0
operator|&&
operator|!
name|qmode
condition|)
name|quoteit
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|copylev
operator|>
literal|0
condition|)
block|{
name|SM_APPEND_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|SM_APPEND_CHAR
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
goto|goto
name|putg
goto|;
block|}
name|gotcolon
operator|=
name|true
expr_stmt|;
name|bp
operator|=
name|bufhead
expr_stmt|;
if|if
condition|(
name|quoteit
condition|)
block|{
name|SM_APPEND_CHAR
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
comment|/* back up over the ':' and any spaces */
operator|--
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|>
name|addr
operator|&&
name|isascii
argument_list|(
operator|*
operator|--
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
continue|continue;
name|p
operator|++
expr_stmt|;
block|}
for|for
control|(
name|q
operator|=
name|addrhead
init|;
name|q
operator|<
name|p
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|q
operator|++
expr_stmt|;
if|if
condition|(
name|quoteit
operator|&&
name|c
operator|==
literal|'"'
condition|)
name|SM_APPEND_CHAR
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|SM_APPEND_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|quoteit
condition|)
block|{
if|if
condition|(
name|bp
operator|==
operator|&
name|bufhead
index|[
literal|1
index|]
condition|)
name|bp
operator|--
expr_stmt|;
else|else
name|SM_APPEND_CHAR
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|':'
condition|)
name|SM_APPEND_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|SM_APPEND_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* any trailing white space is part of group: */
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|SM_APPEND_CHAR
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|copylev
operator|=
literal|0
expr_stmt|;
name|putgmac
operator|=
name|quoteit
operator|=
name|false
expr_stmt|;
name|bufhead
operator|=
name|bp
expr_stmt|;
name|addrhead
operator|=
name|p
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|';'
operator|&&
name|copylev
operator|<=
literal|0
operator|&&
operator|!
name|ColonOkInAddr
condition|)
name|SM_APPEND_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* check for characters that may have to be quoted */
if|if
condition|(
name|strchr
argument_list|(
name|MustQuoteChars
argument_list|,
name|c
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 			**  If these occur as the phrase part of a<> 			**  construct, but are not inside of () or already 			**  quoted, they will have to be quoted.  Note that 			**  now (but don't actually do the quoting). 			*/
if|if
condition|(
name|cmtlev
operator|<=
literal|0
operator|&&
operator|!
name|qmode
condition|)
name|quoteit
operator|=
name|true
expr_stmt|;
block|}
comment|/* check for angle brackets */
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
comment|/* assume first of two angles is bogus */
if|if
condition|(
name|gotangle
condition|)
name|quoteit
operator|=
name|true
expr_stmt|;
name|gotangle
operator|=
name|true
expr_stmt|;
comment|/* oops -- have to change our mind */
name|anglelev
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SM_HAVE_ROOM
condition|)
block|{
if|if
condition|(
operator|!
name|addangle
condition|)
name|buflim
operator|--
expr_stmt|;
name|addangle
operator|=
name|true
expr_stmt|;
block|}
name|bp
operator|=
name|bufhead
expr_stmt|;
if|if
condition|(
name|quoteit
condition|)
block|{
name|SM_APPEND_CHAR
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
comment|/* back up over the '<' and any spaces */
operator|--
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|>
name|addr
operator|&&
name|isascii
argument_list|(
operator|*
operator|--
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
continue|continue;
name|p
operator|++
expr_stmt|;
block|}
for|for
control|(
name|q
operator|=
name|addrhead
init|;
name|q
operator|<
name|p
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|q
operator|++
expr_stmt|;
if|if
condition|(
name|quoteit
operator|&&
name|c
operator|==
literal|'"'
condition|)
block|{
name|SM_APPEND_CHAR
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|SM_APPEND_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
name|SM_APPEND_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|quoteit
condition|)
block|{
if|if
condition|(
name|bp
operator|==
operator|&
name|buf
index|[
literal|1
index|]
condition|)
name|bp
operator|--
expr_stmt|;
else|else
name|SM_APPEND_CHAR
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'<'
condition|)
name|SM_APPEND_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|SM_APPEND_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|copylev
operator|=
literal|0
expr_stmt|;
name|putgmac
operator|=
name|quoteit
operator|=
name|false
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
block|{
if|if
condition|(
name|anglelev
operator|>
literal|0
condition|)
block|{
name|anglelev
operator|--
expr_stmt|;
if|if
condition|(
name|SM_HAVE_ROOM
condition|)
block|{
if|if
condition|(
name|addangle
condition|)
name|buflim
operator|++
expr_stmt|;
name|addangle
operator|=
name|false
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|SM_HAVE_ROOM
condition|)
block|{
comment|/* syntax error: unmatched> */
if|if
condition|(
name|copylev
operator|>
literal|0
operator|&&
name|bp
operator|>
name|bufhead
condition|)
name|bp
operator|--
expr_stmt|;
name|quoteit
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|copylev
operator|++
operator|<=
literal|0
condition|)
name|SM_APPEND_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* must be a real address character */
name|putg
label|:
if|if
condition|(
name|copylev
operator|<=
literal|0
operator|&&
operator|!
name|putgmac
condition|)
block|{
if|if
condition|(
name|bp
operator|>
name|buf
operator|&&
name|bp
index|[
operator|-
literal|1
index|]
operator|==
literal|')'
condition|)
name|SM_APPEND_CHAR
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|SM_APPEND_CHAR
argument_list|(
name|MACROEXPAND
argument_list|)
expr_stmt|;
name|SM_APPEND_CHAR
argument_list|(
literal|'g'
argument_list|)
expr_stmt|;
name|putgmac
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* repair any syntactic damage */
if|if
condition|(
name|realqmode
operator|&&
name|bp
operator|<
name|bufend
condition|)
operator|*
name|bp
operator|++
operator|=
literal|'"'
expr_stmt|;
while|while
condition|(
name|realcmtlev
operator|--
operator|>
literal|0
operator|&&
name|bp
operator|<
name|bufend
condition|)
operator|*
name|bp
operator|++
operator|=
literal|')'
expr_stmt|;
if|if
condition|(
name|addangle
operator|&&
name|bp
operator|<
name|bufend
condition|)
operator|*
name|bp
operator|++
operator|=
literal|'>'
expr_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|bp
operator|<
name|bufend
condition|)
goto|goto
name|success
goto|;
name|returng
label|:
comment|/* String too long, punt */
name|buf
index|[
literal|0
index|]
operator|=
literal|'<'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|MACROEXPAND
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|'g'
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
literal|'>'
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_ALERT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Dropped invalid comments from header address"
argument_list|)
expr_stmt|;
name|success
label|:
if|if
condition|(
name|tTd
argument_list|(
literal|33
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"crackaddr=>`"
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"'\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_block

begin_comment
comment|/* **  PUTHEADER -- put the header part of a message from the in-core copy ** **	Parameters: **		mci -- the connection information. **		hdr -- the header to put. **		e -- envelope to use. **		flags -- MIME conversion flags. ** **	Returns: **		true iff header part was written successfully ** **	Side Effects: **		none. */
end_comment

begin_function
name|bool
name|putheader
parameter_list|(
name|mci
parameter_list|,
name|hdr
parameter_list|,
name|e
parameter_list|,
name|flags
parameter_list|)
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
name|HDR
modifier|*
name|hdr
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
specifier|register
name|HDR
modifier|*
name|h
decl_stmt|;
name|char
name|buf
index|[
name|SM_MAX
argument_list|(
name|MAXLINE
argument_list|,
name|BUFSIZ
argument_list|)
index|]
decl_stmt|;
name|char
name|obuf
index|[
name|MAXLINE
index|]
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|34
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"--- putheader, mailer = %s ---\n"
argument_list|,
name|mci
operator|->
name|mci_mailer
operator|->
name|m_name
argument_list|)
expr_stmt|;
comment|/* 	**  If we're in MIME mode, we're not really in the header of the 	**  message, just the header of one of the parts of the body of 	**  the message.  Therefore MCIF_INHEADER should not be turned on. 	*/
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|MCIF_INMIME
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_INHEADER
expr_stmt|;
for|for
control|(
name|h
operator|=
name|hdr
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|h_link
control|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|h
operator|->
name|h_value
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|34
argument_list|,
literal|11
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"  %s:"
argument_list|,
name|h
operator|->
name|h_field
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* Skip empty headers */
if|if
condition|(
name|h
operator|->
name|h_value
operator|==
name|NULL
condition|)
continue|continue;
comment|/* heuristic shortening of MIME fields to avoid MUA overflows */
if|if
condition|(
name|MaxMimeFieldLength
operator|>
literal|0
operator|&&
name|wordinclass
argument_list|(
name|h
operator|->
name|h_field
argument_list|,
name|macid
argument_list|(
literal|"{checkMIMEFieldHeaders}"
argument_list|)
argument_list|)
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|fix_mime_header
argument_list|(
name|h
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_ALERT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Truncated MIME %s header due to field size (length = %ld) (possible attack)"
argument_list|,
name|h
operator|->
name|h_field
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|34
argument_list|,
literal|11
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"  truncated MIME %s header due to field size  (length = %ld) (possible attack)\n"
argument_list|,
name|h
operator|->
name|h_field
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|MaxMimeHeaderLength
operator|>
literal|0
operator|&&
name|wordinclass
argument_list|(
name|h
operator|->
name|h_field
argument_list|,
name|macid
argument_list|(
literal|"{checkMIMETextHeaders}"
argument_list|)
argument_list|)
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|h
operator|->
name|h_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
operator|(
name|size_t
operator|)
name|MaxMimeHeaderLength
condition|)
block|{
name|h
operator|->
name|h_value
index|[
name|MaxMimeHeaderLength
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_ALERT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Truncated long MIME %s header (length = %ld) (possible attack)"
argument_list|,
name|h
operator|->
name|h_field
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|34
argument_list|,
literal|11
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"  truncated long MIME %s header (length = %ld) (possible attack)\n"
argument_list|,
name|h
operator|->
name|h_field
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|MaxMimeHeaderLength
operator|>
literal|0
operator|&&
name|wordinclass
argument_list|(
name|h
operator|->
name|h_field
argument_list|,
name|macid
argument_list|(
literal|"{checkMIMEHeaders}"
argument_list|)
argument_list|)
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|h
operator|->
name|h_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|shorten_rfc822_string
argument_list|(
name|h
operator|->
name|h_value
argument_list|,
name|MaxMimeHeaderLength
argument_list|)
condition|)
block|{
if|if
condition|(
name|len
operator|<
name|MaxMimeHeaderLength
condition|)
block|{
comment|/* we only rebalanced a bogus header */
name|sm_syslog
argument_list|(
name|LOG_ALERT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Fixed MIME %s header (possible attack)"
argument_list|,
name|h
operator|->
name|h_field
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|34
argument_list|,
literal|11
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"  fixed MIME %s header (possible attack)\n"
argument_list|,
name|h
operator|->
name|h_field
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* we actually shortened header */
name|sm_syslog
argument_list|(
name|LOG_ALERT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Truncated long MIME %s header (length = %ld) (possible attack)"
argument_list|,
name|h
operator|->
name|h_field
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|34
argument_list|,
literal|11
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"  truncated long MIME %s header (length = %ld) (possible attack)\n"
argument_list|,
name|h
operator|->
name|h_field
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 		**  Suppress Content-Transfer-Encoding: if we are MIMEing 		**  and we are potentially converting from 8 bit to 7 bit 		**  MIME.  If converting, add a new CTE header in 		**  mime8to7(). 		*/
if|if
condition|(
name|bitset
argument_list|(
name|H_CTE
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
name|bitset
argument_list|(
name|MCIF_CVT8TO7
operator||
name|MCIF_CVT7TO8
operator||
name|MCIF_INMIME
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|M87F_NO8TO7
argument_list|,
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|34
argument_list|,
literal|11
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|" (skipped (content-transfer-encoding))\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_INMIME
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|34
argument_list|,
literal|11
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|put_vanilla_header
argument_list|(
name|h
argument_list|,
name|p
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
continue|continue;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|H_CHECK
operator||
name|H_ACHECK
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
operator|!
name|bitintersect
argument_list|(
name|h
operator|->
name|h_mflags
argument_list|,
name|mci
operator|->
name|mci_mailer
operator|->
name|m_flags
argument_list|)
operator|&&
operator|(
name|h
operator|->
name|h_macro
operator|==
literal|'\0'
operator|||
operator|(
name|q
operator|=
name|macvalue
argument_list|(
name|bitidx
argument_list|(
name|h
operator|->
name|h_macro
argument_list|)
argument_list|,
name|e
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|*
name|q
operator|==
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|34
argument_list|,
literal|11
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|" (skipped)\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* handle Resent-... headers specially */
if|if
condition|(
name|bitset
argument_list|(
name|H_RESENT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_RESENT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|34
argument_list|,
literal|11
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|" (skipped (resent))\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* suppress return receipts if requested */
if|if
condition|(
name|bitset
argument_list|(
name|H_RECEIPTTO
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
operator|(
name|RrtImpliesDsn
operator|||
name|bitset
argument_list|(
name|EF_NORECEIPT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|34
argument_list|,
literal|11
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|" (skipped (receipt))\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* macro expand value if generated internally */
if|if
condition|(
name|bitset
argument_list|(
name|H_DEFAULT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|||
name|bitset
argument_list|(
name|H_BINDLATE
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
block|{
name|expand
argument_list|(
name|p
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|34
argument_list|,
literal|11
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|" (skipped -- null value)\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|bitset
argument_list|(
name|H_BCC
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
block|{
comment|/* Bcc: field -- either truncate or delete */
if|if
condition|(
name|bitset
argument_list|(
name|EF_DELETE_BCC
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|34
argument_list|,
literal|11
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|" (skipped -- bcc)\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* no other recipient headers: truncate value */
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|obuf
argument_list|,
sizeof|sizeof
argument_list|(
name|obuf
argument_list|)
argument_list|,
literal|2
argument_list|,
name|h
operator|->
name|h_field
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|obuf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
continue|continue;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|34
argument_list|,
literal|11
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|H_FROM
operator||
name|H_RCPT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
block|{
comment|/* address field */
name|bool
name|oldstyle
init|=
name|bitset
argument_list|(
name|EF_OLDSTYLE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|H_FROM
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
name|oldstyle
operator|=
name|false
expr_stmt|;
name|commaize
argument_list|(
name|h
argument_list|,
name|p
argument_list|,
name|oldstyle
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|put_vanilla_header
argument_list|(
name|h
argument_list|,
name|p
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
block|}
comment|/* 	**  If we are converting this to a MIME message, add the 	**  MIME headers (but not in MIME mode!). 	*/
if|#
directive|if
name|MIME8TO7
if|if
condition|(
name|bitset
argument_list|(
name|MM_MIME8BIT
argument_list|,
name|MimeMode
argument_list|)
operator|&&
name|bitset
argument_list|(
name|EF_HAS8BIT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_DONT_MIME
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
operator|!
name|bitnset
argument_list|(
name|M_8BITS
argument_list|,
name|mci
operator|->
name|mci_mailer
operator|->
name|m_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|MCIF_CVT8TO7
operator||
name|MCIF_CVT7TO8
operator||
name|MCIF_INMIME
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
operator|&&
name|hvalue
argument_list|(
literal|"MIME-Version"
argument_list|,
name|e
operator|->
name|e_header
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|putline
argument_list|(
literal|"MIME-Version: 1.0"
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
if|if
condition|(
name|hvalue
argument_list|(
literal|"Content-Type"
argument_list|,
name|e
operator|->
name|e_header
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|obuf
argument_list|,
sizeof|sizeof
argument_list|(
name|obuf
argument_list|)
argument_list|,
literal|"Content-Type: text/plain; charset=%s"
argument_list|,
name|defcharset
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|obuf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
if|if
condition|(
name|hvalue
argument_list|(
literal|"Content-Transfer-Encoding"
argument_list|,
name|e
operator|->
name|e_header
argument_list|)
operator|==
name|NULL
operator|&&
operator|!
name|putline
argument_list|(
literal|"Content-Transfer-Encoding: 8bit"
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
endif|#
directive|endif
comment|/* MIME8TO7 */
return|return
name|true
return|;
name|writeerr
label|:
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* **  PUT_VANILLA_HEADER -- output a fairly ordinary header ** **	Parameters: **		h -- the structure describing this header **		v -- the value of this header **		mci -- the connection info for output ** **	Returns: **		true iff header was written successfully */
end_comment

begin_function
specifier|static
name|bool
name|put_vanilla_header
parameter_list|(
name|h
parameter_list|,
name|v
parameter_list|,
name|mci
parameter_list|)
name|HDR
modifier|*
name|h
decl_stmt|;
name|char
modifier|*
name|v
decl_stmt|;
name|MCI
modifier|*
name|mci
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|nlp
decl_stmt|;
specifier|register
name|char
modifier|*
name|obp
decl_stmt|;
name|int
name|putflags
decl_stmt|;
name|char
name|obuf
index|[
name|MAXLINE
operator|+
literal|256
index|]
decl_stmt|;
comment|/* additional length for h_field */
name|putflags
operator|=
name|PXLF_HEADER
operator||
name|PXLF_STRIPMQUOTE
expr_stmt|;
if|if
condition|(
name|bitnset
argument_list|(
name|M_7BITHDRS
argument_list|,
name|mci
operator|->
name|mci_mailer
operator|->
name|m_flags
argument_list|)
condition|)
name|putflags
operator||=
name|PXLF_STRIP8BIT
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|obuf
argument_list|,
sizeof|sizeof
argument_list|(
name|obuf
argument_list|)
argument_list|,
literal|"%.200s:"
argument_list|,
name|h
operator|->
name|h_field
argument_list|)
expr_stmt|;
name|obp
operator|=
name|obuf
operator|+
name|strlen
argument_list|(
name|obuf
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|nlp
operator|=
name|strchr
argument_list|(
name|v
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|l
decl_stmt|;
name|l
operator|=
name|nlp
operator|-
name|v
expr_stmt|;
comment|/* 		**  XXX This is broken for SPACELEFT()==0 		**  However, SPACELEFT() is always> 0 unless MAXLINE==1. 		*/
if|if
condition|(
name|SPACELEFT
argument_list|(
name|obuf
argument_list|,
name|obp
argument_list|)
operator|-
literal|1
operator|<
operator|(
name|size_t
operator|)
name|l
condition|)
name|l
operator|=
name|SPACELEFT
argument_list|(
name|obuf
argument_list|,
name|obp
argument_list|)
operator|-
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|obp
argument_list|,
name|SPACELEFT
argument_list|(
name|obuf
argument_list|,
name|obp
argument_list|)
argument_list|,
literal|"%.*s"
argument_list|,
name|l
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putxline
argument_list|(
name|obuf
argument_list|,
name|strlen
argument_list|(
name|obuf
argument_list|)
argument_list|,
name|mci
argument_list|,
name|putflags
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
name|v
operator|+=
name|l
operator|+
literal|1
expr_stmt|;
name|obp
operator|=
name|obuf
expr_stmt|;
if|if
condition|(
operator|*
name|v
operator|!=
literal|' '
operator|&&
operator|*
name|v
operator|!=
literal|'\t'
condition|)
operator|*
name|obp
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
comment|/* XXX This is broken for SPACELEFT()==0 */
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|obp
argument_list|,
name|SPACELEFT
argument_list|(
name|obuf
argument_list|,
name|obp
argument_list|)
argument_list|,
literal|"%.*s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|SPACELEFT
argument_list|(
name|obuf
argument_list|,
name|obp
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
name|putxline
argument_list|(
name|obuf
argument_list|,
name|strlen
argument_list|(
name|obuf
argument_list|)
argument_list|,
name|mci
argument_list|,
name|putflags
argument_list|)
return|;
name|writeerr
label|:
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* **  COMMAIZE -- output a header field, making a comma-translated list. ** **	Parameters: **		h -- the header field to output. **		p -- the value to put in it. **		oldstyle -- true if this is an old style header. **		mci -- the connection information. **		e -- the envelope containing the message. ** **	Returns: **		true iff header field was written successfully ** **	Side Effects: **		outputs "p" to "mci". */
end_comment

begin_function
name|bool
name|commaize
parameter_list|(
name|h
parameter_list|,
name|p
parameter_list|,
name|oldstyle
parameter_list|,
name|mci
parameter_list|,
name|e
parameter_list|)
specifier|register
name|HDR
modifier|*
name|h
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|bool
name|oldstyle
decl_stmt|;
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|obp
decl_stmt|;
name|int
name|opos
decl_stmt|,
name|omax
decl_stmt|,
name|spaces
decl_stmt|;
name|bool
name|firstone
init|=
name|true
decl_stmt|;
name|int
name|putflags
init|=
name|PXLF_HEADER
operator||
name|PXLF_STRIPMQUOTE
decl_stmt|;
name|char
modifier|*
modifier|*
name|res
decl_stmt|;
name|char
name|obuf
index|[
name|MAXLINE
operator|+
literal|3
index|]
decl_stmt|;
comment|/* 	**  Output the address list translated by the 	**  mailer and with commas. 	*/
if|if
condition|(
name|tTd
argument_list|(
literal|14
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"commaize(%s:%s)\n"
argument_list|,
name|h
operator|->
name|h_field
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitnset
argument_list|(
name|M_7BITHDRS
argument_list|,
name|mci
operator|->
name|mci_mailer
operator|->
name|m_flags
argument_list|)
condition|)
name|putflags
operator||=
name|PXLF_STRIP8BIT
expr_stmt|;
name|obp
operator|=
name|obuf
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|obp
argument_list|,
name|SPACELEFT
argument_list|(
name|obuf
argument_list|,
name|obp
argument_list|)
argument_list|,
literal|"%.200s:"
argument_list|,
name|h
operator|->
name|h_field
argument_list|)
expr_stmt|;
comment|/* opos = strlen(obp); instead of the next 3 lines? */
name|opos
operator|=
name|strlen
argument_list|(
name|h
operator|->
name|h_field
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|opos
operator|>
literal|201
condition|)
name|opos
operator|=
literal|201
expr_stmt|;
name|obp
operator|+=
name|opos
expr_stmt|;
name|spaces
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
operator|++
name|spaces
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
name|spaces
operator|>
literal|0
condition|)
block|{
name|SM_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|obuf
argument_list|)
operator|>
name|opos
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* 		**  Restrict number of spaces to half the length of buffer 		**  so the header field body can be put in here too. 		**  Note: this is a hack... 		*/
if|if
condition|(
name|spaces
operator|>
sizeof|sizeof
argument_list|(
name|obuf
argument_list|)
operator|/
literal|2
condition|)
name|spaces
operator|=
sizeof|sizeof
argument_list|(
name|obuf
argument_list|)
operator|/
literal|2
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|obp
argument_list|,
name|SPACELEFT
argument_list|(
name|obuf
argument_list|,
name|obp
argument_list|)
argument_list|,
literal|"%*s"
argument_list|,
name|spaces
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|opos
operator|+=
name|spaces
expr_stmt|;
name|obp
operator|+=
name|spaces
expr_stmt|;
name|SM_ASSERT
argument_list|(
name|obp
operator|<
operator|&
name|obuf
index|[
name|MAXLINE
index|]
argument_list|)
expr_stmt|;
block|}
name|omax
operator|=
name|mci
operator|->
name|mci_mailer
operator|->
name|m_linelimit
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|omax
operator|<
literal|0
operator|||
name|omax
operator|>
literal|78
condition|)
name|omax
operator|=
literal|78
expr_stmt|;
comment|/* 	**  Run through the list of values. 	*/
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
name|savechar
decl_stmt|;
name|int
name|flags
decl_stmt|;
specifier|auto
name|int
name|status
decl_stmt|;
comment|/* 		**  Find the end of the name.  New style names 		**  end with a comma, old style names end with 		**  a space character.  However, spaces do not 		**  necessarily delimit an old-style name -- at 		**  signs mean keep going. 		*/
comment|/* find end of name */
while|while
condition|(
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|||
operator|*
name|p
operator|==
literal|','
condition|)
name|p
operator|++
expr_stmt|;
name|name
operator|=
name|p
expr_stmt|;
name|res
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|auto
name|char
modifier|*
name|oldp
decl_stmt|;
name|char
name|pvpbuf
index|[
name|PSBUFSIZE
index|]
decl_stmt|;
name|res
operator|=
name|prescan
argument_list|(
name|p
argument_list|,
name|oldstyle
condition|?
literal|' '
else|:
literal|','
argument_list|,
name|pvpbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pvpbuf
argument_list|)
argument_list|,
operator|&
name|oldp
argument_list|,
name|ExtTokenTab
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|p
operator|=
name|oldp
expr_stmt|;
if|#
directive|if
name|_FFR_IGNORE_BOGUS_ADDR
comment|/* ignore addresses that can't be parsed */
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|name
operator|=
name|p
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* _FFR_IGNORE_BOGUS_ADDR */
comment|/* look to see if we have an at sign */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'@'
condition|)
block|{
name|p
operator|=
name|oldp
expr_stmt|;
break|break;
block|}
operator|++
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
block|}
comment|/* at the end of one complete name */
comment|/* strip off trailing white space */
while|while
condition|(
name|p
operator|>=
name|name
operator|&&
operator|(
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|||
operator|*
name|p
operator|==
literal|','
operator|||
operator|*
name|p
operator|==
literal|'\0'
operator|)
condition|)
name|p
operator|--
expr_stmt|;
if|if
condition|(
operator|++
name|p
operator|==
name|name
condition|)
continue|continue;
comment|/* 		**  if prescan() failed go a bit backwards; this is a hack, 		**  there should be some better error recovery. 		*/
if|if
condition|(
name|res
operator|==
name|NULL
operator|&&
name|p
operator|>
name|name
operator|&&
operator|!
operator|(
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|||
operator|*
name|p
operator|==
literal|','
operator|||
operator|*
name|p
operator|==
literal|'\0'
operator|)
condition|)
operator|--
name|p
expr_stmt|;
name|savechar
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* translate the name to be relative */
name|flags
operator|=
name|RF_HEADERADDR
operator||
name|RF_ADDDOMAIN
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|H_FROM
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
name|flags
operator||=
name|RF_SENDERADDR
expr_stmt|;
if|#
directive|if
name|USERDB
elseif|else
if|if
condition|(
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|!=
name|NULL
operator|&&
name|bitnset
argument_list|(
name|M_UDBRECIPIENT
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|->
name|m_flags
argument_list|)
condition|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|udbsender
argument_list|(
name|name
argument_list|,
name|e
operator|->
name|e_rpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
name|name
operator|=
name|q
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USERDB */
name|status
operator|=
name|EX_OK
expr_stmt|;
name|name
operator|=
name|remotename
argument_list|(
name|name
argument_list|,
name|mci
operator|->
name|mci_mailer
argument_list|,
name|flags
argument_list|,
operator|&
name|status
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|p
operator|=
name|savechar
expr_stmt|;
continue|continue;
block|}
name|name
operator|=
name|denlstring
argument_list|(
name|name
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* output the name with nice formatting */
name|opos
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|firstone
condition|)
name|opos
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|opos
operator|>
name|omax
operator|&&
operator|!
name|firstone
condition|)
block|{
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|obp
argument_list|,
literal|",\n"
argument_list|,
name|SPACELEFT
argument_list|(
name|obuf
argument_list|,
name|obp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putxline
argument_list|(
name|obuf
argument_list|,
name|strlen
argument_list|(
name|obuf
argument_list|)
argument_list|,
name|mci
argument_list|,
name|putflags
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
name|obp
operator|=
name|obuf
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|obp
argument_list|,
literal|"        "
argument_list|,
sizeof|sizeof
argument_list|(
name|obuf
argument_list|)
argument_list|)
expr_stmt|;
name|opos
operator|=
name|strlen
argument_list|(
name|obp
argument_list|)
expr_stmt|;
name|obp
operator|+=
name|opos
expr_stmt|;
name|opos
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|firstone
condition|)
block|{
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|obp
argument_list|,
literal|", "
argument_list|,
name|SPACELEFT
argument_list|(
name|obuf
argument_list|,
name|obp
argument_list|)
argument_list|)
expr_stmt|;
name|obp
operator|+=
literal|2
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|name
operator|++
operator|)
operator|!=
literal|'\0'
operator|&&
name|obp
operator|<
operator|&
name|obuf
index|[
name|MAXLINE
index|]
condition|)
operator|*
name|obp
operator|++
operator|=
name|c
expr_stmt|;
name|firstone
operator|=
name|false
expr_stmt|;
operator|*
name|p
operator|=
name|savechar
expr_stmt|;
block|}
if|if
condition|(
name|obp
operator|<
operator|&
name|obuf
index|[
sizeof|sizeof
argument_list|(
name|obuf
argument_list|)
index|]
condition|)
operator|*
name|obp
operator|=
literal|'\0'
expr_stmt|;
else|else
name|obuf
index|[
sizeof|sizeof
argument_list|(
name|obuf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|putxline
argument_list|(
name|obuf
argument_list|,
name|strlen
argument_list|(
name|obuf
argument_list|)
argument_list|,
name|mci
argument_list|,
name|putflags
argument_list|)
return|;
name|writeerr
label|:
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* **  COPYHEADER -- copy header list ** **	This routine is the equivalent of newstr for header lists ** **	Parameters: **		header -- list of header structures to copy. **		rpool -- resource pool, or NULL ** **	Returns: **		a copy of 'header'. ** **	Side Effects: **		none. */
end_comment

begin_function
name|HDR
modifier|*
name|copyheader
parameter_list|(
name|header
parameter_list|,
name|rpool
parameter_list|)
specifier|register
name|HDR
modifier|*
name|header
decl_stmt|;
name|SM_RPOOL_T
modifier|*
name|rpool
decl_stmt|;
block|{
specifier|register
name|HDR
modifier|*
name|newhdr
decl_stmt|;
name|HDR
modifier|*
name|ret
decl_stmt|;
specifier|register
name|HDR
modifier|*
modifier|*
name|tail
init|=
operator|&
name|ret
decl_stmt|;
while|while
condition|(
name|header
operator|!=
name|NULL
condition|)
block|{
name|newhdr
operator|=
operator|(
name|HDR
operator|*
operator|)
name|sm_rpool_malloc_x
argument_list|(
name|rpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|newhdr
argument_list|)
argument_list|)
expr_stmt|;
name|STRUCTCOPY
argument_list|(
operator|*
name|header
argument_list|,
operator|*
name|newhdr
argument_list|)
expr_stmt|;
operator|*
name|tail
operator|=
name|newhdr
expr_stmt|;
name|tail
operator|=
operator|&
name|newhdr
operator|->
name|h_link
expr_stmt|;
name|header
operator|=
name|header
operator|->
name|h_link
expr_stmt|;
block|}
operator|*
name|tail
operator|=
name|NULL
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* **  FIX_MIME_HEADER -- possibly truncate/rebalance parameters in a MIME header ** **	Run through all of the parameters of a MIME header and **	possibly truncate and rebalance the parameter according **	to MaxMimeFieldLength. ** **	Parameters: **		h -- the header to truncate/rebalance **		e -- the current envelope ** **	Returns: **		length of last offending field, 0 if all ok. ** **	Side Effects: **		string modified in place */
end_comment

begin_function
specifier|static
name|size_t
name|fix_mime_header
parameter_list|(
name|h
parameter_list|,
name|e
parameter_list|)
name|HDR
modifier|*
name|h
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|char
modifier|*
name|begin
init|=
name|h
operator|->
name|h_value
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
name|size_t
name|retlen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|begin
operator|==
name|NULL
operator|||
operator|*
name|begin
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
comment|/* Split on each ';' */
comment|/* find_character() never returns NULL */
while|while
condition|(
operator|(
name|end
operator|=
name|find_character
argument_list|(
name|begin
argument_list|,
literal|';'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
name|save
init|=
operator|*
name|end
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|begin
argument_list|)
expr_stmt|;
comment|/* Shorten individual parameter */
if|if
condition|(
name|shorten_rfc822_string
argument_list|(
name|begin
argument_list|,
name|MaxMimeFieldLength
argument_list|)
condition|)
block|{
if|if
condition|(
name|len
operator|<
name|MaxMimeFieldLength
condition|)
block|{
comment|/* we only rebalanced a bogus field */
name|sm_syslog
argument_list|(
name|LOG_ALERT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Fixed MIME %s header field (possible attack)"
argument_list|,
name|h
operator|->
name|h_field
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|34
argument_list|,
literal|11
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"  fixed MIME %s header field (possible attack)\n"
argument_list|,
name|h
operator|->
name|h_field
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* we actually shortened the header */
name|retlen
operator|=
name|len
expr_stmt|;
block|}
block|}
comment|/* Collapse the possibly shortened string with rest */
name|bp
operator|=
name|begin
operator|+
name|strlen
argument_list|(
name|begin
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|end
condition|)
block|{
name|char
modifier|*
name|ep
init|=
name|end
decl_stmt|;
operator|*
name|end
operator|=
name|save
expr_stmt|;
name|end
operator|=
name|bp
expr_stmt|;
comment|/* copy character by character due to overlap */
while|while
condition|(
operator|*
name|ep
operator|!=
literal|'\0'
condition|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|ep
operator|++
expr_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
operator|*
name|end
operator|=
name|save
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|==
literal|'\0'
condition|)
break|break;
comment|/* Move past ';' */
name|begin
operator|=
name|end
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|retlen
return|;
block|}
end_function

end_unit

