begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2003 Proofpoint, Inc. and its suppliers.  *	All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  * Contributed by Jose Marcio Martins da Cruz - Ecole des Mines de Paris  *   Jose-Marcio.Martins@ensmp.fr  */
end_comment

begin_comment
comment|/* a part of this code is based on inetd.c for which this copyright applies: */
end_comment

begin_comment
comment|/*  * Copyright (c) 1983, 1991, 1993, 1994  *      The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by the University of  *      California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sendmail.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: ratectrl.c,v 8.14 2013/11/22 20:51:56 ca Exp $"
argument_list|)
end_macro

begin_comment
comment|/* **  stuff included - given some warnings (inet_ntoa) **	- surely not everything is needed */
end_comment

begin_if
if|#
directive|if
name|NETINET
operator|||
name|NETINET6
end_if

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NETINET || NETINET6 */
end_comment

begin_include
include|#
directive|include
file|<sm/time.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HASH_ALG
end_ifndef

begin_define
define|#
directive|define
name|HASH_ALG
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HASH_ALG */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RATECTL_DEBUG
end_ifndef

begin_define
define|#
directive|define
name|RATECTL_DEBUG
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RATECTL_DEBUG */
end_comment

begin_comment
comment|/* forward declarations */
end_comment

begin_decl_stmt
specifier|static
name|int
name|client_rate
name|__P
argument_list|(
operator|(
name|time_t
operator|,
name|SOCKADDR
operator|*
operator|,
name|bool
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_rate
name|__P
argument_list|(
operator|(
name|time_t
operator|,
name|bool
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  CONNECTION_RATE_CHECK - updates connection history data **      and computes connection rate for the given host ** **    Parameters: **      hostaddr -- ip address of smtp client **      e -- envelope ** **    Returns: **      true (always) ** **    Side Effects: **      updates connection history ** **    Warnings: **      For each connection, this call shall be **      done only once with the value true for the **      update parameter. **      Typically, this call is done with the value **      true by the father, and once again with **      the value false by the children. ** */
end_comment

begin_function
name|bool
name|connection_rate_check
parameter_list|(
name|hostaddr
parameter_list|,
name|e
parameter_list|)
name|SOCKADDR
modifier|*
name|hostaddr
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|time_t
name|now
decl_stmt|;
name|int
name|totalrate
decl_stmt|,
name|clientrate
decl_stmt|;
specifier|static
name|int
name|clientconn
init|=
literal|0
decl_stmt|;
name|now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
name|RATECTL_DEBUG
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"connection_rate_check entering..."
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RATECTL_DEBUG */
comment|/* update server connection rate */
name|totalrate
operator|=
name|total_rate
argument_list|(
name|now
argument_list|,
name|e
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
name|RATECTL_DEBUG
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"global connection rate: %d"
argument_list|,
name|totalrate
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RATECTL_DEBUG */
comment|/* update client connection rate */
name|clientrate
operator|=
name|client_rate
argument_list|(
name|now
argument_list|,
name|hostaddr
argument_list|,
name|e
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|clientconn
operator|=
name|count_open_connections
argument_list|(
name|hostaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|!=
name|NULL
condition|)
block|{
name|char
name|s
index|[
literal|16
index|]
decl_stmt|;
name|sm_snprintf
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|clientrate
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{client_rate}"
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|sm_snprintf
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|totalrate
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{total_rate}"
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|sm_snprintf
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|clientconn
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{client_connections}"
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* **  Data declarations needed to evaluate connection rate */
end_comment

begin_decl_stmt
specifier|static
name|int
name|CollTime
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* this should be a power of 2, otherwise CPMHMASK doesn't work well */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CPMHSIZE
end_ifndef

begin_define
define|#
directive|define
name|CPMHSIZE
value|1024
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CPMHSIZE */
end_comment

begin_define
define|#
directive|define
name|CPMHMASK
value|(CPMHSIZE-1)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_CT_STEPS
end_ifndef

begin_define
define|#
directive|define
name|MAX_CT_STEPS
value|10
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAX_CT_STEPS */
end_comment

begin_comment
comment|/* **  time granularity: 10s (that's one "tick") **  will be initialised to ConnectionRateWindowSize/CHTSIZE **  before being used the first time */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ChtGran
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CHTSIZE
value|6
end_define

begin_comment
comment|/* Number of connections for a certain "tick" */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|CTime
block|{
name|unsigned
name|long
name|ct_Ticks
decl_stmt|;
name|int
name|ct_Count
decl_stmt|;
block|}
name|CTime_T
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|CHash
block|{
if|#
directive|if
name|NETINET6
operator|&&
name|NETINET
union|union
block|{
name|struct
name|in_addr
name|c4_Addr
decl_stmt|;
name|struct
name|in6_addr
name|c6_Addr
decl_stmt|;
block|}
name|cu_Addr
union|;
define|#
directive|define
name|ch_Addr4
value|cu_Addr.c4_Addr
define|#
directive|define
name|ch_Addr6
value|cu_Addr.c6_Addr
else|#
directive|else
comment|/* NETINET6&& NETINET */
if|#
directive|if
name|NETINET6
name|struct
name|in6_addr
name|ch_Addr
decl_stmt|;
define|#
directive|define
name|ch_Addr6
value|ch_Addr
else|#
directive|else
comment|/* NETINET6 */
name|struct
name|in_addr
name|ch_Addr
decl_stmt|;
define|#
directive|define
name|ch_Addr4
value|ch_Addr
endif|#
directive|endif
comment|/* NETINET6 */
endif|#
directive|endif
comment|/* NETINET6&& NETINET */
name|int
name|ch_Family
decl_stmt|;
name|time_t
name|ch_LTime
decl_stmt|;
name|unsigned
name|long
name|ch_colls
decl_stmt|;
comment|/* 6 buckets for ticks: 60s */
name|CTime_T
name|ch_Times
index|[
name|CHTSIZE
index|]
decl_stmt|;
block|}
name|CHash_T
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|CHash_T
name|CHashAry
index|[
name|CPMHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|CHashAryOK
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  CLIENT_RATE - Evaluate connection rate per smtp client ** **	Parameters: **		now - current time in secs **		saddr - client address **		update - update data / check only ** **	Returns: **		connection rate (connections / ConnectionRateWindowSize) ** **	Side effects: **		update static global data ** */
end_comment

begin_function
specifier|static
name|int
name|client_rate
parameter_list|(
name|now
parameter_list|,
name|saddr
parameter_list|,
name|update
parameter_list|)
name|time_t
name|now
decl_stmt|;
name|SOCKADDR
modifier|*
name|saddr
decl_stmt|;
name|bool
name|update
decl_stmt|;
block|{
name|unsigned
name|int
name|hv
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|bool
name|coll
decl_stmt|;
name|CHash_T
modifier|*
name|chBest
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|ticks
decl_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
name|hv
operator|=
literal|0xABC3D20F
expr_stmt|;
if|if
condition|(
name|ChtGran
operator|<
literal|0
condition|)
name|ChtGran
operator|=
name|ConnectionRateWindowSize
operator|/
name|CHTSIZE
expr_stmt|;
if|if
condition|(
name|ChtGran
operator|<=
literal|0
condition|)
name|ChtGran
operator|=
literal|10
expr_stmt|;
name|ticks
operator|=
name|now
operator|/
name|ChtGran
expr_stmt|;
if|if
condition|(
operator|!
name|CHashAryOK
condition|)
block|{
name|memset
argument_list|(
name|CHashAry
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|CHashAry
argument_list|)
argument_list|)
expr_stmt|;
name|CHashAryOK
operator|=
name|true
expr_stmt|;
block|}
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|addrlen
decl_stmt|;
if|#
directive|if
name|HASH_ALG
operator|!=
literal|1
name|int
name|c
decl_stmt|,
name|d
decl_stmt|;
endif|#
directive|endif
comment|/* HASH_ALG != 1 */
switch|switch
condition|(
name|saddr
operator|->
name|sa
operator|.
name|sa_family
condition|)
block|{
if|#
directive|if
name|NETINET
case|case
name|AF_INET
case|:
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|saddr
operator|->
name|sin
operator|.
name|sin_addr
expr_stmt|;
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET6
case|case
name|AF_INET6
case|:
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|saddr
operator|->
name|sin6
operator|.
name|sin6_addr
expr_stmt|;
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET6 */
default|default:
comment|/* should not happen */
return|return
operator|-
literal|1
return|;
block|}
comment|/* compute hash value */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|addrlen
condition|;
operator|++
name|i
operator|,
operator|++
name|p
control|)
if|#
directive|if
name|HASH_ALG
operator|==
literal|1
name|hv
operator|=
operator|(
name|hv
operator|<<
literal|5
operator|)
operator|^
operator|(
name|hv
operator|>>
literal|23
operator|)
operator|^
operator|*
name|p
expr_stmt|;
name|hv
operator|=
operator|(
name|hv
operator|^
operator|(
name|hv
operator|>>
literal|16
operator|)
operator|)
expr_stmt|;
elif|#
directive|elif
name|HASH_ALG
operator|==
literal|2
block|{
name|d
operator|=
operator|*
name|p
expr_stmt|;
name|c
operator|=
name|d
expr_stmt|;
name|c
operator|^=
name|c
operator|<<
literal|6
expr_stmt|;
name|hv
operator|+=
operator|(
name|c
operator|<<
literal|11
operator|)
operator|^
operator|(
name|c
operator|>>
literal|1
operator|)
expr_stmt|;
name|hv
operator|^=
operator|(
name|d
operator|<<
literal|14
operator|)
operator|+
operator|(
name|d
operator|<<
literal|7
operator|)
operator|+
operator|(
name|d
operator|<<
literal|4
operator|)
operator|+
name|d
expr_stmt|;
block|}
elif|#
directive|elif
name|HASH_ALG
operator|==
literal|3
block|{
name|hv
operator|=
operator|(
name|hv
operator|<<
literal|4
operator|)
operator|+
operator|*
name|p
expr_stmt|;
name|d
operator|=
name|hv
operator|&
literal|0xf0000000
expr_stmt|;
if|if
condition|(
name|d
operator|!=
literal|0
condition|)
block|{
name|hv
operator|^=
operator|(
name|d
operator|>>
literal|24
operator|)
expr_stmt|;
name|hv
operator|^=
name|d
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* HASH_ALG == 1 */
name|hv
operator|=
operator|(
operator|(
name|hv
operator|<<
literal|1
operator|)
operator|^
operator|(
operator|*
name|p
operator|&
literal|0377
operator|)
operator|)
operator|%
name|cctx
operator|->
name|cc_size
expr_stmt|;
endif|#
directive|endif
comment|/* HASH_ALG == 1 */
block|}
name|coll
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_CT_STEPS
condition|;
operator|++
name|i
control|)
block|{
name|CHash_T
modifier|*
name|ch
init|=
operator|&
name|CHashAry
index|[
operator|(
name|hv
operator|+
name|i
operator|)
operator|&
name|CPMHMASK
index|]
decl_stmt|;
if|#
directive|if
name|NETINET
if|if
condition|(
name|saddr
operator|->
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
operator|&&
name|ch
operator|->
name|ch_Family
operator|==
name|AF_INET
operator|&&
operator|(
name|saddr
operator|->
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|ch
operator|->
name|ch_Addr4
operator|.
name|s_addr
operator|||
name|ch
operator|->
name|ch_Addr4
operator|.
name|s_addr
operator|==
literal|0
operator|)
condition|)
block|{
name|chBest
operator|=
name|ch
expr_stmt|;
name|coll
operator|=
name|false
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET6
if|if
condition|(
name|saddr
operator|->
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
operator|&&
name|ch
operator|->
name|ch_Family
operator|==
name|AF_INET6
operator|&&
operator|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|saddr
operator|->
name|sin6
operator|.
name|sin6_addr
argument_list|,
operator|&
name|ch
operator|->
name|ch_Addr6
argument_list|)
operator|!=
literal|0
operator|||
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|ch
operator|->
name|ch_Addr6
argument_list|)
operator|)
condition|)
block|{
name|chBest
operator|=
name|ch
expr_stmt|;
name|coll
operator|=
name|false
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* NETINET6 */
if|if
condition|(
name|chBest
operator|==
name|NULL
operator|||
name|ch
operator|->
name|ch_LTime
operator|==
literal|0
operator|||
name|ch
operator|->
name|ch_LTime
operator|<
name|chBest
operator|->
name|ch_LTime
condition|)
name|chBest
operator|=
name|ch
expr_stmt|;
block|}
comment|/* Let's update data... */
if|if
condition|(
name|update
condition|)
block|{
if|if
condition|(
name|coll
operator|&&
operator|(
name|now
operator|-
name|chBest
operator|->
name|ch_LTime
operator|<
name|CollTime
operator|)
condition|)
block|{
comment|/* 			**  increment the number of collisions last 			**  CollTime for this client 			*/
name|chBest
operator|->
name|ch_colls
operator|++
expr_stmt|;
comment|/* 			**  Maybe shall log if collision rate is too high... 			**  and take measures to resize tables 			**  if this is the case 			*/
block|}
comment|/* 		**  If it's not a match, then replace the data. 		**  Note: this purges the history of a colliding entry, 		**  which may cause "overruns", i.e., if two entries are 		**  "cancelling" each other out, then they may exceed 		**  the limits that are set. This might be mitigated a bit 		**  by the above "best of 5" function however. 		** 		**  Alternative approach: just use the old data, which may 		**  cause false positives however. 		**  To activate this, change deactivate following memset call. 		*/
if|if
condition|(
name|coll
condition|)
block|{
if|#
directive|if
name|NETINET
if|if
condition|(
name|saddr
operator|->
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|chBest
operator|->
name|ch_Family
operator|=
name|AF_INET
expr_stmt|;
name|chBest
operator|->
name|ch_Addr4
operator|=
name|saddr
operator|->
name|sin
operator|.
name|sin_addr
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET6
if|if
condition|(
name|saddr
operator|->
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|chBest
operator|->
name|ch_Family
operator|=
name|AF_INET6
expr_stmt|;
name|chBest
operator|->
name|ch_Addr6
operator|=
name|saddr
operator|->
name|sin6
operator|.
name|sin6_addr
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NETINET6 */
if|#
directive|if
literal|1
name|memset
argument_list|(
name|chBest
operator|->
name|ch_Times
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|chBest
operator|->
name|ch_Times
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 1 */
block|}
name|chBest
operator|->
name|ch_LTime
operator|=
name|now
expr_stmt|;
block|{
name|CTime_T
modifier|*
name|ct
init|=
operator|&
name|chBest
operator|->
name|ch_Times
index|[
name|ticks
operator|%
name|CHTSIZE
index|]
decl_stmt|;
if|if
condition|(
name|ct
operator|->
name|ct_Ticks
operator|!=
name|ticks
condition|)
block|{
name|ct
operator|->
name|ct_Ticks
operator|=
name|ticks
expr_stmt|;
name|ct
operator|->
name|ct_Count
operator|=
literal|0
expr_stmt|;
block|}
operator|++
name|ct
operator|->
name|ct_Count
expr_stmt|;
block|}
block|}
comment|/* Now let's count connections on the window */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CHTSIZE
condition|;
operator|++
name|i
control|)
block|{
name|CTime_T
modifier|*
name|ct
init|=
operator|&
name|chBest
operator|->
name|ch_Times
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ct
operator|->
name|ct_Ticks
operator|<=
name|ticks
operator|&&
name|ct
operator|->
name|ct_Ticks
operator|>=
name|ticks
operator|-
name|CHTSIZE
condition|)
name|cnt
operator|+=
name|ct
operator|->
name|ct_Count
expr_stmt|;
block|}
if|#
directive|if
name|RATECTL_DEBUG
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"cln: cnt=(%d), CHTSIZE=(%d), ChtGran=(%d)"
argument_list|,
name|cnt
argument_list|,
name|CHTSIZE
argument_list|,
name|ChtGran
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RATECTL_DEBUG */
return|return
name|cnt
return|;
block|}
end_function

begin_comment
comment|/* **  TOTAL_RATE - Evaluate global connection rate ** **	Parameters: **		now - current time in secs **		update - update data / check only ** **	Returns: **		connection rate (connections / ConnectionRateWindowSize) */
end_comment

begin_decl_stmt
specifier|static
name|CTime_T
name|srv_Times
index|[
name|CHTSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|srv_Times_OK
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|total_rate
parameter_list|(
name|now
parameter_list|,
name|update
parameter_list|)
name|time_t
name|now
decl_stmt|;
name|bool
name|update
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|CTime_T
modifier|*
name|ct
decl_stmt|;
name|unsigned
name|int
name|ticks
decl_stmt|;
if|if
condition|(
name|ChtGran
operator|<
literal|0
condition|)
name|ChtGran
operator|=
name|ConnectionRateWindowSize
operator|/
name|CHTSIZE
expr_stmt|;
if|if
condition|(
name|ChtGran
operator|==
literal|0
condition|)
name|ChtGran
operator|=
literal|10
expr_stmt|;
name|ticks
operator|=
name|now
operator|/
name|ChtGran
expr_stmt|;
if|if
condition|(
operator|!
name|srv_Times_OK
condition|)
block|{
name|memset
argument_list|(
name|srv_Times
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|srv_Times
argument_list|)
argument_list|)
expr_stmt|;
name|srv_Times_OK
operator|=
name|true
expr_stmt|;
block|}
comment|/* Let's update data */
if|if
condition|(
name|update
condition|)
block|{
name|ct
operator|=
operator|&
name|srv_Times
index|[
name|ticks
operator|%
name|CHTSIZE
index|]
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|ct_Ticks
operator|!=
name|ticks
condition|)
block|{
name|ct
operator|->
name|ct_Ticks
operator|=
name|ticks
expr_stmt|;
name|ct
operator|->
name|ct_Count
operator|=
literal|0
expr_stmt|;
block|}
operator|++
name|ct
operator|->
name|ct_Count
expr_stmt|;
block|}
comment|/* Let's count connections on the window */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CHTSIZE
condition|;
operator|++
name|i
control|)
block|{
name|ct
operator|=
operator|&
name|srv_Times
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|ct_Ticks
operator|<=
name|ticks
operator|&&
name|ct
operator|->
name|ct_Ticks
operator|>=
name|ticks
operator|-
name|CHTSIZE
condition|)
name|cnt
operator|+=
name|ct
operator|->
name|ct_Count
expr_stmt|;
block|}
if|#
directive|if
name|RATECTL_DEBUG
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"srv: cnt=(%d), CHTSIZE=(%d), ChtGran=(%d)"
argument_list|,
name|cnt
argument_list|,
name|CHTSIZE
argument_list|,
name|ChtGran
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RATECTL_DEBUG */
return|return
name|cnt
return|;
block|}
end_function

end_unit

