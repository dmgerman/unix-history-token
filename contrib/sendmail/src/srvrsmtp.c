begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998-2006 Sendmail, Inc. and its suppliers.  *	All rights reserved.  * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_include
include|#
directive|include
file|<sendmail.h>
end_include

begin_if
if|#
directive|if
name|MILTER
end_if

begin_include
include|#
directive|include
file|<libmilter/mfapi.h>
end_include

begin_include
include|#
directive|include
file|<libmilter/mfdef.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MILTER */
end_comment

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: srvrsmtp.c,v 8.924.2.2 2006/05/31 20:56:37 ca Exp $"
argument_list|)
end_macro

begin_include
include|#
directive|include
file|<sm/time.h>
end_include

begin_include
include|#
directive|include
file|<sm/fdset.h>
end_include

begin_if
if|#
directive|if
name|SASL
operator|||
name|STARTTLS
end_if

begin_include
include|#
directive|include
file|"sfsasl.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SASL || STARTTLS */
end_comment

begin_if
if|#
directive|if
name|SASL
end_if

begin_define
define|#
directive|define
name|ENC64LEN
parameter_list|(
name|l
parameter_list|)
value|(((l) + 2) * 4 / 3 + 1)
end_define

begin_decl_stmt
specifier|static
name|int
name|saslmechs
name|__P
argument_list|(
operator|(
name|sasl_conn_t
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SASL */
end_comment

begin_if
if|#
directive|if
name|STARTTLS
end_if

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_decl_stmt
specifier|static
name|SSL_CTX
modifier|*
name|srv_ctx
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TLS server context */
end_comment

begin_decl_stmt
specifier|static
name|SSL
modifier|*
name|srv_ssl
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* per connection context */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|tls_ok_srv
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|_FFR_DM_ONE
end_if

begin_decl_stmt
specifier|static
name|bool
name|NotFirstDelivery
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_DM_ONE */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|tls_set_verify
name|__P
argument_list|(
operator|(
name|SSL_CTX
operator|*
operator|,
name|SSL
operator|*
operator|,
name|bool
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TLS_VERIFY_CLIENT
parameter_list|()
value|tls_set_verify(srv_ctx, srv_ssl, \ 				bitset(SRV_VRFY_CLT, features))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STARTTLS */
end_comment

begin_comment
comment|/* server features */
end_comment

begin_define
define|#
directive|define
name|SRV_NONE
value|0x0000
end_define

begin_comment
comment|/* none... */
end_comment

begin_define
define|#
directive|define
name|SRV_OFFER_TLS
value|0x0001
end_define

begin_comment
comment|/* offer STARTTLS */
end_comment

begin_define
define|#
directive|define
name|SRV_VRFY_CLT
value|0x0002
end_define

begin_comment
comment|/* request a cert */
end_comment

begin_define
define|#
directive|define
name|SRV_OFFER_AUTH
value|0x0004
end_define

begin_comment
comment|/* offer AUTH */
end_comment

begin_define
define|#
directive|define
name|SRV_OFFER_ETRN
value|0x0008
end_define

begin_comment
comment|/* offer ETRN */
end_comment

begin_define
define|#
directive|define
name|SRV_OFFER_VRFY
value|0x0010
end_define

begin_comment
comment|/* offer VRFY (not yet used) */
end_comment

begin_define
define|#
directive|define
name|SRV_OFFER_EXPN
value|0x0020
end_define

begin_comment
comment|/* offer EXPN */
end_comment

begin_define
define|#
directive|define
name|SRV_OFFER_VERB
value|0x0040
end_define

begin_comment
comment|/* offer VERB */
end_comment

begin_define
define|#
directive|define
name|SRV_OFFER_DSN
value|0x0080
end_define

begin_comment
comment|/* offer DSN */
end_comment

begin_if
if|#
directive|if
name|PIPELINING
end_if

begin_define
define|#
directive|define
name|SRV_OFFER_PIPE
value|0x0100
end_define

begin_comment
comment|/* offer PIPELINING */
end_comment

begin_if
if|#
directive|if
name|_FFR_NO_PIPE
end_if

begin_define
define|#
directive|define
name|SRV_NO_PIPE
value|0x0200
end_define

begin_comment
comment|/* disable PIPELINING, sleep if used */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_NO_PIPE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PIPELINING */
end_comment

begin_define
define|#
directive|define
name|SRV_REQ_AUTH
value|0x0400
end_define

begin_comment
comment|/* require AUTH */
end_comment

begin_define
define|#
directive|define
name|SRV_REQ_SEC
value|0x0800
end_define

begin_comment
comment|/* require security - equiv to AuthOptions=p */
end_comment

begin_define
define|#
directive|define
name|SRV_TMP_FAIL
value|0x1000
end_define

begin_comment
comment|/* ruleset caused a temporary failure */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|srvfeatures
name|__P
argument_list|(
operator|(
name|ENVELOPE
operator|*
operator|,
name|char
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|STOP_ATTACK
value|((time_t) -1)
end_define

begin_decl_stmt
specifier|static
name|time_t
name|checksmtpattack
name|__P
argument_list|(
operator|(
specifier|volatile
name|unsigned
name|int
operator|*
operator|,
name|unsigned
name|int
operator|,
name|bool
operator|,
name|char
operator|*
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mail_esmtp_args
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|ENVELOPE
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|printvrfyaddr
name|__P
argument_list|(
operator|(
name|ADDRESS
operator|*
operator|,
name|bool
operator|,
name|bool
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rcpt_esmtp_args
name|__P
argument_list|(
operator|(
name|ADDRESS
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|ENVELOPE
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|skipword
name|__P
argument_list|(
operator|(
name|char
operator|*
specifier|volatile
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|setup_smtpd_io
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|SASL
end_if

begin_if
if|#
directive|if
name|SASL
operator|>=
literal|20000
end_if

begin_decl_stmt
specifier|static
name|int
name|reset_saslconn
name|__P
argument_list|(
operator|(
name|sasl_conn_t
operator|*
operator|*
name|_conn
operator|,
name|char
operator|*
name|_hostname
operator|,
name|char
operator|*
name|_remoteip
operator|,
name|char
operator|*
name|_localip
operator|,
name|char
operator|*
name|_auth_id
operator|,
name|sasl_ssf_t
operator|*
name|_ext_ssf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RESET_SASLCONN
define|\
value|do							\ 	{							\ 		result = reset_saslconn(&conn, AuthRealm, remoteip, \ 					localip, auth_id,&ext_ssf); \ 		if (result != SASL_OK)				\ 			sasl_ok = false;			\ 	} while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SASL>= 20000 */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reset_saslconn
name|__P
argument_list|(
operator|(
name|sasl_conn_t
operator|*
operator|*
name|_conn
operator|,
name|char
operator|*
name|_hostname
operator|,
expr|struct
name|sockaddr_in
operator|*
name|_saddr_r
operator|,
expr|struct
name|sockaddr_in
operator|*
name|_saddr_l
operator|,
name|sasl_external_properties_t
operator|*
name|_ext_ssf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RESET_SASLCONN
define|\
value|do							\ 	{							\ 		result = reset_saslconn(&conn, AuthRealm,&saddr_r, \&saddr_l,&ext_ssf);	\ 		if (result != SASL_OK)				\ 			sasl_ok = false;			\ 	} while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SASL>= 20000 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SASL */
end_comment

begin_decl_stmt
specifier|extern
name|ENVELOPE
name|BlankEnvelope
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NBADRCPTS
define|\
value|do							\ 	{							\ 		char buf[16];					\ 		(void) sm_snprintf(buf, sizeof buf, "%d",	\ 			BadRcptThrottle> 0&& n_badrcpts> BadRcptThrottle \ 				? n_badrcpts - 1 : n_badrcpts);	\ 		macdefine(&e->e_macro, A_TEMP, macid("{nbadrcpts}"), buf); \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|SKIP_SPACE
parameter_list|(
name|s
parameter_list|)
value|while (isascii(*s)&& isspace(*s))	\ 				(s)++
end_define

begin_comment
comment|/* **  SMTP -- run the SMTP protocol. ** **	Parameters: **		nullserver -- if non-NULL, rejection message for **			(almost) all SMTP commands. **		d_flags -- daemon flags **		e -- the envelope. ** **	Returns: **		never. ** **	Side Effects: **		Reads commands from the input channel and processes them. */
end_comment

begin_comment
comment|/* **  Notice: The smtp server doesn't have a session context like the client **	side has (mci). Therefore some data (session oriented) is allocated **	or assigned to the "wrong" structure (esp. STARTTLS, AUTH). **	This should be fixed in a successor version. */
end_comment

begin_struct
struct|struct
name|cmd
block|{
name|char
modifier|*
name|cmd_name
decl_stmt|;
comment|/* command name */
name|int
name|cmd_code
decl_stmt|;
comment|/* internal code, see below */
block|}
struct|;
end_struct

begin_comment
comment|/* values for cmd_code */
end_comment

begin_define
define|#
directive|define
name|CMDERROR
value|0
end_define

begin_comment
comment|/* bad command */
end_comment

begin_define
define|#
directive|define
name|CMDMAIL
value|1
end_define

begin_comment
comment|/* mail -- designate sender */
end_comment

begin_define
define|#
directive|define
name|CMDRCPT
value|2
end_define

begin_comment
comment|/* rcpt -- designate recipient */
end_comment

begin_define
define|#
directive|define
name|CMDDATA
value|3
end_define

begin_comment
comment|/* data -- send message text */
end_comment

begin_define
define|#
directive|define
name|CMDRSET
value|4
end_define

begin_comment
comment|/* rset -- reset state */
end_comment

begin_define
define|#
directive|define
name|CMDVRFY
value|5
end_define

begin_comment
comment|/* vrfy -- verify address */
end_comment

begin_define
define|#
directive|define
name|CMDEXPN
value|6
end_define

begin_comment
comment|/* expn -- expand address */
end_comment

begin_define
define|#
directive|define
name|CMDNOOP
value|7
end_define

begin_comment
comment|/* noop -- do nothing */
end_comment

begin_define
define|#
directive|define
name|CMDQUIT
value|8
end_define

begin_comment
comment|/* quit -- close connection and die */
end_comment

begin_define
define|#
directive|define
name|CMDHELO
value|9
end_define

begin_comment
comment|/* helo -- be polite */
end_comment

begin_define
define|#
directive|define
name|CMDHELP
value|10
end_define

begin_comment
comment|/* help -- give usage info */
end_comment

begin_define
define|#
directive|define
name|CMDEHLO
value|11
end_define

begin_comment
comment|/* ehlo -- extended helo (RFC 1425) */
end_comment

begin_define
define|#
directive|define
name|CMDETRN
value|12
end_define

begin_comment
comment|/* etrn -- flush queue */
end_comment

begin_if
if|#
directive|if
name|SASL
end_if

begin_define
define|#
directive|define
name|CMDAUTH
value|13
end_define

begin_comment
comment|/* auth -- SASL authenticate */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SASL */
end_comment

begin_if
if|#
directive|if
name|STARTTLS
end_if

begin_define
define|#
directive|define
name|CMDSTLS
value|14
end_define

begin_comment
comment|/* STARTTLS -- start TLS session */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STARTTLS */
end_comment

begin_comment
comment|/* non-standard commands */
end_comment

begin_define
define|#
directive|define
name|CMDVERB
value|17
end_define

begin_comment
comment|/* verb -- go into verbose mode */
end_comment

begin_comment
comment|/* unimplemented commands from RFC 821 */
end_comment

begin_define
define|#
directive|define
name|CMDUNIMPL
value|19
end_define

begin_comment
comment|/* unimplemented rfc821 commands */
end_comment

begin_comment
comment|/* use this to catch and log "door handle" attempts on your system */
end_comment

begin_define
define|#
directive|define
name|CMDLOGBOGUS
value|23
end_define

begin_comment
comment|/* bogus command that should be logged */
end_comment

begin_comment
comment|/* debugging-only commands, only enabled if SMTPDEBUG is defined */
end_comment

begin_define
define|#
directive|define
name|CMDDBGQSHOW
value|24
end_define

begin_comment
comment|/* showq -- show send queue */
end_comment

begin_define
define|#
directive|define
name|CMDDBGDEBUG
value|25
end_define

begin_comment
comment|/* debug -- set debug mode */
end_comment

begin_comment
comment|/* **  Note: If you change this list, remember to update 'helpfile' */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cmd
name|CmdTab
index|[]
init|=
block|{
block|{
literal|"mail"
block|,
name|CMDMAIL
block|}
block|,
block|{
literal|"rcpt"
block|,
name|CMDRCPT
block|}
block|,
block|{
literal|"data"
block|,
name|CMDDATA
block|}
block|,
block|{
literal|"rset"
block|,
name|CMDRSET
block|}
block|,
block|{
literal|"vrfy"
block|,
name|CMDVRFY
block|}
block|,
block|{
literal|"expn"
block|,
name|CMDEXPN
block|}
block|,
block|{
literal|"help"
block|,
name|CMDHELP
block|}
block|,
block|{
literal|"noop"
block|,
name|CMDNOOP
block|}
block|,
block|{
literal|"quit"
block|,
name|CMDQUIT
block|}
block|,
block|{
literal|"helo"
block|,
name|CMDHELO
block|}
block|,
block|{
literal|"ehlo"
block|,
name|CMDEHLO
block|}
block|,
block|{
literal|"etrn"
block|,
name|CMDETRN
block|}
block|,
block|{
literal|"verb"
block|,
name|CMDVERB
block|}
block|,
block|{
literal|"send"
block|,
name|CMDUNIMPL
block|}
block|,
block|{
literal|"saml"
block|,
name|CMDUNIMPL
block|}
block|,
block|{
literal|"soml"
block|,
name|CMDUNIMPL
block|}
block|,
block|{
literal|"turn"
block|,
name|CMDUNIMPL
block|}
block|,
if|#
directive|if
name|SASL
block|{
literal|"auth"
block|,
name|CMDAUTH
block|,	}
block|,
endif|#
directive|endif
comment|/* SASL */
if|#
directive|if
name|STARTTLS
block|{
literal|"starttls"
block|,
name|CMDSTLS
block|,	}
block|,
endif|#
directive|endif
comment|/* STARTTLS */
comment|/* remaining commands are here only to trap and log attempts to use them */
block|{
literal|"showq"
block|,
name|CMDDBGQSHOW
block|}
block|,
block|{
literal|"debug"
block|,
name|CMDDBGDEBUG
block|}
block|,
block|{
literal|"wiz"
block|,
name|CMDLOGBOGUS
block|}
block|,
block|{
name|NULL
block|,
name|CMDERROR
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|CurSmtpClient
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* who's at the other end of channel */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAXBADCOMMANDS
end_ifndef

begin_define
define|#
directive|define
name|MAXBADCOMMANDS
value|25
end_define

begin_comment
comment|/* maximum number of bad commands */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! MAXBADCOMMANDS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAXHELOCOMMANDS
end_ifndef

begin_define
define|#
directive|define
name|MAXHELOCOMMANDS
value|3
end_define

begin_comment
comment|/* max HELO/EHLO commands before slowdown */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! MAXHELOCOMMANDS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAXVRFYCOMMANDS
end_ifndef

begin_define
define|#
directive|define
name|MAXVRFYCOMMANDS
value|6
end_define

begin_comment
comment|/* max VRFY/EXPN commands before slowdown */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! MAXVRFYCOMMANDS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAXETRNCOMMANDS
end_ifndef

begin_define
define|#
directive|define
name|MAXETRNCOMMANDS
value|8
end_define

begin_comment
comment|/* max ETRN commands before slowdown */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! MAXETRNCOMMANDS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAXTIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|MAXTIMEOUT
value|(4 * 60)
end_define

begin_comment
comment|/* max timeout for bad commands */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! MAXTIMEOUT */
end_comment

begin_comment
comment|/* **  Maximum shift value to compute timeout for bad commands. **  This introduces an upper limit of 2^MAXSHIFT for the timeout. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAXSHIFT
end_ifndef

begin_define
define|#
directive|define
name|MAXSHIFT
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! MAXSHIFT */
end_comment

begin_if
if|#
directive|if
name|MAXSHIFT
operator|>
literal|31
end_if

begin_expr_stmt
name|ERROR
name|_MAXSHIFT
operator|>
literal|31
name|is
name|invalid
endif|#
directive|endif
comment|/* MAXSHIFT */
if|#
directive|if
name|MAXBADCOMMANDS
operator|>
literal|0
define|#
directive|define
name|STOP_IF_ATTACK
parameter_list|(
name|r
parameter_list|)
value|do		\ 	{					\ 		if ((r) == STOP_ATTACK)		\ 			goto stopattack;	\ 	} while (0)
else|#
directive|else
comment|/* MAXBADCOMMANDS> 0 */
define|#
directive|define
name|STOP_IF_ATTACK
parameter_list|(
name|r
parameter_list|)
value|r
endif|#
directive|endif
comment|/* MAXBADCOMMANDS> 0 */
if|#
directive|if
name|SM_HEAP_CHECK
specifier|static
name|SM_DEBUG_T
name|DebugLeakSmtp
operator|=
name|SM_DEBUG_INITIALIZER
argument_list|(
literal|"leak_smtp"
argument_list|,
literal|"@(#)$Debug: leak_smtp - trace memory leaks during SMTP processing $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SM_HEAP_CHECK */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|bool
name|sm_gotmail
decl_stmt|;
comment|/* mail command received */
name|unsigned
name|int
name|sm_nrcpts
decl_stmt|;
comment|/* number of successful RCPT commands */
name|bool
name|sm_discard
decl_stmt|;
if|#
directive|if
name|MILTER
name|bool
name|sm_milterize
decl_stmt|;
name|bool
name|sm_milterlist
decl_stmt|;
comment|/* any filters in the list? */
endif|#
directive|endif
comment|/* MILTER */
name|char
modifier|*
name|sm_quarmsg
decl_stmt|;
comment|/* carry quarantining across messages */
block|}
name|SMTP_T
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|bool
name|smtp_data
name|__P
argument_list|(
operator|(
name|SMTP_T
operator|*
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MSG_TEMPFAIL
value|"451 4.3.2 Please try again later"
end_define

begin_if
if|#
directive|if
name|MILTER
end_if

begin_define
define|#
directive|define
name|MILTER_ABORT
parameter_list|(
name|e
parameter_list|)
value|milter_abort((e))
end_define

begin_define
define|#
directive|define
name|MILTER_REPLY
parameter_list|(
name|str
parameter_list|)
define|\
value|{								\ 		int savelogusrerrs = LogUsrErrs;			\ 									\ 		switch (state)						\ 		{							\ 		  case SMFIR_SHUTDOWN:					\ 			if (MilterLogLevel> 3)				\ 			{						\ 				sm_syslog(LOG_INFO, e->e_id,		\ 					  "Milter: %s=%s, reject=421, errormode=4",	\ 					  str, addr);			\ 				LogUsrErrs = false;			\ 			}						\ 			{						\ 				bool tsave = QuickAbort;		\ 									\ 				QuickAbort = false;			\ 				usrerr("421 4.3.0 closing connection");	\ 				QuickAbort = tsave;			\ 				e->e_sendqueue = NULL;			\ 				goto doquit;				\ 			}						\ 			break;						\ 		  case SMFIR_REPLYCODE:					\ 			if (MilterLogLevel> 3)				\ 			{						\ 				sm_syslog(LOG_INFO, e->e_id,		\ 					  "Milter: %s=%s, reject=%s",	\ 					  str, addr, response);		\ 				LogUsrErrs = false;			\ 			}						\ 			if (strncmp(response, "421 ", 4) == 0		\ 			    || strncmp(response, "421-", 4) == 0)	\ 			{						\ 				bool tsave = QuickAbort;		\ 									\ 				QuickAbort = false;			\ 				usrerr(response);			\ 				QuickAbort = tsave;			\ 				e->e_sendqueue = NULL;			\ 				goto doquit;				\ 			}						\ 			else						\ 				usrerr(response);			\ 			break;						\ 									\ 		  case SMFIR_REJECT:					\ 			if (MilterLogLevel> 3)				\ 			{						\ 				sm_syslog(LOG_INFO, e->e_id,		\ 					  "Milter: %s=%s, reject=550 5.7.1 Command rejected", \ 					  str, addr);			\ 				LogUsrErrs = false;			\ 			}						\ 			usrerr("550 5.7.1 Command rejected");		\ 			break;						\ 									\ 		  case SMFIR_DISCARD:					\ 			if (MilterLogLevel> 3)				\ 				sm_syslog(LOG_INFO, e->e_id,		\ 					  "Milter: %s=%s, discard",	\ 					  str, addr);			\ 			e->e_flags |= EF_DISCARD;			\ 			break;						\ 									\ 		  case SMFIR_TEMPFAIL:					\ 			if (MilterLogLevel> 3)				\ 			{						\ 				sm_syslog(LOG_INFO, e->e_id,		\ 					  "Milter: %s=%s, reject=%s",	\ 					  str, addr, MSG_TEMPFAIL);	\ 				LogUsrErrs = false;			\ 			}						\ 			usrerr(MSG_TEMPFAIL);				\ 			break;						\ 		}							\ 		LogUsrErrs = savelogusrerrs;				\ 		if (response != NULL)					\ 			sm_free(response);
comment|/* XXX */
value|\ 	}
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* MILTER */
end_comment

begin_define
define|#
directive|define
name|MILTER_ABORT
parameter_list|(
name|e
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MILTER */
end_comment

begin_comment
comment|/* clear all SMTP state (for HELO/EHLO/RSET) */
end_comment

begin_define
define|#
directive|define
name|CLEAR_STATE
parameter_list|(
name|cmd
parameter_list|)
define|\
value|do								\ {								\
comment|/* abort milter filters */
value|\ 	MILTER_ABORT(e);					\ 								\ 	if (smtp.sm_nrcpts> 0)					\ 	{							\ 		logundelrcpts(e, cmd, 10, false);		\ 		smtp.sm_nrcpts = 0;				\ 		macdefine(&e->e_macro, A_PERM,			\ 			  macid("{nrcpts}"), "0");		\ 	}							\ 								\ 	e->e_sendqueue = NULL;					\ 	e->e_flags |= EF_CLRQUEUE;				\ 								\ 	if (LogLevel> 4&& bitset(EF_LOGSENDER, e->e_flags))	\ 		logsender(e, NULL);				\ 	e->e_flags&= ~EF_LOGSENDER;				\ 								\
comment|/* clean up a bit */
value|\ 	smtp.sm_gotmail = false;				\ 	SuprErrs = true;					\ 	dropenvelope(e, true, false);				\ 	sm_rpool_free(e->e_rpool);				\ 	e = newenvelope(e, CurEnv, sm_rpool_new_x(NULL));	\ 	CurEnv = e;						\ 								\
comment|/* put back discard bit */
value|\ 	if (smtp.sm_discard)					\ 		e->e_flags |= EF_DISCARD;			\ 								\
comment|/* restore connection quarantining */
value|\ 	if (smtp.sm_quarmsg == NULL)				\ 	{							\ 		e->e_quarmsg = NULL;				\ 		macdefine(&e->e_macro, A_PERM,			\ 			macid("{quarantine}"), "");		\ 	}							\ 	else							\ 	{							\ 		e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool,	\ 						smtp.sm_quarmsg);	\ 		macdefine(&e->e_macro, A_PERM, macid("{quarantine}"),	\ 			  e->e_quarmsg);			\ 	}							\ } while (0)
end_define

begin_comment
comment|/* sleep to flatten out connection load */
end_comment

begin_define
define|#
directive|define
name|MIN_DELAY_LOG
value|15
end_define

begin_comment
comment|/* wait before logging this again */
end_comment

begin_comment
comment|/* is it worth setting the process title for 1s? */
end_comment

begin_define
define|#
directive|define
name|DELAY_CONN
parameter_list|(
name|cmd
parameter_list|)
define|\
value|if (DelayLA> 0&& (CurrentLA = getla())>= DelayLA)	\ 	{							\ 		time_t dnow;					\ 								\ 		sm_setproctitle(true, e,			\ 				"%s: %s: delaying %s: load average: %d", \ 				qid_printname(e), CurSmtpClient,	\ 				cmd, DelayLA);	\ 		if (LogLevel> 8&& (dnow = curtime())> log_delay)	\ 		{						\ 			sm_syslog(LOG_INFO, e->e_id,		\ 				  "delaying=%s, load average=%d>= %d",	\ 				  cmd, CurrentLA, DelayLA);		\ 			log_delay = dnow + MIN_DELAY_LOG;	\ 		}						\ 		(void) sleep(1);				\ 		sm_setproctitle(true, e, "%s %s: %.80s",	\ 				qid_printname(e), CurSmtpClient, inp);	\ 	}
end_define

begin_function
name|void
name|smtp
parameter_list|(
name|nullserver
parameter_list|,
name|d_flags
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
specifier|volatile
name|nullserver
decl_stmt|;
name|BITMAP256
name|d_flags
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
specifier|volatile
name|e
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
specifier|volatile
name|p
decl_stmt|;
specifier|register
name|struct
name|cmd
modifier|*
specifier|volatile
name|c
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
specifier|auto
name|ADDRESS
modifier|*
name|vrfyqueue
decl_stmt|;
name|ADDRESS
modifier|*
name|a
decl_stmt|;
specifier|volatile
name|bool
name|gothello
decl_stmt|;
comment|/* helo command received */
name|bool
name|vrfy
decl_stmt|;
comment|/* set if this is a vrfy command */
name|char
modifier|*
specifier|volatile
name|protocol
decl_stmt|;
comment|/* sending protocol */
name|char
modifier|*
specifier|volatile
name|sendinghost
decl_stmt|;
comment|/* sending hostname */
name|char
modifier|*
specifier|volatile
name|peerhostname
decl_stmt|;
comment|/* name of SMTP peer or "localhost" */
specifier|auto
name|char
modifier|*
name|delimptr
decl_stmt|;
name|char
modifier|*
name|id
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|n_badcmds
init|=
literal|0
decl_stmt|;
comment|/* count of bad commands */
specifier|volatile
name|unsigned
name|int
name|n_badrcpts
init|=
literal|0
decl_stmt|;
comment|/* number of rejected RCPT */
specifier|volatile
name|unsigned
name|int
name|n_verifies
init|=
literal|0
decl_stmt|;
comment|/* count of VRFY/EXPN */
specifier|volatile
name|unsigned
name|int
name|n_etrn
init|=
literal|0
decl_stmt|;
comment|/* count of ETRN */
specifier|volatile
name|unsigned
name|int
name|n_noop
init|=
literal|0
decl_stmt|;
comment|/* count of NOOP/VERB/etc */
specifier|volatile
name|unsigned
name|int
name|n_helo
init|=
literal|0
decl_stmt|;
comment|/* count of HELO/EHLO */
specifier|volatile
name|int
name|save_sevenbitinput
decl_stmt|;
name|bool
name|ok
decl_stmt|;
if|#
directive|if
name|_FFR_BLOCK_PROXIES
specifier|volatile
name|bool
name|first
decl_stmt|;
endif|#
directive|endif
comment|/* _FFR_BLOCK_PROXIES */
specifier|volatile
name|bool
name|tempfail
init|=
name|false
decl_stmt|;
specifier|volatile
name|time_t
name|wt
decl_stmt|;
comment|/* timeout after too many commands */
specifier|volatile
name|time_t
name|previous
decl_stmt|;
comment|/* time after checksmtpattack() */
specifier|volatile
name|bool
name|lognullconnection
init|=
name|true
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|SMTP_T
name|smtp
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
name|char
modifier|*
name|greetcode
init|=
literal|"220"
decl_stmt|;
name|char
modifier|*
name|hostname
decl_stmt|;
comment|/* my hostname ($j) */
name|QUEUE_CHAR
modifier|*
name|new
decl_stmt|;
name|int
name|argno
decl_stmt|;
name|char
modifier|*
name|args
index|[
name|MAXSMTPARGS
index|]
decl_stmt|;
name|char
name|inp
index|[
name|MAXLINE
index|]
decl_stmt|;
name|char
name|cmdbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
if|#
directive|if
name|SASL
name|sasl_conn_t
modifier|*
name|conn
decl_stmt|;
specifier|volatile
name|bool
name|sasl_ok
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|n_auth
init|=
literal|0
decl_stmt|;
comment|/* count of AUTH commands */
name|bool
name|ismore
decl_stmt|;
name|int
name|result
decl_stmt|;
specifier|volatile
name|int
name|authenticating
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|;
name|char
modifier|*
name|in
decl_stmt|,
modifier|*
name|out2
decl_stmt|;
if|#
directive|if
name|SASL
operator|>=
literal|20000
name|char
modifier|*
name|auth_id
decl_stmt|;
specifier|const
name|char
modifier|*
name|out
decl_stmt|;
name|sasl_ssf_t
name|ext_ssf
decl_stmt|;
name|char
name|localip
index|[
literal|60
index|]
decl_stmt|,
name|remoteip
index|[
literal|60
index|]
decl_stmt|;
else|#
directive|else
comment|/* SASL>= 20000 */
name|char
modifier|*
name|out
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|sasl_external_properties_t
name|ext_ssf
decl_stmt|;
name|struct
name|sockaddr_in
name|saddr_l
decl_stmt|;
name|struct
name|sockaddr_in
name|saddr_r
decl_stmt|;
endif|#
directive|endif
comment|/* SASL>= 20000 */
name|sasl_security_properties_t
name|ssp
decl_stmt|;
name|sasl_ssf_t
modifier|*
name|ssf
decl_stmt|;
name|unsigned
name|int
name|inlen
decl_stmt|,
name|out2len
decl_stmt|;
name|unsigned
name|int
name|outlen
decl_stmt|;
name|char
modifier|*
specifier|volatile
name|auth_type
decl_stmt|;
name|char
modifier|*
name|mechlist
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|n_mechs
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
endif|#
directive|endif
comment|/* SASL */
name|int
name|r
decl_stmt|;
if|#
directive|if
name|STARTTLS
name|int
name|rfd
decl_stmt|,
name|wfd
decl_stmt|;
specifier|volatile
name|bool
name|tls_active
init|=
name|false
decl_stmt|;
specifier|volatile
name|bool
name|smtps
init|=
name|bitnset
argument_list|(
name|D_SMTPS
argument_list|,
name|d_flags
argument_list|)
decl_stmt|;
name|bool
name|saveQuickAbort
decl_stmt|;
name|bool
name|saveSuprErrs
decl_stmt|;
name|time_t
name|tlsstart
decl_stmt|;
endif|#
directive|endif
comment|/* STARTTLS */
specifier|volatile
name|unsigned
name|int
name|features
decl_stmt|;
if|#
directive|if
name|PIPELINING
if|#
directive|if
name|_FFR_NO_PIPE
name|int
name|np_log
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* _FFR_NO_PIPE */
endif|#
directive|endif
comment|/* PIPELINING */
specifier|volatile
name|time_t
name|log_delay
init|=
operator|(
name|time_t
operator|)
literal|0
decl_stmt|;
name|save_sevenbitinput
operator|=
name|SevenBitInput
expr_stmt|;
name|smtp
operator|.
name|sm_nrcpts
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|MILTER
name|smtp
operator|.
name|sm_milterize
operator|=
operator|(
name|nullserver
operator|==
name|NULL
operator|)
expr_stmt|;
name|smtp
operator|.
name|sm_milterlist
operator|=
name|false
expr_stmt|;
endif|#
directive|endif
comment|/* MILTER */
comment|/* setup I/O fd correctly for the SMTP server */
name|setup_smtpd_io
argument_list|()
expr_stmt|;
if|#
directive|if
name|SM_HEAP_CHECK
if|if
condition|(
name|sm_debug_active
argument_list|(
operator|&
name|DebugLeakSmtp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_heap_newgroup
argument_list|()
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"smtp() heap group #%d\n"
argument_list|,
name|sm_heap_group
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SM_HEAP_CHECK */
comment|/* XXX the rpool should be set when e is initialized in main() */
name|e
operator|->
name|e_rpool
operator|=
name|sm_rpool_new_x
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_macro
operator|.
name|mac_rpool
operator|=
name|e
operator|->
name|e_rpool
expr_stmt|;
name|settime
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|sm_getla
argument_list|()
expr_stmt|;
name|peerhostname
operator|=
name|RealHostName
expr_stmt|;
if|if
condition|(
name|peerhostname
operator|==
name|NULL
condition|)
name|peerhostname
operator|=
literal|"localhost"
expr_stmt|;
name|CurHostName
operator|=
name|peerhostname
expr_stmt|;
name|CurSmtpClient
operator|=
name|macvalue
argument_list|(
literal|'_'
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|CurSmtpClient
operator|==
name|NULL
condition|)
name|CurSmtpClient
operator|=
name|CurHostName
expr_stmt|;
comment|/* check_relay may have set discard bit, save for later */
name|smtp
operator|.
name|sm_discard
operator|=
name|bitset
argument_list|(
name|EF_DISCARD
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
expr_stmt|;
if|#
directive|if
name|PIPELINING
comment|/* auto-flush output when reading input */
operator|(
name|void
operator|)
name|sm_io_autoflush
argument_list|(
name|InChannel
argument_list|,
name|OutChannel
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PIPELINING */
name|sm_setproctitle
argument_list|(
name|true
argument_list|,
name|e
argument_list|,
literal|"server %s startup"
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
comment|/* Set default features for server. */
name|features
operator|=
operator|(
operator|(
name|bitset
argument_list|(
name|PRIV_NOETRN
argument_list|,
name|PrivacyFlags
argument_list|)
operator|||
name|bitnset
argument_list|(
name|D_NOETRN
argument_list|,
name|d_flags
argument_list|)
operator|)
condition|?
name|SRV_NONE
else|:
name|SRV_OFFER_ETRN
operator|)
operator||
operator|(
name|bitnset
argument_list|(
name|D_AUTHREQ
argument_list|,
name|d_flags
argument_list|)
condition|?
name|SRV_REQ_AUTH
else|:
name|SRV_NONE
operator|)
operator||
operator|(
name|bitset
argument_list|(
name|PRIV_NOEXPN
argument_list|,
name|PrivacyFlags
argument_list|)
condition|?
name|SRV_NONE
else|:
operator|(
name|SRV_OFFER_EXPN
operator||
operator|(
name|bitset
argument_list|(
name|PRIV_NOVERB
argument_list|,
name|PrivacyFlags
argument_list|)
condition|?
name|SRV_NONE
else|:
name|SRV_OFFER_VERB
operator|)
operator|)
operator|)
operator||
operator|(
operator|(
name|bitset
argument_list|(
name|PRIV_NORECEIPTS
argument_list|,
name|PrivacyFlags
argument_list|)
operator|||
operator|!
name|SendMIMEErrors
operator|)
condition|?
name|SRV_NONE
else|:
name|SRV_OFFER_DSN
operator|)
if|#
directive|if
name|SASL
operator||
operator|(
name|bitnset
argument_list|(
name|D_NOAUTH
argument_list|,
name|d_flags
argument_list|)
condition|?
name|SRV_NONE
else|:
name|SRV_OFFER_AUTH
operator|)
operator||
operator|(
name|bitset
argument_list|(
name|SASL_SEC_NOPLAINTEXT
argument_list|,
name|SASLOpts
argument_list|)
condition|?
name|SRV_REQ_SEC
else|:
name|SRV_NONE
operator|)
endif|#
directive|endif
comment|/* SASL */
if|#
directive|if
name|PIPELINING
operator||
name|SRV_OFFER_PIPE
endif|#
directive|endif
comment|/* PIPELINING */
if|#
directive|if
name|STARTTLS
operator||
operator|(
name|bitnset
argument_list|(
name|D_NOTLS
argument_list|,
name|d_flags
argument_list|)
condition|?
name|SRV_NONE
else|:
name|SRV_OFFER_TLS
operator|)
operator||
operator|(
name|bitset
argument_list|(
name|TLS_I_NO_VRFY
argument_list|,
name|TLS_Srv_Opts
argument_list|)
condition|?
name|SRV_NONE
else|:
name|SRV_VRFY_CLT
operator|)
endif|#
directive|endif
comment|/* STARTTLS */
expr_stmt|;
if|if
condition|(
name|nullserver
operator|==
name|NULL
condition|)
block|{
name|features
operator|=
name|srvfeatures
argument_list|(
name|e
argument_list|,
name|CurSmtpClient
argument_list|,
name|features
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|SRV_TMP_FAIL
argument_list|,
name|features
argument_list|)
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|4
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"ERROR: srv_features=tempfail, relay=%.100s, access temporarily disabled"
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
name|nullserver
operator|=
literal|"450 4.3.0 Please try again later."
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|PIPELINING
if|#
directive|if
name|_FFR_NO_PIPE
if|if
condition|(
name|bitset
argument_list|(
name|SRV_NO_PIPE
argument_list|,
name|features
argument_list|)
condition|)
block|{
comment|/* for consistency */
name|features
operator|&=
operator|~
name|SRV_OFFER_PIPE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _FFR_NO_PIPE */
endif|#
directive|endif
comment|/* PIPELINING */
if|#
directive|if
name|SASL
if|if
condition|(
name|bitset
argument_list|(
name|SRV_REQ_SEC
argument_list|,
name|features
argument_list|)
condition|)
name|SASLOpts
operator||=
name|SASL_SEC_NOPLAINTEXT
expr_stmt|;
else|else
name|SASLOpts
operator|&=
operator|~
name|SASL_SEC_NOPLAINTEXT
expr_stmt|;
endif|#
directive|endif
comment|/* SASL */
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|nullserver
argument_list|,
literal|"421 "
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|message
argument_list|(
name|nullserver
argument_list|)
expr_stmt|;
goto|goto
name|doquit
goto|;
block|}
name|hostname
operator|=
name|macvalue
argument_list|(
literal|'j'
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|#
directive|if
name|SASL
if|if
condition|(
name|AuthRealm
operator|==
name|NULL
condition|)
name|AuthRealm
operator|=
name|hostname
expr_stmt|;
name|sasl_ok
operator|=
name|bitset
argument_list|(
name|SRV_OFFER_AUTH
argument_list|,
name|features
argument_list|)
expr_stmt|;
name|n_mechs
operator|=
literal|0
expr_stmt|;
name|authenticating
operator|=
name|SASL_NOT_AUTH
expr_stmt|;
comment|/* SASL server new connection */
if|if
condition|(
name|sasl_ok
condition|)
block|{
if|#
directive|if
name|SASL
operator|>=
literal|20000
name|result
operator|=
name|sasl_server_new
argument_list|(
literal|"smtp"
argument_list|,
name|AuthRealm
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|conn
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|SASL
operator|>
literal|10505
comment|/* use empty realm: only works in SASL> 1.5.5 */
name|result
operator|=
name|sasl_server_new
argument_list|(
literal|"smtp"
argument_list|,
name|AuthRealm
argument_list|,
literal|""
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|conn
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SASL>= 20000 */
comment|/* use no realm -> realm is set to hostname by SASL lib */
name|result
operator|=
name|sasl_server_new
argument_list|(
literal|"smtp"
argument_list|,
name|AuthRealm
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|conn
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SASL>= 20000 */
name|sasl_ok
operator|=
name|result
operator|==
name|SASL_OK
expr_stmt|;
if|if
condition|(
operator|!
name|sasl_ok
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"AUTH error: sasl_server_new failed=%d"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sasl_ok
condition|)
block|{
comment|/* 		**  SASL set properties for sasl 		**  set local/remote IP 		**  XXX Cyrus SASL v1 only supports IPv4 		** 		**  XXX where exactly are these used/required? 		**  Kerberos_v4 		*/
if|#
directive|if
name|SASL
operator|>=
literal|20000
name|localip
index|[
literal|0
index|]
operator|=
name|remoteip
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|#
directive|if
name|NETINET
operator|||
name|NETINET6
name|in
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{daemon_family}"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|!=
name|NULL
operator|&&
operator|(
if|#
directive|if
name|NETINET6
name|strcmp
argument_list|(
name|in
argument_list|,
literal|"inet6"
argument_list|)
operator|==
literal|0
operator|||
endif|#
directive|endif
comment|/* NETINET6 */
name|strcmp
argument_list|(
name|in
argument_list|,
literal|"inet"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|SOCKADDR_LEN_T
name|addrsize
decl_stmt|;
name|SOCKADDR
name|saddr_l
decl_stmt|;
name|SOCKADDR
name|saddr_r
decl_stmt|;
name|addrsize
operator|=
sizeof|sizeof
argument_list|(
name|saddr_r
argument_list|)
expr_stmt|;
if|if
condition|(
name|getpeername
argument_list|(
name|sm_io_getinfo
argument_list|(
name|InChannel
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr_r
argument_list|,
operator|&
name|addrsize
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|iptostring
argument_list|(
operator|&
name|saddr_r
argument_list|,
name|addrsize
argument_list|,
name|remoteip
argument_list|,
sizeof|sizeof
name|remoteip
argument_list|)
condition|)
block|{
name|sasl_setprop
argument_list|(
name|conn
argument_list|,
name|SASL_IPREMOTEPORT
argument_list|,
name|remoteip
argument_list|)
expr_stmt|;
block|}
name|addrsize
operator|=
sizeof|sizeof
argument_list|(
name|saddr_l
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|sm_io_getinfo
argument_list|(
name|InChannel
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr_l
argument_list|,
operator|&
name|addrsize
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|iptostring
argument_list|(
operator|&
name|saddr_l
argument_list|,
name|addrsize
argument_list|,
name|localip
argument_list|,
sizeof|sizeof
name|localip
argument_list|)
condition|)
block|{
name|sasl_setprop
argument_list|(
name|conn
argument_list|,
name|SASL_IPLOCALPORT
argument_list|,
name|localip
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
comment|/* NETINET || NETINET6 */
else|#
directive|else
comment|/* SASL>= 20000 */
if|#
directive|if
name|NETINET
name|in
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{daemon_family}"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|in
argument_list|,
literal|"inet"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SOCKADDR_LEN_T
name|addrsize
decl_stmt|;
name|addrsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|getpeername
argument_list|(
name|sm_io_getinfo
argument_list|(
name|InChannel
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr_r
argument_list|,
operator|&
name|addrsize
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sasl_setprop
argument_list|(
name|conn
argument_list|,
name|SASL_IP_REMOTE
argument_list|,
operator|&
name|saddr_r
argument_list|)
expr_stmt|;
name|addrsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|sm_io_getinfo
argument_list|(
name|InChannel
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr_l
argument_list|,
operator|&
name|addrsize
argument_list|)
operator|==
literal|0
condition|)
name|sasl_setprop
argument_list|(
name|conn
argument_list|,
name|SASL_IP_LOCAL
argument_list|,
operator|&
name|saddr_l
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* NETINET */
endif|#
directive|endif
comment|/* SASL>= 20000 */
name|auth_type
operator|=
name|NULL
expr_stmt|;
name|mechlist
operator|=
name|NULL
expr_stmt|;
name|user
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
literal|0
block|macdefine(&BlankEnvelope.e_macro, A_PERM, 			macid("{auth_author}"), NULL);
endif|#
directive|endif
comment|/* 0 */
comment|/* set properties */
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|&
name|ssp
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|ssp
argument_list|)
expr_stmt|;
comment|/* XXX should these be options settable via .cf ? */
comment|/* ssp.min_ssf = 0; is default due to memset() */
block|{
name|ssp
operator|.
name|max_ssf
operator|=
name|MaxSLBits
expr_stmt|;
name|ssp
operator|.
name|maxbufsize
operator|=
name|MAXOUTLEN
expr_stmt|;
block|}
name|ssp
operator|.
name|security_flags
operator|=
name|SASLOpts
operator|&
name|SASL_SEC_MASK
expr_stmt|;
name|sasl_ok
operator|=
name|sasl_setprop
argument_list|(
name|conn
argument_list|,
name|SASL_SEC_PROPS
argument_list|,
operator|&
name|ssp
argument_list|)
operator|==
name|SASL_OK
expr_stmt|;
if|if
condition|(
name|sasl_ok
condition|)
block|{
comment|/* 			**  external security strength factor; 			**	currently we have none so zero 			*/
if|#
directive|if
name|SASL
operator|>=
literal|20000
name|ext_ssf
operator|=
literal|0
expr_stmt|;
name|auth_id
operator|=
name|NULL
expr_stmt|;
name|sasl_ok
operator|=
operator|(
operator|(
name|sasl_setprop
argument_list|(
name|conn
argument_list|,
name|SASL_SSF_EXTERNAL
argument_list|,
operator|&
name|ext_ssf
argument_list|)
operator|==
name|SASL_OK
operator|)
operator|&&
operator|(
name|sasl_setprop
argument_list|(
name|conn
argument_list|,
name|SASL_AUTH_EXTERNAL
argument_list|,
name|auth_id
argument_list|)
operator|==
name|SASL_OK
operator|)
operator|)
expr_stmt|;
else|#
directive|else
comment|/* SASL>= 20000 */
name|ext_ssf
operator|.
name|ssf
operator|=
literal|0
expr_stmt|;
name|ext_ssf
operator|.
name|auth_id
operator|=
name|NULL
expr_stmt|;
name|sasl_ok
operator|=
name|sasl_setprop
argument_list|(
name|conn
argument_list|,
name|SASL_SSF_EXTERNAL
argument_list|,
operator|&
name|ext_ssf
argument_list|)
operator|==
name|SASL_OK
expr_stmt|;
endif|#
directive|endif
comment|/* SASL>= 20000 */
block|}
if|if
condition|(
name|sasl_ok
condition|)
name|n_mechs
operator|=
name|saslmechs
argument_list|(
name|conn
argument_list|,
operator|&
name|mechlist
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SASL */
if|#
directive|if
name|STARTTLS
endif|#
directive|endif
comment|/* STARTTLS */
if|#
directive|if
name|MILTER
if|if
condition|(
name|smtp
operator|.
name|sm_milterize
condition|)
block|{
name|char
name|state
decl_stmt|;
comment|/* initialize mail filter connection */
name|smtp
operator|.
name|sm_milterlist
operator|=
name|milter_init
argument_list|(
name|e
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|SMFIR_REJECT
case|:
if|if
condition|(
name|MilterLogLevel
operator|>
literal|3
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: initialization failed, rejecting commands"
argument_list|)
expr_stmt|;
name|greetcode
operator|=
literal|"554"
expr_stmt|;
name|nullserver
operator|=
literal|"Command rejected"
expr_stmt|;
name|smtp
operator|.
name|sm_milterize
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|SMFIR_TEMPFAIL
case|:
if|if
condition|(
name|MilterLogLevel
operator|>
literal|3
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: initialization failed, temp failing commands"
argument_list|)
expr_stmt|;
name|tempfail
operator|=
name|true
expr_stmt|;
name|smtp
operator|.
name|sm_milterize
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|SMFIR_SHUTDOWN
case|:
if|if
condition|(
name|MilterLogLevel
operator|>
literal|3
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: initialization failed, closing connection"
argument_list|)
expr_stmt|;
name|tempfail
operator|=
name|true
expr_stmt|;
name|smtp
operator|.
name|sm_milterize
operator|=
name|false
expr_stmt|;
name|message
argument_list|(
literal|"421 4.7.0 %s closing connection"
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
comment|/* arrange to ignore send list */
name|e
operator|->
name|e_sendqueue
operator|=
name|NULL
expr_stmt|;
goto|goto
name|doquit
goto|;
block|}
block|}
if|if
condition|(
name|smtp
operator|.
name|sm_milterlist
operator|&&
name|smtp
operator|.
name|sm_milterize
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_DISCARD
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|char
name|state
decl_stmt|;
name|char
modifier|*
name|response
decl_stmt|;
name|response
operator|=
name|milter_connect
argument_list|(
name|peerhostname
argument_list|,
name|RealHostAddr
argument_list|,
name|e
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|SMFIR_REPLYCODE
case|:
comment|/* REPLYCODE shouldn't happen */
case|case
name|SMFIR_REJECT
case|:
if|if
condition|(
name|MilterLogLevel
operator|>
literal|3
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: connect: host=%s, addr=%s, rejecting commands"
argument_list|,
name|peerhostname
argument_list|,
name|anynet_ntoa
argument_list|(
operator|&
name|RealHostAddr
argument_list|)
argument_list|)
expr_stmt|;
name|greetcode
operator|=
literal|"554"
expr_stmt|;
name|nullserver
operator|=
literal|"Command rejected"
expr_stmt|;
name|smtp
operator|.
name|sm_milterize
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|SMFIR_TEMPFAIL
case|:
if|if
condition|(
name|MilterLogLevel
operator|>
literal|3
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: connect: host=%s, addr=%s, temp failing commands"
argument_list|,
name|peerhostname
argument_list|,
name|anynet_ntoa
argument_list|(
operator|&
name|RealHostAddr
argument_list|)
argument_list|)
expr_stmt|;
name|tempfail
operator|=
name|true
expr_stmt|;
name|smtp
operator|.
name|sm_milterize
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|SMFIR_SHUTDOWN
case|:
if|if
condition|(
name|MilterLogLevel
operator|>
literal|3
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: connect: host=%s, addr=%s, shutdown"
argument_list|,
name|peerhostname
argument_list|,
name|anynet_ntoa
argument_list|(
operator|&
name|RealHostAddr
argument_list|)
argument_list|)
expr_stmt|;
name|tempfail
operator|=
name|true
expr_stmt|;
name|smtp
operator|.
name|sm_milterize
operator|=
name|false
expr_stmt|;
name|message
argument_list|(
literal|"421 4.7.0 %s closing connection"
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
comment|/* arrange to ignore send list */
name|e
operator|->
name|e_sendqueue
operator|=
name|NULL
expr_stmt|;
goto|goto
name|doquit
goto|;
block|}
if|if
condition|(
name|response
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
endif|#
directive|endif
comment|/* MILTER */
comment|/* 	**  Broken proxies and SMTP slammers 	**  push data without waiting, catch them 	*/
if|if
condition|(
if|#
directive|if
name|STARTTLS
operator|!
name|smtps
operator|&&
endif|#
directive|endif
comment|/* STARTTLS */
operator|*
name|greetcode
operator|==
literal|'2'
condition|)
block|{
name|time_t
name|msecs
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
name|char
name|pvpbuf
index|[
name|PSBUFSIZE
index|]
decl_stmt|;
comment|/* Ask the rulesets how long to pause */
name|pvp
operator|=
name|NULL
expr_stmt|;
name|r
operator|=
name|rscap
argument_list|(
literal|"greet_pause"
argument_list|,
name|peerhostname
argument_list|,
name|anynet_ntoa
argument_list|(
operator|&
name|RealHostAddr
argument_list|)
argument_list|,
name|e
argument_list|,
operator|&
name|pvp
argument_list|,
name|pvpbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pvpbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|EX_OK
operator|&&
name|pvp
operator|!=
name|NULL
operator|&&
name|pvp
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
operator|(
name|pvp
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|&
literal|0377
operator|)
operator|==
name|CANONNET
operator|&&
name|pvp
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
name|msecs
operator|=
name|strtol
argument_list|(
name|pvp
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msecs
operator|>
literal|0
condition|)
block|{
name|int
name|fd
decl_stmt|;
name|fd_set
name|readfds
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
if|#
directive|if
name|_FFR_LOG_GREET_PAUSE
name|struct
name|timeval
name|bp
decl_stmt|,
name|ep
decl_stmt|,
name|tp
decl_stmt|;
comment|/* {begin,end,total}pause */
endif|#
directive|endif
comment|/* _FFR_LOG_GREET_PAUSE */
comment|/* pause for a moment */
name|timeout
operator|.
name|tv_sec
operator|=
name|msecs
operator|/
literal|1000
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
operator|(
name|msecs
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
comment|/* Obey RFC 2821: 4.3.5.2: 220 timeout of 5 minutes */
if|if
condition|(
name|timeout
operator|.
name|tv_sec
operator|>=
literal|300
condition|)
block|{
name|timeout
operator|.
name|tv_sec
operator|=
literal|300
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
block|}
comment|/* check if data is on the socket during the pause */
name|fd
operator|=
name|sm_io_getinfo
argument_list|(
name|InChannel
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|SM_FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
if|#
directive|if
name|_FFR_LOG_GREET_PAUSE
name|gettimeofday
argument_list|(
operator|&
name|bp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_LOG_GREET_PAUSE */
if|if
condition|(
name|select
argument_list|(
name|fd
operator|+
literal|1
argument_list|,
name|FDSET_CAST
operator|&
name|readfds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|timeout
argument_list|)
operator|>
literal|0
operator|&&
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|readfds
argument_list|)
condition|)
block|{
if|#
directive|if
name|_FFR_LOG_GREET_PAUSE
name|gettimeofday
argument_list|(
operator|&
name|ep
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|timersub
argument_list|(
operator|&
name|ep
argument_list|,
operator|&
name|bp
argument_list|,
operator|&
name|tp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_LOG_GREET_PAUSE */
name|greetcode
operator|=
literal|"554"
expr_stmt|;
name|nullserver
operator|=
literal|"Command rejected"
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
if|#
directive|if
name|_FFR_LOG_GREET_PAUSE
literal|"rejecting commands from %s [%s] after %d seconds due to pre-greeting traffic"
argument_list|,
else|#
directive|else
comment|/* _FFR_LOG_GREET_PAUSE */
literal|"rejecting commands from %s [%s] due to pre-greeting traffic"
argument_list|,
endif|#
directive|endif
comment|/* _FFR_LOG_GREET_PAUSE */
name|peerhostname
argument_list|,
name|anynet_ntoa
argument_list|(
operator|&
name|RealHostAddr
argument_list|)
if|#
directive|if
name|_FFR_LOG_GREET_PAUSE
argument_list|,
operator|(
name|int
operator|)
name|tp
operator|.
name|tv_sec
operator|+
operator|(
name|tp
operator|.
name|tv_usec
operator|>=
literal|500000
condition|?
literal|1
else|:
literal|0
operator|)
endif|#
directive|endif
comment|/* _FFR_LOG_GREET_PAUSE */
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|#
directive|if
name|STARTTLS
comment|/* If this an smtps connection, start TLS now */
if|if
condition|(
name|smtps
condition|)
block|{
name|Errors
operator|=
literal|0
expr_stmt|;
goto|goto
name|starttls
goto|;
block|}
name|greeting
label|:
endif|#
directive|endif
comment|/* STARTTLS */
comment|/* output the first line, inserting "ESMTP" as second word */
if|if
condition|(
operator|*
name|greetcode
operator|==
literal|'5'
condition|)
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|inp
argument_list|,
sizeof|sizeof
name|inp
argument_list|,
literal|"%s not accepting messages"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
else|else
name|expand
argument_list|(
name|SmtpGreeting
argument_list|,
name|inp
argument_list|,
sizeof|sizeof
name|inp
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|inp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|id
operator|=
name|strchr
argument_list|(
name|inp
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
name|id
operator|=
operator|&
name|inp
index|[
name|strlen
argument_list|(
name|inp
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|cmdbuf
argument_list|,
sizeof|sizeof
name|cmdbuf
argument_list|,
literal|"%s %%.*s ESMTP%%s"
argument_list|,
name|greetcode
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|cmdbuf
argument_list|,
sizeof|sizeof
name|cmdbuf
argument_list|,
literal|"%s-%%.*s ESMTP%%s"
argument_list|,
name|greetcode
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|cmdbuf
argument_list|,
call|(
name|int
call|)
argument_list|(
name|id
operator|-
name|inp
argument_list|)
argument_list|,
name|inp
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* output remaining lines */
while|while
condition|(
operator|(
name|id
operator|=
name|p
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|id
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|isascii
argument_list|(
operator|*
name|id
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|id
argument_list|)
condition|)
name|id
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|cmdbuf
argument_list|,
sizeof|sizeof
name|cmdbuf
argument_list|,
literal|2
argument_list|,
name|greetcode
argument_list|,
literal|"-%s"
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|cmdbuf
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|id
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|isascii
argument_list|(
operator|*
name|id
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|id
argument_list|)
condition|)
name|id
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|cmdbuf
argument_list|,
sizeof|sizeof
name|cmdbuf
argument_list|,
literal|2
argument_list|,
name|greetcode
argument_list|,
literal|" %s"
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|cmdbuf
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
name|protocol
operator|=
name|NULL
expr_stmt|;
name|sendinghost
operator|=
name|macvalue
argument_list|(
literal|'s'
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* If quarantining by a connect/ehlo action, save between messages */
if|if
condition|(
name|e
operator|->
name|e_quarmsg
operator|==
name|NULL
condition|)
name|smtp
operator|.
name|sm_quarmsg
operator|=
name|NULL
expr_stmt|;
else|else
name|smtp
operator|.
name|sm_quarmsg
operator|=
name|newstr
argument_list|(
name|e
operator|->
name|e_quarmsg
argument_list|)
expr_stmt|;
comment|/* sendinghost's storage must outlive the current envelope */
if|if
condition|(
name|sendinghost
operator|!=
name|NULL
condition|)
name|sendinghost
operator|=
name|sm_strdup_x
argument_list|(
name|sendinghost
argument_list|)
expr_stmt|;
if|#
directive|if
name|_FFR_BLOCK_PROXIES
name|first
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_BLOCK_PROXIES */
name|gothello
operator|=
name|false
expr_stmt|;
name|smtp
operator|.
name|sm_gotmail
operator|=
name|false
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|SM_TRY
block|{
name|QuickAbort
operator|=
name|false
expr_stmt|;
name|HoldErrs
operator|=
name|false
expr_stmt|;
name|SuprErrs
operator|=
name|false
expr_stmt|;
name|LogUsrErrs
operator|=
name|false
expr_stmt|;
name|OnlyOneError
operator|=
name|true
expr_stmt|;
name|e
operator|->
name|e_flags
operator|&=
operator|~
operator|(
name|EF_VRFYONLY
operator||
name|EF_GLOBALERRS
operator|)
expr_stmt|;
comment|/* setup for the read */
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
name|Errors
operator|=
literal|0
expr_stmt|;
name|FileName
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_flush
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
comment|/* read the input line */
name|SmtpPhase
operator|=
literal|"server cmd read"
expr_stmt|;
name|sm_setproctitle
argument_list|(
name|true
argument_list|,
name|e
argument_list|,
literal|"server %s cmd read"
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
if|#
directive|if
name|SASL
comment|/* 		**  XXX SMTP AUTH requires accepting any length, 		**	at least for challenge/response 		*/
endif|#
directive|endif
comment|/* SASL */
comment|/* handle errors */
if|if
condition|(
name|sm_io_error
argument_list|(
name|OutChannel
argument_list|)
operator|||
operator|(
name|p
operator|=
name|sfgets
argument_list|(
name|inp
argument_list|,
sizeof|sizeof
name|inp
argument_list|,
name|InChannel
argument_list|,
name|TimeOuts
operator|.
name|to_nextcommand
argument_list|,
name|SmtpPhase
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|d
decl_stmt|;
name|d
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{daemon_name}"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
name|d
operator|=
literal|"stdin"
expr_stmt|;
comment|/* end of file, just die */
name|disconnect
argument_list|(
literal|1
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|#
directive|if
name|MILTER
comment|/* close out milter filters */
name|milter_quit
argument_list|(
name|e
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MILTER */
name|message
argument_list|(
literal|"421 4.4.1 %s Lost input channel from %s"
argument_list|,
name|MyHostName
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
operator|(
name|smtp
operator|.
name|sm_gotmail
condition|?
literal|1
else|:
literal|19
operator|)
condition|)
name|sm_syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"lost input channel from %s to %s after %s"
argument_list|,
name|CurSmtpClient
argument_list|,
name|d
argument_list|,
operator|(
name|c
operator|==
name|NULL
operator|||
name|c
operator|->
name|cmd_name
operator|==
name|NULL
operator|)
condition|?
literal|"startup"
else|:
name|c
operator|->
name|cmd_name
argument_list|)
expr_stmt|;
comment|/* 			**  If have not accepted mail (DATA), do not bounce 			**  bad addresses back to sender. 			*/
if|if
condition|(
name|bitset
argument_list|(
name|EF_CLRQUEUE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|e
operator|->
name|e_sendqueue
operator|=
name|NULL
expr_stmt|;
goto|goto
name|doquit
goto|;
block|}
if|#
directive|if
name|_FFR_BLOCK_PROXIES
if|if
condition|(
name|first
condition|)
block|{
name|size_t
name|inplen
decl_stmt|,
name|cmdlen
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|char
modifier|*
name|http_cmd
decl_stmt|;
specifier|static
name|char
modifier|*
name|http_cmds
index|[]
init|=
block|{
literal|"GET"
block|,
literal|"POST"
block|,
literal|"CONNECT"
block|,
literal|"USER"
block|,
name|NULL
block|}
decl_stmt|;
name|inplen
operator|=
name|strlen
argument_list|(
name|inp
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
operator|(
name|http_cmd
operator|=
name|http_cmds
index|[
name|idx
index|]
operator|)
operator|!=
name|NULL
condition|;
name|idx
operator|++
control|)
block|{
name|cmdlen
operator|=
name|strlen
argument_list|(
name|http_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdlen
operator|<
name|inplen
operator|&&
name|sm_strncasecmp
argument_list|(
name|inp
argument_list|,
name|http_cmd
argument_list|,
name|cmdlen
argument_list|)
operator|==
literal|0
operator|&&
name|isascii
argument_list|(
name|inp
index|[
name|cmdlen
index|]
argument_list|)
operator|&&
name|isspace
argument_list|(
name|inp
index|[
name|cmdlen
index|]
argument_list|)
condition|)
block|{
comment|/* Open proxy, drop it */
name|message
argument_list|(
literal|"421 4.7.0 %s Rejecting open proxy %s"
argument_list|,
name|MyHostName
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%s: probable open proxy: command=%.40s"
argument_list|,
name|CurSmtpClient
argument_list|,
name|inp
argument_list|)
expr_stmt|;
goto|goto
name|doquit
goto|;
block|}
block|}
name|first
operator|=
name|false
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _FFR_BLOCK_PROXIES */
comment|/* clean up end of line */
name|fixcrlf
argument_list|(
name|inp
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|#
directive|if
name|PIPELINING
if|#
directive|if
name|_FFR_NO_PIPE
comment|/* 		**  if there is more input and pipelining is disabled: 		**	delay ... (and maybe discard the input?) 		**  XXX this doesn't really work, at least in tests using 		**  telnet SM_IO_IS_READABLE only returns 1 if there were 		**  more than 2 input lines available. 		*/
if|if
condition|(
name|bitset
argument_list|(
name|SRV_NO_PIPE
argument_list|,
name|features
argument_list|)
operator|&&
name|sm_io_getinfo
argument_list|(
name|InChannel
argument_list|,
name|SM_IO_IS_READABLE
argument_list|,
name|NULL
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|np_log
operator|<
literal|3
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"unauthorized PIPELINING, sleeping"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _FFR_NO_PIPE */
endif|#
directive|endif
comment|/* PIPELINING */
if|#
directive|if
name|SASL
if|if
condition|(
name|authenticating
operator|==
name|SASL_PROC_AUTH
condition|)
block|{
if|#
directive|if
literal|0
block|if (*inp == '\0') 			{ 				authenticating = SASL_NOT_AUTH; 				message("501 5.5.2 missing input"); 				RESET_SASLCONN; 				continue; 			}
endif|#
directive|endif
comment|/* 0 */
if|if
condition|(
operator|*
name|inp
operator|==
literal|'*'
operator|&&
operator|*
operator|(
name|inp
operator|+
literal|1
operator|)
operator|==
literal|'\0'
condition|)
block|{
name|authenticating
operator|=
name|SASL_NOT_AUTH
expr_stmt|;
comment|/* rfc 2254 4. */
name|message
argument_list|(
literal|"501 5.0.0 AUTH aborted"
argument_list|)
expr_stmt|;
name|RESET_SASLCONN
expr_stmt|;
continue|continue;
block|}
comment|/* could this be shorter? XXX */
if|#
directive|if
name|SASL
operator|>=
literal|20000
name|in
operator|=
name|xalloc
argument_list|(
name|strlen
argument_list|(
name|inp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|sasl_decode64
argument_list|(
name|inp
argument_list|,
name|strlen
argument_list|(
name|inp
argument_list|)
argument_list|,
name|in
argument_list|,
name|strlen
argument_list|(
name|inp
argument_list|)
argument_list|,
operator|&
name|inlen
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SASL>= 20000 */
name|out
operator|=
name|xalloc
argument_list|(
name|strlen
argument_list|(
name|inp
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|sasl_decode64
argument_list|(
name|inp
argument_list|,
name|strlen
argument_list|(
name|inp
argument_list|)
argument_list|,
name|out
argument_list|,
operator|&
name|outlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SASL>= 20000 */
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
block|{
name|authenticating
operator|=
name|SASL_NOT_AUTH
expr_stmt|;
comment|/* rfc 2254 4. */
name|message
argument_list|(
literal|"501 5.5.4 cannot decode AUTH parameter %s"
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|#
directive|if
name|SASL
operator|>=
literal|20000
name|sm_free
argument_list|(
name|in
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SASL>= 20000 */
name|RESET_SASLCONN
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
name|SASL
operator|>=
literal|20000
name|result
operator|=
name|sasl_server_step
argument_list|(
name|conn
argument_list|,
name|in
argument_list|,
name|inlen
argument_list|,
operator|&
name|out
argument_list|,
operator|&
name|outlen
argument_list|)
expr_stmt|;
name|sm_free
argument_list|(
name|in
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SASL>= 20000 */
name|result
operator|=
name|sasl_server_step
argument_list|(
name|conn
argument_list|,
name|out
argument_list|,
name|outlen
argument_list|,
operator|&
name|out
argument_list|,
operator|&
name|outlen
argument_list|,
operator|&
name|errstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SASL>= 20000 */
comment|/* get an OK if we're done */
if|if
condition|(
name|result
operator|==
name|SASL_OK
condition|)
block|{
name|authenticated
label|:
name|message
argument_list|(
literal|"235 2.0.0 OK Authenticated"
argument_list|)
expr_stmt|;
name|authenticating
operator|=
name|SASL_IS_AUTH
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{auth_type}"
argument_list|)
argument_list|,
name|auth_type
argument_list|)
expr_stmt|;
if|#
directive|if
name|SASL
operator|>=
literal|20000
name|user
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{auth_authen}"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* get security strength (features) */
name|result
operator|=
name|sasl_getprop
argument_list|(
name|conn
argument_list|,
name|SASL_SSF
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|ssf
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SASL>= 20000 */
name|result
operator|=
name|sasl_getprop
argument_list|(
name|conn
argument_list|,
name|SASL_USERNAME
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
block|{
name|user
operator|=
literal|""
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{auth_authen}"
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{auth_authen}"
argument_list|)
argument_list|,
name|xtextify
argument_list|(
name|user
argument_list|,
literal|"<>\")"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* get realm? */
block|sasl_getprop(conn, SASL_REALM, (void **)&data);
endif|#
directive|endif
comment|/* 0 */
comment|/* get security strength (features) */
name|result
operator|=
name|sasl_getprop
argument_list|(
name|conn
argument_list|,
name|SASL_SSF
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ssf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SASL>= 20000 */
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
block|{
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{auth_ssf}"
argument_list|)
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|ssf
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|char
name|pbuf
index|[
literal|8
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|pbuf
argument_list|,
sizeof|sizeof
name|pbuf
argument_list|,
literal|"%u"
argument_list|,
operator|*
name|ssf
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{auth_ssf}"
argument_list|)
argument_list|,
name|pbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|95
argument_list|,
literal|8
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"AUTH auth_ssf: %u\n"
argument_list|,
operator|*
name|ssf
argument_list|)
expr_stmt|;
block|}
comment|/* 				**  Only switch to encrypted connection 				**  if a security layer has been negotiated 				*/
if|if
condition|(
name|ssf
operator|!=
name|NULL
operator|&&
operator|*
name|ssf
operator|>
literal|0
condition|)
block|{
name|int
name|tmo
decl_stmt|;
comment|/* 					**  Convert I/O layer to use SASL. 					**  If the call fails, the connection 					**  is aborted. 					*/
name|tmo
operator|=
name|TimeOuts
operator|.
name|to_datablock
operator|*
literal|1000
expr_stmt|;
if|if
condition|(
name|sfdcsasl
argument_list|(
operator|&
name|InChannel
argument_list|,
operator|&
name|OutChannel
argument_list|,
name|conn
argument_list|,
name|tmo
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* restart dialogue */
name|n_helo
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|PIPELINING
operator|(
name|void
operator|)
name|sm_io_autoflush
argument_list|(
name|InChannel
argument_list|,
name|OutChannel
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PIPELINING */
block|}
else|else
name|syserr
argument_list|(
literal|"503 5.3.3 SASL TLS failed"
argument_list|)
expr_stmt|;
block|}
comment|/* NULL pointer ok since it's our function */
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"AUTH=server, relay=%s, authid=%.128s, mech=%.16s, bits=%d"
argument_list|,
name|CurSmtpClient
argument_list|,
name|shortenstring
argument_list|(
name|user
argument_list|,
literal|128
argument_list|)
argument_list|,
name|auth_type
argument_list|,
operator|*
name|ssf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|SASL_CONTINUE
condition|)
block|{
name|len
operator|=
name|ENC64LEN
argument_list|(
name|outlen
argument_list|)
expr_stmt|;
name|out2
operator|=
name|xalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|result
operator|=
name|sasl_encode64
argument_list|(
name|out
argument_list|,
name|outlen
argument_list|,
name|out2
argument_list|,
name|len
argument_list|,
operator|&
name|out2len
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
block|{
comment|/* correct code? XXX */
comment|/* 454 Temp. authentication failure */
name|message
argument_list|(
literal|"454 4.5.4 Internal error: unable to encode64"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"AUTH encode64 error [%d for \"%s\"]"
argument_list|,
name|result
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/* start over? */
name|authenticating
operator|=
name|SASL_NOT_AUTH
expr_stmt|;
block|}
else|else
block|{
name|message
argument_list|(
literal|"334 %s"
argument_list|,
name|out2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|95
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"AUTH continue: msg='%s' len=%u\n"
argument_list|,
name|out2
argument_list|,
name|out2len
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|SASL
operator|>=
literal|20000
name|sm_free
argument_list|(
name|out2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SASL>= 20000 */
block|}
else|else
block|{
comment|/* not SASL_OK or SASL_CONT */
name|message
argument_list|(
literal|"535 5.7.0 authentication failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"AUTH failure (%s): %s (%d) %s"
argument_list|,
name|auth_type
argument_list|,
name|sasl_errstring
argument_list|(
name|result
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|result
argument_list|,
if|#
directive|if
name|SASL
operator|>=
literal|20000
name|sasl_errdetail
argument_list|(
name|conn
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SASL>= 20000 */
name|errstr
operator|==
name|NULL
condition|?
literal|""
else|:
name|errstr
block|)
empty_stmt|;
endif|#
directive|endif
comment|/* SASL>= 20000 */
name|RESET_SASLCONN
expr_stmt|;
name|authenticating
operator|=
name|SASL_NOT_AUTH
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* don't want to do any of this if authenticating */
endif|#
directive|endif
comment|/* SASL */
comment|/* echo command to transcript */
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"<<< %s\n"
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|14
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"<-- %s"
argument_list|,
name|inp
argument_list|)
expr_stmt|;
comment|/* break off command */
for|for
control|(
name|p
operator|=
name|inp
init|;
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
name|cmd
operator|=
name|cmdbuf
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|&&
name|cmd
operator|<
operator|&
name|cmdbuf
index|[
sizeof|sizeof
name|cmdbuf
operator|-
literal|2
index|]
condition|)
operator|*
name|cmd
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|cmd
operator|=
literal|'\0'
expr_stmt|;
comment|/* throw away leading whitespace */
name|SKIP_SPACE
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* decode command */
for|for
control|(
name|c
operator|=
name|CmdTab
init|;
name|c
operator|->
name|cmd_name
operator|!=
name|NULL
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|c
operator|->
name|cmd_name
argument_list|,
name|cmdbuf
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* reset errors */
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* check whether a "non-null" command has been used */
switch|switch
condition|(
name|c
operator|->
name|cmd_code
condition|)
block|{
if|#
directive|if
name|SASL
case|case
name|CMDAUTH
case|:
comment|/* avoid information leak; take first two words? */
name|q
operator|=
literal|"AUTH"
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* SASL */
case|case
name|CMDMAIL
case|:
case|case
name|CMDEXPN
case|:
case|case
name|CMDVRFY
case|:
case|case
name|CMDETRN
case|:
name|lognullconnection
operator|=
name|false
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
name|q
operator|=
name|inp
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|e
operator|->
name|e_id
operator|==
name|NULL
condition|)
name|sm_setproctitle
argument_list|(
name|true
argument_list|,
name|e
argument_list|,
literal|"%s: %.80s"
argument_list|,
name|CurSmtpClient
argument_list|,
name|q
argument_list|)
expr_stmt|;
else|else
name|sm_setproctitle
argument_list|(
name|true
argument_list|,
name|e
argument_list|,
literal|"%s %s: %.80s"
argument_list|,
name|qid_printname
argument_list|(
name|e
argument_list|)
argument_list|,
name|CurSmtpClient
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* 		**  Process command. 		** 		**	If we are running as a null server, return 550 		**	to almost everything. 		*/
if|if
condition|(
name|nullserver
operator|!=
name|NULL
operator|||
name|bitnset
argument_list|(
name|D_ETRNONLY
argument_list|,
name|d_flags
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|c
operator|->
name|cmd_code
condition|)
block|{
case|case
name|CMDQUIT
case|:
case|case
name|CMDHELO
case|:
case|case
name|CMDEHLO
case|:
case|case
name|CMDNOOP
case|:
case|case
name|CMDRSET
case|:
case|case
name|CMDERROR
case|:
comment|/* process normally */
break|break;
case|case
name|CMDETRN
case|:
if|if
condition|(
name|bitnset
argument_list|(
name|D_ETRNONLY
argument_list|,
name|d_flags
argument_list|)
operator|&&
name|nullserver
operator|==
name|NULL
condition|)
break|break;
name|DELAY_CONN
argument_list|(
literal|"ETRN"
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
if|#
directive|if
name|MAXBADCOMMANDS
operator|>
literal|0
comment|/* theoretically this could overflow */
if|if
condition|(
name|nullserver
operator|!=
name|NULL
operator|&&
operator|++
name|n_badcmds
operator|>
name|MAXBADCOMMANDS
condition|)
block|{
name|message
argument_list|(
literal|"421 4.7.0 %s Too many bad commands; closing connection"
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
comment|/* arrange to ignore send list */
name|e
operator|->
name|e_sendqueue
operator|=
name|NULL
expr_stmt|;
goto|goto
name|doquit
goto|;
block|}
endif|#
directive|endif
comment|/* MAXBADCOMMANDS> 0 */
if|if
condition|(
name|nullserver
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ISSMTPREPLY
argument_list|(
name|nullserver
argument_list|)
condition|)
name|usrerr
argument_list|(
name|nullserver
argument_list|)
expr_stmt|;
else|else
name|usrerr
argument_list|(
literal|"550 5.0.0 %s"
argument_list|,
name|nullserver
argument_list|)
expr_stmt|;
block|}
else|else
name|usrerr
argument_list|(
literal|"452 4.4.5 Insufficient disk space; try again later"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
switch|switch
condition|(
name|c
operator|->
name|cmd_code
condition|)
block|{
if|#
directive|if
name|SASL
case|case
name|CMDAUTH
case|:
comment|/* sasl */
name|DELAY_CONN
argument_list|(
literal|"AUTH"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sasl_ok
operator|||
name|n_mechs
operator|<=
literal|0
condition|)
block|{
name|message
argument_list|(
literal|"503 5.3.3 AUTH not available"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|authenticating
operator|==
name|SASL_IS_AUTH
condition|)
block|{
name|message
argument_list|(
literal|"503 5.5.0 Already Authenticated"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|smtp
operator|.
name|sm_gotmail
condition|)
block|{
name|message
argument_list|(
literal|"503 5.5.0 AUTH not permitted during a mail transaction"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tempfail
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"SMTP AUTH command (%.100s) from %s tempfailed (due to previous checks)"
argument_list|,
name|p
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
name|usrerr
argument_list|(
literal|"454 4.3.0 Please try again later"
argument_list|)
expr_stmt|;
break|break;
block|}
name|ismore
operator|=
name|false
expr_stmt|;
comment|/* crude way to avoid crack attempts */
name|STOP_IF_ATTACK
argument_list|(
name|checksmtpattack
argument_list|(
operator|&
name|n_auth
argument_list|,
name|n_mechs
operator|+
literal|1
argument_list|,
name|true
argument_list|,
literal|"AUTH"
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
comment|/* make sure mechanism (p) is a valid string */
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
operator|!=
literal|'\0'
operator|&&
name|isascii
argument_list|(
operator|*
name|q
argument_list|)
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|q
argument_list|)
condition|)
block|{
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|q
operator|!=
literal|'\0'
operator|&&
name|isascii
argument_list|(
operator|*
name|q
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|q
argument_list|)
condition|)
continue|continue;
operator|*
operator|(
name|q
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|ismore
operator|=
operator|(
operator|*
name|q
operator|!=
literal|'\0'
operator|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|message
argument_list|(
literal|"501 5.5.2 AUTH mechanism must be specified"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* check whether mechanism is available */
if|if
condition|(
name|iteminlist
argument_list|(
name|p
argument_list|,
name|mechlist
argument_list|,
literal|" "
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|message
argument_list|(
literal|"504 5.3.3 AUTH mechanism %.32s not available"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ismore
condition|)
block|{
comment|/* could this be shorter? XXX */
if|#
directive|if
name|SASL
operator|>=
literal|20000
name|in
operator|=
name|xalloc
argument_list|(
name|strlen
argument_list|(
name|q
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|sasl_decode64
argument_list|(
name|q
argument_list|,
name|strlen
argument_list|(
name|q
argument_list|)
argument_list|,
name|in
argument_list|,
name|strlen
argument_list|(
name|q
argument_list|)
argument_list|,
operator|&
name|inlen
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SASL>= 20000 */
name|in
operator|=
name|sm_rpool_malloc
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|strlen
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|sasl_decode64
argument_list|(
name|q
argument_list|,
name|strlen
argument_list|(
name|q
argument_list|)
argument_list|,
name|in
argument_list|,
operator|&
name|inlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SASL>= 20000 */
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
block|{
name|message
argument_list|(
literal|"501 5.5.4 cannot BASE64 decode '%s'"
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"AUTH decode64 error [%d for \"%s\"]"
argument_list|,
name|result
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* start over? */
name|authenticating
operator|=
name|SASL_NOT_AUTH
expr_stmt|;
if|#
directive|if
name|SASL
operator|>=
literal|20000
name|sm_free
argument_list|(
name|in
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SASL>= 20000 */
name|in
operator|=
name|NULL
expr_stmt|;
name|inlen
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|in
operator|=
name|NULL
expr_stmt|;
name|inlen
operator|=
literal|0
expr_stmt|;
block|}
comment|/* see if that auth type exists */
if|#
directive|if
name|SASL
operator|>=
literal|20000
name|result
operator|=
name|sasl_server_start
argument_list|(
name|conn
argument_list|,
name|p
argument_list|,
name|in
argument_list|,
name|inlen
argument_list|,
operator|&
name|out
argument_list|,
operator|&
name|outlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|in
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SASL>= 20000 */
name|result
operator|=
name|sasl_server_start
argument_list|(
name|conn
argument_list|,
name|p
argument_list|,
name|in
argument_list|,
name|inlen
argument_list|,
operator|&
name|out
argument_list|,
operator|&
name|outlen
argument_list|,
operator|&
name|errstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SASL>= 20000 */
if|if
condition|(
name|result
operator|!=
name|SASL_OK
operator|&&
name|result
operator|!=
name|SASL_CONTINUE
condition|)
block|{
name|message
argument_list|(
literal|"535 5.7.0 authentication failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"AUTH failure (%s): %s (%d) %s"
argument_list|,
name|p
argument_list|,
name|sasl_errstring
argument_list|(
name|result
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|result
argument_list|,
if|#
directive|if
name|SASL
operator|>=
literal|20000
name|sasl_errdetail
argument_list|(
name|conn
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SASL>= 20000 */
name|errstr
block|)
empty_stmt|;
endif|#
directive|endif
comment|/* SASL>= 20000 */
name|RESET_SASLCONN
expr_stmt|;
break|break;
block|}
name|auth_type
operator|=
name|newstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|SASL_OK
condition|)
block|{
comment|/* ugly, but same code */
goto|goto
name|authenticated
goto|;
comment|/* authenticated by the initial response */
block|}
comment|/* len is at least 2 */
name|len
operator|=
name|ENC64LEN
argument_list|(
name|outlen
argument_list|)
expr_stmt|;
name|out2
operator|=
name|xalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|result
operator|=
name|sasl_encode64
argument_list|(
name|out
argument_list|,
name|outlen
argument_list|,
name|out2
argument_list|,
name|len
argument_list|,
operator|&
name|out2len
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
block|{
name|message
argument_list|(
literal|"454 4.5.4 Temporary authentication failure"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"AUTH encode64 error [%d for \"%s\"]"
argument_list|,
name|result
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/* start over? */
name|authenticating
operator|=
name|SASL_NOT_AUTH
expr_stmt|;
name|RESET_SASLCONN
expr_stmt|;
block|}
else|else
block|{
name|message
argument_list|(
literal|"334 %s"
argument_list|,
name|out2
argument_list|)
expr_stmt|;
name|authenticating
operator|=
name|SASL_PROC_AUTH
expr_stmt|;
block|}
if|#
directive|if
name|SASL
operator|>=
literal|20000
name|sm_free
argument_list|(
name|out2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SASL>= 20000 */
break|break;
endif|#
directive|endif
comment|/* SASL */
if|#
directive|if
name|STARTTLS
case|case
name|CMDSTLS
case|:
comment|/* starttls */
name|DELAY_CONN
argument_list|(
literal|"STARTTLS"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|message
argument_list|(
literal|"501 5.5.2 Syntax error (no parameters allowed)"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|SRV_OFFER_TLS
argument_list|,
name|features
argument_list|)
condition|)
block|{
name|message
argument_list|(
literal|"503 5.5.0 TLS not available"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|tls_ok_srv
condition|)
block|{
name|message
argument_list|(
literal|"454 4.3.3 TLS not available after start"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|smtp
operator|.
name|sm_gotmail
condition|)
block|{
name|message
argument_list|(
literal|"503 5.5.0 TLS not permitted during a mail transaction"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tempfail
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"SMTP STARTTLS command (%.100s) from %s tempfailed (due to previous checks)"
argument_list|,
name|p
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
name|usrerr
argument_list|(
literal|"454 4.7.0 Please try again later"
argument_list|)
expr_stmt|;
break|break;
block|}
name|starttls
label|:
if|#
directive|if
name|TLS_NO_RSA
comment|/* 			**  XXX do we need a temp key ? 			*/
else|#
directive|else
comment|/* TLS_NO_RSA */
endif|#
directive|endif
comment|/* TLS_NO_RSA */
if|#
directive|if
name|TLS_VRFY_PER_CTX
comment|/* 			**  Note: this sets the verification globally 			**  (per SSL_CTX) 			**  it's ok since it applies only to one transaction 			*/
name|TLS_VERIFY_CLIENT
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* TLS_VRFY_PER_CTX */
if|if
condition|(
name|srv_ssl
operator|!=
name|NULL
condition|)
name|SSL_clear
argument_list|(
name|srv_ssl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|srv_ssl
operator|=
name|SSL_new
argument_list|(
name|srv_ctx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|message
argument_list|(
literal|"454 4.3.3 TLS not available: error generating SSL handle"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|tlslogerr
argument_list|(
literal|"server"
argument_list|)
expr_stmt|;
goto|goto
name|tls_done
goto|;
block|}
if|#
directive|if
operator|!
name|TLS_VRFY_PER_CTX
comment|/* 			**  this could be used if it were possible to set 			**  verification per SSL (connection) 			**  not just per SSL_CTX (global) 			*/
name|TLS_VERIFY_CLIENT
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* !TLS_VRFY_PER_CTX */
name|rfd
operator|=
name|sm_io_getinfo
argument_list|(
name|InChannel
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|wfd
operator|=
name|sm_io_getinfo
argument_list|(
name|OutChannel
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rfd
operator|<
literal|0
operator|||
name|wfd
operator|<
literal|0
operator|||
name|SSL_set_rfd
argument_list|(
name|srv_ssl
argument_list|,
name|rfd
argument_list|)
operator|<=
literal|0
operator|||
name|SSL_set_wfd
argument_list|(
name|srv_ssl
argument_list|,
name|wfd
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|message
argument_list|(
literal|"454 4.3.3 TLS not available: error set fd"
argument_list|)
expr_stmt|;
name|SSL_free
argument_list|(
name|srv_ssl
argument_list|)
expr_stmt|;
name|srv_ssl
operator|=
name|NULL
expr_stmt|;
goto|goto
name|tls_done
goto|;
block|}
if|if
condition|(
operator|!
name|smtps
condition|)
name|message
argument_list|(
literal|"220 2.0.0 Ready to start TLS"
argument_list|)
expr_stmt|;
if|#
directive|if
name|PIPELINING
operator|(
name|void
operator|)
name|sm_io_flush
argument_list|(
name|OutChannel
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PIPELINING */
name|SSL_set_accept_state
argument_list|(
name|srv_ssl
argument_list|)
expr_stmt|;
define|#
directive|define
name|SSL_ACC
parameter_list|(
name|s
parameter_list|)
value|SSL_accept(s)
name|tlsstart
operator|=
name|curtime
argument_list|()
expr_stmt|;
name|ssl_retry
label|:
if|if
condition|(
operator|(
name|r
operator|=
name|SSL_ACC
argument_list|(
name|srv_ssl
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|,
name|ssl_err
decl_stmt|;
name|ssl_err
operator|=
name|SSL_get_error
argument_list|(
name|srv_ssl
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|i
operator|=
name|tls_retry
argument_list|(
name|srv_ssl
argument_list|,
name|rfd
argument_list|,
name|wfd
argument_list|,
name|tlsstart
argument_list|,
name|TimeOuts
operator|.
name|to_starttls
argument_list|,
name|ssl_err
argument_list|,
literal|"server"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
goto|goto
name|ssl_retry
goto|;
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=server, error: accept failed=%d, SSL_error=%d, errno=%d, retry=%d"
argument_list|,
name|r
argument_list|,
name|ssl_err
argument_list|,
name|errno
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|tlslogerr
argument_list|(
literal|"server"
argument_list|)
expr_stmt|;
block|}
name|tls_ok_srv
operator|=
name|false
expr_stmt|;
name|SSL_free
argument_list|(
name|srv_ssl
argument_list|)
expr_stmt|;
name|srv_ssl
operator|=
name|NULL
expr_stmt|;
comment|/* 				**  according to the next draft of 				**  RFC 2487 the connection should be dropped 				*/
comment|/* arrange to ignore any current send list */
name|e
operator|->
name|e_sendqueue
operator|=
name|NULL
expr_stmt|;
goto|goto
name|doquit
goto|;
block|}
comment|/* ignore return code for now, it's in {verify} */
operator|(
name|void
operator|)
name|tls_get_info
argument_list|(
name|srv_ssl
argument_list|,
name|true
argument_list|,
name|CurSmtpClient
argument_list|,
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|bitset
argument_list|(
name|SRV_VRFY_CLT
argument_list|,
name|features
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			**  call Stls_client to find out whether 			**  to accept the connection from the client 			*/
name|saveQuickAbort
operator|=
name|QuickAbort
expr_stmt|;
name|saveSuprErrs
operator|=
name|SuprErrs
expr_stmt|;
name|SuprErrs
operator|=
name|true
expr_stmt|;
name|QuickAbort
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|rscheck
argument_list|(
literal|"tls_client"
argument_list|,
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{verify}"
argument_list|)
argument_list|,
name|e
argument_list|)
argument_list|,
literal|"STARTTLS"
argument_list|,
name|e
argument_list|,
name|RSF_RMCOMM
operator||
name|RSF_COUNT
argument_list|,
literal|5
argument_list|,
name|NULL
argument_list|,
name|NOQID
argument_list|)
operator|!=
name|EX_OK
operator|||
name|Errors
operator|>
literal|0
condition|)
block|{
specifier|extern
name|char
name|MsgBuf
index|[]
decl_stmt|;
if|if
condition|(
name|MsgBuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|ISSMTPREPLY
argument_list|(
name|MsgBuf
argument_list|)
condition|)
name|nullserver
operator|=
name|newstr
argument_list|(
name|MsgBuf
argument_list|)
expr_stmt|;
else|else
name|nullserver
operator|=
literal|"503 5.7.0 Authentication required."
expr_stmt|;
block|}
name|QuickAbort
operator|=
name|saveQuickAbort
expr_stmt|;
name|SuprErrs
operator|=
name|saveSuprErrs
expr_stmt|;
name|tls_ok_srv
operator|=
name|false
expr_stmt|;
comment|/* don't offer STARTTLS again */
name|n_helo
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|SASL
if|if
condition|(
name|sasl_ok
condition|)
block|{
name|int
name|cipher_bits
decl_stmt|;
name|bool
name|verified
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|v
decl_stmt|,
modifier|*
name|c
decl_stmt|;
name|s
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{cipher_bits}"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|v
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{verify}"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|c
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{cert_subject}"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|verified
operator|=
operator|(
name|v
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"OK"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|cipher_bits
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|#
directive|if
name|SASL
operator|>=
literal|20000
name|ext_ssf
operator|=
name|cipher_bits
expr_stmt|;
name|auth_id
operator|=
name|verified
condition|?
name|c
else|:
name|NULL
expr_stmt|;
name|sasl_ok
operator|=
operator|(
operator|(
name|sasl_setprop
argument_list|(
name|conn
argument_list|,
name|SASL_SSF_EXTERNAL
argument_list|,
operator|&
name|ext_ssf
argument_list|)
operator|==
name|SASL_OK
operator|)
operator|&&
operator|(
name|sasl_setprop
argument_list|(
name|conn
argument_list|,
name|SASL_AUTH_EXTERNAL
argument_list|,
name|auth_id
argument_list|)
operator|==
name|SASL_OK
operator|)
operator|)
expr_stmt|;
else|#
directive|else
comment|/* SASL>= 20000 */
name|ext_ssf
operator|.
name|ssf
operator|=
name|cipher_bits
expr_stmt|;
name|ext_ssf
operator|.
name|auth_id
operator|=
name|verified
condition|?
name|c
else|:
name|NULL
expr_stmt|;
name|sasl_ok
operator|=
name|sasl_setprop
argument_list|(
name|conn
argument_list|,
name|SASL_SSF_EXTERNAL
argument_list|,
operator|&
name|ext_ssf
argument_list|)
operator|==
name|SASL_OK
expr_stmt|;
endif|#
directive|endif
comment|/* SASL>= 20000 */
name|mechlist
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sasl_ok
condition|)
name|n_mechs
operator|=
name|saslmechs
argument_list|(
name|conn
argument_list|,
operator|&
name|mechlist
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SASL */
comment|/* switch to secure connection */
if|if
condition|(
name|sfdctls
argument_list|(
operator|&
name|InChannel
argument_list|,
operator|&
name|OutChannel
argument_list|,
name|srv_ssl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tls_active
operator|=
name|true
expr_stmt|;
if|#
directive|if
name|PIPELINING
operator|(
name|void
operator|)
name|sm_io_autoflush
argument_list|(
name|InChannel
argument_list|,
name|OutChannel
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PIPELINING */
block|}
else|else
block|{
comment|/* 				**  XXX this is an internal error 				**  how to deal with it? 				**  we can't generate an error message 				**  since the other side switched to an 				**  encrypted layer, but we could not... 				**  just "hang up"? 				*/
name|nullserver
operator|=
literal|"454 4.3.3 TLS not available: can't switch to encrypted layer"
expr_stmt|;
name|syserr
argument_list|(
literal|"STARTTLS: can't switch to encrypted layer"
argument_list|)
expr_stmt|;
block|}
name|tls_done
label|:
if|if
condition|(
name|smtps
condition|)
block|{
if|if
condition|(
name|tls_active
condition|)
goto|goto
name|greeting
goto|;
else|else
goto|goto
name|doquit
goto|;
block|}
break|break;
endif|#
directive|endif
comment|/* STARTTLS */
case|case
name|CMDHELO
case|:
comment|/* hello -- introduce yourself */
case|case
name|CMDEHLO
case|:
comment|/* extended hello */
name|DELAY_CONN
argument_list|(
literal|"EHLO"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|cmd_code
operator|==
name|CMDEHLO
condition|)
block|{
name|protocol
operator|=
literal|"ESMTP"
expr_stmt|;
name|SmtpPhase
operator|=
literal|"server EHLO"
expr_stmt|;
block|}
else|else
block|{
name|protocol
operator|=
literal|"SMTP"
expr_stmt|;
name|SmtpPhase
operator|=
literal|"server HELO"
expr_stmt|;
block|}
comment|/* avoid denial-of-service */
name|STOP_IF_ATTACK
argument_list|(
name|checksmtpattack
argument_list|(
operator|&
name|n_helo
argument_list|,
name|MAXHELOCOMMANDS
argument_list|,
name|true
argument_list|,
literal|"HELO/EHLO"
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* RFC2821 4.1.4 allows duplicate HELO/EHLO */
comment|/* check for duplicate HELO/EHLO per RFC 1651 4.2 */
block|if (gothello) 			{ 				usrerr("503 %s Duplicate HELO/EHLO", 				       MyHostName); 				break; 			}
endif|#
directive|endif
comment|/* 0 */
comment|/* check for valid domain name (re 1123 5.2.5) */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|&&
operator|!
name|AllowBogusHELO
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 %s requires domain address"
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* check for long domain name (hides Received: info) */
if|if
condition|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|>
name|MAXNAME
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 Invalid domain name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"invalid domain name (too long) from %s"
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
break|break;
block|}
name|ok
operator|=
name|true
expr_stmt|;
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
operator|!=
literal|'\0'
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|q
argument_list|)
condition|)
break|break;
if|if
condition|(
name|isalnum
argument_list|(
operator|*
name|q
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|q
argument_list|)
condition|)
block|{
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
comment|/* only complain if strict check */
name|ok
operator|=
name|AllowBogusHELO
expr_stmt|;
comment|/* allow trailing whitespace */
while|while
condition|(
operator|!
name|ok
operator|&&
operator|*
operator|++
name|q
operator|!=
literal|'\0'
operator|&&
name|isspace
argument_list|(
operator|*
name|q
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
condition|)
name|ok
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strchr
argument_list|(
literal|"[].-_#:"
argument_list|,
operator|*
name|q
argument_list|)
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
operator|&&
name|ok
condition|)
block|{
name|q
operator|=
literal|"pleased to meet you"
expr_stmt|;
name|sendinghost
operator|=
name|sm_strdup_x
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|AllowBogusHELO
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 Invalid domain name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"invalid domain name (%s) from %.100s"
argument_list|,
name|p
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|q
operator|=
literal|"accepting invalid domain name"
expr_stmt|;
block|}
if|if
condition|(
name|gothello
operator|||
name|smtp
operator|.
name|sm_gotmail
condition|)
name|CLEAR_STATE
argument_list|(
name|cmdbuf
argument_list|)
expr_stmt|;
if|#
directive|if
name|MILTER
if|if
condition|(
name|smtp
operator|.
name|sm_milterlist
operator|&&
name|smtp
operator|.
name|sm_milterize
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_DISCARD
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|char
name|state
decl_stmt|;
name|char
modifier|*
name|response
decl_stmt|;
name|response
operator|=
name|milter_helo
argument_list|(
name|p
argument_list|,
name|e
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|SMFIR_REPLYCODE
case|:
if|if
condition|(
name|MilterLogLevel
operator|>
literal|3
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: helo=%s, reject=%s"
argument_list|,
name|p
argument_list|,
name|response
argument_list|)
expr_stmt|;
name|nullserver
operator|=
name|newstr
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|smtp
operator|.
name|sm_milterize
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|SMFIR_REJECT
case|:
if|if
condition|(
name|MilterLogLevel
operator|>
literal|3
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: helo=%s, reject=Command rejected"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|nullserver
operator|=
literal|"Command rejected"
expr_stmt|;
name|smtp
operator|.
name|sm_milterize
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|SMFIR_TEMPFAIL
case|:
if|if
condition|(
name|MilterLogLevel
operator|>
literal|3
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: helo=%s, reject=%s"
argument_list|,
name|p
argument_list|,
name|MSG_TEMPFAIL
argument_list|)
expr_stmt|;
name|tempfail
operator|=
name|true
expr_stmt|;
name|smtp
operator|.
name|sm_milterize
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|SMFIR_SHUTDOWN
case|:
if|if
condition|(
name|MilterLogLevel
operator|>
literal|3
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: helo=%s, reject=421 4.7.0 %s closing connection"
argument_list|,
name|p
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
name|tempfail
operator|=
name|true
expr_stmt|;
name|smtp
operator|.
name|sm_milterize
operator|=
name|false
expr_stmt|;
name|message
argument_list|(
literal|"421 4.7.0 %s closing connection"
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
comment|/* arrange to ignore send list */
name|e
operator|->
name|e_sendqueue
operator|=
name|NULL
expr_stmt|;
goto|goto
name|doquit
goto|;
block|}
if|if
condition|(
name|response
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
comment|/* 				**  If quarantining by a connect/ehlo action, 				**  save between messages 				*/
if|if
condition|(
name|smtp
operator|.
name|sm_quarmsg
operator|==
name|NULL
operator|&&
name|e
operator|->
name|e_quarmsg
operator|!=
name|NULL
condition|)
name|smtp
operator|.
name|sm_quarmsg
operator|=
name|newstr
argument_list|(
name|e
operator|->
name|e_quarmsg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MILTER */
name|gothello
operator|=
name|true
expr_stmt|;
comment|/* print HELO response message */
if|if
condition|(
name|c
operator|->
name|cmd_code
operator|!=
name|CMDEHLO
condition|)
block|{
name|message
argument_list|(
literal|"250 %s Hello %s, %s"
argument_list|,
name|MyHostName
argument_list|,
name|CurSmtpClient
argument_list|,
name|q
argument_list|)
expr_stmt|;
break|break;
block|}
name|message
argument_list|(
literal|"250-%s Hello %s, %s"
argument_list|,
name|MyHostName
argument_list|,
name|CurSmtpClient
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* offer ENHSC even for nullserver */
if|if
condition|(
name|nullserver
operator|!=
name|NULL
condition|)
block|{
name|message
argument_list|(
literal|"250 ENHANCEDSTATUSCODES"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			**  print EHLO features list 			** 			**  Note: If you change this list, 			**	  remember to update 'helpfile' 			*/
name|message
argument_list|(
literal|"250-ENHANCEDSTATUSCODES"
argument_list|)
expr_stmt|;
if|#
directive|if
name|PIPELINING
if|if
condition|(
name|bitset
argument_list|(
name|SRV_OFFER_PIPE
argument_list|,
name|features
argument_list|)
condition|)
name|message
argument_list|(
literal|"250-PIPELINING"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PIPELINING */
if|if
condition|(
name|bitset
argument_list|(
name|SRV_OFFER_EXPN
argument_list|,
name|features
argument_list|)
condition|)
block|{
name|message
argument_list|(
literal|"250-EXPN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|SRV_OFFER_VERB
argument_list|,
name|features
argument_list|)
condition|)
name|message
argument_list|(
literal|"250-VERB"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|MIME8TO7
name|message
argument_list|(
literal|"250-8BITMIME"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MIME8TO7 */
if|if
condition|(
name|MaxMessageSize
operator|>
literal|0
condition|)
name|message
argument_list|(
literal|"250-SIZE %ld"
argument_list|,
name|MaxMessageSize
argument_list|)
expr_stmt|;
else|else
name|message
argument_list|(
literal|"250-SIZE"
argument_list|)
expr_stmt|;
if|#
directive|if
name|DSN
if|if
condition|(
name|SendMIMEErrors
operator|&&
name|bitset
argument_list|(
name|SRV_OFFER_DSN
argument_list|,
name|features
argument_list|)
condition|)
name|message
argument_list|(
literal|"250-DSN"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DSN */
if|if
condition|(
name|bitset
argument_list|(
name|SRV_OFFER_ETRN
argument_list|,
name|features
argument_list|)
condition|)
name|message
argument_list|(
literal|"250-ETRN"
argument_list|)
expr_stmt|;
if|#
directive|if
name|SASL
if|if
condition|(
name|sasl_ok
operator|&&
name|mechlist
operator|!=
name|NULL
operator|&&
operator|*
name|mechlist
operator|!=
literal|'\0'
condition|)
name|message
argument_list|(
literal|"250-AUTH %s"
argument_list|,
name|mechlist
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SASL */
if|#
directive|if
name|STARTTLS
if|if
condition|(
name|tls_ok_srv
operator|&&
name|bitset
argument_list|(
name|SRV_OFFER_TLS
argument_list|,
name|features
argument_list|)
condition|)
name|message
argument_list|(
literal|"250-STARTTLS"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* STARTTLS */
if|if
condition|(
name|DeliverByMin
operator|>
literal|0
condition|)
name|message
argument_list|(
literal|"250-DELIVERBY %ld"
argument_list|,
operator|(
name|long
operator|)
name|DeliverByMin
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DeliverByMin
operator|==
literal|0
condition|)
name|message
argument_list|(
literal|"250-DELIVERBY"
argument_list|)
expr_stmt|;
comment|/*< 0: no deliver-by */
name|message
argument_list|(
literal|"250 HELP"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDMAIL
case|:
comment|/* mail -- designate sender */
name|SmtpPhase
operator|=
literal|"server MAIL"
expr_stmt|;
name|DELAY_CONN
argument_list|(
literal|"MAIL"
argument_list|)
expr_stmt|;
comment|/* check for validity of this command */
if|if
condition|(
operator|!
name|gothello
operator|&&
name|bitset
argument_list|(
name|PRIV_NEEDMAILHELO
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"503 5.0.0 Polite people say HELO first"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|smtp
operator|.
name|sm_gotmail
condition|)
block|{
name|usrerr
argument_list|(
literal|"503 5.5.0 Sender already specified"
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|SASL
if|if
condition|(
name|bitset
argument_list|(
name|SRV_REQ_AUTH
argument_list|,
name|features
argument_list|)
operator|&&
name|authenticating
operator|!=
name|SASL_IS_AUTH
condition|)
block|{
name|usrerr
argument_list|(
literal|"530 5.7.0 Authentication required"
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* SASL */
name|p
operator|=
name|skipword
argument_list|(
name|p
argument_list|,
literal|"from"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|tempfail
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"SMTP MAIL command (%.100s) from %s tempfailed (due to previous checks)"
argument_list|,
name|p
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
name|usrerr
argument_list|(
name|MSG_TEMPFAIL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* make sure we know who the sending host is */
if|if
condition|(
name|sendinghost
operator|==
name|NULL
condition|)
name|sendinghost
operator|=
name|peerhostname
expr_stmt|;
if|#
directive|if
name|SM_HEAP_CHECK
if|if
condition|(
name|sm_debug_active
argument_list|(
operator|&
name|DebugLeakSmtp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_heap_newgroup
argument_list|()
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"smtp() heap group #%d\n"
argument_list|,
name|sm_heap_group
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SM_HEAP_CHECK */
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|undo_no_pm
goto|;
if|if
condition|(
operator|!
name|gothello
condition|)
block|{
name|auth_warning
argument_list|(
name|e
argument_list|,
literal|"%s didn't use HELO protocol"
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PICKY_HELO_CHECK
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|sendinghost
argument_list|,
name|peerhostname
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|sm_strcasecmp
argument_list|(
name|peerhostname
argument_list|,
literal|"localhost"
argument_list|)
operator|!=
literal|0
operator|||
name|sm_strcasecmp
argument_list|(
name|sendinghost
argument_list|,
name|MyHostName
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|auth_warning
argument_list|(
name|e
argument_list|,
literal|"Host %s claimed to be %s"
argument_list|,
name|CurSmtpClient
argument_list|,
name|sendinghost
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PICKY_HELO_CHECK */
if|if
condition|(
name|protocol
operator|==
name|NULL
condition|)
name|protocol
operator|=
literal|"SMTP"
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'r'
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'s'
argument_list|,
name|sendinghost
argument_list|)
expr_stmt|;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|undo_no_pm
goto|;
name|smtp
operator|.
name|sm_nrcpts
operator|=
literal|0
expr_stmt|;
name|n_badrcpts
operator|=
literal|0
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{ntries}"
argument_list|)
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{nrcpts}"
argument_list|)
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{nbadrcpts}"
argument_list|)
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_CLRQUEUE
expr_stmt|;
name|sm_setproctitle
argument_list|(
name|true
argument_list|,
name|e
argument_list|,
literal|"%s %s: %.80s"
argument_list|,
name|qid_printname
argument_list|(
name|e
argument_list|)
argument_list|,
name|CurSmtpClient
argument_list|,
name|inp
argument_list|)
expr_stmt|;
comment|/* do the processing */
name|SM_TRY
block|{
specifier|extern
name|char
modifier|*
name|FullName
decl_stmt|;
name|QuickAbort
operator|=
name|true
expr_stmt|;
name|SM_FREE_CLR
argument_list|(
name|FullName
argument_list|)
expr_stmt|;
comment|/* must parse sender first */
name|delimptr
operator|=
name|NULL
expr_stmt|;
name|setsender
argument_list|(
name|p
argument_list|,
name|e
argument_list|,
operator|&
name|delimptr
argument_list|,
literal|' '
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|delimptr
operator|!=
name|NULL
operator|&&
operator|*
name|delimptr
operator|!=
literal|'\0'
condition|)
operator|*
name|delimptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
name|sm_exc_raisenew_x
argument_list|(
operator|&
name|EtypeQuickAbort
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Successfully set e_from, allow logging */
name|e
operator|->
name|e_flags
operator||=
name|EF_LOGSENDER
expr_stmt|;
comment|/* put resulting triple from parseaddr() into macros */
if|if
condition|(
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|!=
name|NULL
condition|)
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{mail_mailer}"
argument_list|)
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|->
name|m_name
argument_list|)
expr_stmt|;
else|else
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{mail_mailer}"
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_from
operator|.
name|q_host
operator|!=
name|NULL
condition|)
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{mail_host}"
argument_list|)
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_host
argument_list|)
expr_stmt|;
else|else
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{mail_host}"
argument_list|)
argument_list|,
literal|"localhost"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_from
operator|.
name|q_user
operator|!=
name|NULL
condition|)
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{mail_addr}"
argument_list|)
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_user
argument_list|)
expr_stmt|;
else|else
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{mail_addr}"
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
name|sm_exc_raisenew_x
argument_list|(
operator|&
name|EtypeQuickAbort
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* check for possible spoofing */
if|if
condition|(
name|RealUid
operator|!=
literal|0
operator|&&
name|OpMode
operator|==
name|MD_SMTP
operator|&&
operator|!
name|wordinclass
argument_list|(
name|RealUserName
argument_list|,
literal|'t'
argument_list|)
operator|&&
operator|(
operator|!
name|bitnset
argument_list|(
name|M_LOCALMAILER
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|->
name|m_flags
argument_list|)
operator|||
name|strcmp
argument_list|(
name|e
operator|->
name|e_from
operator|.
name|q_user
argument_list|,
name|RealUserName
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|auth_warning
argument_list|(
name|e
argument_list|,
literal|"%s owned process doing -bs"
argument_list|,
name|RealUserName
argument_list|)
expr_stmt|;
block|}
comment|/* reset to default value */
name|SevenBitInput
operator|=
name|save_sevenbitinput
expr_stmt|;
comment|/* now parse ESMTP arguments */
name|e
operator|->
name|e_msgsize
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|p
expr_stmt|;
name|argno
operator|=
literal|0
expr_stmt|;
name|args
index|[
name|argno
operator|++
index|]
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|delimptr
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|kp
decl_stmt|;
name|char
modifier|*
name|vp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|equal
init|=
name|NULL
decl_stmt|;
comment|/* locate the beginning of the keyword */
name|SKIP_SPACE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
name|kp
operator|=
name|p
expr_stmt|;
comment|/* skip to the value portion */
while|while
condition|(
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|||
operator|*
name|p
operator|==
literal|'-'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'='
condition|)
block|{
name|equal
operator|=
name|p
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|vp
operator|=
name|p
expr_stmt|;
comment|/* skip to the end of the value */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|iscntrl
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|&&
operator|*
name|p
operator|!=
literal|'='
condition|)
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|19
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"MAIL: got arg %s=\"%s\"\n"
argument_list|,
name|kp
argument_list|,
name|vp
operator|==
name|NULL
condition|?
literal|"<null>"
else|:
name|vp
argument_list|)
expr_stmt|;
name|mail_esmtp_args
argument_list|(
name|kp
argument_list|,
name|vp
argument_list|,
name|e
argument_list|,
name|features
argument_list|)
expr_stmt|;
if|if
condition|(
name|equal
operator|!=
name|NULL
condition|)
operator|*
name|equal
operator|=
literal|'='
expr_stmt|;
name|args
index|[
name|argno
operator|++
index|]
operator|=
name|kp
expr_stmt|;
if|if
condition|(
name|argno
operator|>=
name|MAXSMTPARGS
operator|-
literal|1
condition|)
name|usrerr
argument_list|(
literal|"501 5.5.4 Too many parameters"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
name|sm_exc_raisenew_x
argument_list|(
operator|&
name|EtypeQuickAbort
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|args
index|[
name|argno
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
name|sm_exc_raisenew_x
argument_list|(
operator|&
name|EtypeQuickAbort
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|SASL
if|#
directive|if
name|_FFR_AUTH_PASSING
comment|/* set the default AUTH= if the sender didn't */
if|if
condition|(
name|e
operator|->
name|e_auth_param
operator|==
name|NULL
condition|)
block|{
comment|/* XXX only do this for an MSA? */
name|e
operator|->
name|e_auth_param
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{auth_authen}"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_auth_param
operator|==
name|NULL
condition|)
name|e
operator|->
name|e_auth_param
operator|=
literal|"<>"
expr_stmt|;
comment|/* 				**  XXX should we invoke Strust_auth now? 				**  authorizing as the client that just 				**  authenticated, so we'll trust implicitly 				*/
block|}
endif|#
directive|endif
comment|/* _FFR_AUTH_PASSING */
endif|#
directive|endif
comment|/* SASL */
comment|/* do config file checking of the sender */
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{addr_type}"
argument_list|)
argument_list|,
literal|"e s"
argument_list|)
expr_stmt|;
if|#
directive|if
name|_FFR_MAIL_MACRO
comment|/* make the "real" sender address available */
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{mail_from}"
argument_list|)
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_MAIL_MACRO */
if|if
condition|(
name|rscheck
argument_list|(
literal|"check_mail"
argument_list|,
name|addr
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
name|RSF_RMCOMM
operator||
name|RSF_COUNT
argument_list|,
literal|3
argument_list|,
name|NULL
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
operator|!=
name|EX_OK
operator|||
name|Errors
operator|>
literal|0
condition|)
name|sm_exc_raisenew_x
argument_list|(
operator|&
name|EtypeQuickAbort
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{addr_type}"
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|MaxMessageSize
operator|>
literal|0
operator|&&
operator|(
name|e
operator|->
name|e_msgsize
operator|>
name|MaxMessageSize
operator|||
name|e
operator|->
name|e_msgsize
operator|<
literal|0
operator|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"552 5.2.3 Message size exceeds fixed maximum message size (%ld)"
argument_list|,
name|MaxMessageSize
argument_list|)
expr_stmt|;
name|sm_exc_raisenew_x
argument_list|(
operator|&
name|EtypeQuickAbort
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 			**  XXX always check whether there is at least one fs 			**  with enough space? 			**  However, this may not help much: the queue group 			**  selection may later on select a FS that hasn't 			**  enough space. 			*/
if|if
condition|(
operator|(
name|NumFileSys
operator|==
literal|1
operator|||
name|NumQueue
operator|==
literal|1
operator|)
operator|&&
operator|!
name|enoughdiskspace
argument_list|(
name|e
operator|->
name|e_msgsize
argument_list|,
name|e
argument_list|)
if|#
directive|if
name|_FFR_ANY_FREE_FS
operator|&&
operator|!
name|filesys_free
argument_list|(
name|e
operator|->
name|e_msgsize
argument_list|)
endif|#
directive|endif
comment|/* _FFR_ANY_FREE_FS */
condition|)
block|{
comment|/* 				**  We perform this test again when the 				**  queue directory is selected, in collect. 				*/
name|usrerr
argument_list|(
literal|"452 4.4.5 Insufficient disk space; try again later"
argument_list|)
expr_stmt|;
name|sm_exc_raisenew_x
argument_list|(
operator|&
name|EtypeQuickAbort
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
name|sm_exc_raisenew_x
argument_list|(
operator|&
name|EtypeQuickAbort
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|LogUsrErrs
operator|=
name|true
expr_stmt|;
if|#
directive|if
name|MILTER
if|if
condition|(
name|smtp
operator|.
name|sm_milterlist
operator|&&
name|smtp
operator|.
name|sm_milterize
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_DISCARD
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|char
name|state
decl_stmt|;
name|char
modifier|*
name|response
decl_stmt|;
name|response
operator|=
name|milter_envfrom
argument_list|(
name|args
argument_list|,
name|e
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
name|MILTER_REPLY
argument_list|(
literal|"from"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MILTER */
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
name|sm_exc_raisenew_x
argument_list|(
operator|&
name|EtypeQuickAbort
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"250 2.1.0 Sender ok"
argument_list|)
expr_stmt|;
name|smtp
operator|.
name|sm_gotmail
operator|=
name|true
expr_stmt|;
block|}
name|SM_EXCEPT
argument_list|(
argument|exc
argument_list|,
literal|"[!F]*"
argument_list|)
block|{
comment|/* 			**  An error occurred while processing a MAIL command. 			**  Jump to the common error handling code. 			*/
name|sm_exc_free
argument_list|(
name|exc
argument_list|)
expr_stmt|;
goto|goto
name|undo_no_pm
goto|;
block|}
name|SM_END_TRY
break|break;
name|undo_no_pm
label|:
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_PM_NOTIFY
expr_stmt|;
name|undo
label|:
break|break;
case|case
name|CMDRCPT
case|:
comment|/* rcpt -- designate recipient */
name|DELAY_CONN
argument_list|(
literal|"RCPT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|BadRcptThrottle
operator|>
literal|0
operator|&&
name|n_badrcpts
operator|>=
name|BadRcptThrottle
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|5
operator|&&
name|n_badrcpts
operator|==
name|BadRcptThrottle
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%s: Possible SMTP RCPT flood, throttling."
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
comment|/* To avoid duplicated message */
name|n_badrcpts
operator|++
expr_stmt|;
block|}
name|NBADRCPTS
expr_stmt|;
comment|/* 				**  Don't use exponential backoff for now. 				**  Some servers will open more connections 				**  and actually overload the receiver even 				**  more. 				*/
operator|(
name|void
operator|)
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|smtp
operator|.
name|sm_gotmail
condition|)
block|{
name|usrerr
argument_list|(
literal|"503 5.0.0 Need MAIL before RCPT"
argument_list|)
expr_stmt|;
break|break;
block|}
name|SmtpPhase
operator|=
literal|"server RCPT"
expr_stmt|;
name|SM_TRY
block|{
name|QuickAbort
operator|=
name|true
expr_stmt|;
name|LogUsrErrs
operator|=
name|true
expr_stmt|;
comment|/* limit flooding of our machine */
if|if
condition|(
name|MaxRcptPerMsg
operator|>
literal|0
operator|&&
name|smtp
operator|.
name|sm_nrcpts
operator|>=
name|MaxRcptPerMsg
condition|)
block|{
comment|/* sleep(1); / * slow down? */
name|usrerr
argument_list|(
literal|"452 4.5.3 Too many recipients"
argument_list|)
expr_stmt|;
goto|goto
name|rcpt_done
goto|;
block|}
if|if
condition|(
name|e
operator|->
name|e_sendmode
operator|!=
name|SM_DELIVER
if|#
directive|if
name|_FFR_DM_ONE
operator|&&
operator|(
name|NotFirstDelivery
operator|||
name|SM_DM_ONE
operator|!=
name|e
operator|->
name|e_sendmode
operator|)
endif|#
directive|endif
comment|/* _FFR_DM_ONE */
condition|)
name|e
operator|->
name|e_flags
operator||=
name|EF_VRFYONLY
expr_stmt|;
if|#
directive|if
name|MILTER
comment|/* 			**  If the filter will be deleting recipients, 			**  don't expand them at RCPT time (in the call 			**  to recipient()).  If they are expanded, it 			**  is impossible for removefromlist() to figure 			**  out the expanded members of the original 			**  recipient and mark them as QS_DONTSEND. 			*/
if|if
condition|(
name|milter_can_delrcpts
argument_list|()
condition|)
name|e
operator|->
name|e_flags
operator||=
name|EF_VRFYONLY
expr_stmt|;
endif|#
directive|endif
comment|/* MILTER */
name|p
operator|=
name|skipword
argument_list|(
name|p
argument_list|,
literal|"to"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
goto|goto
name|rcpt_done
goto|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{addr_type}"
argument_list|)
argument_list|,
literal|"e r"
argument_list|)
expr_stmt|;
name|a
operator|=
name|parseaddr
argument_list|(
name|p
argument_list|,
name|NULLADDR
argument_list|,
name|RF_COPYALL
argument_list|,
literal|' '
argument_list|,
operator|&
name|delimptr
argument_list|,
name|e
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{addr_type}"
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|rcpt_done
goto|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.0.0 Missing recipient"
argument_list|)
expr_stmt|;
goto|goto
name|rcpt_done
goto|;
block|}
if|if
condition|(
name|delimptr
operator|!=
name|NULL
operator|&&
operator|*
name|delimptr
operator|!=
literal|'\0'
condition|)
operator|*
name|delimptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* put resulting triple from parseaddr() into macros */
if|if
condition|(
name|a
operator|->
name|q_mailer
operator|!=
name|NULL
condition|)
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{rcpt_mailer}"
argument_list|)
argument_list|,
name|a
operator|->
name|q_mailer
operator|->
name|m_name
argument_list|)
expr_stmt|;
else|else
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{rcpt_mailer}"
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|q_host
operator|!=
name|NULL
condition|)
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{rcpt_host}"
argument_list|)
argument_list|,
name|a
operator|->
name|q_host
argument_list|)
expr_stmt|;
else|else
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{rcpt_host}"
argument_list|)
argument_list|,
literal|"localhost"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|q_user
operator|!=
name|NULL
condition|)
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{rcpt_addr}"
argument_list|)
argument_list|,
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
else|else
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{rcpt_addr}"
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|rcpt_done
goto|;
comment|/* now parse ESMTP arguments */
name|addr
operator|=
name|p
expr_stmt|;
name|argno
operator|=
literal|0
expr_stmt|;
name|args
index|[
name|argno
operator|++
index|]
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|delimptr
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|kp
decl_stmt|;
name|char
modifier|*
name|vp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|equal
init|=
name|NULL
decl_stmt|;
comment|/* locate the beginning of the keyword */
name|SKIP_SPACE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
name|kp
operator|=
name|p
expr_stmt|;
comment|/* skip to the value portion */
while|while
condition|(
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|||
operator|*
name|p
operator|==
literal|'-'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'='
condition|)
block|{
name|equal
operator|=
name|p
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|vp
operator|=
name|p
expr_stmt|;
comment|/* skip to the end of the value */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|iscntrl
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|&&
operator|*
name|p
operator|!=
literal|'='
condition|)
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|19
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"RCPT: got arg %s=\"%s\"\n"
argument_list|,
name|kp
argument_list|,
name|vp
operator|==
name|NULL
condition|?
literal|"<null>"
else|:
name|vp
argument_list|)
expr_stmt|;
name|rcpt_esmtp_args
argument_list|(
name|a
argument_list|,
name|kp
argument_list|,
name|vp
argument_list|,
name|e
argument_list|,
name|features
argument_list|)
expr_stmt|;
if|if
condition|(
name|equal
operator|!=
name|NULL
condition|)
operator|*
name|equal
operator|=
literal|'='
expr_stmt|;
name|args
index|[
name|argno
operator|++
index|]
operator|=
name|kp
expr_stmt|;
if|if
condition|(
name|argno
operator|>=
name|MAXSMTPARGS
operator|-
literal|1
condition|)
name|usrerr
argument_list|(
literal|"501 5.5.4 Too many parameters"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
break|break;
block|}
name|args
index|[
name|argno
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|rcpt_done
goto|;
comment|/* do config file checking of the recipient */
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{addr_type}"
argument_list|)
argument_list|,
literal|"e r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rscheck
argument_list|(
literal|"check_rcpt"
argument_list|,
name|addr
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
name|RSF_RMCOMM
operator||
name|RSF_COUNT
argument_list|,
literal|3
argument_list|,
name|NULL
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
operator|!=
name|EX_OK
operator|||
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|rcpt_done
goto|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{addr_type}"
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If discarding, don't bother to verify user */
if|if
condition|(
name|bitset
argument_list|(
name|EF_DISCARD
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|a
operator|->
name|q_state
operator|=
name|QS_VERIFIED
expr_stmt|;
if|#
directive|if
name|MILTER
if|if
condition|(
name|smtp
operator|.
name|sm_milterlist
operator|&&
name|smtp
operator|.
name|sm_milterize
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_DISCARD
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|char
name|state
decl_stmt|;
name|char
modifier|*
name|response
decl_stmt|;
name|response
operator|=
name|milter_envrcpt
argument_list|(
name|args
argument_list|,
name|e
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
name|MILTER_REPLY
argument_list|(
literal|"to"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MILTER */
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{rcpt_mailer}"
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{rcpt_host}"
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{rcpt_addr}"
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{dsn_notify}"
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|rcpt_done
goto|;
comment|/* save in recipient list after ESMTP mods */
name|a
operator|=
name|recipient
argument_list|(
name|a
argument_list|,
operator|&
name|e
operator|->
name|e_sendqueue
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|rcpt_done
goto|;
comment|/* no errors during parsing, but might be a duplicate */
name|e
operator|->
name|e_to
operator|=
name|a
operator|->
name|q_paddr
expr_stmt|;
if|if
condition|(
operator|!
name|QS_IS_BADADDR
argument_list|(
name|a
operator|->
name|q_state
argument_list|)
condition|)
block|{
if|if
condition|(
name|smtp
operator|.
name|sm_nrcpts
operator|==
literal|0
condition|)
name|initsys
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"250 2.1.5 Recipient ok%s"
argument_list|,
name|QS_IS_QUEUEUP
argument_list|(
name|a
operator|->
name|q_state
argument_list|)
condition|?
literal|" (will queue)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|smtp
operator|.
name|sm_nrcpts
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* punt -- should keep message in ADDRESS.... */
name|usrerr
argument_list|(
literal|"550 5.1.1 Addressee unknown"
argument_list|)
expr_stmt|;
block|}
name|rcpt_done
label|:
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
block|{
operator|++
name|n_badrcpts
expr_stmt|;
name|NBADRCPTS
expr_stmt|;
block|}
block|}
name|SM_EXCEPT
argument_list|(
argument|exc
argument_list|,
literal|"[!F]*"
argument_list|)
block|{
comment|/* An exception occurred while processing RCPT */
name|e
operator|->
name|e_flags
operator|&=
operator|~
operator|(
name|EF_FATALERRS
operator||
name|EF_PM_NOTIFY
operator|)
expr_stmt|;
operator|++
name|n_badrcpts
expr_stmt|;
name|NBADRCPTS
expr_stmt|;
block|}
name|SM_END_TRY
break|break;
case|case
name|CMDDATA
case|:
comment|/* data -- text of mail */
name|DELAY_CONN
argument_list|(
literal|"DATA"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|smtp_data
argument_list|(
operator|&
name|smtp
argument_list|,
name|e
argument_list|)
condition|)
goto|goto
name|doquit
goto|;
break|break;
case|case
name|CMDRSET
case|:
comment|/* rset -- reset state */
if|if
condition|(
name|tTd
argument_list|(
literal|94
argument_list|,
literal|100
argument_list|)
condition|)
name|message
argument_list|(
literal|"451 4.0.0 Test failure"
argument_list|)
expr_stmt|;
else|else
name|message
argument_list|(
literal|"250 2.0.0 Reset state"
argument_list|)
expr_stmt|;
name|CLEAR_STATE
argument_list|(
name|cmdbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDVRFY
case|:
comment|/* vrfy -- verify address */
case|case
name|CMDEXPN
case|:
comment|/* expn -- expand address */
name|vrfy
operator|=
name|c
operator|->
name|cmd_code
operator|==
name|CMDVRFY
expr_stmt|;
name|DELAY_CONN
argument_list|(
name|vrfy
condition|?
literal|"VRFY"
else|:
literal|"EXPN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempfail
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"SMTP %s command (%.100s) from %s tempfailed (due to previous checks)"
argument_list|,
name|vrfy
condition|?
literal|"VRFY"
else|:
literal|"EXPN"
argument_list|,
name|p
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
comment|/* RFC 821 doesn't allow 4xy reply code */
name|usrerr
argument_list|(
literal|"550 5.7.1 Please try again later"
argument_list|)
expr_stmt|;
break|break;
block|}
name|wt
operator|=
name|checksmtpattack
argument_list|(
operator|&
name|n_verifies
argument_list|,
name|MAXVRFYCOMMANDS
argument_list|,
name|false
argument_list|,
name|vrfy
condition|?
literal|"VRFY"
else|:
literal|"EXPN"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|STOP_IF_ATTACK
argument_list|(
name|wt
argument_list|)
expr_stmt|;
name|previous
operator|=
name|curtime
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|vrfy
operator|&&
name|bitset
argument_list|(
name|PRIV_NOVRFY
argument_list|,
name|PrivacyFlags
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|vrfy
operator|&&
operator|!
name|bitset
argument_list|(
name|SRV_OFFER_EXPN
argument_list|,
name|features
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|vrfy
condition|)
name|message
argument_list|(
literal|"252 2.5.2 Cannot VRFY user; try RCPT to attempt delivery (or try finger)"
argument_list|)
expr_stmt|;
else|else
name|message
argument_list|(
literal|"502 5.7.0 Sorry, we do not allow this operation"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%s: %s [rejected]"
argument_list|,
name|CurSmtpClient
argument_list|,
name|shortenstring
argument_list|(
name|inp
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|gothello
operator|&&
name|bitset
argument_list|(
name|vrfy
condition|?
name|PRIV_NEEDVRFYHELO
else|:
name|PRIV_NEEDEXPNHELO
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"503 5.0.0 I demand that you introduce yourself first"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%s: %s"
argument_list|,
name|CurSmtpClient
argument_list|,
name|shortenstring
argument_list|(
name|inp
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|)
expr_stmt|;
name|SM_TRY
block|{
name|QuickAbort
operator|=
name|true
expr_stmt|;
name|vrfyqueue
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|vrfy
condition|)
name|e
operator|->
name|e_flags
operator||=
name|EF_VRFYONLY
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.2 Argument required"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* do config file checking of the address */
if|if
condition|(
name|rscheck
argument_list|(
name|vrfy
condition|?
literal|"check_vrfy"
else|:
literal|"check_expn"
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
name|RSF_RMCOMM
argument_list|,
literal|3
argument_list|,
name|NULL
argument_list|,
name|NOQID
argument_list|)
operator|!=
name|EX_OK
operator|||
name|Errors
operator|>
literal|0
condition|)
name|sm_exc_raisenew_x
argument_list|(
operator|&
name|EtypeQuickAbort
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sendtolist
argument_list|(
name|p
argument_list|,
name|NULLADDR
argument_list|,
operator|&
name|vrfyqueue
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wt
operator|>
literal|0
condition|)
block|{
name|time_t
name|t
decl_stmt|;
name|t
operator|=
name|wt
operator|-
operator|(
name|curtime
argument_list|()
operator|-
name|previous
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|sleep
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
name|sm_exc_raisenew_x
argument_list|(
operator|&
name|EtypeQuickAbort
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrfyqueue
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"554 5.5.2 Nothing to %s"
argument_list|,
name|vrfy
condition|?
literal|"VRFY"
else|:
literal|"EXPN"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|vrfyqueue
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|QS_IS_UNDELIVERED
argument_list|(
name|vrfyqueue
operator|->
name|q_state
argument_list|)
condition|)
block|{
name|vrfyqueue
operator|=
name|vrfyqueue
operator|->
name|q_next
expr_stmt|;
continue|continue;
block|}
comment|/* see if there is more in the vrfy list */
name|a
operator|=
name|vrfyqueue
expr_stmt|;
while|while
condition|(
operator|(
name|a
operator|=
name|a
operator|->
name|q_next
operator|)
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|QS_IS_UNDELIVERED
argument_list|(
name|a
operator|->
name|q_state
argument_list|)
operator|)
condition|)
continue|continue;
name|printvrfyaddr
argument_list|(
name|vrfyqueue
argument_list|,
name|a
operator|==
name|NULL
argument_list|,
name|vrfy
argument_list|)
expr_stmt|;
name|vrfyqueue
operator|=
name|a
expr_stmt|;
block|}
block|}
name|SM_EXCEPT
argument_list|(
argument|exc
argument_list|,
literal|"[!F]*"
argument_list|)
block|{
comment|/* 			**  An exception occurred while processing VRFY/EXPN 			*/
name|sm_exc_free
argument_list|(
name|exc
argument_list|)
expr_stmt|;
goto|goto
name|undo
goto|;
block|}
name|SM_END_TRY
break|break;
case|case
name|CMDETRN
case|:
comment|/* etrn -- force queue flush */
name|DELAY_CONN
argument_list|(
literal|"ETRN"
argument_list|)
expr_stmt|;
comment|/* Don't leak queue information via debug flags */
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|SRV_OFFER_ETRN
argument_list|,
name|features
argument_list|)
operator|||
name|UseMSP
operator|||
operator|(
name|RealUid
operator|!=
literal|0
operator|&&
name|RealUid
operator|!=
name|TrustedUid
operator|&&
name|OpMode
operator|==
name|MD_SMTP
operator|)
condition|)
block|{
comment|/* different message for MSA ? */
name|message
argument_list|(
literal|"502 5.7.0 Sorry, we do not allow this operation"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%s: %s [rejected]"
argument_list|,
name|CurSmtpClient
argument_list|,
name|shortenstring
argument_list|(
name|inp
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tempfail
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"SMTP ETRN command (%.100s) from %s tempfailed (due to previous checks)"
argument_list|,
name|p
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
name|usrerr
argument_list|(
name|MSG_TEMPFAIL
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"500 5.5.2 Parameter required"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* crude way to avoid denial-of-service attacks */
name|STOP_IF_ATTACK
argument_list|(
name|checksmtpattack
argument_list|(
operator|&
name|n_etrn
argument_list|,
name|MAXETRNCOMMANDS
argument_list|,
name|true
argument_list|,
literal|"ETRN"
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			**  Do config file checking of the parameter. 			**  Even though we have srv_features now, we still 			**  need this ruleset because the former is called 			**  when the connection has been established, while 			**  this ruleset is called when the command is 			**  actually issued and therefore has all information 			**  available to make a decision. 			*/
if|if
condition|(
name|rscheck
argument_list|(
literal|"check_etrn"
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
name|RSF_RMCOMM
argument_list|,
literal|3
argument_list|,
name|NULL
argument_list|,
name|NOQID
argument_list|)
operator|!=
name|EX_OK
operator|||
name|Errors
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%s: ETRN %s"
argument_list|,
name|CurSmtpClient
argument_list|,
name|shortenstring
argument_list|(
name|p
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|id
operator|==
literal|'#'
condition|)
block|{
name|int
name|i
decl_stmt|,
name|qgrp
decl_stmt|;
name|id
operator|++
expr_stmt|;
name|qgrp
operator|=
name|name2qid
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISVALIDQGRP
argument_list|(
name|qgrp
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"459 4.5.4 Queue %s unknown"
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NumQueue
operator|&&
name|Queue
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|Queue
index|[
name|i
index|]
operator|->
name|qg_nextrun
operator|=
operator|(
name|time_t
operator|)
operator|-
literal|1
expr_stmt|;
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_nextrun
operator|=
literal|0
expr_stmt|;
name|ok
operator|=
name|run_work_group
argument_list|(
name|Queue
index|[
name|qgrp
index|]
operator|->
name|qg_wgrp
argument_list|,
name|RWG_FORK
operator||
name|RWG_FORCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|&&
name|Errors
operator|==
literal|0
condition|)
name|message
argument_list|(
literal|"250 2.0.0 Queuing for queue group %s started"
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|id
operator|==
literal|'@'
condition|)
name|id
operator|++
expr_stmt|;
else|else
operator|*
operator|--
name|id
operator|=
literal|'@'
expr_stmt|;
name|new
operator|=
operator|(
name|QUEUE_CHAR
operator|*
operator|)
name|sm_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|QUEUE_CHAR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"500 5.5.0 ETRN out of memory"
argument_list|)
expr_stmt|;
break|break;
block|}
name|new
operator|->
name|queue_match
operator|=
name|id
expr_stmt|;
name|new
operator|->
name|queue_negate
operator|=
name|false
expr_stmt|;
name|new
operator|->
name|queue_next
operator|=
name|NULL
expr_stmt|;
name|QueueLimitRecipient
operator|=
name|new
expr_stmt|;
name|ok
operator|=
name|runqueue
argument_list|(
name|true
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|sm_free
argument_list|(
name|QueueLimitRecipient
argument_list|)
expr_stmt|;
comment|/* XXX */
name|QueueLimitRecipient
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ok
operator|&&
name|Errors
operator|==
literal|0
condition|)
name|message
argument_list|(
literal|"250 2.0.0 Queuing for node %s started"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDHELP
case|:
comment|/* help -- give user info */
name|DELAY_CONN
argument_list|(
literal|"HELP"
argument_list|)
expr_stmt|;
name|help
argument_list|(
name|p
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDNOOP
case|:
comment|/* noop -- do nothing */
name|DELAY_CONN
argument_list|(
literal|"NOOP"
argument_list|)
expr_stmt|;
name|STOP_IF_ATTACK
argument_list|(
name|checksmtpattack
argument_list|(
operator|&
name|n_noop
argument_list|,
name|MaxNOOPCommands
argument_list|,
name|true
argument_list|,
literal|"NOOP"
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"250 2.0.0 OK"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDQUIT
case|:
comment|/* quit -- leave mail */
name|message
argument_list|(
literal|"221 2.0.0 %s closing connection"
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
if|#
directive|if
name|PIPELINING
operator|(
name|void
operator|)
name|sm_io_flush
argument_list|(
name|OutChannel
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PIPELINING */
if|if
condition|(
name|smtp
operator|.
name|sm_nrcpts
operator|>
literal|0
condition|)
name|logundelrcpts
argument_list|(
name|e
argument_list|,
literal|"aborted by sender"
argument_list|,
literal|9
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* arrange to ignore any current send list */
name|e
operator|->
name|e_sendqueue
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|STARTTLS
comment|/* shutdown TLS connection */
if|if
condition|(
name|tls_active
condition|)
block|{
operator|(
name|void
operator|)
name|endtls
argument_list|(
name|srv_ssl
argument_list|,
literal|"server"
argument_list|)
expr_stmt|;
name|tls_active
operator|=
name|false
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* STARTTLS */
if|#
directive|if
name|SASL
if|if
condition|(
name|authenticating
operator|==
name|SASL_IS_AUTH
condition|)
block|{
name|sasl_dispose
argument_list|(
operator|&
name|conn
argument_list|)
expr_stmt|;
name|authenticating
operator|=
name|SASL_NOT_AUTH
expr_stmt|;
comment|/* XXX sasl_done(); this is a child */
block|}
endif|#
directive|endif
comment|/* SASL */
name|doquit
label|:
comment|/* avoid future 050 messages */
name|disconnect
argument_list|(
literal|1
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|#
directive|if
name|MILTER
comment|/* close out milter filters */
name|milter_quit
argument_list|(
name|e
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MILTER */
if|if
condition|(
name|LogLevel
operator|>
literal|4
operator|&&
name|bitset
argument_list|(
name|EF_LOGSENDER
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|logsender
argument_list|(
name|e
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_LOGSENDER
expr_stmt|;
if|if
condition|(
name|lognullconnection
operator|&&
name|LogLevel
operator|>
literal|5
operator|&&
name|nullserver
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|d
decl_stmt|;
name|d
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{daemon_name}"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
name|d
operator|=
literal|"stdin"
expr_stmt|;
comment|/* 				**  even though this id is "bogus", it makes 				**  it simpler to "grep" related events, e.g., 				**  timeouts for the same connection. 				*/
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%s did not issue MAIL/EXPN/VRFY/ETRN during connection to %s"
argument_list|,
name|CurSmtpClient
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|93
argument_list|,
literal|100
argument_list|)
condition|)
block|{
comment|/* return to handle next connection */
return|return;
block|}
name|finis
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
comment|/* just to avoid bogus warning from some compilers */
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
case|case
name|CMDVERB
case|:
comment|/* set verbose mode */
name|DELAY_CONN
argument_list|(
literal|"VERB"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|SRV_OFFER_EXPN
argument_list|,
name|features
argument_list|)
operator|||
operator|!
name|bitset
argument_list|(
name|SRV_OFFER_VERB
argument_list|,
name|features
argument_list|)
condition|)
block|{
comment|/* this would give out the same info */
name|message
argument_list|(
literal|"502 5.7.0 Verbose unavailable"
argument_list|)
expr_stmt|;
break|break;
block|}
name|STOP_IF_ATTACK
argument_list|(
name|checksmtpattack
argument_list|(
operator|&
name|n_noop
argument_list|,
name|MaxNOOPCommands
argument_list|,
name|true
argument_list|,
literal|"VERB"
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|Verbose
operator|=
literal|1
expr_stmt|;
name|set_delivery_mode
argument_list|(
name|SM_DELIVER
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"250 2.0.0 Verbose mode"
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|SMTPDEBUG
case|case
name|CMDDBGQSHOW
case|:
comment|/* show queues */
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Send Queue="
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|smioout
argument_list|,
name|e
operator|->
name|e_sendqueue
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDDBGDEBUG
case|:
comment|/* set debug mode */
name|tTsetup
argument_list|(
name|tTdvect
argument_list|,
sizeof|sizeof
name|tTdvect
argument_list|,
literal|"0-99.1"
argument_list|)
expr_stmt|;
name|tTflag
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"200 2.0.0 Debug set"
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
comment|/* SMTPDEBUG */
case|case
name|CMDDBGQSHOW
case|:
comment|/* show queues */
case|case
name|CMDDBGDEBUG
case|:
comment|/* set debug mode */
endif|#
directive|endif
comment|/* SMTPDEBUG */
case|case
name|CMDLOGBOGUS
case|:
comment|/* bogus command */
name|DELAY_CONN
argument_list|(
literal|"Bogus"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_CRIT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"\"%s\" command from %s (%.100s)"
argument_list|,
name|c
operator|->
name|cmd_name
argument_list|,
name|CurSmtpClient
argument_list|,
name|anynet_ntoa
argument_list|(
operator|&
name|RealHostAddr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|CMDERROR
case|:
comment|/* unknown command */
if|#
directive|if
name|MAXBADCOMMANDS
operator|>
literal|0
if|if
condition|(
operator|++
name|n_badcmds
operator|>
name|MAXBADCOMMANDS
condition|)
block|{
name|stopattack
label|:
name|message
argument_list|(
literal|"421 4.7.0 %s Too many bad commands; closing connection"
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
comment|/* arrange to ignore any current send list */
name|e
operator|->
name|e_sendqueue
operator|=
name|NULL
expr_stmt|;
goto|goto
name|doquit
goto|;
block|}
endif|#
directive|endif
comment|/* MAXBADCOMMANDS> 0 */
if|#
directive|if
name|MILTER
operator|&&
name|SMFI_VERSION
operator|>
literal|2
if|if
condition|(
name|smtp
operator|.
name|sm_milterlist
operator|&&
name|smtp
operator|.
name|sm_milterize
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_DISCARD
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|char
name|state
decl_stmt|;
name|char
modifier|*
name|response
decl_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Sending \"%s\" to Milter"
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|response
operator|=
name|milter_unknown
argument_list|(
name|inp
argument_list|,
name|e
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
name|MILTER_REPLY
argument_list|(
literal|"unknown"
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|SMFIR_REPLYCODE
operator|||
name|state
operator|==
name|SMFIR_REJECT
operator|||
name|state
operator|==
name|SMFIR_TEMPFAIL
operator|||
name|state
operator|==
name|SMFIR_SHUTDOWN
condition|)
block|{
comment|/* MILTER_REPLY already gave an error */
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* MILTER&& SMFI_VERSION> 2 */
name|usrerr
argument_list|(
literal|"500 5.5.1 Command unrecognized: \"%s\""
argument_list|,
name|shortenstring
argument_list|(
name|inp
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDUNIMPL
case|:
name|DELAY_CONN
argument_list|(
literal|"Unimpl"
argument_list|)
expr_stmt|;
name|usrerr
argument_list|(
literal|"502 5.5.1 Command not implemented: \"%s\""
argument_list|,
name|shortenstring
argument_list|(
name|inp
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DELAY_CONN
argument_list|(
literal|"default"
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|syserr
argument_list|(
literal|"500 5.5.0 smtp: unknown code %d"
argument_list|,
name|c
operator|->
name|cmd_code
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|SASL
block|}
endif|#
directive|endif
comment|/* SASL */
block|}
end_function

begin_macro
name|SM_EXCEPT
argument_list|(
argument|exc
argument_list|,
literal|"[!F]*"
argument_list|)
end_macro

begin_block
block|{
comment|/* 		**  The only possible exception is "E:mta.quickabort". 		**  There is nothing to do except fall through and loop. 		*/
block|}
end_block

begin_expr_stmt
name|SM_END_TRY
end_expr_stmt

begin_comment
unit|} }
comment|/* **  SMTP_DATA -- implement the SMTP DATA command. ** **	Parameters: **		smtp -- status of SMTP connection. **		e -- envelope. ** **	Returns: **		true iff SMTP session can continue. ** **	Side Effects: **		possibly sends message. */
end_comment

begin_function
specifier|static
name|bool
name|smtp_data
parameter_list|(
name|smtp
parameter_list|,
name|e
parameter_list|)
name|SMTP_T
modifier|*
name|smtp
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
if|#
directive|if
name|MILTER
name|bool
name|milteraccept
decl_stmt|;
endif|#
directive|endif
comment|/* MILTER */
name|bool
name|aborting
decl_stmt|;
name|bool
name|doublequeue
decl_stmt|;
name|ADDRESS
modifier|*
name|a
decl_stmt|;
name|ENVELOPE
modifier|*
name|ee
decl_stmt|;
name|char
modifier|*
name|id
decl_stmt|;
name|char
modifier|*
name|oldid
decl_stmt|;
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|bool
name|rv
init|=
name|true
decl_stmt|;
name|SmtpPhase
operator|=
literal|"server DATA"
expr_stmt|;
if|if
condition|(
operator|!
name|smtp
operator|->
name|sm_gotmail
condition|)
block|{
name|usrerr
argument_list|(
literal|"503 5.0.0 Need MAIL command"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|smtp
operator|->
name|sm_nrcpts
operator|<=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"503 5.0.0 Need RCPT (recipient)"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"%u"
argument_list|,
name|smtp
operator|->
name|sm_nrcpts
argument_list|)
expr_stmt|;
if|if
condition|(
name|rscheck
argument_list|(
literal|"check_data"
argument_list|,
name|buf
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
name|RSF_RMCOMM
operator||
name|RSF_UNSTRUCTURED
operator||
name|RSF_COUNT
argument_list|,
literal|3
argument_list|,
name|NULL
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
operator|!=
name|EX_OK
condition|)
return|return
name|true
return|;
if|#
directive|if
name|MILTER
operator|&&
name|SMFI_VERSION
operator|>
literal|3
if|if
condition|(
name|smtp
operator|->
name|sm_milterlist
operator|&&
name|smtp
operator|->
name|sm_milterize
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_DISCARD
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|char
name|state
decl_stmt|;
name|char
modifier|*
name|response
decl_stmt|;
name|int
name|savelogusrerrs
init|=
name|LogUsrErrs
decl_stmt|;
name|response
operator|=
name|milter_data_cmd
argument_list|(
name|e
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|SMFIR_REPLYCODE
case|:
if|if
condition|(
name|MilterLogLevel
operator|>
literal|3
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: cmd=data, reject=%s"
argument_list|,
name|response
argument_list|)
expr_stmt|;
name|LogUsrErrs
operator|=
name|false
expr_stmt|;
block|}
name|usrerr
argument_list|(
name|response
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|response
argument_list|,
literal|"421 "
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|response
argument_list|,
literal|"421-"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|e
operator|->
name|e_sendqueue
operator|=
name|NULL
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
case|case
name|SMFIR_REJECT
case|:
if|if
condition|(
name|MilterLogLevel
operator|>
literal|3
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: cmd=data, reject=550 5.7.1 Command rejected"
argument_list|)
expr_stmt|;
name|LogUsrErrs
operator|=
name|false
expr_stmt|;
block|}
name|usrerr
argument_list|(
literal|"550 5.7.1 Command rejected"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|SMFIR_DISCARD
case|:
if|if
condition|(
name|MilterLogLevel
operator|>
literal|3
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: cmd=data, discard"
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_DISCARD
expr_stmt|;
break|break;
case|case
name|SMFIR_TEMPFAIL
case|:
if|if
condition|(
name|MilterLogLevel
operator|>
literal|3
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: cmd=data, reject=%s"
argument_list|,
name|MSG_TEMPFAIL
argument_list|)
expr_stmt|;
name|LogUsrErrs
operator|=
name|false
expr_stmt|;
block|}
name|usrerr
argument_list|(
name|MSG_TEMPFAIL
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|SMFIR_SHUTDOWN
case|:
if|if
condition|(
name|MilterLogLevel
operator|>
literal|3
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: cmd=data, reject=421 4.7.0 %s closing connection"
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
name|LogUsrErrs
operator|=
name|false
expr_stmt|;
block|}
name|usrerr
argument_list|(
literal|"421 4.7.0 %s closing connection"
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_sendqueue
operator|=
name|NULL
expr_stmt|;
return|return
name|false
return|;
block|}
name|LogUsrErrs
operator|=
name|savelogusrerrs
expr_stmt|;
if|if
condition|(
name|response
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
endif|#
directive|endif
comment|/* MILTER&& SMFI_VERSION> 3 */
comment|/* put back discard bit */
if|if
condition|(
name|smtp
operator|->
name|sm_discard
condition|)
name|e
operator|->
name|e_flags
operator||=
name|EF_DISCARD
expr_stmt|;
comment|/* check to see if we need to re-expand aliases */
comment|/* also reset QS_BADADDR on already-diagnosted addrs */
name|doublequeue
operator|=
name|false
expr_stmt|;
for|for
control|(
name|a
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|QS_IS_VERIFIED
argument_list|(
name|a
operator|->
name|q_state
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_DISCARD
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
comment|/* need to re-expand aliases */
name|doublequeue
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|QS_IS_BADADDR
argument_list|(
name|a
operator|->
name|q_state
argument_list|)
condition|)
block|{
comment|/* make this "go away" */
name|a
operator|->
name|q_state
operator|=
name|QS_DONTSEND
expr_stmt|;
block|}
block|}
comment|/* collect the text of the message */
name|SmtpPhase
operator|=
literal|"collect"
expr_stmt|;
name|buffer_errors
argument_list|()
expr_stmt|;
name|collect
argument_list|(
name|InChannel
argument_list|,
name|true
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* redefine message size */
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"%ld"
argument_list|,
name|e
operator|->
name|e_msgsize
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{msg_size}"
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|#
directive|if
name|_FFR_CHECK_EOM
comment|/* rscheck() will set Errors or EF_DISCARD if it trips */
operator|(
name|void
operator|)
name|rscheck
argument_list|(
literal|"check_eom"
argument_list|,
name|buf
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
name|RSF_UNSTRUCTURED
operator||
name|RSF_COUNT
argument_list|,
literal|3
argument_list|,
name|NULL
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_CHECK_EOM */
if|#
directive|if
name|MILTER
name|milteraccept
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|smtp
operator|->
name|sm_milterlist
operator|&&
name|smtp
operator|->
name|sm_milterize
operator|&&
name|Errors
operator|<=
literal|0
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_DISCARD
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|char
name|state
decl_stmt|;
name|char
modifier|*
name|response
decl_stmt|;
name|response
operator|=
name|milter_data
argument_list|(
name|e
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|SMFIR_REPLYCODE
case|:
if|if
condition|(
name|MilterLogLevel
operator|>
literal|3
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: data, reject=%s"
argument_list|,
name|response
argument_list|)
expr_stmt|;
name|milteraccept
operator|=
name|false
expr_stmt|;
name|usrerr
argument_list|(
name|response
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMFIR_REJECT
case|:
name|milteraccept
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|3
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: data, reject=554 5.7.1 Command rejected"
argument_list|)
expr_stmt|;
name|usrerr
argument_list|(
literal|"554 5.7.1 Command rejected"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMFIR_DISCARD
case|:
if|if
condition|(
name|MilterLogLevel
operator|>
literal|3
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: data, discard"
argument_list|)
expr_stmt|;
name|milteraccept
operator|=
name|false
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_DISCARD
expr_stmt|;
break|break;
case|case
name|SMFIR_TEMPFAIL
case|:
if|if
condition|(
name|MilterLogLevel
operator|>
literal|3
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: data, reject=%s"
argument_list|,
name|MSG_TEMPFAIL
argument_list|)
expr_stmt|;
name|milteraccept
operator|=
name|false
expr_stmt|;
name|usrerr
argument_list|(
name|MSG_TEMPFAIL
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMFIR_SHUTDOWN
case|:
if|if
condition|(
name|MilterLogLevel
operator|>
literal|3
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: data, reject=421 4.7.0 %s closing connection"
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
name|milteraccept
operator|=
name|false
expr_stmt|;
name|usrerr
argument_list|(
literal|"421 4.7.0 %s closing connection"
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
name|rv
operator|=
name|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|response
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
comment|/* Milter may have changed message size */
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"%ld"
argument_list|,
name|e
operator|->
name|e_msgsize
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{msg_size}"
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* abort message filters that didn't get the body& log msg is OK */
if|if
condition|(
name|smtp
operator|->
name|sm_milterlist
operator|&&
name|smtp
operator|->
name|sm_milterize
condition|)
block|{
name|milter_abort
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|milteraccept
operator|&&
name|MilterLogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter accept: message"
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  If SuperSafe is SAFE_REALLY_POSTMILTER, and we don't have milter or 	**  milter accepted message, sync it now 	** 	**  XXX This is almost a copy of the code in collect(): put it into 	**	a function that is called from both places? 	*/
if|if
condition|(
name|milteraccept
operator|&&
name|SuperSafe
operator|==
name|SAFE_REALLY_POSTMILTER
condition|)
block|{
name|int
name|afd
decl_stmt|;
name|SM_FILE_T
modifier|*
specifier|volatile
name|df
decl_stmt|;
name|char
modifier|*
name|dfname
decl_stmt|;
name|df
operator|=
name|e
operator|->
name|e_dfp
expr_stmt|;
name|dfname
operator|=
name|queuename
argument_list|(
name|e
argument_list|,
name|DATAFL_LETTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm_io_setinfo
argument_list|(
name|df
argument_list|,
name|SM_BF_COMMIT
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINVAL
condition|)
block|{
name|int
name|save_errno
decl_stmt|;
name|save_errno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|save_errno
operator|==
name|EEXIST
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|dfd
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dfname
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
name|st
operator|.
name|st_size
operator|=
operator|-
literal|1
expr_stmt|;
name|errno
operator|=
name|EEXIST
expr_stmt|;
name|syserr
argument_list|(
literal|"@collect: bfcommit(%s): already on disk, size=%ld"
argument_list|,
name|dfname
argument_list|,
operator|(
name|long
operator|)
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|dfd
operator|=
name|sm_io_getinfo
argument_list|(
name|df
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfd
operator|>=
literal|0
condition|)
name|dumpfd
argument_list|(
name|dfd
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
name|save_errno
expr_stmt|;
name|dferror
argument_list|(
name|df
argument_list|,
literal|"bfcommit"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|flush_errors
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|save_errno
operator|!=
name|EEXIST
argument_list|,
name|true
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|afd
operator|=
name|sm_io_getinfo
argument_list|(
name|df
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|dferror
argument_list|(
name|df
argument_list|,
literal|"sm_io_getinfo"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|flush_errors
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
elseif|else
if|if
condition|(
name|fsync
argument_list|(
name|afd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|dferror
argument_list|(
name|df
argument_list|,
literal|"fsync"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|flush_errors
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
elseif|else
if|if
condition|(
name|sm_io_close
argument_list|(
name|df
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
operator|<
literal|0
condition|)
block|{
name|dferror
argument_list|(
name|df
argument_list|,
literal|"sm_io_close"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|flush_errors
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* Now reopen the df file */
name|e
operator|->
name|e_dfp
operator|=
name|sm_io_open
argument_list|(
name|SmFtStdio
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|dfname
argument_list|,
name|SM_IO_RDONLY
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|==
name|NULL
condition|)
block|{
comment|/* we haven't acked receipt yet, so just chuck this */
name|syserr
argument_list|(
literal|"@Cannot reopen %s"
argument_list|,
name|dfname
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
endif|#
directive|endif
comment|/* MILTER */
comment|/* Check if quarantining stats should be updated */
if|if
condition|(
name|e
operator|->
name|e_quarmsg
operator|!=
name|NULL
condition|)
name|markstats
argument_list|(
name|e
argument_list|,
name|NULL
argument_list|,
name|STATS_QUARANTINE
argument_list|)
expr_stmt|;
comment|/* 	**  If a header/body check (header checks or milter) 	**  set EF_DISCARD, don't queueup the message -- 	**  that would lose the EF_DISCARD bit and deliver 	**  the message. 	*/
if|if
condition|(
name|bitset
argument_list|(
name|EF_DISCARD
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|doublequeue
operator|=
name|false
expr_stmt|;
name|aborting
operator|=
name|Errors
operator|>
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|aborting
operator|||
name|bitset
argument_list|(
name|EF_DISCARD
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|)
operator|&&
operator|(
name|QueueMode
operator|==
name|QM_QUARANTINE
operator|||
name|e
operator|->
name|e_quarmsg
operator|==
name|NULL
operator|)
operator|&&
operator|!
name|split_by_recipient
argument_list|(
name|e
argument_list|)
condition|)
name|aborting
operator|=
name|bitset
argument_list|(
name|EF_FATALERRS
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|aborting
condition|)
block|{
comment|/* Log who the mail would have gone to */
name|logundelrcpts
argument_list|(
name|e
argument_list|,
name|e
operator|->
name|e_message
argument_list|,
literal|8
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|flush_errors
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|buffer_errors
argument_list|()
expr_stmt|;
goto|goto
name|abortmessage
goto|;
block|}
comment|/* from now on, we have to operate silently */
name|buffer_errors
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	**  Clear message, it may contain an error from the SMTP dialogue. 	**  This error must not show up in the queue. 	**	Some error message should show up, e.g., alias database 	**	not available, but others shouldn't, e.g., from check_rcpt. 	*/
block|e->e_message = NULL;
endif|#
directive|endif
comment|/* 0 */
comment|/* 	**  Arrange to send to everyone. 	**	If sending to multiple people, mail back 	**		errors rather than reporting directly. 	**	In any case, don't mail back errors for 	**		anything that has happened up to 	**		now (the other end will do this). 	**	Truncate our transcript -- the mail has gotten 	**		to us successfully, and if we have 	**		to mail this back, it will be easier 	**		on the reader. 	**	Then send to everyone. 	**	Finally give a reply code.  If an error has 	**		already been given, don't mail a 	**		message back. 	**	We goose error returns by clearing error bit. 	*/
name|SmtpPhase
operator|=
literal|"delivery"
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_setinfo
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_BF_TRUNCATE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|id
operator|=
name|e
operator|->
name|e_id
expr_stmt|;
if|#
directive|if
name|NAMED_BIND
name|_res
operator|.
name|retry
operator|=
name|TimeOuts
operator|.
name|res_retry
index|[
name|RES_TO_FIRST
index|]
expr_stmt|;
name|_res
operator|.
name|retrans
operator|=
name|TimeOuts
operator|.
name|res_retrans
index|[
name|RES_TO_FIRST
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* NAMED_BIND */
for|for
control|(
name|ee
operator|=
name|e
init|;
name|ee
operator|!=
name|NULL
condition|;
name|ee
operator|=
name|ee
operator|->
name|e_sibling
control|)
block|{
comment|/* make sure we actually do delivery */
name|ee
operator|->
name|e_flags
operator|&=
operator|~
name|EF_CLRQUEUE
expr_stmt|;
comment|/* from now on, operate silently */
name|ee
operator|->
name|e_errormode
operator|=
name|EM_MAIL
expr_stmt|;
if|if
condition|(
name|doublequeue
condition|)
block|{
comment|/* make sure it is in the queue */
name|queueup
argument_list|(
name|ee
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|mode
decl_stmt|;
comment|/* send to all recipients */
name|mode
operator|=
name|SM_DEFAULT
expr_stmt|;
if|#
directive|if
name|_FFR_DM_ONE
if|if
condition|(
name|SM_DM_ONE
operator|==
name|e
operator|->
name|e_sendmode
condition|)
block|{
if|if
condition|(
name|NotFirstDelivery
condition|)
block|{
name|mode
operator|=
name|SM_QUEUE
expr_stmt|;
name|e
operator|->
name|e_sendmode
operator|=
name|SM_QUEUE
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
name|SM_FORK
expr_stmt|;
name|NotFirstDelivery
operator|=
name|true
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* _FFR_DM_ONE */
name|sendall
argument_list|(
name|ee
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|ee
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* put back id for SMTP logging in putoutmsg() */
name|oldid
operator|=
name|CurEnv
operator|->
name|e_id
expr_stmt|;
name|CurEnv
operator|->
name|e_id
operator|=
name|id
expr_stmt|;
comment|/* issue success message */
if|#
directive|if
name|_FFR_MSG_ACCEPT
if|if
condition|(
name|MessageAccept
operator|!=
name|NULL
operator|&&
operator|*
name|MessageAccept
operator|!=
literal|'\0'
condition|)
block|{
name|char
name|msg
index|[
name|MAXLINE
index|]
decl_stmt|;
name|expand
argument_list|(
name|MessageAccept
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
name|msg
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"250 2.0.0 %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* _FFR_MSG_ACCEPT */
name|message
argument_list|(
literal|"250 2.0.0 %s Message accepted for delivery"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|CurEnv
operator|->
name|e_id
operator|=
name|oldid
expr_stmt|;
comment|/* if we just queued, poke it */
if|if
condition|(
name|doublequeue
condition|)
block|{
name|bool
name|anything_to_send
init|=
name|false
decl_stmt|;
name|sm_getla
argument_list|()
expr_stmt|;
for|for
control|(
name|ee
operator|=
name|e
init|;
name|ee
operator|!=
name|NULL
condition|;
name|ee
operator|=
name|ee
operator|->
name|e_sibling
control|)
block|{
if|if
condition|(
name|WILL_BE_QUEUED
argument_list|(
name|ee
operator|->
name|e_sendmode
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|shouldqueue
argument_list|(
name|ee
operator|->
name|e_msgpriority
argument_list|,
name|ee
operator|->
name|e_ctime
argument_list|)
condition|)
block|{
name|ee
operator|->
name|e_sendmode
operator|=
name|SM_QUEUE
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|QueueMode
operator|!=
name|QM_QUARANTINE
operator|&&
name|ee
operator|->
name|e_quarmsg
operator|!=
name|NULL
condition|)
block|{
name|ee
operator|->
name|e_sendmode
operator|=
name|SM_QUEUE
expr_stmt|;
continue|continue;
block|}
name|anything_to_send
operator|=
name|true
expr_stmt|;
comment|/* close all the queue files */
name|closexscript
argument_list|(
name|ee
argument_list|)
expr_stmt|;
if|if
condition|(
name|ee
operator|->
name|e_dfp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|ee
operator|->
name|e_dfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
name|ee
operator|->
name|e_dfp
operator|=
name|NULL
expr_stmt|;
block|}
name|unlockqueue
argument_list|(
name|ee
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|anything_to_send
condition|)
block|{
if|#
directive|if
name|PIPELINING
comment|/* 			**  XXX if we don't do this, we get 250 twice 			**	because it is also flushed in the child. 			*/
operator|(
name|void
operator|)
name|sm_io_flush
argument_list|(
name|OutChannel
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PIPELINING */
operator|(
name|void
operator|)
name|doworklist
argument_list|(
name|e
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
name|abortmessage
label|:
if|if
condition|(
name|LogLevel
operator|>
literal|4
operator|&&
name|bitset
argument_list|(
name|EF_LOGSENDER
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|logsender
argument_list|(
name|e
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_LOGSENDER
expr_stmt|;
comment|/* clean up a bit */
name|smtp
operator|->
name|sm_gotmail
operator|=
name|false
expr_stmt|;
comment|/* 	**  Call dropenvelope if and only if the envelope is *not* 	**  being processed by the child process forked by doworklist(). 	*/
if|if
condition|(
name|aborting
operator|||
name|bitset
argument_list|(
name|EF_DISCARD
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|dropenvelope
argument_list|(
name|e
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|ee
operator|=
name|e
init|;
name|ee
operator|!=
name|NULL
condition|;
name|ee
operator|=
name|ee
operator|->
name|e_sibling
control|)
block|{
if|if
condition|(
operator|!
name|doublequeue
operator|&&
name|QueueMode
operator|!=
name|QM_QUARANTINE
operator|&&
name|ee
operator|->
name|e_quarmsg
operator|!=
name|NULL
condition|)
block|{
name|dropenvelope
argument_list|(
name|ee
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|WILL_BE_QUEUED
argument_list|(
name|ee
operator|->
name|e_sendmode
argument_list|)
condition|)
name|dropenvelope
argument_list|(
name|ee
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
name|sm_rpool_free
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|)
expr_stmt|;
comment|/* 	**  At this point, e ==&MainEnvelope, but if we did splitting, 	**  then CurEnv may point to an envelope structure that was just 	**  freed with the rpool.  So reset CurEnv *before* calling 	**  newenvelope. 	*/
name|CurEnv
operator|=
name|e
expr_stmt|;
name|newenvelope
argument_list|(
name|e
argument_list|,
name|e
argument_list|,
name|sm_rpool_new_x
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator|=
name|BlankEnvelope
operator|.
name|e_flags
expr_stmt|;
comment|/* restore connection quarantining */
if|if
condition|(
name|smtp
operator|->
name|sm_quarmsg
operator|==
name|NULL
condition|)
block|{
name|e
operator|->
name|e_quarmsg
operator|=
name|NULL
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{quarantine}"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e
operator|->
name|e_quarmsg
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|smtp
operator|->
name|sm_quarmsg
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{quarantine}"
argument_list|)
argument_list|,
name|e
operator|->
name|e_quarmsg
argument_list|)
expr_stmt|;
block|}
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/* **  LOGUNDELRCPTS -- log undelivered (or all) recipients. ** **	Parameters: **		e -- envelope. **		msg -- message for Stat= **		level -- log level. **		all -- log all recipients. ** **	Returns: **		none. ** **	Side Effects: **		logs undelivered (or all) recipients */
end_comment

begin_function
name|void
name|logundelrcpts
parameter_list|(
name|e
parameter_list|,
name|msg
parameter_list|,
name|level
parameter_list|,
name|all
parameter_list|)
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|level
decl_stmt|;
name|bool
name|all
decl_stmt|;
block|{
name|ADDRESS
modifier|*
name|a
decl_stmt|;
if|if
condition|(
name|LogLevel
operator|<=
name|level
operator|||
name|msg
operator|==
name|NULL
operator|||
operator|*
name|msg
operator|==
literal|'\0'
condition|)
return|return;
comment|/* Clear $h so relay= doesn't get mislogged by logdelivery() */
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'h'
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Log who the mail would have gone to */
for|for
control|(
name|a
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|q_next
control|)
block|{
if|if
condition|(
operator|!
name|QS_IS_UNDELIVERED
argument_list|(
name|a
operator|->
name|q_state
argument_list|)
operator|&&
operator|!
name|all
condition|)
continue|continue;
name|e
operator|->
name|e_to
operator|=
name|a
operator|->
name|q_paddr
expr_stmt|;
name|logdelivery
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|a
operator|->
name|q_status
argument_list|,
name|msg
argument_list|,
name|NULL
argument_list|,
operator|(
name|time_t
operator|)
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  CHECKSMTPATTACK -- check for denial-of-service attack by repetition ** **	Parameters: **		pcounter -- pointer to a counter for this command. **		maxcount -- maximum value for this counter before we **			slow down. **		waitnow -- sleep now (in this routine)? **		cname -- command name for logging. **		e -- the current envelope. ** **	Returns: **		time to wait, **		STOP_ATTACK if twice as many commands as allowed and **			MaxChildren> 0. ** **	Side Effects: **		Slows down if we seem to be under attack. */
end_comment

begin_function
specifier|static
name|time_t
name|checksmtpattack
parameter_list|(
name|pcounter
parameter_list|,
name|maxcount
parameter_list|,
name|waitnow
parameter_list|,
name|cname
parameter_list|,
name|e
parameter_list|)
specifier|volatile
name|unsigned
name|int
modifier|*
name|pcounter
decl_stmt|;
name|unsigned
name|int
name|maxcount
decl_stmt|;
name|bool
name|waitnow
decl_stmt|;
name|char
modifier|*
name|cname
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
if|if
condition|(
name|maxcount
operator|<=
literal|0
condition|)
comment|/* no limit */
return|return
operator|(
name|time_t
operator|)
literal|0
return|;
if|if
condition|(
operator|++
operator|(
operator|*
name|pcounter
operator|)
operator|>=
name|maxcount
condition|)
block|{
name|unsigned
name|int
name|shift
decl_stmt|;
name|time_t
name|s
decl_stmt|;
if|if
condition|(
operator|*
name|pcounter
operator|==
name|maxcount
operator|&&
name|LogLevel
operator|>
literal|5
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%s: possible SMTP attack: command=%.40s, count=%u"
argument_list|,
name|CurSmtpClient
argument_list|,
name|cname
argument_list|,
operator|*
name|pcounter
argument_list|)
expr_stmt|;
block|}
name|shift
operator|=
operator|*
name|pcounter
operator|-
name|maxcount
expr_stmt|;
name|s
operator|=
literal|1
operator|<<
name|shift
expr_stmt|;
if|if
condition|(
name|shift
operator|>
name|MAXSHIFT
operator|||
name|s
operator|>=
name|MAXTIMEOUT
operator|||
name|s
operator|<=
literal|0
condition|)
name|s
operator|=
name|MAXTIMEOUT
expr_stmt|;
define|#
directive|define
name|IS_ATTACK
parameter_list|(
name|s
parameter_list|)
value|((MaxChildren> 0&& *pcounter>= maxcount * 2)	\ 				? STOP_ATTACK : (time_t) s)
comment|/* sleep at least 1 second before returning */
operator|(
name|void
operator|)
name|sleep
argument_list|(
operator|*
name|pcounter
operator|/
name|maxcount
argument_list|)
expr_stmt|;
name|s
operator|-=
operator|*
name|pcounter
operator|/
name|maxcount
expr_stmt|;
if|if
condition|(
name|s
operator|>=
name|MAXTIMEOUT
operator|||
name|s
operator|<
literal|0
condition|)
name|s
operator|=
name|MAXTIMEOUT
expr_stmt|;
if|if
condition|(
name|waitnow
operator|&&
name|s
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sleep
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|IS_ATTACK
argument_list|(
literal|0
argument_list|)
return|;
block|}
return|return
name|IS_ATTACK
argument_list|(
name|s
argument_list|)
return|;
block|}
return|return
operator|(
name|time_t
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/* **  SETUP_SMTPD_IO -- setup I/O fd correctly for the SMTP server ** **	Parameters: **		none. ** **	Returns: **		nothing. ** **	Side Effects: **		may change I/O fd. */
end_comment

begin_function
specifier|static
name|void
name|setup_smtpd_io
parameter_list|()
block|{
name|int
name|inchfd
decl_stmt|,
name|outchfd
decl_stmt|,
name|outfd
decl_stmt|;
name|inchfd
operator|=
name|sm_io_getinfo
argument_list|(
name|InChannel
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|outchfd
operator|=
name|sm_io_getinfo
argument_list|(
name|OutChannel
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|outfd
operator|=
name|sm_io_getinfo
argument_list|(
name|smioout
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|outchfd
operator|!=
name|outfd
condition|)
block|{
comment|/* arrange for debugging output to go to remote host */
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|outchfd
argument_list|,
name|outfd
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  if InChannel and OutChannel are stdin/stdout 	**  and connected to ttys 	**  and fcntl(STDIN, F_SETFL, O_NONBLOCKING) also changes STDOUT, 	**  then "chain" them together. 	*/
if|if
condition|(
name|inchfd
operator|==
name|STDIN_FILENO
operator|&&
name|outchfd
operator|==
name|STDOUT_FILENO
operator|&&
name|isatty
argument_list|(
name|inchfd
argument_list|)
operator|&&
name|isatty
argument_list|(
name|outchfd
argument_list|)
condition|)
block|{
name|int
name|inmode
decl_stmt|,
name|outmode
decl_stmt|;
name|inmode
operator|=
name|fcntl
argument_list|(
name|inchfd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|inmode
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|11
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"fcntl(inchfd, F_GETFL) failed: %s"
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|outmode
operator|=
name|fcntl
argument_list|(
name|outchfd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|outmode
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|11
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"fcntl(outchfd, F_GETFL) failed: %s"
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|O_NONBLOCK
argument_list|,
name|inmode
argument_list|)
operator|||
name|bitset
argument_list|(
name|O_NONBLOCK
argument_list|,
name|outmode
argument_list|)
operator|||
name|fcntl
argument_list|(
name|inchfd
argument_list|,
name|F_SETFL
argument_list|,
name|inmode
operator||
name|O_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return;
name|outmode
operator|=
name|fcntl
argument_list|(
name|outchfd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|outmode
operator|!=
operator|-
literal|1
operator|&&
name|bitset
argument_list|(
name|O_NONBLOCK
argument_list|,
name|outmode
argument_list|)
condition|)
block|{
comment|/* changing InChannel also changes OutChannel */
name|sm_io_automode
argument_list|(
name|OutChannel
argument_list|,
name|InChannel
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|97
argument_list|,
literal|4
argument_list|)
operator|&&
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"set automode for I (%d)/O (%d) in SMTP server"
argument_list|,
name|inchfd
argument_list|,
name|outchfd
argument_list|)
expr_stmt|;
block|}
comment|/* undo change of inchfd */
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|inchfd
argument_list|,
name|F_SETFL
argument_list|,
name|inmode
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  SKIPWORD -- skip a fixed word. ** **	Parameters: **		p -- place to start looking. **		w -- word to skip. ** **	Returns: **		p following w. **		NULL on error. ** **	Side Effects: **		clobbers the p data area. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|skipword
parameter_list|(
name|p
parameter_list|,
name|w
parameter_list|)
specifier|register
name|char
modifier|*
specifier|volatile
name|p
decl_stmt|;
name|char
modifier|*
name|w
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|firstp
init|=
name|p
decl_stmt|;
comment|/* find beginning of word */
name|SKIP_SPACE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
comment|/* find end of word */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
block|{
name|syntax
label|:
name|usrerr
argument_list|(
literal|"501 5.5.2 Syntax error in parameters scanning \"%s\""
argument_list|,
name|shortenstring
argument_list|(
name|firstp
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|SKIP_SPACE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
goto|goto
name|syntax
goto|;
comment|/* see if the input word matches desired word */
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|q
argument_list|,
name|w
argument_list|)
condition|)
goto|goto
name|syntax
goto|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* **  MAIL_ESMTP_ARGS -- process ESMTP arguments from MAIL line ** **	Parameters: **		kp -- the parameter key. **		vp -- the value of that parameter. **		e -- the envelope. **		features -- current server features ** **	Returns: **		none. */
end_comment

begin_function
specifier|static
name|void
name|mail_esmtp_args
parameter_list|(
name|kp
parameter_list|,
name|vp
parameter_list|,
name|e
parameter_list|,
name|features
parameter_list|)
name|char
modifier|*
name|kp
decl_stmt|;
name|char
modifier|*
name|vp
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|unsigned
name|int
name|features
decl_stmt|;
block|{
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|kp
argument_list|,
literal|"size"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.2 SIZE requires a value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{msg_size}"
argument_list|)
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|e_msgsize
operator|=
name|strtol
argument_list|(
name|vp
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_msgsize
operator|==
name|LONG_MAX
operator|&&
name|errno
operator|==
name|ERANGE
condition|)
block|{
name|usrerr
argument_list|(
literal|"552 5.2.3 Message size exceeds maximum value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|e
operator|->
name|e_msgsize
operator|<
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"552 5.2.3 Message size invalid"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|kp
argument_list|,
literal|"body"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.2 BODY requires a value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|vp
argument_list|,
literal|"8bitmime"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SevenBitInput
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|vp
argument_list|,
literal|"7bit"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SevenBitInput
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|usrerr
argument_list|(
literal|"501 5.5.4 Unknown BODY type %s"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|e
operator|->
name|e_bodytype
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|vp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|kp
argument_list|,
literal|"envid"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|SRV_OFFER_DSN
argument_list|,
name|features
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"504 5.7.0 Sorry, ENVID not supported, we do not allow DSN"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.2 ENVID requires a value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
operator|!
name|xtextok
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.4 Syntax error in ENVID parameter value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|e
operator|->
name|e_envid
operator|!=
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.0 Duplicate ENVID parameter"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|e
operator|->
name|e_envid
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{dsn_envid}"
argument_list|)
argument_list|,
name|e
operator|->
name|e_envid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|kp
argument_list|,
literal|"ret"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|SRV_OFFER_DSN
argument_list|,
name|features
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"504 5.7.0 Sorry, RET not supported, we do not allow DSN"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.2 RET requires a value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|bitset
argument_list|(
name|EF_RET_PARAM
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.0 Duplicate RET parameter"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|e
operator|->
name|e_flags
operator||=
name|EF_RET_PARAM
expr_stmt|;
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|vp
argument_list|,
literal|"hdrs"
argument_list|)
operator|==
literal|0
condition|)
name|e
operator|->
name|e_flags
operator||=
name|EF_NO_BODY_RETN
expr_stmt|;
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|vp
argument_list|,
literal|"full"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.2 Bad argument \"%s\" to RET"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{dsn_ret}"
argument_list|)
argument_list|,
name|vp
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|SASL
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|kp
argument_list|,
literal|"auth"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|auth_param
decl_stmt|;
comment|/* the value of the AUTH=x */
name|bool
name|saveQuickAbort
init|=
name|QuickAbort
decl_stmt|;
name|bool
name|saveSuprErrs
init|=
name|SuprErrs
decl_stmt|;
name|bool
name|saveExitStat
init|=
name|ExitStat
decl_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.2 AUTH= requires a value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|e
operator|->
name|e_auth_param
operator|!=
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.0 Duplicate AUTH parameter"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|vp
argument_list|,
literal|' '
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|len
operator|=
name|q
operator|-
name|vp
operator|+
literal|1
expr_stmt|;
else|else
name|len
operator|=
name|strlen
argument_list|(
name|vp
argument_list|)
operator|+
literal|1
expr_stmt|;
name|auth_param
operator|=
name|xalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|auth_param
argument_list|,
name|vp
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xtextok
argument_list|(
name|auth_param
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.4 Syntax error in AUTH parameter value"
argument_list|)
expr_stmt|;
comment|/* just a warning? */
comment|/* NOTREACHED */
block|}
comment|/* XXX define this always or only if trusted? */
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{auth_author}"
argument_list|)
argument_list|,
name|auth_param
argument_list|)
expr_stmt|;
comment|/* 		**  call Strust_auth to find out whether 		**  auth_param is acceptable (trusted) 		**  we shouldn't trust it if not authenticated 		**  (required by RFC, leave it to ruleset?) 		*/
name|SuprErrs
operator|=
name|true
expr_stmt|;
name|QuickAbort
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|auth_param
argument_list|,
literal|"<>"
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|rscheck
argument_list|(
literal|"trust_auth"
argument_list|,
name|auth_param
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
name|RSF_RMCOMM
argument_list|,
literal|9
argument_list|,
name|NULL
argument_list|,
name|NOQID
argument_list|)
operator|!=
name|EX_OK
operator|||
name|Errors
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|95
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|q
operator|=
name|e
operator|->
name|e_auth_param
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"auth=\"%.100s\" not trusted user=\"%.100s\"\n"
argument_list|,
name|auth_param
argument_list|,
operator|(
name|q
operator|==
name|NULL
operator|)
condition|?
literal|""
else|:
name|q
argument_list|)
expr_stmt|;
block|}
comment|/* not trusted */
name|e
operator|->
name|e_auth_param
operator|=
literal|"<>"
expr_stmt|;
if|#
directive|if
name|_FFR_AUTH_PASSING
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{auth_author}"
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_AUTH_PASSING */
block|}
else|else
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|95
argument_list|,
literal|8
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"auth=\"%.100s\" trusted\n"
argument_list|,
name|auth_param
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_auth_param
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|auth_param
argument_list|)
expr_stmt|;
block|}
name|sm_free
argument_list|(
name|auth_param
argument_list|)
expr_stmt|;
comment|/* XXX */
comment|/* reset values */
name|Errors
operator|=
literal|0
expr_stmt|;
name|QuickAbort
operator|=
name|saveQuickAbort
expr_stmt|;
name|SuprErrs
operator|=
name|saveSuprErrs
expr_stmt|;
name|ExitStat
operator|=
name|saveExitStat
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SASL */
define|#
directive|define
name|PRTCHAR
parameter_list|(
name|c
parameter_list|)
value|((isascii(c)&& isprint(c)) ? (c) : '?')
comment|/* 	**  "by" is only accepted if DeliverByMin>= 0. 	**  We maybe could add this to the list of server_features. 	*/
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|kp
argument_list|,
literal|"by"
argument_list|)
operator|==
literal|0
operator|&&
name|DeliverByMin
operator|>=
literal|0
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.2 BY= requires a value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|e_deliver_by
operator|=
name|strtol
argument_list|(
name|vp
argument_list|,
operator|&
name|s
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_deliver_by
operator|==
name|LONG_MIN
operator|||
name|e
operator|->
name|e_deliver_by
operator|==
name|LONG_MAX
operator|||
name|e
operator|->
name|e_deliver_by
operator|>
literal|999999999l
operator|||
name|e
operator|->
name|e_deliver_by
operator|<
operator|-
literal|999999999l
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.2 BY=%s out of range"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|*
name|s
operator|!=
literal|';'
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.2 BY= missing ';'"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|e
operator|->
name|e_dlvr_flag
operator|=
literal|0
expr_stmt|;
operator|++
name|s
expr_stmt|;
comment|/* XXX: spaces allowed? */
name|SKIP_SPACE
argument_list|(
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tolower
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
case|case
literal|'n'
case|:
name|e
operator|->
name|e_dlvr_flag
operator|=
name|DLVR_NOTIFY
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|e
operator|->
name|e_dlvr_flag
operator|=
name|DLVR_RETURN
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_deliver_by
operator|<=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.4 mode R requires BY time> 0"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|DeliverByMin
operator|>
literal|0
operator|&&
name|e
operator|->
name|e_deliver_by
operator|>
literal|0
operator|&&
name|e
operator|->
name|e_deliver_by
operator|<
name|DeliverByMin
condition|)
block|{
name|usrerr
argument_list|(
literal|"555 5.5.2 time %ld less than %ld"
argument_list|,
name|e
operator|->
name|e_deliver_by
argument_list|,
operator|(
name|long
operator|)
name|DeliverByMin
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
break|break;
default|default:
name|usrerr
argument_list|(
literal|"501 5.5.2 illegal by-mode '%c'"
argument_list|,
name|PRTCHAR
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
operator|++
name|s
expr_stmt|;
comment|/* XXX: spaces allowed? */
name|SKIP_SPACE
argument_list|(
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tolower
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
case|case
literal|'t'
case|:
name|e
operator|->
name|e_dlvr_flag
operator||=
name|DLVR_TRACE
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
break|break;
default|default:
name|usrerr
argument_list|(
literal|"501 5.5.2 illegal by-trace '%c'"
argument_list|,
name|PRTCHAR
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* XXX: check whether more characters follow? */
block|}
else|else
block|{
name|usrerr
argument_list|(
literal|"555 5.5.4 %s parameter unrecognized"
argument_list|,
name|kp
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_function

begin_comment
comment|/* **  RCPT_ESMTP_ARGS -- process ESMTP arguments from RCPT line ** **	Parameters: **		a -- the address corresponding to the To: parameter. **		kp -- the parameter key. **		vp -- the value of that parameter. **		e -- the envelope. **		features -- current server features ** **	Returns: **		none. */
end_comment

begin_function
specifier|static
name|void
name|rcpt_esmtp_args
parameter_list|(
name|a
parameter_list|,
name|kp
parameter_list|,
name|vp
parameter_list|,
name|e
parameter_list|,
name|features
parameter_list|)
name|ADDRESS
modifier|*
name|a
decl_stmt|;
name|char
modifier|*
name|kp
decl_stmt|;
name|char
modifier|*
name|vp
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|unsigned
name|int
name|features
decl_stmt|;
block|{
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|kp
argument_list|,
literal|"notify"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|SRV_OFFER_DSN
argument_list|,
name|features
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"504 5.7.0 Sorry, NOTIFY not supported, we do not allow DSN"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.2 NOTIFY requires a value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|a
operator|->
name|q_flags
operator|&=
operator|~
operator|(
name|QPINGONSUCCESS
operator||
name|QPINGONFAILURE
operator||
name|QPINGONDELAY
operator|)
expr_stmt|;
name|a
operator|->
name|q_flags
operator||=
name|QHASNOTIFY
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{dsn_notify}"
argument_list|)
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|vp
argument_list|,
literal|"never"
argument_list|)
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|vp
init|;
name|p
operator|!=
name|NULL
condition|;
name|vp
operator|=
name|p
control|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|vp
argument_list|,
literal|"success"
argument_list|)
operator|==
literal|0
condition|)
name|a
operator|->
name|q_flags
operator||=
name|QPINGONSUCCESS
expr_stmt|;
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|vp
argument_list|,
literal|"failure"
argument_list|)
operator|==
literal|0
condition|)
name|a
operator|->
name|q_flags
operator||=
name|QPINGONFAILURE
expr_stmt|;
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|vp
argument_list|,
literal|"delay"
argument_list|)
operator|==
literal|0
condition|)
name|a
operator|->
name|q_flags
operator||=
name|QPINGONDELAY
expr_stmt|;
else|else
block|{
name|usrerr
argument_list|(
literal|"501 5.5.4 Bad argument \"%s\"  to NOTIFY"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
operator|*
name|s
operator|=
literal|','
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|kp
argument_list|,
literal|"orcpt"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|SRV_OFFER_DSN
argument_list|,
name|features
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"504 5.7.0 Sorry, ORCPT not supported, we do not allow DSN"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.2 ORCPT requires a value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|strchr
argument_list|(
name|vp
argument_list|,
literal|';'
argument_list|)
operator|==
name|NULL
operator|||
operator|!
name|xtextok
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.4 Syntax error in ORCPT parameter value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|a
operator|->
name|q_orcpt
operator|!=
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.0 Duplicate ORCPT parameter"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|a
operator|->
name|q_orcpt
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|vp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usrerr
argument_list|(
literal|"555 5.5.4 %s parameter unrecognized"
argument_list|,
name|kp
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_function

begin_comment
comment|/* **  PRINTVRFYADDR -- print an entry in the verify queue ** **	Parameters: **		a -- the address to print. **		last -- set if this is the last one. **		vrfy -- set if this is a VRFY command. ** **	Returns: **		none. ** **	Side Effects: **		Prints the appropriate 250 codes. */
end_comment

begin_define
define|#
directive|define
name|OFFF
value|(3 + 1 + 5 + 1)
end_define

begin_comment
comment|/* offset in fmt: SMTP reply + enh. code */
end_comment

begin_function
specifier|static
name|void
name|printvrfyaddr
parameter_list|(
name|a
parameter_list|,
name|last
parameter_list|,
name|vrfy
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
name|bool
name|last
decl_stmt|;
name|bool
name|vrfy
decl_stmt|;
block|{
name|char
name|fmtbuf
index|[
literal|30
index|]
decl_stmt|;
if|if
condition|(
name|vrfy
operator|&&
name|a
operator|->
name|q_mailer
operator|!=
name|NULL
operator|&&
operator|!
name|bitnset
argument_list|(
name|M_VRFY250
argument_list|,
name|a
operator|->
name|q_mailer
operator|->
name|m_flags
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|fmtbuf
argument_list|,
literal|"252"
argument_list|,
sizeof|sizeof
name|fmtbuf
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|fmtbuf
argument_list|,
literal|"250"
argument_list|,
sizeof|sizeof
name|fmtbuf
argument_list|)
expr_stmt|;
name|fmtbuf
index|[
literal|3
index|]
operator|=
name|last
condition|?
literal|' '
else|:
literal|'-'
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
operator|&
name|fmtbuf
index|[
literal|4
index|]
argument_list|,
literal|"2.1.5 "
argument_list|,
sizeof|sizeof
name|fmtbuf
operator|-
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|q_fullname
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|a
operator|->
name|q_mailer
operator|==
name|NULL
operator|||
name|a
operator|->
name|q_mailer
operator|->
name|m_addrtype
operator|==
name|NULL
operator|||
name|sm_strcasecmp
argument_list|(
name|a
operator|->
name|q_mailer
operator|->
name|m_addrtype
argument_list|,
literal|"rfc822"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|strchr
argument_list|(
name|a
operator|->
name|q_user
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
operator|&
name|fmtbuf
index|[
name|OFFF
index|]
argument_list|,
literal|"<%s@%s>"
argument_list|,
sizeof|sizeof
name|fmtbuf
operator|-
name|OFFF
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
operator|&
name|fmtbuf
index|[
name|OFFF
index|]
argument_list|,
literal|"<%s>"
argument_list|,
sizeof|sizeof
name|fmtbuf
operator|-
name|OFFF
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|fmtbuf
argument_list|,
name|a
operator|->
name|q_user
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|a
operator|->
name|q_mailer
operator|==
name|NULL
operator|||
name|a
operator|->
name|q_mailer
operator|->
name|m_addrtype
operator|==
name|NULL
operator|||
name|sm_strcasecmp
argument_list|(
name|a
operator|->
name|q_mailer
operator|->
name|m_addrtype
argument_list|,
literal|"rfc822"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|strchr
argument_list|(
name|a
operator|->
name|q_user
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
operator|&
name|fmtbuf
index|[
name|OFFF
index|]
argument_list|,
literal|"%s<%s@%s>"
argument_list|,
sizeof|sizeof
name|fmtbuf
operator|-
name|OFFF
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
operator|&
name|fmtbuf
index|[
name|OFFF
index|]
argument_list|,
literal|"%s<%s>"
argument_list|,
sizeof|sizeof
name|fmtbuf
operator|-
name|OFFF
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|fmtbuf
argument_list|,
name|a
operator|->
name|q_fullname
argument_list|,
name|a
operator|->
name|q_user
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|SASL
end_if

begin_comment
comment|/* **  SASLMECHS -- get list of possible AUTH mechanisms ** **	Parameters: **		conn -- SASL connection info. **		mechlist -- output parameter for list of mechanisms. ** **	Returns: **		number of mechs. */
end_comment

begin_function
specifier|static
name|int
name|saslmechs
parameter_list|(
name|conn
parameter_list|,
name|mechlist
parameter_list|)
name|sasl_conn_t
modifier|*
name|conn
decl_stmt|;
name|char
modifier|*
modifier|*
name|mechlist
decl_stmt|;
block|{
name|int
name|len
decl_stmt|,
name|num
decl_stmt|,
name|result
decl_stmt|;
comment|/* "user" is currently unused */
if|#
directive|if
name|SASL
operator|>=
literal|20000
name|result
operator|=
name|sasl_listmech
argument_list|(
name|conn
argument_list|,
name|NULL
argument_list|,
literal|""
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|mechlist
argument_list|,
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|&
name|len
argument_list|,
operator|&
name|num
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SASL>= 20000 */
name|result
operator|=
name|sasl_listmech
argument_list|(
name|conn
argument_list|,
literal|"user"
argument_list|,
comment|/* XXX */
literal|""
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
name|mechlist
argument_list|,
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|&
name|len
argument_list|,
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|&
name|num
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SASL>= 20000 */
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"AUTH error: listmech=%d, num=%d"
argument_list|,
name|result
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|num
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|11
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"AUTH: available mech=%s, allowed mech=%s"
argument_list|,
operator|*
name|mechlist
argument_list|,
name|AuthMechanisms
argument_list|)
expr_stmt|;
operator|*
name|mechlist
operator|=
name|intersect
argument_list|(
name|AuthMechanisms
argument_list|,
operator|*
name|mechlist
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|mechlist
operator|=
name|NULL
expr_stmt|;
comment|/* be paranoid... */
if|if
condition|(
name|result
operator|==
name|SASL_OK
operator|&&
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"AUTH warning: no mechanisms"
argument_list|)
expr_stmt|;
block|}
return|return
name|num
return|;
block|}
end_function

begin_if
if|#
directive|if
name|SASL
operator|>=
literal|20000
end_if

begin_comment
comment|/* **  PROXY_POLICY -- define proxy policy for AUTH ** **	Parameters: **		conn -- unused. **		context -- unused. **		requested_user -- authorization identity. **		rlen -- authorization identity length. **		auth_identity -- authentication identity. **		alen -- authentication identity length. **		def_realm -- default user realm. **		urlen -- user realm length. **		propctx -- unused. ** **	Returns: **		ok? ** **	Side Effects: **		sets {auth_authen} macro. */
end_comment

begin_function
name|int
name|proxy_policy
parameter_list|(
name|conn
parameter_list|,
name|context
parameter_list|,
name|requested_user
parameter_list|,
name|rlen
parameter_list|,
name|auth_identity
parameter_list|,
name|alen
parameter_list|,
name|def_realm
parameter_list|,
name|urlen
parameter_list|,
name|propctx
parameter_list|)
name|sasl_conn_t
modifier|*
name|conn
decl_stmt|;
name|void
modifier|*
name|context
decl_stmt|;
specifier|const
name|char
modifier|*
name|requested_user
decl_stmt|;
name|unsigned
name|rlen
decl_stmt|;
specifier|const
name|char
modifier|*
name|auth_identity
decl_stmt|;
name|unsigned
name|alen
decl_stmt|;
specifier|const
name|char
modifier|*
name|def_realm
decl_stmt|;
name|unsigned
name|urlen
decl_stmt|;
name|struct
name|propctx
modifier|*
name|propctx
decl_stmt|;
block|{
if|if
condition|(
name|auth_identity
operator|==
name|NULL
condition|)
return|return
name|SASL_FAIL
return|;
name|macdefine
argument_list|(
operator|&
name|BlankEnvelope
operator|.
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{auth_authen}"
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|auth_identity
argument_list|)
expr_stmt|;
return|return
name|SASL_OK
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SASL>= 20000 */
end_comment

begin_comment
comment|/* **  PROXY_POLICY -- define proxy policy for AUTH ** **	Parameters: **		context -- unused. **		auth_identity -- authentication identity. **		requested_user -- authorization identity. **		user -- allowed user (output). **		errstr -- possible error string (output). ** **	Returns: **		ok? */
end_comment

begin_function
name|int
name|proxy_policy
parameter_list|(
name|context
parameter_list|,
name|auth_identity
parameter_list|,
name|requested_user
parameter_list|,
name|user
parameter_list|,
name|errstr
parameter_list|)
name|void
modifier|*
name|context
decl_stmt|;
specifier|const
name|char
modifier|*
name|auth_identity
decl_stmt|;
specifier|const
name|char
modifier|*
name|requested_user
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|user
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errstr
decl_stmt|;
block|{
if|if
condition|(
name|user
operator|==
name|NULL
operator|||
name|auth_identity
operator|==
name|NULL
condition|)
return|return
name|SASL_FAIL
return|;
operator|*
name|user
operator|=
name|newstr
argument_list|(
name|auth_identity
argument_list|)
expr_stmt|;
return|return
name|SASL_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SASL>= 20000 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SASL */
end_comment

begin_if
if|#
directive|if
name|STARTTLS
end_if

begin_comment
comment|/* **  INITSRVTLS -- initialize server side TLS ** **	Parameters: **		tls_ok -- should tls initialization be done? ** **	Returns: **		succeeded? ** **	Side Effects: **		sets tls_ok_srv which is a static variable in this module. **		Do NOT remove assignments to it! */
end_comment

begin_function
name|bool
name|initsrvtls
parameter_list|(
name|tls_ok
parameter_list|)
name|bool
name|tls_ok
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|tls_ok
condition|)
return|return
name|false
return|;
comment|/* do NOT remove assignment */
name|tls_ok_srv
operator|=
name|inittls
argument_list|(
operator|&
name|srv_ctx
argument_list|,
name|TLS_Srv_Opts
argument_list|,
name|true
argument_list|,
name|SrvCertFile
argument_list|,
name|SrvKeyFile
argument_list|,
name|CACertPath
argument_list|,
name|CACertFile
argument_list|,
name|DHParams
argument_list|)
expr_stmt|;
return|return
name|tls_ok_srv
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STARTTLS */
end_comment

begin_comment
comment|/* **  SRVFEATURES -- get features for SMTP server ** **	Parameters: **		e -- envelope (should be session context). **		clientname -- name of client. **		features -- default features for this invocation. ** **	Returns: **		server features. */
end_comment

begin_comment
comment|/* table with options: it uses just one character, how about strings? */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|char
name|srvf_opt
decl_stmt|;
name|unsigned
name|int
name|srvf_flag
decl_stmt|;
block|}
name|srv_feat_table
index|[]
init|=
block|{
block|{
literal|'A'
block|,
name|SRV_OFFER_AUTH
block|}
block|,
block|{
literal|'B'
block|,
name|SRV_OFFER_VERB
block|}
block|,
block|{
literal|'C'
block|,
name|SRV_REQ_SEC
block|}
block|,
block|{
literal|'D'
block|,
name|SRV_OFFER_DSN
block|}
block|,
block|{
literal|'E'
block|,
name|SRV_OFFER_ETRN
block|}
block|,
block|{
literal|'L'
block|,
name|SRV_REQ_AUTH
block|}
block|,
if|#
directive|if
name|PIPELINING
if|#
directive|if
name|_FFR_NO_PIPE
block|{
literal|'N'
block|,
name|SRV_NO_PIPE
block|}
block|,
endif|#
directive|endif
comment|/* _FFR_NO_PIPE */
block|{
literal|'P'
block|,
name|SRV_OFFER_PIPE
block|}
block|,
endif|#
directive|endif
comment|/* PIPELINING */
block|{
literal|'R'
block|,
name|SRV_VRFY_CLT
block|}
block|,
comment|/* same as V; not documented */
block|{
literal|'S'
block|,
name|SRV_OFFER_TLS
block|}
block|,
comment|/*	{ 'T',	SRV_TMP_FAIL	},	*/
block|{
literal|'V'
block|,
name|SRV_VRFY_CLT
block|}
block|,
block|{
literal|'X'
block|,
name|SRV_OFFER_EXPN
block|}
block|,
comment|/*	{ 'Y',	SRV_OFFER_VRFY	},	*/
block|{
literal|'\0'
block|,
name|SRV_NONE
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|unsigned
name|int
name|srvfeatures
parameter_list|(
name|e
parameter_list|,
name|clientname
parameter_list|,
name|features
parameter_list|)
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|clientname
decl_stmt|;
name|unsigned
name|int
name|features
decl_stmt|;
block|{
name|int
name|r
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|,
name|c
decl_stmt|,
name|opt
decl_stmt|;
name|char
name|pvpbuf
index|[
name|PSBUFSIZE
index|]
decl_stmt|;
name|pvp
operator|=
name|NULL
expr_stmt|;
name|r
operator|=
name|rscap
argument_list|(
literal|"srv_features"
argument_list|,
name|clientname
argument_list|,
literal|""
argument_list|,
name|e
argument_list|,
operator|&
name|pvp
argument_list|,
name|pvpbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pvpbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|EX_OK
condition|)
return|return
name|features
return|;
if|if
condition|(
name|pvp
operator|==
name|NULL
operator|||
name|pvp
index|[
literal|0
index|]
operator|==
name|NULL
operator|||
operator|(
name|pvp
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|&
literal|0377
operator|)
operator|!=
name|CANONNET
condition|)
return|return
name|features
return|;
if|if
condition|(
name|pvp
index|[
literal|1
index|]
operator|!=
name|NULL
operator|&&
name|sm_strncasecmp
argument_list|(
name|pvp
index|[
literal|1
index|]
argument_list|,
literal|"temp"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SRV_TMP_FAIL
return|;
comment|/* 	**  General rule (see sendmail.h, d_flags): 	**  lower case: required/offered, upper case: Not required/available 	** 	**  Since we can change some features per daemon, we have both 	**  cases here: turn on/off a feature. 	*/
for|for
control|(
name|i
operator|=
literal|1
init|;
name|pvp
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|pvp
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|opt
operator|=
name|srv_feat_table
index|[
name|j
index|]
operator|.
name|srvf_opt
operator|)
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"srvfeatures: unknown feature %s"
argument_list|,
name|pvp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
name|opt
condition|)
block|{
name|features
operator|&=
operator|~
operator|(
name|srv_feat_table
index|[
name|j
index|]
operator|.
name|srvf_flag
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
name|tolower
argument_list|(
name|opt
argument_list|)
condition|)
block|{
name|features
operator||=
name|srv_feat_table
index|[
name|j
index|]
operator|.
name|srvf_flag
expr_stmt|;
break|break;
block|}
operator|++
name|j
expr_stmt|;
block|}
block|}
return|return
name|features
return|;
block|}
end_function

begin_comment
comment|/* **  HELP -- implement the HELP command. ** **	Parameters: **		topic -- the topic we want help for. **		e -- envelope. ** **	Returns: **		none. ** **	Side Effects: **		outputs the help file to message output. */
end_comment

begin_define
define|#
directive|define
name|HELPVSTR
value|"#vers	"
end_define

begin_define
define|#
directive|define
name|HELPVERSION
value|2
end_define

begin_function
name|void
name|help
parameter_list|(
name|topic
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|topic
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|SM_FILE_T
modifier|*
name|hf
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
name|bool
name|noinfo
decl_stmt|;
name|bool
name|first
init|=
name|true
decl_stmt|;
name|long
name|sff
init|=
name|SFF_OPENASROOT
operator||
name|SFF_REGONLY
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|char
name|inp
index|[
name|MAXLINE
index|]
decl_stmt|;
specifier|static
name|int
name|foundvers
init|=
operator|-
literal|1
decl_stmt|;
specifier|extern
name|char
name|Version
index|[]
decl_stmt|;
if|if
condition|(
name|DontLockReadFiles
condition|)
name|sff
operator||=
name|SFF_NOLOCK
expr_stmt|;
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|DBS_HELPFILEINUNSAFEDIRPATH
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
name|sff
operator||=
name|SFF_SAFEDIRPATH
expr_stmt|;
if|if
condition|(
name|HelpFile
operator|==
name|NULL
operator|||
operator|(
name|hf
operator|=
name|safefopen
argument_list|(
name|HelpFile
argument_list|,
name|O_RDONLY
argument_list|,
literal|0444
argument_list|,
name|sff
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* no help */
name|errno
operator|=
literal|0
expr_stmt|;
name|message
argument_list|(
literal|"502 5.3.0 Sendmail %s -- HELP not implemented"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|topic
operator|==
name|NULL
operator|||
operator|*
name|topic
operator|==
literal|'\0'
condition|)
block|{
name|topic
operator|=
literal|"smtp"
expr_stmt|;
name|noinfo
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|makelower
argument_list|(
name|topic
argument_list|)
expr_stmt|;
name|noinfo
operator|=
name|true
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|topic
argument_list|)
expr_stmt|;
while|while
condition|(
name|sm_io_fgets
argument_list|(
name|hf
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
if|if
condition|(
name|foundvers
operator|<
literal|0
operator|&&
name|strncmp
argument_list|(
name|buf
argument_list|,
name|HELPVSTR
argument_list|,
name|strlen
argument_list|(
name|HELPVSTR
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|h
decl_stmt|;
if|if
condition|(
name|sm_io_sscanf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|HELPVSTR
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|h
argument_list|)
operator|==
literal|1
condition|)
name|foundvers
operator|=
name|h
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
name|topic
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
name|false
expr_stmt|;
comment|/* print version if no/old vers# in file */
if|if
condition|(
name|foundvers
operator|<
literal|2
operator|&&
operator|!
name|noinfo
condition|)
name|message
argument_list|(
literal|"214-2.0.0 This is Sendmail version %s"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|strpbrk
argument_list|(
name|buf
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
name|fixcrlf
argument_list|(
name|p
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundvers
operator|>=
literal|2
condition|)
block|{
name|translate_dollars
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|expand
argument_list|(
name|p
argument_list|,
name|inp
argument_list|,
sizeof|sizeof
name|inp
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|p
operator|=
name|inp
expr_stmt|;
block|}
name|message
argument_list|(
literal|"214-2.0.0 %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|noinfo
operator|=
name|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|noinfo
condition|)
name|message
argument_list|(
literal|"504 5.3.0 HELP topic \"%.10s\" unknown"
argument_list|,
name|topic
argument_list|)
expr_stmt|;
else|else
name|message
argument_list|(
literal|"214 2.0.0 End of HELP info"
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundvers
operator|!=
literal|0
operator|&&
name|foundvers
operator|<
name|HELPVERSION
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|1
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%s too old (require version %d)"
argument_list|,
name|HelpFile
argument_list|,
name|HELPVERSION
argument_list|)
expr_stmt|;
comment|/* avoid log next time */
name|foundvers
operator|=
literal|0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|hf
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|SASL
end_if

begin_comment
comment|/* **  RESET_SASLCONN -- reset SASL connection data ** **	Parameters: **		conn -- SASL connection context **		hostname -- host name **		various connection data ** **	Returns: **		SASL result */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reset_saslconn
argument_list|(
name|sasl_conn_t
operator|*
operator|*
name|conn
argument_list|,
name|char
operator|*
name|hostname
argument_list|,
if|#
directive|if
name|SASL
operator|>=
literal|20000
name|char
operator|*
name|remoteip
argument_list|,
name|char
operator|*
name|localip
argument_list|,
name|char
operator|*
name|auth_id
argument_list|,
name|sasl_ssf_t
operator|*
name|ext_ssf
argument_list|)
else|#
directive|else
comment|/* SASL>= 20000 */
decl|struct
name|sockaddr_in
modifier|*
name|saddr_r
decl_stmt|, struct
name|sockaddr_in
modifier|*
name|saddr_l
decl_stmt|,
name|sasl_external_properties_t
modifier|*
name|ext_ssf
decl_stmt|)
endif|#
directive|endif
comment|/* SASL>= 20000 */
block|{
name|int
name|result
decl_stmt|;
name|sasl_dispose
argument_list|(
name|conn
argument_list|)
expr_stmt|;
if|#
directive|if
name|SASL
operator|>=
literal|20000
name|result
operator|=
name|sasl_server_new
argument_list|(
literal|"smtp"
argument_list|,
name|hostname
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|conn
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|SASL
operator|>
literal|10505
comment|/* use empty realm: only works in SASL> 1.5.5 */
name|result
operator|=
name|sasl_server_new
argument_list|(
literal|"smtp"
argument_list|,
name|hostname
argument_list|,
literal|""
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|conn
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SASL>= 20000 */
comment|/* use no realm -> realm is set to hostname by SASL lib */
name|result
operator|=
name|sasl_server_new
argument_list|(
literal|"smtp"
argument_list|,
name|hostname
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|conn
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SASL>= 20000 */
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
return|return
name|result
return|;
if|#
directive|if
name|SASL
operator|>=
literal|20000
if|#
directive|if
name|NETINET
operator|||
name|NETINET6
if|if
condition|(
name|remoteip
operator|!=
name|NULL
operator|&&
operator|*
name|remoteip
operator|!=
literal|'\0'
condition|)
name|result
operator|=
name|sasl_setprop
argument_list|(
operator|*
name|conn
argument_list|,
name|SASL_IPREMOTEPORT
argument_list|,
name|remoteip
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
return|return
name|result
return|;
if|if
condition|(
name|localip
operator|!=
name|NULL
operator|&&
operator|*
name|localip
operator|!=
literal|'\0'
condition|)
name|result
operator|=
name|sasl_setprop
argument_list|(
operator|*
name|conn
argument_list|,
name|SASL_IPLOCALPORT
argument_list|,
name|localip
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
return|return
name|result
return|;
endif|#
directive|endif
comment|/* NETINET || NETINET6 */
name|result
operator|=
name|sasl_setprop
argument_list|(
operator|*
name|conn
argument_list|,
name|SASL_SSF_EXTERNAL
argument_list|,
name|ext_ssf
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
return|return
name|result
return|;
name|result
operator|=
name|sasl_setprop
argument_list|(
operator|*
name|conn
argument_list|,
name|SASL_AUTH_EXTERNAL
argument_list|,
name|auth_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
return|return
name|result
return|;
else|#
directive|else
comment|/* SASL>= 20000 */
if|#
directive|if
name|NETINET
if|if
condition|(
name|saddr_r
operator|!=
name|NULL
condition|)
name|result
operator|=
name|sasl_setprop
argument_list|(
operator|*
name|conn
argument_list|,
name|SASL_IP_REMOTE
argument_list|,
name|saddr_r
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
return|return
name|result
return|;
if|if
condition|(
name|saddr_l
operator|!=
name|NULL
condition|)
name|result
operator|=
name|sasl_setprop
argument_list|(
operator|*
name|conn
argument_list|,
name|SASL_IP_LOCAL
argument_list|,
name|saddr_l
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
return|return
name|result
return|;
endif|#
directive|endif
comment|/* NETINET */
name|result
operator|=
name|sasl_setprop
argument_list|(
operator|*
name|conn
argument_list|,
name|SASL_SSF_EXTERNAL
argument_list|,
name|ext_ssf
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
return|return
name|result
return|;
endif|#
directive|endif
comment|/* SASL>= 20000 */
return|return
name|SASL_OK
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SASL */
end_comment

end_unit

