begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.  *	All rights reserved.  * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_include
include|#
directive|include
file|<sendmail.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
name|SMTP
end_if

begin_decl_stmt
specifier|static
name|char
name|id
index|[]
init|=
literal|"@(#)$Id: srvrsmtp.c,v 8.471.2.2.2.78 2001/06/26 18:52:21 gshapiro Exp $ (with SMTP)"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SMTP */
end_comment

begin_decl_stmt
specifier|static
name|char
name|id
index|[]
init|=
literal|"@(#)$Id: srvrsmtp.c,v 8.471.2.2.2.78 2001/06/26 18:52:21 gshapiro Exp $ (without SMTP)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SMTP */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! lint */
end_comment

begin_if
if|#
directive|if
name|SMTP
end_if

begin_if
if|#
directive|if
name|SASL
operator|||
name|STARTTLS
end_if

begin_include
include|#
directive|include
file|"sfsasl.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SASL || STARTTLS */
end_comment

begin_if
if|#
directive|if
name|SASL
end_if

begin_define
define|#
directive|define
name|ENC64LEN
parameter_list|(
name|l
parameter_list|)
value|(((l) + 2) * 4 / 3 + 1)
end_define

begin_decl_stmt
specifier|static
name|int
name|saslmechs
name|__P
argument_list|(
operator|(
name|sasl_conn_t
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SASL */
end_comment

begin_if
if|#
directive|if
name|STARTTLS
end_if

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|<openssl/bio.h>
end_include

begin_include
include|#
directive|include
file|<openssl/pem.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HASURANDOMDEV
end_ifndef

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HASURANDOMDEV */
end_comment

begin_decl_stmt
specifier|static
name|SSL
modifier|*
name|srv_ssl
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SSL_CTX
modifier|*
name|srv_ctx
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|TLS_NO_RSA
end_if

begin_decl_stmt
specifier|static
name|RSA
modifier|*
name|rsa
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !TLS_NO_RSA */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|tls_ok_srv
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tls_verify_cb
name|__P
argument_list|(
operator|(
name|X509_STORE_CTX
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|TLS_NO_RSA
end_if

begin_define
define|#
directive|define
name|RSA_KEYLENGTH
value|512
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !TLS_NO_RSA */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STARTTLS */
end_comment

begin_decl_stmt
specifier|static
name|time_t
name|checksmtpattack
name|__P
argument_list|(
operator|(
specifier|volatile
name|int
operator|*
operator|,
name|int
operator|,
name|bool
operator|,
name|char
operator|*
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mail_esmtp_args
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|printvrfyaddr
name|__P
argument_list|(
operator|(
name|ADDRESS
operator|*
operator|,
name|bool
operator|,
name|bool
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rcpt_esmtp_args
name|__P
argument_list|(
operator|(
name|ADDRESS
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|runinchild
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|skipword
name|__P
argument_list|(
operator|(
name|char
operator|*
specifier|volatile
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|ENVELOPE
name|BlankEnvelope
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  SMTP -- run the SMTP protocol. ** **	Parameters: **		nullserver -- if non-NULL, rejection message for **			all SMTP commands. **		e -- the envelope. ** **	Returns: **		never. ** **	Side Effects: **		Reads commands from the input channel and processes **			them. */
end_comment

begin_struct
struct|struct
name|cmd
block|{
name|char
modifier|*
name|cmd_name
decl_stmt|;
comment|/* command name */
name|int
name|cmd_code
decl_stmt|;
comment|/* internal code, see below */
block|}
struct|;
end_struct

begin_comment
comment|/* values for cmd_code */
end_comment

begin_define
define|#
directive|define
name|CMDERROR
value|0
end_define

begin_comment
comment|/* bad command */
end_comment

begin_define
define|#
directive|define
name|CMDMAIL
value|1
end_define

begin_comment
comment|/* mail -- designate sender */
end_comment

begin_define
define|#
directive|define
name|CMDRCPT
value|2
end_define

begin_comment
comment|/* rcpt -- designate recipient */
end_comment

begin_define
define|#
directive|define
name|CMDDATA
value|3
end_define

begin_comment
comment|/* data -- send message text */
end_comment

begin_define
define|#
directive|define
name|CMDRSET
value|4
end_define

begin_comment
comment|/* rset -- reset state */
end_comment

begin_define
define|#
directive|define
name|CMDVRFY
value|5
end_define

begin_comment
comment|/* vrfy -- verify address */
end_comment

begin_define
define|#
directive|define
name|CMDEXPN
value|6
end_define

begin_comment
comment|/* expn -- expand address */
end_comment

begin_define
define|#
directive|define
name|CMDNOOP
value|7
end_define

begin_comment
comment|/* noop -- do nothing */
end_comment

begin_define
define|#
directive|define
name|CMDQUIT
value|8
end_define

begin_comment
comment|/* quit -- close connection and die */
end_comment

begin_define
define|#
directive|define
name|CMDHELO
value|9
end_define

begin_comment
comment|/* helo -- be polite */
end_comment

begin_define
define|#
directive|define
name|CMDHELP
value|10
end_define

begin_comment
comment|/* help -- give usage info */
end_comment

begin_define
define|#
directive|define
name|CMDEHLO
value|11
end_define

begin_comment
comment|/* ehlo -- extended helo (RFC 1425) */
end_comment

begin_define
define|#
directive|define
name|CMDETRN
value|12
end_define

begin_comment
comment|/* etrn -- flush queue */
end_comment

begin_if
if|#
directive|if
name|SASL
end_if

begin_define
define|#
directive|define
name|CMDAUTH
value|13
end_define

begin_comment
comment|/* auth -- SASL authenticate */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SASL */
end_comment

begin_if
if|#
directive|if
name|STARTTLS
end_if

begin_define
define|#
directive|define
name|CMDSTLS
value|14
end_define

begin_comment
comment|/* STARTTLS -- start TLS session */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STARTTLS */
end_comment

begin_comment
comment|/* non-standard commands */
end_comment

begin_define
define|#
directive|define
name|CMDONEX
value|16
end_define

begin_comment
comment|/* onex -- sending one transaction only */
end_comment

begin_define
define|#
directive|define
name|CMDVERB
value|17
end_define

begin_comment
comment|/* verb -- go into verbose mode */
end_comment

begin_define
define|#
directive|define
name|CMDXUSR
value|18
end_define

begin_comment
comment|/* xusr -- initial (user) submission */
end_comment

begin_comment
comment|/* unimplemented commands from RFC 821 */
end_comment

begin_define
define|#
directive|define
name|CMDUNIMPL
value|19
end_define

begin_comment
comment|/* unimplemented rfc821 commands */
end_comment

begin_comment
comment|/* use this to catch and log "door handle" attempts on your system */
end_comment

begin_define
define|#
directive|define
name|CMDLOGBOGUS
value|23
end_define

begin_comment
comment|/* bogus command that should be logged */
end_comment

begin_comment
comment|/* debugging-only commands, only enabled if SMTPDEBUG is defined */
end_comment

begin_define
define|#
directive|define
name|CMDDBGQSHOW
value|24
end_define

begin_comment
comment|/* showq -- show send queue */
end_comment

begin_define
define|#
directive|define
name|CMDDBGDEBUG
value|25
end_define

begin_comment
comment|/* debug -- set debug mode */
end_comment

begin_comment
comment|/* **  Note: If you change this list, **        remember to update 'helpfile' */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cmd
name|CmdTab
index|[]
init|=
block|{
block|{
literal|"mail"
block|,
name|CMDMAIL
block|}
block|,
block|{
literal|"rcpt"
block|,
name|CMDRCPT
block|}
block|,
block|{
literal|"data"
block|,
name|CMDDATA
block|}
block|,
block|{
literal|"rset"
block|,
name|CMDRSET
block|}
block|,
block|{
literal|"vrfy"
block|,
name|CMDVRFY
block|}
block|,
block|{
literal|"expn"
block|,
name|CMDEXPN
block|}
block|,
block|{
literal|"help"
block|,
name|CMDHELP
block|}
block|,
block|{
literal|"noop"
block|,
name|CMDNOOP
block|}
block|,
block|{
literal|"quit"
block|,
name|CMDQUIT
block|}
block|,
block|{
literal|"helo"
block|,
name|CMDHELO
block|}
block|,
block|{
literal|"ehlo"
block|,
name|CMDEHLO
block|}
block|,
block|{
literal|"etrn"
block|,
name|CMDETRN
block|}
block|,
block|{
literal|"verb"
block|,
name|CMDVERB
block|}
block|,
block|{
literal|"onex"
block|,
name|CMDONEX
block|}
block|,
block|{
literal|"xusr"
block|,
name|CMDXUSR
block|}
block|,
block|{
literal|"send"
block|,
name|CMDUNIMPL
block|}
block|,
block|{
literal|"saml"
block|,
name|CMDUNIMPL
block|}
block|,
block|{
literal|"soml"
block|,
name|CMDUNIMPL
block|}
block|,
block|{
literal|"turn"
block|,
name|CMDUNIMPL
block|}
block|,
if|#
directive|if
name|SASL
block|{
literal|"auth"
block|,
name|CMDAUTH
block|,	}
block|,
endif|#
directive|endif
comment|/* SASL */
if|#
directive|if
name|STARTTLS
block|{
literal|"starttls"
block|,
name|CMDSTLS
block|,	}
block|,
endif|#
directive|endif
comment|/* STARTTLS */
comment|/* remaining commands are here only to trap and log attempts to use them */
block|{
literal|"showq"
block|,
name|CMDDBGQSHOW
block|}
block|,
block|{
literal|"debug"
block|,
name|CMDDBGDEBUG
block|}
block|,
block|{
literal|"wiz"
block|,
name|CMDLOGBOGUS
block|}
block|,
block|{
name|NULL
block|,
name|CMDERROR
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|OneXact
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* one xaction only this run */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|CurSmtpClient
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* who's at the other end of channel */
end_comment

begin_define
define|#
directive|define
name|MAXBADCOMMANDS
value|25
end_define

begin_comment
comment|/* maximum number of bad commands */
end_comment

begin_define
define|#
directive|define
name|MAXNOOPCOMMANDS
value|20
end_define

begin_comment
comment|/* max "noise" commands before slowdown */
end_comment

begin_define
define|#
directive|define
name|MAXHELOCOMMANDS
value|3
end_define

begin_comment
comment|/* max HELO/EHLO commands before slowdown */
end_comment

begin_define
define|#
directive|define
name|MAXVRFYCOMMANDS
value|6
end_define

begin_comment
comment|/* max VRFY/EXPN commands before slowdown */
end_comment

begin_define
define|#
directive|define
name|MAXETRNCOMMANDS
value|8
end_define

begin_comment
comment|/* max ETRN commands before slowdown */
end_comment

begin_define
define|#
directive|define
name|MAXTIMEOUT
value|(4 * 60)
end_define

begin_comment
comment|/* max timeout for bad commands */
end_comment

begin_comment
comment|/* runinchild() returns */
end_comment

begin_define
define|#
directive|define
name|RIC_INCHILD
value|0
end_define

begin_comment
comment|/* in a child process */
end_comment

begin_define
define|#
directive|define
name|RIC_INPARENT
value|1
end_define

begin_comment
comment|/* still in parent process */
end_comment

begin_define
define|#
directive|define
name|RIC_TEMPFAIL
value|2
end_define

begin_comment
comment|/* temporary failure occurred */
end_comment

begin_function
name|void
name|smtp
parameter_list|(
name|nullserver
parameter_list|,
name|d_flags
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
specifier|volatile
name|nullserver
decl_stmt|;
name|BITMAP256
name|d_flags
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
specifier|volatile
name|e
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
specifier|volatile
name|p
decl_stmt|;
specifier|register
name|struct
name|cmd
modifier|*
specifier|volatile
name|c
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
specifier|auto
name|ADDRESS
modifier|*
name|vrfyqueue
decl_stmt|;
name|ADDRESS
modifier|*
name|a
decl_stmt|;
specifier|volatile
name|bool
name|gotmail
decl_stmt|;
comment|/* mail command received */
specifier|volatile
name|bool
name|gothello
decl_stmt|;
comment|/* helo command received */
name|bool
name|vrfy
decl_stmt|;
comment|/* set if this is a vrfy command */
name|char
modifier|*
specifier|volatile
name|protocol
decl_stmt|;
comment|/* sending protocol */
name|char
modifier|*
specifier|volatile
name|sendinghost
decl_stmt|;
comment|/* sending hostname */
name|char
modifier|*
specifier|volatile
name|peerhostname
decl_stmt|;
comment|/* name of SMTP peer or "localhost" */
specifier|auto
name|char
modifier|*
name|delimptr
decl_stmt|;
name|char
modifier|*
name|id
decl_stmt|;
specifier|volatile
name|int
name|nrcpts
init|=
literal|0
decl_stmt|;
comment|/* number of RCPT commands */
name|int
name|ric
decl_stmt|;
name|bool
name|doublequeue
decl_stmt|;
specifier|volatile
name|bool
name|discard
decl_stmt|;
specifier|volatile
name|int
name|badcommands
init|=
literal|0
decl_stmt|;
comment|/* count of bad commands */
specifier|volatile
name|int
name|nverifies
init|=
literal|0
decl_stmt|;
comment|/* count of VRFY/EXPN commands */
specifier|volatile
name|int
name|n_etrn
init|=
literal|0
decl_stmt|;
comment|/* count of ETRN commands */
specifier|volatile
name|int
name|n_noop
init|=
literal|0
decl_stmt|;
comment|/* count of NOOP/VERB/ONEX etc cmds */
specifier|volatile
name|int
name|n_helo
init|=
literal|0
decl_stmt|;
comment|/* count of HELO/EHLO commands */
specifier|volatile
name|int
name|delay
init|=
literal|1
decl_stmt|;
comment|/* timeout for bad commands */
name|bool
name|ok
decl_stmt|;
specifier|volatile
name|bool
name|tempfail
init|=
name|FALSE
decl_stmt|;
if|#
directive|if
name|_FFR_MILTER
specifier|volatile
name|bool
name|milterize
init|=
operator|(
name|nullserver
operator|==
name|NULL
operator|)
decl_stmt|;
endif|#
directive|endif
comment|/* _FFR_MILTER */
specifier|volatile
name|time_t
name|wt
decl_stmt|;
comment|/* timeout after too many commands */
specifier|volatile
name|time_t
name|previous
decl_stmt|;
comment|/* time after checksmtpattack() */
specifier|volatile
name|bool
name|lognullconnection
init|=
name|TRUE
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
name|char
modifier|*
name|greetcode
init|=
literal|"220"
decl_stmt|;
name|QUEUE_CHAR
modifier|*
name|new
decl_stmt|;
name|int
name|argno
decl_stmt|;
name|char
modifier|*
name|args
index|[
name|MAXSMTPARGS
index|]
decl_stmt|;
name|char
name|inp
index|[
name|MAXLINE
index|]
decl_stmt|;
name|char
name|cmdbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
if|#
directive|if
name|SASL
name|sasl_conn_t
modifier|*
name|conn
decl_stmt|;
specifier|volatile
name|bool
name|sasl_ok
decl_stmt|;
specifier|volatile
name|int
name|n_auth
init|=
literal|0
decl_stmt|;
comment|/* count of AUTH commands */
name|bool
name|ismore
decl_stmt|;
name|int
name|result
decl_stmt|;
specifier|volatile
name|int
name|authenticating
decl_stmt|;
name|char
modifier|*
name|hostname
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|;
name|char
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|,
modifier|*
name|out2
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|int
name|inlen
decl_stmt|,
name|out2len
decl_stmt|;
name|unsigned
name|int
name|outlen
decl_stmt|;
name|char
modifier|*
specifier|volatile
name|auth_type
decl_stmt|;
name|char
modifier|*
name|mechlist
decl_stmt|;
specifier|volatile
name|int
name|n_mechs
decl_stmt|;
name|int
name|len
decl_stmt|;
name|sasl_security_properties_t
name|ssp
decl_stmt|;
name|sasl_external_properties_t
name|ext_ssf
decl_stmt|;
if|#
directive|if
name|SFIO
name|sasl_ssf_t
modifier|*
name|ssf
decl_stmt|;
endif|#
directive|endif
comment|/* SFIO */
endif|#
directive|endif
comment|/* SASL */
if|#
directive|if
name|STARTTLS
name|int
name|r
decl_stmt|;
name|int
name|rfd
decl_stmt|,
name|wfd
decl_stmt|;
specifier|volatile
name|bool
name|usetls
init|=
name|TRUE
decl_stmt|;
specifier|volatile
name|bool
name|tls_active
init|=
name|FALSE
decl_stmt|;
name|bool
name|saveQuickAbort
decl_stmt|;
name|bool
name|saveSuprErrs
decl_stmt|;
endif|#
directive|endif
comment|/* STARTTLS */
if|if
condition|(
name|fileno
argument_list|(
name|OutChannel
argument_list|)
operator|!=
name|fileno
argument_list|(
name|stdout
argument_list|)
condition|)
block|{
comment|/* arrange for debugging output to go to remote host */
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|fileno
argument_list|(
name|OutChannel
argument_list|)
argument_list|,
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|settime
argument_list|(
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_getla
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|peerhostname
operator|=
name|RealHostName
expr_stmt|;
if|if
condition|(
name|peerhostname
operator|==
name|NULL
condition|)
name|peerhostname
operator|=
literal|"localhost"
expr_stmt|;
name|CurHostName
operator|=
name|peerhostname
expr_stmt|;
name|CurSmtpClient
operator|=
name|macvalue
argument_list|(
literal|'_'
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|CurSmtpClient
operator|==
name|NULL
condition|)
name|CurSmtpClient
operator|=
name|CurHostName
expr_stmt|;
comment|/* check_relay may have set discard bit, save for later */
name|discard
operator|=
name|bitset
argument_list|(
name|EF_DISCARD
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
expr_stmt|;
name|sm_setproctitle
argument_list|(
name|TRUE
argument_list|,
name|e
argument_list|,
literal|"server %s startup"
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
if|#
directive|if
name|SASL
name|sasl_ok
operator|=
name|FALSE
expr_stmt|;
comment|/* SASL can't be used (yet) */
name|n_mechs
operator|=
literal|0
expr_stmt|;
comment|/* SASL server new connection */
name|hostname
operator|=
name|macvalue
argument_list|(
literal|'j'
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|#
directive|if
name|SASL
operator|>
literal|10505
comment|/* use empty realm: only works in SASL> 1.5.5 */
name|result
operator|=
name|sasl_server_new
argument_list|(
literal|"smtp"
argument_list|,
name|hostname
argument_list|,
literal|""
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|conn
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SASL> 10505 */
comment|/* use no realm -> realm is set to hostname by SASL lib */
name|result
operator|=
name|sasl_server_new
argument_list|(
literal|"smtp"
argument_list|,
name|hostname
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|conn
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SASL> 10505 */
if|if
condition|(
name|result
operator|==
name|SASL_OK
condition|)
block|{
name|sasl_ok
operator|=
name|TRUE
expr_stmt|;
comment|/* 		**  SASL set properties for sasl 		**  set local/remote IP 		**  XXX only IPv4: Cyrus SASL doesn't support anything else 		** 		**  XXX where exactly are these used/required? 		**  Kerberos_v4 		*/
if|#
directive|if
name|NETINET
name|in
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{daemon_family}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|in
argument_list|,
literal|"inet"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SOCKADDR_LEN_T
name|addrsize
decl_stmt|;
name|struct
name|sockaddr_in
name|saddr_l
decl_stmt|;
name|struct
name|sockaddr_in
name|saddr_r
decl_stmt|;
name|addrsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|getpeername
argument_list|(
name|fileno
argument_list|(
name|InChannel
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr_r
argument_list|,
operator|&
name|addrsize
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sasl_setprop
argument_list|(
name|conn
argument_list|,
name|SASL_IP_REMOTE
argument_list|,
operator|&
name|saddr_r
argument_list|)
expr_stmt|;
name|addrsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|fileno
argument_list|(
name|InChannel
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr_l
argument_list|,
operator|&
name|addrsize
argument_list|)
operator|==
literal|0
condition|)
name|sasl_setprop
argument_list|(
name|conn
argument_list|,
name|SASL_IP_LOCAL
argument_list|,
operator|&
name|saddr_l
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* NETINET */
name|authenticating
operator|=
name|SASL_NOT_AUTH
expr_stmt|;
name|auth_type
operator|=
name|NULL
expr_stmt|;
name|mechlist
operator|=
name|NULL
expr_stmt|;
name|user
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
literal|0
block|define(macid("{auth_author}", NULL), NULL,&BlankEnvelope);
endif|#
directive|endif
comment|/* 0 */
comment|/* set properties */
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|&
name|ssp
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|ssp
argument_list|)
expr_stmt|;
if|#
directive|if
name|SFIO
comment|/* XXX should these be options settable via .cf ? */
comment|/* ssp.min_ssf = 0; is default due to memset() */
block|{
name|ssp
operator|.
name|max_ssf
operator|=
name|INT_MAX
expr_stmt|;
name|ssp
operator|.
name|maxbufsize
operator|=
name|MAXOUTLEN
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SFIO */
if|#
directive|if
name|_FFR_SASL_OPTS
name|ssp
operator|.
name|security_flags
operator|=
name|SASLOpts
operator|&
name|SASL_SEC_MASK
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_SASL_OPTS */
name|sasl_ok
operator|=
name|sasl_setprop
argument_list|(
name|conn
argument_list|,
name|SASL_SEC_PROPS
argument_list|,
operator|&
name|ssp
argument_list|)
operator|==
name|SASL_OK
expr_stmt|;
if|if
condition|(
name|sasl_ok
condition|)
block|{
comment|/* 			**  external security strength factor; 			**  we have none so zero #   if STARTTLS 			**  we may have to change this for STARTTLS 			**  (dynamically) #   endif 			*/
name|ext_ssf
operator|.
name|ssf
operator|=
literal|0
expr_stmt|;
name|ext_ssf
operator|.
name|auth_id
operator|=
name|NULL
expr_stmt|;
name|sasl_ok
operator|=
name|sasl_setprop
argument_list|(
name|conn
argument_list|,
name|SASL_SSF_EXTERNAL
argument_list|,
operator|&
name|ext_ssf
argument_list|)
operator|==
name|SASL_OK
expr_stmt|;
block|}
if|if
condition|(
name|sasl_ok
condition|)
block|{
name|n_mechs
operator|=
name|saslmechs
argument_list|(
name|conn
argument_list|,
operator|&
name|mechlist
argument_list|)
expr_stmt|;
name|sasl_ok
operator|=
name|n_mechs
operator|>
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"SASL error: sasl_server_new failed=%d"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SASL */
if|#
directive|if
name|STARTTLS
if|#
directive|if
name|_FFR_TLS_O_T
name|saveQuickAbort
operator|=
name|QuickAbort
expr_stmt|;
name|saveSuprErrs
operator|=
name|SuprErrs
expr_stmt|;
name|SuprErrs
operator|=
name|TRUE
expr_stmt|;
name|QuickAbort
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|rscheck
argument_list|(
literal|"offer_tls"
argument_list|,
name|CurSmtpClient
argument_list|,
literal|""
argument_list|,
name|e
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
literal|8
argument_list|,
name|NULL
argument_list|)
operator|!=
name|EX_OK
operator|||
name|Errors
operator|>
literal|0
condition|)
name|usetls
operator|=
name|FALSE
expr_stmt|;
name|QuickAbort
operator|=
name|saveQuickAbort
expr_stmt|;
name|SuprErrs
operator|=
name|saveSuprErrs
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_TLS_O_T */
endif|#
directive|endif
comment|/* STARTTLS */
if|#
directive|if
name|_FFR_MILTER
if|if
condition|(
name|milterize
condition|)
block|{
name|char
name|state
decl_stmt|;
comment|/* initialize mail filter connection */
name|milter_init
argument_list|(
name|e
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|SMFIR_REJECT
case|:
name|greetcode
operator|=
literal|"554"
expr_stmt|;
name|nullserver
operator|=
literal|"Command rejected"
expr_stmt|;
name|milterize
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|SMFIR_TEMPFAIL
case|:
name|tempfail
operator|=
name|TRUE
expr_stmt|;
name|milterize
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|milterize
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_DISCARD
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|char
name|state
decl_stmt|;
operator|(
name|void
operator|)
name|milter_connect
argument_list|(
name|peerhostname
argument_list|,
name|RealHostAddr
argument_list|,
name|e
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|SMFIR_REPLYCODE
case|:
comment|/* REPLYCODE shouldn't happen */
case|case
name|SMFIR_REJECT
case|:
name|greetcode
operator|=
literal|"554"
expr_stmt|;
name|nullserver
operator|=
literal|"Command rejected"
expr_stmt|;
name|milterize
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|SMFIR_TEMPFAIL
case|:
name|tempfail
operator|=
name|TRUE
expr_stmt|;
name|milterize
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* _FFR_MILTER */
comment|/* output the first line, inserting "ESMTP" as second word */
name|expand
argument_list|(
name|SmtpGreeting
argument_list|,
name|inp
argument_list|,
sizeof|sizeof
name|inp
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|inp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|id
operator|=
name|strchr
argument_list|(
name|inp
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
name|id
operator|=
operator|&
name|inp
index|[
name|strlen
argument_list|(
name|inp
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|snprintf
argument_list|(
name|cmdbuf
argument_list|,
sizeof|sizeof
name|cmdbuf
argument_list|,
literal|"%s %%.*s ESMTP%%s"
argument_list|,
name|greetcode
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|cmdbuf
argument_list|,
sizeof|sizeof
name|cmdbuf
argument_list|,
literal|"%s-%%.*s ESMTP%%s"
argument_list|,
name|greetcode
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|cmdbuf
argument_list|,
call|(
name|int
call|)
argument_list|(
name|id
operator|-
name|inp
argument_list|)
argument_list|,
name|inp
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* output remaining lines */
while|while
condition|(
operator|(
name|id
operator|=
name|p
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|id
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|isascii
argument_list|(
operator|*
name|id
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|id
argument_list|)
condition|)
name|id
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|cmdbuf
argument_list|,
sizeof|sizeof
name|cmdbuf
argument_list|,
literal|"%s-%%s"
argument_list|,
name|greetcode
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|cmdbuf
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|id
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|isascii
argument_list|(
operator|*
name|id
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|id
argument_list|)
condition|)
name|id
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|cmdbuf
argument_list|,
sizeof|sizeof
name|cmdbuf
argument_list|,
literal|"%s %%s"
argument_list|,
name|greetcode
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|cmdbuf
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
name|protocol
operator|=
name|NULL
expr_stmt|;
name|sendinghost
operator|=
name|macvalue
argument_list|(
literal|'s'
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|gothello
operator|=
name|FALSE
expr_stmt|;
name|gotmail
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* arrange for backout */
operator|(
name|void
operator|)
name|setjmp
argument_list|(
name|TopFrame
argument_list|)
expr_stmt|;
name|QuickAbort
operator|=
name|FALSE
expr_stmt|;
name|HoldErrs
operator|=
name|FALSE
expr_stmt|;
name|SuprErrs
operator|=
name|FALSE
expr_stmt|;
name|LogUsrErrs
operator|=
name|FALSE
expr_stmt|;
name|OnlyOneError
operator|=
name|TRUE
expr_stmt|;
name|e
operator|->
name|e_flags
operator|&=
operator|~
operator|(
name|EF_VRFYONLY
operator||
name|EF_GLOBALERRS
operator|)
expr_stmt|;
comment|/* setup for the read */
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
name|Errors
operator|=
literal|0
expr_stmt|;
name|FileName
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* read the input line */
name|SmtpPhase
operator|=
literal|"server cmd read"
expr_stmt|;
name|sm_setproctitle
argument_list|(
name|TRUE
argument_list|,
name|e
argument_list|,
literal|"server %s cmd read"
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
if|#
directive|if
name|SASL
comment|/* 		**  SMTP AUTH requires accepting any length, 		**  at least for challenge/response 		**  XXX 		*/
endif|#
directive|endif
comment|/* SASL */
comment|/* handle errors */
if|if
condition|(
name|ferror
argument_list|(
name|OutChannel
argument_list|)
operator|||
operator|(
name|p
operator|=
name|sfgets
argument_list|(
name|inp
argument_list|,
sizeof|sizeof
name|inp
argument_list|,
name|InChannel
argument_list|,
name|TimeOuts
operator|.
name|to_nextcommand
argument_list|,
name|SmtpPhase
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|d
decl_stmt|;
name|d
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{daemon_name}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
name|d
operator|=
literal|"stdin"
expr_stmt|;
comment|/* end of file, just die */
name|disconnect
argument_list|(
literal|1
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|#
directive|if
name|_FFR_MILTER
comment|/* close out milter filters */
name|milter_quit
argument_list|(
name|e
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_MILTER */
name|message
argument_list|(
literal|"421 4.4.1 %s Lost input channel from %s"
argument_list|,
name|MyHostName
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
operator|(
name|gotmail
condition|?
literal|1
else|:
literal|19
operator|)
condition|)
name|sm_syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"lost input channel from %.100s to %s after %s"
argument_list|,
name|CurSmtpClient
argument_list|,
name|d
argument_list|,
operator|(
name|c
operator|==
name|NULL
operator|||
name|c
operator|->
name|cmd_name
operator|==
name|NULL
operator|)
condition|?
literal|"startup"
else|:
name|c
operator|->
name|cmd_name
argument_list|)
expr_stmt|;
comment|/* 			**  If have not accepted mail (DATA), do not bounce 			**  bad addresses back to sender. 			*/
if|if
condition|(
name|bitset
argument_list|(
name|EF_CLRQUEUE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|e
operator|->
name|e_sendqueue
operator|=
name|NULL
expr_stmt|;
goto|goto
name|doquit
goto|;
block|}
comment|/* clean up end of line */
name|fixcrlf
argument_list|(
name|inp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|#
directive|if
name|SASL
if|if
condition|(
name|authenticating
operator|==
name|SASL_PROC_AUTH
condition|)
block|{
if|#
directive|if
literal|0
block|if (*inp == '\0') 			{ 				authenticating = SASL_NOT_AUTH; 				message("501 5.5.2 missing input"); 				continue; 			}
endif|#
directive|endif
comment|/* 0 */
if|if
condition|(
operator|*
name|inp
operator|==
literal|'*'
operator|&&
operator|*
operator|(
name|inp
operator|+
literal|1
operator|)
operator|==
literal|'\0'
condition|)
block|{
name|authenticating
operator|=
name|SASL_NOT_AUTH
expr_stmt|;
comment|/* rfc 2254 4. */
name|message
argument_list|(
literal|"501 5.0.0 AUTH aborted"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* could this be shorter? XXX */
name|out
operator|=
name|xalloc
argument_list|(
name|strlen
argument_list|(
name|inp
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|sasl_decode64
argument_list|(
name|inp
argument_list|,
name|strlen
argument_list|(
name|inp
argument_list|)
argument_list|,
name|out
argument_list|,
operator|&
name|outlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
block|{
name|authenticating
operator|=
name|SASL_NOT_AUTH
expr_stmt|;
comment|/* rfc 2254 4. */
name|message
argument_list|(
literal|"501 5.5.4 cannot decode AUTH parameter %s"
argument_list|,
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|result
operator|=
name|sasl_server_step
argument_list|(
name|conn
argument_list|,
name|out
argument_list|,
name|outlen
argument_list|,
operator|&
name|out
argument_list|,
operator|&
name|outlen
argument_list|,
operator|&
name|errstr
argument_list|)
expr_stmt|;
comment|/* get an OK if we're done */
if|if
condition|(
name|result
operator|==
name|SASL_OK
condition|)
block|{
name|authenticated
label|:
name|message
argument_list|(
literal|"235 2.0.0 OK Authenticated"
argument_list|)
expr_stmt|;
name|authenticating
operator|=
name|SASL_IS_AUTH
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{auth_type}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|auth_type
argument_list|)
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
name|result
operator|=
name|sasl_getprop
argument_list|(
name|conn
argument_list|,
name|SASL_USERNAME
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
block|{
name|user
operator|=
literal|""
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{auth_authen}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|define
argument_list|(
name|macid
argument_list|(
literal|"{auth_authen}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|user
argument_list|)
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* get realm? */
block|sasl_getprop(conn, SASL_REALM, (void **)&data);
endif|#
directive|endif
comment|/* 0 */
if|#
directive|if
name|SFIO
comment|/* get security strength (features) */
name|result
operator|=
name|sasl_getprop
argument_list|(
name|conn
argument_list|,
name|SASL_SSF
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ssf
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
block|{
name|define
argument_list|(
name|macid
argument_list|(
literal|"{auth_ssf}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"0"
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
name|ssf
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|char
name|pbuf
index|[
literal|8
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|pbuf
argument_list|,
sizeof|sizeof
name|pbuf
argument_list|,
literal|"%u"
argument_list|,
operator|*
name|ssf
argument_list|)
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{auth_ssf}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|pbuf
argument_list|)
argument_list|,
operator|&
name|BlankEnvelope
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|95
argument_list|,
literal|8
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"SASL auth_ssf: %u\n"
argument_list|,
operator|*
name|ssf
argument_list|)
expr_stmt|;
block|}
comment|/* 				**  only switch to encrypted connection 				**  if a security layer has been negotiated 				*/
if|if
condition|(
name|ssf
operator|!=
name|NULL
operator|&&
operator|*
name|ssf
operator|>
literal|0
condition|)
block|{
comment|/* 					**  convert sfio stuff to use SASL 					**  check return values 					**  if the call fails, 					**  fall back to unencrypted version 					**  unless some cf option requires 					**  encryption then the connection must 					**  be aborted 					*/
if|if
condition|(
name|sfdcsasl
argument_list|(
name|InChannel
argument_list|,
name|OutChannel
argument_list|,
name|conn
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* restart dialogue */
name|gothello
operator|=
name|FALSE
expr_stmt|;
name|OneXact
operator|=
name|TRUE
expr_stmt|;
name|n_helo
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|syserr
argument_list|(
literal|"503 5.3.3 SASL TLS failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"SASL: connection from %.64s: mech=%.16s, id=%.64s, bits=%d"
argument_list|,
name|CurSmtpClient
argument_list|,
name|auth_type
argument_list|,
name|user
argument_list|,
operator|*
name|ssf
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* SFIO */
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"SASL: connection from %.64s: mech=%.16s, id=%.64s"
argument_list|,
name|CurSmtpClient
argument_list|,
name|auth_type
argument_list|,
name|user
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SFIO */
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|SASL_CONTINUE
condition|)
block|{
name|len
operator|=
name|ENC64LEN
argument_list|(
name|outlen
argument_list|)
expr_stmt|;
name|out2
operator|=
name|xalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|result
operator|=
name|sasl_encode64
argument_list|(
name|out
argument_list|,
name|outlen
argument_list|,
name|out2
argument_list|,
name|len
argument_list|,
operator|(
name|u_int
operator|*
operator|)
operator|&
name|out2len
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
block|{
comment|/* correct code? XXX */
comment|/* 454 Temp. authentication failure */
name|message
argument_list|(
literal|"454 4.5.4 Internal error: unable to encode64"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"SASL encode64 error [%d for \"%s\"]"
argument_list|,
name|result
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/* start over? */
name|authenticating
operator|=
name|SASL_NOT_AUTH
expr_stmt|;
block|}
else|else
block|{
name|message
argument_list|(
literal|"334 %s"
argument_list|,
name|out2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|95
argument_list|,
literal|2
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"SASL continue: msg='%s' len=%d\n"
argument_list|,
name|out2
argument_list|,
name|out2len
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* not SASL_OK or SASL_CONT */
name|message
argument_list|(
literal|"500 5.7.0 authentication failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"AUTH failure (%s): %s (%d)"
argument_list|,
name|auth_type
argument_list|,
name|sasl_errstring
argument_list|(
name|result
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|authenticating
operator|=
name|SASL_NOT_AUTH
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* don't want to do any of this if authenticating */
endif|#
directive|endif
comment|/* SASL */
comment|/* echo command to transcript */
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
literal|"<<< %s\n"
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>=
literal|15
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"<-- %s"
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_id
operator|==
name|NULL
condition|)
name|sm_setproctitle
argument_list|(
name|TRUE
argument_list|,
name|e
argument_list|,
literal|"%s: %.80s"
argument_list|,
name|CurSmtpClient
argument_list|,
name|inp
argument_list|)
expr_stmt|;
else|else
name|sm_setproctitle
argument_list|(
name|TRUE
argument_list|,
name|e
argument_list|,
literal|"%s %s: %.80s"
argument_list|,
name|qid_printname
argument_list|(
name|e
argument_list|)
argument_list|,
name|CurSmtpClient
argument_list|,
name|inp
argument_list|)
expr_stmt|;
comment|/* break off command */
for|for
control|(
name|p
operator|=
name|inp
init|;
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
name|cmd
operator|=
name|cmdbuf
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|&&
name|cmd
operator|<
operator|&
name|cmdbuf
index|[
sizeof|sizeof
name|cmdbuf
operator|-
literal|2
index|]
condition|)
operator|*
name|cmd
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|cmd
operator|=
literal|'\0'
expr_stmt|;
comment|/* throw away leading whitespace */
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
comment|/* decode command */
for|for
control|(
name|c
operator|=
name|CmdTab
init|;
name|c
operator|->
name|cmd_name
operator|!=
name|NULL
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|c
operator|->
name|cmd_name
argument_list|,
name|cmdbuf
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* reset errors */
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* 		**  Process command. 		** 		**	If we are running as a null server, return 550 		**	to everything. 		*/
if|if
condition|(
name|nullserver
operator|!=
name|NULL
operator|||
name|bitnset
argument_list|(
name|D_ETRNONLY
argument_list|,
name|d_flags
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|c
operator|->
name|cmd_code
condition|)
block|{
case|case
name|CMDQUIT
case|:
case|case
name|CMDHELO
case|:
case|case
name|CMDEHLO
case|:
case|case
name|CMDNOOP
case|:
case|case
name|CMDRSET
case|:
comment|/* process normally */
break|break;
case|case
name|CMDETRN
case|:
if|if
condition|(
name|bitnset
argument_list|(
name|D_ETRNONLY
argument_list|,
name|d_flags
argument_list|)
operator|&&
name|nullserver
operator|==
name|NULL
condition|)
break|break;
comment|/* FALLTHROUGH */
default|default:
if|if
condition|(
operator|++
name|badcommands
operator|>
name|MAXBADCOMMANDS
condition|)
block|{
name|delay
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|delay
operator|>=
name|MAXTIMEOUT
condition|)
name|delay
operator|=
name|MAXTIMEOUT
expr_stmt|;
operator|(
name|void
operator|)
name|sleep
argument_list|(
name|delay
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nullserver
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ISSMTPREPLY
argument_list|(
name|nullserver
argument_list|)
condition|)
name|usrerr
argument_list|(
name|nullserver
argument_list|)
expr_stmt|;
else|else
name|usrerr
argument_list|(
literal|"550 5.0.0 %s"
argument_list|,
name|nullserver
argument_list|)
expr_stmt|;
block|}
else|else
name|usrerr
argument_list|(
literal|"452 4.4.5 Insufficient disk space; try again later"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* non-null server */
switch|switch
condition|(
name|c
operator|->
name|cmd_code
condition|)
block|{
case|case
name|CMDMAIL
case|:
case|case
name|CMDEXPN
case|:
case|case
name|CMDVRFY
case|:
case|case
name|CMDETRN
case|:
name|lognullconnection
operator|=
name|FALSE
expr_stmt|;
block|}
switch|switch
condition|(
name|c
operator|->
name|cmd_code
condition|)
block|{
if|#
directive|if
name|SASL
case|case
name|CMDAUTH
case|:
comment|/* sasl */
if|if
condition|(
operator|!
name|sasl_ok
condition|)
block|{
name|message
argument_list|(
literal|"503 5.3.3 AUTH not available"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|authenticating
operator|==
name|SASL_IS_AUTH
condition|)
block|{
name|message
argument_list|(
literal|"503 5.5.0 Already Authenticated"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|gotmail
condition|)
block|{
name|message
argument_list|(
literal|"503 5.5.0 AUTH not permitted during a mail transaction"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tempfail
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"SMTP AUTH command (%.100s) from %.100s tempfailed (due to previous checks)"
argument_list|,
name|p
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
name|usrerr
argument_list|(
literal|"454 4.7.1 Please try again later"
argument_list|)
expr_stmt|;
break|break;
block|}
name|ismore
operator|=
name|FALSE
expr_stmt|;
comment|/* crude way to avoid crack attempts */
operator|(
name|void
operator|)
name|checksmtpattack
argument_list|(
operator|&
name|n_auth
argument_list|,
name|n_mechs
operator|+
literal|1
argument_list|,
name|TRUE
argument_list|,
literal|"AUTH"
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* make sure it's a valid string */
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
operator|!=
literal|'\0'
operator|&&
name|isascii
argument_list|(
operator|*
name|q
argument_list|)
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|q
argument_list|)
condition|)
block|{
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|q
operator|!=
literal|'\0'
operator|&&
name|isascii
argument_list|(
operator|*
name|q
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|q
argument_list|)
condition|)
continue|continue;
operator|*
operator|(
name|q
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|ismore
operator|=
operator|(
operator|*
name|q
operator|!=
literal|'\0'
operator|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* check whether mechanism is available */
if|if
condition|(
name|iteminlist
argument_list|(
name|p
argument_list|,
name|mechlist
argument_list|,
literal|" "
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|message
argument_list|(
literal|"503 5.3.3 AUTH mechanism %s not available"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ismore
condition|)
block|{
comment|/* could this be shorter? XXX */
name|in
operator|=
name|xalloc
argument_list|(
name|strlen
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|sasl_decode64
argument_list|(
name|q
argument_list|,
name|strlen
argument_list|(
name|q
argument_list|)
argument_list|,
name|in
argument_list|,
operator|(
name|u_int
operator|*
operator|)
operator|&
name|inlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
block|{
name|message
argument_list|(
literal|"501 5.5.4 cannot BASE64 decode '%s'"
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"SASL decode64 error [%d for \"%s\"]"
argument_list|,
name|result
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* start over? */
name|authenticating
operator|=
name|SASL_NOT_AUTH
expr_stmt|;
name|in
operator|=
name|NULL
expr_stmt|;
name|inlen
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|#
directive|if
literal|0
block|if (tTd(95, 99)) 				{ 					int i;  					dprintf("AUTH: more \""); 					for (i = 0; i< inlen; i++) 					{ 						if (isascii(in[i])&& 						    isprint(in[i])) 							dprintf("%c", in[i]); 						else 							dprintf("_"); 					} 					dprintf("\"\n"); 				}
endif|#
directive|endif
comment|/* 0 */
block|}
else|else
block|{
name|in
operator|=
name|NULL
expr_stmt|;
name|inlen
operator|=
literal|0
expr_stmt|;
block|}
comment|/* see if that auth type exists */
name|result
operator|=
name|sasl_server_start
argument_list|(
name|conn
argument_list|,
name|p
argument_list|,
name|in
argument_list|,
name|inlen
argument_list|,
operator|&
name|out
argument_list|,
operator|&
name|outlen
argument_list|,
operator|&
name|errstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
operator|&&
name|result
operator|!=
name|SASL_CONTINUE
condition|)
block|{
name|message
argument_list|(
literal|"500 5.7.0 authentication failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"AUTH failure (%s): %s (%d)"
argument_list|,
name|p
argument_list|,
name|sasl_errstring
argument_list|(
name|result
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
break|break;
block|}
name|auth_type
operator|=
name|newstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|SASL_OK
condition|)
block|{
comment|/* ugly, but same code */
goto|goto
name|authenticated
goto|;
comment|/* authenticated by the initial response */
block|}
comment|/* len is at least 2 */
name|len
operator|=
name|ENC64LEN
argument_list|(
name|outlen
argument_list|)
expr_stmt|;
name|out2
operator|=
name|xalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|result
operator|=
name|sasl_encode64
argument_list|(
name|out
argument_list|,
name|outlen
argument_list|,
name|out2
argument_list|,
name|len
argument_list|,
operator|(
name|u_int
operator|*
operator|)
operator|&
name|out2len
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
block|{
name|message
argument_list|(
literal|"454 4.5.4 Temporary authentication failure"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"SASL encode64 error [%d for \"%s\"]"
argument_list|,
name|result
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/* start over? */
name|authenticating
operator|=
name|SASL_NOT_AUTH
expr_stmt|;
block|}
else|else
block|{
name|message
argument_list|(
literal|"334 %s"
argument_list|,
name|out2
argument_list|)
expr_stmt|;
name|authenticating
operator|=
name|SASL_PROC_AUTH
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* SASL */
if|#
directive|if
name|STARTTLS
case|case
name|CMDSTLS
case|:
comment|/* starttls */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|message
argument_list|(
literal|"501 5.5.2 Syntax error (no parameters allowed)"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|usetls
condition|)
block|{
name|message
argument_list|(
literal|"503 5.5.0 TLS not available"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|tls_ok_srv
condition|)
block|{
name|message
argument_list|(
literal|"454 4.3.3 TLS not available after start"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|gotmail
condition|)
block|{
name|message
argument_list|(
literal|"503 5.5.0 TLS not permitted during a mail transaction"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tempfail
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"SMTP STARTTLS command (%.100s) from %.100s tempfailed (due to previous checks)"
argument_list|,
name|p
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
name|usrerr
argument_list|(
literal|"454 4.7.1 Please try again later"
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|TLS_NO_RSA
comment|/* 			**  XXX do we need a temp key ? 			*/
else|#
directive|else
comment|/* TLS_NO_RSA */
if|if
condition|(
name|SSL_CTX_need_tmp_RSA
argument_list|(
name|srv_ctx
argument_list|)
operator|&&
operator|!
name|SSL_CTX_set_tmp_rsa
argument_list|(
name|srv_ctx
argument_list|,
operator|(
name|rsa
operator|=
name|RSA_generate_key
argument_list|(
name|RSA_KEYLENGTH
argument_list|,
name|RSA_F4
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
argument_list|)
condition|)
block|{
name|message
argument_list|(
literal|"454 4.3.3 TLS not available: error generating RSA temp key"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsa
operator|!=
name|NULL
condition|)
name|RSA_free
argument_list|(
name|rsa
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* TLS_NO_RSA */
if|if
condition|(
name|srv_ssl
operator|!=
name|NULL
condition|)
name|SSL_clear
argument_list|(
name|srv_ssl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|srv_ssl
operator|=
name|SSL_new
argument_list|(
name|srv_ctx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|message
argument_list|(
literal|"454 4.3.3 TLS not available: error generating SSL handle"
argument_list|)
expr_stmt|;
break|break;
block|}
name|rfd
operator|=
name|fileno
argument_list|(
name|InChannel
argument_list|)
expr_stmt|;
name|wfd
operator|=
name|fileno
argument_list|(
name|OutChannel
argument_list|)
expr_stmt|;
if|if
condition|(
name|rfd
operator|<
literal|0
operator|||
name|wfd
operator|<
literal|0
operator|||
name|SSL_set_rfd
argument_list|(
name|srv_ssl
argument_list|,
name|rfd
argument_list|)
operator|<=
literal|0
operator|||
name|SSL_set_wfd
argument_list|(
name|srv_ssl
argument_list|,
name|wfd
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|message
argument_list|(
literal|"454 4.3.3 TLS not available: error set fd"
argument_list|)
expr_stmt|;
name|SSL_free
argument_list|(
name|srv_ssl
argument_list|)
expr_stmt|;
name|srv_ssl
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|message
argument_list|(
literal|"220 2.0.0 Ready to start TLS"
argument_list|)
expr_stmt|;
name|SSL_set_accept_state
argument_list|(
name|srv_ssl
argument_list|)
expr_stmt|;
define|#
directive|define
name|SSL_ACC
parameter_list|(
name|s
parameter_list|)
value|SSL_accept(s)
if|if
condition|(
operator|(
name|r
operator|=
name|SSL_ACC
argument_list|(
name|srv_ssl
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* what to do in this case? */
name|i
operator|=
name|SSL_get_error
argument_list|(
name|srv_ssl
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"TLS: error: accept failed=%d (%d)"
argument_list|,
name|r
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|tlslogerr
argument_list|()
expr_stmt|;
block|}
name|tls_ok_srv
operator|=
name|FALSE
expr_stmt|;
name|SSL_free
argument_list|(
name|srv_ssl
argument_list|)
expr_stmt|;
name|srv_ssl
operator|=
name|NULL
expr_stmt|;
comment|/* 				**  according to the next draft of 				**  RFC 2487 the connection should be dropped 				*/
comment|/* arrange to ignore any current send list */
name|e
operator|->
name|e_sendqueue
operator|=
name|NULL
expr_stmt|;
goto|goto
name|doquit
goto|;
block|}
comment|/* ignore return code for now, it's in {verify} */
operator|(
name|void
operator|)
name|tls_get_info
argument_list|(
name|srv_ssl
argument_list|,
operator|&
name|BlankEnvelope
argument_list|,
name|TRUE
argument_list|,
name|CurSmtpClient
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 			**  call Stls_client to find out whether 			**  to accept the connection from the client 			*/
name|saveQuickAbort
operator|=
name|QuickAbort
expr_stmt|;
name|saveSuprErrs
operator|=
name|SuprErrs
expr_stmt|;
name|SuprErrs
operator|=
name|TRUE
expr_stmt|;
name|QuickAbort
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|rscheck
argument_list|(
literal|"tls_client"
argument_list|,
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{verify}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|e
argument_list|)
argument_list|,
literal|"STARTTLS"
argument_list|,
name|e
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|6
argument_list|,
name|NULL
argument_list|)
operator|!=
name|EX_OK
operator|||
name|Errors
operator|>
literal|0
condition|)
block|{
specifier|extern
name|char
name|MsgBuf
index|[]
decl_stmt|;
if|if
condition|(
name|MsgBuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|ISSMTPREPLY
argument_list|(
name|MsgBuf
argument_list|)
condition|)
name|nullserver
operator|=
name|newstr
argument_list|(
name|MsgBuf
argument_list|)
expr_stmt|;
else|else
name|nullserver
operator|=
literal|"503 5.7.0 Authentication required."
expr_stmt|;
block|}
name|QuickAbort
operator|=
name|saveQuickAbort
expr_stmt|;
name|SuprErrs
operator|=
name|saveSuprErrs
expr_stmt|;
name|tls_ok_srv
operator|=
name|FALSE
expr_stmt|;
comment|/* don't offer STARTTLS again */
name|gothello
operator|=
name|FALSE
expr_stmt|;
comment|/* discard info */
name|n_helo
operator|=
literal|0
expr_stmt|;
name|OneXact
operator|=
name|TRUE
expr_stmt|;
comment|/* only one xaction this run */
if|#
directive|if
name|SASL
if|if
condition|(
name|sasl_ok
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{cipher_bits}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|e
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|ext_ssf
operator|.
name|ssf
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|#
directive|if
name|_FFR_EXT_MECH
name|ext_ssf
operator|.
name|auth_id
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{cert_subject}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_EXT_MECH */
name|sasl_ok
operator|=
name|sasl_setprop
argument_list|(
name|conn
argument_list|,
name|SASL_SSF_EXTERNAL
argument_list|,
operator|&
name|ext_ssf
argument_list|)
operator|==
name|SASL_OK
expr_stmt|;
if|if
condition|(
name|mechlist
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|mechlist
argument_list|)
expr_stmt|;
name|mechlist
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sasl_ok
condition|)
block|{
name|n_mechs
operator|=
name|saslmechs
argument_list|(
name|conn
argument_list|,
operator|&
name|mechlist
argument_list|)
expr_stmt|;
name|sasl_ok
operator|=
name|n_mechs
operator|>
literal|0
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* SASL */
comment|/* switch to secure connection */
if|#
directive|if
name|SFIO
name|r
operator|=
name|sfdctls
argument_list|(
name|InChannel
argument_list|,
name|OutChannel
argument_list|,
name|srv_ssl
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SFIO */
if|#
directive|if
name|_FFR_TLS_TOREK
name|r
operator|=
name|sfdctls
argument_list|(
operator|&
name|InChannel
argument_list|,
operator|&
name|OutChannel
argument_list|,
name|srv_ssl
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_TLS_TOREK */
endif|#
directive|endif
comment|/* SFIO */
if|if
condition|(
name|r
operator|==
literal|0
condition|)
name|tls_active
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
comment|/* 				**  XXX this is an internal error 				**  how to deal with it? 				**  we can't generate an error message 				**  since the other side switched to an 				**  encrypted layer, but we could not... 				**  just "hang up"? 				*/
name|nullserver
operator|=
literal|"454 4.3.3 TLS not available: can't switch to encrypted layer"
expr_stmt|;
name|syserr
argument_list|(
literal|"TLS: can't switch to encrypted layer"
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* STARTTLS */
case|case
name|CMDHELO
case|:
comment|/* hello -- introduce yourself */
case|case
name|CMDEHLO
case|:
comment|/* extended hello */
if|if
condition|(
name|c
operator|->
name|cmd_code
operator|==
name|CMDEHLO
condition|)
block|{
name|protocol
operator|=
literal|"ESMTP"
expr_stmt|;
name|SmtpPhase
operator|=
literal|"server EHLO"
expr_stmt|;
block|}
else|else
block|{
name|protocol
operator|=
literal|"SMTP"
expr_stmt|;
name|SmtpPhase
operator|=
literal|"server HELO"
expr_stmt|;
block|}
comment|/* avoid denial-of-service */
operator|(
name|void
operator|)
name|checksmtpattack
argument_list|(
operator|&
name|n_helo
argument_list|,
name|MAXHELOCOMMANDS
argument_list|,
name|TRUE
argument_list|,
literal|"HELO/EHLO"
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* check for duplicate HELO/EHLO per RFC 1651 4.2 */
if|if
condition|(
name|gothello
condition|)
block|{
name|usrerr
argument_list|(
literal|"503 %s Duplicate HELO/EHLO"
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* check for valid domain name (re 1123 5.2.5) */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|&&
operator|!
name|AllowBogusHELO
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 %s requires domain address"
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* check for long domain name (hides Received: info) */
if|if
condition|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|>
name|MAXNAME
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 Invalid domain name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"invalid domain name (too long) from %.100s"
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
operator|!=
literal|'\0'
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|q
argument_list|)
condition|)
break|break;
if|if
condition|(
name|isalnum
argument_list|(
operator|*
name|q
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|q
argument_list|)
condition|)
block|{
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strchr
argument_list|(
literal|"[].-_#"
argument_list|,
operator|*
name|q
argument_list|)
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
condition|)
block|{
name|q
operator|=
literal|"pleased to meet you"
expr_stmt|;
name|sendinghost
operator|=
name|newstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|AllowBogusHELO
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 Invalid domain name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
literal|"invalid domain name (%.100s) from %.100s"
argument_list|,
name|p
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|q
operator|=
literal|"accepting invalid domain name"
expr_stmt|;
block|}
name|gothello
operator|=
name|TRUE
expr_stmt|;
if|#
directive|if
name|_FFR_MILTER
if|if
condition|(
name|milterize
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_DISCARD
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|char
name|state
decl_stmt|;
name|char
modifier|*
name|response
decl_stmt|;
name|response
operator|=
name|milter_helo
argument_list|(
name|p
argument_list|,
name|e
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|SMFIR_REPLYCODE
case|:
name|nullserver
operator|=
name|response
expr_stmt|;
name|milterize
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|SMFIR_REJECT
case|:
name|nullserver
operator|=
literal|"Command rejected"
expr_stmt|;
name|milterize
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|SMFIR_TEMPFAIL
case|:
name|tempfail
operator|=
name|TRUE
expr_stmt|;
name|milterize
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* _FFR_MILTER */
comment|/* print HELO response message */
if|if
condition|(
name|c
operator|->
name|cmd_code
operator|!=
name|CMDEHLO
condition|)
block|{
name|message
argument_list|(
literal|"250 %s Hello %s, %s"
argument_list|,
name|MyHostName
argument_list|,
name|CurSmtpClient
argument_list|,
name|q
argument_list|)
expr_stmt|;
break|break;
block|}
name|message
argument_list|(
literal|"250-%s Hello %s, %s"
argument_list|,
name|MyHostName
argument_list|,
name|CurSmtpClient
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* offer ENHSC even for nullserver */
if|if
condition|(
name|nullserver
operator|!=
name|NULL
condition|)
block|{
name|message
argument_list|(
literal|"250 ENHANCEDSTATUSCODES"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			**  print EHLO features list 			** 			**  Note: If you change this list, 			**        remember to update 'helpfile' 			*/
name|message
argument_list|(
literal|"250-ENHANCEDSTATUSCODES"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|PRIV_NOEXPN
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
block|{
name|message
argument_list|(
literal|"250-EXPN"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|PRIV_NOVERB
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
name|message
argument_list|(
literal|"250-VERB"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|MIME8TO7
name|message
argument_list|(
literal|"250-8BITMIME"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MIME8TO7 */
if|if
condition|(
name|MaxMessageSize
operator|>
literal|0
condition|)
name|message
argument_list|(
literal|"250-SIZE %ld"
argument_list|,
name|MaxMessageSize
argument_list|)
expr_stmt|;
else|else
name|message
argument_list|(
literal|"250-SIZE"
argument_list|)
expr_stmt|;
if|#
directive|if
name|DSN
if|if
condition|(
name|SendMIMEErrors
operator|&&
operator|!
name|bitset
argument_list|(
name|PRIV_NORECEIPTS
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
name|message
argument_list|(
literal|"250-DSN"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DSN */
name|message
argument_list|(
literal|"250-ONEX"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|PRIV_NOETRN
argument_list|,
name|PrivacyFlags
argument_list|)
operator|&&
operator|!
name|bitnset
argument_list|(
name|D_NOETRN
argument_list|,
name|d_flags
argument_list|)
condition|)
name|message
argument_list|(
literal|"250-ETRN"
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"250-XUSR"
argument_list|)
expr_stmt|;
if|#
directive|if
name|SASL
if|if
condition|(
name|sasl_ok
operator|&&
name|mechlist
operator|!=
name|NULL
operator|&&
operator|*
name|mechlist
operator|!=
literal|'\0'
condition|)
name|message
argument_list|(
literal|"250-AUTH %s"
argument_list|,
name|mechlist
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SASL */
if|#
directive|if
name|STARTTLS
if|if
condition|(
name|tls_ok_srv
operator|&&
name|usetls
condition|)
name|message
argument_list|(
literal|"250-STARTTLS"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* STARTTLS */
name|message
argument_list|(
literal|"250 HELP"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDMAIL
case|:
comment|/* mail -- designate sender */
name|SmtpPhase
operator|=
literal|"server MAIL"
expr_stmt|;
comment|/* check for validity of this command */
if|if
condition|(
operator|!
name|gothello
operator|&&
name|bitset
argument_list|(
name|PRIV_NEEDMAILHELO
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"503 5.0.0 Polite people say HELO first"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|gotmail
condition|)
block|{
name|usrerr
argument_list|(
literal|"503 5.5.0 Sender already specified"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|InChild
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|syserr
argument_list|(
literal|"503 5.5.0 Nested MAIL command: MAIL %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|TRUE
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|SASL
if|if
condition|(
name|bitnset
argument_list|(
name|D_AUTHREQ
argument_list|,
name|d_flags
argument_list|)
operator|&&
name|authenticating
operator|!=
name|SASL_IS_AUTH
condition|)
block|{
name|usrerr
argument_list|(
literal|"530 5.7.0 Authentication required"
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* SASL */
name|p
operator|=
name|skipword
argument_list|(
name|p
argument_list|,
literal|"from"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|tempfail
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"SMTP MAIL command (%.100s) from %.100s tempfailed (due to previous checks)"
argument_list|,
name|p
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
name|usrerr
argument_list|(
literal|"451 4.7.1 Please try again later"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* make sure we know who the sending host is */
if|if
condition|(
name|sendinghost
operator|==
name|NULL
condition|)
name|sendinghost
operator|=
name|peerhostname
expr_stmt|;
comment|/* fork a subprocess to process this command */
name|ric
operator|=
name|runinchild
argument_list|(
literal|"SMTP-MAIL"
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* Catch a problem and stop processing */
if|if
condition|(
name|ric
operator|==
name|RIC_TEMPFAIL
operator|&&
name|nullserver
operator|==
name|NULL
condition|)
name|nullserver
operator|=
literal|"452 4.3.0 Internal software error"
expr_stmt|;
if|if
condition|(
name|ric
operator|!=
name|RIC_INCHILD
condition|)
break|break;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|undo_subproc_no_pm
goto|;
if|if
condition|(
operator|!
name|gothello
condition|)
block|{
name|auth_warning
argument_list|(
name|e
argument_list|,
literal|"%s didn't use HELO protocol"
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PICKY_HELO_CHECK
if|if
condition|(
name|strcasecmp
argument_list|(
name|sendinghost
argument_list|,
name|peerhostname
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|strcasecmp
argument_list|(
name|peerhostname
argument_list|,
literal|"localhost"
argument_list|)
operator|!=
literal|0
operator|||
name|strcasecmp
argument_list|(
name|sendinghost
argument_list|,
name|MyHostName
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|auth_warning
argument_list|(
name|e
argument_list|,
literal|"Host %s claimed to be %s"
argument_list|,
name|CurSmtpClient
argument_list|,
name|sendinghost
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PICKY_HELO_CHECK */
if|if
condition|(
name|protocol
operator|==
name|NULL
condition|)
name|protocol
operator|=
literal|"SMTP"
expr_stmt|;
name|define
argument_list|(
literal|'r'
argument_list|,
name|protocol
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'s'
argument_list|,
name|sendinghost
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|undo_subproc_no_pm
goto|;
name|nrcpts
operator|=
literal|0
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{ntries}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"0"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_CLRQUEUE
expr_stmt|;
name|sm_setproctitle
argument_list|(
name|TRUE
argument_list|,
name|e
argument_list|,
literal|"%s %s: %.80s"
argument_list|,
name|qid_printname
argument_list|(
name|e
argument_list|)
argument_list|,
name|CurSmtpClient
argument_list|,
name|inp
argument_list|)
expr_stmt|;
comment|/* child -- go do the processing */
if|if
condition|(
name|setjmp
argument_list|(
name|TopFrame
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* this failed -- undo work */
name|undo_subproc_no_pm
label|:
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_PM_NOTIFY
expr_stmt|;
name|undo_subproc
label|:
if|if
condition|(
name|InChild
condition|)
block|{
name|QuickAbort
operator|=
name|FALSE
expr_stmt|;
name|SuprErrs
operator|=
name|TRUE
expr_stmt|;
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_FATALERRS
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|4
operator|&&
name|bitset
argument_list|(
name|EF_LOGSENDER
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|logsender
argument_list|(
name|e
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_LOGSENDER
expr_stmt|;
name|finis
argument_list|(
name|TRUE
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|QuickAbort
operator|=
name|TRUE
expr_stmt|;
comment|/* must parse sender first */
name|delimptr
operator|=
name|NULL
expr_stmt|;
name|setsender
argument_list|(
name|p
argument_list|,
name|e
argument_list|,
operator|&
name|delimptr
argument_list|,
literal|' '
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|delimptr
operator|!=
name|NULL
operator|&&
operator|*
name|delimptr
operator|!=
literal|'\0'
condition|)
operator|*
name|delimptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|undo_subproc_no_pm
goto|;
comment|/* Successfully set e_from, allow logging */
name|e
operator|->
name|e_flags
operator||=
name|EF_LOGSENDER
expr_stmt|;
comment|/* put resulting triple from parseaddr() into macros */
if|if
condition|(
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|!=
name|NULL
condition|)
name|define
argument_list|(
name|macid
argument_list|(
literal|"{mail_mailer}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|->
name|m_name
argument_list|,
name|e
argument_list|)
expr_stmt|;
else|else
name|define
argument_list|(
name|macid
argument_list|(
literal|"{mail_mailer}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_from
operator|.
name|q_host
operator|!=
name|NULL
condition|)
name|define
argument_list|(
name|macid
argument_list|(
literal|"{mail_host}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_host
argument_list|,
name|e
argument_list|)
expr_stmt|;
else|else
name|define
argument_list|(
name|macid
argument_list|(
literal|"{mail_host}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"localhost"
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_from
operator|.
name|q_user
operator|!=
name|NULL
condition|)
name|define
argument_list|(
name|macid
argument_list|(
literal|"{mail_addr}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_user
argument_list|,
name|e
argument_list|)
expr_stmt|;
else|else
name|define
argument_list|(
name|macid
argument_list|(
literal|"{mail_addr}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|undo_subproc_no_pm
goto|;
comment|/* check for possible spoofing */
if|if
condition|(
name|RealUid
operator|!=
literal|0
operator|&&
name|OpMode
operator|==
name|MD_SMTP
operator|&&
operator|!
name|wordinclass
argument_list|(
name|RealUserName
argument_list|,
literal|'t'
argument_list|)
operator|&&
operator|(
operator|!
name|bitnset
argument_list|(
name|M_LOCALMAILER
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|->
name|m_flags
argument_list|)
operator|||
name|strcmp
argument_list|(
name|e
operator|->
name|e_from
operator|.
name|q_user
argument_list|,
name|RealUserName
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|auth_warning
argument_list|(
name|e
argument_list|,
literal|"%s owned process doing -bs"
argument_list|,
name|RealUserName
argument_list|)
expr_stmt|;
block|}
comment|/* now parse ESMTP arguments */
name|e
operator|->
name|e_msgsize
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|p
expr_stmt|;
name|argno
operator|=
literal|0
expr_stmt|;
name|args
index|[
name|argno
operator|++
index|]
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|delimptr
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|kp
decl_stmt|;
name|char
modifier|*
name|vp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|equal
init|=
name|NULL
decl_stmt|;
comment|/* locate the beginning of the keyword */
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
name|kp
operator|=
name|p
expr_stmt|;
comment|/* skip to the value portion */
while|while
condition|(
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|||
operator|*
name|p
operator|==
literal|'-'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'='
condition|)
block|{
name|equal
operator|=
name|p
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|vp
operator|=
name|p
expr_stmt|;
comment|/* skip to the end of the value */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|iscntrl
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|&&
operator|*
name|p
operator|!=
literal|'='
condition|)
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|19
argument_list|,
literal|1
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"MAIL: got arg %s=\"%s\"\n"
argument_list|,
name|kp
argument_list|,
name|vp
operator|==
name|NULL
condition|?
literal|"<null>"
else|:
name|vp
argument_list|)
expr_stmt|;
name|mail_esmtp_args
argument_list|(
name|kp
argument_list|,
name|vp
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|equal
operator|!=
name|NULL
condition|)
operator|*
name|equal
operator|=
literal|'='
expr_stmt|;
name|args
index|[
name|argno
operator|++
index|]
operator|=
name|kp
expr_stmt|;
if|if
condition|(
name|argno
operator|>=
name|MAXSMTPARGS
operator|-
literal|1
condition|)
name|usrerr
argument_list|(
literal|"501 5.5.4 Too many parameters"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|undo_subproc_no_pm
goto|;
block|}
name|args
index|[
name|argno
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|undo_subproc_no_pm
goto|;
comment|/* do config file checking of the sender */
if|if
condition|(
name|rscheck
argument_list|(
literal|"check_mail"
argument_list|,
name|addr
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|4
argument_list|,
name|NULL
argument_list|)
operator|!=
name|EX_OK
operator|||
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|undo_subproc_no_pm
goto|;
if|if
condition|(
name|MaxMessageSize
operator|>
literal|0
operator|&&
operator|(
name|e
operator|->
name|e_msgsize
operator|>
name|MaxMessageSize
operator|||
name|e
operator|->
name|e_msgsize
operator|<
literal|0
operator|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"552 5.2.3 Message size exceeds fixed maximum message size (%ld)"
argument_list|,
name|MaxMessageSize
argument_list|)
expr_stmt|;
goto|goto
name|undo_subproc_no_pm
goto|;
block|}
if|if
condition|(
operator|!
name|enoughdiskspace
argument_list|(
name|e
operator|->
name|e_msgsize
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"452 4.4.5 Insufficient disk space; try again later"
argument_list|)
expr_stmt|;
goto|goto
name|undo_subproc_no_pm
goto|;
block|}
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|undo_subproc_no_pm
goto|;
if|#
directive|if
name|_FFR_MILTER
name|LogUsrErrs
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|milterize
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_DISCARD
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|char
name|state
decl_stmt|;
name|char
modifier|*
name|response
decl_stmt|;
name|response
operator|=
name|milter_envfrom
argument_list|(
name|args
argument_list|,
name|e
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|SMFIR_REPLYCODE
case|:
name|usrerr
argument_list|(
name|response
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMFIR_REJECT
case|:
name|usrerr
argument_list|(
literal|"550 5.7.1 Command rejected"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMFIR_DISCARD
case|:
name|e
operator|->
name|e_flags
operator||=
name|EF_DISCARD
expr_stmt|;
break|break;
case|case
name|SMFIR_TEMPFAIL
case|:
name|usrerr
argument_list|(
literal|"451 4.7.1 Please try again later"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|response
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _FFR_MILTER */
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|undo_subproc_no_pm
goto|;
name|message
argument_list|(
literal|"250 2.1.0 Sender ok"
argument_list|)
expr_stmt|;
name|gotmail
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|CMDRCPT
case|:
comment|/* rcpt -- designate recipient */
if|if
condition|(
operator|!
name|gotmail
condition|)
block|{
name|usrerr
argument_list|(
literal|"503 5.0.0 Need MAIL before RCPT"
argument_list|)
expr_stmt|;
break|break;
block|}
name|SmtpPhase
operator|=
literal|"server RCPT"
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|TopFrame
argument_list|)
operator|>
literal|0
condition|)
block|{
name|e
operator|->
name|e_flags
operator|&=
operator|~
operator|(
name|EF_FATALERRS
operator||
name|EF_PM_NOTIFY
operator|)
expr_stmt|;
break|break;
block|}
name|QuickAbort
operator|=
name|TRUE
expr_stmt|;
name|LogUsrErrs
operator|=
name|TRUE
expr_stmt|;
comment|/* limit flooding of our machine */
if|if
condition|(
name|MaxRcptPerMsg
operator|>
literal|0
operator|&&
name|nrcpts
operator|>=
name|MaxRcptPerMsg
condition|)
block|{
name|usrerr
argument_list|(
literal|"452 4.5.3 Too many recipients"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|e
operator|->
name|e_sendmode
operator|!=
name|SM_DELIVER
condition|)
name|e
operator|->
name|e_flags
operator||=
name|EF_VRFYONLY
expr_stmt|;
if|#
directive|if
name|_FFR_MILTER
comment|/* 			**  If the filter will be deleting recipients, 			**  don't expand them at RCPT time (in the call 			**  to recipient()).  If they are expanded, it 			**  is impossible for removefromlist() to figure 			**  out the expanded members of the original 			**  recipient and mark them as QS_DONTSEND. 			*/
if|if
condition|(
name|milter_can_delrcpts
argument_list|()
condition|)
name|e
operator|->
name|e_flags
operator||=
name|EF_VRFYONLY
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_MILTER */
name|p
operator|=
name|skipword
argument_list|(
name|p
argument_list|,
literal|"to"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
break|break;
if|#
directive|if
name|_FFR_ADDR_TYPE
name|define
argument_list|(
name|macid
argument_list|(
literal|"{addr_type}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"e r"
argument_list|,
name|e
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_ADDR_TYPE */
name|a
operator|=
name|parseaddr
argument_list|(
name|p
argument_list|,
name|NULLADDR
argument_list|,
name|RF_COPYALL
argument_list|,
literal|' '
argument_list|,
operator|&
name|delimptr
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|#
directive|if
name|_FFR_ADDR_TYPE
name|define
argument_list|(
name|macid
argument_list|(
literal|"{addr_type}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_ADDR_TYPE */
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.0.0 Missing recipient"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|delimptr
operator|!=
name|NULL
operator|&&
operator|*
name|delimptr
operator|!=
literal|'\0'
condition|)
operator|*
name|delimptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* put resulting triple from parseaddr() into macros */
if|if
condition|(
name|a
operator|->
name|q_mailer
operator|!=
name|NULL
condition|)
name|define
argument_list|(
name|macid
argument_list|(
literal|"{rcpt_mailer}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|a
operator|->
name|q_mailer
operator|->
name|m_name
argument_list|,
name|e
argument_list|)
expr_stmt|;
else|else
name|define
argument_list|(
name|macid
argument_list|(
literal|"{rcpt_mailer}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|q_host
operator|!=
name|NULL
condition|)
name|define
argument_list|(
name|macid
argument_list|(
literal|"{rcpt_host}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|a
operator|->
name|q_host
argument_list|,
name|e
argument_list|)
expr_stmt|;
else|else
name|define
argument_list|(
name|macid
argument_list|(
literal|"{rcpt_host}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"localhost"
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|q_user
operator|!=
name|NULL
condition|)
name|define
argument_list|(
name|macid
argument_list|(
literal|"{rcpt_addr}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|a
operator|->
name|q_user
argument_list|,
name|e
argument_list|)
expr_stmt|;
else|else
name|define
argument_list|(
name|macid
argument_list|(
literal|"{rcpt_addr}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
break|break;
comment|/* now parse ESMTP arguments */
name|addr
operator|=
name|p
expr_stmt|;
name|argno
operator|=
literal|0
expr_stmt|;
name|args
index|[
name|argno
operator|++
index|]
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|delimptr
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|kp
decl_stmt|;
name|char
modifier|*
name|vp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|equal
init|=
name|NULL
decl_stmt|;
comment|/* locate the beginning of the keyword */
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
name|kp
operator|=
name|p
expr_stmt|;
comment|/* skip to the value portion */
while|while
condition|(
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|||
operator|*
name|p
operator|==
literal|'-'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'='
condition|)
block|{
name|equal
operator|=
name|p
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|vp
operator|=
name|p
expr_stmt|;
comment|/* skip to the end of the value */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|iscntrl
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|&&
operator|*
name|p
operator|!=
literal|'='
condition|)
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|19
argument_list|,
literal|1
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"RCPT: got arg %s=\"%s\"\n"
argument_list|,
name|kp
argument_list|,
name|vp
operator|==
name|NULL
condition|?
literal|"<null>"
else|:
name|vp
argument_list|)
expr_stmt|;
name|rcpt_esmtp_args
argument_list|(
name|a
argument_list|,
name|kp
argument_list|,
name|vp
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|equal
operator|!=
name|NULL
condition|)
operator|*
name|equal
operator|=
literal|'='
expr_stmt|;
name|args
index|[
name|argno
operator|++
index|]
operator|=
name|kp
expr_stmt|;
if|if
condition|(
name|argno
operator|>=
name|MAXSMTPARGS
operator|-
literal|1
condition|)
name|usrerr
argument_list|(
literal|"501 5.5.4 Too many parameters"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
break|break;
block|}
name|args
index|[
name|argno
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
break|break;
comment|/* do config file checking of the recipient */
if|if
condition|(
name|rscheck
argument_list|(
literal|"check_rcpt"
argument_list|,
name|addr
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
literal|4
argument_list|,
name|NULL
argument_list|)
operator|!=
name|EX_OK
operator|||
name|Errors
operator|>
literal|0
condition|)
break|break;
if|#
directive|if
name|_FFR_MILTER
if|if
condition|(
name|milterize
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_DISCARD
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|char
name|state
decl_stmt|;
name|char
modifier|*
name|response
decl_stmt|;
name|response
operator|=
name|milter_envrcpt
argument_list|(
name|args
argument_list|,
name|e
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|SMFIR_REPLYCODE
case|:
name|usrerr
argument_list|(
name|response
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMFIR_REJECT
case|:
name|usrerr
argument_list|(
literal|"550 5.7.1 Command rejected"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMFIR_DISCARD
case|:
name|e
operator|->
name|e_flags
operator||=
name|EF_DISCARD
expr_stmt|;
break|break;
case|case
name|SMFIR_TEMPFAIL
case|:
name|usrerr
argument_list|(
literal|"451 4.7.1 Please try again later"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|response
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _FFR_MILTER */
name|define
argument_list|(
name|macid
argument_list|(
literal|"{rcpt_mailer}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{rcpt_relay}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{rcpt_addr}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{dsn_notify}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
break|break;
comment|/* save in recipient list after ESMTP mods */
name|a
operator|=
name|recipient
argument_list|(
name|a
argument_list|,
operator|&
name|e
operator|->
name|e_sendqueue
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
break|break;
comment|/* no errors during parsing, but might be a duplicate */
name|e
operator|->
name|e_to
operator|=
name|a
operator|->
name|q_paddr
expr_stmt|;
if|if
condition|(
operator|!
name|QS_IS_BADADDR
argument_list|(
name|a
operator|->
name|q_state
argument_list|)
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|e_queuedir
operator|==
name|NOQDIR
condition|)
name|initsys
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"250 2.1.5 Recipient ok%s"
argument_list|,
name|QS_IS_QUEUEUP
argument_list|(
name|a
operator|->
name|q_state
argument_list|)
condition|?
literal|" (will queue)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|nrcpts
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* punt -- should keep message in ADDRESS.... */
name|usrerr
argument_list|(
literal|"550 5.1.1 Addressee unknown"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMDDATA
case|:
comment|/* data -- text of mail */
name|SmtpPhase
operator|=
literal|"server DATA"
expr_stmt|;
if|if
condition|(
operator|!
name|gotmail
condition|)
block|{
name|usrerr
argument_list|(
literal|"503 5.0.0 Need MAIL command"
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|nrcpts
operator|<=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"503 5.0.0 Need RCPT (recipient)"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* put back discard bit */
if|if
condition|(
name|discard
condition|)
name|e
operator|->
name|e_flags
operator||=
name|EF_DISCARD
expr_stmt|;
comment|/* check to see if we need to re-expand aliases */
comment|/* also reset QS_BADADDR on already-diagnosted addrs */
name|doublequeue
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|a
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|QS_IS_VERIFIED
argument_list|(
name|a
operator|->
name|q_state
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_DISCARD
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
comment|/* need to re-expand aliases */
name|doublequeue
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|QS_IS_BADADDR
argument_list|(
name|a
operator|->
name|q_state
argument_list|)
condition|)
block|{
comment|/* make this "go away" */
name|a
operator|->
name|q_state
operator|=
name|QS_DONTSEND
expr_stmt|;
block|}
block|}
comment|/* collect the text of the message */
name|SmtpPhase
operator|=
literal|"collect"
expr_stmt|;
name|buffer_errors
argument_list|()
expr_stmt|;
name|collect
argument_list|(
name|InChannel
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|#
directive|if
name|_FFR_MILTER
if|if
condition|(
name|milterize
operator|&&
name|Errors
operator|<=
literal|0
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_DISCARD
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|char
name|state
decl_stmt|;
name|char
modifier|*
name|response
decl_stmt|;
name|response
operator|=
name|milter_data
argument_list|(
name|e
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|SMFIR_REPLYCODE
case|:
name|usrerr
argument_list|(
name|response
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMFIR_REJECT
case|:
name|usrerr
argument_list|(
literal|"554 5.7.1 Command rejected"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMFIR_DISCARD
case|:
name|e
operator|->
name|e_flags
operator||=
name|EF_DISCARD
expr_stmt|;
break|break;
case|case
name|SMFIR_TEMPFAIL
case|:
name|usrerr
argument_list|(
literal|"451 4.7.1 Please try again later"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|response
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
comment|/* abort message filters that didn't get the body */
if|if
condition|(
name|milterize
condition|)
name|milter_abort
argument_list|(
name|e
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_MILTER */
comment|/* redefine message size */
if|if
condition|(
operator|(
name|q
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{msg_size}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|e
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|inp
argument_list|,
sizeof|sizeof
name|inp
argument_list|,
literal|"%ld"
argument_list|,
name|e
operator|->
name|e_msgsize
argument_list|)
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{msg_size}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|inp
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
block|{
comment|/* Log who the mail would have gone to */
if|if
condition|(
name|LogLevel
operator|>
literal|8
operator|&&
name|e
operator|->
name|e_message
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|a
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|q_next
control|)
block|{
if|if
condition|(
operator|!
name|QS_IS_UNDELIVERED
argument_list|(
name|a
operator|->
name|q_state
argument_list|)
condition|)
continue|continue;
name|e
operator|->
name|e_to
operator|=
name|a
operator|->
name|q_paddr
expr_stmt|;
name|logdelivery
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|a
operator|->
name|q_status
argument_list|,
name|e
operator|->
name|e_message
argument_list|,
name|NULL
argument_list|,
operator|(
name|time_t
operator|)
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
block|}
name|flush_errors
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|buffer_errors
argument_list|()
expr_stmt|;
goto|goto
name|abortmessage
goto|;
block|}
comment|/* make sure we actually do delivery */
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_CLRQUEUE
expr_stmt|;
comment|/* from now on, we have to operate silently */
name|buffer_errors
argument_list|()
expr_stmt|;
name|e
operator|->
name|e_errormode
operator|=
name|EM_MAIL
expr_stmt|;
comment|/* 			**  Arrange to send to everyone. 			**	If sending to multiple people, mail back 			**		errors rather than reporting directly. 			**	In any case, don't mail back errors for 			**		anything that has happened up to 			**		now (the other end will do this). 			**	Truncate our transcript -- the mail has gotten 			**		to us successfully, and if we have 			**		to mail this back, it will be easier 			**		on the reader. 			**	Then send to everyone. 			**	Finally give a reply code.  If an error has 			**		already been given, don't mail a 			**		message back. 			**	We goose error returns by clearing error bit. 			*/
name|SmtpPhase
operator|=
literal|"delivery"
expr_stmt|;
operator|(
name|void
operator|)
name|bftruncate
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|)
expr_stmt|;
name|id
operator|=
name|e
operator|->
name|e_id
expr_stmt|;
comment|/* 			**  If a header/body check (header checks or milter) 			**  set EF_DISCARD, don't queueup the message -- 			**  that would lose the EF_DISCARD bit and deliver 			**  the message. 			*/
if|if
condition|(
name|bitset
argument_list|(
name|EF_DISCARD
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|doublequeue
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|doublequeue
condition|)
block|{
comment|/* make sure it is in the queue */
name|queueup
argument_list|(
name|e
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* send to all recipients */
if|#
directive|if
name|NAMED_BIND
name|_res
operator|.
name|retry
operator|=
name|TimeOuts
operator|.
name|res_retry
index|[
name|RES_TO_FIRST
index|]
expr_stmt|;
name|_res
operator|.
name|retrans
operator|=
name|TimeOuts
operator|.
name|res_retrans
index|[
name|RES_TO_FIRST
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* NAMED_BIND */
name|sendall
argument_list|(
name|e
argument_list|,
name|SM_DEFAULT
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
comment|/* issue success message */
name|message
argument_list|(
literal|"250 2.0.0 %s Message accepted for delivery"
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* if we just queued, poke it */
if|if
condition|(
name|doublequeue
operator|&&
name|e
operator|->
name|e_sendmode
operator|!=
name|SM_QUEUE
operator|&&
name|e
operator|->
name|e_sendmode
operator|!=
name|SM_DEFER
condition|)
block|{
name|CurrentLA
operator|=
name|sm_getla
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shouldqueue
argument_list|(
name|e
operator|->
name|e_msgpriority
argument_list|,
name|e
operator|->
name|e_ctime
argument_list|)
condition|)
block|{
comment|/* close all the queue files */
name|closexscript
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|bfclose
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_dfp
operator|=
name|NULL
expr_stmt|;
name|unlockqueue
argument_list|(
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dowork
argument_list|(
name|e
operator|->
name|e_queuedir
argument_list|,
name|id
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|abortmessage
label|:
if|if
condition|(
name|LogLevel
operator|>
literal|4
operator|&&
name|bitset
argument_list|(
name|EF_LOGSENDER
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|logsender
argument_list|(
name|e
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_LOGSENDER
expr_stmt|;
comment|/* if in a child, pop back to our parent */
if|if
condition|(
name|InChild
condition|)
name|finis
argument_list|(
name|TRUE
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
comment|/* clean up a bit */
name|gotmail
operator|=
name|FALSE
expr_stmt|;
name|dropenvelope
argument_list|(
name|e
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|CurEnv
operator|=
name|e
operator|=
name|newenvelope
argument_list|(
name|e
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator|=
name|BlankEnvelope
operator|.
name|e_flags
expr_stmt|;
break|break;
case|case
name|CMDRSET
case|:
comment|/* rset -- reset state */
if|#
directive|if
name|_FFR_MILTER
comment|/* abort milter filters */
name|milter_abort
argument_list|(
name|e
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_MILTER */
if|if
condition|(
name|tTd
argument_list|(
literal|94
argument_list|,
literal|100
argument_list|)
condition|)
name|message
argument_list|(
literal|"451 4.0.0 Test failure"
argument_list|)
expr_stmt|;
else|else
name|message
argument_list|(
literal|"250 2.0.0 Reset state"
argument_list|)
expr_stmt|;
comment|/* arrange to ignore any current send list */
name|e
operator|->
name|e_sendqueue
operator|=
name|NULL
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_CLRQUEUE
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|4
operator|&&
name|bitset
argument_list|(
name|EF_LOGSENDER
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|logsender
argument_list|(
name|e
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_LOGSENDER
expr_stmt|;
if|if
condition|(
name|InChild
condition|)
name|finis
argument_list|(
name|TRUE
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
comment|/* clean up a bit */
name|gotmail
operator|=
name|FALSE
expr_stmt|;
name|SuprErrs
operator|=
name|TRUE
expr_stmt|;
name|dropenvelope
argument_list|(
name|e
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|CurEnv
operator|=
name|e
operator|=
name|newenvelope
argument_list|(
name|e
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDVRFY
case|:
comment|/* vrfy -- verify address */
case|case
name|CMDEXPN
case|:
comment|/* expn -- expand address */
if|if
condition|(
name|tempfail
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"SMTP %s command (%.100s) from %.100s tempfailed (due to previous checks)"
argument_list|,
name|c
operator|->
name|cmd_code
operator|==
name|CMDVRFY
condition|?
literal|"VRFY"
else|:
literal|"EXPN"
argument_list|,
name|p
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
name|usrerr
argument_list|(
literal|"550 5.7.1 Please try again later"
argument_list|)
expr_stmt|;
break|break;
block|}
name|wt
operator|=
name|checksmtpattack
argument_list|(
operator|&
name|nverifies
argument_list|,
name|MAXVRFYCOMMANDS
argument_list|,
name|FALSE
argument_list|,
name|c
operator|->
name|cmd_code
operator|==
name|CMDVRFY
condition|?
literal|"VRFY"
else|:
literal|"EXPN"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|previous
operator|=
name|curtime
argument_list|()
expr_stmt|;
name|vrfy
operator|=
name|c
operator|->
name|cmd_code
operator|==
name|CMDVRFY
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|vrfy
condition|?
name|PRIV_NOVRFY
else|:
name|PRIV_NOEXPN
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
block|{
if|if
condition|(
name|vrfy
condition|)
name|message
argument_list|(
literal|"252 2.5.2 Cannot VRFY user; try RCPT to attempt delivery (or try finger)"
argument_list|)
expr_stmt|;
else|else
name|message
argument_list|(
literal|"502 5.7.0 Sorry, we do not allow this operation"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%.100s: %s [rejected]"
argument_list|,
name|CurSmtpClient
argument_list|,
name|shortenstring
argument_list|(
name|inp
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|gothello
operator|&&
name|bitset
argument_list|(
name|vrfy
condition|?
name|PRIV_NEEDVRFYHELO
else|:
name|PRIV_NEEDEXPNHELO
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"503 5.0.0 I demand that you introduce yourself first"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|runinchild
argument_list|(
name|vrfy
condition|?
literal|"SMTP-VRFY"
else|:
literal|"SMTP-EXPN"
argument_list|,
name|e
argument_list|)
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|undo_subproc
goto|;
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%.100s: %s"
argument_list|,
name|CurSmtpClient
argument_list|,
name|shortenstring
argument_list|(
name|inp
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|TopFrame
argument_list|)
operator|>
literal|0
condition|)
goto|goto
name|undo_subproc
goto|;
name|QuickAbort
operator|=
name|TRUE
expr_stmt|;
name|vrfyqueue
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|vrfy
condition|)
name|e
operator|->
name|e_flags
operator||=
name|EF_VRFYONLY
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.2 Argument required"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* do config file checking of the address */
if|if
condition|(
name|rscheck
argument_list|(
name|vrfy
condition|?
literal|"check_vrfy"
else|:
literal|"check_expn"
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
literal|4
argument_list|,
name|NULL
argument_list|)
operator|!=
name|EX_OK
operator|||
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|undo_subproc
goto|;
operator|(
name|void
operator|)
name|sendtolist
argument_list|(
name|p
argument_list|,
name|NULLADDR
argument_list|,
operator|&
name|vrfyqueue
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wt
operator|>
literal|0
condition|)
block|{
name|time_t
name|t
decl_stmt|;
name|t
operator|=
name|wt
operator|-
operator|(
name|curtime
argument_list|()
operator|-
name|previous
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|sleep
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Errors
operator|>
literal|0
condition|)
goto|goto
name|undo_subproc
goto|;
if|if
condition|(
name|vrfyqueue
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"554 5.5.2 Nothing to %s"
argument_list|,
name|vrfy
condition|?
literal|"VRFY"
else|:
literal|"EXPN"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|vrfyqueue
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|QS_IS_UNDELIVERED
argument_list|(
name|vrfyqueue
operator|->
name|q_state
argument_list|)
condition|)
block|{
name|vrfyqueue
operator|=
name|vrfyqueue
operator|->
name|q_next
expr_stmt|;
continue|continue;
block|}
comment|/* see if there is more in the vrfy list */
name|a
operator|=
name|vrfyqueue
expr_stmt|;
while|while
condition|(
operator|(
name|a
operator|=
name|a
operator|->
name|q_next
operator|)
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|QS_IS_UNDELIVERED
argument_list|(
name|a
operator|->
name|q_state
argument_list|)
operator|)
condition|)
continue|continue;
name|printvrfyaddr
argument_list|(
name|vrfyqueue
argument_list|,
name|a
operator|==
name|NULL
argument_list|,
name|vrfy
argument_list|)
expr_stmt|;
name|vrfyqueue
operator|=
name|a
expr_stmt|;
block|}
if|if
condition|(
name|InChild
condition|)
name|finis
argument_list|(
name|TRUE
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDETRN
case|:
comment|/* etrn -- force queue flush */
if|if
condition|(
name|bitset
argument_list|(
name|PRIV_NOETRN
argument_list|,
name|PrivacyFlags
argument_list|)
operator|||
name|bitnset
argument_list|(
name|D_NOETRN
argument_list|,
name|d_flags
argument_list|)
condition|)
block|{
comment|/* different message for MSA ? */
name|message
argument_list|(
literal|"502 5.7.0 Sorry, we do not allow this operation"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%.100s: %s [rejected]"
argument_list|,
name|CurSmtpClient
argument_list|,
name|shortenstring
argument_list|(
name|inp
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tempfail
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"SMTP ETRN command (%.100s) from %.100s tempfailed (due to previous checks)"
argument_list|,
name|p
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
name|usrerr
argument_list|(
literal|"451 4.7.1 Please try again later"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"500 5.5.2 Parameter required"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* crude way to avoid denial-of-service attacks */
operator|(
name|void
operator|)
name|checksmtpattack
argument_list|(
operator|&
name|n_etrn
argument_list|,
name|MAXETRNCOMMANDS
argument_list|,
name|TRUE
argument_list|,
literal|"ETRN"
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* do config file checking of the parameter */
if|if
condition|(
name|rscheck
argument_list|(
literal|"check_etrn"
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
literal|4
argument_list|,
name|NULL
argument_list|)
operator|!=
name|EX_OK
operator|||
name|Errors
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%.100s: ETRN %s"
argument_list|,
name|CurSmtpClient
argument_list|,
name|shortenstring
argument_list|(
name|p
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|id
operator|==
literal|'@'
condition|)
name|id
operator|++
expr_stmt|;
else|else
operator|*
operator|--
name|id
operator|=
literal|'@'
expr_stmt|;
name|new
operator|=
operator|(
name|QUEUE_CHAR
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|QUEUE_CHAR
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|queue_match
operator|=
name|id
expr_stmt|;
name|new
operator|->
name|queue_next
operator|=
name|NULL
expr_stmt|;
name|QueueLimitRecipient
operator|=
name|new
expr_stmt|;
name|ok
operator|=
name|runqueue
argument_list|(
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|sm_free
argument_list|(
name|QueueLimitRecipient
argument_list|)
expr_stmt|;
name|QueueLimitRecipient
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ok
operator|&&
name|Errors
operator|==
literal|0
condition|)
name|message
argument_list|(
literal|"250 2.0.0 Queuing for node %s started"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDHELP
case|:
comment|/* help -- give user info */
name|help
argument_list|(
name|p
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDNOOP
case|:
comment|/* noop -- do nothing */
operator|(
name|void
operator|)
name|checksmtpattack
argument_list|(
operator|&
name|n_noop
argument_list|,
name|MAXNOOPCOMMANDS
argument_list|,
name|TRUE
argument_list|,
literal|"NOOP"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"250 2.0.0 OK"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDQUIT
case|:
comment|/* quit -- leave mail */
name|message
argument_list|(
literal|"221 2.0.0 %s closing connection"
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
comment|/* arrange to ignore any current send list */
name|e
operator|->
name|e_sendqueue
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|STARTTLS
comment|/* shutdown TLS connection */
if|if
condition|(
name|tls_active
condition|)
block|{
operator|(
name|void
operator|)
name|endtls
argument_list|(
name|srv_ssl
argument_list|,
literal|"server"
argument_list|)
expr_stmt|;
name|tls_active
operator|=
name|FALSE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* STARTTLS */
if|#
directive|if
name|SASL
if|if
condition|(
name|authenticating
operator|==
name|SASL_IS_AUTH
condition|)
block|{
name|sasl_dispose
argument_list|(
operator|&
name|conn
argument_list|)
expr_stmt|;
name|authenticating
operator|=
name|SASL_NOT_AUTH
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SASL */
name|doquit
label|:
comment|/* avoid future 050 messages */
name|disconnect
argument_list|(
literal|1
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|#
directive|if
name|_FFR_MILTER
comment|/* close out milter filters */
name|milter_quit
argument_list|(
name|e
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_MILTER */
if|if
condition|(
name|InChild
condition|)
name|ExitStat
operator|=
name|EX_QUIT
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|4
operator|&&
name|bitset
argument_list|(
name|EF_LOGSENDER
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|logsender
argument_list|(
name|e
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_LOGSENDER
expr_stmt|;
if|if
condition|(
name|lognullconnection
operator|&&
name|LogLevel
operator|>
literal|5
condition|)
block|{
name|char
modifier|*
name|d
decl_stmt|;
name|d
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{daemon_name}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
name|d
operator|=
literal|"stdin"
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NULL
argument_list|,
literal|"%.100s did not issue MAIL/EXPN/VRFY/ETRN during connection to %s"
argument_list|,
name|CurSmtpClient
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
name|finis
argument_list|(
name|TRUE
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|CMDVERB
case|:
comment|/* set verbose mode */
if|if
condition|(
name|bitset
argument_list|(
name|PRIV_NOEXPN
argument_list|,
name|PrivacyFlags
argument_list|)
operator|||
name|bitset
argument_list|(
name|PRIV_NOVERB
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
block|{
comment|/* this would give out the same info */
name|message
argument_list|(
literal|"502 5.7.0 Verbose unavailable"
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|checksmtpattack
argument_list|(
operator|&
name|n_noop
argument_list|,
name|MAXNOOPCOMMANDS
argument_list|,
name|TRUE
argument_list|,
literal|"VERB"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|Verbose
operator|=
literal|1
expr_stmt|;
name|set_delivery_mode
argument_list|(
name|SM_DELIVER
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"250 2.0.0 Verbose mode"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDONEX
case|:
comment|/* doing one transaction only */
operator|(
name|void
operator|)
name|checksmtpattack
argument_list|(
operator|&
name|n_noop
argument_list|,
name|MAXNOOPCOMMANDS
argument_list|,
name|TRUE
argument_list|,
literal|"ONEX"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|OneXact
operator|=
name|TRUE
expr_stmt|;
name|message
argument_list|(
literal|"250 2.0.0 Only one transaction"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDXUSR
case|:
comment|/* initial (user) submission */
operator|(
name|void
operator|)
name|checksmtpattack
argument_list|(
operator|&
name|n_noop
argument_list|,
name|MAXNOOPCOMMANDS
argument_list|,
name|TRUE
argument_list|,
literal|"XUSR"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{daemon_flags}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"c u"
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"250 2.0.0 Initial submission"
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|SMTPDEBUG
case|case
name|CMDDBGQSHOW
case|:
comment|/* show queues */
name|printf
argument_list|(
literal|"Send Queue="
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|e
operator|->
name|e_sendqueue
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDDBGDEBUG
case|:
comment|/* set debug mode */
name|tTsetup
argument_list|(
name|tTdvect
argument_list|,
sizeof|sizeof
name|tTdvect
argument_list|,
literal|"0-99.1"
argument_list|)
expr_stmt|;
name|tTflag
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"200 2.0.0 Debug set"
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
comment|/* SMTPDEBUG */
case|case
name|CMDDBGQSHOW
case|:
comment|/* show queues */
case|case
name|CMDDBGDEBUG
case|:
comment|/* set debug mode */
endif|#
directive|endif
comment|/* SMTPDEBUG */
case|case
name|CMDLOGBOGUS
case|:
comment|/* bogus command */
if|if
condition|(
name|LogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_CRIT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"\"%s\" command from %.100s (%.100s)"
argument_list|,
name|c
operator|->
name|cmd_name
argument_list|,
name|CurSmtpClient
argument_list|,
name|anynet_ntoa
argument_list|(
operator|&
name|RealHostAddr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|CMDERROR
case|:
comment|/* unknown command */
if|if
condition|(
operator|++
name|badcommands
operator|>
name|MAXBADCOMMANDS
condition|)
block|{
name|message
argument_list|(
literal|"421 4.7.0 %s Too many bad commands; closing connection"
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
comment|/* arrange to ignore any current send list */
name|e
operator|->
name|e_sendqueue
operator|=
name|NULL
expr_stmt|;
goto|goto
name|doquit
goto|;
block|}
name|usrerr
argument_list|(
literal|"500 5.5.1 Command unrecognized: \"%s\""
argument_list|,
name|shortenstring
argument_list|(
name|inp
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDUNIMPL
case|:
name|usrerr
argument_list|(
literal|"502 5.5.1 Command not implemented: \"%s\""
argument_list|,
name|shortenstring
argument_list|(
name|inp
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|errno
operator|=
literal|0
expr_stmt|;
name|syserr
argument_list|(
literal|"500 5.5.0 smtp: unknown code %d"
argument_list|,
name|c
operator|->
name|cmd_code
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|SASL
block|}
endif|#
directive|endif
comment|/* SASL */
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  CHECKSMTPATTACK -- check for denial-of-service attack by repetition ** **	Parameters: **		pcounter -- pointer to a counter for this command. **		maxcount -- maximum value for this counter before we **			slow down. **		waitnow -- sleep now (in this routine)? **		cname -- command name for logging. **		e -- the current envelope. ** **	Returns: **		time to wait. ** **	Side Effects: **		Slows down if we seem to be under attack. */
end_comment

begin_function
specifier|static
name|time_t
name|checksmtpattack
parameter_list|(
name|pcounter
parameter_list|,
name|maxcount
parameter_list|,
name|waitnow
parameter_list|,
name|cname
parameter_list|,
name|e
parameter_list|)
specifier|volatile
name|int
modifier|*
name|pcounter
decl_stmt|;
name|int
name|maxcount
decl_stmt|;
name|bool
name|waitnow
decl_stmt|;
name|char
modifier|*
name|cname
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
if|if
condition|(
operator|++
operator|(
operator|*
name|pcounter
operator|)
operator|>=
name|maxcount
condition|)
block|{
name|time_t
name|s
decl_stmt|;
if|if
condition|(
operator|*
name|pcounter
operator|==
name|maxcount
operator|&&
name|LogLevel
operator|>
literal|5
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%.100s: possible SMTP attack: command=%.40s, count=%d"
argument_list|,
name|CurSmtpClient
argument_list|,
name|cname
argument_list|,
operator|*
name|pcounter
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
literal|1
operator|<<
operator|(
operator|*
name|pcounter
operator|-
name|maxcount
operator|)
expr_stmt|;
if|if
condition|(
name|s
operator|>=
name|MAXTIMEOUT
condition|)
name|s
operator|=
name|MAXTIMEOUT
expr_stmt|;
comment|/* sleep at least 1 second before returning */
operator|(
name|void
operator|)
name|sleep
argument_list|(
operator|*
name|pcounter
operator|/
name|maxcount
argument_list|)
expr_stmt|;
name|s
operator|-=
operator|*
name|pcounter
operator|/
name|maxcount
expr_stmt|;
if|if
condition|(
name|waitnow
condition|)
block|{
operator|(
name|void
operator|)
name|sleep
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|time_t
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  SKIPWORD -- skip a fixed word. ** **	Parameters: **		p -- place to start looking. **		w -- word to skip. ** **	Returns: **		p following w. **		NULL on error. ** **	Side Effects: **		clobbers the p data area. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|skipword
parameter_list|(
name|p
parameter_list|,
name|w
parameter_list|)
specifier|register
name|char
modifier|*
specifier|volatile
name|p
decl_stmt|;
name|char
modifier|*
name|w
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|firstp
init|=
name|p
decl_stmt|;
comment|/* find beginning of word */
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
comment|/* find end of word */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
block|{
name|syntax
label|:
name|usrerr
argument_list|(
literal|"501 5.5.2 Syntax error in parameters scanning \"%s\""
argument_list|,
name|shortenstring
argument_list|(
name|firstp
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
goto|goto
name|syntax
goto|;
comment|/* see if the input word matches desired word */
if|if
condition|(
name|strcasecmp
argument_list|(
name|q
argument_list|,
name|w
argument_list|)
condition|)
goto|goto
name|syntax
goto|;
return|return
name|p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  MAIL_ESMTP_ARGS -- process ESMTP arguments from MAIL line ** **	Parameters: **		kp -- the parameter key. **		vp -- the value of that parameter. **		e -- the envelope. ** **	Returns: **		none. */
end_comment

begin_function
specifier|static
name|void
name|mail_esmtp_args
parameter_list|(
name|kp
parameter_list|,
name|vp
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|kp
decl_stmt|;
name|char
modifier|*
name|vp
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|kp
argument_list|,
literal|"size"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.2 SIZE requires a value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|define
argument_list|(
name|macid
argument_list|(
literal|"{msg_size}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|vp
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_msgsize
operator|=
name|strtol
argument_list|(
name|vp
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_msgsize
operator|==
name|LONG_MAX
operator|&&
name|errno
operator|==
name|ERANGE
condition|)
block|{
name|usrerr
argument_list|(
literal|"552 5.2.3 Message size exceeds maximum value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|kp
argument_list|,
literal|"body"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.2 BODY requires a value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|vp
argument_list|,
literal|"8bitmime"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SevenBitInput
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|vp
argument_list|,
literal|"7bit"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SevenBitInput
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|usrerr
argument_list|(
literal|"501 5.5.4 Unknown BODY type %s"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|e
operator|->
name|e_bodytype
operator|=
name|newstr
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|kp
argument_list|,
literal|"envid"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|PRIV_NORECEIPTS
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"504 5.7.0 Sorry, ENVID not supported, we do not allow DSN"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.2 ENVID requires a value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
operator|!
name|xtextok
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.4 Syntax error in ENVID parameter value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|e
operator|->
name|e_envid
operator|!=
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.0 Duplicate ENVID parameter"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|e
operator|->
name|e_envid
operator|=
name|newstr
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{dsn_envid}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|vp
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|kp
argument_list|,
literal|"ret"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|PRIV_NORECEIPTS
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"504 5.7.0 Sorry, RET not supported, we do not allow DSN"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.2 RET requires a value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|bitset
argument_list|(
name|EF_RET_PARAM
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.0 Duplicate RET parameter"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|e
operator|->
name|e_flags
operator||=
name|EF_RET_PARAM
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|vp
argument_list|,
literal|"hdrs"
argument_list|)
operator|==
literal|0
condition|)
name|e
operator|->
name|e_flags
operator||=
name|EF_NO_BODY_RETN
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|vp
argument_list|,
literal|"full"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.2 Bad argument \"%s\" to RET"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|define
argument_list|(
name|macid
argument_list|(
literal|"{dsn_ret}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|vp
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|SASL
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|kp
argument_list|,
literal|"auth"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|auth_param
decl_stmt|;
comment|/* the value of the AUTH=x */
name|bool
name|saveQuickAbort
init|=
name|QuickAbort
decl_stmt|;
name|bool
name|saveSuprErrs
init|=
name|SuprErrs
decl_stmt|;
name|char
name|pbuf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.2 AUTH= requires a value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|e
operator|->
name|e_auth_param
operator|!=
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.0 Duplicate AUTH parameter"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|vp
argument_list|,
literal|' '
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|len
operator|=
name|q
operator|-
name|vp
operator|+
literal|1
expr_stmt|;
else|else
name|len
operator|=
name|strlen
argument_list|(
name|vp
argument_list|)
operator|+
literal|1
expr_stmt|;
name|auth_param
operator|=
name|xalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|auth_param
argument_list|,
name|vp
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xtextok
argument_list|(
name|auth_param
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.4 Syntax error in AUTH parameter value"
argument_list|)
expr_stmt|;
comment|/* just a warning? */
comment|/* NOTREACHED */
block|}
comment|/* XXX this might be cut off */
name|snprintf
argument_list|(
name|pbuf
argument_list|,
sizeof|sizeof
name|pbuf
argument_list|,
literal|"%s"
argument_list|,
name|xuntextify
argument_list|(
name|auth_param
argument_list|)
argument_list|)
expr_stmt|;
comment|/* xalloc() the buffer instead? */
comment|/* XXX define this always or only if trusted? */
name|define
argument_list|(
name|macid
argument_list|(
literal|"{auth_author}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|pbuf
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* 		**  call Strust_auth to find out whether 		**  auth_param is acceptable (trusted) 		**  we shouldn't trust it if not authenticated 		**  (required by RFC, leave it to ruleset?) 		*/
name|SuprErrs
operator|=
name|TRUE
expr_stmt|;
name|QuickAbort
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|auth_param
argument_list|,
literal|"<>"
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|rscheck
argument_list|(
literal|"trust_auth"
argument_list|,
name|pbuf
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
literal|10
argument_list|,
name|NULL
argument_list|)
operator|!=
name|EX_OK
operator|||
name|Errors
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|95
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|q
operator|=
name|e
operator|->
name|e_auth_param
expr_stmt|;
name|dprintf
argument_list|(
literal|"auth=\"%.100s\" not trusted user=\"%.100s\"\n"
argument_list|,
name|pbuf
argument_list|,
operator|(
name|q
operator|==
name|NULL
operator|)
condition|?
literal|""
else|:
name|q
argument_list|)
expr_stmt|;
block|}
comment|/* not trusted */
name|e
operator|->
name|e_auth_param
operator|=
name|newstr
argument_list|(
literal|"<>"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|95
argument_list|,
literal|8
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"auth=\"%.100s\" trusted\n"
argument_list|,
name|pbuf
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_auth_param
operator|=
name|newstr
argument_list|(
name|auth_param
argument_list|)
expr_stmt|;
block|}
name|sm_free
argument_list|(
name|auth_param
argument_list|)
expr_stmt|;
comment|/* reset values */
name|Errors
operator|=
literal|0
expr_stmt|;
name|QuickAbort
operator|=
name|saveQuickAbort
expr_stmt|;
name|SuprErrs
operator|=
name|saveSuprErrs
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SASL */
else|else
block|{
name|usrerr
argument_list|(
literal|"555 5.5.4 %s parameter unrecognized"
argument_list|,
name|kp
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  RCPT_ESMTP_ARGS -- process ESMTP arguments from RCPT line ** **	Parameters: **		a -- the address corresponding to the To: parameter. **		kp -- the parameter key. **		vp -- the value of that parameter. **		e -- the envelope. ** **	Returns: **		none. */
end_comment

begin_function
specifier|static
name|void
name|rcpt_esmtp_args
parameter_list|(
name|a
parameter_list|,
name|kp
parameter_list|,
name|vp
parameter_list|,
name|e
parameter_list|)
name|ADDRESS
modifier|*
name|a
decl_stmt|;
name|char
modifier|*
name|kp
decl_stmt|;
name|char
modifier|*
name|vp
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|kp
argument_list|,
literal|"notify"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|PRIV_NORECEIPTS
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"504 5.7.0 Sorry, NOTIFY not supported, we do not allow DSN"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.2 NOTIFY requires a value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|a
operator|->
name|q_flags
operator|&=
operator|~
operator|(
name|QPINGONSUCCESS
operator||
name|QPINGONFAILURE
operator||
name|QPINGONDELAY
operator|)
expr_stmt|;
name|a
operator|->
name|q_flags
operator||=
name|QHASNOTIFY
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{dsn_notify}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|vp
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|vp
argument_list|,
literal|"never"
argument_list|)
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|vp
init|;
name|p
operator|!=
name|NULL
condition|;
name|vp
operator|=
name|p
control|)
block|{
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|vp
argument_list|,
literal|"success"
argument_list|)
operator|==
literal|0
condition|)
name|a
operator|->
name|q_flags
operator||=
name|QPINGONSUCCESS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|vp
argument_list|,
literal|"failure"
argument_list|)
operator|==
literal|0
condition|)
name|a
operator|->
name|q_flags
operator||=
name|QPINGONFAILURE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|vp
argument_list|,
literal|"delay"
argument_list|)
operator|==
literal|0
condition|)
name|a
operator|->
name|q_flags
operator||=
name|QPINGONDELAY
expr_stmt|;
else|else
block|{
name|usrerr
argument_list|(
literal|"501 5.5.4 Bad argument \"%s\"  to NOTIFY"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|kp
argument_list|,
literal|"orcpt"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|PRIV_NORECEIPTS
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"504 5.7.0 Sorry, ORCPT not supported, we do not allow DSN"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.2 ORCPT requires a value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|strchr
argument_list|(
name|vp
argument_list|,
literal|';'
argument_list|)
operator|==
name|NULL
operator|||
operator|!
name|xtextok
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.4 Syntax error in ORCPT parameter value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|a
operator|->
name|q_orcpt
operator|!=
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 5.5.0 Duplicate ORCPT parameter"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|a
operator|->
name|q_orcpt
operator|=
name|newstr
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usrerr
argument_list|(
literal|"555 5.5.4 %s parameter unrecognized"
argument_list|,
name|kp
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  PRINTVRFYADDR -- print an entry in the verify queue ** **	Parameters: **		a -- the address to print **		last -- set if this is the last one. **		vrfy -- set if this is a VRFY command. ** **	Returns: **		none. ** **	Side Effects: **		Prints the appropriate 250 codes. */
end_comment

begin_define
define|#
directive|define
name|OFFF
value|(3 + 1 + 5 + 1)
end_define

begin_comment
comment|/* offset in fmt: SMTP reply + enh. code */
end_comment

begin_function
specifier|static
name|void
name|printvrfyaddr
parameter_list|(
name|a
parameter_list|,
name|last
parameter_list|,
name|vrfy
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
name|bool
name|last
decl_stmt|;
name|bool
name|vrfy
decl_stmt|;
block|{
name|char
name|fmtbuf
index|[
literal|30
index|]
decl_stmt|;
if|if
condition|(
name|vrfy
operator|&&
name|a
operator|->
name|q_mailer
operator|!=
name|NULL
operator|&&
operator|!
name|bitnset
argument_list|(
name|M_VRFY250
argument_list|,
name|a
operator|->
name|q_mailer
operator|->
name|m_flags
argument_list|)
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|fmtbuf
argument_list|,
literal|"252"
argument_list|,
sizeof|sizeof
name|fmtbuf
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|fmtbuf
argument_list|,
literal|"250"
argument_list|,
sizeof|sizeof
name|fmtbuf
argument_list|)
expr_stmt|;
name|fmtbuf
index|[
literal|3
index|]
operator|=
name|last
condition|?
literal|' '
else|:
literal|'-'
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
operator|&
name|fmtbuf
index|[
literal|4
index|]
argument_list|,
literal|"2.1.5 "
argument_list|,
sizeof|sizeof
name|fmtbuf
operator|-
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|q_fullname
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|a
operator|->
name|q_mailer
operator|==
name|NULL
operator|||
name|a
operator|->
name|q_mailer
operator|->
name|m_addrtype
operator|==
name|NULL
operator|||
name|strcasecmp
argument_list|(
name|a
operator|->
name|q_mailer
operator|->
name|m_addrtype
argument_list|,
literal|"rfc822"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|strchr
argument_list|(
name|a
operator|->
name|q_user
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
operator|&
name|fmtbuf
index|[
name|OFFF
index|]
argument_list|,
literal|"<%s@%s>"
argument_list|,
sizeof|sizeof
name|fmtbuf
operator|-
name|OFFF
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
operator|&
name|fmtbuf
index|[
name|OFFF
index|]
argument_list|,
literal|"<%s>"
argument_list|,
sizeof|sizeof
name|fmtbuf
operator|-
name|OFFF
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|fmtbuf
argument_list|,
name|a
operator|->
name|q_user
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|a
operator|->
name|q_mailer
operator|==
name|NULL
operator|||
name|a
operator|->
name|q_mailer
operator|->
name|m_addrtype
operator|==
name|NULL
operator|||
name|strcasecmp
argument_list|(
name|a
operator|->
name|q_mailer
operator|->
name|m_addrtype
argument_list|,
literal|"rfc822"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|strchr
argument_list|(
name|a
operator|->
name|q_user
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
operator|&
name|fmtbuf
index|[
name|OFFF
index|]
argument_list|,
literal|"%s<%s@%s>"
argument_list|,
sizeof|sizeof
name|fmtbuf
operator|-
name|OFFF
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
operator|&
name|fmtbuf
index|[
name|OFFF
index|]
argument_list|,
literal|"%s<%s>"
argument_list|,
sizeof|sizeof
name|fmtbuf
operator|-
name|OFFF
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|fmtbuf
argument_list|,
name|a
operator|->
name|q_fullname
argument_list|,
name|a
operator|->
name|q_user
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  RUNINCHILD -- return twice -- once in the child, then in the parent again ** **	Parameters: **		label -- a string used in error messages ** **	Returns: **		RIC_INCHILD in the child **		RIC_INPARENT in the parent **		RIC_TEMPFAIL tempfail condition ** **	Side Effects: **		none. */
end_comment

begin_function
specifier|static
name|int
name|runinchild
parameter_list|(
name|label
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|label
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|pid_t
name|childpid
decl_stmt|;
if|if
condition|(
operator|!
name|OneXact
condition|)
block|{
specifier|extern
name|int
name|NumQueues
decl_stmt|;
comment|/* 		**  advance state of PRNG 		**  this is necessary because otherwise all child processes 		**  will produce the same PRN sequence and hence the selection 		**  of a queue directory is not "really" random. 		*/
if|if
condition|(
name|NumQueues
operator|>
literal|1
condition|)
operator|(
name|void
operator|)
name|get_random
argument_list|()
expr_stmt|;
comment|/* 		**  Disable child process reaping, in case ETRN has preceded 		**  MAIL command, and then fork. 		*/
operator|(
name|void
operator|)
name|blocksignal
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
name|childpid
operator|=
name|dofork
argument_list|()
expr_stmt|;
if|if
condition|(
name|childpid
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"451 4.3.0 %s: cannot fork"
argument_list|,
name|label
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|releasesignal
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
return|return
name|RIC_INPARENT
return|;
block|}
if|if
condition|(
name|childpid
operator|>
literal|0
condition|)
block|{
specifier|auto
name|int
name|st
decl_stmt|;
comment|/* parent -- wait for child to complete */
name|sm_setproctitle
argument_list|(
name|TRUE
argument_list|,
name|e
argument_list|,
literal|"server %s child wait"
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
name|st
operator|=
name|waitfor
argument_list|(
name|childpid
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
operator|-
literal|1
condition|)
name|syserr
argument_list|(
literal|"451 4.3.0 %s: lost child"
argument_list|,
name|label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|WIFEXITED
argument_list|(
name|st
argument_list|)
condition|)
block|{
name|syserr
argument_list|(
literal|"451 4.3.0 %s: died on signal %d"
argument_list|,
name|label
argument_list|,
name|st
operator|&
literal|0177
argument_list|)
expr_stmt|;
return|return
name|RIC_TEMPFAIL
return|;
block|}
comment|/* if exited on a QUIT command, complete the process */
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|st
argument_list|)
operator|==
name|EX_QUIT
condition|)
block|{
name|disconnect
argument_list|(
literal|1
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|TRUE
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
block|}
comment|/* restore the child signal */
operator|(
name|void
operator|)
name|releasesignal
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
return|return
name|RIC_INPARENT
return|;
block|}
else|else
block|{
comment|/* child */
name|InChild
operator|=
name|TRUE
expr_stmt|;
name|QuickAbort
operator|=
name|FALSE
expr_stmt|;
comment|/* Reset global flags */
name|RestartRequest
operator|=
name|NULL
expr_stmt|;
name|ShutdownRequest
operator|=
name|NULL
expr_stmt|;
name|PendingSignal
operator|=
literal|0
expr_stmt|;
name|clearstats
argument_list|()
expr_stmt|;
name|clearenvelope
argument_list|(
name|e
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|assign_queueid
argument_list|(
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|releasesignal
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|RIC_INCHILD
return|;
block|}
end_function

begin_if
if|#
directive|if
name|SASL
end_if

begin_escape
end_escape

begin_comment
comment|/* **  SASLMECHS -- get list of possible AUTH mechanisms ** **	Parameters: **		conn -- SASL connection info **		mechlist -- output parameter for list of mechanisms ** **	Returns: **		number of mechs */
end_comment

begin_function
specifier|static
name|int
name|saslmechs
parameter_list|(
name|conn
parameter_list|,
name|mechlist
parameter_list|)
name|sasl_conn_t
modifier|*
name|conn
decl_stmt|;
name|char
modifier|*
modifier|*
name|mechlist
decl_stmt|;
block|{
name|int
name|len
decl_stmt|,
name|num
decl_stmt|,
name|result
decl_stmt|;
comment|/* "user" is currently unused */
name|result
operator|=
name|sasl_listmech
argument_list|(
name|conn
argument_list|,
literal|"user"
argument_list|,
comment|/* XXX */
literal|""
argument_list|,
literal|" "
argument_list|,
literal|""
argument_list|,
name|mechlist
argument_list|,
operator|(
name|u_int
operator|*
operator|)
operator|&
name|len
argument_list|,
operator|(
name|u_int
operator|*
operator|)
operator|&
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|SASL_OK
operator|&&
name|num
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|11
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"SASL: available mech=%s, allowed mech=%s"
argument_list|,
operator|*
name|mechlist
argument_list|,
name|AuthMechanisms
argument_list|)
expr_stmt|;
operator|*
name|mechlist
operator|=
name|intersect
argument_list|(
name|AuthMechanisms
argument_list|,
operator|*
name|mechlist
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"SASL error: listmech=%d, num=%d"
argument_list|,
name|result
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|num
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  PROXY_POLICY -- define proxy policy for AUTH ** **	Parameters: **		conntext -- unused **		auth_identity -- authentication identity **		requested_user -- authorization identity **		user -- allowed user (output) **		errstr -- possible error string (output) ** **	Returns: **		ok? */
end_comment

begin_function
name|int
name|proxy_policy
parameter_list|(
name|context
parameter_list|,
name|auth_identity
parameter_list|,
name|requested_user
parameter_list|,
name|user
parameter_list|,
name|errstr
parameter_list|)
name|void
modifier|*
name|context
decl_stmt|;
specifier|const
name|char
modifier|*
name|auth_identity
decl_stmt|;
specifier|const
name|char
modifier|*
name|requested_user
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|user
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errstr
decl_stmt|;
block|{
if|if
condition|(
name|user
operator|==
name|NULL
operator|||
name|auth_identity
operator|==
name|NULL
condition|)
return|return
name|SASL_FAIL
return|;
operator|*
name|user
operator|=
name|newstr
argument_list|(
name|auth_identity
argument_list|)
expr_stmt|;
return|return
name|SASL_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SASL */
end_comment

begin_if
if|#
directive|if
name|STARTTLS
end_if

begin_if
if|#
directive|if
operator|!
name|TLS_NO_RSA
end_if

begin_decl_stmt
name|RSA
modifier|*
name|rsa_tmp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* temporary RSA key */
end_comment

begin_decl_stmt
specifier|static
name|RSA
modifier|*
name|tmp_rsa_key
name|__P
argument_list|(
operator|(
name|SSL
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !TLS_NO_RSA */
end_comment

begin_if
if|#
directive|if
operator|!
name|NO_DH
end_if

begin_decl_stmt
specifier|static
name|DH
modifier|*
name|get_dh512
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|dh512_p
index|[]
init|=
block|{
literal|0xDA
block|,
literal|0x58
block|,
literal|0x3C
block|,
literal|0x16
block|,
literal|0xD9
block|,
literal|0x85
block|,
literal|0x22
block|,
literal|0x89
block|,
literal|0xD0
block|,
literal|0xE4
block|,
literal|0xAF
block|,
literal|0x75
block|,
literal|0x6F
block|,
literal|0x4C
block|,
literal|0xCA
block|,
literal|0x92
block|,
literal|0xDD
block|,
literal|0x4B
block|,
literal|0xE5
block|,
literal|0x33
block|,
literal|0xB8
block|,
literal|0x04
block|,
literal|0xFB
block|,
literal|0x0F
block|,
literal|0xED
block|,
literal|0x94
block|,
literal|0xEF
block|,
literal|0x9C
block|,
literal|0x8A
block|,
literal|0x44
block|,
literal|0x03
block|,
literal|0xED
block|,
literal|0x57
block|,
literal|0x46
block|,
literal|0x50
block|,
literal|0xD3
block|,
literal|0x69
block|,
literal|0x99
block|,
literal|0xDB
block|,
literal|0x29
block|,
literal|0xD7
block|,
literal|0x76
block|,
literal|0x27
block|,
literal|0x6B
block|,
literal|0xA2
block|,
literal|0xD3
block|,
literal|0xD4
block|,
literal|0x12
block|,
literal|0xE2
block|,
literal|0x18
block|,
literal|0xF4
block|,
literal|0xDD
block|,
literal|0x1E
block|,
literal|0x08
block|,
literal|0x4C
block|,
literal|0xF6
block|,
literal|0xD8
block|,
literal|0x00
block|,
literal|0x3E
block|,
literal|0x7C
block|,
literal|0x47
block|,
literal|0x74
block|,
literal|0xE8
block|,
literal|0x33
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|dh512_g
index|[]
init|=
block|{
literal|0x02
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|DH
modifier|*
name|get_dh512
parameter_list|()
block|{
name|DH
modifier|*
name|dh
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|dh
operator|=
name|DH_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|dh
operator|->
name|p
operator|=
name|BN_bin2bn
argument_list|(
name|dh512_p
argument_list|,
sizeof|sizeof
argument_list|(
name|dh512_p
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dh
operator|->
name|g
operator|=
name|BN_bin2bn
argument_list|(
name|dh512_g
argument_list|,
sizeof|sizeof
argument_list|(
name|dh512_g
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dh
operator|->
name|p
operator|==
name|NULL
operator|)
operator|||
operator|(
name|dh
operator|->
name|g
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|dh
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !NO_DH */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **  TLS_RAND_INIT -- initialize STARTTLS random generator ** **	Parameters: **		randfile -- name of file with random data **		logl -- loglevel ** **	Returns: **		success/failure ** **	Side Effects: **		initializes PRNG for tls library. */
end_comment

begin_define
define|#
directive|define
name|MIN_RAND_BYTES
value|16
end_define

begin_comment
comment|/* 128 bits */
end_comment

begin_function
name|bool
name|tls_rand_init
parameter_list|(
name|randfile
parameter_list|,
name|logl
parameter_list|)
name|char
modifier|*
name|randfile
decl_stmt|;
name|int
name|logl
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|HASURANDOMDEV
comment|/* not required if /dev/urandom exists, OpenSSL does it internally */
define|#
directive|define
name|RF_OK
value|0
comment|/* randfile OK */
define|#
directive|define
name|RF_MISS
value|1
comment|/* randfile == NULL || *randfile == '\0' */
define|#
directive|define
name|RF_UNKNOWN
value|2
comment|/* unknown prefix for randfile */
define|#
directive|define
name|RI_NONE
value|0
comment|/* no init yet */
define|#
directive|define
name|RI_SUCCESS
value|1
comment|/* init was successful */
define|#
directive|define
name|RI_FAIL
value|2
comment|/* init failed */
name|bool
name|ok
decl_stmt|;
name|int
name|randdef
decl_stmt|;
specifier|static
name|int
name|done
init|=
name|RI_NONE
decl_stmt|;
comment|/* 	**  initialize PRNG 	*/
comment|/* did we try this before? if yes: return old value */
if|if
condition|(
name|done
operator|!=
name|RI_NONE
condition|)
return|return
name|done
operator|==
name|RI_SUCCESS
return|;
comment|/* set default values */
name|ok
operator|=
name|FALSE
expr_stmt|;
name|done
operator|=
name|RI_FAIL
expr_stmt|;
name|randdef
operator|=
operator|(
name|randfile
operator|==
name|NULL
operator|||
operator|*
name|randfile
operator|==
literal|'\0'
operator|)
condition|?
name|RF_MISS
else|:
name|RF_OK
expr_stmt|;
if|#
directive|if
name|EGD
if|if
condition|(
name|randdef
operator|==
name|RF_OK
operator|&&
name|strncasecmp
argument_list|(
name|randfile
argument_list|,
literal|"egd:"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|randfile
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|RAND_egd
argument_list|(
name|randfile
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: RAND_egd(%s) failed: random number generator not seeded"
argument_list|,
name|randfile
argument_list|)
expr_stmt|;
block|}
else|else
name|ok
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* EGD */
if|if
condition|(
name|randdef
operator|==
name|RF_OK
operator|&&
name|strncasecmp
argument_list|(
name|randfile
argument_list|,
literal|"file:"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|fd
decl_stmt|;
name|long
name|sff
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|randfile
operator|+=
literal|5
expr_stmt|;
name|sff
operator|=
name|SFF_SAFEDIRPATH
operator||
name|SFF_NOWLINK
operator||
name|SFF_NOGWFILES
operator||
name|SFF_NOWWFILES
operator||
name|SFF_NOGRFILES
operator||
name|SFF_NOWRFILES
operator||
name|SFF_MUSTOWN
operator||
name|SFF_ROOTOK
operator||
name|SFF_OPENASROOT
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|safeopen
argument_list|(
name|randfile
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
name|sff
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
name|logl
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: can't fstat(%s)"
argument_list|,
name|randfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bool
name|use
decl_stmt|,
name|problem
decl_stmt|;
name|use
operator|=
name|TRUE
expr_stmt|;
name|problem
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|st
operator|.
name|st_mtime
operator|+
literal|600
operator|<
name|curtime
argument_list|()
condition|)
block|{
name|use
operator|=
name|bitnset
argument_list|(
name|DBS_INSUFFICIENTENTROPY
argument_list|,
name|DontBlameSendmail
argument_list|)
expr_stmt|;
name|problem
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
name|logl
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: RandFile %s too old: %s"
argument_list|,
name|randfile
argument_list|,
name|use
condition|?
literal|"unsafe"
else|:
literal|"unusable"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|use
operator|&&
name|st
operator|.
name|st_size
operator|<
name|MIN_RAND_BYTES
condition|)
block|{
name|use
operator|=
name|bitnset
argument_list|(
name|DBS_INSUFFICIENTENTROPY
argument_list|,
name|DontBlameSendmail
argument_list|)
expr_stmt|;
name|problem
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
name|logl
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: size(%s)< %d: %s"
argument_list|,
name|randfile
argument_list|,
name|MIN_RAND_BYTES
argument_list|,
name|use
condition|?
literal|"unsafe"
else|:
literal|"unusable"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|use
condition|)
name|ok
operator|=
name|RAND_load_file
argument_list|(
name|randfile
argument_list|,
operator|-
literal|1
argument_list|)
operator|>=
name|MIN_RAND_BYTES
expr_stmt|;
if|if
condition|(
name|use
operator|&&
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
name|logl
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: RAND_load_file(%s) failed: random number generator not seeded"
argument_list|,
name|randfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|problem
condition|)
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|ok
operator|||
name|bitnset
argument_list|(
name|DBS_INSUFFICIENTENTROPY
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
block|{
comment|/* add this even if fstat() failed */
name|RAND_seed
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|st
argument_list|,
sizeof|sizeof
name|st
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LogLevel
operator|>
name|logl
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: Warning: safeopen(%s) failed"
argument_list|,
name|randfile
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|randdef
operator|==
name|RF_OK
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
name|logl
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: Error: no proper random file definition %s"
argument_list|,
name|randfile
argument_list|)
expr_stmt|;
name|randdef
operator|=
name|RF_UNKNOWN
expr_stmt|;
block|}
if|if
condition|(
name|randdef
operator|==
name|RF_MISS
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
name|logl
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: Error: missing random file definition"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
operator|&&
name|bitnset
argument_list|(
name|DBS_INSUFFICIENTENTROPY
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|long
name|r
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
name|MIN_RAND_BYTES
index|]
decl_stmt|;
comment|/* assert((MIN_RAND_BYTES % sizeof(long)) == 0); */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
control|)
block|{
name|r
operator|=
name|get_random
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|buf
operator|+
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|r
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RAND_seed
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
name|logl
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: Warning: random number generator not properly seeded"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|TRUE
expr_stmt|;
block|}
name|done
operator|=
name|ok
condition|?
name|RI_SUCCESS
else|:
name|RI_FAIL
expr_stmt|;
return|return
name|ok
return|;
else|#
directive|else
comment|/* !HASURANDOMDEV */
return|return
name|TRUE
return|;
endif|#
directive|endif
comment|/* !HASURANDOMDEV */
block|}
end_function

begin_comment
comment|/* **  status in initialization **  these flags keep track of the status of the initialization **  i.e., whether a file exists (_EX) and whether it can be used (_OK) **  [due to permissions] */
end_comment

begin_define
define|#
directive|define
name|TLS_S_NONE
value|0x00000000
end_define

begin_comment
comment|/* none yet  */
end_comment

begin_define
define|#
directive|define
name|TLS_S_CERT_EX
value|0x00000001
end_define

begin_comment
comment|/* CERT file exists */
end_comment

begin_define
define|#
directive|define
name|TLS_S_CERT_OK
value|0x00000002
end_define

begin_comment
comment|/* CERT file is ok */
end_comment

begin_define
define|#
directive|define
name|TLS_S_KEY_EX
value|0x00000004
end_define

begin_comment
comment|/* KEY file exists */
end_comment

begin_define
define|#
directive|define
name|TLS_S_KEY_OK
value|0x00000008
end_define

begin_comment
comment|/* KEY file is ok */
end_comment

begin_define
define|#
directive|define
name|TLS_S_CERTP_EX
value|0x00000010
end_define

begin_comment
comment|/* CA CERT PATH exists */
end_comment

begin_define
define|#
directive|define
name|TLS_S_CERTP_OK
value|0x00000020
end_define

begin_comment
comment|/* CA CERT PATH is ok */
end_comment

begin_define
define|#
directive|define
name|TLS_S_CERTF_EX
value|0x00000040
end_define

begin_comment
comment|/* CA CERT FILE exists */
end_comment

begin_define
define|#
directive|define
name|TLS_S_CERTF_OK
value|0x00000080
end_define

begin_comment
comment|/* CA CERT FILE is ok */
end_comment

begin_if
if|#
directive|if
name|_FFR_TLS_1
end_if

begin_define
define|#
directive|define
name|TLS_S_CERT2_EX
value|0x00001000
end_define

begin_comment
comment|/* 2nd CERT file exists */
end_comment

begin_define
define|#
directive|define
name|TLS_S_CERT2_OK
value|0x00002000
end_define

begin_comment
comment|/* 2nd CERT file is ok */
end_comment

begin_define
define|#
directive|define
name|TLS_S_KEY2_EX
value|0x00004000
end_define

begin_comment
comment|/* 2nd KEY file exists */
end_comment

begin_define
define|#
directive|define
name|TLS_S_KEY2_OK
value|0x00008000
end_define

begin_comment
comment|/* 2nd KEY file is ok */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_TLS_1 */
end_comment

begin_define
define|#
directive|define
name|TLS_S_DH_OK
value|0x00200000
end_define

begin_comment
comment|/* DH cert is ok */
end_comment

begin_define
define|#
directive|define
name|TLS_S_DHPAR_EX
value|0x00400000
end_define

begin_comment
comment|/* DH param file exists */
end_comment

begin_define
define|#
directive|define
name|TLS_S_DHPAR_OK
value|0x00800000
end_define

begin_comment
comment|/* DH param file is ok to use */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **  TLS_OK_F -- can var be an absolute filename? ** **	Parameters: **		var -- filename **		fn -- what is the filename used for? ** **	Returns: **		ok? */
end_comment

begin_function
specifier|static
name|bool
name|tls_ok_f
parameter_list|(
name|var
parameter_list|,
name|fn
parameter_list|)
name|char
modifier|*
name|var
decl_stmt|;
name|char
modifier|*
name|fn
decl_stmt|;
block|{
comment|/* must be absolute pathname */
if|if
condition|(
name|var
operator|!=
name|NULL
operator|&&
operator|*
name|var
operator|==
literal|'/'
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|LogLevel
operator|>
literal|12
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: file %s missing"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  TLS_SAFE_F -- is a file safe to use? ** **	Parameters: **		var -- filename **		sff -- flags for safefile() ** **	Returns: **		ok? */
end_comment

begin_function
specifier|static
name|bool
name|tls_safe_f
parameter_list|(
name|var
parameter_list|,
name|sff
parameter_list|)
name|char
modifier|*
name|var
decl_stmt|;
name|long
name|sff
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|safefile
argument_list|(
name|var
argument_list|,
name|RunAsUid
argument_list|,
name|RunAsGid
argument_list|,
name|RunAsUserName
argument_list|,
name|sff
argument_list|,
name|S_IRUSR
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|LogLevel
operator|>
literal|7
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: file %s unsafe: %s"
argument_list|,
name|var
argument_list|,
name|errstring
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* **  TLS_OK_F -- macro to simplify calls to tls_ok_f ** **	Parameters: **		var -- filename **		fn -- what is the filename used for? **		req -- is the file required? **		st -- status bit to set if ok ** **	Side Effects: **		uses r, ok; may change ok and status. ** */
end_comment

begin_define
define|#
directive|define
name|TLS_OK_F
parameter_list|(
name|var
parameter_list|,
name|fn
parameter_list|,
name|req
parameter_list|,
name|st
parameter_list|)
value|if (ok) \ 	{ \ 		r = tls_ok_f(var, fn); \ 		if (r) \ 			status |= st; \ 		else if (req) \ 			ok = FALSE; \ 	}
end_define

begin_comment
comment|/* **  TLS_UNR -- macro to return whether a file should be unreadable ** **	Parameters: **		bit -- flag to test **		req -- flags ** **	Returns: **		0/SFF_NORFILES */
end_comment

begin_define
define|#
directive|define
name|TLS_UNR
parameter_list|(
name|bit
parameter_list|,
name|req
parameter_list|)
value|(bitset(bit, req) ? SFF_NORFILES : 0)
end_define

begin_comment
comment|/* **  TLS_SAFE_F -- macro to simplify calls to tls_safe_f ** **	Parameters: **		var -- filename **		sff -- flags for safefile() **		req -- is the file required? **		ex -- does the file exist? **		st -- status bit to set if ok ** **	Side Effects: **		uses r, ok, ex; may change ok and status. ** */
end_comment

begin_define
define|#
directive|define
name|TLS_SAFE_F
parameter_list|(
name|var
parameter_list|,
name|sff
parameter_list|,
name|req
parameter_list|,
name|ex
parameter_list|,
name|st
parameter_list|)
value|if (ex&& ok) \ 	{ \ 		r = tls_safe_f(var, sff); \ 		if (r) \ 			status |= st;	\ 		else if (req) \ 			ok = FALSE;	\ 	}
end_define

begin_escape
end_escape

begin_comment
comment|/* **  INIT_TLS_LIBRARY -- calls functions which setup TLS library for global use ** **	Parameters: **		none. ** **	Returns: **		succeeded? ** **	Side Effects: **		Sets tls_ok_srv static, even when called from main() */
end_comment

begin_function
name|bool
name|init_tls_library
parameter_list|()
block|{
comment|/* 	**  basic TLS initialization 	**  ignore result for now 	*/
name|SSL_library_init
argument_list|()
expr_stmt|;
name|SSL_load_error_strings
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* this is currently a macro for SSL_library_init */
block|SSLeay_add_ssl_algorithms();
endif|#
directive|endif
comment|/* 0 */
comment|/* initialize PRNG */
name|tls_ok_srv
operator|=
name|tls_rand_init
argument_list|(
name|RandFile
argument_list|,
literal|7
argument_list|)
expr_stmt|;
return|return
name|tls_ok_srv
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  INITTLS -- initialize TLS ** **	Parameters: **		ctx -- pointer to context **		req -- requirements for initialization (see sendmail.h) **		srv -- server side? **		certfile -- filename of certificate **		keyfile -- filename of private key **		cacertpath -- path to CAs **		cacertfile -- file with CA **		dhparam -- parameters for DH ** **	Returns: **		succeeded? */
end_comment

begin_function
name|bool
name|inittls
parameter_list|(
name|ctx
parameter_list|,
name|req
parameter_list|,
name|srv
parameter_list|,
name|certfile
parameter_list|,
name|keyfile
parameter_list|,
name|cacertpath
parameter_list|,
name|cacertfile
parameter_list|,
name|dhparam
parameter_list|)
name|SSL_CTX
modifier|*
modifier|*
name|ctx
decl_stmt|;
name|u_long
name|req
decl_stmt|;
name|bool
name|srv
decl_stmt|;
name|char
modifier|*
name|certfile
decl_stmt|,
decl|*
name|keyfile
decl_stmt|,
modifier|*
name|cacertpath
decl_stmt|,
modifier|*
name|cacertfile
decl_stmt|,
modifier|*
name|dhparam
decl_stmt|;
end_function

begin_block
block|{
if|#
directive|if
operator|!
name|NO_DH
specifier|static
name|DH
modifier|*
name|dh
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* !NO_DH */
name|int
name|r
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|long
name|sff
decl_stmt|,
name|status
decl_stmt|;
name|char
modifier|*
name|who
decl_stmt|;
if|#
directive|if
name|_FFR_TLS_1
name|char
modifier|*
name|cf2
decl_stmt|,
modifier|*
name|kf2
decl_stmt|;
endif|#
directive|endif
comment|/* _FFR_TLS_1 */
name|status
operator|=
name|TLS_S_NONE
expr_stmt|;
name|who
operator|=
name|srv
condition|?
literal|"srv"
else|:
literal|"clt"
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"TLS: %s:inittls: ctx == NULL"
argument_list|,
name|who
argument_list|)
expr_stmt|;
comment|/* already initialized? (we could re-init...) */
if|if
condition|(
operator|*
name|ctx
operator|!=
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* PRNG seeded? */
if|if
condition|(
operator|!
name|tls_rand_init
argument_list|(
name|RandFile
argument_list|,
literal|10
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* let's start with the assumption it will work */
name|ok
operator|=
name|TRUE
expr_stmt|;
if|#
directive|if
name|_FFR_TLS_1
comment|/* 	**  look for a second filename: it must be separated by a ',' 	**  no blanks allowed (they won't be skipped). 	**  we change a global variable here! this change will be undone 	**  before return from the function but only if it returns TRUE. 	**  this isn't a problem since in a failure case this function 	**  won't be called again with the same (overwritten) values. 	**  otherwise each return must be replaced with a goto endinittls. 	*/
name|cf2
operator|=
name|NULL
expr_stmt|;
name|kf2
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|certfile
operator|!=
name|NULL
operator|&&
operator|(
name|cf2
operator|=
name|strchr
argument_list|(
name|certfile
argument_list|,
literal|','
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cf2
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|keyfile
operator|!=
name|NULL
operator|&&
operator|(
name|kf2
operator|=
name|strchr
argument_list|(
name|keyfile
argument_list|,
literal|','
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|kf2
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _FFR_TLS_1 */
comment|/* 	**  what do we require from the client? 	**  must it have CERTs? 	**  introduce an option and decide based on that 	*/
name|TLS_OK_F
argument_list|(
name|certfile
argument_list|,
literal|"CertFile"
argument_list|,
name|bitset
argument_list|(
name|TLS_I_CERT_EX
argument_list|,
name|req
argument_list|)
argument_list|,
name|TLS_S_CERT_EX
argument_list|)
expr_stmt|;
name|TLS_OK_F
argument_list|(
name|keyfile
argument_list|,
literal|"KeyFile"
argument_list|,
name|bitset
argument_list|(
name|TLS_I_KEY_EX
argument_list|,
name|req
argument_list|)
argument_list|,
name|TLS_S_KEY_EX
argument_list|)
expr_stmt|;
name|TLS_OK_F
argument_list|(
name|cacertpath
argument_list|,
literal|"CACERTPath"
argument_list|,
name|bitset
argument_list|(
name|TLS_I_CERTP_EX
argument_list|,
name|req
argument_list|)
argument_list|,
name|TLS_S_CERTP_EX
argument_list|)
expr_stmt|;
name|TLS_OK_F
argument_list|(
name|cacertfile
argument_list|,
literal|"CACERTFile"
argument_list|,
name|bitset
argument_list|(
name|TLS_I_CERTF_EX
argument_list|,
name|req
argument_list|)
argument_list|,
name|TLS_S_CERTF_EX
argument_list|)
expr_stmt|;
if|#
directive|if
name|_FFR_TLS_1
if|if
condition|(
name|cf2
operator|!=
name|NULL
condition|)
block|{
name|TLS_OK_F
argument_list|(
name|cf2
argument_list|,
literal|"CertFile"
argument_list|,
name|bitset
argument_list|(
name|TLS_I_CERT_EX
argument_list|,
name|req
argument_list|)
argument_list|,
name|TLS_S_CERT2_EX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kf2
operator|!=
name|NULL
condition|)
block|{
name|TLS_OK_F
argument_list|(
name|kf2
argument_list|,
literal|"KeyFile"
argument_list|,
name|bitset
argument_list|(
name|TLS_I_KEY_EX
argument_list|,
name|req
argument_list|)
argument_list|,
name|TLS_S_KEY2_EX
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _FFR_TLS_1 */
comment|/* 	**  valid values for dhparam are (only the first char is checked) 	**  none	no parameters: don't use DH 	**  512		generate 512 bit parameters (fixed) 	**  1024	generate 1024 bit parameters 	**  /file/name	read parameters from /file/name 	**  default is: 1024 for server, 512 for client (OK? XXX) 	*/
if|if
condition|(
name|bitset
argument_list|(
name|TLS_I_TRY_DH
argument_list|,
name|req
argument_list|)
condition|)
block|{
if|if
condition|(
name|dhparam
operator|!=
name|NULL
condition|)
block|{
name|char
name|c
init|=
operator|*
name|dhparam
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'1'
condition|)
name|req
operator||=
name|TLS_I_DH1024
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'5'
condition|)
name|req
operator||=
name|TLS_I_DH512
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'n'
operator|&&
name|c
operator|!=
literal|'N'
operator|&&
name|c
operator|!=
literal|'/'
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|12
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: error: illegal value '%s' for DHParam"
argument_list|,
name|dhparam
argument_list|)
expr_stmt|;
name|dhparam
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dhparam
operator|==
name|NULL
condition|)
name|dhparam
operator|=
name|srv
condition|?
literal|"1"
else|:
literal|"5"
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|dhparam
operator|==
literal|'/'
condition|)
block|{
name|TLS_OK_F
argument_list|(
name|dhparam
argument_list|,
literal|"DHParameters"
argument_list|,
name|bitset
argument_list|(
name|TLS_I_DHPAR_EX
argument_list|,
name|req
argument_list|)
argument_list|,
name|TLS_S_DHPAR_EX
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|ok
return|;
comment|/* certfile etc. must be "safe". */
name|sff
operator|=
name|SFF_REGONLY
operator||
name|SFF_SAFEDIRPATH
operator||
name|SFF_NOWLINK
operator||
name|SFF_NOGWFILES
operator||
name|SFF_NOWWFILES
operator||
name|SFF_MUSTOWN
operator||
name|SFF_ROOTOK
operator||
name|SFF_OPENASROOT
expr_stmt|;
if|if
condition|(
name|DontLockReadFiles
condition|)
name|sff
operator||=
name|SFF_NOLOCK
expr_stmt|;
name|TLS_SAFE_F
argument_list|(
name|certfile
argument_list|,
name|sff
operator||
name|TLS_UNR
argument_list|(
name|TLS_I_CERT_UNR
argument_list|,
name|req
argument_list|)
argument_list|,
name|bitset
argument_list|(
name|TLS_I_CERT_EX
argument_list|,
name|req
argument_list|)
argument_list|,
name|bitset
argument_list|(
name|TLS_S_CERT_EX
argument_list|,
name|status
argument_list|)
argument_list|,
name|TLS_S_CERT_OK
argument_list|)
expr_stmt|;
name|TLS_SAFE_F
argument_list|(
name|keyfile
argument_list|,
name|sff
operator||
name|TLS_UNR
argument_list|(
name|TLS_I_KEY_UNR
argument_list|,
name|req
argument_list|)
argument_list|,
name|bitset
argument_list|(
name|TLS_I_KEY_EX
argument_list|,
name|req
argument_list|)
argument_list|,
name|bitset
argument_list|(
name|TLS_S_KEY_EX
argument_list|,
name|status
argument_list|)
argument_list|,
name|TLS_S_KEY_OK
argument_list|)
expr_stmt|;
name|TLS_SAFE_F
argument_list|(
name|cacertfile
argument_list|,
name|sff
operator||
name|TLS_UNR
argument_list|(
name|TLS_I_CERTF_UNR
argument_list|,
name|req
argument_list|)
argument_list|,
name|bitset
argument_list|(
name|TLS_I_CERTF_EX
argument_list|,
name|req
argument_list|)
argument_list|,
name|bitset
argument_list|(
name|TLS_S_CERTF_EX
argument_list|,
name|status
argument_list|)
argument_list|,
name|TLS_S_CERTF_OK
argument_list|)
expr_stmt|;
name|TLS_SAFE_F
argument_list|(
name|dhparam
argument_list|,
name|sff
operator||
name|TLS_UNR
argument_list|(
name|TLS_I_DHPAR_UNR
argument_list|,
name|req
argument_list|)
argument_list|,
name|bitset
argument_list|(
name|TLS_I_DHPAR_EX
argument_list|,
name|req
argument_list|)
argument_list|,
name|bitset
argument_list|(
name|TLS_S_DHPAR_EX
argument_list|,
name|status
argument_list|)
argument_list|,
name|TLS_S_DHPAR_OK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|ok
return|;
if|#
directive|if
name|_FFR_TLS_1
if|if
condition|(
name|cf2
operator|!=
name|NULL
condition|)
block|{
name|TLS_SAFE_F
argument_list|(
name|cf2
argument_list|,
name|sff
operator||
name|TLS_UNR
argument_list|(
name|TLS_I_CERT_UNR
argument_list|,
name|req
argument_list|)
argument_list|,
name|bitset
argument_list|(
name|TLS_I_CERT_EX
argument_list|,
name|req
argument_list|)
argument_list|,
name|bitset
argument_list|(
name|TLS_S_CERT2_EX
argument_list|,
name|status
argument_list|)
argument_list|,
name|TLS_S_CERT2_OK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kf2
operator|!=
name|NULL
condition|)
block|{
name|TLS_SAFE_F
argument_list|(
name|kf2
argument_list|,
name|sff
operator||
name|TLS_UNR
argument_list|(
name|TLS_I_KEY_UNR
argument_list|,
name|req
argument_list|)
argument_list|,
name|bitset
argument_list|(
name|TLS_I_KEY_EX
argument_list|,
name|req
argument_list|)
argument_list|,
name|bitset
argument_list|(
name|TLS_S_KEY2_EX
argument_list|,
name|status
argument_list|)
argument_list|,
name|TLS_S_KEY2_OK
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _FFR_TLS_1 */
comment|/* create a method and a new context */
if|if
condition|(
name|srv
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|ctx
operator|=
name|SSL_CTX_new
argument_list|(
name|SSLv23_server_method
argument_list|()
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|7
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: error: SSL_CTX_new(SSLv23_server_method()) failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|tlslogerr
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|*
name|ctx
operator|=
name|SSL_CTX_new
argument_list|(
name|SSLv23_client_method
argument_list|()
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|7
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: error: SSL_CTX_new(SSLv23_client_method()) failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|tlslogerr
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|#
directive|if
name|TLS_NO_RSA
comment|/* turn off backward compatibility, required for no-rsa */
name|SSL_CTX_set_options
argument_list|(
operator|*
name|ctx
argument_list|,
name|SSL_OP_NO_SSLv2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TLS_NO_RSA */
if|#
directive|if
operator|!
name|TLS_NO_RSA
comment|/* 	**  Create a temporary RSA key 	**  XXX  Maybe we shouldn't create this always (even though it 	**  is only at startup). 	**  It is a time-consuming operation and it is not always necessary. 	**  maybe we should do it only on demand... 	*/
if|if
condition|(
name|bitset
argument_list|(
name|TLS_I_RSA_TMP
argument_list|,
name|req
argument_list|)
operator|&&
operator|(
name|rsa_tmp
operator|=
name|RSA_generate_key
argument_list|(
name|RSA_KEYLENGTH
argument_list|,
name|RSA_F4
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|7
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: error: %s: RSA_generate_key failed"
argument_list|,
name|who
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|tlslogerr
argument_list|()
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
endif|#
directive|endif
comment|/* !TLS_NO_RSA */
comment|/* 	**  load private key 	**  XXX change this for DSA-only version 	*/
if|if
condition|(
name|bitset
argument_list|(
name|TLS_S_KEY_OK
argument_list|,
name|status
argument_list|)
operator|&&
name|SSL_CTX_use_PrivateKey_file
argument_list|(
operator|*
name|ctx
argument_list|,
name|keyfile
argument_list|,
name|SSL_FILETYPE_PEM
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|7
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: error: %s: SSL_CTX_use_PrivateKey_file(%s) failed"
argument_list|,
name|who
argument_list|,
name|keyfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|tlslogerr
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|TLS_I_USE_KEY
argument_list|,
name|req
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* get the certificate file */
if|if
condition|(
name|bitset
argument_list|(
name|TLS_S_CERT_OK
argument_list|,
name|status
argument_list|)
operator|&&
name|SSL_CTX_use_certificate_file
argument_list|(
operator|*
name|ctx
argument_list|,
name|certfile
argument_list|,
name|SSL_FILETYPE_PEM
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|7
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: error: %s: SSL_CTX_use_certificate_file(%s) failed"
argument_list|,
name|who
argument_list|,
name|certfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|tlslogerr
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|TLS_I_USE_CERT
argument_list|,
name|req
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* check the private key */
if|if
condition|(
name|bitset
argument_list|(
name|TLS_S_KEY_OK
argument_list|,
name|status
argument_list|)
operator|&&
operator|(
name|r
operator|=
name|SSL_CTX_check_private_key
argument_list|(
operator|*
name|ctx
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
comment|/* Private key does not match the certificate public key */
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: error: %s: SSL_CTX_check_private_key failed(%s): %d"
argument_list|,
name|who
argument_list|,
name|keyfile
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|tlslogerr
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|TLS_I_USE_KEY
argument_list|,
name|req
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|#
directive|if
name|_FFR_TLS_1
comment|/* XXX this code is pretty much duplicated from above! */
comment|/* load private key */
if|if
condition|(
name|bitset
argument_list|(
name|TLS_S_KEY2_OK
argument_list|,
name|status
argument_list|)
operator|&&
name|SSL_CTX_use_PrivateKey_file
argument_list|(
operator|*
name|ctx
argument_list|,
name|kf2
argument_list|,
name|SSL_FILETYPE_PEM
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|7
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: error: %s: SSL_CTX_use_PrivateKey_file(%s) failed"
argument_list|,
name|who
argument_list|,
name|kf2
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|tlslogerr
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* get the certificate file */
if|if
condition|(
name|bitset
argument_list|(
name|TLS_S_CERT2_OK
argument_list|,
name|status
argument_list|)
operator|&&
name|SSL_CTX_use_certificate_file
argument_list|(
operator|*
name|ctx
argument_list|,
name|cf2
argument_list|,
name|SSL_FILETYPE_PEM
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|7
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: error: %s: SSL_CTX_use_certificate_file(%s) failed"
argument_list|,
name|who
argument_list|,
name|cf2
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|tlslogerr
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* we should also check the private key: */
if|if
condition|(
name|bitset
argument_list|(
name|TLS_S_KEY2_OK
argument_list|,
name|status
argument_list|)
operator|&&
operator|(
name|r
operator|=
name|SSL_CTX_check_private_key
argument_list|(
operator|*
name|ctx
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
comment|/* Private key does not match the certificate public key */
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: error: %s: SSL_CTX_check_private_key 2 failed: %d"
argument_list|,
name|who
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|tlslogerr
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* _FFR_TLS_1 */
comment|/* SSL_CTX_set_quiet_shutdown(*ctx, 1); violation of standard? */
name|SSL_CTX_set_options
argument_list|(
operator|*
name|ctx
argument_list|,
name|SSL_OP_ALL
argument_list|)
expr_stmt|;
comment|/* XXX bug compatibility? */
if|#
directive|if
operator|!
name|NO_DH
comment|/* Diffie-Hellman initialization */
if|if
condition|(
name|bitset
argument_list|(
name|TLS_I_TRY_DH
argument_list|,
name|req
argument_list|)
condition|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|TLS_S_DHPAR_OK
argument_list|,
name|status
argument_list|)
condition|)
block|{
name|BIO
modifier|*
name|bio
decl_stmt|;
if|if
condition|(
operator|(
name|bio
operator|=
name|BIO_new_file
argument_list|(
name|dhparam
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dh
operator|=
name|PEM_read_bio_DHparams
argument_list|(
name|bio
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|BIO_free
argument_list|(
name|bio
argument_list|)
expr_stmt|;
if|if
condition|(
name|dh
operator|==
name|NULL
operator|&&
name|LogLevel
operator|>
literal|7
condition|)
block|{
name|u_long
name|err
decl_stmt|;
name|err
operator|=
name|ERR_get_error
argument_list|()
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: error: %s: cannot read DH parameters(%s): %s"
argument_list|,
name|who
argument_list|,
name|dhparam
argument_list|,
name|ERR_error_string
argument_list|(
name|err
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|tlslogerr
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: error: %s: BIO_new_file(%s) failed"
argument_list|,
name|who
argument_list|,
name|dhparam
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|tlslogerr
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|dh
operator|==
name|NULL
operator|&&
name|bitset
argument_list|(
name|TLS_I_DH1024
argument_list|,
name|req
argument_list|)
condition|)
block|{
name|DSA
modifier|*
name|dsa
decl_stmt|;
comment|/* this takes a while! (7-130s on a 450MHz AMD K6-2) */
name|dsa
operator|=
name|DSA_generate_parameters
argument_list|(
literal|1024
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dh
operator|=
name|DSA_dup_DH
argument_list|(
name|dsa
argument_list|)
expr_stmt|;
name|DSA_free
argument_list|(
name|dsa
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dh
operator|==
name|NULL
operator|&&
name|bitset
argument_list|(
name|TLS_I_DH512
argument_list|,
name|req
argument_list|)
condition|)
name|dh
operator|=
name|get_dh512
argument_list|()
expr_stmt|;
if|if
condition|(
name|dh
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
block|{
name|u_long
name|err
decl_stmt|;
name|err
operator|=
name|ERR_get_error
argument_list|()
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: error: %s: cannot read or set DH parameters(%s): %s"
argument_list|,
name|who
argument_list|,
name|dhparam
argument_list|,
name|ERR_error_string
argument_list|(
name|err
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|TLS_I_REQ_DH
argument_list|,
name|req
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|SSL_CTX_set_tmp_dh
argument_list|(
operator|*
name|ctx
argument_list|,
name|dh
argument_list|)
expr_stmt|;
comment|/* important to avoid small subgroup attacks */
name|SSL_CTX_set_options
argument_list|(
operator|*
name|ctx
argument_list|,
name|SSL_OP_SINGLE_DH_USE
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|12
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: %s: Diffie-Hellman init, key=%d bit (%c)"
argument_list|,
name|who
argument_list|,
literal|8
operator|*
name|DH_size
argument_list|(
name|dh
argument_list|)
argument_list|,
operator|*
name|dhparam
argument_list|)
expr_stmt|;
name|DH_free
argument_list|(
name|dh
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* !NO_DH */
comment|/* XXX do we need this cache here? */
if|if
condition|(
name|bitset
argument_list|(
name|TLS_I_CACHE
argument_list|,
name|req
argument_list|)
condition|)
name|SSL_CTX_sess_set_cache_size
argument_list|(
operator|*
name|ctx
argument_list|,
literal|128
argument_list|)
expr_stmt|;
comment|/* timeout? SSL_CTX_set_timeout(*ctx, TimeOut...); */
comment|/* load certificate locations and default CA paths */
if|if
condition|(
name|bitset
argument_list|(
name|TLS_S_CERTP_EX
argument_list|,
name|status
argument_list|)
operator|&&
name|bitset
argument_list|(
name|TLS_S_CERTF_EX
argument_list|,
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|SSL_CTX_load_verify_locations
argument_list|(
operator|*
name|ctx
argument_list|,
name|cacertfile
argument_list|,
name|cacertpath
argument_list|)
operator|)
operator|==
literal|1
condition|)
block|{
if|#
directive|if
operator|!
name|TLS_NO_RSA
if|if
condition|(
name|bitset
argument_list|(
name|TLS_I_RSA_TMP
argument_list|,
name|req
argument_list|)
condition|)
name|SSL_CTX_set_tmp_rsa_callback
argument_list|(
operator|*
name|ctx
argument_list|,
name|tmp_rsa_key
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !TLS_NO_RSA */
comment|/* ask to verify the peer */
name|SSL_CTX_set_verify
argument_list|(
operator|*
name|ctx
argument_list|,
name|SSL_VERIFY_PEER
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* install verify callback */
name|SSL_CTX_set_cert_verify_callback
argument_list|(
operator|*
name|ctx
argument_list|,
name|tls_verify_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SSL_CTX_set_client_CA_list
argument_list|(
operator|*
name|ctx
argument_list|,
name|SSL_load_client_CA_file
argument_list|(
name|cacertfile
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			**  can't load CA data; do we care? 			**  the data is necessary to authenticate the client, 			**  which in turn would be necessary 			**  if we want to allow relaying based on it. 			*/
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: error: %s: %d load verify locs %s, %s"
argument_list|,
name|who
argument_list|,
name|r
argument_list|,
name|cacertpath
argument_list|,
name|cacertfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|tlslogerr
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|TLS_I_VRFY_LOC
argument_list|,
name|req
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
comment|/* XXX: make this dependent on an option? */
if|if
condition|(
name|tTd
argument_list|(
literal|96
argument_list|,
literal|9
argument_list|)
condition|)
name|SSL_CTX_set_info_callback
argument_list|(
operator|*
name|ctx
argument_list|,
name|apps_ssl_info_cb
argument_list|)
expr_stmt|;
if|#
directive|if
name|_FFR_TLS_1
comment|/* 	**  XXX install our own cipher list: option? 	*/
if|if
condition|(
name|CipherList
operator|!=
name|NULL
operator|&&
operator|*
name|CipherList
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|SSL_CTX_set_cipher_list
argument_list|(
operator|*
name|ctx
argument_list|,
name|CipherList
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|7
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: error: %s: SSL_CTX_set_cipher_list(%s) failed, list ignored"
argument_list|,
name|who
argument_list|,
name|CipherList
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|tlslogerr
argument_list|()
expr_stmt|;
block|}
comment|/* failure if setting to this list is required? */
block|}
block|}
endif|#
directive|endif
comment|/* _FFR_TLS_1 */
if|if
condition|(
name|LogLevel
operator|>
literal|12
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: init(%s)=%d"
argument_list|,
name|who
argument_list|,
name|ok
argument_list|)
expr_stmt|;
if|#
directive|if
name|_FFR_TLS_1
if|#
directive|if
literal|0
comment|/* 	**  this label is required if we want to have a "clean" exit 	**  see the comments above at the initialization of cf2 	*/
block|endinittls:
endif|#
directive|endif
comment|/* 0 */
comment|/* undo damage to global variables */
if|if
condition|(
name|cf2
operator|!=
name|NULL
condition|)
operator|*
operator|--
name|cf2
operator|=
literal|','
expr_stmt|;
if|if
condition|(
name|kf2
operator|!=
name|NULL
condition|)
operator|*
operator|--
name|kf2
operator|=
literal|','
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_TLS_1 */
return|return
name|ok
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  INITSRVTLS -- initialize server side TLS ** **	Parameters: **		none. ** **	Returns: **		succeeded? ** **	Side Effects: **		sets tls_ok_srv static, even when called from main() */
end_comment

begin_function
name|bool
name|initsrvtls
parameter_list|()
block|{
name|tls_ok_srv
operator|=
name|inittls
argument_list|(
operator|&
name|srv_ctx
argument_list|,
name|TLS_I_SRV
argument_list|,
name|TRUE
argument_list|,
name|SrvCERTfile
argument_list|,
name|Srvkeyfile
argument_list|,
name|CACERTpath
argument_list|,
name|CACERTfile
argument_list|,
name|DHParams
argument_list|)
expr_stmt|;
return|return
name|tls_ok_srv
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  TLS_GET_INFO -- get information about TLS connection ** **	Parameters: **		ssl -- SSL connection structure **		e -- current envelope **		srv -- server or client **		host -- hostname of other side **		log -- log connection information? ** **	Returns: **		result of authentication. ** **	Side Effects: **		sets ${cipher}, ${tls_version}, ${verify}, ${cipher_bits}, **		${cert} */
end_comment

begin_function
name|int
name|tls_get_info
parameter_list|(
name|ssl
parameter_list|,
name|e
parameter_list|,
name|srv
parameter_list|,
name|host
parameter_list|,
name|log
parameter_list|)
name|SSL
modifier|*
name|ssl
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|bool
name|srv
decl_stmt|;
name|char
modifier|*
name|host
decl_stmt|;
name|bool
name|log
decl_stmt|;
block|{
name|SSL_CIPHER
modifier|*
name|c
decl_stmt|;
name|int
name|b
decl_stmt|,
name|r
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|bitstr
index|[
literal|16
index|]
decl_stmt|;
name|X509
modifier|*
name|cert
decl_stmt|;
name|c
operator|=
name|SSL_get_current_cipher
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{cipher}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|SSL_CIPHER_get_name
argument_list|(
name|c
argument_list|)
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|b
operator|=
name|SSL_CIPHER_get_bits
argument_list|(
name|c
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|bitstr
argument_list|,
sizeof|sizeof
name|bitstr
argument_list|,
literal|"%d"
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{cipher_bits}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|bitstr
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|#
directive|if
name|_FFR_TLS_1
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|bitstr
argument_list|,
sizeof|sizeof
name|bitstr
argument_list|,
literal|"%d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{alg_bits}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|bitstr
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_TLS_1 */
name|s
operator|=
name|SSL_CIPHER_get_version
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|s
operator|=
literal|"UNKNOWN"
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{tls_version}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|s
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|cert
operator|=
name|SSL_get_peer_certificate
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
operator|&&
name|LogLevel
operator|>=
literal|14
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"TLS: get_verify in %s: %ld get_peer: 0x%lx"
argument_list|,
name|srv
condition|?
literal|"srv"
else|:
literal|"clt"
argument_list|,
name|SSL_get_verify_result
argument_list|(
name|ssl
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|cert
argument_list|)
expr_stmt|;
if|if
condition|(
name|cert
operator|!=
name|NULL
condition|)
block|{
name|char
name|buf
index|[
name|MAXNAME
index|]
decl_stmt|;
name|X509_NAME_oneline
argument_list|(
name|X509_get_subject_name
argument_list|(
name|cert
argument_list|)
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{cert_subject}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|xtextify
argument_list|(
name|buf
argument_list|,
literal|"<>\")"
argument_list|)
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|X509_NAME_oneline
argument_list|(
name|X509_get_issuer_name
argument_list|(
name|cert
argument_list|)
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{cert_issuer}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|xtextify
argument_list|(
name|buf
argument_list|,
literal|"<>\")"
argument_list|)
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|#
directive|if
name|_FFR_TLS_1
name|X509_NAME_get_text_by_NID
argument_list|(
name|X509_get_subject_name
argument_list|(
name|cert
argument_list|)
argument_list|,
name|NID_commonName
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{cn_subject}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|xtextify
argument_list|(
name|buf
argument_list|,
literal|"<>\")"
argument_list|)
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|X509_NAME_get_text_by_NID
argument_list|(
name|X509_get_issuer_name
argument_list|(
name|cert
argument_list|)
argument_list|,
name|NID_commonName
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{cn_issuer}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|xtextify
argument_list|(
name|buf
argument_list|,
literal|"<>\")"
argument_list|)
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_TLS_1 */
block|}
else|else
block|{
name|define
argument_list|(
name|macid
argument_list|(
literal|"{cert_subject}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|""
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{cert_issuer}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|""
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|#
directive|if
name|_FFR_TLS_1
name|define
argument_list|(
name|macid
argument_list|(
literal|"{cn_subject}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|""
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|define
argument_list|(
name|macid
argument_list|(
literal|"{cn_issuer}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|""
argument_list|,
name|e
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_TLS_1 */
block|}
switch|switch
condition|(
name|SSL_get_verify_result
argument_list|(
name|ssl
argument_list|)
condition|)
block|{
case|case
name|X509_V_OK
case|:
if|if
condition|(
name|cert
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
literal|"OK"
expr_stmt|;
name|r
operator|=
name|TLS_AUTH_OK
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
literal|"NO"
expr_stmt|;
name|r
operator|=
name|TLS_AUTH_NO
expr_stmt|;
block|}
break|break;
default|default:
name|s
operator|=
literal|"FAIL"
expr_stmt|;
name|r
operator|=
name|TLS_AUTH_FAIL
expr_stmt|;
break|break;
block|}
name|define
argument_list|(
name|macid
argument_list|(
literal|"{verify}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|s
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|cert
operator|!=
name|NULL
condition|)
name|X509_free
argument_list|(
name|cert
argument_list|)
expr_stmt|;
comment|/* do some logging */
if|if
condition|(
name|log
operator|&&
name|LogLevel
operator|>
literal|9
condition|)
block|{
name|char
modifier|*
name|vers
decl_stmt|,
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|,
modifier|*
name|bits
decl_stmt|;
name|vers
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{tls_version}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|bits
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{cipher_bits}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|s1
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{verify}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|s2
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{cipher}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: connection %s %.64s, version=%.16s, verify=%.16s, cipher=%.64s, bits=%.6s"
argument_list|,
name|srv
condition|?
literal|"from"
else|:
literal|"to"
argument_list|,
name|host
operator|==
name|NULL
condition|?
literal|"none"
else|:
name|host
argument_list|,
name|vers
operator|==
name|NULL
condition|?
literal|"none"
else|:
name|vers
argument_list|,
name|s1
operator|==
name|NULL
condition|?
literal|"none"
else|:
name|s1
argument_list|,
name|s2
operator|==
name|NULL
condition|?
literal|"none"
else|:
name|s2
argument_list|,
name|bits
operator|==
name|NULL
condition|?
literal|"0"
else|:
name|bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|11
condition|)
block|{
comment|/* 			**  maybe run xuntextify on the strings? 			**  that is easier to read but makes it maybe a bit 			**  more complicated to figure out the right values 			**  for the access map... 			*/
name|s1
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{cert_subject}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|s2
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{cert_issuer}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: %s cert subject:%.128s, cert issuer=%.128s"
argument_list|,
name|srv
condition|?
literal|"client"
else|:
literal|"server"
argument_list|,
name|s1
operator|==
name|NULL
condition|?
literal|"none"
else|:
name|s1
argument_list|,
name|s2
operator|==
name|NULL
condition|?
literal|"none"
else|:
name|s2
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|r
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|TLS_NO_RSA
end_if

begin_escape
end_escape

begin_comment
comment|/* **  TMP_RSA_KEY -- return temporary RSA key ** **	Parameters: **		s -- SSL connection structure **		export -- **		keylength -- ** **	Returns: **		temporary RSA key. */
end_comment

begin_comment
comment|/* ARGUSED0 */
end_comment

begin_function
specifier|static
name|RSA
modifier|*
name|tmp_rsa_key
parameter_list|(
name|s
parameter_list|,
name|export
parameter_list|,
name|keylength
parameter_list|)
name|SSL
modifier|*
name|s
decl_stmt|;
name|int
name|export
decl_stmt|;
name|int
name|keylength
decl_stmt|;
block|{
return|return
name|rsa_tmp
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !TLS_NO_RSA */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **  APPS_SSL_INFO_CB -- info callback for TLS connections ** **	Parameters: **		s -- SSL connection structure **		where -- **		ret -- ** **	Returns: **		none. */
end_comment

begin_function
name|void
name|apps_ssl_info_cb
parameter_list|(
name|s
parameter_list|,
name|where
parameter_list|,
name|ret
parameter_list|)
name|SSL
modifier|*
name|s
decl_stmt|;
name|int
name|where
decl_stmt|;
name|int
name|ret
decl_stmt|;
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|w
decl_stmt|;
name|BIO
modifier|*
name|bio_err
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|14
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"info_callback where 0x%x ret %d"
argument_list|,
name|where
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|w
operator|=
name|where
operator|&
operator|~
name|SSL_ST_MASK
expr_stmt|;
if|if
condition|(
name|bio_err
operator|==
name|NULL
condition|)
name|bio_err
operator|=
name|BIO_new_fp
argument_list|(
name|stderr
argument_list|,
name|BIO_NOCLOSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|&
name|SSL_ST_CONNECT
condition|)
name|str
operator|=
literal|"SSL_connect"
expr_stmt|;
elseif|else
if|if
condition|(
name|w
operator|&
name|SSL_ST_ACCEPT
condition|)
name|str
operator|=
literal|"SSL_accept"
expr_stmt|;
else|else
name|str
operator|=
literal|"undefined"
expr_stmt|;
if|if
condition|(
name|where
operator|&
name|SSL_CB_LOOP
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|12
condition|)
name|sm_syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
name|NOQID
argument_list|,
literal|"%s:%s\n"
argument_list|,
name|str
argument_list|,
name|SSL_state_string_long
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|where
operator|&
name|SSL_CB_ALERT
condition|)
block|{
name|str
operator|=
operator|(
name|where
operator|&
name|SSL_CB_READ
operator|)
condition|?
literal|"read"
else|:
literal|"write"
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|12
condition|)
name|sm_syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
name|NOQID
argument_list|,
literal|"SSL3 alert %s:%s:%s\n"
argument_list|,
name|str
argument_list|,
name|SSL_alert_type_string_long
argument_list|(
name|ret
argument_list|)
argument_list|,
name|SSL_alert_desc_string_long
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|where
operator|&
name|SSL_CB_EXIT
condition|)
block|{
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|7
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"%s:failed in %s\n"
argument_list|,
name|str
argument_list|,
name|SSL_state_string_long
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|7
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"%s:error in %s\n"
argument_list|,
name|str
argument_list|,
name|SSL_state_string_long
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  TLS_VERIFY_LOG -- log verify error for TLS certificates ** **	Parameters: **		ok -- verify ok? **		ctx -- x509 context ** **	Returns: **		0 -- fatal error **		1 -- ok */
end_comment

begin_function
specifier|static
name|int
name|tls_verify_log
parameter_list|(
name|ok
parameter_list|,
name|ctx
parameter_list|)
name|int
name|ok
decl_stmt|;
name|X509_STORE_CTX
modifier|*
name|ctx
decl_stmt|;
block|{
name|SSL
modifier|*
name|ssl
decl_stmt|;
name|X509
modifier|*
name|cert
decl_stmt|;
name|int
name|reason
decl_stmt|,
name|depth
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
name|cert
operator|=
name|X509_STORE_CTX_get_current_cert
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|reason
operator|=
name|X509_STORE_CTX_get_error
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|depth
operator|=
name|X509_STORE_CTX_get_error_depth
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|ssl
operator|=
operator|(
name|SSL
operator|*
operator|)
name|X509_STORE_CTX_get_ex_data
argument_list|(
name|ctx
argument_list|,
name|SSL_get_ex_data_X509_STORE_CTX_idx
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssl
operator|==
name|NULL
condition|)
block|{
comment|/* internal error */
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: internal error: tls_verify_cb: ssl == NULL"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|X509_NAME_oneline
argument_list|(
name|X509_get_subject_name
argument_list|(
name|cert
argument_list|)
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"TLS cert verify: depth=%d %s, state=%d, reason=%s\n"
argument_list|,
name|depth
argument_list|,
name|buf
argument_list|,
name|ok
argument_list|,
name|X509_verify_cert_error_string
argument_list|(
name|reason
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  TLS_VERIFY_CB -- verify callback for TLS certificates ** **	Parameters: **		ctx -- x509 context ** **	Returns: **		accept connection? **		currently: always yes. */
end_comment

begin_function
specifier|static
name|int
name|tls_verify_cb
parameter_list|(
name|ctx
parameter_list|)
name|X509_STORE_CTX
modifier|*
name|ctx
decl_stmt|;
block|{
name|int
name|ok
decl_stmt|;
name|ok
operator|=
name|X509_verify_cert
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|13
condition|)
return|return
name|tls_verify_log
argument_list|(
name|ok
argument_list|,
name|ctx
argument_list|)
return|;
return|return
literal|1
return|;
comment|/* override it */
block|}
return|return
name|ok
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  TLSLOGERR -- log the errors from the TLS error stack ** **	Parameters: **		none. ** **	Returns: **		none. */
end_comment

begin_function
name|void
name|tlslogerr
parameter_list|()
block|{
name|unsigned
name|long
name|l
decl_stmt|;
name|int
name|line
decl_stmt|,
name|flags
decl_stmt|;
name|unsigned
name|long
name|es
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|,
modifier|*
name|data
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
define|#
directive|define
name|CP
value|(const char **)
name|es
operator|=
name|CRYPTO_thread_id
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|l
operator|=
name|ERR_get_error_line_data
argument_list|(
name|CP
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|,
name|CP
operator|&
name|data
argument_list|,
operator|&
name|flags
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"TLS: %lu:%s:%s:%d:%s\n"
argument_list|,
name|es
argument_list|,
name|ERR_error_string
argument_list|(
name|l
argument_list|,
name|buf
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
operator|(
name|flags
operator|&
name|ERR_TXT_STRING
operator|)
condition|?
name|data
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STARTTLS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SMTP */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **  HELP -- implement the HELP command. ** **	Parameters: **		topic -- the topic we want help for. **		e -- envelope ** **	Returns: **		none. ** **	Side Effects: **		outputs the help file to message output. */
end_comment

begin_define
define|#
directive|define
name|HELPVSTR
value|"#vers	"
end_define

begin_define
define|#
directive|define
name|HELPVERSION
value|2
end_define

begin_function
name|void
name|help
parameter_list|(
name|topic
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|topic
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|hf
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
name|bool
name|noinfo
decl_stmt|;
name|bool
name|first
init|=
name|TRUE
decl_stmt|;
name|long
name|sff
init|=
name|SFF_OPENASROOT
operator||
name|SFF_REGONLY
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|char
name|inp
index|[
name|MAXLINE
index|]
decl_stmt|;
specifier|static
name|int
name|foundvers
init|=
operator|-
literal|1
decl_stmt|;
specifier|extern
name|char
name|Version
index|[]
decl_stmt|;
if|if
condition|(
name|DontLockReadFiles
condition|)
name|sff
operator||=
name|SFF_NOLOCK
expr_stmt|;
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|DBS_HELPFILEINUNSAFEDIRPATH
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
name|sff
operator||=
name|SFF_SAFEDIRPATH
expr_stmt|;
if|if
condition|(
name|HelpFile
operator|==
name|NULL
operator|||
operator|(
name|hf
operator|=
name|safefopen
argument_list|(
name|HelpFile
argument_list|,
name|O_RDONLY
argument_list|,
literal|0444
argument_list|,
name|sff
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* no help */
name|errno
operator|=
literal|0
expr_stmt|;
name|message
argument_list|(
literal|"502 5.3.0 Sendmail %s -- HELP not implemented"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|topic
operator|==
name|NULL
operator|||
operator|*
name|topic
operator|==
literal|'\0'
condition|)
block|{
name|topic
operator|=
literal|"smtp"
expr_stmt|;
name|noinfo
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|makelower
argument_list|(
name|topic
argument_list|)
expr_stmt|;
name|noinfo
operator|=
name|TRUE
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|topic
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|hf
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
if|if
condition|(
name|foundvers
operator|<
literal|0
operator|&&
name|strncmp
argument_list|(
name|buf
argument_list|,
name|HELPVSTR
argument_list|,
name|strlen
argument_list|(
name|HELPVSTR
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|h
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|HELPVSTR
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|h
argument_list|)
operator|==
literal|1
condition|)
name|foundvers
operator|=
name|h
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
name|topic
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
name|FALSE
expr_stmt|;
comment|/* print version if no/old vers# in file */
if|if
condition|(
name|foundvers
operator|<
literal|2
operator|&&
operator|!
name|noinfo
condition|)
name|message
argument_list|(
literal|"214-2.0.0 This is Sendmail version %s"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|strpbrk
argument_list|(
name|buf
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
name|fixcrlf
argument_list|(
name|p
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundvers
operator|>=
literal|2
condition|)
block|{
name|translate_dollars
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|expand
argument_list|(
name|p
argument_list|,
name|inp
argument_list|,
sizeof|sizeof
name|inp
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|p
operator|=
name|inp
expr_stmt|;
block|}
name|message
argument_list|(
literal|"214-2.0.0 %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|noinfo
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|noinfo
condition|)
name|message
argument_list|(
literal|"504 5.3.0 HELP topic \"%.10s\" unknown"
argument_list|,
name|topic
argument_list|)
expr_stmt|;
else|else
name|message
argument_list|(
literal|"214 2.0.0 End of HELP info"
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundvers
operator|!=
literal|0
operator|&&
name|foundvers
operator|<
name|HELPVERSION
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|1
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%s too old (require version %d)"
argument_list|,
name|HelpFile
argument_list|,
name|HELPVERSION
argument_list|)
expr_stmt|;
comment|/* avoid log next time */
name|foundvers
operator|=
literal|0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|hf
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

