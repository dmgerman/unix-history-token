begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998-2003 Sendmail, Inc. and its suppliers.  *	All rights reserved.  * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_include
include|#
directive|include
file|<sendmail.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: parseaddr.c,v 8.359.2.9 2003/09/16 18:07:50 ca Exp $"
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|void
name|allocaddr
name|__P
argument_list|(
operator|(
name|ADDRESS
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|callsubr
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|map_lookup
name|__P
argument_list|(
operator|(
name|STAB
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|*
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ADDRESS
modifier|*
name|buildaddr
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|ADDRESS
operator|*
operator|,
name|int
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|hasctrlchar
name|__P
argument_list|(
operator|(
specifier|register
name|char
operator|*
operator|,
name|bool
operator|,
name|bool
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* replacement for illegal characters in addresses */
end_comment

begin_define
define|#
directive|define
name|BAD_CHAR_REPLACEMENT
value|'?'
end_define

begin_comment
comment|/* **  PARSEADDR -- Parse an address ** **	Parses an address and breaks it up into three parts: a **	net to transmit the message on, the host to transmit it **	to, and a user on that host.  These are loaded into an **	ADDRESS header with the values squirreled away if necessary. **	The "user" part may not be a real user; the process may **	just reoccur on that machine.  For example, on a machine **	with an arpanet connection, the address **		csvax.bill@berkeley **	will break up to a "user" of 'csvax.bill' and a host **	of 'berkeley' -- to be transmitted over the arpanet. ** **	Parameters: **		addr -- the address to parse. **		a -- a pointer to the address descriptor buffer. **			If NULL, an address will be created. **		flags -- describe detail for parsing.  See RF_ definitions **			in sendmail.h. **		delim -- the character to terminate the address, passed **			to prescan. **		delimptr -- if non-NULL, set to the location of the **			delim character that was found. **		e -- the envelope that will contain this address. **		isrcpt -- true if the address denotes a recipient; false **			indicates a sender. ** **	Returns: **		A pointer to the address descriptor header (`a' if **			`a' is non-NULL). **		NULL on error. ** **	Side Effects: **		e->e_to = addr */
end_comment

begin_comment
comment|/* following delimiters are inherent to the internal algorithms */
end_comment

begin_define
define|#
directive|define
name|DELIMCHARS
value|"()<>,;\r\n"
end_define

begin_comment
comment|/* default word delimiters */
end_comment

begin_function
name|ADDRESS
modifier|*
name|parseaddr
parameter_list|(
name|addr
parameter_list|,
name|a
parameter_list|,
name|flags
parameter_list|,
name|delim
parameter_list|,
name|delimptr
parameter_list|,
name|e
parameter_list|,
name|isrcpt
parameter_list|)
name|char
modifier|*
name|addr
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|delim
decl_stmt|;
name|char
modifier|*
modifier|*
name|delimptr
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|bool
name|isrcpt
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
specifier|auto
name|char
modifier|*
name|delimptrbuf
decl_stmt|;
name|bool
name|qup
decl_stmt|;
name|char
name|pvpbuf
index|[
name|PSBUFSIZE
index|]
decl_stmt|;
comment|/* 	**  Initialize and prescan address. 	*/
name|e
operator|->
name|e_to
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|20
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"\n--parseaddr(%s)\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|delimptr
operator|==
name|NULL
condition|)
name|delimptr
operator|=
operator|&
name|delimptrbuf
expr_stmt|;
name|pvp
operator|=
name|prescan
argument_list|(
name|addr
argument_list|,
name|delim
argument_list|,
name|pvpbuf
argument_list|,
sizeof|sizeof
name|pvpbuf
argument_list|,
name|delimptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|20
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"parseaddr-->NULL\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|invalidaddr
argument_list|(
name|addr
argument_list|,
name|delim
operator|==
literal|'\0'
condition|?
name|NULL
else|:
operator|*
name|delimptr
argument_list|,
name|isrcpt
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|20
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"parseaddr-->bad address\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 	**  Save addr if we are going to have to. 	** 	**	We have to do this early because there is a chance that 	**	the map lookups in the rewriting rules could clobber 	**	static memory somewhere. 	*/
if|if
condition|(
name|bitset
argument_list|(
name|RF_COPYPADDR
argument_list|,
name|flags
argument_list|)
operator|&&
name|addr
operator|!=
name|NULL
condition|)
block|{
name|char
name|savec
init|=
operator|*
operator|*
name|delimptr
decl_stmt|;
if|if
condition|(
name|savec
operator|!=
literal|'\0'
condition|)
operator|*
operator|*
name|delimptr
operator|=
literal|'\0'
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|addr
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|savec
operator|!=
literal|'\0'
condition|)
operator|*
operator|*
name|delimptr
operator|=
name|savec
expr_stmt|;
block|}
comment|/* 	**  Apply rewriting rules. 	**	Ruleset 0 does basic parsing.  It must resolve. 	*/
name|qup
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|REWRITE
argument_list|(
name|pvp
argument_list|,
literal|3
argument_list|,
name|e
argument_list|)
operator|==
name|EX_TEMPFAIL
condition|)
name|qup
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|REWRITE
argument_list|(
name|pvp
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
operator|==
name|EX_TEMPFAIL
condition|)
name|qup
operator|=
name|true
expr_stmt|;
comment|/* 	**  Build canonical address from pvp. 	*/
name|a
operator|=
name|buildaddr
argument_list|(
name|pvp
argument_list|,
name|a
argument_list|,
name|flags
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasctrlchar
argument_list|(
name|a
operator|->
name|q_user
argument_list|,
name|isrcpt
argument_list|,
name|true
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|20
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"parseaddr-->bad q_user\n"
argument_list|)
expr_stmt|;
comment|/* 		**  Just mark the address as bad so DSNs work. 		**  hasctrlchar() has to make sure that the address 		**  has been sanitized, e.g., shortened. 		*/
name|a
operator|->
name|q_state
operator|=
name|QS_BADADDR
expr_stmt|;
block|}
comment|/* 	**  Make local copies of the host& user and then 	**  transport them out. 	*/
name|allocaddr
argument_list|(
name|a
argument_list|,
name|flags
argument_list|,
name|addr
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|QS_IS_BADADDR
argument_list|(
name|a
operator|->
name|q_state
argument_list|)
condition|)
block|{
comment|/* weed out bad characters in the printable address too */
operator|(
name|void
operator|)
name|hasctrlchar
argument_list|(
name|a
operator|->
name|q_paddr
argument_list|,
name|isrcpt
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
comment|/* 	**  Select a queue directory for recipient addresses. 	**	This is done here and in split_across_queue_groups(), 	**	but the latter applies to addresses after aliasing, 	**	and only if splitting is done. 	*/
if|if
condition|(
operator|(
name|a
operator|->
name|q_qgrp
operator|==
name|NOAQGRP
operator|||
name|a
operator|->
name|q_qgrp
operator|==
name|ENVQGRP
operator|)
operator|&&
operator|!
name|bitset
argument_list|(
name|RF_SENDERADDR
operator||
name|RF_HEADERADDR
argument_list|,
name|flags
argument_list|)
operator|&&
name|OpMode
operator|!=
name|MD_INITALIAS
condition|)
block|{
name|int
name|r
decl_stmt|;
comment|/* call ruleset which should return a queue group name */
name|r
operator|=
name|rscap
argument_list|(
name|RS_QUEUEGROUP
argument_list|,
name|a
operator|->
name|q_user
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
operator|&
name|pvp
argument_list|,
name|pvpbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pvpbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|EX_OK
operator|&&
name|pvp
operator|!=
name|NULL
operator|&&
name|pvp
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
operator|(
name|pvp
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|&
literal|0377
operator|)
operator|==
name|CANONNET
operator|&&
name|pvp
index|[
literal|1
index|]
operator|!=
name|NULL
operator|&&
name|pvp
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|r
operator|=
name|name2qid
argument_list|(
name|pvp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NOQGRP
operator|&&
name|LogLevel
operator|>
literal|10
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"can't find queue group name %s, selection ignored"
argument_list|,
name|pvp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|20
argument_list|,
literal|4
argument_list|)
operator|&&
name|r
operator|!=
name|NOQGRP
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"queue group name %s -> %d"
argument_list|,
name|pvp
index|[
literal|1
index|]
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_qgrp
operator|=
name|r
operator|==
name|NOQGRP
condition|?
name|ENVQGRP
else|:
name|r
expr_stmt|;
block|}
block|}
comment|/* 	**  If there was a parsing failure, mark it for queueing. 	*/
if|if
condition|(
name|qup
operator|&&
name|OpMode
operator|!=
name|MD_INITALIAS
condition|)
block|{
name|char
modifier|*
name|msg
init|=
literal|"Transient parse error -- message queued for future delivery"
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|e_sendmode
operator|==
name|SM_DEFER
condition|)
name|msg
operator|=
literal|"Deferring message until queue run"
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|20
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"parseaddr: queuing message\n"
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_message
operator|==
name|NULL
operator|&&
name|e
operator|->
name|e_sendmode
operator|!=
name|SM_DEFER
condition|)
name|e
operator|->
name|e_message
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_state
operator|=
name|QS_QUEUEUP
expr_stmt|;
name|a
operator|->
name|q_status
operator|=
literal|"4.4.3"
expr_stmt|;
block|}
comment|/* 	**  Compute return value. 	*/
if|if
condition|(
name|tTd
argument_list|(
literal|20
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"parseaddr-->"
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|a
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
return|return
name|a
return|;
block|}
end_function

begin_comment
comment|/* **  INVALIDADDR -- check for address containing characters used for macros ** **	Parameters: **		addr -- the address to check. **		delimptr -- if non-NULL: end of address to check, i.e., **			a pointer in the address string. **		isrcpt -- true iff the address is for a recipient. ** **	Returns: **		true -- if the address has characters that are reservered **			for macros or is too long. **		false -- otherwise. */
end_comment

begin_function
name|bool
name|invalidaddr
parameter_list|(
name|addr
parameter_list|,
name|delimptr
parameter_list|,
name|isrcpt
parameter_list|)
specifier|register
name|char
modifier|*
name|addr
decl_stmt|;
name|char
modifier|*
name|delimptr
decl_stmt|;
name|bool
name|isrcpt
decl_stmt|;
block|{
name|bool
name|result
init|=
name|false
decl_stmt|;
name|char
name|savedelim
init|=
literal|'\0'
decl_stmt|;
name|char
modifier|*
name|b
init|=
name|addr
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|delimptr
operator|!=
name|NULL
condition|)
block|{
comment|/* delimptr points to the end of the address to test */
name|savedelim
operator|=
operator|*
name|delimptr
expr_stmt|;
if|if
condition|(
name|savedelim
operator|!=
literal|'\0'
condition|)
comment|/* if that isn't '\0' already: */
operator|*
name|delimptr
operator|=
literal|'\0'
expr_stmt|;
comment|/* set it */
block|}
for|for
control|(
init|;
operator|*
name|addr
operator|!=
literal|'\0'
condition|;
name|addr
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|addr
operator|&
literal|0340
operator|)
operator|==
literal|0200
condition|)
block|{
name|setstat
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
name|result
operator|=
name|true
expr_stmt|;
operator|*
name|addr
operator|=
name|BAD_CHAR_REPLACEMENT
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|len
operator|>
name|MAXNAME
operator|-
literal|1
condition|)
block|{
name|char
name|saved
init|=
operator|*
name|addr
decl_stmt|;
operator|*
name|addr
operator|=
literal|'\0'
expr_stmt|;
name|usrerr
argument_list|(
literal|"553 5.1.0 Address \"%s\" too long (%d bytes max)"
argument_list|,
name|b
argument_list|,
name|MAXNAME
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|addr
operator|=
name|saved
expr_stmt|;
name|result
operator|=
name|true
expr_stmt|;
goto|goto
name|delim
goto|;
block|}
block|}
if|if
condition|(
name|result
condition|)
block|{
if|if
condition|(
name|isrcpt
condition|)
name|usrerr
argument_list|(
literal|"501 5.1.3 8-bit character in mailbox address \"%s\""
argument_list|,
name|b
argument_list|)
expr_stmt|;
else|else
name|usrerr
argument_list|(
literal|"501 5.1.7 8-bit character in mailbox address \"%s\""
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
name|delim
label|:
if|if
condition|(
name|delimptr
operator|!=
name|NULL
operator|&&
name|savedelim
operator|!=
literal|'\0'
condition|)
operator|*
name|delimptr
operator|=
name|savedelim
expr_stmt|;
comment|/* restore old character at delimptr */
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* **  HASCTRLCHAR -- check for address containing meta-characters ** **  Checks that the address contains no meta-characters, and contains **  no "non-printable" characters unless they are quoted or escaped. **  Quoted or escaped characters are literals. ** **	Parameters: **		addr -- the address to check. **		isrcpt -- true if the address is for a recipient; false **			indicates a from. **		complain -- true if an error should issued if the address **			is invalid and should be "repaired". ** **	Returns: **		true -- if the address has any "wierd" characters or **			non-printable characters or if a quote is unbalanced. **		false -- otherwise. */
end_comment

begin_function
specifier|static
name|bool
name|hasctrlchar
parameter_list|(
name|addr
parameter_list|,
name|isrcpt
parameter_list|,
name|complain
parameter_list|)
specifier|register
name|char
modifier|*
name|addr
decl_stmt|;
name|bool
name|isrcpt
decl_stmt|,
name|complain
decl_stmt|;
block|{
name|bool
name|quoted
init|=
name|false
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|b
init|=
name|addr
decl_stmt|;
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
return|return
name|false
return|;
for|for
control|(
init|;
operator|*
name|addr
operator|!=
literal|'\0'
condition|;
name|addr
operator|++
control|)
block|{
if|if
condition|(
operator|++
name|len
operator|>
name|MAXNAME
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|complain
condition|)
block|{
operator|(
name|void
operator|)
name|shorten_rfc822_string
argument_list|(
name|b
argument_list|,
name|MAXNAME
operator|-
literal|1
argument_list|)
expr_stmt|;
name|usrerr
argument_list|(
literal|"553 5.1.0 Address \"%s\" too long (%d bytes max)"
argument_list|,
name|b
argument_list|,
name|MAXNAME
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|result
operator|=
literal|"too long"
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|quoted
operator|&&
operator|(
operator|*
name|addr
operator|<
literal|32
operator|||
operator|*
name|addr
operator|==
literal|127
operator|)
condition|)
block|{
name|result
operator|=
literal|"non-printable character"
expr_stmt|;
operator|*
name|addr
operator|=
name|BAD_CHAR_REPLACEMENT
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|addr
operator|==
literal|'"'
condition|)
name|quoted
operator|=
operator|!
name|quoted
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|addr
operator|==
literal|'\\'
condition|)
block|{
comment|/* XXX Generic problem: no '\0' in strings. */
if|if
condition|(
operator|*
operator|++
name|addr
operator|==
literal|'\0'
condition|)
block|{
name|result
operator|=
literal|"trailing \\ character"
expr_stmt|;
operator|*
operator|--
name|addr
operator|=
name|BAD_CHAR_REPLACEMENT
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
operator|*
name|addr
operator|&
literal|0340
operator|)
operator|==
literal|0200
condition|)
block|{
name|setstat
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
name|result
operator|=
literal|"8-bit character"
expr_stmt|;
operator|*
name|addr
operator|=
name|BAD_CHAR_REPLACEMENT
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|quoted
condition|)
name|result
operator|=
literal|"unbalanced quote"
expr_stmt|;
comment|/* unbalanced quote */
if|if
condition|(
name|result
operator|!=
name|NULL
operator|&&
name|complain
condition|)
block|{
if|if
condition|(
name|isrcpt
condition|)
name|usrerr
argument_list|(
literal|"501 5.1.3 Syntax error in mailbox address \"%s\" (%s)"
argument_list|,
name|b
argument_list|,
name|result
argument_list|)
expr_stmt|;
else|else
name|usrerr
argument_list|(
literal|"501 5.1.7 Syntax error in mailbox address \"%s\" (%s)"
argument_list|,
name|b
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
return|return
name|result
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  ALLOCADDR -- do local allocations of address on demand. ** **	Also lowercases the host name if requested. ** **	Parameters: **		a -- the address to reallocate. **		flags -- the copy flag (see RF_ definitions in sendmail.h **			for a description). **		paddr -- the printname of the address. **		e -- envelope ** **	Returns: **		none. ** **	Side Effects: **		Copies portions of a into local buffers as requested. */
end_comment

begin_function
specifier|static
name|void
name|allocaddr
parameter_list|(
name|a
parameter_list|,
name|flags
parameter_list|,
name|paddr
parameter_list|,
name|e
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|char
modifier|*
name|paddr
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|24
argument_list|,
literal|4
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"allocaddr(flags=%x, paddr=%s)\n"
argument_list|,
name|flags
argument_list|,
name|paddr
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_paddr
operator|=
name|paddr
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|q_user
operator|==
name|NULL
condition|)
name|a
operator|->
name|q_user
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|q_host
operator|==
name|NULL
condition|)
name|a
operator|->
name|q_host
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RF_COPYPARSE
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|a
operator|->
name|q_host
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|a
operator|->
name|q_host
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|q_user
operator|!=
name|a
operator|->
name|q_paddr
condition|)
name|a
operator|->
name|q_user
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|->
name|q_paddr
operator|==
name|NULL
condition|)
name|a
operator|->
name|q_paddr
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_qgrp
operator|=
name|NOAQGRP
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  PRESCAN -- Prescan name and make it canonical ** **	Scans a name and turns it into a set of tokens.  This process **	deletes blanks and comments (in parentheses) (if the token type **	for left paren is SPC). ** **	This routine knows about quoted strings and angle brackets. ** **	There are certain subtleties to this routine.  The one that **	comes to mind now is that backslashes on the ends of names **	are silently stripped off; this is intentional.  The problem **	is that some versions of sndmsg (like at LBL) set the kill **	character to something other than @ when reading addresses; **	so people type "csvax.eric\@berkeley" -- which screws up the **	berknet mailer. ** **	Parameters: **		addr -- the name to chomp. **		delim -- the delimiter for the address, normally **			'\0' or ','; \0 is accepted in any case. **			If '\t' then we are reading the .cf file. **		pvpbuf -- place to put the saved text -- note that **			the pointers are static. **		pvpbsize -- size of pvpbuf. **		delimptr -- if non-NULL, set to the location of the **			terminating delimiter. **		toktab -- if set, a token table to use for parsing. **			If NULL, use the default table. ** **	Returns: **		A pointer to a vector of tokens. **		NULL on error. */
end_comment

begin_comment
comment|/* states and character types */
end_comment

begin_define
define|#
directive|define
name|OPR
value|0
end_define

begin_comment
comment|/* operator */
end_comment

begin_define
define|#
directive|define
name|ATM
value|1
end_define

begin_comment
comment|/* atom */
end_comment

begin_define
define|#
directive|define
name|QST
value|2
end_define

begin_comment
comment|/* in quoted string */
end_comment

begin_define
define|#
directive|define
name|SPC
value|3
end_define

begin_comment
comment|/* chewing up spaces */
end_comment

begin_define
define|#
directive|define
name|ONE
value|4
end_define

begin_comment
comment|/* pick up one character */
end_comment

begin_define
define|#
directive|define
name|ILL
value|5
end_define

begin_comment
comment|/* illegal character */
end_comment

begin_define
define|#
directive|define
name|NSTATES
value|6
end_define

begin_comment
comment|/* number of states */
end_comment

begin_define
define|#
directive|define
name|TYPE
value|017
end_define

begin_comment
comment|/* mask to select state type */
end_comment

begin_comment
comment|/* meta bits for table */
end_comment

begin_define
define|#
directive|define
name|M
value|020
end_define

begin_comment
comment|/* meta character; don't pass through */
end_comment

begin_define
define|#
directive|define
name|B
value|040
end_define

begin_comment
comment|/* cause a break */
end_comment

begin_define
define|#
directive|define
name|MB
value|M|B
end_define

begin_comment
comment|/* meta-break */
end_comment

begin_decl_stmt
specifier|static
name|short
name|StateTab
index|[
name|NSTATES
index|]
index|[
name|NSTATES
index|]
init|=
block|{
comment|/*	oldst	chtype>	OPR	ATM	QST	SPC	ONE	ILL	*/
comment|/*OPR*/
block|{
name|OPR
operator||
name|B
block|,
name|ATM
operator||
name|B
block|,
name|QST
operator||
name|B
block|,
name|SPC
operator||
name|MB
block|,
name|ONE
operator||
name|B
block|,
name|ILL
operator||
name|MB
block|}
block|,
comment|/*ATM*/
block|{
name|OPR
operator||
name|B
block|,
name|ATM
block|,
name|QST
operator||
name|B
block|,
name|SPC
operator||
name|MB
block|,
name|ONE
operator||
name|B
block|,
name|ILL
operator||
name|MB
block|}
block|,
comment|/*QST*/
block|{
name|QST
block|,
name|QST
block|,
name|OPR
block|,
name|QST
block|,
name|QST
block|,
name|QST
block|}
block|,
comment|/*SPC*/
block|{
name|OPR
block|,
name|ATM
block|,
name|QST
block|,
name|SPC
operator||
name|M
block|,
name|ONE
block|,
name|ILL
operator||
name|MB
block|}
block|,
comment|/*ONE*/
block|{
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|ILL
operator||
name|MB
block|}
block|,
comment|/*ILL*/
block|{
name|OPR
operator||
name|B
block|,
name|ATM
operator||
name|B
block|,
name|QST
operator||
name|B
block|,
name|SPC
operator||
name|MB
block|,
name|ONE
operator||
name|B
block|,
name|ILL
operator||
name|M
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* token type table -- it gets modified with $o characters */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|TokTypeTab
index|[
literal|256
index|]
init|=
block|{
comment|/*	nul soh stx etx eot enq ack bel  bs  ht  nl  vt  np  cr  so  si   */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|SPC
block|,
name|SPC
block|,
name|SPC
block|,
name|SPC
block|,
name|SPC
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*	dle dc1 dc2 dc3 dc4 nak syn etb  can em  sub esc fs  gs  rs  us   */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*  sp  !   "   #   $   %&   '    (   )   *   +   ,   -   .   /    */
name|SPC
block|,
name|ATM
block|,
name|QST
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|SPC
block|,
name|SPC
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*	0   1   2   3   4   5   6   7    8   9   :   ;<   =>   ?    */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*	@   A   B   C   D   E   F   G    H   I   J   K   L   M   N   O    */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*  P   Q   R   S   T   U   V   W    X   Y   Z   [   \   ]   ^   _    */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*	`   a   b   c   d   e   f   g    h   i   j   k   l   m   n   o    */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*  p   q   r   s   t   u   v   w    x   y   z   {   |   }   ~   del  */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*	nul soh stx etx eot enq ack bel  bs  ht  nl  vt  np  cr  so  si   */
name|OPR
block|,
name|OPR
block|,
name|ONE
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
comment|/*	dle dc1 dc2 dc3 dc4 nak syn etb  can em  sub esc fs  gs  rs  us   */
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|ONE
block|,
name|ONE
block|,
name|ONE
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
comment|/*  sp  !   "   #   $   %&   '    (   )   *   +   ,   -   .   /    */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*	0   1   2   3   4   5   6   7    8   9   :   ;<   =>   ?    */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*	@   A   B   C   D   E   F   G    H   I   J   K   L   M   N   O    */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*  P   Q   R   S   T   U   V   W    X   Y   Z   [   \   ]   ^   _    */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*	`   a   b   c   d   e   f   g    h   i   j   k   l   m   n   o    */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*  p   q   r   s   t   u   v   w    x   y   z   {   |   }   ~   del  */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* token type table for MIME parsing */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|MimeTokenTab
index|[
literal|256
index|]
init|=
block|{
comment|/*	nul soh stx etx eot enq ack bel  bs  ht  nl  vt  np  cr  so  si   */
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|SPC
block|,
name|SPC
block|,
name|SPC
block|,
name|SPC
block|,
name|SPC
block|,
name|ILL
block|,
name|ILL
block|,
comment|/*	dle dc1 dc2 dc3 dc4 nak syn etb  can em  sub esc fs  gs  rs  us   */
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
comment|/*  sp  !   "   #   $   %&   '    (   )   *   +   ,   -   .   /    */
name|SPC
block|,
name|ATM
block|,
name|QST
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|SPC
block|,
name|SPC
block|,
name|ATM
block|,
name|ATM
block|,
name|OPR
block|,
name|ATM
block|,
name|ATM
block|,
name|OPR
block|,
comment|/*	0   1   2   3   4   5   6   7    8   9   :   ;<   =>   ?    */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
comment|/*	@   A   B   C   D   E   F   G    H   I   J   K   L   M   N   O    */
name|OPR
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*  P   Q   R   S   T   U   V   W    X   Y   Z   [   \   ]   ^   _    */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*	`   a   b   c   d   e   f   g    h   i   j   k   l   m   n   o    */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*  p   q   r   s   t   u   v   w    x   y   z   {   |   }   ~   del  */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*	nul soh stx etx eot enq ack bel  bs  ht  nl  vt  np  cr  so  si   */
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
comment|/*	dle dc1 dc2 dc3 dc4 nak syn etb  can em  sub esc fs  gs  rs  us   */
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
comment|/*  sp  !   "   #   $   %&   '    (   )   *   +   ,   -   .   /    */
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
comment|/*	0   1   2   3   4   5   6   7    8   9   :   ;<   =>   ?    */
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
comment|/*	@   A   B   C   D   E   F   G    H   I   J   K   L   M   N   O    */
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
comment|/*  P   Q   R   S   T   U   V   W    X   Y   Z   [   \   ]   ^   _    */
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
comment|/*	`   a   b   c   d   e   f   g    h   i   j   k   l   m   n   o    */
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
comment|/*  p   q   r   s   t   u   v   w    x   y   z   {   |   }   ~   del  */
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|,
name|ILL
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* token type table: don't strip comments */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|TokTypeNoC
index|[
literal|256
index|]
init|=
block|{
comment|/*	nul soh stx etx eot enq ack bel  bs  ht  nl  vt  np  cr  so  si   */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|SPC
block|,
name|SPC
block|,
name|SPC
block|,
name|SPC
block|,
name|SPC
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*	dle dc1 dc2 dc3 dc4 nak syn etb  can em  sub esc fs  gs  rs  us   */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*  sp  !   "   #   $   %&   '    (   )   *   +   ,   -   .   /    */
name|SPC
block|,
name|ATM
block|,
name|QST
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|OPR
block|,
name|OPR
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*	0   1   2   3   4   5   6   7    8   9   :   ;<   =>   ?    */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*	@   A   B   C   D   E   F   G    H   I   J   K   L   M   N   O    */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*  P   Q   R   S   T   U   V   W    X   Y   Z   [   \   ]   ^   _    */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*	`   a   b   c   d   e   f   g    h   i   j   k   l   m   n   o    */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*  p   q   r   s   t   u   v   w    x   y   z   {   |   }   ~   del  */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*	nul soh stx etx eot enq ack bel  bs  ht  nl  vt  np  cr  so  si   */
name|OPR
block|,
name|OPR
block|,
name|ONE
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
comment|/*	dle dc1 dc2 dc3 dc4 nak syn etb  can em  sub esc fs  gs  rs  us   */
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|ONE
block|,
name|ONE
block|,
name|ONE
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
comment|/*  sp  !   "   #   $   %&   '    (   )   *   +   ,   -   .   /    */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*	0   1   2   3   4   5   6   7    8   9   :   ;<   =>   ?    */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*	@   A   B   C   D   E   F   G    H   I   J   K   L   M   N   O    */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*  P   Q   R   S   T   U   V   W    X   Y   Z   [   \   ]   ^   _    */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*	`   a   b   c   d   e   f   g    h   i   j   k   l   m   n   o    */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
comment|/*  p   q   r   s   t   u   v   w    x   y   z   {   |   }   ~   del  */
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NOCHAR
value|(-1)
end_define

begin_comment
comment|/* signal nothing in lookahead token */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|prescan
parameter_list|(
name|addr
parameter_list|,
name|delim
parameter_list|,
name|pvpbuf
parameter_list|,
name|pvpbsize
parameter_list|,
name|delimptr
parameter_list|,
name|toktab
parameter_list|)
name|char
modifier|*
name|addr
decl_stmt|;
name|int
name|delim
decl_stmt|;
name|char
name|pvpbuf
index|[]
decl_stmt|;
name|int
name|pvpbsize
decl_stmt|;
name|char
modifier|*
modifier|*
name|delimptr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|toktab
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
modifier|*
modifier|*
name|avp
decl_stmt|;
name|bool
name|bslashmode
decl_stmt|;
name|bool
name|route_syntax
decl_stmt|;
name|int
name|cmntcnt
decl_stmt|;
name|int
name|anglecnt
decl_stmt|;
name|char
modifier|*
name|tok
decl_stmt|;
name|int
name|state
decl_stmt|;
name|int
name|newstate
decl_stmt|;
name|char
modifier|*
name|saveto
init|=
name|CurEnv
operator|->
name|e_to
decl_stmt|;
specifier|static
name|char
modifier|*
name|av
index|[
name|MAXATOM
operator|+
literal|1
index|]
decl_stmt|;
specifier|static
name|bool
name|firsttime
init|=
name|true
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
if|if
condition|(
name|firsttime
condition|)
block|{
comment|/* initialize the token type table */
name|char
name|obuf
index|[
literal|50
index|]
decl_stmt|;
name|firsttime
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|OperatorChars
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ConfigLevel
operator|<
literal|7
condition|)
name|OperatorChars
operator|=
name|macvalue
argument_list|(
literal|'o'
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
if|if
condition|(
name|OperatorChars
operator|==
name|NULL
condition|)
name|OperatorChars
operator|=
literal|".:@[]"
expr_stmt|;
block|}
name|expand
argument_list|(
name|OperatorChars
argument_list|,
name|obuf
argument_list|,
sizeof|sizeof
name|obuf
operator|-
sizeof|sizeof
name|DELIMCHARS
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|obuf
argument_list|,
name|DELIMCHARS
argument_list|,
sizeof|sizeof
name|obuf
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|obuf
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|TokTypeTab
index|[
operator|*
name|p
operator|&
literal|0xff
index|]
operator|==
name|ATM
condition|)
name|TokTypeTab
index|[
operator|*
name|p
operator|&
literal|0xff
index|]
operator|=
name|OPR
expr_stmt|;
if|if
condition|(
name|TokTypeNoC
index|[
operator|*
name|p
operator|&
literal|0xff
index|]
operator|==
name|ATM
condition|)
name|TokTypeNoC
index|[
operator|*
name|p
operator|&
literal|0xff
index|]
operator|=
name|OPR
expr_stmt|;
block|}
block|}
if|if
condition|(
name|toktab
operator|==
name|NULL
condition|)
name|toktab
operator|=
name|TokTypeTab
expr_stmt|;
comment|/* make sure error messages don't have garbage on them */
name|errno
operator|=
literal|0
expr_stmt|;
name|q
operator|=
name|pvpbuf
expr_stmt|;
name|bslashmode
operator|=
name|false
expr_stmt|;
name|route_syntax
operator|=
name|false
expr_stmt|;
name|cmntcnt
operator|=
literal|0
expr_stmt|;
name|anglecnt
operator|=
literal|0
expr_stmt|;
name|avp
operator|=
name|av
expr_stmt|;
name|state
operator|=
name|ATM
expr_stmt|;
name|c
operator|=
name|NOCHAR
expr_stmt|;
name|p
operator|=
name|addr
expr_stmt|;
name|CurEnv
operator|->
name|e_to
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|22
argument_list|,
literal|11
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"prescan: "
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
do|do
block|{
comment|/* read a token */
name|tok
operator|=
name|q
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* store away any old lookahead character */
if|if
condition|(
name|c
operator|!=
name|NOCHAR
operator|&&
operator|!
name|bslashmode
condition|)
block|{
comment|/* see if there is room */
if|if
condition|(
name|q
operator|>=
operator|&
name|pvpbuf
index|[
name|pvpbsize
operator|-
literal|5
index|]
condition|)
block|{
name|addrtoolong
label|:
name|usrerr
argument_list|(
literal|"553 5.1.1 Address too long"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|addr
argument_list|)
operator|>
name|MAXNAME
condition|)
name|addr
index|[
name|MAXNAME
index|]
operator|=
literal|'\0'
expr_stmt|;
name|returnnull
label|:
if|if
condition|(
name|delimptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|>
name|addr
condition|)
operator|--
name|p
expr_stmt|;
operator|*
name|delimptr
operator|=
name|p
expr_stmt|;
block|}
name|CurEnv
operator|->
name|e_to
operator|=
name|saveto
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* squirrel it away */
if|#
directive|if
operator|!
name|ALLOW_255
if|if
condition|(
operator|(
name|char
operator|)
name|c
operator|==
operator|(
name|char
operator|)
operator|-
literal|1
operator|&&
operator|!
name|tTd
argument_list|(
literal|82
argument_list|,
literal|101
argument_list|)
condition|)
name|c
operator|&=
literal|0x7f
expr_stmt|;
endif|#
directive|endif
comment|/* !ALLOW_255 */
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
block|}
comment|/* read a new input character */
name|c
operator|=
operator|(
operator|*
name|p
operator|++
operator|)
operator|&
literal|0x00ff
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
comment|/* diagnose and patch up bad syntax */
if|if
condition|(
name|state
operator|==
name|QST
condition|)
block|{
name|usrerr
argument_list|(
literal|"553 Unbalanced '\"'"
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'"'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmntcnt
operator|>
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"553 Unbalanced '('"
argument_list|)
expr_stmt|;
name|c
operator|=
literal|')'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|anglecnt
operator|>
literal|0
condition|)
block|{
name|c
operator|=
literal|'>'
expr_stmt|;
name|usrerr
argument_list|(
literal|"553 Unbalanced '<'"
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
name|p
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|delim
operator|&&
name|cmntcnt
operator|<=
literal|0
operator|&&
name|state
operator|!=
name|QST
condition|)
block|{
if|if
condition|(
name|anglecnt
operator|<=
literal|0
condition|)
break|break;
comment|/* special case for better error management */
if|if
condition|(
name|delim
operator|==
literal|','
operator|&&
operator|!
name|route_syntax
condition|)
block|{
name|usrerr
argument_list|(
literal|"553 Unbalanced '<'"
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'>'
expr_stmt|;
name|p
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|22
argument_list|,
literal|101
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"c=%c, s=%d; "
argument_list|,
name|c
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|/* chew up special characters */
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|bslashmode
condition|)
block|{
name|bslashmode
operator|=
name|false
expr_stmt|;
comment|/* kludge \! for naive users */
if|if
condition|(
name|cmntcnt
operator|>
literal|0
condition|)
block|{
name|c
operator|=
name|NOCHAR
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'!'
operator|||
name|state
operator|==
name|QST
condition|)
block|{
comment|/* see if there is room */
if|if
condition|(
name|q
operator|>=
operator|&
name|pvpbuf
index|[
name|pvpbsize
operator|-
literal|5
index|]
condition|)
goto|goto
name|addrtoolong
goto|;
operator|*
name|q
operator|++
operator|=
literal|'\\'
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|bslashmode
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|QST
condition|)
block|{
comment|/* EMPTY */
comment|/* do nothing, just avoid next clauses */
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'('
operator|&&
name|toktab
index|[
literal|'('
index|]
operator|==
name|SPC
condition|)
block|{
name|cmntcnt
operator|++
expr_stmt|;
name|c
operator|=
name|NOCHAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
operator|&&
name|toktab
index|[
literal|'('
index|]
operator|==
name|SPC
condition|)
block|{
if|if
condition|(
name|cmntcnt
operator|<=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"553 Unbalanced ')'"
argument_list|)
expr_stmt|;
name|c
operator|=
name|NOCHAR
expr_stmt|;
block|}
else|else
name|cmntcnt
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmntcnt
operator|>
literal|0
condition|)
block|{
name|c
operator|=
name|NOCHAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
name|char
modifier|*
name|ptr
init|=
name|p
decl_stmt|;
name|anglecnt
operator|++
expr_stmt|;
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|ptr
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'@'
condition|)
name|route_syntax
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
block|{
if|if
condition|(
name|anglecnt
operator|<=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"553 Unbalanced '>'"
argument_list|)
expr_stmt|;
name|c
operator|=
name|NOCHAR
expr_stmt|;
block|}
else|else
name|anglecnt
operator|--
expr_stmt|;
name|route_syntax
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|delim
operator|==
literal|' '
operator|&&
name|isascii
argument_list|(
name|c
argument_list|)
operator|&&
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NOCHAR
condition|)
continue|continue;
comment|/* see if this is end of input */
if|if
condition|(
name|c
operator|==
name|delim
operator|&&
name|anglecnt
operator|<=
literal|0
operator|&&
name|state
operator|!=
name|QST
condition|)
break|break;
name|newstate
operator|=
name|StateTab
index|[
name|state
index|]
index|[
name|toktab
index|[
name|c
operator|&
literal|0xff
index|]
index|]
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|22
argument_list|,
literal|101
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"ns=%02o\n"
argument_list|,
name|newstate
argument_list|)
expr_stmt|;
name|state
operator|=
name|newstate
operator|&
name|TYPE
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|ILL
condition|)
block|{
if|if
condition|(
name|isascii
argument_list|(
name|c
argument_list|)
operator|&&
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|usrerr
argument_list|(
literal|"553 Illegal character %c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|usrerr
argument_list|(
literal|"553 Illegal character 0x%02x"
argument_list|,
name|c
operator|&
literal|0x0ff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|M
argument_list|,
name|newstate
argument_list|)
condition|)
name|c
operator|=
name|NOCHAR
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|B
argument_list|,
name|newstate
argument_list|)
condition|)
break|break;
block|}
comment|/* new token */
if|if
condition|(
name|tok
operator|!=
name|q
condition|)
block|{
comment|/* see if there is room */
if|if
condition|(
name|q
operator|>=
operator|&
name|pvpbuf
index|[
name|pvpbsize
operator|-
literal|5
index|]
condition|)
goto|goto
name|addrtoolong
goto|;
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|22
argument_list|,
literal|36
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"tok="
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|tok
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|avp
operator|>=
operator|&
name|av
index|[
name|MAXATOM
index|]
condition|)
block|{
name|usrerr
argument_list|(
literal|"553 5.1.0 prescan: too many tokens"
argument_list|)
expr_stmt|;
goto|goto
name|returnnull
goto|;
block|}
if|if
condition|(
name|q
operator|-
name|tok
operator|>
name|MAXNAME
condition|)
block|{
name|usrerr
argument_list|(
literal|"553 5.1.0 prescan: token too long"
argument_list|)
expr_stmt|;
goto|goto
name|returnnull
goto|;
block|}
operator|*
name|avp
operator|++
operator|=
name|tok
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|!=
literal|'\0'
operator|&&
operator|(
name|c
operator|!=
name|delim
operator|||
name|anglecnt
operator|>
literal|0
operator|)
condition|)
do|;
operator|*
name|avp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|delimptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|>
name|addr
condition|)
name|p
operator|--
expr_stmt|;
operator|*
name|delimptr
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|22
argument_list|,
literal|12
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"prescan==>"
argument_list|)
expr_stmt|;
name|printav
argument_list|(
name|av
argument_list|)
expr_stmt|;
block|}
name|CurEnv
operator|->
name|e_to
operator|=
name|saveto
expr_stmt|;
if|if
condition|(
name|av
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|22
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"prescan: null leading token\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|av
return|;
block|}
end_function

begin_comment
comment|/* **  REWRITE -- apply rewrite rules to token vector. ** **	This routine is an ordered production system.  Each rewrite **	rule has a LHS (called the pattern) and a RHS (called the **	rewrite); 'rwr' points the the current rewrite rule. ** **	For each rewrite rule, 'avp' points the address vector we **	are trying to match against, and 'pvp' points to the pattern. **	If pvp points to a special match value (MATCHZANY, MATCHANY, **	MATCHONE, MATCHCLASS, MATCHNCLASS) then the address in avp **	matched is saved away in the match vector (pointed to by 'mvp'). ** **	When a match between avp& pvp does not match, we try to **	back out.  If we back up over MATCHONE, MATCHCLASS, or MATCHNCLASS **	we must also back out the match in mvp.  If we reach a **	MATCHANY or MATCHZANY we just extend the match and start **	over again. ** **	When we finally match, we rewrite the address vector **	and try over again. ** **	Parameters: **		pvp -- pointer to token vector. **		ruleset -- the ruleset to use for rewriting. **		reclevel -- recursion level (to catch loops). **		e -- the current envelope. **		maxatom -- maximum length of buffer (usually MAXATOM) ** **	Returns: **		A status code.  If EX_TEMPFAIL, higher level code should **			attempt recovery. ** **	Side Effects: **		pvp is modified. */
end_comment

begin_struct
struct|struct
name|match
block|{
name|char
modifier|*
modifier|*
name|match_first
decl_stmt|;
comment|/* first token matched */
name|char
modifier|*
modifier|*
name|match_last
decl_stmt|;
comment|/* last token matched */
name|char
modifier|*
modifier|*
name|match_pattern
decl_stmt|;
comment|/* pointer to pattern */
block|}
struct|;
end_struct

begin_function
name|int
name|rewrite
parameter_list|(
name|pvp
parameter_list|,
name|ruleset
parameter_list|,
name|reclevel
parameter_list|,
name|e
parameter_list|,
name|maxatom
parameter_list|)
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
name|int
name|ruleset
decl_stmt|;
name|int
name|reclevel
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|int
name|maxatom
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ap
decl_stmt|;
comment|/* address pointer */
specifier|register
name|char
modifier|*
name|rp
decl_stmt|;
comment|/* rewrite pointer */
specifier|register
name|char
modifier|*
name|rulename
decl_stmt|;
comment|/* ruleset name */
specifier|register
name|char
modifier|*
name|prefix
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|avp
decl_stmt|;
comment|/* address vector pointer */
specifier|register
name|char
modifier|*
modifier|*
name|rvp
decl_stmt|;
comment|/* rewrite vector pointer */
specifier|register
name|struct
name|match
modifier|*
name|mlp
decl_stmt|;
comment|/* cur ptr into mlist */
specifier|register
name|struct
name|rewrite
modifier|*
name|rwr
decl_stmt|;
comment|/* pointer to current rewrite rule */
name|int
name|ruleno
decl_stmt|;
comment|/* current rule number */
name|int
name|rstat
init|=
name|EX_OK
decl_stmt|;
comment|/* return status */
name|int
name|loopcount
decl_stmt|;
name|struct
name|match
name|mlist
index|[
name|MAXMATCH
index|]
decl_stmt|;
comment|/* stores match on LHS */
name|char
modifier|*
name|npvp
index|[
name|MAXATOM
operator|+
literal|1
index|]
decl_stmt|;
comment|/* temporary space for rebuild */
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|char
name|name
index|[
literal|6
index|]
decl_stmt|;
comment|/* 	**  mlp will not exceed mlist[] because readcf enforces 	**	the upper limit of entries when reading rulesets. 	*/
if|if
condition|(
name|ruleset
operator|<
literal|0
operator|||
name|ruleset
operator|>=
name|MAXRWSETS
condition|)
block|{
name|syserr
argument_list|(
literal|"554 5.3.5 rewrite: illegal ruleset number %d"
argument_list|,
name|ruleset
argument_list|)
expr_stmt|;
return|return
name|EX_CONFIG
return|;
block|}
name|rulename
operator|=
name|RuleSetNames
index|[
name|ruleset
index|]
expr_stmt|;
if|if
condition|(
name|rulename
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
literal|"%d"
argument_list|,
name|ruleset
argument_list|)
expr_stmt|;
name|rulename
operator|=
name|name
expr_stmt|;
block|}
if|if
condition|(
name|OpMode
operator|==
name|MD_TEST
condition|)
name|prefix
operator|=
literal|""
expr_stmt|;
else|else
name|prefix
operator|=
literal|"rewrite: ruleset "
expr_stmt|;
if|if
condition|(
name|OpMode
operator|==
name|MD_TEST
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s%-16.16s   input:"
argument_list|,
name|prefix
argument_list|,
name|rulename
argument_list|)
expr_stmt|;
name|printav
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"%s%-16.16s   input:"
argument_list|,
name|prefix
argument_list|,
name|rulename
argument_list|)
expr_stmt|;
name|printav
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reclevel
operator|++
operator|>
name|MaxRuleRecursion
condition|)
block|{
name|syserr
argument_list|(
literal|"rewrite: excessive recursion (max %d), ruleset %s"
argument_list|,
name|MaxRuleRecursion
argument_list|,
name|rulename
argument_list|)
expr_stmt|;
return|return
name|EX_CONFIG
return|;
block|}
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
return|return
name|EX_USAGE
return|;
if|if
condition|(
name|maxatom
operator|<=
literal|0
condition|)
return|return
name|EX_USAGE
return|;
comment|/* 	**  Run through the list of rewrite rules, applying 	**	any that match. 	*/
name|ruleno
operator|=
literal|1
expr_stmt|;
name|loopcount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|rwr
operator|=
name|RewriteRules
index|[
name|ruleset
index|]
init|;
name|rwr
operator|!=
name|NULL
condition|;
control|)
block|{
name|int
name|status
decl_stmt|;
comment|/* if already canonical, quit now */
if|if
condition|(
name|pvp
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
operator|(
name|pvp
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|&
literal|0377
operator|)
operator|==
name|CANONNET
condition|)
break|break;
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|12
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|15
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"-----trying rule (line %d):"
argument_list|,
name|rwr
operator|->
name|r_line
argument_list|)
expr_stmt|;
else|else
name|sm_dprintf
argument_list|(
literal|"-----trying rule:"
argument_list|)
expr_stmt|;
name|printav
argument_list|(
name|rwr
operator|->
name|r_lhs
argument_list|)
expr_stmt|;
block|}
comment|/* try to match on this rule */
name|mlp
operator|=
name|mlist
expr_stmt|;
name|rvp
operator|=
name|rwr
operator|->
name|r_lhs
expr_stmt|;
name|avp
operator|=
name|pvp
expr_stmt|;
if|if
condition|(
operator|++
name|loopcount
operator|>
literal|100
condition|)
block|{
name|syserr
argument_list|(
literal|"554 5.3.5 Infinite loop in ruleset %s, rule %d"
argument_list|,
name|rulename
argument_list|,
name|ruleno
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"workspace: "
argument_list|)
expr_stmt|;
name|printav
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
while|while
condition|(
operator|(
name|ap
operator|=
operator|*
name|avp
operator|)
operator|!=
name|NULL
operator|||
operator|*
name|rvp
operator|!=
name|NULL
condition|)
block|{
name|rp
operator|=
operator|*
name|rvp
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|35
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"ADVANCE rp="
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|", ap="
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
block|{
comment|/* end-of-pattern before end-of-address */
goto|goto
name|backup
goto|;
block|}
if|if
condition|(
name|ap
operator|==
name|NULL
operator|&&
operator|(
operator|*
name|rp
operator|&
literal|0377
operator|)
operator|!=
name|MATCHZANY
operator|&&
operator|(
operator|*
name|rp
operator|&
literal|0377
operator|)
operator|!=
name|MATCHZERO
condition|)
block|{
comment|/* end-of-input with patterns left */
goto|goto
name|backup
goto|;
block|}
switch|switch
condition|(
operator|*
name|rp
operator|&
literal|0377
condition|)
block|{
case|case
name|MATCHCLASS
case|:
comment|/* match any phrase in a class */
name|mlp
operator|->
name|match_pattern
operator|=
name|rvp
expr_stmt|;
name|mlp
operator|->
name|match_first
operator|=
name|avp
expr_stmt|;
name|extendclass
label|:
name|ap
operator|=
operator|*
name|avp
expr_stmt|;
if|if
condition|(
name|ap
operator|==
name|NULL
condition|)
goto|goto
name|backup
goto|;
name|mlp
operator|->
name|match_last
operator|=
name|avp
operator|++
expr_stmt|;
name|cataddr
argument_list|(
name|mlp
operator|->
name|match_first
argument_list|,
name|mlp
operator|->
name|match_last
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wordinclass
argument_list|(
name|buf
argument_list|,
name|rp
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|36
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"EXTEND  rp="
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|", ap="
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
goto|goto
name|extendclass
goto|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|36
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"CLMATCH\n"
argument_list|)
expr_stmt|;
name|mlp
operator|++
expr_stmt|;
break|break;
case|case
name|MATCHNCLASS
case|:
comment|/* match any token not in a class */
if|if
condition|(
name|wordinclass
argument_list|(
name|ap
argument_list|,
name|rp
index|[
literal|1
index|]
argument_list|)
condition|)
goto|goto
name|backup
goto|;
comment|/* FALLTHROUGH */
case|case
name|MATCHONE
case|:
case|case
name|MATCHANY
case|:
comment|/* match exactly one token */
name|mlp
operator|->
name|match_pattern
operator|=
name|rvp
expr_stmt|;
name|mlp
operator|->
name|match_first
operator|=
name|avp
expr_stmt|;
name|mlp
operator|->
name|match_last
operator|=
name|avp
operator|++
expr_stmt|;
name|mlp
operator|++
expr_stmt|;
break|break;
case|case
name|MATCHZANY
case|:
comment|/* match zero or more tokens */
name|mlp
operator|->
name|match_pattern
operator|=
name|rvp
expr_stmt|;
name|mlp
operator|->
name|match_first
operator|=
name|avp
expr_stmt|;
name|mlp
operator|->
name|match_last
operator|=
name|avp
operator|-
literal|1
expr_stmt|;
name|mlp
operator|++
expr_stmt|;
break|break;
case|case
name|MATCHZERO
case|:
comment|/* match zero tokens */
break|break;
case|case
name|MACRODEXPAND
case|:
comment|/* 				**  Match against run-time macro. 				**  This algorithm is broken for the 				**  general case (no recursive macros, 				**  improper tokenization) but should 				**  work for the usual cases. 				*/
name|ap
operator|=
name|macvalue
argument_list|(
name|rp
index|[
literal|1
index|]
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|mlp
operator|->
name|match_first
operator|=
name|avp
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"rewrite: LHS $&{%s} => \"%s\"\n"
argument_list|,
name|macname
argument_list|(
name|rp
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|ap
operator|==
name|NULL
condition|?
literal|"(NULL)"
else|:
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|==
name|NULL
condition|)
break|break;
while|while
condition|(
operator|*
name|ap
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|avp
operator|==
name|NULL
operator|||
name|sm_strncasecmp
argument_list|(
name|ap
argument_list|,
operator|*
name|avp
argument_list|,
name|strlen
argument_list|(
operator|*
name|avp
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* no match */
name|avp
operator|=
name|mlp
operator|->
name|match_first
expr_stmt|;
goto|goto
name|backup
goto|;
block|}
name|ap
operator|+=
name|strlen
argument_list|(
operator|*
name|avp
operator|++
argument_list|)
expr_stmt|;
block|}
comment|/* match */
break|break;
default|default:
comment|/* must have exact match */
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|rp
argument_list|,
name|ap
argument_list|)
condition|)
goto|goto
name|backup
goto|;
name|avp
operator|++
expr_stmt|;
break|break;
block|}
comment|/* successful match on this token */
name|rvp
operator|++
expr_stmt|;
continue|continue;
name|backup
label|:
comment|/* match failed -- back up */
while|while
condition|(
operator|--
name|mlp
operator|>=
name|mlist
condition|)
block|{
name|rvp
operator|=
name|mlp
operator|->
name|match_pattern
expr_stmt|;
name|rp
operator|=
operator|*
name|rvp
expr_stmt|;
name|avp
operator|=
name|mlp
operator|->
name|match_last
operator|+
literal|1
expr_stmt|;
name|ap
operator|=
operator|*
name|avp
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|36
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"BACKUP  rp="
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|", ap="
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|==
name|NULL
condition|)
block|{
comment|/* run off the end -- back up again */
continue|continue;
block|}
if|if
condition|(
operator|(
operator|*
name|rp
operator|&
literal|0377
operator|)
operator|==
name|MATCHANY
operator|||
operator|(
operator|*
name|rp
operator|&
literal|0377
operator|)
operator|==
name|MATCHZANY
condition|)
block|{
comment|/* extend binding and continue */
name|mlp
operator|->
name|match_last
operator|=
name|avp
operator|++
expr_stmt|;
name|rvp
operator|++
expr_stmt|;
name|mlp
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
operator|*
name|rp
operator|&
literal|0377
operator|)
operator|==
name|MATCHCLASS
condition|)
block|{
comment|/* extend binding and try again */
name|mlp
operator|->
name|match_last
operator|=
name|avp
expr_stmt|;
goto|goto
name|extendclass
goto|;
block|}
block|}
if|if
condition|(
name|mlp
operator|<
name|mlist
condition|)
block|{
comment|/* total failure to match */
break|break;
block|}
block|}
comment|/* 		**  See if we successfully matched 		*/
if|if
condition|(
name|mlp
operator|<
name|mlist
operator|||
operator|*
name|rvp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"----- rule fails\n"
argument_list|)
expr_stmt|;
name|rwr
operator|=
name|rwr
operator|->
name|r_next
expr_stmt|;
name|ruleno
operator|++
expr_stmt|;
name|loopcount
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|rvp
operator|=
name|rwr
operator|->
name|r_rhs
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|12
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"-----rule matches:"
argument_list|)
expr_stmt|;
name|printav
argument_list|(
name|rvp
argument_list|)
expr_stmt|;
block|}
name|rp
operator|=
operator|*
name|rvp
expr_stmt|;
if|if
condition|(
name|rp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|rp
operator|&
literal|0377
operator|)
operator|==
name|CANONUSER
condition|)
block|{
name|rvp
operator|++
expr_stmt|;
name|rwr
operator|=
name|rwr
operator|->
name|r_next
expr_stmt|;
name|ruleno
operator|++
expr_stmt|;
name|loopcount
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|rp
operator|&
literal|0377
operator|)
operator|==
name|CANONHOST
condition|)
block|{
name|rvp
operator|++
expr_stmt|;
name|rwr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* substitute */
for|for
control|(
name|avp
operator|=
name|npvp
init|;
operator|*
name|rvp
operator|!=
name|NULL
condition|;
name|rvp
operator|++
control|)
block|{
specifier|register
name|struct
name|match
modifier|*
name|m
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|rp
operator|=
operator|*
name|rvp
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|rp
operator|&
literal|0377
operator|)
operator|==
name|MATCHREPL
condition|)
block|{
comment|/* substitute from LHS */
name|m
operator|=
operator|&
name|mlist
index|[
name|rp
index|[
literal|1
index|]
operator|-
literal|'1'
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|<
name|mlist
operator|||
name|m
operator|>=
name|mlp
condition|)
block|{
name|syserr
argument_list|(
literal|"554 5.3.5 rewrite: ruleset %s: replacement $%c out of bounds"
argument_list|,
name|rulename
argument_list|,
name|rp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|EX_CONFIG
return|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|15
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"$%c:"
argument_list|,
name|rp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pp
operator|=
name|m
operator|->
name|match_first
expr_stmt|;
while|while
condition|(
name|pp
operator|<=
name|m
operator|->
name|match_last
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|" %p=\""
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
name|sm_dflush
argument_list|()
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"%s\""
argument_list|,
operator|*
name|pp
operator|++
argument_list|)
expr_stmt|;
block|}
name|sm_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|pp
operator|=
name|m
operator|->
name|match_first
expr_stmt|;
while|while
condition|(
name|pp
operator|<=
name|m
operator|->
name|match_last
condition|)
block|{
if|if
condition|(
name|avp
operator|>=
operator|&
name|npvp
index|[
name|maxatom
index|]
condition|)
goto|goto
name|toolong
goto|;
operator|*
name|avp
operator|++
operator|=
operator|*
name|pp
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* some sort of replacement */
if|if
condition|(
name|avp
operator|>=
operator|&
name|npvp
index|[
name|maxatom
index|]
condition|)
block|{
name|toolong
label|:
name|syserr
argument_list|(
literal|"554 5.3.0 rewrite: expansion too long"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"rewrite: expansion too long, ruleset=%s, ruleno=%d"
argument_list|,
name|rulename
argument_list|,
name|ruleno
argument_list|)
expr_stmt|;
return|return
name|EX_DATAERR
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|rp
operator|&
literal|0377
operator|)
operator|!=
name|MACRODEXPAND
condition|)
block|{
comment|/* vanilla replacement */
operator|*
name|avp
operator|++
operator|=
name|rp
expr_stmt|;
block|}
else|else
block|{
comment|/* $&{x} replacement */
name|char
modifier|*
name|mval
init|=
name|macvalue
argument_list|(
name|rp
index|[
literal|1
index|]
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|xpvp
decl_stmt|;
name|int
name|trsize
init|=
literal|0
decl_stmt|;
specifier|static
name|size_t
name|pvpb1_size
init|=
literal|0
decl_stmt|;
specifier|static
name|char
modifier|*
modifier|*
name|pvpb1
init|=
name|NULL
decl_stmt|;
name|char
name|pvpbuf
index|[
name|PSBUFSIZE
index|]
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"rewrite: RHS $&{%s} => \"%s\"\n"
argument_list|,
name|macname
argument_list|(
name|rp
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|mval
operator|==
name|NULL
condition|?
literal|"(NULL)"
else|:
name|mval
argument_list|)
expr_stmt|;
if|if
condition|(
name|mval
operator|==
name|NULL
operator|||
operator|*
name|mval
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/* save the remainder of the input */
for|for
control|(
name|xpvp
operator|=
name|pvp
init|;
operator|*
name|xpvp
operator|!=
name|NULL
condition|;
name|xpvp
operator|++
control|)
name|trsize
operator|+=
sizeof|sizeof
expr|*
name|xpvp
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|trsize
operator|>
name|pvpb1_size
condition|)
block|{
if|if
condition|(
name|pvpb1
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|pvpb1
argument_list|)
expr_stmt|;
name|pvpb1
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|sm_pmalloc_x
argument_list|(
name|trsize
argument_list|)
expr_stmt|;
name|pvpb1_size
operator|=
name|trsize
expr_stmt|;
block|}
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pvpb1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pvp
argument_list|,
name|trsize
argument_list|)
expr_stmt|;
comment|/* scan the new replacement */
name|xpvp
operator|=
name|prescan
argument_list|(
name|mval
argument_list|,
literal|'\0'
argument_list|,
name|pvpbuf
argument_list|,
sizeof|sizeof
name|pvpbuf
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpvp
operator|==
name|NULL
condition|)
block|{
comment|/* prescan pre-printed error */
return|return
name|EX_DATAERR
return|;
block|}
comment|/* insert it into the output stream */
while|while
condition|(
operator|*
name|xpvp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|19
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|" ... %s\n"
argument_list|,
operator|*
name|xpvp
argument_list|)
expr_stmt|;
operator|*
name|avp
operator|++
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
operator|*
name|xpvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|avp
operator|>=
operator|&
name|npvp
index|[
name|maxatom
index|]
condition|)
goto|goto
name|toolong
goto|;
name|xpvp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|19
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|" ... DONE\n"
argument_list|)
expr_stmt|;
comment|/* restore the old trailing input */
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pvp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pvpb1
argument_list|,
name|trsize
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|*
name|avp
operator|++
operator|=
name|NULL
expr_stmt|;
comment|/* 		**  Check for any hostname/keyword lookups. 		*/
for|for
control|(
name|rvp
operator|=
name|npvp
init|;
operator|*
name|rvp
operator|!=
name|NULL
condition|;
name|rvp
operator|++
control|)
block|{
name|char
modifier|*
modifier|*
name|hbrvp
decl_stmt|;
name|char
modifier|*
modifier|*
name|xpvp
decl_stmt|;
name|int
name|trsize
decl_stmt|;
name|char
modifier|*
name|replac
decl_stmt|;
name|int
name|endtoken
decl_stmt|;
name|STAB
modifier|*
name|map
decl_stmt|;
name|char
modifier|*
name|mapname
decl_stmt|;
name|char
modifier|*
modifier|*
name|key_rvp
decl_stmt|;
name|char
modifier|*
modifier|*
name|arg_rvp
decl_stmt|;
name|char
modifier|*
modifier|*
name|default_rvp
decl_stmt|;
name|char
name|cbuf
index|[
name|MAXNAME
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|pvpb1
index|[
name|MAXATOM
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|argvect
index|[
name|MAX_MAP_ARGS
index|]
decl_stmt|;
name|char
name|pvpbuf
index|[
name|PSBUFSIZE
index|]
decl_stmt|;
name|char
modifier|*
name|nullpvp
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|(
operator|*
operator|*
name|rvp
operator|&
literal|0377
operator|)
operator|!=
name|HOSTBEGIN
operator|&&
operator|(
operator|*
operator|*
name|rvp
operator|&
literal|0377
operator|)
operator|!=
name|LOOKUPBEGIN
condition|)
continue|continue;
comment|/* 			**  Got a hostname/keyword lookup. 			** 			**	This could be optimized fairly easily. 			*/
name|hbrvp
operator|=
name|rvp
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|*
name|rvp
operator|&
literal|0377
operator|)
operator|==
name|HOSTBEGIN
condition|)
block|{
name|endtoken
operator|=
name|HOSTEND
expr_stmt|;
name|mapname
operator|=
literal|"host"
expr_stmt|;
block|}
else|else
block|{
name|endtoken
operator|=
name|LOOKUPEND
expr_stmt|;
name|mapname
operator|=
operator|*
operator|++
name|rvp
expr_stmt|;
if|if
condition|(
name|mapname
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"554 5.3.0 rewrite: missing mapname"
argument_list|)
expr_stmt|;
block|}
name|map
operator|=
name|stab
argument_list|(
name|mapname
argument_list|,
name|ST_MAP
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"554 5.3.0 rewrite: map %s not found"
argument_list|,
name|mapname
argument_list|)
expr_stmt|;
comment|/* extract the match part */
name|key_rvp
operator|=
operator|++
name|rvp
expr_stmt|;
if|if
condition|(
name|key_rvp
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"554 5.3.0 rewrite: missing key for map %s"
argument_list|,
name|mapname
argument_list|)
expr_stmt|;
name|default_rvp
operator|=
name|NULL
expr_stmt|;
name|arg_rvp
operator|=
name|argvect
expr_stmt|;
name|xpvp
operator|=
name|NULL
expr_stmt|;
name|replac
operator|=
name|pvpbuf
expr_stmt|;
while|while
condition|(
operator|*
name|rvp
operator|!=
name|NULL
operator|&&
operator|(
operator|*
operator|*
name|rvp
operator|&
literal|0377
operator|)
operator|!=
name|endtoken
condition|)
block|{
name|int
name|nodetype
init|=
operator|*
operator|*
name|rvp
operator|&
literal|0377
decl_stmt|;
if|if
condition|(
name|nodetype
operator|!=
name|CANONHOST
operator|&&
name|nodetype
operator|!=
name|CANONUSER
condition|)
block|{
name|rvp
operator|++
expr_stmt|;
continue|continue;
block|}
operator|*
name|rvp
operator|++
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|xpvp
operator|!=
name|NULL
condition|)
block|{
name|cataddr
argument_list|(
name|xpvp
argument_list|,
name|NULL
argument_list|,
name|replac
argument_list|,
operator|&
name|pvpbuf
index|[
sizeof|sizeof
name|pvpbuf
index|]
operator|-
name|replac
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_rvp
operator|<
operator|&
name|argvect
index|[
name|MAX_MAP_ARGS
operator|-
literal|1
index|]
condition|)
operator|*
operator|++
name|arg_rvp
operator|=
name|replac
expr_stmt|;
name|replac
operator|+=
name|strlen
argument_list|(
name|replac
argument_list|)
operator|+
literal|1
expr_stmt|;
name|xpvp
operator|=
name|NULL
expr_stmt|;
block|}
switch|switch
condition|(
name|nodetype
condition|)
block|{
case|case
name|CANONHOST
case|:
name|xpvp
operator|=
name|rvp
expr_stmt|;
break|break;
case|case
name|CANONUSER
case|:
name|default_rvp
operator|=
name|rvp
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|rvp
operator|!=
name|NULL
condition|)
operator|*
name|rvp
operator|++
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|xpvp
operator|!=
name|NULL
condition|)
block|{
name|cataddr
argument_list|(
name|xpvp
argument_list|,
name|NULL
argument_list|,
name|replac
argument_list|,
operator|&
name|pvpbuf
index|[
sizeof|sizeof
name|pvpbuf
index|]
operator|-
name|replac
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_rvp
operator|<
operator|&
name|argvect
index|[
name|MAX_MAP_ARGS
operator|-
literal|1
index|]
condition|)
operator|*
operator|++
name|arg_rvp
operator|=
name|replac
expr_stmt|;
block|}
if|if
condition|(
name|arg_rvp
operator|>=
operator|&
name|argvect
index|[
name|MAX_MAP_ARGS
operator|-
literal|1
index|]
condition|)
name|argvect
index|[
name|MAX_MAP_ARGS
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
else|else
operator|*
operator|++
name|arg_rvp
operator|=
name|NULL
expr_stmt|;
comment|/* save the remainder of the input string */
name|trsize
operator|=
call|(
name|int
call|)
argument_list|(
name|avp
operator|-
name|rvp
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
expr|*
name|rvp
expr_stmt|;
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pvpb1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|rvp
argument_list|,
name|trsize
argument_list|)
expr_stmt|;
comment|/* look it up */
name|cataddr
argument_list|(
name|key_rvp
argument_list|,
name|NULL
argument_list|,
name|cbuf
argument_list|,
sizeof|sizeof
name|cbuf
argument_list|,
name|map
operator|==
name|NULL
condition|?
literal|'\0'
else|:
name|map
operator|->
name|s_map
operator|.
name|map_spacesub
argument_list|)
expr_stmt|;
name|argvect
index|[
literal|0
index|]
operator|=
name|cbuf
expr_stmt|;
name|replac
operator|=
name|map_lookup
argument_list|(
name|map
argument_list|,
name|cbuf
argument_list|,
name|argvect
argument_list|,
operator|&
name|rstat
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* if no replacement, use default */
if|if
condition|(
name|replac
operator|==
name|NULL
operator|&&
name|default_rvp
operator|!=
name|NULL
condition|)
block|{
comment|/* create the default */
name|cataddr
argument_list|(
name|default_rvp
argument_list|,
name|NULL
argument_list|,
name|cbuf
argument_list|,
sizeof|sizeof
name|cbuf
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|replac
operator|=
name|cbuf
expr_stmt|;
block|}
if|if
condition|(
name|replac
operator|==
name|NULL
condition|)
block|{
name|xpvp
operator|=
name|key_rvp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|replac
operator|==
literal|'\0'
condition|)
block|{
comment|/* null replacement */
name|nullpvp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|xpvp
operator|=
name|nullpvp
expr_stmt|;
block|}
else|else
block|{
comment|/* scan the new replacement */
name|xpvp
operator|=
name|prescan
argument_list|(
name|replac
argument_list|,
literal|'\0'
argument_list|,
name|pvpbuf
argument_list|,
sizeof|sizeof
name|pvpbuf
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpvp
operator|==
name|NULL
condition|)
block|{
comment|/* prescan already printed error */
return|return
name|EX_DATAERR
return|;
block|}
block|}
comment|/* append it to the token list */
for|for
control|(
name|avp
operator|=
name|hbrvp
init|;
operator|*
name|xpvp
operator|!=
name|NULL
condition|;
name|xpvp
operator|++
control|)
block|{
operator|*
name|avp
operator|++
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
operator|*
name|xpvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|avp
operator|>=
operator|&
name|npvp
index|[
name|maxatom
index|]
condition|)
goto|goto
name|toolong
goto|;
block|}
comment|/* restore the old trailing information */
name|rvp
operator|=
name|avp
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|xpvp
operator|=
name|pvpb1
init|;
operator|(
operator|*
name|avp
operator|++
operator|=
operator|*
name|xpvp
operator|++
operator|)
operator|!=
name|NULL
condition|;
control|)
if|if
condition|(
name|avp
operator|>=
operator|&
name|npvp
index|[
name|maxatom
index|]
condition|)
goto|goto
name|toolong
goto|;
block|}
comment|/* 		**  Check for subroutine calls. 		*/
name|status
operator|=
name|callsubr
argument_list|(
name|npvp
argument_list|,
name|reclevel
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|rstat
operator|==
name|EX_OK
operator|||
name|status
operator|==
name|EX_TEMPFAIL
condition|)
name|rstat
operator|=
name|status
expr_stmt|;
comment|/* copy vector back into original space. */
for|for
control|(
name|avp
operator|=
name|npvp
init|;
operator|*
name|avp
operator|++
operator|!=
name|NULL
condition|;
control|)
continue|continue;
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pvp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|npvp
argument_list|,
call|(
name|int
call|)
argument_list|(
name|avp
operator|-
name|npvp
argument_list|)
operator|*
sizeof|sizeof
expr|*
name|avp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"rewritten as:"
argument_list|)
expr_stmt|;
name|printav
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|OpMode
operator|==
name|MD_TEST
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s%-16.16s returns:"
argument_list|,
name|prefix
argument_list|,
name|rulename
argument_list|)
expr_stmt|;
name|printav
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"%s%-16.16s returns:"
argument_list|,
name|prefix
argument_list|,
name|rulename
argument_list|)
expr_stmt|;
name|printav
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
block|}
return|return
name|rstat
return|;
block|}
end_function

begin_comment
comment|/* **  CALLSUBR -- call subroutines in rewrite vector ** **	Parameters: **		pvp -- pointer to token vector. **		reclevel -- the current recursion level. **		e -- the current envelope. ** **	Returns: **		The status from the subroutine call. ** **	Side Effects: **		pvp is modified. */
end_comment

begin_function
specifier|static
name|int
name|callsubr
parameter_list|(
name|pvp
parameter_list|,
name|reclevel
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
name|int
name|reclevel
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|avp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|subr
decl_stmt|,
name|j
decl_stmt|;
name|int
name|nsubr
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|rstat
init|=
name|EX_OK
decl_stmt|;
define|#
directive|define
name|MAX_SUBR
value|16
name|int
name|subrnumber
index|[
name|MAX_SUBR
index|]
decl_stmt|;
name|int
name|subrindex
index|[
name|MAX_SUBR
index|]
decl_stmt|;
name|nsubr
operator|=
literal|0
expr_stmt|;
comment|/* 	**  Look for subroutine calls in pvp, collect them into subr*[] 	**  We will perform the calls in the next loop, because we will 	**  call the "last" subroutine first to avoid recursive calls 	**  and too much copying. 	*/
for|for
control|(
name|avp
operator|=
name|pvp
operator|,
name|j
operator|=
literal|0
init|;
operator|*
name|avp
operator|!=
name|NULL
condition|;
name|avp
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
operator|*
name|avp
operator|&
literal|0377
operator|)
operator|==
name|CALLSUBR
operator|&&
name|avp
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
name|stripquotes
argument_list|(
name|avp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|subr
operator|=
name|strtorwset
argument_list|(
name|avp
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|subr
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"554 5.3.5 Unknown ruleset %s"
argument_list|,
name|avp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|EX_CONFIG
return|;
block|}
comment|/* 			**  XXX instead of doing this we could optimize 			**  the rules after reading them: just remove 			**  calls to empty rulesets 			*/
comment|/* subroutine is an empty ruleset?  don't call it */
if|if
condition|(
name|RewriteRules
index|[
name|subr
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|3
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"-----skip subr %s (%d)\n"
argument_list|,
name|avp
index|[
literal|1
index|]
argument_list|,
name|subr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|avp
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|avp
index|[
name|i
operator|-
literal|2
index|]
operator|=
name|avp
index|[
name|i
index|]
expr_stmt|;
name|avp
index|[
name|i
operator|-
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|++
name|nsubr
operator|>=
name|MAX_SUBR
condition|)
block|{
name|syserr
argument_list|(
literal|"554 5.3.0 Too many subroutine calls (%d max)"
argument_list|,
name|MAX_SUBR
argument_list|)
expr_stmt|;
return|return
name|EX_CONFIG
return|;
block|}
name|subrnumber
index|[
name|nsubr
index|]
operator|=
name|subr
expr_stmt|;
name|subrindex
index|[
name|nsubr
index|]
operator|=
name|j
expr_stmt|;
block|}
block|}
comment|/* 	**  Perform the actual subroutines calls, "last" one first, i.e., 	**  go from the right to the left through all calls, 	**  do the rewriting in place. 	*/
for|for
control|(
init|;
name|nsubr
operator|>
literal|0
condition|;
name|nsubr
operator|--
control|)
block|{
name|subr
operator|=
name|subrnumber
index|[
name|nsubr
index|]
expr_stmt|;
name|avp
operator|=
name|pvp
operator|+
name|subrindex
index|[
name|nsubr
index|]
expr_stmt|;
comment|/* remove the subroutine call and name */
for|for
control|(
name|i
operator|=
literal|2
init|;
name|avp
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|avp
index|[
name|i
operator|-
literal|2
index|]
operator|=
name|avp
index|[
name|i
index|]
expr_stmt|;
name|avp
index|[
name|i
operator|-
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* 		**  Now we need to call the ruleset specified for 		**  the subroutine. We can do this in place since 		**  we call the "last" subroutine first. 		*/
name|status
operator|=
name|rewrite
argument_list|(
name|avp
argument_list|,
name|subr
argument_list|,
name|reclevel
argument_list|,
name|e
argument_list|,
name|MAXATOM
operator|-
name|subrindex
index|[
name|nsubr
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|EX_OK
operator|&&
name|status
operator|!=
name|EX_TEMPFAIL
condition|)
return|return
name|status
return|;
if|if
condition|(
name|rstat
operator|==
name|EX_OK
operator|||
name|status
operator|==
name|EX_TEMPFAIL
condition|)
name|rstat
operator|=
name|status
expr_stmt|;
block|}
return|return
name|rstat
return|;
block|}
end_function

begin_comment
comment|/* **  MAP_LOOKUP -- do lookup in map ** **	Parameters: **		smap -- the map to use for the lookup. **		key -- the key to look up. **		argvect -- arguments to pass to the map lookup. **		pstat -- a pointer to an integer in which to store the **			status from the lookup. **		e -- the current envelope. ** **	Returns: **		The result of the lookup. **		NULL -- if there was no data for the given key. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|map_lookup
parameter_list|(
name|smap
parameter_list|,
name|key
parameter_list|,
name|argvect
parameter_list|,
name|pstat
parameter_list|,
name|e
parameter_list|)
name|STAB
modifier|*
name|smap
decl_stmt|;
name|char
name|key
index|[]
decl_stmt|;
name|char
modifier|*
modifier|*
name|argvect
decl_stmt|;
name|int
modifier|*
name|pstat
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|auto
name|int
name|status
init|=
name|EX_OK
decl_stmt|;
name|MAP
modifier|*
name|map
decl_stmt|;
name|char
modifier|*
name|replac
decl_stmt|;
if|if
condition|(
name|smap
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|map
operator|=
operator|&
name|smap
operator|->
name|s_map
expr_stmt|;
name|DYNOPENMAP
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_sendmode
operator|==
name|SM_DEFER
operator|&&
name|bitset
argument_list|(
name|MF_DEFER
argument_list|,
name|map
operator|->
name|map_mflags
argument_list|)
condition|)
block|{
comment|/* don't do any map lookups */
if|if
condition|(
name|tTd
argument_list|(
literal|60
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"map_lookup(%s, %s) => DEFERRED\n"
argument_list|,
name|smap
operator|->
name|s_name
argument_list|,
name|key
argument_list|)
expr_stmt|;
operator|*
name|pstat
operator|=
name|EX_TEMPFAIL
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|MF_KEEPQUOTES
argument_list|,
name|map
operator|->
name|map_mflags
argument_list|)
condition|)
name|stripquotes
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|60
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"map_lookup(%s, %s"
argument_list|,
name|smap
operator|->
name|s_name
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|60
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|argvect
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|sm_dprintf
argument_list|(
literal|", %%%d=%s"
argument_list|,
name|i
argument_list|,
name|argvect
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|sm_dprintf
argument_list|(
literal|") => "
argument_list|)
expr_stmt|;
block|}
name|replac
operator|=
call|(
modifier|*
name|map
operator|->
name|map_class
operator|->
name|map_lookup
call|)
argument_list|(
name|map
argument_list|,
name|key
argument_list|,
name|argvect
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|60
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"%s (%d)\n"
argument_list|,
name|replac
operator|!=
name|NULL
condition|?
name|replac
else|:
literal|"NOT FOUND"
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* should recover if status == EX_TEMPFAIL */
if|if
condition|(
name|status
operator|==
name|EX_TEMPFAIL
operator|&&
operator|!
name|bitset
argument_list|(
name|MF_NODEFER
argument_list|,
name|map
operator|->
name|map_mflags
argument_list|)
condition|)
block|{
operator|*
name|pstat
operator|=
name|EX_TEMPFAIL
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|60
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"map_lookup(%s, %s) tempfail: errno=%d\n"
argument_list|,
name|smap
operator|->
name|s_name
argument_list|,
name|key
argument_list|,
name|errno
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_message
operator|==
name|NULL
condition|)
block|{
name|char
name|mbuf
index|[
literal|320
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|mbuf
argument_list|,
sizeof|sizeof
name|mbuf
argument_list|,
literal|"%.80s map: lookup (%s): deferred"
argument_list|,
name|smap
operator|->
name|s_name
argument_list|,
name|shortenstring
argument_list|(
name|key
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_message
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
operator|==
name|EX_TEMPFAIL
operator|&&
name|map
operator|->
name|map_tapp
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|i
init|=
name|strlen
argument_list|(
name|key
argument_list|)
operator|+
name|strlen
argument_list|(
name|map
operator|->
name|map_tapp
argument_list|)
operator|+
literal|1
decl_stmt|;
specifier|static
name|char
modifier|*
name|rwbuf
init|=
name|NULL
decl_stmt|;
specifier|static
name|size_t
name|rwbuflen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|i
operator|>
name|rwbuflen
condition|)
block|{
if|if
condition|(
name|rwbuf
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|rwbuf
argument_list|)
expr_stmt|;
name|rwbuflen
operator|=
name|i
expr_stmt|;
name|rwbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|sm_pmalloc_x
argument_list|(
name|rwbuflen
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|rwbuf
argument_list|,
name|rwbuflen
argument_list|,
literal|2
argument_list|,
name|key
argument_list|,
name|map
operator|->
name|map_tapp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|60
argument_list|,
literal|4
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"map_lookup tempfail: returning \"%s\"\n"
argument_list|,
name|rwbuf
argument_list|)
expr_stmt|;
return|return
name|rwbuf
return|;
block|}
return|return
name|replac
return|;
block|}
end_function

begin_comment
comment|/* **  INITERRMAILERS -- initialize error and discard mailers ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		initializes error and discard mailers. */
end_comment

begin_decl_stmt
specifier|static
name|MAILER
name|discardmailer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|MAILER
name|errormailer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|discardargv
index|[]
init|=
block|{
literal|"DISCARD"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|errorargv
index|[]
init|=
block|{
literal|"ERROR"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|initerrmailers
parameter_list|()
block|{
if|if
condition|(
name|discardmailer
operator|.
name|m_name
operator|==
name|NULL
condition|)
block|{
comment|/* initialize the discard mailer */
name|discardmailer
operator|.
name|m_name
operator|=
literal|"*discard*"
expr_stmt|;
name|discardmailer
operator|.
name|m_mailer
operator|=
literal|"DISCARD"
expr_stmt|;
name|discardmailer
operator|.
name|m_argv
operator|=
name|discardargv
expr_stmt|;
block|}
if|if
condition|(
name|errormailer
operator|.
name|m_name
operator|==
name|NULL
condition|)
block|{
comment|/* initialize the bogus mailer */
name|errormailer
operator|.
name|m_name
operator|=
literal|"*error*"
expr_stmt|;
name|errormailer
operator|.
name|m_mailer
operator|=
literal|"ERROR"
expr_stmt|;
name|errormailer
operator|.
name|m_argv
operator|=
name|errorargv
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  BUILDADDR -- build address from token vector. ** **	Parameters: **		tv -- token vector. **		a -- pointer to address descriptor to fill. **			If NULL, one will be allocated. **		flags -- info regarding whether this is a sender or **			a recipient. **		e -- the current envelope. ** **	Returns: **		NULL if there was an error. **		'a' otherwise. ** **	Side Effects: **		fills in 'a' */
end_comment

begin_struct
specifier|static
struct|struct
name|errcodes
block|{
name|char
modifier|*
name|ec_name
decl_stmt|;
comment|/* name of error code */
name|int
name|ec_code
decl_stmt|;
comment|/* numeric code */
block|}
name|ErrorCodes
index|[]
init|=
block|{
block|{
literal|"usage"
block|,
name|EX_USAGE
block|}
block|,
block|{
literal|"nouser"
block|,
name|EX_NOUSER
block|}
block|,
block|{
literal|"nohost"
block|,
name|EX_NOHOST
block|}
block|,
block|{
literal|"unavailable"
block|,
name|EX_UNAVAILABLE
block|}
block|,
block|{
literal|"software"
block|,
name|EX_SOFTWARE
block|}
block|,
block|{
literal|"tempfail"
block|,
name|EX_TEMPFAIL
block|}
block|,
block|{
literal|"protocol"
block|,
name|EX_PROTOCOL
block|}
block|,
block|{
literal|"config"
block|,
name|EX_CONFIG
block|}
block|,
block|{
name|NULL
block|,
name|EX_UNAVAILABLE
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|ADDRESS
modifier|*
name|buildaddr
parameter_list|(
name|tv
parameter_list|,
name|a
parameter_list|,
name|flags
parameter_list|,
name|e
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|tv
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
name|int
name|flags
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|bool
name|tempfail
init|=
name|false
decl_stmt|;
name|int
name|maxatom
decl_stmt|;
name|struct
name|mailer
modifier|*
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|mailer
modifier|*
name|m
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|mname
decl_stmt|;
name|char
modifier|*
modifier|*
name|hostp
decl_stmt|;
name|char
name|hbuf
index|[
name|MAXNAME
operator|+
literal|1
index|]
decl_stmt|;
specifier|static
name|char
name|ubuf
index|[
name|MAXNAME
operator|+
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|24
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"buildaddr, flags=%x, tv="
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|printav
argument_list|(
name|tv
argument_list|)
expr_stmt|;
block|}
name|maxatom
operator|=
name|MAXATOM
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
name|a
operator|=
operator|(
name|ADDRESS
operator|*
operator|)
name|sm_rpool_malloc_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
sizeof|sizeof
expr|*
name|a
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
expr|*
name|a
argument_list|)
expr_stmt|;
name|hbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* set up default error return flags */
name|a
operator|->
name|q_flags
operator||=
name|DefaultNotify
expr_stmt|;
comment|/* figure out what net/mailer to use */
if|if
condition|(
operator|*
name|tv
operator|==
name|NULL
operator|||
operator|(
operator|*
operator|*
name|tv
operator|&
literal|0377
operator|)
operator|!=
name|CANONNET
condition|)
block|{
name|syserr
argument_list|(
literal|"554 5.3.5 buildaddr: no mailer in parsed address"
argument_list|)
expr_stmt|;
name|badaddr
label|:
if|#
directive|if
name|_FFR_ALLOW_S0_ERROR_4XX
comment|/* 		**  ExitStat may have been set by an earlier map open 		**  failure (to a permanent error (EX_OSERR) in syserr()) 		**  so we also need to check if this particular $#error 		**  return wanted a 4XX failure. 		** 		**  XXX the real fix is probably to set ExitStat correctly, 		**  i.e., to EX_TEMPFAIL if the map open is just a temporary 		**  error. 		** 		**  tempfail is tested here even if _FFR_ALLOW_S0_ERROR_4XX 		**  is not set; that's ok because it is initialized to false. 		*/
endif|#
directive|endif
comment|/* _FFR_ALLOW_S0_ERROR_4XX */
if|if
condition|(
name|ExitStat
operator|==
name|EX_TEMPFAIL
operator|||
name|tempfail
condition|)
name|a
operator|->
name|q_state
operator|=
name|QS_QUEUEUP
expr_stmt|;
else|else
block|{
name|a
operator|->
name|q_state
operator|=
name|QS_BADADDR
expr_stmt|;
name|a
operator|->
name|q_mailer
operator|=
operator|&
name|errormailer
expr_stmt|;
block|}
return|return
name|a
return|;
block|}
name|mname
operator|=
operator|*
operator|++
name|tv
expr_stmt|;
operator|--
name|maxatom
expr_stmt|;
comment|/* extract host and user portions */
if|if
condition|(
operator|*
operator|++
name|tv
operator|!=
name|NULL
operator|&&
operator|(
operator|*
operator|*
name|tv
operator|&
literal|0377
operator|)
operator|==
name|CANONHOST
condition|)
block|{
name|hostp
operator|=
operator|++
name|tv
expr_stmt|;
operator|--
name|maxatom
expr_stmt|;
block|}
else|else
name|hostp
operator|=
name|NULL
expr_stmt|;
operator|--
name|maxatom
expr_stmt|;
while|while
condition|(
operator|*
name|tv
operator|!=
name|NULL
operator|&&
operator|(
operator|*
operator|*
name|tv
operator|&
literal|0377
operator|)
operator|!=
name|CANONUSER
condition|)
block|{
name|tv
operator|++
expr_stmt|;
operator|--
name|maxatom
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|tv
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"554 5.3.5 buildaddr: no user"
argument_list|)
expr_stmt|;
goto|goto
name|badaddr
goto|;
block|}
if|if
condition|(
name|tv
operator|==
name|hostp
condition|)
name|hostp
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|hostp
operator|!=
name|NULL
condition|)
name|cataddr
argument_list|(
name|hostp
argument_list|,
name|tv
operator|-
literal|1
argument_list|,
name|hbuf
argument_list|,
sizeof|sizeof
name|hbuf
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|cataddr
argument_list|(
operator|++
name|tv
argument_list|,
name|NULL
argument_list|,
name|ubuf
argument_list|,
sizeof|sizeof
name|ubuf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|--
name|maxatom
expr_stmt|;
comment|/* save away the host name */
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|mname
argument_list|,
literal|"error"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Set up triplet for use by -bv */
name|a
operator|->
name|q_mailer
operator|=
operator|&
name|errormailer
expr_stmt|;
name|a
operator|->
name|q_user
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|ubuf
argument_list|)
expr_stmt|;
comment|/* XXX wrong place? */
if|if
condition|(
name|hostp
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|struct
name|errcodes
modifier|*
name|ep
decl_stmt|;
name|a
operator|->
name|q_host
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|hbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|hbuf
argument_list|,
literal|'.'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|a
operator|->
name|q_status
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|hbuf
argument_list|)
expr_stmt|;
name|setstat
argument_list|(
name|dsntoexitstat
argument_list|(
name|hbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isascii
argument_list|(
name|hbuf
index|[
literal|0
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|hbuf
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|setstat
argument_list|(
name|atoi
argument_list|(
name|hbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|ep
operator|=
name|ErrorCodes
init|;
name|ep
operator|->
name|ec_name
operator|!=
name|NULL
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|ep
operator|->
name|ec_name
argument_list|,
name|hbuf
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|setstat
argument_list|(
name|ep
operator|->
name|ec_code
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|a
operator|->
name|q_host
operator|=
name|NULL
expr_stmt|;
name|setstat
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
name|stripquotes
argument_list|(
name|ubuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISSMTPCODE
argument_list|(
name|ubuf
argument_list|)
operator|&&
name|ubuf
index|[
literal|3
index|]
operator|==
literal|' '
condition|)
block|{
name|char
name|fmt
index|[
literal|16
index|]
decl_stmt|;
name|int
name|off
decl_stmt|;
if|if
condition|(
operator|(
name|off
operator|=
name|isenhsc
argument_list|(
name|ubuf
operator|+
literal|4
argument_list|,
literal|' '
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|ubuf
index|[
name|off
operator|+
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
name|off
operator|+=
literal|5
expr_stmt|;
block|}
else|else
block|{
name|off
operator|=
literal|4
expr_stmt|;
name|ubuf
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|fmt
argument_list|,
sizeof|sizeof
name|fmt
argument_list|,
literal|2
argument_list|,
name|ubuf
argument_list|,
literal|" %s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|>
literal|4
condition|)
name|usrerr
argument_list|(
name|fmt
argument_list|,
name|ubuf
operator|+
name|off
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isenhsc
argument_list|(
name|hbuf
argument_list|,
literal|'\0'
argument_list|)
operator|>
literal|0
condition|)
name|usrerrenh
argument_list|(
name|hbuf
argument_list|,
name|fmt
argument_list|,
name|ubuf
operator|+
name|off
argument_list|)
expr_stmt|;
else|else
name|usrerr
argument_list|(
name|fmt
argument_list|,
name|ubuf
operator|+
name|off
argument_list|)
expr_stmt|;
comment|/* XXX ubuf[off - 1] = ' '; */
if|#
directive|if
name|_FFR_ALLOW_S0_ERROR_4XX
if|if
condition|(
name|ubuf
index|[
literal|0
index|]
operator|==
literal|'4'
condition|)
name|tempfail
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_ALLOW_S0_ERROR_4XX */
block|}
else|else
block|{
name|usrerr
argument_list|(
literal|"553 5.3.0 %s"
argument_list|,
name|ubuf
argument_list|)
expr_stmt|;
block|}
goto|goto
name|badaddr
goto|;
block|}
for|for
control|(
name|mp
operator|=
name|Mailer
init|;
operator|(
name|m
operator|=
operator|*
name|mp
operator|++
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|m
operator|->
name|m_name
argument_list|,
name|mname
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"554 5.3.5 buildaddr: unknown mailer %s"
argument_list|,
name|mname
argument_list|)
expr_stmt|;
goto|goto
name|badaddr
goto|;
block|}
name|a
operator|->
name|q_mailer
operator|=
name|m
expr_stmt|;
comment|/* figure out what host (if any) */
if|if
condition|(
name|hostp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|M_LOCALMAILER
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
name|syserr
argument_list|(
literal|"554 5.3.5 buildaddr: no host"
argument_list|)
expr_stmt|;
goto|goto
name|badaddr
goto|;
block|}
name|a
operator|->
name|q_host
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|a
operator|->
name|q_host
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|hbuf
argument_list|)
expr_stmt|;
comment|/* figure out the user */
name|p
operator|=
name|ubuf
expr_stmt|;
if|if
condition|(
name|bitnset
argument_list|(
name|M_CHECKUDB
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|&&
operator|*
name|p
operator|==
literal|'@'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|tv
operator|++
expr_stmt|;
operator|--
name|maxatom
expr_stmt|;
name|a
operator|->
name|q_flags
operator||=
name|QNOTREMOTE
expr_stmt|;
block|}
comment|/* do special mapping for local mailer */
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'|'
operator|&&
name|bitnset
argument_list|(
name|M_CHECKPROG
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|a
operator|->
name|q_mailer
operator|=
name|m
operator|=
name|ProgMailer
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
operator|&&
name|bitnset
argument_list|(
name|M_CHECKFILE
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|a
operator|->
name|q_mailer
operator|=
name|m
operator|=
name|FileMailer
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
operator|&&
name|bitnset
argument_list|(
name|M_CHECKINCLUDE
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
comment|/* may be :include: */
name|stripquotes
argument_list|(
name|ubuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm_strncasecmp
argument_list|(
name|ubuf
argument_list|,
literal|":include:"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* if :include:, don't need further rewriting */
name|a
operator|->
name|q_mailer
operator|=
name|m
operator|=
name|InclMailer
expr_stmt|;
name|a
operator|->
name|q_user
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
operator|&
name|ubuf
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
return|return
name|a
return|;
block|}
block|}
comment|/* rewrite according recipient mailer rewriting rules */
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'h'
argument_list|,
name|a
operator|->
name|q_host
argument_list|)
expr_stmt|;
if|if
condition|(
name|ConfigLevel
operator|>=
literal|10
operator|||
operator|!
name|bitset
argument_list|(
name|RF_SENDERADDR
operator||
name|RF_HEADERADDR
argument_list|,
name|flags
argument_list|)
condition|)
block|{
comment|/* sender addresses done later */
operator|(
name|void
operator|)
name|rewrite
argument_list|(
name|tv
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|e
argument_list|,
name|maxatom
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_re_rwset
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|rewrite
argument_list|(
name|tv
argument_list|,
name|m
operator|->
name|m_re_rwset
argument_list|,
literal|0
argument_list|,
name|e
argument_list|,
name|maxatom
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|rewrite
argument_list|(
name|tv
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|e
argument_list|,
name|maxatom
argument_list|)
expr_stmt|;
comment|/* save the result for the command line/RCPT argument */
name|cataddr
argument_list|(
name|tv
argument_list|,
name|NULL
argument_list|,
name|ubuf
argument_list|,
sizeof|sizeof
name|ubuf
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_user
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|ubuf
argument_list|)
expr_stmt|;
comment|/* 	**  Do mapping to lower case as requested by mailer 	*/
if|if
condition|(
name|a
operator|->
name|q_host
operator|!=
name|NULL
operator|&&
operator|!
name|bitnset
argument_list|(
name|M_HST_UPPER
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|makelower
argument_list|(
name|a
operator|->
name|q_host
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|M_USR_UPPER
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|makelower
argument_list|(
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|24
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"buildaddr => "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|a
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
return|return
name|a
return|;
block|}
end_function

begin_comment
comment|/* **  CATADDR -- concatenate pieces of addresses (putting in<LWSP> subs) ** **	Parameters: **		pvp -- parameter vector to rebuild. **		evp -- last parameter to include.  Can be NULL to **			use entire pvp. **		buf -- buffer to build the string into. **		sz -- size of buf. **		spacesub -- the space separator character; if '\0', **			use SpaceSub. ** **	Returns: **		none. ** **	Side Effects: **		Destroys buf. */
end_comment

begin_function
name|void
name|cataddr
parameter_list|(
name|pvp
parameter_list|,
name|evp
parameter_list|,
name|buf
parameter_list|,
name|sz
parameter_list|,
name|spacesub
parameter_list|)
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
name|char
modifier|*
modifier|*
name|evp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
specifier|register
name|int
name|sz
decl_stmt|;
name|int
name|spacesub
decl_stmt|;
block|{
name|bool
name|oatomtok
init|=
name|false
decl_stmt|;
name|bool
name|natomtok
init|=
name|false
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|sz
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|spacesub
operator|==
literal|'\0'
condition|)
name|spacesub
operator|=
name|SpaceSub
expr_stmt|;
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
block|{
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|buf
expr_stmt|;
name|sz
operator|-=
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|pvp
operator|!=
name|NULL
operator|&&
name|sz
operator|>
literal|0
condition|)
block|{
name|natomtok
operator|=
operator|(
name|TokTypeTab
index|[
operator|*
operator|*
name|pvp
operator|&
literal|0xff
index|]
operator|==
name|ATM
operator|)
expr_stmt|;
if|if
condition|(
name|oatomtok
operator|&&
name|natomtok
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|spacesub
expr_stmt|;
if|if
condition|(
operator|--
name|sz
operator|<=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|i
operator|=
name|sm_strlcpy
argument_list|(
name|p
argument_list|,
operator|*
name|pvp
argument_list|,
name|sz
argument_list|)
operator|)
operator|>=
name|sz
condition|)
break|break;
name|oatomtok
operator|=
name|natomtok
expr_stmt|;
name|p
operator|+=
name|i
expr_stmt|;
name|sz
operator|-=
name|i
expr_stmt|;
if|if
condition|(
name|pvp
operator|++
operator|==
name|evp
condition|)
break|break;
block|}
if|#
directive|if
name|_FFR_CATCH_LONG_STRINGS
comment|/* Don't silently truncate long strings; broken for evp != NULL */
if|if
condition|(
operator|*
name|pvp
operator|!=
name|NULL
condition|)
name|syserr
argument_list|(
literal|"cataddr: string too long"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_CATCH_LONG_STRINGS */
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  SAMEADDR -- Determine if two addresses are the same ** **	This is not just a straight comparison -- if the mailer doesn't **	care about the host we just ignore it, etc. ** **	Parameters: **		a, b -- pointers to the internal forms to compare. ** **	Returns: **		true -- they represent the same mailbox. **		false -- they don't. ** **	Side Effects: **		none. */
end_comment

begin_function
name|bool
name|sameaddr
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|b
decl_stmt|;
block|{
specifier|register
name|ADDRESS
modifier|*
name|ca
decl_stmt|,
modifier|*
name|cb
decl_stmt|;
comment|/* if they don't have the same mailer, forget it */
if|if
condition|(
name|a
operator|->
name|q_mailer
operator|!=
name|b
operator|->
name|q_mailer
condition|)
return|return
name|false
return|;
comment|/* if the user isn't the same, we can drop out */
if|if
condition|(
name|strcmp
argument_list|(
name|a
operator|->
name|q_user
argument_list|,
name|b
operator|->
name|q_user
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
comment|/* if we have good uids for both but they differ, these are different */
if|if
condition|(
name|a
operator|->
name|q_mailer
operator|==
name|ProgMailer
condition|)
block|{
name|ca
operator|=
name|getctladdr
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|cb
operator|=
name|getctladdr
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|ca
operator|!=
name|NULL
operator|&&
name|cb
operator|!=
name|NULL
operator|&&
name|bitset
argument_list|(
name|QGOODUID
argument_list|,
name|ca
operator|->
name|q_flags
operator|&
name|cb
operator|->
name|q_flags
argument_list|)
operator|&&
name|ca
operator|->
name|q_uid
operator|!=
name|cb
operator|->
name|q_uid
condition|)
return|return
name|false
return|;
block|}
comment|/* otherwise compare hosts (but be careful for NULL ptrs) */
if|if
condition|(
name|a
operator|->
name|q_host
operator|==
name|b
operator|->
name|q_host
condition|)
block|{
comment|/* probably both null pointers */
return|return
name|true
return|;
block|}
if|if
condition|(
name|a
operator|->
name|q_host
operator|==
name|NULL
operator|||
name|b
operator|->
name|q_host
operator|==
name|NULL
condition|)
block|{
comment|/* only one is a null pointer */
return|return
name|false
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|a
operator|->
name|q_host
argument_list|,
name|b
operator|->
name|q_host
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* **  PRINTADDR -- print address (for debugging) ** **	Parameters: **		a -- the address to print **		follow -- follow the q_next chain. ** **	Returns: **		none. ** **	Side Effects: **		none. */
end_comment

begin_struct
struct|struct
name|qflags
block|{
name|char
modifier|*
name|qf_name
decl_stmt|;
name|unsigned
name|long
name|qf_bit
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|qflags
name|AddressFlags
index|[]
init|=
block|{
block|{
literal|"QGOODUID"
block|,
name|QGOODUID
block|}
block|,
block|{
literal|"QPRIMARY"
block|,
name|QPRIMARY
block|}
block|,
block|{
literal|"QNOTREMOTE"
block|,
name|QNOTREMOTE
block|}
block|,
block|{
literal|"QSELFREF"
block|,
name|QSELFREF
block|}
block|,
block|{
literal|"QBOGUSSHELL"
block|,
name|QBOGUSSHELL
block|}
block|,
block|{
literal|"QUNSAFEADDR"
block|,
name|QUNSAFEADDR
block|}
block|,
block|{
literal|"QPINGONSUCCESS"
block|,
name|QPINGONSUCCESS
block|}
block|,
block|{
literal|"QPINGONFAILURE"
block|,
name|QPINGONFAILURE
block|}
block|,
block|{
literal|"QPINGONDELAY"
block|,
name|QPINGONDELAY
block|}
block|,
block|{
literal|"QHASNOTIFY"
block|,
name|QHASNOTIFY
block|}
block|,
block|{
literal|"QRELAYED"
block|,
name|QRELAYED
block|}
block|,
block|{
literal|"QEXPANDED"
block|,
name|QEXPANDED
block|}
block|,
block|{
literal|"QDELIVERED"
block|,
name|QDELIVERED
block|}
block|,
block|{
literal|"QDELAYED"
block|,
name|QDELAYED
block|}
block|,
block|{
literal|"QTHISPASS"
block|,
name|QTHISPASS
block|}
block|,
block|{
literal|"QRCPTOK"
block|,
name|QRCPTOK
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|printaddr
parameter_list|(
name|a
parameter_list|,
name|follow
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
name|bool
name|follow
decl_stmt|;
block|{
specifier|register
name|MAILER
modifier|*
name|m
decl_stmt|;
name|MAILER
name|pseudomailer
decl_stmt|;
specifier|register
name|struct
name|qflags
modifier|*
name|qfp
decl_stmt|;
name|bool
name|firstone
decl_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"[NULL]\n"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|a
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%p="
argument_list|,
name|a
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_flush
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
comment|/* find the mailer -- carefully */
name|m
operator|=
name|a
operator|->
name|q_mailer
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
operator|&
name|pseudomailer
expr_stmt|;
name|m
operator|->
name|m_mno
operator|=
operator|-
literal|1
expr_stmt|;
name|m
operator|->
name|m_name
operator|=
literal|"NULL"
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s:\n\tmailer %d (%s), host `%s'\n"
argument_list|,
name|a
operator|->
name|q_paddr
operator|==
name|NULL
condition|?
literal|"<null>"
else|:
name|a
operator|->
name|q_paddr
argument_list|,
name|m
operator|->
name|m_mno
argument_list|,
name|m
operator|->
name|m_name
argument_list|,
name|a
operator|->
name|q_host
operator|==
name|NULL
condition|?
literal|"<null>"
else|:
name|a
operator|->
name|q_host
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\tuser `%s', ruser `%s'\n"
argument_list|,
name|a
operator|->
name|q_user
argument_list|,
name|a
operator|->
name|q_ruser
operator|==
name|NULL
condition|?
literal|"<null>"
else|:
name|a
operator|->
name|q_ruser
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\tstate="
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|a
operator|->
name|q_state
condition|)
block|{
case|case
name|QS_OK
case|:
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"OK"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QS_DONTSEND
case|:
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"DONTSEND"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QS_BADADDR
case|:
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"BADADDR"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QS_QUEUEUP
case|:
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"QUEUEUP"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QS_RETRY
case|:
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"RETRY"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QS_SENT
case|:
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"SENT"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QS_VERIFIED
case|:
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"VERIFIED"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QS_EXPANDED
case|:
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"EXPANDED"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QS_SENDER
case|:
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"SENDER"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QS_CLONED
case|:
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"CLONED"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QS_DISCARDED
case|:
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"DISCARDED"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QS_REPLACED
case|:
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"REPLACED"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QS_REMOVED
case|:
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"REMOVED"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QS_DUPLICATE
case|:
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"DUPLICATE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QS_INCLUDED
case|:
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"INCLUDED"
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%d"
argument_list|,
name|a
operator|->
name|q_state
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|", next=%p, alias %p, uid %d, gid %d\n"
argument_list|,
name|a
operator|->
name|q_next
argument_list|,
name|a
operator|->
name|q_alias
argument_list|,
operator|(
name|int
operator|)
name|a
operator|->
name|q_uid
argument_list|,
operator|(
name|int
operator|)
name|a
operator|->
name|q_gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\tflags=%lx<"
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
expr_stmt|;
name|firstone
operator|=
name|true
expr_stmt|;
for|for
control|(
name|qfp
operator|=
name|AddressFlags
init|;
name|qfp
operator|->
name|qf_name
operator|!=
name|NULL
condition|;
name|qfp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|qfp
operator|->
name|qf_bit
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|firstone
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|firstone
operator|=
name|false
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s"
argument_list|,
name|qfp
operator|->
name|qf_name
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|">\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\towner=%s, home=\"%s\", fullname=\"%s\"\n"
argument_list|,
name|a
operator|->
name|q_owner
operator|==
name|NULL
condition|?
literal|"(none)"
else|:
name|a
operator|->
name|q_owner
argument_list|,
name|a
operator|->
name|q_home
operator|==
name|NULL
condition|?
literal|"(none)"
else|:
name|a
operator|->
name|q_home
argument_list|,
name|a
operator|->
name|q_fullname
operator|==
name|NULL
condition|?
literal|"(none)"
else|:
name|a
operator|->
name|q_fullname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\torcpt=\"%s\", statmta=%s, status=%s\n"
argument_list|,
name|a
operator|->
name|q_orcpt
operator|==
name|NULL
condition|?
literal|"(none)"
else|:
name|a
operator|->
name|q_orcpt
argument_list|,
name|a
operator|->
name|q_statmta
operator|==
name|NULL
condition|?
literal|"(none)"
else|:
name|a
operator|->
name|q_statmta
argument_list|,
name|a
operator|->
name|q_status
operator|==
name|NULL
condition|?
literal|"(none)"
else|:
name|a
operator|->
name|q_status
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\tfinalrcpt=\"%s\"\n"
argument_list|,
name|a
operator|->
name|q_finalrcpt
operator|==
name|NULL
condition|?
literal|"(none)"
else|:
name|a
operator|->
name|q_finalrcpt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\trstatus=\"%s\"\n"
argument_list|,
name|a
operator|->
name|q_rstatus
operator|==
name|NULL
condition|?
literal|"(none)"
else|:
name|a
operator|->
name|q_rstatus
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\tstatdate=%s\n"
argument_list|,
name|a
operator|->
name|q_statdate
operator|==
literal|0
condition|?
literal|"(none)"
else|:
name|ctime
argument_list|(
operator|&
name|a
operator|->
name|q_statdate
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|follow
condition|)
return|return;
name|a
operator|=
name|a
operator|->
name|q_next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  EMPTYADDR -- return true if this address is empty (``<>'') ** **	Parameters: **		a -- pointer to the address ** **	Returns: **		true -- if this address is "empty" (i.e., no one should **			ever generate replies to it. **		false -- if it is a "regular" (read: replyable) address. */
end_comment

begin_function
name|bool
name|emptyaddr
parameter_list|(
name|a
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
block|{
return|return
name|a
operator|->
name|q_paddr
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|a
operator|->
name|q_paddr
argument_list|,
literal|"<>"
argument_list|)
operator|==
literal|0
operator|||
name|a
operator|->
name|q_user
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|a
operator|->
name|q_user
argument_list|,
literal|"<>"
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* **  REMOTENAME -- return the name relative to the current mailer ** **	Parameters: **		name -- the name to translate. **		m -- the mailer that we want to do rewriting relative to. **		flags -- fine tune operations. **		pstat -- pointer to status word. **		e -- the current envelope. ** **	Returns: **		the text string representing this address relative to **			the receiving mailer. ** **	Side Effects: **		none. ** **	Warnings: **		The text string returned is tucked away locally; **			copy it if you intend to save it. */
end_comment

begin_function
name|char
modifier|*
name|remotename
parameter_list|(
name|name
parameter_list|,
name|m
parameter_list|,
name|flags
parameter_list|,
name|pstat
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|mailer
modifier|*
name|m
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
modifier|*
name|pstat
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
name|char
modifier|*
name|SM_NONVOLATILE
name|fancy
decl_stmt|;
name|char
modifier|*
name|oldg
decl_stmt|;
name|int
name|rwset
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|MAXNAME
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|lbuf
index|[
name|MAXNAME
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|pvpbuf
index|[
name|PSBUFSIZE
index|]
decl_stmt|;
name|char
name|addrtype
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|12
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"remotename(%s)\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* don't do anything if we are tagging it as special */
if|if
condition|(
name|bitset
argument_list|(
name|RF_SENDERADDR
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|rwset
operator|=
name|bitset
argument_list|(
name|RF_HEADERADDR
argument_list|,
name|flags
argument_list|)
condition|?
name|m
operator|->
name|m_sh_rwset
else|:
name|m
operator|->
name|m_se_rwset
expr_stmt|;
name|addrtype
index|[
literal|2
index|]
operator|=
literal|'s'
expr_stmt|;
block|}
else|else
block|{
name|rwset
operator|=
name|bitset
argument_list|(
name|RF_HEADERADDR
argument_list|,
name|flags
argument_list|)
condition|?
name|m
operator|->
name|m_rh_rwset
else|:
name|m
operator|->
name|m_re_rwset
expr_stmt|;
name|addrtype
index|[
literal|2
index|]
operator|=
literal|'r'
expr_stmt|;
block|}
if|if
condition|(
name|rwset
operator|<
literal|0
condition|)
return|return
name|name
return|;
name|addrtype
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|addrtype
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|addrtype
index|[
literal|0
index|]
operator|=
name|bitset
argument_list|(
name|RF_HEADERADDR
argument_list|,
name|flags
argument_list|)
condition|?
literal|'h'
else|:
literal|'e'
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{addr_type}"
argument_list|)
argument_list|,
name|addrtype
argument_list|)
expr_stmt|;
comment|/* 	**  Do a heuristic crack of this name to extract any comment info. 	**	This will leave the name as a comment and a $g macro. 	*/
if|if
condition|(
name|bitset
argument_list|(
name|RF_CANONICAL
argument_list|,
name|flags
argument_list|)
operator|||
name|bitnset
argument_list|(
name|M_NOCOMMENT
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|fancy
operator|=
literal|"\201g"
expr_stmt|;
else|else
name|fancy
operator|=
name|crackaddr
argument_list|(
name|name
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* 	**  Turn the name into canonical form. 	**	Normally this will be RFC 822 style, i.e., "user@domain". 	**	If this only resolves to "user", and the "C" flag is 	**	specified in the sending mailer, then the sender's 	**	domain will be appended. 	*/
name|pvp
operator|=
name|prescan
argument_list|(
name|name
argument_list|,
literal|'\0'
argument_list|,
name|pvpbuf
argument_list|,
sizeof|sizeof
name|pvpbuf
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
return|return
name|name
return|;
if|if
condition|(
name|REWRITE
argument_list|(
name|pvp
argument_list|,
literal|3
argument_list|,
name|e
argument_list|)
operator|==
name|EX_TEMPFAIL
condition|)
operator|*
name|pstat
operator|=
name|EX_TEMPFAIL
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RF_ADDDOMAIN
argument_list|,
name|flags
argument_list|)
operator|&&
name|e
operator|->
name|e_fromdomain
operator|!=
name|NULL
condition|)
block|{
comment|/* append from domain to this address */
specifier|register
name|char
modifier|*
modifier|*
name|pxp
init|=
name|pvp
decl_stmt|;
name|int
name|l
init|=
name|MAXATOM
decl_stmt|;
comment|/* size of buffer for pvp */
comment|/* see if there is an "@domain" in the current name */
while|while
condition|(
operator|*
name|pxp
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
operator|*
name|pxp
argument_list|,
literal|"@"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|pxp
operator|++
expr_stmt|;
operator|--
name|l
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|pxp
operator|==
name|NULL
condition|)
block|{
comment|/* no.... append the "@domain" from the sender */
specifier|register
name|char
modifier|*
modifier|*
name|qxq
init|=
name|e
operator|->
name|e_fromdomain
decl_stmt|;
while|while
condition|(
operator|(
operator|*
name|pxp
operator|++
operator|=
operator|*
name|qxq
operator|++
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|--
name|l
operator|<=
literal|0
condition|)
block|{
operator|*
operator|--
name|pxp
operator|=
name|NULL
expr_stmt|;
name|usrerr
argument_list|(
literal|"553 5.1.0 remotename: too many tokens"
argument_list|)
expr_stmt|;
operator|*
name|pstat
operator|=
name|EX_UNAVAILABLE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|REWRITE
argument_list|(
name|pvp
argument_list|,
literal|3
argument_list|,
name|e
argument_list|)
operator|==
name|EX_TEMPFAIL
condition|)
operator|*
name|pstat
operator|=
name|EX_TEMPFAIL
expr_stmt|;
block|}
block|}
comment|/* 	**  Do more specific rewriting. 	**	Rewrite using ruleset 1 or 2 depending on whether this is 	**		a sender address or not. 	**	Then run it through any receiving-mailer-specific rulesets. 	*/
if|if
condition|(
name|bitset
argument_list|(
name|RF_SENDERADDR
argument_list|,
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|REWRITE
argument_list|(
name|pvp
argument_list|,
literal|1
argument_list|,
name|e
argument_list|)
operator|==
name|EX_TEMPFAIL
condition|)
operator|*
name|pstat
operator|=
name|EX_TEMPFAIL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|REWRITE
argument_list|(
name|pvp
argument_list|,
literal|2
argument_list|,
name|e
argument_list|)
operator|==
name|EX_TEMPFAIL
condition|)
operator|*
name|pstat
operator|=
name|EX_TEMPFAIL
expr_stmt|;
block|}
if|if
condition|(
name|rwset
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|REWRITE
argument_list|(
name|pvp
argument_list|,
name|rwset
argument_list|,
name|e
argument_list|)
operator|==
name|EX_TEMPFAIL
condition|)
operator|*
name|pstat
operator|=
name|EX_TEMPFAIL
expr_stmt|;
block|}
comment|/* 	**  Do any final sanitation the address may require. 	**	This will normally be used to turn internal forms 	**	(e.g., user@host.LOCAL) into external form.  This 	**	may be used as a default to the above rules. 	*/
if|if
condition|(
name|REWRITE
argument_list|(
name|pvp
argument_list|,
literal|4
argument_list|,
name|e
argument_list|)
operator|==
name|EX_TEMPFAIL
condition|)
operator|*
name|pstat
operator|=
name|EX_TEMPFAIL
expr_stmt|;
comment|/* 	**  Now restore the comment information we had at the beginning. 	*/
name|cataddr
argument_list|(
name|pvp
argument_list|,
name|NULL
argument_list|,
name|lbuf
argument_list|,
sizeof|sizeof
name|lbuf
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|oldg
operator|=
name|macget
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
literal|'g'
argument_list|)
expr_stmt|;
name|macset
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
literal|'g'
argument_list|,
name|lbuf
argument_list|)
expr_stmt|;
name|SM_TRY
comment|/* need to make sure route-addrs have<angle brackets> */
if|if
condition|(
name|bitset
argument_list|(
name|RF_CANONICAL
argument_list|,
name|flags
argument_list|)
operator|&&
name|lbuf
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
name|expand
argument_list|(
literal|"<\201g>"
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|e
argument_list|)
expr_stmt|;
else|else
name|expand
argument_list|(
name|fancy
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|SM_FINALLY
name|macset
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
literal|'g'
argument_list|,
name|oldg
argument_list|)
decl_stmt|;
name|SM_END_TRY
if|if
condition|(
name|tTd
argument_list|(
literal|12
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"remotename => `%s'\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* **  MAPLOCALUSER -- run local username through ruleset 5 for final redirection ** **	Parameters: **		a -- the address to map (but just the user name part). **		sendq -- the sendq in which to install any replacement **			addresses. **		aliaslevel -- the alias nesting depth. **		e -- the envelope. ** **	Returns: **		none. */
end_comment

begin_define
define|#
directive|define
name|Q_COPYFLAGS
value|(QPRIMARY|QBOGUSSHELL|QUNSAFEADDR|\ 			 Q_PINGFLAGS|QHASNOTIFY|\ 			 QRELAYED|QEXPANDED|QDELIVERED|QDELAYED|\ 			 QBYTRACE|QBYNDELAY|QBYNRELAY)
end_define

begin_function
name|void
name|maplocaluser
parameter_list|(
name|a
parameter_list|,
name|sendq
parameter_list|,
name|aliaslevel
parameter_list|,
name|e
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
name|ADDRESS
modifier|*
modifier|*
name|sendq
decl_stmt|;
name|int
name|aliaslevel
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|SM_NONVOLATILE
name|a1
init|=
name|NULL
decl_stmt|;
name|char
name|pvpbuf
index|[
name|PSBUFSIZE
index|]
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"maplocaluser: "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|a
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|pvp
operator|=
name|prescan
argument_list|(
name|a
operator|->
name|q_user
argument_list|,
literal|'\0'
argument_list|,
name|pvpbuf
argument_list|,
sizeof|sizeof
name|pvpbuf
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|9
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"maplocaluser: cannot prescan %s\n"
argument_list|,
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
return|return;
block|}
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'h'
argument_list|,
name|a
operator|->
name|q_host
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'u'
argument_list|,
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'z'
argument_list|,
name|a
operator|->
name|q_home
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{addr_type}"
argument_list|)
argument_list|,
literal|"e r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|REWRITE
argument_list|(
name|pvp
argument_list|,
literal|5
argument_list|,
name|e
argument_list|)
operator|==
name|EX_TEMPFAIL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|9
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"maplocaluser: rewrite tempfail\n"
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_state
operator|=
name|QS_QUEUEUP
expr_stmt|;
name|a
operator|->
name|q_status
operator|=
literal|"4.4.3"
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pvp
index|[
literal|0
index|]
operator|==
name|NULL
operator|||
operator|(
name|pvp
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|&
literal|0377
operator|)
operator|!=
name|CANONNET
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|9
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"maplocaluser: doesn't resolve\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|SM_TRY
name|a1
init|=
name|buildaddr
argument_list|(
name|pvp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|SM_EXCEPT
argument_list|(
argument|exc
argument_list|,
literal|"E:mta.quickabort"
argument_list|)
comment|/* 		**  mark address as bad, S5 returned an error 		**	and we gave that back to the SMTP client. 		*/
name|a
operator|->
name|q_state
operator|=
name|QS_DONTSEND
expr_stmt|;
name|sm_exc_raisenew_x
argument_list|(
operator|&
name|EtypeQuickAbort
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|SM_END_TRY
comment|/* if non-null, mailer destination specified -- has it changed? */
if|if
condition|(
name|a1
operator|==
name|NULL
operator|||
name|sameaddr
argument_list|(
name|a
argument_list|,
name|a1
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|9
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"maplocaluser: address unchanged\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* make new address take on flags and print attributes of old */
name|a1
operator|->
name|q_flags
operator|&=
operator|~
name|Q_COPYFLAGS
expr_stmt|;
name|a1
operator|->
name|q_flags
operator||=
name|a
operator|->
name|q_flags
operator|&
name|Q_COPYFLAGS
expr_stmt|;
name|a1
operator|->
name|q_paddr
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|a
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
name|a1
operator|->
name|q_finalrcpt
operator|=
name|a
operator|->
name|q_finalrcpt
expr_stmt|;
name|a1
operator|->
name|q_orcpt
operator|=
name|a
operator|->
name|q_orcpt
expr_stmt|;
comment|/* mark old address as dead; insert new address */
name|a
operator|->
name|q_state
operator|=
name|QS_REPLACED
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"maplocaluser: QS_REPLACED "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|a
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|a1
operator|->
name|q_alias
operator|=
name|a
expr_stmt|;
name|allocaddr
argument_list|(
name|a1
argument_list|,
name|RF_COPYALL
argument_list|,
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|a
operator|->
name|q_paddr
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|recipient
argument_list|(
name|a1
argument_list|,
name|sendq
argument_list|,
name|aliaslevel
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  DEQUOTE_INIT -- initialize dequote map ** **	Parameters: **		map -- the internal map structure. **		args -- arguments. ** **	Returns: **		true. */
end_comment

begin_function
name|bool
name|dequote_init
parameter_list|(
name|map
parameter_list|,
name|args
parameter_list|)
name|MAP
modifier|*
name|map
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
comment|/* there is no check whether there is really an argument */
name|map
operator|->
name|map_mflags
operator||=
name|MF_KEEPQUOTES
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'-'
condition|)
break|break;
switch|switch
condition|(
operator|*
operator|++
name|p
condition|)
block|{
case|case
literal|'a'
case|:
name|map
operator|->
name|map_app
operator|=
operator|++
name|p
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|map
operator|->
name|map_mflags
operator||=
name|MF_DEFER
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
name|map
operator|->
name|map_spacesub
operator|=
operator|*
operator|++
name|p
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|map
operator|->
name|map_app
operator|!=
name|NULL
condition|)
name|map
operator|->
name|map_app
operator|=
name|newstr
argument_list|(
name|map
operator|->
name|map_app
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* **  DEQUOTE_MAP -- unquote an address ** **	Parameters: **		map -- the internal map structure (ignored). **		name -- the name to dequote. **		av -- arguments (ignored). **		statp -- pointer to status out-parameter. ** **	Returns: **		NULL -- if there were no quotes, or if the resulting **			unquoted buffer would not be acceptable to prescan. **		else -- The dequoted buffer. */
end_comment

begin_comment
comment|/* ARGSUSED2 */
end_comment

begin_function
name|char
modifier|*
name|dequote_map
parameter_list|(
name|map
parameter_list|,
name|name
parameter_list|,
name|av
parameter_list|,
name|statp
parameter_list|)
name|MAP
modifier|*
name|map
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
name|int
modifier|*
name|statp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|int
name|anglecnt
init|=
literal|0
decl_stmt|;
name|int
name|cmntcnt
init|=
literal|0
decl_stmt|;
name|int
name|quotecnt
init|=
literal|0
decl_stmt|;
name|int
name|spacecnt
init|=
literal|0
decl_stmt|;
name|bool
name|quotemode
init|=
name|false
decl_stmt|;
name|bool
name|bslashmode
init|=
name|false
decl_stmt|;
name|char
name|spacesub
init|=
name|map
operator|->
name|map_spacesub
decl_stmt|;
for|for
control|(
name|p
operator|=
name|q
operator|=
name|name
init|;
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
condition|;
control|)
block|{
if|if
condition|(
name|bslashmode
condition|)
block|{
name|bslashmode
operator|=
name|false
expr_stmt|;
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|' '
operator|&&
name|spacesub
operator|!=
literal|'\0'
condition|)
name|c
operator|=
name|spacesub
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
name|bslashmode
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|cmntcnt
operator|++
expr_stmt|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
name|cmntcnt
operator|--
operator|<=
literal|0
condition|)
return|return
name|NULL
return|;
break|break;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
name|spacecnt
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cmntcnt
operator|>
literal|0
condition|)
block|{
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'"'
case|:
name|quotemode
operator|=
operator|!
name|quotemode
expr_stmt|;
name|quotecnt
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'<'
case|:
name|anglecnt
operator|++
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|anglecnt
operator|--
operator|<=
literal|0
condition|)
return|return
name|NULL
return|;
break|break;
block|}
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|anglecnt
operator|!=
literal|0
operator|||
name|cmntcnt
operator|!=
literal|0
operator|||
name|bslashmode
operator|||
name|quotemode
operator|||
name|quotecnt
operator|<=
literal|0
operator|||
name|spacecnt
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
name|map_rewrite
argument_list|(
name|map
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  RSCHECK -- check string(s) for validity using rewriting sets ** **	Parameters: **		rwset -- the rewriting set to use. **		p1 -- the first string to check. **		p2 -- the second string to check -- may be null. **		e -- the current envelope. **		flags -- control some behavior, see RSF_ in sendmail.h **		logl -- logging level. **		host -- NULL or relay host. **		logid -- id for sm_syslog. ** **	Returns: **		EX_OK -- if the rwset doesn't resolve to $#error **		else -- the failure status (message printed) */
end_comment

begin_function
name|int
name|rscheck
parameter_list|(
name|rwset
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|,
name|e
parameter_list|,
name|flags
parameter_list|,
name|logl
parameter_list|,
name|host
parameter_list|,
name|logid
parameter_list|)
name|char
modifier|*
name|rwset
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
name|char
modifier|*
name|p2
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|logl
decl_stmt|;
name|char
modifier|*
name|host
decl_stmt|;
name|char
modifier|*
name|logid
decl_stmt|;
block|{
name|char
modifier|*
specifier|volatile
name|buf
decl_stmt|;
name|int
name|bufsize
decl_stmt|;
name|int
name|saveexitstat
decl_stmt|;
name|int
specifier|volatile
name|rstat
init|=
name|EX_OK
decl_stmt|;
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
name|int
name|rsno
decl_stmt|;
name|bool
specifier|volatile
name|discard
init|=
name|false
decl_stmt|;
specifier|auto
name|ADDRESS
name|a1
decl_stmt|;
name|bool
name|saveQuickAbort
init|=
name|QuickAbort
decl_stmt|;
name|bool
name|saveSuprErrs
init|=
name|SuprErrs
decl_stmt|;
if|#
directive|if
name|_FFR_QUARANTINE
name|bool
name|quarantine
init|=
name|false
decl_stmt|;
name|char
name|ubuf
index|[
name|BUFSIZ
operator|*
literal|2
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* _FFR_QUARANTINE */
name|char
name|buf0
index|[
name|MAXLINE
index|]
decl_stmt|;
name|char
name|pvpbuf
index|[
name|PSBUFSIZE
index|]
decl_stmt|;
specifier|extern
name|char
name|MsgBuf
index|[]
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|48
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"rscheck(%s, %s, %s)\n"
argument_list|,
name|rwset
argument_list|,
name|p1
argument_list|,
name|p2
operator|==
name|NULL
condition|?
literal|"(NULL)"
else|:
name|p2
argument_list|)
expr_stmt|;
name|rsno
operator|=
name|strtorwset
argument_list|(
name|rwset
argument_list|,
name|NULL
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsno
operator|<
literal|0
condition|)
return|return
name|EX_OK
return|;
if|if
condition|(
name|p2
operator|!=
name|NULL
condition|)
block|{
name|bufsize
operator|=
name|strlen
argument_list|(
name|p1
argument_list|)
operator|+
name|strlen
argument_list|(
name|p2
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|bufsize
operator|>
sizeof|sizeof
name|buf0
condition|)
name|buf
operator|=
name|sm_malloc_x
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
else|else
block|{
name|buf
operator|=
name|buf0
expr_stmt|;
name|bufsize
operator|=
sizeof|sizeof
name|buf0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|,
literal|"%s%c%s"
argument_list|,
name|p1
argument_list|,
name|CONDELSE
argument_list|,
name|p2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bufsize
operator|=
name|strlen
argument_list|(
name|p1
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|bufsize
operator|>
sizeof|sizeof
name|buf0
condition|)
name|buf
operator|=
name|sm_malloc_x
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
else|else
block|{
name|buf
operator|=
name|buf0
expr_stmt|;
name|bufsize
operator|=
sizeof|sizeof
name|buf0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|buf
argument_list|,
name|p1
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
block|}
name|SM_TRY
block|{
name|SuprErrs
operator|=
name|true
expr_stmt|;
name|QuickAbort
operator|=
name|false
expr_stmt|;
name|pvp
operator|=
name|prescan
argument_list|(
name|buf
argument_list|,
literal|'\0'
argument_list|,
name|pvpbuf
argument_list|,
sizeof|sizeof
name|pvpbuf
argument_list|,
name|NULL
argument_list|,
name|bitset
argument_list|(
name|RSF_RMCOMM
argument_list|,
name|flags
argument_list|)
condition|?
name|NULL
else|:
name|TokTypeNoC
argument_list|)
expr_stmt|;
name|SuprErrs
operator|=
name|saveSuprErrs
expr_stmt|;
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|48
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"rscheck: cannot prescan input\n"
argument_list|)
expr_stmt|;
comment|/* 			syserr("rscheck: cannot prescan input: \"%s\"", 				shortenstring(buf, MAXSHORTSTR)); 			rstat = EX_DATAERR; 	*/
goto|goto
name|finis
goto|;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|RSF_UNSTRUCTURED
argument_list|,
name|flags
argument_list|)
condition|)
name|SuprErrs
operator|=
name|true
expr_stmt|;
operator|(
name|void
operator|)
name|REWRITE
argument_list|(
name|pvp
argument_list|,
name|rsno
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RSF_UNSTRUCTURED
argument_list|,
name|flags
argument_list|)
condition|)
name|SuprErrs
operator|=
name|saveSuprErrs
expr_stmt|;
if|if
condition|(
name|pvp
index|[
literal|0
index|]
operator|==
name|NULL
operator|||
operator|(
name|pvp
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|&
literal|0377
operator|)
operator|!=
name|CANONNET
operator|||
name|pvp
index|[
literal|1
index|]
operator|==
name|NULL
operator|||
operator|(
name|strcmp
argument_list|(
name|pvp
index|[
literal|1
index|]
argument_list|,
literal|"error"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|pvp
index|[
literal|1
index|]
argument_list|,
literal|"discard"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
goto|goto
name|finis
goto|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|pvp
index|[
literal|1
index|]
argument_list|,
literal|"discard"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|48
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"rscheck: discard mailer selected\n"
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_DISCARD
expr_stmt|;
name|discard
operator|=
name|true
expr_stmt|;
block|}
if|#
directive|if
name|_FFR_QUARANTINE
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|pvp
index|[
literal|1
index|]
argument_list|,
literal|"error"
argument_list|)
operator|==
literal|0
operator|&&
name|pvp
index|[
literal|2
index|]
operator|!=
name|NULL
operator|&&
operator|(
name|pvp
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|&
literal|0377
operator|)
operator|==
name|CANONHOST
operator|&&
name|pvp
index|[
literal|3
index|]
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|pvp
index|[
literal|3
index|]
argument_list|,
literal|"quarantine"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pvp
index|[
literal|4
index|]
operator|==
name|NULL
operator|||
operator|(
name|pvp
index|[
literal|4
index|]
index|[
literal|0
index|]
operator|&
literal|0377
operator|)
operator|!=
name|CANONUSER
operator|||
name|pvp
index|[
literal|5
index|]
operator|==
name|NULL
condition|)
name|e
operator|->
name|e_quarmsg
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|rwset
argument_list|)
expr_stmt|;
else|else
block|{
name|cataddr
argument_list|(
operator|&
operator|(
name|pvp
index|[
literal|5
index|]
operator|)
argument_list|,
name|NULL
argument_list|,
name|ubuf
argument_list|,
sizeof|sizeof
name|ubuf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_quarmsg
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|ubuf
argument_list|)
expr_stmt|;
block|}
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{quarantine}"
argument_list|)
argument_list|,
name|e
operator|->
name|e_quarmsg
argument_list|)
expr_stmt|;
name|quarantine
operator|=
name|true
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _FFR_QUARANTINE */
else|else
block|{
name|int
name|savelogusrerrs
init|=
name|LogUsrErrs
decl_stmt|;
specifier|static
name|bool
name|logged
init|=
name|false
decl_stmt|;
comment|/* got an error -- process it */
name|saveexitstat
operator|=
name|ExitStat
expr_stmt|;
name|LogUsrErrs
operator|=
name|false
expr_stmt|;
operator|(
name|void
operator|)
name|buildaddr
argument_list|(
name|pvp
argument_list|,
operator|&
name|a1
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|LogUsrErrs
operator|=
name|savelogusrerrs
expr_stmt|;
name|rstat
operator|=
name|ExitStat
expr_stmt|;
name|ExitStat
operator|=
name|saveexitstat
expr_stmt|;
if|if
condition|(
operator|!
name|logged
condition|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|RSF_COUNT
argument_list|,
name|flags
argument_list|)
condition|)
name|markstats
argument_list|(
name|e
argument_list|,
operator|&
name|a1
argument_list|,
name|STATS_REJECT
argument_list|)
expr_stmt|;
name|logged
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LogLevel
operator|>
name|logl
condition|)
block|{
name|char
modifier|*
name|relay
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|lbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|p
operator|=
name|lbuf
expr_stmt|;
if|if
condition|(
name|p2
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|p
argument_list|,
name|SPACELEFT
argument_list|(
name|lbuf
argument_list|,
name|p
argument_list|)
argument_list|,
literal|", arg2=%s"
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|host
operator|!=
name|NULL
condition|)
name|relay
operator|=
name|host
expr_stmt|;
else|else
name|relay
operator|=
name|macvalue
argument_list|(
literal|'_'
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|relay
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|p
argument_list|,
name|SPACELEFT
argument_list|(
name|lbuf
argument_list|,
name|p
argument_list|)
argument_list|,
literal|", relay=%s"
argument_list|,
name|relay
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|discard
condition|)
name|sm_syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
name|logid
argument_list|,
literal|"ruleset=%s, arg1=%s%s, discard"
argument_list|,
name|rwset
argument_list|,
name|p1
argument_list|,
name|lbuf
argument_list|)
expr_stmt|;
if|#
directive|if
name|_FFR_QUARANTINE
elseif|else
if|if
condition|(
name|quarantine
condition|)
name|sm_syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
name|logid
argument_list|,
literal|"ruleset=%s, arg1=%s%s, quarantine=%s"
argument_list|,
name|rwset
argument_list|,
name|p1
argument_list|,
name|lbuf
argument_list|,
name|ubuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_QUARANTINE */
else|else
name|sm_syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
name|logid
argument_list|,
literal|"ruleset=%s, arg1=%s%s, reject=%s"
argument_list|,
name|rwset
argument_list|,
name|p1
argument_list|,
name|lbuf
argument_list|,
name|MsgBuf
argument_list|)
expr_stmt|;
block|}
name|finis
label|:
empty_stmt|;
block|}
name|SM_FINALLY
block|{
comment|/* clean up */
if|if
condition|(
name|buf
operator|!=
name|buf0
condition|)
name|sm_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|QuickAbort
operator|=
name|saveQuickAbort
expr_stmt|;
block|}
name|SM_END_TRY
name|setstat
argument_list|(
name|rstat
argument_list|)
decl_stmt|;
comment|/* rulesets don't set errno */
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rstat
operator|!=
name|EX_OK
operator|&&
name|QuickAbort
condition|)
name|sm_exc_raisenew_x
argument_list|(
operator|&
name|EtypeQuickAbort
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|rstat
return|;
block|}
end_function

begin_comment
comment|/* **  RSCAP -- call rewriting set to return capabilities ** **	Parameters: **		rwset -- the rewriting set to use. **		p1 -- the first string to check. **		p2 -- the second string to check -- may be null. **		e -- the current envelope. **		pvp -- pointer to token vector. **		pvpbuf -- buffer space. **		size -- size of buffer space. ** **	Returns: **		EX_UNAVAILABLE -- ruleset doesn't exist. **		EX_DATAERR -- prescan() failed. **		EX_OK -- rewrite() was successful. **		else -- return status from rewrite(). */
end_comment

begin_function
name|int
name|rscap
parameter_list|(
name|rwset
parameter_list|,
name|p1
parameter_list|,
name|p2
parameter_list|,
name|e
parameter_list|,
name|pvp
parameter_list|,
name|pvpbuf
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|rwset
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
name|char
modifier|*
name|p2
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|pvp
decl_stmt|;
name|char
modifier|*
name|pvpbuf
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|char
modifier|*
specifier|volatile
name|buf
decl_stmt|;
name|int
name|bufsize
decl_stmt|;
name|int
specifier|volatile
name|rstat
init|=
name|EX_OK
decl_stmt|;
name|int
name|rsno
decl_stmt|;
name|bool
name|saveQuickAbort
init|=
name|QuickAbort
decl_stmt|;
name|bool
name|saveSuprErrs
init|=
name|SuprErrs
decl_stmt|;
name|char
name|buf0
index|[
name|MAXLINE
index|]
decl_stmt|;
specifier|extern
name|char
name|MsgBuf
index|[]
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|48
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"rscap(%s, %s, %s)\n"
argument_list|,
name|rwset
argument_list|,
name|p1
argument_list|,
name|p2
operator|==
name|NULL
condition|?
literal|"(NULL)"
else|:
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|!=
name|NULL
condition|)
operator|*
name|pvp
operator|=
name|NULL
expr_stmt|;
name|rsno
operator|=
name|strtorwset
argument_list|(
name|rwset
argument_list|,
name|NULL
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsno
operator|<
literal|0
condition|)
return|return
name|EX_UNAVAILABLE
return|;
if|if
condition|(
name|p2
operator|!=
name|NULL
condition|)
block|{
name|bufsize
operator|=
name|strlen
argument_list|(
name|p1
argument_list|)
operator|+
name|strlen
argument_list|(
name|p2
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|bufsize
operator|>
sizeof|sizeof
name|buf0
condition|)
name|buf
operator|=
name|sm_malloc_x
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
else|else
block|{
name|buf
operator|=
name|buf0
expr_stmt|;
name|bufsize
operator|=
sizeof|sizeof
name|buf0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|,
literal|"%s%c%s"
argument_list|,
name|p1
argument_list|,
name|CONDELSE
argument_list|,
name|p2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bufsize
operator|=
name|strlen
argument_list|(
name|p1
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|bufsize
operator|>
sizeof|sizeof
name|buf0
condition|)
name|buf
operator|=
name|sm_malloc_x
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
else|else
block|{
name|buf
operator|=
name|buf0
expr_stmt|;
name|bufsize
operator|=
sizeof|sizeof
name|buf0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|buf
argument_list|,
name|p1
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
block|}
name|SM_TRY
block|{
name|SuprErrs
operator|=
name|true
expr_stmt|;
name|QuickAbort
operator|=
name|false
expr_stmt|;
operator|*
name|pvp
operator|=
name|prescan
argument_list|(
name|buf
argument_list|,
literal|'\0'
argument_list|,
name|pvpbuf
argument_list|,
name|size
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pvp
operator|!=
name|NULL
condition|)
name|rstat
operator|=
name|rewrite
argument_list|(
operator|*
name|pvp
argument_list|,
name|rsno
argument_list|,
literal|0
argument_list|,
name|e
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|48
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"rscap: cannot prescan input\n"
argument_list|)
expr_stmt|;
name|rstat
operator|=
name|EX_DATAERR
expr_stmt|;
block|}
block|}
name|SM_FINALLY
block|{
comment|/* clean up */
if|if
condition|(
name|buf
operator|!=
name|buf0
condition|)
name|sm_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|SuprErrs
operator|=
name|saveSuprErrs
expr_stmt|;
name|QuickAbort
operator|=
name|saveQuickAbort
expr_stmt|;
comment|/* prevent information leak, this may contain rewrite error */
name|MsgBuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|SM_END_TRY
return|return
name|rstat
return|;
block|}
end_function

end_unit

