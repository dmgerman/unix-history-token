begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1999-2003 Sendmail, Inc. and its suppliers.  *	All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_include
include|#
directive|include
file|<sendmail.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: milter.c,v 8.197.2.10 2003/12/01 23:57:44 msk Exp $"
argument_list|)
end_macro

begin_if
if|#
directive|if
name|MILTER
end_if

begin_include
include|#
directive|include
file|<libmilter/mfapi.h>
end_include

begin_include
include|#
directive|include
file|<libmilter/mfdef.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_if
if|#
directive|if
name|NETINET
operator|||
name|NETINET6
end_if

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NETINET || NETINET6 */
end_comment

begin_include
include|#
directive|include
file|<sm/fdset.h>
end_include

begin_decl_stmt
specifier|static
name|void
name|milter_connect_timeout
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|milter_error
name|__P
argument_list|(
operator|(
expr|struct
name|milter
operator|*
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|milter_open
name|__P
argument_list|(
operator|(
expr|struct
name|milter
operator|*
operator|,
name|bool
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|milter_parse_timeouts
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|milter
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|MilterConnectMacros
index|[
name|MAXFILTERMACROS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|MilterHeloMacros
index|[
name|MAXFILTERMACROS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|MilterEnvFromMacros
index|[
name|MAXFILTERMACROS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|MilterEnvRcptMacros
index|[
name|MAXFILTERMACROS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|_FFR_MILTER_MACROS_EOM
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|MilterEOMMacros
index|[
name|MAXFILTERMACROS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_MILTER_MACROS_EOM */
end_comment

begin_define
define|#
directive|define
name|MILTER_CHECK_DONE_MSG
parameter_list|()
define|\
value|if (*state == SMFIR_REPLYCODE || \ 	    *state == SMFIR_REJECT || \ 	    *state == SMFIR_DISCARD || \ 	    *state == SMFIR_TEMPFAIL) \ 	{ \
comment|/* Abort the filters to let them know we are done with msg */
value|\ 		milter_abort(e); \ 	}
end_define

begin_if
if|#
directive|if
name|_FFR_QUARANTINE
end_if

begin_define
define|#
directive|define
name|MILTER_CHECK_ERROR
parameter_list|(
name|initial
parameter_list|,
name|action
parameter_list|)
define|\
value|if (!initial&& tTd(71, 100)) \ 	{ \ 		if (e->e_quarmsg == NULL) \ 		{ \ 			e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, \ 							 "filter failure"); \ 			macdefine(&e->e_macro, A_PERM, macid("{quarantine}"), \ 				  e->e_quarmsg); \ 		} \ 	} \ 	else if (tTd(71, 101)) \ 	{ \ 		if (e->e_quarmsg == NULL) \ 		{ \ 			e->e_quarmsg = sm_rpool_strdup_x(e->e_rpool, \ 							 "filter failure"); \ 			macdefine(&e->e_macro, A_PERM, macid("{quarantine}"), \ 				  e->e_quarmsg); \ 		} \ 	} \ 	else if (bitnset(SMF_TEMPFAIL, m->mf_flags)) \ 		*state = SMFIR_TEMPFAIL; \ 	else if (bitnset(SMF_REJECT, m->mf_flags)) \ 		*state = SMFIR_REJECT; \ 	else \ 		action;
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* _FFR_QUARANTINE */
end_comment

begin_define
define|#
directive|define
name|MILTER_CHECK_ERROR
parameter_list|(
name|initial
parameter_list|,
name|action
parameter_list|)
define|\
value|if (bitnset(SMF_TEMPFAIL, m->mf_flags)) \ 		*state = SMFIR_TEMPFAIL; \ 	else if (bitnset(SMF_REJECT, m->mf_flags)) \ 		*state = SMFIR_REJECT; \ 	else \ 		action;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _FFR_QUARANTINE */
end_comment

begin_define
define|#
directive|define
name|MILTER_CHECK_REPLYCODE
parameter_list|(
define|default) \ 	if (response == NULL || \ 	    strlen(response) + 1 != (size_t) rlen || \ 	    rlen< 3 || \ 	    (response[0] != '4'&& response[0] != '5') || \ 	    !isascii(response[1]) || !isdigit(response[1]) || \ 	    !isascii(response[2]) || !isdigit(response[2])) \ 	{ \ 		if (response != NULL) \ 			sm_free(response);
comment|/* XXX */
define|\ 		response = newstr(default); \ 	} \ 	else \ 	{ \ 		char *ptr = response; \  \
comment|/* Check for unprotected %'s in the string */
define|\ 		while (*ptr != '\0') \ 		{ \ 			if (*ptr == '%'&& *++ptr != '%') \ 			{ \ 				sm_free(response);
comment|/* XXX */
define|\ 				response = newstr(default); \ 				break; \ 			} \ 			ptr++; \ 		} \ 	}
end_define

begin_define
define|#
directive|define
name|MILTER_DF_ERROR
parameter_list|(
name|msg
parameter_list|)
define|\
value|{ \ 	int save_errno = errno; \  \ 	if (tTd(64, 5)) \ 	{ \ 		sm_dprintf(msg, dfname, sm_errstring(save_errno)); \ 		sm_dprintf("\n"); \ 	} \ 	if (MilterLogLevel> 0) \ 		sm_syslog(LOG_ERR, e->e_id, msg, dfname, sm_errstring(save_errno)); \ 	if (SuperSafe == SAFE_REALLY) \ 	{ \ 		if (e->e_dfp != NULL) \ 		{ \ 			(void) sm_io_close(e->e_dfp, SM_TIME_DEFAULT); \ 			e->e_dfp = NULL; \ 		} \ 		e->e_flags&= ~EF_HAS_DF; \ 	} \ 	errno = save_errno; \ }
end_define

begin_comment
comment|/* **  MILTER_TIMEOUT -- make sure socket is ready in time ** **	Parameters: **		routine -- routine name for debug/logging **		secs -- number of seconds in timeout **		write -- waiting to read or write? **		started -- whether this is part of a previous sequence ** **	Assumes 'm' is a milter structure for the current socket. */
end_comment

begin_define
define|#
directive|define
name|MILTER_TIMEOUT
parameter_list|(
name|routine
parameter_list|,
name|secs
parameter_list|,
name|write
parameter_list|,
name|started
parameter_list|)
define|\
value|{ \ 	int ret; \ 	int save_errno; \ 	fd_set fds; \ 	struct timeval tv; \  \ 	if (SM_FD_SETSIZE> 0&& m->mf_sock>= SM_FD_SETSIZE) \ 	{ \ 		if (tTd(64, 5)) \ 			sm_dprintf("milter_%s(%s): socket %d is larger than FD_SETSIZE %d\n", \ 				   (routine), m->mf_name, m->mf_sock, \ 				   SM_FD_SETSIZE); \ 		if (MilterLogLevel> 0) \ 			sm_syslog(LOG_ERR, e->e_id, \ 				  "Milter (%s): socket(%s) %d is larger than FD_SETSIZE %d", \ 				  m->mf_name, (routine), m->mf_sock, \ 				  SM_FD_SETSIZE); \ 		milter_error(m, e); \ 		return NULL; \ 	} \  \ 	do \ 	{ \ 		FD_ZERO(&fds); \ 		SM_FD_SET(m->mf_sock,&fds); \ 		tv.tv_sec = (secs); \ 		tv.tv_usec = 0; \ 		ret = select(m->mf_sock + 1, \ 			     (write) ? NULL :&fds, \ 			     (write) ?&fds : NULL, \ 			     NULL,&tv); \ 	} while (ret< 0&& errno == EINTR); \  \ 	switch (ret) \ 	{ \ 	  case 0: \ 		if (tTd(64, 5)) \ 			sm_dprintf("milter_%s(%s): timeout\n", (routine), \ 				   m->mf_name); \ 		if (MilterLogLevel> 0) \ 			sm_syslog(LOG_ERR, e->e_id, \ 				  "Milter (%s): %s %s %s %s", \ 				  m->mf_name, "timeout", \ 				  started ? "during" : "before", \ 				  "data", (routine)); \ 		milter_error(m, e); \ 		return NULL; \  \ 	  case -1: \ 		save_errno = errno; \ 		if (tTd(64, 5)) \ 			sm_dprintf("milter_%s(%s): select: %s\n", (routine), \ 				   m->mf_name, sm_errstring(save_errno)); \ 		if (MilterLogLevel> 0) \ 		{ \ 			sm_syslog(LOG_ERR, e->e_id, \ 				  "Milter (%s): select(%s): %s", \ 				  m->mf_name, (routine), \ 				  sm_errstring(save_errno)); \ 		} \ 		milter_error(m, e); \ 		return NULL; \  \ 	  default: \ 		if (SM_FD_ISSET(m->mf_sock,&fds)) \ 			break; \ 		if (tTd(64, 5)) \ 			sm_dprintf("milter_%s(%s): socket not ready\n", \ 				(routine), m->mf_name); \ 		if (MilterLogLevel> 0) \ 		{ \ 			sm_syslog(LOG_ERR, e->e_id, \ 				  "Milter (%s): socket(%s) not ready", \ 				  m->mf_name, (routine)); \ 		} \ 		milter_error(m, e); \ 		return NULL; \ 	} \ }
end_define

begin_comment
comment|/* **  Low level functions */
end_comment

begin_comment
comment|/* **  MILTER_READ -- read from a remote milter filter ** **	Parameters: **		m -- milter to read from. **		cmd -- return param for command read. **		rlen -- return length of response string. **		to -- timeout in seconds. **		e -- current envelope. ** **	Returns: **		response string (may be NULL) */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|milter_sysread
parameter_list|(
name|m
parameter_list|,
name|buf
parameter_list|,
name|sz
parameter_list|,
name|to
parameter_list|,
name|e
parameter_list|)
name|struct
name|milter
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|ssize_t
name|sz
decl_stmt|;
name|time_t
name|to
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|time_t
name|readstart
init|=
literal|0
decl_stmt|;
name|ssize_t
name|len
decl_stmt|,
name|curl
decl_stmt|;
name|bool
name|started
init|=
name|false
decl_stmt|;
name|curl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|to
operator|>
literal|0
condition|)
name|readstart
operator|=
name|curtime
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|to
operator|>
literal|0
condition|)
block|{
name|time_t
name|now
decl_stmt|;
name|now
operator|=
name|curtime
argument_list|()
expr_stmt|;
if|if
condition|(
name|now
operator|-
name|readstart
operator|>=
name|to
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_read (%s): %s %s %s"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
literal|"timeout"
argument_list|,
name|started
condition|?
literal|"during"
else|:
literal|"before"
argument_list|,
literal|"data read"
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): %s %s %s"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
literal|"timeout"
argument_list|,
name|started
condition|?
literal|"during"
else|:
literal|"before"
argument_list|,
literal|"data read"
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|to
operator|-=
name|now
operator|-
name|readstart
expr_stmt|;
name|readstart
operator|=
name|now
expr_stmt|;
name|MILTER_TIMEOUT
argument_list|(
literal|"read"
argument_list|,
name|to
argument_list|,
name|false
argument_list|,
name|started
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|read
argument_list|(
name|m
operator|->
name|mf_sock
argument_list|,
name|buf
operator|+
name|curl
argument_list|,
name|sz
operator|-
name|curl
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_read(%s): read returned %ld: %s\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
operator|(
name|long
operator|)
name|len
argument_list|,
name|sm_errstring
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): read returned %ld: %s"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
operator|(
name|long
operator|)
name|len
argument_list|,
name|sm_errstring
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|started
operator|=
name|true
expr_stmt|;
name|curl
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
operator|||
name|curl
operator|>=
name|sz
condition|)
break|break;
block|}
if|if
condition|(
name|curl
operator|!=
name|sz
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_read(%s): cmd read returned %ld, expecting %ld\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
operator|(
name|long
operator|)
name|curl
argument_list|,
operator|(
name|long
operator|)
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"milter_read(%s): cmd read returned %ld, expecting %ld"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
operator|(
name|long
operator|)
name|curl
argument_list|,
operator|(
name|long
operator|)
name|sz
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|milter_read
parameter_list|(
name|m
parameter_list|,
name|cmd
parameter_list|,
name|rlen
parameter_list|,
name|to
parameter_list|,
name|e
parameter_list|)
name|struct
name|milter
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|ssize_t
modifier|*
name|rlen
decl_stmt|;
name|time_t
name|to
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|time_t
name|readstart
init|=
literal|0
decl_stmt|;
name|ssize_t
name|expl
decl_stmt|;
name|mi_int32
name|i
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
name|data
index|[
name|MILTER_LEN_BYTES
operator|+
literal|1
index|]
decl_stmt|;
operator|*
name|rlen
operator|=
literal|0
expr_stmt|;
operator|*
name|cmd
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|to
operator|>
literal|0
condition|)
name|readstart
operator|=
name|curtime
argument_list|()
expr_stmt|;
if|if
condition|(
name|milter_sysread
argument_list|(
name|m
argument_list|,
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|,
name|to
argument_list|,
name|e
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* reset timeout */
if|if
condition|(
name|to
operator|>
literal|0
condition|)
block|{
name|time_t
name|now
decl_stmt|;
name|now
operator|=
name|curtime
argument_list|()
expr_stmt|;
if|if
condition|(
name|now
operator|-
name|readstart
operator|>=
name|to
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_read(%s): timeout before data read\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter read(%s): timeout before data read"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|to
operator|-=
name|now
operator|-
name|readstart
expr_stmt|;
block|}
operator|*
name|cmd
operator|=
name|data
index|[
name|MILTER_LEN_BYTES
index|]
expr_stmt|;
name|data
index|[
name|MILTER_LEN_BYTES
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|&
name|i
argument_list|,
name|data
argument_list|,
name|MILTER_LEN_BYTES
argument_list|)
expr_stmt|;
name|expl
operator|=
name|ntohl
argument_list|(
name|i
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|25
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_read(%s): expecting %ld bytes\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
operator|(
name|long
operator|)
name|expl
argument_list|)
expr_stmt|;
if|if
condition|(
name|expl
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_read(%s): read size %ld out of range\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
operator|(
name|long
operator|)
name|expl
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"milter_read(%s): read size %ld out of range"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
operator|(
name|long
operator|)
name|expl
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|expl
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xalloc
argument_list|(
name|expl
argument_list|)
expr_stmt|;
if|if
condition|(
name|milter_sysread
argument_list|(
name|m
argument_list|,
name|buf
argument_list|,
name|expl
argument_list|,
name|to
argument_list|,
name|e
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|sm_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* XXX */
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|50
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_read(%s): Returning %*s\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
operator|(
name|int
operator|)
name|expl
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|*
name|rlen
operator|=
name|expl
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* **  MILTER_WRITE -- write to a remote milter filter ** **	Parameters: **		m -- milter to read from. **		cmd -- command to send. **		buf -- optional command data. **		len -- length of buf. **		to -- timeout in seconds. **		e -- current envelope. ** **	Returns: **		buf if successful, NULL otherwise **		Not actually used anywhere but function prototype **			must match milter_read() */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|milter_write
parameter_list|(
name|m
parameter_list|,
name|cmd
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|to
parameter_list|,
name|e
parameter_list|)
name|struct
name|milter
modifier|*
name|m
decl_stmt|;
name|char
name|cmd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|time_t
name|to
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|time_t
name|writestart
init|=
operator|(
name|time_t
operator|)
literal|0
decl_stmt|;
name|ssize_t
name|sl
decl_stmt|,
name|i
decl_stmt|;
name|mi_int32
name|nl
decl_stmt|;
name|char
name|data
index|[
name|MILTER_LEN_BYTES
operator|+
literal|1
index|]
decl_stmt|;
name|bool
name|started
init|=
name|false
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|MILTER_CHUNK_SIZE
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_write(%s): length %ld out of range\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
operator|(
name|long
operator|)
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"milter_write(%s): length %ld out of range"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
operator|(
name|long
operator|)
name|len
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|20
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_write(%s): cmd %c, len %ld\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|cmd
argument_list|,
operator|(
name|long
operator|)
name|len
argument_list|)
expr_stmt|;
name|nl
operator|=
name|htonl
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* add 1 for the cmd char */
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|data
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|nl
argument_list|,
name|MILTER_LEN_BYTES
argument_list|)
expr_stmt|;
name|data
index|[
name|MILTER_LEN_BYTES
index|]
operator|=
name|cmd
expr_stmt|;
name|sl
operator|=
name|MILTER_LEN_BYTES
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|to
operator|>
literal|0
condition|)
block|{
name|writestart
operator|=
name|curtime
argument_list|()
expr_stmt|;
name|MILTER_TIMEOUT
argument_list|(
literal|"write"
argument_list|,
name|to
argument_list|,
name|true
argument_list|,
name|started
argument_list|)
expr_stmt|;
block|}
comment|/* use writev() instead to send the whole stuff at once? */
name|i
operator|=
name|write
argument_list|(
name|m
operator|->
name|mf_sock
argument_list|,
operator|(
name|void
operator|*
operator|)
name|data
argument_list|,
name|sl
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|sl
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_write (%s): write(%c) returned %ld, expected %ld: %s\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|cmd
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|,
operator|(
name|long
operator|)
name|sl
argument_list|,
name|sm_errstring
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): write(%c) returned %ld, expected %ld: %s"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|cmd
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|,
operator|(
name|long
operator|)
name|sl
argument_list|,
name|sm_errstring
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
if|if
condition|(
name|len
operator|<=
literal|0
operator|||
name|buf
operator|==
name|NULL
condition|)
return|return
name|buf
return|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|50
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_write(%s): Sending %*s\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|started
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|to
operator|>
literal|0
condition|)
block|{
name|time_t
name|now
decl_stmt|;
name|now
operator|=
name|curtime
argument_list|()
expr_stmt|;
if|if
condition|(
name|now
operator|-
name|writestart
operator|>=
name|to
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_write(%s): timeout before data write\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): timeout before data write"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
block|{
name|to
operator|-=
name|now
operator|-
name|writestart
expr_stmt|;
name|MILTER_TIMEOUT
argument_list|(
literal|"write"
argument_list|,
name|to
argument_list|,
name|true
argument_list|,
name|started
argument_list|)
expr_stmt|;
block|}
block|}
name|i
operator|=
name|write
argument_list|(
name|m
operator|->
name|mf_sock
argument_list|,
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|len
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_write(%s): write(%c) returned %ld, expected %ld: %s\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|cmd
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|,
operator|(
name|long
operator|)
name|sl
argument_list|,
name|sm_errstring
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): write(%c) returned %ld, expected %ld: %s"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|cmd
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|,
operator|(
name|long
operator|)
name|len
argument_list|,
name|sm_errstring
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* **  Utility functions */
end_comment

begin_comment
comment|/* **  MILTER_OPEN -- connect to remote milter filter ** **	Parameters: **		m -- milter to connect to. **		parseonly -- parse but don't connect. **		e -- current envelope. ** **	Returns: **		connected socket if successful&& !parseonly, **		0 upon parse success if parseonly, **		-1 otherwise. */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|MilterConnectTimeout
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|milter_open
parameter_list|(
name|m
parameter_list|,
name|parseonly
parameter_list|,
name|e
parameter_list|)
name|struct
name|milter
modifier|*
name|m
decl_stmt|;
name|bool
name|parseonly
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|sock
init|=
literal|0
decl_stmt|;
name|SOCKADDR_LEN_T
name|addrlen
init|=
literal|0
decl_stmt|;
name|int
name|addrno
init|=
literal|0
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|colon
decl_stmt|;
name|char
modifier|*
name|at
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
init|=
name|NULL
decl_stmt|;
name|SOCKADDR
name|addr
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|mf_conn
operator|==
name|NULL
operator|||
name|m
operator|->
name|mf_conn
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"X%s: empty or missing socket information\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|parseonly
condition|)
name|syserr
argument_list|(
literal|"X%s: empty or missing socket information"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): empty or missing socket information"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* protocol:filename or protocol:port@host */
name|memset
argument_list|(
operator|&
name|addr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|addr
argument_list|)
expr_stmt|;
name|p
operator|=
name|m
operator|->
name|mf_conn
expr_stmt|;
name|colon
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|colon
operator|!=
name|NULL
condition|)
block|{
operator|*
name|colon
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
if|#
directive|if
name|NETUNIX
comment|/* default to AF_UNIX */
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_UNIX
expr_stmt|;
else|#
directive|else
comment|/* NETUNIX */
if|#
directive|if
name|NETINET
comment|/* default to AF_INET */
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
else|#
directive|else
comment|/* NETINET */
if|#
directive|if
name|NETINET6
comment|/* default to AF_INET6 */
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET6
expr_stmt|;
else|#
directive|else
comment|/* NETINET6 */
comment|/* no protocols available */
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): no valid socket protocols available"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
comment|/* NETINET6 */
endif|#
directive|endif
comment|/* NETINET */
endif|#
directive|endif
comment|/* NETUNIX */
block|}
if|#
directive|if
name|NETUNIX
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|p
argument_list|,
literal|"unix"
argument_list|)
operator|==
literal|0
operator|||
name|sm_strcasecmp
argument_list|(
name|p
argument_list|,
literal|"local"
argument_list|)
operator|==
literal|0
condition|)
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_UNIX
expr_stmt|;
endif|#
directive|endif
comment|/* NETUNIX */
if|#
directive|if
name|NETINET
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|p
argument_list|,
literal|"inet"
argument_list|)
operator|==
literal|0
condition|)
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET6
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|p
argument_list|,
literal|"inet6"
argument_list|)
operator|==
literal|0
condition|)
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET6
expr_stmt|;
endif|#
directive|endif
comment|/* NETINET6 */
else|else
block|{
ifdef|#
directive|ifdef
name|EPROTONOSUPPORT
name|errno
operator|=
name|EPROTONOSUPPORT
expr_stmt|;
else|#
directive|else
comment|/* EPROTONOSUPPORT */
name|errno
operator|=
name|EINVAL
expr_stmt|;
endif|#
directive|endif
comment|/* EPROTONOSUPPORT */
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"X%s: unknown socket type %s\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|parseonly
condition|)
name|syserr
argument_list|(
literal|"X%s: unknown socket type %s"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): unknown socket type %s"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|colon
operator|++
operator|=
literal|':'
expr_stmt|;
block|}
else|else
block|{
comment|/* default to AF_UNIX */
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_UNIX
expr_stmt|;
name|colon
operator|=
name|p
expr_stmt|;
block|}
if|#
directive|if
name|NETUNIX
if|if
condition|(
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_UNIX
condition|)
block|{
name|long
name|sff
init|=
name|SFF_SAFEDIRPATH
operator||
name|SFF_OPENASROOT
operator||
name|SFF_NOLINK
operator||
name|SFF_EXECOK
decl_stmt|;
name|at
operator|=
name|colon
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|colon
argument_list|)
operator|>=
sizeof|sizeof
name|addr
operator|.
name|sunix
operator|.
name|sun_path
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"X%s: local socket name %s too long\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|colon
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|parseonly
condition|)
name|syserr
argument_list|(
literal|"X%s: local socket name %s too long"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|colon
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): local socket name %s too long"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|colon
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|errno
operator|=
name|safefile
argument_list|(
name|colon
argument_list|,
name|RunAsUid
argument_list|,
name|RunAsGid
argument_list|,
name|RunAsUserName
argument_list|,
name|sff
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* if just parsing .cf file, socket doesn't need to exist */
if|if
condition|(
name|parseonly
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
if|if
condition|(
name|OpMode
operator|==
name|MD_DAEMON
operator|||
name|OpMode
operator|==
name|MD_FGDAEMON
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioerr
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"WARNING: X%s: local socket name %s missing\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|colon
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
comment|/* if not safe, don't create */
name|save_errno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"X%s: local socket name %s unsafe\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|colon
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
if|if
condition|(
name|parseonly
condition|)
block|{
if|if
condition|(
name|OpMode
operator|==
name|MD_DAEMON
operator|||
name|OpMode
operator|==
name|MD_FGDAEMON
operator|||
name|OpMode
operator|==
name|MD_SMTP
condition|)
name|syserr
argument_list|(
literal|"X%s: local socket name %s unsafe"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|colon
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): local socket name %s unsafe"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|colon
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|addr
operator|.
name|sunix
operator|.
name|sun_path
argument_list|,
name|colon
argument_list|,
sizeof|sizeof
name|addr
operator|.
name|sunix
operator|.
name|sun_path
argument_list|)
expr_stmt|;
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* NETUNIX */
if|#
directive|if
name|NETINET
operator|||
name|NETINET6
if|if
condition|(
name|false
if|#
directive|if
name|NETINET
operator|||
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET6
operator|||
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
endif|#
directive|endif
comment|/* NETINET6 */
condition|)
block|{
name|unsigned
name|short
name|port
decl_stmt|;
comment|/* Parse port@host */
name|at
operator|=
name|strchr
argument_list|(
name|colon
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"X%s: bad address %s (expected port@host)\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|colon
argument_list|)
expr_stmt|;
if|if
condition|(
name|parseonly
condition|)
name|syserr
argument_list|(
literal|"X%s: bad address %s (expected port@host)"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|colon
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): bad address %s (expected port@host)"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|colon
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|at
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|isascii
argument_list|(
operator|*
name|colon
argument_list|)
operator|&&
name|isdigit
argument_list|(
operator|*
name|colon
argument_list|)
condition|)
name|port
operator|=
name|htons
argument_list|(
operator|(
name|unsigned
name|short
operator|)
name|atoi
argument_list|(
name|colon
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|NO_GETSERVBYNAME
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"X%s: invalid port number %s\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|colon
argument_list|)
expr_stmt|;
if|if
condition|(
name|parseonly
condition|)
name|syserr
argument_list|(
literal|"X%s: invalid port number %s"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|colon
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): invalid port number %s"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|colon
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
else|#
directive|else
comment|/* NO_GETSERVBYNAME */
specifier|register
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|getservbyname
argument_list|(
name|colon
argument_list|,
literal|"tcp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"X%s: unknown port name %s\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|colon
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
if|if
condition|(
name|parseonly
condition|)
name|syserr
argument_list|(
literal|"X%s: unknown port name %s"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|colon
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): unknown port name %s"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|colon
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|port
operator|=
name|sp
operator|->
name|s_port
expr_stmt|;
endif|#
directive|endif
comment|/* NO_GETSERVBYNAME */
block|}
operator|*
name|at
operator|++
operator|=
literal|'@'
expr_stmt|;
if|if
condition|(
operator|*
name|at
operator|==
literal|'['
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|end
operator|=
name|strchr
argument_list|(
name|at
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|!=
name|NULL
condition|)
block|{
name|bool
name|found
init|=
name|false
decl_stmt|;
if|#
directive|if
name|NETINET
name|unsigned
name|long
name|hid
init|=
name|INADDR_NONE
decl_stmt|;
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET6
name|struct
name|sockaddr_in6
name|hid6
decl_stmt|;
endif|#
directive|endif
comment|/* NETINET6 */
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
if|#
directive|if
name|NETINET
if|if
condition|(
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
operator|&&
operator|(
name|hid
operator|=
name|inet_addr
argument_list|(
operator|&
name|at
index|[
literal|1
index|]
argument_list|)
operator|)
operator|!=
name|INADDR_NONE
condition|)
block|{
name|addr
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|hid
expr_stmt|;
name|addr
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET6
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|&
name|hid6
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|hid6
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
operator|&&
name|anynet_pton
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|at
index|[
literal|1
index|]
argument_list|,
operator|&
name|hid6
operator|.
name|sin6_addr
argument_list|)
operator|==
literal|1
condition|)
block|{
name|addr
operator|.
name|sin6
operator|.
name|sin6_addr
operator|=
name|hid6
operator|.
name|sin6_addr
expr_stmt|;
name|addr
operator|.
name|sin6
operator|.
name|sin6_port
operator|=
name|port
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NETINET6 */
operator|*
name|end
operator|=
literal|']'
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"X%s: Invalid numeric domain spec \"%s\"\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|at
argument_list|)
expr_stmt|;
if|if
condition|(
name|parseonly
condition|)
name|syserr
argument_list|(
literal|"X%s: Invalid numeric domain spec \"%s\""
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|at
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): Invalid numeric domain spec \"%s\""
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|at
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"X%s: Invalid numeric domain spec \"%s\"\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|at
argument_list|)
expr_stmt|;
if|if
condition|(
name|parseonly
condition|)
name|syserr
argument_list|(
literal|"X%s: Invalid numeric domain spec \"%s\""
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|at
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): Invalid numeric domain spec \"%s\""
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|at
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
name|hp
operator|=
name|sm_gethostbyname
argument_list|(
name|at
argument_list|,
name|addr
operator|.
name|sa
operator|.
name|sa_family
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"X%s: Unknown host name %s\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|at
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
if|if
condition|(
name|parseonly
condition|)
name|syserr
argument_list|(
literal|"X%s: Unknown host name %s"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|at
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): Unknown host name %s"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|at
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|addr
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
switch|switch
condition|(
name|hp
operator|->
name|h_addrtype
condition|)
block|{
if|#
directive|if
name|NETINET
case|case
name|AF_INET
case|:
name|memmove
argument_list|(
operator|&
name|addr
operator|.
name|sin
operator|.
name|sin_addr
argument_list|,
name|hp
operator|->
name|h_addr
argument_list|,
name|INADDRSZ
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|addrno
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET6
case|case
name|AF_INET6
case|:
name|memmove
argument_list|(
operator|&
name|addr
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|,
name|hp
operator|->
name|h_addr
argument_list|,
name|IN6ADDRSZ
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sin6
operator|.
name|sin6_port
operator|=
name|port
expr_stmt|;
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|addrno
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET6 */
default|default:
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"X%s: Unknown protocol for %s (%d)\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|at
argument_list|,
name|hp
operator|->
name|h_addrtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|parseonly
condition|)
name|syserr
argument_list|(
literal|"X%s: Unknown protocol for %s (%d)"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|at
argument_list|,
name|hp
operator|->
name|h_addrtype
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): Unknown protocol for %s (%d)"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|at
argument_list|,
name|hp
operator|->
name|h_addrtype
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|#
directive|if
name|NETINET6
name|freehostent
argument_list|(
name|hp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NETINET6 */
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
else|else
endif|#
directive|endif
comment|/* NETINET || NETINET6 */
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"X%s: unknown socket protocol\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|parseonly
condition|)
name|syserr
argument_list|(
literal|"X%s: unknown socket protocol"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): unknown socket protocol"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* just parsing through? */
if|if
condition|(
name|parseonly
condition|)
block|{
name|m
operator|->
name|mf_state
operator|=
name|SMFS_READY
expr_stmt|;
if|#
directive|if
name|NETINET6
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
name|freehostent
argument_list|(
name|hp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NETINET6 */
return|return
literal|0
return|;
block|}
comment|/* sanity check */
if|if
condition|(
name|m
operator|->
name|mf_state
operator|!=
name|SMFS_READY
operator|&&
name|m
operator|->
name|mf_state
operator|!=
name|SMFS_CLOSED
condition|)
block|{
comment|/* shouldn't happen */
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"Milter (%s): Trying to open filter in state %c\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
operator|(
name|char
operator|)
name|m
operator|->
name|mf_state
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|#
directive|if
name|NETINET6
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
name|freehostent
argument_list|(
name|hp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NETINET6 */
return|return
operator|-
literal|1
return|;
block|}
comment|/* nope, actually connecting */
for|for
control|(
init|;
condition|;
control|)
block|{
name|sock
operator|=
name|socket
argument_list|(
name|addr
operator|.
name|sa
operator|.
name|sa_family
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"Milter (%s): error creating socket: %s\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|sm_errstring
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): error creating socket: %s"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|sm_errstring
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|#
directive|if
name|NETINET6
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
name|freehostent
argument_list|(
name|hp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NETINET6 */
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|setjmp
argument_list|(
name|MilterConnectTimeout
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SM_EVENT
modifier|*
name|ev
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|mf_timeout
index|[
name|SMFTO_CONNECT
index|]
operator|>
literal|0
condition|)
name|ev
operator|=
name|sm_setevent
argument_list|(
name|m
operator|->
name|mf_timeout
index|[
name|SMFTO_CONNECT
index|]
argument_list|,
name|milter_connect_timeout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
name|connect
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|save_errno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|ev
operator|!=
name|NULL
condition|)
name|sm_clrevent
argument_list|(
name|ev
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
break|break;
block|}
comment|/* couldn't connect.... try next address */
name|save_errno
operator|=
name|errno
expr_stmt|;
name|p
operator|=
name|CurHostName
expr_stmt|;
name|CurHostName
operator|=
name|at
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_open (%s): open %s failed: %s\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|at
argument_list|,
name|sm_errstring
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|13
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): open %s failed: %s"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|at
argument_list|,
name|sm_errstring
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
name|CurHostName
operator|=
name|p
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/* try next address */
if|if
condition|(
name|hp
operator|!=
name|NULL
operator|&&
name|hp
operator|->
name|h_addr_list
index|[
name|addrno
index|]
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|addr
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
if|#
directive|if
name|NETINET
case|case
name|AF_INET
case|:
name|memmove
argument_list|(
operator|&
name|addr
operator|.
name|sin
operator|.
name|sin_addr
argument_list|,
name|hp
operator|->
name|h_addr_list
index|[
name|addrno
operator|++
index|]
argument_list|,
name|INADDRSZ
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET6
case|case
name|AF_INET6
case|:
name|memmove
argument_list|(
operator|&
name|addr
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|,
name|hp
operator|->
name|h_addr_list
index|[
name|addrno
operator|++
index|]
argument_list|,
name|IN6ADDRSZ
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET6 */
default|default:
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"X%s: Unknown protocol for %s (%d)\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|at
argument_list|,
name|hp
operator|->
name|h_addrtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): Unknown protocol for %s (%d)"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|at
argument_list|,
name|hp
operator|->
name|h_addrtype
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|#
directive|if
name|NETINET6
name|freehostent
argument_list|(
name|hp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NETINET6 */
return|return
operator|-
literal|1
return|;
block|}
continue|continue;
block|}
name|p
operator|=
name|CurHostName
expr_stmt|;
name|CurHostName
operator|=
name|at
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"X%s: error connecting to filter: %s\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|sm_errstring
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): error connecting to filter: %s"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|sm_errstring
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
name|CurHostName
operator|=
name|p
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|#
directive|if
name|NETINET6
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
name|freehostent
argument_list|(
name|hp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NETINET6 */
return|return
operator|-
literal|1
return|;
block|}
name|m
operator|->
name|mf_state
operator|=
name|SMFS_OPEN
expr_stmt|;
if|#
directive|if
name|NETINET6
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
block|{
name|freehostent
argument_list|(
name|hp
argument_list|)
expr_stmt|;
name|hp
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NETINET6 */
return|return
name|sock
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|milter_connect_timeout
parameter_list|()
block|{
comment|/* 	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD 	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE 	**	DOING. 	*/
name|errno
operator|=
name|ETIMEDOUT
expr_stmt|;
name|longjmp
argument_list|(
name|MilterConnectTimeout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  MILTER_SETUP -- setup structure for a mail filter ** **	Parameters: **		line -- the options line. ** **	Returns: **		none */
end_comment

begin_function
name|void
name|milter_setup
parameter_list|(
name|line
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
block|{
name|char
name|fcode
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|milter
modifier|*
name|m
decl_stmt|;
name|STAB
modifier|*
name|s
decl_stmt|;
comment|/* collect the filter name */
for|for
control|(
name|p
operator|=
name|line
init|;
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|','
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|;
name|p
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|syserr
argument_list|(
literal|"name required for mail filter"
argument_list|)
expr_stmt|;
return|return;
block|}
name|m
operator|=
operator|(
expr|struct
name|milter
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|m
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|m
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
expr|*
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|mf_name
operator|=
name|newstr
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|m
operator|->
name|mf_state
operator|=
name|SMFS_READY
expr_stmt|;
name|m
operator|->
name|mf_sock
operator|=
operator|-
literal|1
expr_stmt|;
name|m
operator|->
name|mf_timeout
index|[
name|SMFTO_CONNECT
index|]
operator|=
operator|(
name|time_t
operator|)
literal|300
expr_stmt|;
name|m
operator|->
name|mf_timeout
index|[
name|SMFTO_WRITE
index|]
operator|=
operator|(
name|time_t
operator|)
literal|10
expr_stmt|;
name|m
operator|->
name|mf_timeout
index|[
name|SMFTO_READ
index|]
operator|=
operator|(
name|time_t
operator|)
literal|10
expr_stmt|;
name|m
operator|->
name|mf_timeout
index|[
name|SMFTO_EOM
index|]
operator|=
operator|(
name|time_t
operator|)
literal|300
expr_stmt|;
comment|/* now scan through and assign info from the fields */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|delimptr
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|(
operator|*
name|p
operator|==
literal|','
operator|||
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|)
condition|)
name|p
operator|++
expr_stmt|;
comment|/* p now points to field code */
name|fcode
operator|=
operator|*
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|'='
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'='
condition|)
block|{
name|syserr
argument_list|(
literal|"X%s: `=' expected"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
comment|/* p now points to the field body */
name|p
operator|=
name|munchstring
argument_list|(
name|p
argument_list|,
operator|&
name|delimptr
argument_list|,
literal|','
argument_list|)
expr_stmt|;
comment|/* install the field into the filter struct */
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
literal|'S'
case|:
comment|/* socket */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|m
operator|->
name|mf_conn
operator|=
name|NULL
expr_stmt|;
else|else
name|m
operator|->
name|mf_conn
operator|=
name|newstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* Milter flags configured on MTA */
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|)
name|setbitn
argument_list|(
name|bitidx
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|m
operator|->
name|mf_flags
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'T'
case|:
comment|/* timeouts */
name|milter_parse_timeouts
argument_list|(
name|p
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
literal|"X%s: unknown filter equate %c="
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|fcode
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|delimptr
expr_stmt|;
block|}
comment|/* early check for errors */
operator|(
name|void
operator|)
name|milter_open
argument_list|(
name|m
argument_list|,
name|true
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* enter the filter into the symbol table */
name|s
operator|=
name|stab
argument_list|(
name|m
operator|->
name|mf_name
argument_list|,
name|ST_MILTER
argument_list|,
name|ST_ENTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s_milter
operator|!=
name|NULL
condition|)
name|syserr
argument_list|(
literal|"X%s: duplicate filter definition"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
else|else
name|s
operator|->
name|s_milter
operator|=
name|m
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  MILTER_CONFIG -- parse option list into an array and check config ** **	Called when reading configuration file. ** **	Parameters: **		spec -- the filter list. **		list -- the array to fill in. **		max -- the maximum number of entries in list. ** **	Returns: **		none */
end_comment

begin_function
name|void
name|milter_config
parameter_list|(
name|spec
parameter_list|,
name|list
parameter_list|,
name|max
parameter_list|)
name|char
modifier|*
name|spec
decl_stmt|;
name|struct
name|milter
modifier|*
modifier|*
name|list
decl_stmt|;
name|int
name|max
decl_stmt|;
block|{
name|int
name|numitems
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* leave one for the NULL signifying the end of the list */
name|max
operator|--
expr_stmt|;
for|for
control|(
name|p
operator|=
name|spec
init|;
name|p
operator|!=
name|NULL
condition|;
control|)
block|{
name|STAB
modifier|*
name|s
decl_stmt|;
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
name|spec
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|numitems
operator|>=
name|max
condition|)
block|{
name|syserr
argument_list|(
literal|"Too many filters defined, %d max"
argument_list|,
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|>
literal|0
condition|)
name|list
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|_FFR_MILTER_PERDAEMON
name|p
operator|=
name|strpbrk
argument_list|(
name|p
argument_list|,
literal|";,"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* _FFR_MILTER_PERDAEMON */
name|p
operator|=
name|strpbrk
argument_list|(
name|p
argument_list|,
literal|","
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_MILTER_PERDAEMON */
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|stab
argument_list|(
name|spec
argument_list|,
name|ST_MILTER
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"InputFilter %s not defined"
argument_list|,
name|spec
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_CONFIG
expr_stmt|;
return|return;
block|}
name|list
index|[
name|numitems
operator|++
index|]
operator|=
name|s
operator|->
name|s_milter
expr_stmt|;
block|}
name|list
index|[
name|numitems
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* if not set, set to LogLevel */
if|if
condition|(
name|MilterLogLevel
operator|==
operator|-
literal|1
condition|)
name|MilterLogLevel
operator|=
name|LogLevel
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  MILTER_PARSE_TIMEOUTS -- parse timeout list ** **	Called when reading configuration file. ** **	Parameters: **		spec -- the timeout list. **		m -- milter to set. ** **	Returns: **		none */
end_comment

begin_function
specifier|static
name|void
name|milter_parse_timeouts
parameter_list|(
name|spec
parameter_list|,
name|m
parameter_list|)
name|char
modifier|*
name|spec
decl_stmt|;
name|struct
name|milter
modifier|*
name|m
decl_stmt|;
block|{
name|char
name|fcode
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|spec
expr_stmt|;
comment|/* now scan through and assign info from the fields */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|delimptr
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|(
operator|*
name|p
operator|==
literal|';'
operator|||
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|)
condition|)
name|p
operator|++
expr_stmt|;
comment|/* p now points to field code */
name|fcode
operator|=
operator|*
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|':'
condition|)
block|{
name|syserr
argument_list|(
literal|"X%s, T=: `:' expected"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
comment|/* p now points to the field body */
name|p
operator|=
name|munchstring
argument_list|(
name|p
argument_list|,
operator|&
name|delimptr
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
comment|/* install the field into the filter struct */
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
literal|'C'
case|:
name|m
operator|->
name|mf_timeout
index|[
name|SMFTO_CONNECT
index|]
operator|=
name|convtime
argument_list|(
name|p
argument_list|,
literal|'s'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"X%s: %c=%lu\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|fcode
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|m
operator|->
name|mf_timeout
index|[
name|SMFTO_CONNECT
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|m
operator|->
name|mf_timeout
index|[
name|SMFTO_WRITE
index|]
operator|=
name|convtime
argument_list|(
name|p
argument_list|,
literal|'s'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"X%s: %c=%lu\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|fcode
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|m
operator|->
name|mf_timeout
index|[
name|SMFTO_WRITE
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|m
operator|->
name|mf_timeout
index|[
name|SMFTO_READ
index|]
operator|=
name|convtime
argument_list|(
name|p
argument_list|,
literal|'s'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"X%s: %c=%lu\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|fcode
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|m
operator|->
name|mf_timeout
index|[
name|SMFTO_READ
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|m
operator|->
name|mf_timeout
index|[
name|SMFTO_EOM
index|]
operator|=
name|convtime
argument_list|(
name|p
argument_list|,
literal|'s'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"X%s: %c=%lu\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|fcode
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|m
operator|->
name|mf_timeout
index|[
name|SMFTO_EOM
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"X%s: %c unknown\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|fcode
argument_list|)
expr_stmt|;
name|syserr
argument_list|(
literal|"X%s: unknown filter timeout %c"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|fcode
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|delimptr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  MILTER_SET_OPTION -- set an individual milter option ** **	Parameters: **		name -- the name of the option. **		val -- the value of the option. **		sticky -- if set, don't let other setoptions override **			this value. ** **	Returns: **		none. */
end_comment

begin_comment
comment|/* set if Milter sub-option is stuck */
end_comment

begin_decl_stmt
specifier|static
name|BITMAP256
name|StickyMilterOpt
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|milteropt
block|{
name|char
modifier|*
name|mo_name
decl_stmt|;
comment|/* long name of milter option */
name|unsigned
name|char
name|mo_code
decl_stmt|;
comment|/* code for option */
block|}
name|MilterOptTab
index|[]
init|=
block|{
define|#
directive|define
name|MO_MACROS_CONNECT
value|0x01
block|{
literal|"macros.connect"
block|,
name|MO_MACROS_CONNECT
block|}
block|,
define|#
directive|define
name|MO_MACROS_HELO
value|0x02
block|{
literal|"macros.helo"
block|,
name|MO_MACROS_HELO
block|}
block|,
define|#
directive|define
name|MO_MACROS_ENVFROM
value|0x03
block|{
literal|"macros.envfrom"
block|,
name|MO_MACROS_ENVFROM
block|}
block|,
define|#
directive|define
name|MO_MACROS_ENVRCPT
value|0x04
block|{
literal|"macros.envrcpt"
block|,
name|MO_MACROS_ENVRCPT
block|}
block|,
define|#
directive|define
name|MO_LOGLEVEL
value|0x05
block|{
literal|"loglevel"
block|,
name|MO_LOGLEVEL
block|}
block|,
if|#
directive|if
name|_FFR_MILTER_MACROS_EOM
define|#
directive|define
name|MO_MACROS_EOM
value|0x06
block|{
literal|"macros.eom"
block|,
name|MO_MACROS_EOM
block|}
block|,
endif|#
directive|endif
comment|/* _FFR_MILTER_MACROS_EOM */
block|{
name|NULL
block|,
literal|0
block|}
block|, }
struct|;
end_struct

begin_function
name|void
name|milter_set_option
parameter_list|(
name|name
parameter_list|,
name|val
parameter_list|,
name|sticky
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|bool
name|sticky
decl_stmt|;
block|{
name|int
name|nummac
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|milteropt
modifier|*
name|mo
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
modifier|*
name|macros
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|37
argument_list|,
literal|2
argument_list|)
operator|||
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_set_option(%s = %s)"
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"milter_set_option: invalid Milter option, must specify suboption"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|mo
operator|=
name|MilterOptTab
init|;
name|mo
operator|->
name|mo_name
operator|!=
name|NULL
condition|;
name|mo
operator|++
control|)
block|{
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|mo
operator|->
name|mo_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|mo
operator|->
name|mo_name
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"milter_set_option: invalid Milter option %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	**  See if this option is preset for us. 	*/
if|if
condition|(
operator|!
name|sticky
operator|&&
name|bitnset
argument_list|(
name|mo
operator|->
name|mo_code
argument_list|,
name|StickyMilterOpt
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|37
argument_list|,
literal|2
argument_list|)
operator|||
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|" (ignored)\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|37
argument_list|,
literal|2
argument_list|)
operator|||
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mo
operator|->
name|mo_code
condition|)
block|{
case|case
name|MO_LOGLEVEL
case|:
name|MilterLogLevel
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|MO_MACROS_CONNECT
case|:
if|if
condition|(
name|macros
operator|==
name|NULL
condition|)
name|macros
operator|=
name|MilterConnectMacros
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MO_MACROS_HELO
case|:
if|if
condition|(
name|macros
operator|==
name|NULL
condition|)
name|macros
operator|=
name|MilterHeloMacros
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MO_MACROS_ENVFROM
case|:
if|if
condition|(
name|macros
operator|==
name|NULL
condition|)
name|macros
operator|=
name|MilterEnvFromMacros
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MO_MACROS_ENVRCPT
case|:
if|if
condition|(
name|macros
operator|==
name|NULL
condition|)
name|macros
operator|=
name|MilterEnvRcptMacros
expr_stmt|;
if|#
directive|if
name|_FFR_MILTER_MACROS_EOM
comment|/* FALLTHROUGH */
case|case
name|MO_MACROS_EOM
case|:
if|if
condition|(
name|macros
operator|==
name|NULL
condition|)
name|macros
operator|=
name|MilterEOMMacros
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_MILTER_MACROS_EOM */
name|p
operator|=
name|newstr
argument_list|(
name|val
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|macro
decl_stmt|;
comment|/* Skip leading commas, spaces */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|(
operator|*
name|p
operator|==
literal|','
operator|||
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
comment|/* Find end of macro */
name|macro
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|','
operator|&&
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|nummac
operator|>=
name|MAXFILTERMACROS
condition|)
block|{
name|syserr
argument_list|(
literal|"milter_set_option: too many macros in Milter.%s (max %d)"
argument_list|,
name|name
argument_list|,
name|MAXFILTERMACROS
argument_list|)
expr_stmt|;
name|macros
index|[
name|nummac
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|macros
index|[
name|nummac
operator|++
index|]
operator|=
name|macro
expr_stmt|;
block|}
name|macros
index|[
name|nummac
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
literal|"milter_set_option: invalid Milter option %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sticky
condition|)
name|setbitn
argument_list|(
name|mo
operator|->
name|mo_code
argument_list|,
name|StickyMilterOpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  MILTER_REOPEN_DF -- open& truncate the data file (for replbody) ** **	Parameters: **		e -- current envelope. ** **	Returns: **		0 if succesful, -1 otherwise */
end_comment

begin_function
specifier|static
name|int
name|milter_reopen_df
parameter_list|(
name|e
parameter_list|)
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|char
name|dfname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|dfname
argument_list|,
name|queuename
argument_list|(
name|e
argument_list|,
name|DATAFL_LETTER
argument_list|)
argument_list|,
sizeof|sizeof
name|dfname
argument_list|)
expr_stmt|;
comment|/* 	**  In SuperSafe == SAFE_REALLY mode, e->e_dfp is a read-only FP so 	**  close and reopen writable (later close and reopen 	**  read only again). 	** 	**  In SuperSafe != SAFE_REALLY mode, e->e_dfp still points at the 	**  buffered file I/O descriptor, still open for writing 	**  so there isn't as much work to do, just truncate it 	**  and go. 	*/
if|if
condition|(
name|SuperSafe
operator|==
name|SAFE_REALLY
condition|)
block|{
comment|/* close read-only data file */
if|if
condition|(
name|bitset
argument_list|(
name|EF_HAS_DF
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
name|e
operator|->
name|e_dfp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_HAS_DF
expr_stmt|;
block|}
comment|/* open writable */
if|if
condition|(
operator|(
name|e
operator|->
name|e_dfp
operator|=
name|sm_io_open
argument_list|(
name|SmFtStdio
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|dfname
argument_list|,
name|SM_IO_RDWR_B
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|MILTER_DF_ERROR
argument_list|(
literal|"milter_reopen_df: sm_io_open %s: %s"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|==
name|NULL
condition|)
block|{
comment|/* shouldn't happen */
name|errno
operator|=
name|ENOENT
expr_stmt|;
name|MILTER_DF_ERROR
argument_list|(
literal|"milter_reopen_df: NULL e_dfp (%s: %s)"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* **  MILTER_RESET_DF -- re-open read-only the data file (for replbody) ** **	Parameters: **		e -- current envelope. ** **	Returns: **		0 if succesful, -1 otherwise */
end_comment

begin_function
specifier|static
name|int
name|milter_reset_df
parameter_list|(
name|e
parameter_list|)
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|afd
decl_stmt|;
name|char
name|dfname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|dfname
argument_list|,
name|queuename
argument_list|(
name|e
argument_list|,
name|DATAFL_LETTER
argument_list|)
argument_list|,
sizeof|sizeof
name|dfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm_io_flush
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
operator|!=
literal|0
operator|||
name|sm_io_error
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|)
condition|)
block|{
name|MILTER_DF_ERROR
argument_list|(
literal|"milter_reset_df: error writing/flushing %s: %s"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|SuperSafe
operator|!=
name|SAFE_REALLY
condition|)
block|{
comment|/* skip next few clauses */
comment|/* EMPTY */
block|}
elseif|else
if|if
condition|(
operator|(
name|afd
operator|=
name|sm_io_getinfo
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
name|fsync
argument_list|(
name|afd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|MILTER_DF_ERROR
argument_list|(
literal|"milter_reset_df: error sync'ing %s: %s"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|sm_io_close
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
operator|<
literal|0
condition|)
block|{
name|MILTER_DF_ERROR
argument_list|(
literal|"milter_reset_df: error closing %s: %s"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|e
operator|->
name|e_dfp
operator|=
name|sm_io_open
argument_list|(
name|SmFtStdio
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|dfname
argument_list|,
name|SM_IO_RDONLY_B
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|MILTER_DF_ERROR
argument_list|(
literal|"milter_reset_df: error reopening %s: %s"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
name|e
operator|->
name|e_flags
operator||=
name|EF_HAS_DF
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* **  MILTER_CAN_DELRCPTS -- can any milter filters delete recipients? ** **	Parameters: **		none ** **	Returns: **		true if any filter deletes recipients, false otherwise */
end_comment

begin_function
name|bool
name|milter_can_delrcpts
parameter_list|()
block|{
name|bool
name|can
init|=
name|false
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_can_delrcpts:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|InputFilters
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|milter
modifier|*
name|m
init|=
name|InputFilters
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|SMFIF_DELRCPT
argument_list|,
name|m
operator|->
name|mf_fflags
argument_list|)
condition|)
block|{
name|can
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"%s\n"
argument_list|,
name|can
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
return|return
name|can
return|;
block|}
end_function

begin_comment
comment|/* **  MILTER_QUIT_FILTER -- close down a single filter ** **	Parameters: **		m -- milter structure of filter to close down. **		e -- current envelope. ** **	Returns: **		none */
end_comment

begin_function
specifier|static
name|void
name|milter_quit_filter
parameter_list|(
name|m
parameter_list|,
name|e
parameter_list|)
name|struct
name|milter
modifier|*
name|m
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_quit_filter(%s)\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|18
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): quit filter"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
comment|/* Never replace error state */
if|if
condition|(
name|m
operator|->
name|mf_state
operator|==
name|SMFS_ERROR
condition|)
return|return;
if|if
condition|(
name|m
operator|->
name|mf_sock
operator|<
literal|0
operator|||
name|m
operator|->
name|mf_state
operator|==
name|SMFS_CLOSED
operator|||
name|m
operator|->
name|mf_state
operator|==
name|SMFS_READY
condition|)
block|{
name|m
operator|->
name|mf_sock
operator|=
operator|-
literal|1
expr_stmt|;
name|m
operator|->
name|mf_state
operator|=
name|SMFS_CLOSED
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|milter_write
argument_list|(
name|m
argument_list|,
name|SMFIC_QUIT
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|m
operator|->
name|mf_timeout
index|[
name|SMFTO_WRITE
index|]
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|mf_sock
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|m
operator|->
name|mf_sock
argument_list|)
expr_stmt|;
name|m
operator|->
name|mf_sock
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|mf_state
operator|!=
name|SMFS_ERROR
condition|)
name|m
operator|->
name|mf_state
operator|=
name|SMFS_CLOSED
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  MILTER_ABORT_FILTER -- tell filter to abort current message ** **	Parameters: **		m -- milter structure of filter to abort. **		e -- current envelope. ** **	Returns: **		none */
end_comment

begin_function
specifier|static
name|void
name|milter_abort_filter
parameter_list|(
name|m
parameter_list|,
name|e
parameter_list|)
name|struct
name|milter
modifier|*
name|m
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_abort_filter(%s)\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|10
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): abort filter"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|mf_sock
operator|<
literal|0
operator|||
name|m
operator|->
name|mf_state
operator|!=
name|SMFS_INMSG
condition|)
return|return;
operator|(
name|void
operator|)
name|milter_write
argument_list|(
name|m
argument_list|,
name|SMFIC_ABORT
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|m
operator|->
name|mf_timeout
index|[
name|SMFTO_WRITE
index|]
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|mf_state
operator|!=
name|SMFS_ERROR
condition|)
name|m
operator|->
name|mf_state
operator|=
name|SMFS_DONE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  MILTER_SEND_MACROS -- provide macros to the filters ** **	Parameters: **		m -- milter to send macros to. **		macros -- macros to send for filter smfi_getsymval(). **		cmd -- which command the macros are associated with. **		e -- current envelope (for macro access). ** **	Returns: **		none */
end_comment

begin_function
specifier|static
name|void
name|milter_send_macros
parameter_list|(
name|m
parameter_list|,
name|macros
parameter_list|,
name|cmd
parameter_list|,
name|e
parameter_list|)
name|struct
name|milter
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
modifier|*
name|macros
decl_stmt|;
name|char
name|cmd
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|mid
decl_stmt|;
name|char
modifier|*
name|v
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|char
name|exp
index|[
name|MAXLINE
index|]
decl_stmt|;
name|ssize_t
name|s
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|macros
operator|==
name|NULL
operator|||
name|macros
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
return|return;
comment|/* put together data */
name|s
operator|=
literal|1
expr_stmt|;
comment|/* for the command character */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|macros
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|mid
operator|=
name|macid
argument_list|(
name|macros
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|==
literal|0
condition|)
continue|continue;
name|v
operator|=
name|macvalue
argument_list|(
name|mid
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
continue|continue;
name|expand
argument_list|(
name|v
argument_list|,
name|exp
argument_list|,
sizeof|sizeof
argument_list|(
name|exp
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|macros
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|exp
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|<
literal|0
condition|)
return|return;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xalloc
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
name|cmd
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|macros
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|mid
operator|=
name|macid
argument_list|(
name|macros
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|==
literal|0
condition|)
continue|continue;
name|v
operator|=
name|macvalue
argument_list|(
name|mid
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
continue|continue;
name|expand
argument_list|(
name|v
argument_list|,
name|exp
argument_list|,
sizeof|sizeof
argument_list|(
name|exp
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_send_macros(%s, %c): %s=%s\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|cmd
argument_list|,
name|macros
index|[
name|i
index|]
argument_list|,
name|exp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|bp
argument_list|,
name|macros
index|[
name|i
index|]
argument_list|,
name|s
operator|-
operator|(
name|bp
operator|-
name|buf
operator|)
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|bp
argument_list|,
name|exp
argument_list|,
name|s
operator|-
operator|(
name|bp
operator|-
name|buf
operator|)
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|milter_write
argument_list|(
name|m
argument_list|,
name|SMFIC_MACRO
argument_list|,
name|buf
argument_list|,
name|s
argument_list|,
name|m
operator|->
name|mf_timeout
index|[
name|SMFTO_WRITE
index|]
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|sm_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
end_function

begin_comment
comment|/* **  MILTER_SEND_COMMAND -- send a command and return the response for a filter ** **	Parameters: **		m -- current milter filter **		command -- command to send. **		data -- optional command data. **		sz -- length of buf. **		e -- current envelope (for e->e_id). **		state -- return state word. ** **	Returns: **		response string (may be NULL) */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|milter_send_command
parameter_list|(
name|m
parameter_list|,
name|command
parameter_list|,
name|data
parameter_list|,
name|sz
parameter_list|,
name|e
parameter_list|,
name|state
parameter_list|)
name|struct
name|milter
modifier|*
name|m
decl_stmt|;
name|char
name|command
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|ssize_t
name|sz
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|state
decl_stmt|;
block|{
name|char
name|rcmd
decl_stmt|;
name|ssize_t
name|rlen
decl_stmt|;
name|unsigned
name|long
name|skipflag
decl_stmt|;
name|char
modifier|*
name|action
decl_stmt|;
name|char
modifier|*
name|defresponse
decl_stmt|;
name|char
modifier|*
name|response
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_send_command(%s): cmd %c len %ld\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
operator|(
name|char
operator|)
name|command
argument_list|,
operator|(
name|long
operator|)
name|sz
argument_list|)
expr_stmt|;
comment|/* find skip flag and default failure */
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SMFIC_CONNECT
case|:
name|skipflag
operator|=
name|SMFIP_NOCONNECT
expr_stmt|;
name|action
operator|=
literal|"connect"
expr_stmt|;
name|defresponse
operator|=
literal|"554 Command rejected"
expr_stmt|;
break|break;
case|case
name|SMFIC_HELO
case|:
name|skipflag
operator|=
name|SMFIP_NOHELO
expr_stmt|;
name|action
operator|=
literal|"helo"
expr_stmt|;
name|defresponse
operator|=
literal|"550 Command rejected"
expr_stmt|;
break|break;
case|case
name|SMFIC_MAIL
case|:
name|skipflag
operator|=
name|SMFIP_NOMAIL
expr_stmt|;
name|action
operator|=
literal|"mail"
expr_stmt|;
name|defresponse
operator|=
literal|"550 5.7.1 Command rejected"
expr_stmt|;
break|break;
case|case
name|SMFIC_RCPT
case|:
name|skipflag
operator|=
name|SMFIP_NORCPT
expr_stmt|;
name|action
operator|=
literal|"rcpt"
expr_stmt|;
name|defresponse
operator|=
literal|"550 5.7.1 Command rejected"
expr_stmt|;
break|break;
case|case
name|SMFIC_HEADER
case|:
name|skipflag
operator|=
name|SMFIP_NOHDRS
expr_stmt|;
name|action
operator|=
literal|"header"
expr_stmt|;
name|defresponse
operator|=
literal|"550 5.7.1 Command rejected"
expr_stmt|;
break|break;
case|case
name|SMFIC_BODY
case|:
name|skipflag
operator|=
name|SMFIP_NOBODY
expr_stmt|;
name|action
operator|=
literal|"body"
expr_stmt|;
name|defresponse
operator|=
literal|"554 5.7.1 Command rejected"
expr_stmt|;
break|break;
case|case
name|SMFIC_EOH
case|:
name|skipflag
operator|=
name|SMFIP_NOEOH
expr_stmt|;
name|action
operator|=
literal|"eoh"
expr_stmt|;
name|defresponse
operator|=
literal|"550 5.7.1 Command rejected"
expr_stmt|;
break|break;
case|case
name|SMFIC_BODYEOB
case|:
case|case
name|SMFIC_OPTNEG
case|:
case|case
name|SMFIC_MACRO
case|:
case|case
name|SMFIC_ABORT
case|:
case|case
name|SMFIC_QUIT
case|:
comment|/* NOTE: not handled by milter_send_command() */
comment|/* FALLTHROUGH */
default|default:
name|skipflag
operator|=
literal|0
expr_stmt|;
name|action
operator|=
literal|"default"
expr_stmt|;
name|defresponse
operator|=
literal|"550 5.7.1 Command rejected"
expr_stmt|;
break|break;
block|}
comment|/* check if filter wants this command */
if|if
condition|(
name|skipflag
operator|!=
literal|0
operator|&&
name|bitset
argument_list|(
name|skipflag
argument_list|,
name|m
operator|->
name|mf_pflags
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* send the command to the filter */
operator|(
name|void
operator|)
name|milter_write
argument_list|(
name|m
argument_list|,
name|command
argument_list|,
name|data
argument_list|,
name|sz
argument_list|,
name|m
operator|->
name|mf_timeout
index|[
name|SMFTO_WRITE
index|]
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|mf_state
operator|==
name|SMFS_ERROR
condition|)
block|{
name|MILTER_CHECK_ERROR
argument_list|(
argument|false
argument_list|,
argument|return NULL
argument_list|)
empty_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* get the response from the filter */
name|response
operator|=
name|milter_read
argument_list|(
name|m
argument_list|,
operator|&
name|rcmd
argument_list|,
operator|&
name|rlen
argument_list|,
name|m
operator|->
name|mf_timeout
index|[
name|SMFTO_READ
index|]
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|mf_state
operator|==
name|SMFS_ERROR
condition|)
block|{
name|MILTER_CHECK_ERROR
argument_list|(
argument|false
argument_list|,
argument|return NULL
argument_list|)
empty_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_send_command(%s): returned %c\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
operator|(
name|char
operator|)
name|rcmd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rcmd
condition|)
block|{
case|case
name|SMFIR_REPLYCODE
case|:
name|MILTER_CHECK_REPLYCODE
argument_list|(
name|defresponse
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|10
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"milter=%s, action=%s, reject=%s"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|action
argument_list|,
name|response
argument_list|)
expr_stmt|;
operator|*
name|state
operator|=
name|rcmd
expr_stmt|;
break|break;
case|case
name|SMFIR_REJECT
case|:
if|if
condition|(
name|MilterLogLevel
operator|>
literal|10
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"milter=%s, action=%s, reject"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|action
argument_list|)
expr_stmt|;
operator|*
name|state
operator|=
name|rcmd
expr_stmt|;
break|break;
case|case
name|SMFIR_DISCARD
case|:
if|if
condition|(
name|MilterLogLevel
operator|>
literal|10
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"milter=%s, action=%s, discard"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|action
argument_list|)
expr_stmt|;
operator|*
name|state
operator|=
name|rcmd
expr_stmt|;
break|break;
case|case
name|SMFIR_TEMPFAIL
case|:
if|if
condition|(
name|MilterLogLevel
operator|>
literal|10
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"milter=%s, action=%s, tempfail"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|action
argument_list|)
expr_stmt|;
operator|*
name|state
operator|=
name|rcmd
expr_stmt|;
break|break;
case|case
name|SMFIR_ACCEPT
case|:
comment|/* this filter is done with message/connection */
if|if
condition|(
name|command
operator|==
name|SMFIC_HELO
operator|||
name|command
operator|==
name|SMFIC_CONNECT
condition|)
name|m
operator|->
name|mf_state
operator|=
name|SMFS_CLOSABLE
expr_stmt|;
else|else
name|m
operator|->
name|mf_state
operator|=
name|SMFS_DONE
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|10
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"milter=%s, action=%s, accepted"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|action
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMFIR_CONTINUE
case|:
comment|/* if MAIL command is ok, filter is in message state */
if|if
condition|(
name|command
operator|==
name|SMFIC_MAIL
condition|)
name|m
operator|->
name|mf_state
operator|=
name|SMFS_INMSG
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|12
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"milter=%s, action=%s, continue"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|action
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Invalid response to command */
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"milter_send_command(%s): action=%s returned bogus response %c"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|action
argument_list|,
name|rcmd
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|state
operator|!=
name|SMFIR_REPLYCODE
operator|&&
name|response
operator|!=
name|NULL
condition|)
block|{
name|sm_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
comment|/* XXX */
name|response
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|response
return|;
block|}
end_function

begin_comment
comment|/* **  MILTER_COMMAND -- send a command and return the response for each filter ** **	Parameters: **		command -- command to send. **		data -- optional command data. **		sz -- length of buf. **		macros -- macros to send for filter smfi_getsymval(). **		e -- current envelope (for macro access). **		state -- return state word. ** **	Returns: **		response string (may be NULL) */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|milter_command
parameter_list|(
name|command
parameter_list|,
name|data
parameter_list|,
name|sz
parameter_list|,
name|macros
parameter_list|,
name|e
parameter_list|,
name|state
parameter_list|)
name|char
name|command
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|ssize_t
name|sz
decl_stmt|;
name|char
modifier|*
modifier|*
name|macros
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|state
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|response
init|=
name|NULL
decl_stmt|;
name|time_t
name|tn
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_command: cmd %c len %ld\n"
argument_list|,
operator|(
name|char
operator|)
name|command
argument_list|,
operator|(
name|long
operator|)
name|sz
argument_list|)
expr_stmt|;
operator|*
name|state
operator|=
name|SMFIR_CONTINUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|InputFilters
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|milter
modifier|*
name|m
init|=
name|InputFilters
index|[
name|i
index|]
decl_stmt|;
comment|/* previous problem? */
if|if
condition|(
name|m
operator|->
name|mf_state
operator|==
name|SMFS_ERROR
condition|)
block|{
name|MILTER_CHECK_ERROR
argument_list|(
argument|false
argument_list|,
argument|continue
argument_list|)
empty_stmt|;
break|break;
block|}
comment|/* sanity check */
if|if
condition|(
name|m
operator|->
name|mf_sock
operator|<
literal|0
operator|||
operator|(
name|m
operator|->
name|mf_state
operator|!=
name|SMFS_OPEN
operator|&&
name|m
operator|->
name|mf_state
operator|!=
name|SMFS_INMSG
operator|)
condition|)
continue|continue;
comment|/* send macros (regardless of whether we send command) */
if|if
condition|(
name|macros
operator|!=
name|NULL
operator|&&
name|macros
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
name|milter_send_macros
argument_list|(
name|m
argument_list|,
name|macros
argument_list|,
name|command
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|mf_state
operator|==
name|SMFS_ERROR
condition|)
block|{
name|MILTER_CHECK_ERROR
argument_list|(
argument|false
argument_list|,
argument|continue
argument_list|)
empty_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|MilterLogLevel
operator|>
literal|21
condition|)
name|tn
operator|=
name|curtime
argument_list|()
expr_stmt|;
name|response
operator|=
name|milter_send_command
argument_list|(
name|m
argument_list|,
name|command
argument_list|,
name|data
argument_list|,
name|sz
argument_list|,
name|e
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|21
condition|)
block|{
comment|/* log the time it took for the command per filter */
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): time command (%c), %d"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|command
argument_list|,
call|(
name|int
call|)
argument_list|(
name|tn
operator|-
name|curtime
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|state
operator|!=
name|SMFIR_CONTINUE
condition|)
break|break;
block|}
return|return
name|response
return|;
block|}
end_function

begin_comment
comment|/* **  MILTER_NEGOTIATE -- get version and flags from filter ** **	Parameters: **		m -- milter filter structure. **		e -- current envelope. ** **	Returns: **		0 on success, -1 otherwise */
end_comment

begin_function
specifier|static
name|int
name|milter_negotiate
parameter_list|(
name|m
parameter_list|,
name|e
parameter_list|)
name|struct
name|milter
modifier|*
name|m
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|char
name|rcmd
decl_stmt|;
name|mi_int32
name|fvers
decl_stmt|;
name|mi_int32
name|fflags
decl_stmt|;
name|mi_int32
name|pflags
decl_stmt|;
name|char
modifier|*
name|response
decl_stmt|;
name|ssize_t
name|rlen
decl_stmt|;
name|char
name|data
index|[
name|MILTER_OPTLEN
index|]
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|m
operator|->
name|mf_sock
operator|<
literal|0
operator|||
name|m
operator|->
name|mf_state
operator|!=
name|SMFS_OPEN
condition|)
block|{
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): negotiate, impossible state"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|fvers
operator|=
name|htonl
argument_list|(
name|SMFI_VERSION
argument_list|)
expr_stmt|;
name|fflags
operator|=
name|htonl
argument_list|(
name|SMFI_CURR_ACTS
argument_list|)
expr_stmt|;
name|pflags
operator|=
name|htonl
argument_list|(
name|SMFI_CURR_PROT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|data
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fvers
argument_list|,
name|MILTER_LEN_BYTES
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|data
operator|+
name|MILTER_LEN_BYTES
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fflags
argument_list|,
name|MILTER_LEN_BYTES
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|data
operator|+
operator|(
name|MILTER_LEN_BYTES
operator|*
literal|2
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pflags
argument_list|,
name|MILTER_LEN_BYTES
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|milter_write
argument_list|(
name|m
argument_list|,
name|SMFIC_OPTNEG
argument_list|,
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|,
name|m
operator|->
name|mf_timeout
index|[
name|SMFTO_WRITE
index|]
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|mf_state
operator|==
name|SMFS_ERROR
condition|)
return|return
operator|-
literal|1
return|;
name|response
operator|=
name|milter_read
argument_list|(
name|m
argument_list|,
operator|&
name|rcmd
argument_list|,
operator|&
name|rlen
argument_list|,
name|m
operator|->
name|mf_timeout
index|[
name|SMFTO_READ
index|]
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|mf_state
operator|==
name|SMFS_ERROR
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|rcmd
operator|!=
name|SMFIC_OPTNEG
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_negotiate(%s): returned %c instead of %c\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|rcmd
argument_list|,
name|SMFIC_OPTNEG
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): negotiate: returned %c instead of %c"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|rcmd
argument_list|,
name|SMFIC_OPTNEG
argument_list|)
expr_stmt|;
if|if
condition|(
name|response
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
comment|/* XXX */
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Make sure we have enough bytes for the version */
if|if
condition|(
name|response
operator|==
name|NULL
operator|||
name|rlen
operator|<
name|MILTER_LEN_BYTES
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_negotiate(%s): did not return valid info\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): negotiate: did not return valid info"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|response
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
comment|/* XXX */
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* extract information */
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|fvers
argument_list|,
name|response
argument_list|,
name|MILTER_LEN_BYTES
argument_list|)
expr_stmt|;
comment|/* Now make sure we have enough for the feature bitmap */
if|if
condition|(
name|rlen
operator|!=
name|MILTER_OPTLEN
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_negotiate(%s): did not return enough info\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): negotiate: did not return enough info"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|response
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
comment|/* XXX */
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|fflags
argument_list|,
name|response
operator|+
name|MILTER_LEN_BYTES
argument_list|,
name|MILTER_LEN_BYTES
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pflags
argument_list|,
name|response
operator|+
operator|(
name|MILTER_LEN_BYTES
operator|*
literal|2
operator|)
argument_list|,
name|MILTER_LEN_BYTES
argument_list|)
expr_stmt|;
name|sm_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
comment|/* XXX */
name|response
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|mf_fvers
operator|=
name|ntohl
argument_list|(
name|fvers
argument_list|)
expr_stmt|;
name|m
operator|->
name|mf_fflags
operator|=
name|ntohl
argument_list|(
name|fflags
argument_list|)
expr_stmt|;
name|m
operator|->
name|mf_pflags
operator|=
name|ntohl
argument_list|(
name|pflags
argument_list|)
expr_stmt|;
comment|/* check for version compatibility */
if|if
condition|(
name|m
operator|->
name|mf_fvers
operator|==
literal|1
operator|||
name|m
operator|->
name|mf_fvers
operator|>
name|SMFI_VERSION
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_negotiate(%s): version %d != MTA milter version %d\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|m
operator|->
name|mf_fvers
argument_list|,
name|SMFI_VERSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): negotiate: version %d != MTA milter version %d"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|m
operator|->
name|mf_fvers
argument_list|,
name|SMFI_VERSION
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* check for filter feature mismatch */
if|if
condition|(
operator|(
name|m
operator|->
name|mf_fflags
operator|&
name|SMFI_CURR_ACTS
operator|)
operator|!=
name|m
operator|->
name|mf_fflags
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_negotiate(%s): filter abilities 0x%x != MTA milter abilities 0x%lx\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|m
operator|->
name|mf_fflags
argument_list|,
name|SMFI_CURR_ACTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): negotiate: filter abilities 0x%x != MTA milter abilities 0x%lx"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|m
operator|->
name|mf_fflags
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|SMFI_CURR_ACTS
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* check for protocol feature mismatch */
if|if
condition|(
operator|(
name|m
operator|->
name|mf_pflags
operator|&
name|SMFI_CURR_PROT
operator|)
operator|!=
name|m
operator|->
name|mf_pflags
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_negotiate(%s): protocol abilities 0x%x != MTA milter abilities 0x%lx\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|m
operator|->
name|mf_pflags
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|SMFI_CURR_PROT
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): negotiate: protocol abilities 0x%x != MTA milter abilities 0x%lx"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|m
operator|->
name|mf_pflags
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|SMFI_CURR_PROT
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_negotiate(%s): version %u, fflags 0x%x, pflags 0x%x\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|m
operator|->
name|mf_fvers
argument_list|,
name|m
operator|->
name|mf_fflags
argument_list|,
name|m
operator|->
name|mf_pflags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* **  MILTER_PER_CONNECTION_CHECK -- checks on per-connection commands ** **	Reduce code duplication by putting these checks in one place ** **	Parameters: **		e -- current envelope. ** **	Returns: **		none */
end_comment

begin_function
specifier|static
name|void
name|milter_per_connection_check
parameter_list|(
name|e
parameter_list|)
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* see if we are done with any of the filters */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|InputFilters
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|milter
modifier|*
name|m
init|=
name|InputFilters
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|mf_state
operator|==
name|SMFS_CLOSABLE
condition|)
name|milter_quit_filter
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  MILTER_ERROR -- Put a milter filter into error state ** **	Parameters: **		m -- the broken filter. ** **	Returns: **		none */
end_comment

begin_function
specifier|static
name|void
name|milter_error
parameter_list|(
name|m
parameter_list|,
name|e
parameter_list|)
name|struct
name|milter
modifier|*
name|m
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
comment|/* 	**  We could send a quit here but 	**  we may have gotten here due to 	**  an I/O error so we don't want 	**  to try to make things worse. 	*/
if|if
condition|(
name|m
operator|->
name|mf_sock
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|m
operator|->
name|mf_sock
argument_list|)
expr_stmt|;
name|m
operator|->
name|mf_sock
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|m
operator|->
name|mf_state
operator|=
name|SMFS_ERROR
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): to error state"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  MILTER_HEADERS -- send headers to a single milter filter ** **	Parameters: **		m -- current filter. **		e -- current envelope. **		state -- return state from response. ** **	Returns: **		response string (may be NULL) */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|milter_headers
parameter_list|(
name|m
parameter_list|,
name|e
parameter_list|,
name|state
parameter_list|)
name|struct
name|milter
modifier|*
name|m
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|state
decl_stmt|;
block|{
name|char
modifier|*
name|response
init|=
name|NULL
decl_stmt|;
name|HDR
modifier|*
name|h
decl_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|17
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): headers, send"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
for|for
control|(
name|h
operator|=
name|e
operator|->
name|e_header
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|h_link
control|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|ssize_t
name|s
decl_stmt|;
comment|/* don't send over deleted headers */
if|if
condition|(
name|h
operator|->
name|h_value
operator|==
name|NULL
condition|)
block|{
comment|/* strip H_USER so not counted in milter_chgheader() */
name|h
operator|->
name|h_flags
operator|&=
operator|~
name|H_USER
expr_stmt|;
continue|continue;
block|}
comment|/* skip auto-generated */
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|H_USER
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_headers: %s: %s\n"
argument_list|,
name|h
operator|->
name|h_field
argument_list|,
name|h
operator|->
name|h_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|21
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): header, %s"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|h
operator|->
name|h_field
argument_list|)
expr_stmt|;
name|s
operator|=
name|strlen
argument_list|(
name|h
operator|->
name|h_field
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|h
operator|->
name|h_value
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
continue|continue;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xalloc
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
name|s
argument_list|,
literal|"%s%c%s"
argument_list|,
name|h
operator|->
name|h_field
argument_list|,
literal|'\0'
argument_list|,
name|h
operator|->
name|h_value
argument_list|)
expr_stmt|;
comment|/* send it over */
name|response
operator|=
name|milter_send_command
argument_list|(
name|m
argument_list|,
name|SMFIC_HEADER
argument_list|,
name|buf
argument_list|,
name|s
argument_list|,
name|e
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|sm_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|m
operator|->
name|mf_state
operator|==
name|SMFS_ERROR
operator|||
name|m
operator|->
name|mf_state
operator|==
name|SMFS_DONE
operator|||
operator|*
name|state
operator|!=
name|SMFIR_CONTINUE
condition|)
break|break;
block|}
if|if
condition|(
name|MilterLogLevel
operator|>
literal|17
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): headers, sent"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
return|return
name|response
return|;
block|}
end_function

begin_comment
comment|/* **  MILTER_BODY -- send the body to a filter ** **	Parameters: **		m -- current filter. **		e -- current envelope. **		state -- return state from response. ** **	Returns: **		response string (may be NULL) */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|milter_body
parameter_list|(
name|m
parameter_list|,
name|e
parameter_list|,
name|state
parameter_list|)
name|struct
name|milter
modifier|*
name|m
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|state
decl_stmt|;
block|{
name|char
name|bufchar
init|=
literal|'\0'
decl_stmt|;
name|char
name|prevchar
init|=
literal|'\0'
decl_stmt|;
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|response
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
name|char
name|buf
index|[
name|MILTER_CHUNK_SIZE
index|]
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_body\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfrewind
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ExitStat
operator|=
name|EX_IOERR
expr_stmt|;
operator|*
name|state
operator|=
name|SMFIR_TEMPFAIL
expr_stmt|;
name|syserr
argument_list|(
literal|"milter_body: %s/%cf%s: rewind error"
argument_list|,
name|qid_printqueue
argument_list|(
name|e
operator|->
name|e_qgrp
argument_list|,
name|e
operator|->
name|e_qdir
argument_list|)
argument_list|,
name|DATAFL_LETTER
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|MilterLogLevel
operator|>
literal|17
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): body, send"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|sm_io_getc
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
operator|)
operator|!=
name|SM_IO_EOF
condition|)
block|{
comment|/*  Change LF to CRLF */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* Not a CRLF already? */
if|if
condition|(
name|prevchar
operator|!=
literal|'\r'
condition|)
block|{
comment|/* Room for CR now? */
if|if
condition|(
name|bp
operator|+
literal|2
operator|>
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
index|]
condition|)
block|{
comment|/* No room, buffer LF */
name|bufchar
operator|=
name|c
expr_stmt|;
comment|/* and send CR now */
name|c
operator|=
literal|'\r'
expr_stmt|;
block|}
else|else
block|{
comment|/* Room to do it now */
operator|*
name|bp
operator|++
operator|=
literal|'\r'
expr_stmt|;
name|prevchar
operator|=
literal|'\r'
expr_stmt|;
block|}
block|}
block|}
operator|*
name|bp
operator|++
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
name|prevchar
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|bp
operator|>=
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
index|]
condition|)
block|{
comment|/* send chunk */
name|response
operator|=
name|milter_send_command
argument_list|(
name|m
argument_list|,
name|SMFIC_BODY
argument_list|,
name|buf
argument_list|,
name|bp
operator|-
name|buf
argument_list|,
name|e
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|bufchar
operator|!=
literal|'\0'
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
name|bufchar
expr_stmt|;
name|bufchar
operator|=
literal|'\0'
expr_stmt|;
name|prevchar
operator|=
name|bufchar
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
operator|->
name|mf_state
operator|==
name|SMFS_ERROR
operator|||
name|m
operator|->
name|mf_state
operator|==
name|SMFS_DONE
operator|||
operator|*
name|state
operator|!=
name|SMFIR_CONTINUE
condition|)
break|break;
block|}
comment|/* check for read errors */
if|if
condition|(
name|sm_io_error
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|)
condition|)
block|{
name|ExitStat
operator|=
name|EX_IOERR
expr_stmt|;
if|if
condition|(
operator|*
name|state
operator|==
name|SMFIR_CONTINUE
operator|||
operator|*
name|state
operator|==
name|SMFIR_ACCEPT
condition|)
block|{
operator|*
name|state
operator|=
name|SMFIR_TEMPFAIL
expr_stmt|;
if|if
condition|(
name|response
operator|!=
name|NULL
condition|)
block|{
name|sm_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
comment|/* XXX */
name|response
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|syserr
argument_list|(
literal|"milter_body: %s/%cf%s: read error"
argument_list|,
name|qid_printqueue
argument_list|(
name|e
operator|->
name|e_qgrp
argument_list|,
name|e
operator|->
name|e_qdir
argument_list|)
argument_list|,
name|DATAFL_LETTER
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
return|return
name|response
return|;
block|}
comment|/* send last body chunk */
if|if
condition|(
name|bp
operator|>
name|buf
operator|&&
name|m
operator|->
name|mf_state
operator|!=
name|SMFS_ERROR
operator|&&
name|m
operator|->
name|mf_state
operator|!=
name|SMFS_DONE
operator|&&
operator|*
name|state
operator|==
name|SMFIR_CONTINUE
condition|)
block|{
comment|/* send chunk */
name|response
operator|=
name|milter_send_command
argument_list|(
name|m
argument_list|,
name|SMFIC_BODY
argument_list|,
name|buf
argument_list|,
name|bp
operator|-
name|buf
argument_list|,
name|e
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
block|}
if|if
condition|(
name|MilterLogLevel
operator|>
literal|17
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): body, sent"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
return|return
name|response
return|;
block|}
end_function

begin_comment
comment|/* **  Actions */
end_comment

begin_comment
comment|/* **  MILTER_ADDHEADER -- Add the supplied header to the message ** **	Parameters: **		response -- encoded form of header/value. **		rlen -- length of response. **		e -- current envelope. ** **	Returns: **		none */
end_comment

begin_function
specifier|static
name|void
name|milter_addheader
parameter_list|(
name|response
parameter_list|,
name|rlen
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|response
decl_stmt|;
name|ssize_t
name|rlen
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|HDR
modifier|*
name|h
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_addheader: "
argument_list|)
expr_stmt|;
comment|/* sanity checks */
if|if
condition|(
name|response
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"NULL response\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rlen
operator|<
literal|2
operator|||
name|strlen
argument_list|(
name|response
argument_list|)
operator|+
literal|1
operator|>=
operator|(
name|size_t
operator|)
name|rlen
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"didn't follow protocol (total len)\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find separating NUL */
name|val
operator|=
name|response
operator|+
name|strlen
argument_list|(
name|response
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* another sanity check */
if|if
condition|(
name|strlen
argument_list|(
name|response
argument_list|)
operator|+
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|2
operator|!=
operator|(
name|size_t
operator|)
name|rlen
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"didn't follow protocol (part len)\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|response
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"empty field name\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|h
operator|=
name|e
operator|->
name|e_header
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|h_link
control|)
block|{
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|h
operator|->
name|h_field
argument_list|,
name|response
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|bitset
argument_list|(
name|H_USER
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|H_TRACE
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
break|break;
block|}
comment|/* add to e_msgsize */
name|e
operator|->
name|e_msgsize
operator|+=
name|strlen
argument_list|(
name|response
argument_list|)
operator|+
literal|2
operator|+
name|strlen
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"Replace default header %s value with %s\n"
argument_list|,
name|h
operator|->
name|h_field
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|8
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter change: default header %s value with %s"
argument_list|,
name|h
operator|->
name|h_field
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_value
operator|=
name|newstr
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_flags
operator||=
name|H_USER
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"Add %s: %s\n"
argument_list|,
name|response
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|8
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter add: header: %s: %s"
argument_list|,
name|response
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|addheader
argument_list|(
name|newstr
argument_list|(
name|response
argument_list|)
argument_list|,
name|val
argument_list|,
name|H_USER
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  MILTER_CHANGEHEADER -- Change the supplied header in the message ** **	Parameters: **		response -- encoded form of header/index/value. **		rlen -- length of response. **		e -- current envelope. ** **	Returns: **		none */
end_comment

begin_function
specifier|static
name|void
name|milter_changeheader
parameter_list|(
name|response
parameter_list|,
name|rlen
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|response
decl_stmt|;
name|ssize_t
name|rlen
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|mi_int32
name|i
decl_stmt|,
name|index
decl_stmt|;
name|char
modifier|*
name|field
decl_stmt|,
modifier|*
name|val
decl_stmt|;
name|HDR
modifier|*
name|h
decl_stmt|,
modifier|*
name|sysheader
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_changeheader: "
argument_list|)
expr_stmt|;
comment|/* sanity checks */
if|if
condition|(
name|response
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"NULL response\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rlen
operator|<
literal|2
operator|||
name|strlen
argument_list|(
name|response
argument_list|)
operator|+
literal|1
operator|>=
operator|(
name|size_t
operator|)
name|rlen
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"didn't follow protocol (total len)\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find separating NUL */
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|i
argument_list|,
name|response
argument_list|,
name|MILTER_LEN_BYTES
argument_list|)
expr_stmt|;
name|index
operator|=
name|ntohl
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|field
operator|=
name|response
operator|+
name|MILTER_LEN_BYTES
expr_stmt|;
name|val
operator|=
name|field
operator|+
name|strlen
argument_list|(
name|field
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* another sanity check */
if|if
condition|(
name|MILTER_LEN_BYTES
operator|+
name|strlen
argument_list|(
name|field
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|1
operator|!=
operator|(
name|size_t
operator|)
name|rlen
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"didn't follow protocol (part len)\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|field
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"empty field name\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sysheader
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|h
operator|=
name|e
operator|->
name|e_header
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|h_link
control|)
block|{
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|h
operator|->
name|h_field
argument_list|,
name|field
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|H_USER
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
operator|--
name|index
operator|<=
literal|0
condition|)
block|{
name|sysheader
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|H_USER
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|H_TRACE
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
block|{
comment|/* 				**  DRUMS msg-fmt draft says can only have 				**  multiple occurences of trace fields, 				**  so make sure we replace any non-trace, 				**  non-user field. 				*/
name|sysheader
operator|=
name|h
expr_stmt|;
block|}
block|}
block|}
comment|/* if not found as user-provided header at index, use sysheader */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
name|h
operator|=
name|sysheader
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|val
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"Delete (noop) %s:\n"
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* treat modify value with no existing header as add */
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"Add %s: %s\n"
argument_list|,
name|field
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|addheader
argument_list|(
name|newstr
argument_list|(
name|field
argument_list|)
argument_list|,
name|val
argument_list|,
name|H_USER
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|val
operator|==
literal|'\0'
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"Delete%s %s: %s\n"
argument_list|,
name|h
operator|==
name|sysheader
condition|?
literal|" (default header)"
else|:
literal|""
argument_list|,
name|field
argument_list|,
name|h
operator|->
name|h_value
operator|==
name|NULL
condition|?
literal|"<NULL>"
else|:
name|h
operator|->
name|h_value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sm_dprintf
argument_list|(
literal|"Change%s %s: from %s to %s\n"
argument_list|,
name|h
operator|==
name|sysheader
condition|?
literal|" (default header)"
else|:
literal|""
argument_list|,
name|field
argument_list|,
name|h
operator|->
name|h_value
operator|==
name|NULL
condition|?
literal|"<NULL>"
else|:
name|h
operator|->
name|h_value
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|MilterLogLevel
operator|>
literal|8
condition|)
block|{
if|if
condition|(
operator|*
name|val
operator|==
literal|'\0'
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter delete: header %s %s: %s"
argument_list|,
name|h
operator|==
name|sysheader
condition|?
literal|" (default header)"
else|:
literal|""
argument_list|,
name|field
argument_list|,
name|h
operator|->
name|h_value
operator|==
name|NULL
condition|?
literal|"<NULL>"
else|:
name|h
operator|->
name|h_value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter change: header %s %s: from %s to %s"
argument_list|,
name|h
operator|==
name|sysheader
condition|?
literal|" (default header)"
else|:
literal|""
argument_list|,
name|field
argument_list|,
name|h
operator|->
name|h_value
operator|==
name|NULL
condition|?
literal|"<NULL>"
else|:
name|h
operator|->
name|h_value
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|h
operator|!=
name|sysheader
operator|&&
name|h
operator|->
name|h_value
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|l
decl_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|h
operator|->
name|h_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|e
operator|->
name|e_msgsize
condition|)
name|e
operator|->
name|e_msgsize
operator|=
literal|0
expr_stmt|;
else|else
name|e
operator|->
name|e_msgsize
operator|-=
name|l
expr_stmt|;
comment|/* rpool, don't free: sm_free(h->h_value); XXX */
block|}
if|if
condition|(
operator|*
name|val
operator|==
literal|'\0'
condition|)
block|{
comment|/* Remove "Field: " from message size */
if|if
condition|(
name|h
operator|!=
name|sysheader
condition|)
block|{
name|size_t
name|l
decl_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|h
operator|->
name|h_field
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|e
operator|->
name|e_msgsize
condition|)
name|e
operator|->
name|e_msgsize
operator|=
literal|0
expr_stmt|;
else|else
name|e
operator|->
name|e_msgsize
operator|-=
name|l
expr_stmt|;
block|}
name|h
operator|->
name|h_value
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|h
operator|->
name|h_value
operator|=
name|newstr
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_flags
operator||=
name|H_USER
expr_stmt|;
name|e
operator|->
name|e_msgsize
operator|+=
name|strlen
argument_list|(
name|h
operator|->
name|h_value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  MILTER_ADDRCPT -- Add the supplied recipient to the message ** **	Parameters: **		response -- encoded form of recipient address. **		rlen -- length of response. **		e -- current envelope. ** **	Returns: **		none */
end_comment

begin_function
specifier|static
name|void
name|milter_addrcpt
parameter_list|(
name|response
parameter_list|,
name|rlen
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|response
decl_stmt|;
name|ssize_t
name|rlen
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|olderrors
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_addrcpt: "
argument_list|)
expr_stmt|;
comment|/* sanity checks */
if|if
condition|(
name|response
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"NULL response\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|response
operator|==
literal|'\0'
operator|||
name|strlen
argument_list|(
name|response
argument_list|)
operator|+
literal|1
operator|!=
operator|(
name|size_t
operator|)
name|rlen
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"didn't follow protocol (total len %d != rlen %d)\n"
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|response
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|rlen
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"%s\n"
argument_list|,
name|response
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|8
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter add: rcpt: %s"
argument_list|,
name|response
argument_list|)
expr_stmt|;
name|olderrors
operator|=
name|Errors
expr_stmt|;
operator|(
name|void
operator|)
name|sendtolist
argument_list|(
name|response
argument_list|,
name|NULLADDR
argument_list|,
operator|&
name|e
operator|->
name|e_sendqueue
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|Errors
operator|=
name|olderrors
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* **  MILTER_DELRCPT -- Delete the supplied recipient from the message ** **	Parameters: **		response -- encoded form of recipient address. **		rlen -- length of response. **		e -- current envelope. ** **	Returns: **		none */
end_comment

begin_function
specifier|static
name|void
name|milter_delrcpt
parameter_list|(
name|response
parameter_list|,
name|rlen
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|response
decl_stmt|;
name|ssize_t
name|rlen
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_delrcpt: "
argument_list|)
expr_stmt|;
comment|/* sanity checks */
if|if
condition|(
name|response
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"NULL response\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|response
operator|==
literal|'\0'
operator|||
name|strlen
argument_list|(
name|response
argument_list|)
operator|+
literal|1
operator|!=
operator|(
name|size_t
operator|)
name|rlen
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"didn't follow protocol (total len)\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"%s\n"
argument_list|,
name|response
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|8
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter delete: rcpt %s"
argument_list|,
name|response
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|removefromlist
argument_list|(
name|response
argument_list|,
operator|&
name|e
operator|->
name|e_sendqueue
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* **  MILTER_REPLBODY -- Replace the current data file with new body ** **	Parameters: **		response -- encoded form of new body. **		rlen -- length of response. **		newfilter -- if first time called by a new filter **		e -- current envelope. ** **	Returns: **		0 upon success, -1 upon failure */
end_comment

begin_function
specifier|static
name|int
name|milter_replbody
parameter_list|(
name|response
parameter_list|,
name|rlen
parameter_list|,
name|newfilter
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|response
decl_stmt|;
name|ssize_t
name|rlen
decl_stmt|;
name|bool
name|newfilter
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|static
name|char
name|prevchar
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_replbody\n"
argument_list|)
expr_stmt|;
comment|/* If a new filter, reset previous character and truncate data file */
if|if
condition|(
name|newfilter
condition|)
block|{
name|off_t
name|prevsize
decl_stmt|;
name|char
name|dfname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|dfname
argument_list|,
name|queuename
argument_list|(
name|e
argument_list|,
name|DATAFL_LETTER
argument_list|)
argument_list|,
sizeof|sizeof
name|dfname
argument_list|)
expr_stmt|;
comment|/* Reset prevchar */
name|prevchar
operator|=
literal|'\0'
expr_stmt|;
comment|/* Get the current data file information */
name|prevsize
operator|=
name|sm_io_getinfo
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
name|SM_IO_WHAT_SIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|prevsize
operator|<
literal|0
condition|)
name|prevsize
operator|=
literal|0
expr_stmt|;
comment|/* truncate current data file */
if|if
condition|(
name|sm_io_getinfo
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
name|SM_IO_WHAT_ISTYPE
argument_list|,
name|BF_FILE_TYPE
argument_list|)
condition|)
block|{
if|if
condition|(
name|sm_io_setinfo
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
name|SM_BF_TRUNCATE
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|MILTER_DF_ERROR
argument_list|(
literal|"milter_replbody: sm_io truncate %s: %s"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|sm_io_error
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_flush
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
comment|/* 			**  Clear error if tried to fflush() 			**  a read-only file pointer and 			**  there wasn't a previous error. 			*/
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|sm_io_clearerr
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|)
expr_stmt|;
comment|/* errno is set implicitly by fseek() before return */
name|err
operator|=
name|sm_io_seek
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
name|MILTER_DF_ERROR
argument_list|(
literal|"milter_replbody: sm_io_seek %s: %s"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|#
directive|if
name|NOFTRUNCATE
comment|/* XXX: Not much we can do except rewind it */
name|errno
operator|=
name|EINVAL
expr_stmt|;
name|MILTER_DF_ERROR
argument_list|(
literal|"milter_replbody: ftruncate not available on this platform (%s:%s)"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
else|#
directive|else
comment|/* NOFTRUNCATE */
name|err
operator|=
name|ftruncate
argument_list|(
name|sm_io_getinfo
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
name|MILTER_DF_ERROR
argument_list|(
literal|"milter_replbody: sm_io ftruncate %s: %s"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* NOFTRUNCATE */
block|}
if|if
condition|(
name|prevsize
operator|>
name|e
operator|->
name|e_msgsize
condition|)
name|e
operator|->
name|e_msgsize
operator|=
literal|0
expr_stmt|;
else|else
name|e
operator|->
name|e_msgsize
operator|-=
name|prevsize
expr_stmt|;
block|}
if|if
condition|(
name|newfilter
operator|&&
name|MilterLogLevel
operator|>
literal|8
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter message: body replaced"
argument_list|)
expr_stmt|;
if|if
condition|(
name|response
operator|==
name|NULL
condition|)
block|{
comment|/* Flush the buffered '\r' */
if|if
condition|(
name|prevchar
operator|==
literal|'\r'
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|prevchar
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_msgsize
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rlen
condition|;
name|i
operator|++
control|)
block|{
comment|/* Buffered char from last chunk */
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|prevchar
operator|==
literal|'\r'
condition|)
block|{
comment|/* Not CRLF, output prevchar */
if|if
condition|(
name|response
index|[
name|i
index|]
operator|!=
literal|'\n'
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|prevchar
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_msgsize
operator|++
expr_stmt|;
block|}
name|prevchar
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Turn CRLF into LF */
if|if
condition|(
name|response
index|[
name|i
index|]
operator|==
literal|'\r'
condition|)
block|{
comment|/* check if at end of chunk */
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|rlen
condition|)
block|{
comment|/* If LF, strip CR */
if|if
condition|(
name|response
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* check next chunk */
name|prevchar
operator|=
literal|'\r'
expr_stmt|;
continue|continue;
block|}
block|}
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|response
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_msgsize
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* **  MTA callouts */
end_comment

begin_comment
comment|/* **  MILTER_INIT -- open and negotiate with all of the filters ** **	Parameters: **		e -- current envelope. **		state -- return state from response. ** **	Returns: **		true iff at least one filter is active */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|bool
name|milter_init
parameter_list|(
name|e
parameter_list|,
name|state
parameter_list|)
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|state
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_init\n"
argument_list|)
expr_stmt|;
operator|*
name|state
operator|=
name|SMFIR_CONTINUE
expr_stmt|;
if|if
condition|(
name|InputFilters
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|MilterLogLevel
operator|>
literal|10
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: no active filter"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|InputFilters
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|milter
modifier|*
name|m
init|=
name|InputFilters
index|[
name|i
index|]
decl_stmt|;
name|m
operator|->
name|mf_sock
operator|=
name|milter_open
argument_list|(
name|m
argument_list|,
name|false
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|mf_state
operator|==
name|SMFS_ERROR
condition|)
block|{
name|MILTER_CHECK_ERROR
argument_list|(
argument|true
argument_list|,
argument|continue
argument_list|)
empty_stmt|;
break|break;
block|}
if|if
condition|(
name|m
operator|->
name|mf_sock
operator|<
literal|0
operator|||
name|milter_negotiate
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
operator|<
literal|0
operator|||
name|m
operator|->
name|mf_state
operator|==
name|SMFS_ERROR
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_init(%s): failed to %s\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|m
operator|->
name|mf_sock
operator|<
literal|0
condition|?
literal|"open"
else|:
literal|"negotiate"
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): init failed to %s"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|m
operator|->
name|mf_sock
operator|<
literal|0
condition|?
literal|"open"
else|:
literal|"negotiate"
argument_list|)
expr_stmt|;
comment|/* if negotation failure, close socket */
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|MILTER_CHECK_ERROR
argument_list|(
argument|true
argument_list|,
argument|continue
argument_list|)
empty_stmt|;
block|}
if|if
condition|(
name|MilterLogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter (%s): init success to %s"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|m
operator|->
name|mf_sock
operator|<
literal|0
condition|?
literal|"open"
else|:
literal|"negotiate"
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  If something temp/perm failed with one of the filters, 	**  we won't be using any of them, so clear any existing 	**  connections. 	*/
if|if
condition|(
operator|*
name|state
operator|!=
name|SMFIR_CONTINUE
condition|)
name|milter_quit
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* **  MILTER_CONNECT -- send connection info to milter filters ** **	Parameters: **		hostname -- hostname of remote machine. **		addr -- address of remote machine. **		e -- current envelope. **		state -- return state from response. ** **	Returns: **		response string (may be NULL) */
end_comment

begin_function
name|char
modifier|*
name|milter_connect
parameter_list|(
name|hostname
parameter_list|,
name|addr
parameter_list|,
name|e
parameter_list|,
name|state
parameter_list|)
name|char
modifier|*
name|hostname
decl_stmt|;
name|SOCKADDR
name|addr
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|state
decl_stmt|;
block|{
name|char
name|family
decl_stmt|;
name|unsigned
name|short
name|port
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|response
decl_stmt|;
name|char
modifier|*
name|sockinfo
init|=
name|NULL
decl_stmt|;
name|ssize_t
name|s
decl_stmt|;
if|#
directive|if
name|NETINET6
name|char
name|buf6
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* NETINET6 */
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_connect(%s)\n"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: connect to filters"
argument_list|)
expr_stmt|;
comment|/* gather data */
switch|switch
condition|(
name|addr
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
if|#
directive|if
name|NETUNIX
case|case
name|AF_UNIX
case|:
name|family
operator|=
name|SMFIA_UNIX
expr_stmt|;
name|port
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sockinfo
operator|=
name|addr
operator|.
name|sunix
operator|.
name|sun_path
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETUNIX */
if|#
directive|if
name|NETINET
case|case
name|AF_INET
case|:
name|family
operator|=
name|SMFIA_INET
expr_stmt|;
name|port
operator|=
name|addr
operator|.
name|sin
operator|.
name|sin_port
expr_stmt|;
name|sockinfo
operator|=
operator|(
name|char
operator|*
operator|)
name|inet_ntoa
argument_list|(
name|addr
operator|.
name|sin
operator|.
name|sin_addr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET */
if|#
directive|if
name|NETINET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|addr
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
name|family
operator|=
name|SMFIA_INET
expr_stmt|;
else|else
name|family
operator|=
name|SMFIA_INET6
expr_stmt|;
name|port
operator|=
name|addr
operator|.
name|sin6
operator|.
name|sin6_port
expr_stmt|;
name|sockinfo
operator|=
name|anynet_ntop
argument_list|(
operator|&
name|addr
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|,
name|buf6
argument_list|,
sizeof|sizeof
name|buf6
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockinfo
operator|==
name|NULL
condition|)
name|sockinfo
operator|=
literal|""
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET6 */
default|default:
name|family
operator|=
name|SMFIA_UNKNOWN
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|strlen
argument_list|(
name|hostname
argument_list|)
operator|+
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|family
argument_list|)
expr_stmt|;
if|if
condition|(
name|family
operator|!=
name|SMFIA_UNKNOWN
condition|)
name|s
operator|+=
sizeof|sizeof
argument_list|(
name|port
argument_list|)
operator|+
name|strlen
argument_list|(
name|sockinfo
argument_list|)
operator|+
literal|1
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xalloc
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
comment|/* put together data */
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|bp
argument_list|,
name|hostname
argument_list|,
name|strlen
argument_list|(
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|bp
argument_list|,
operator|&
name|family
argument_list|,
sizeof|sizeof
name|family
argument_list|)
expr_stmt|;
name|bp
operator|+=
sizeof|sizeof
name|family
expr_stmt|;
if|if
condition|(
name|family
operator|!=
name|SMFIA_UNKNOWN
condition|)
block|{
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|bp
argument_list|,
operator|&
name|port
argument_list|,
sizeof|sizeof
name|port
argument_list|)
expr_stmt|;
name|bp
operator|+=
sizeof|sizeof
name|port
expr_stmt|;
comment|/* include trailing '\0' */
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|bp
argument_list|,
name|sockinfo
argument_list|,
name|strlen
argument_list|(
name|sockinfo
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|response
operator|=
name|milter_command
argument_list|(
name|SMFIC_CONNECT
argument_list|,
name|buf
argument_list|,
name|s
argument_list|,
name|MilterConnectMacros
argument_list|,
name|e
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|sm_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* XXX */
comment|/* 	**  If this message connection is done for, 	**  close the filters. 	*/
if|if
condition|(
operator|*
name|state
operator|!=
name|SMFIR_CONTINUE
condition|)
block|{
if|if
condition|(
name|MilterLogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: connect, ending"
argument_list|)
expr_stmt|;
name|milter_quit
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
else|else
name|milter_per_connection_check
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* 	**  SMFIR_REPLYCODE can't work with connect due to 	**  the requirements of SMTP.  Therefore, ignore the 	**  reply code text but keep the state it would reflect. 	*/
if|if
condition|(
operator|*
name|state
operator|==
name|SMFIR_REPLYCODE
condition|)
block|{
if|if
condition|(
name|response
operator|!=
name|NULL
operator|&&
operator|*
name|response
operator|==
literal|'4'
condition|)
block|{
if|#
directive|if
name|_FFR_MILTER_421
if|if
condition|(
name|strncmp
argument_list|(
name|response
argument_list|,
literal|"421 "
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|state
operator|=
name|SMFIR_SHUTDOWN
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* _FFR_MILTER_421 */
operator|*
name|state
operator|=
name|SMFIR_TEMPFAIL
expr_stmt|;
block|}
else|else
operator|*
name|state
operator|=
name|SMFIR_REJECT
expr_stmt|;
if|if
condition|(
name|response
operator|!=
name|NULL
condition|)
block|{
name|sm_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
comment|/* XXX */
name|response
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|response
return|;
block|}
end_function

begin_comment
comment|/* **  MILTER_HELO -- send SMTP HELO/EHLO command info to milter filters ** **	Parameters: **		helo -- argument to SMTP HELO/EHLO command. **		e -- current envelope. **		state -- return state from response. ** **	Returns: **		response string (may be NULL) */
end_comment

begin_function
name|char
modifier|*
name|milter_helo
parameter_list|(
name|helo
parameter_list|,
name|e
parameter_list|,
name|state
parameter_list|)
name|char
modifier|*
name|helo
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|state
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|response
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_helo(%s)\n"
argument_list|,
name|helo
argument_list|)
expr_stmt|;
comment|/* HELO/EHLO can come at any point */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|InputFilters
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|milter
modifier|*
name|m
init|=
name|InputFilters
index|[
name|i
index|]
decl_stmt|;
switch|switch
condition|(
name|m
operator|->
name|mf_state
condition|)
block|{
case|case
name|SMFS_INMSG
case|:
comment|/* abort in message filters */
name|milter_abort_filter
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|SMFS_DONE
case|:
comment|/* reset done filters */
name|m
operator|->
name|mf_state
operator|=
name|SMFS_OPEN
expr_stmt|;
break|break;
block|}
block|}
name|response
operator|=
name|milter_command
argument_list|(
name|SMFIC_HELO
argument_list|,
name|helo
argument_list|,
name|strlen
argument_list|(
name|helo
argument_list|)
operator|+
literal|1
argument_list|,
name|MilterHeloMacros
argument_list|,
name|e
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|milter_per_connection_check
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|response
return|;
block|}
end_function

begin_comment
comment|/* **  MILTER_ENVFROM -- send SMTP MAIL command info to milter filters ** **	Parameters: **		args -- SMTP MAIL command args (args[0] == sender). **		e -- current envelope. **		state -- return state from response. ** **	Returns: **		response string (may be NULL) */
end_comment

begin_function
name|char
modifier|*
name|milter_envfrom
parameter_list|(
name|args
parameter_list|,
name|e
parameter_list|,
name|state
parameter_list|)
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|state
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|response
decl_stmt|;
name|ssize_t
name|s
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"milter_envfrom:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|args
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|sm_dprintf
argument_list|(
literal|" %s"
argument_list|,
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* sanity check */
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
operator|*
name|state
operator|=
name|SMFIR_REJECT
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|10
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: reject, no sender"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* new message, so ... */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|InputFilters
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|milter
modifier|*
name|m
init|=
name|InputFilters
index|[
name|i
index|]
decl_stmt|;
switch|switch
condition|(
name|m
operator|->
name|mf_state
condition|)
block|{
case|case
name|SMFS_INMSG
case|:
comment|/* abort in message filters */
name|milter_abort_filter
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|SMFS_DONE
case|:
comment|/* reset done filters */
name|m
operator|->
name|mf_state
operator|=
name|SMFS_OPEN
expr_stmt|;
break|break;
block|}
block|}
comment|/* put together data */
name|s
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|args
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|s
operator|+=
name|strlen
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
operator|*
name|state
operator|=
name|SMFIR_TEMPFAIL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xalloc
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|args
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|bp
argument_list|,
name|args
index|[
name|i
index|]
argument_list|,
name|s
operator|-
operator|(
name|bp
operator|-
name|buf
operator|)
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|MilterLogLevel
operator|>
literal|14
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: senders: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* send it over */
name|response
operator|=
name|milter_command
argument_list|(
name|SMFIC_MAIL
argument_list|,
name|buf
argument_list|,
name|s
argument_list|,
name|MilterEnvFromMacros
argument_list|,
name|e
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|sm_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* XXX */
comment|/* 	**  If filter rejects/discards a per message command, 	**  abort the other filters since we are done with the 	**  current message. 	*/
name|MILTER_CHECK_DONE_MSG
argument_list|()
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|10
operator|&&
operator|*
name|state
operator|==
name|SMFIR_REJECT
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: reject, senders"
argument_list|)
expr_stmt|;
return|return
name|response
return|;
block|}
end_function

begin_comment
comment|/* **  MILTER_ENVRCPT -- send SMTP RCPT command info to milter filters ** **	Parameters: **		args -- SMTP MAIL command args (args[0] == recipient). **		e -- current envelope. **		state -- return state from response. ** **	Returns: **		response string (may be NULL) */
end_comment

begin_function
name|char
modifier|*
name|milter_envrcpt
parameter_list|(
name|args
parameter_list|,
name|e
parameter_list|,
name|state
parameter_list|)
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|state
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|response
decl_stmt|;
name|ssize_t
name|s
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"milter_envrcpt:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|args
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|sm_dprintf
argument_list|(
literal|" %s"
argument_list|,
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* sanity check */
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
operator|*
name|state
operator|=
name|SMFIR_REJECT
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|10
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: reject, no rcpt"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* put together data */
name|s
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|args
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|s
operator|+=
name|strlen
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
operator|*
name|state
operator|=
name|SMFIR_TEMPFAIL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xalloc
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|args
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|bp
argument_list|,
name|args
index|[
name|i
index|]
argument_list|,
name|s
operator|-
operator|(
name|bp
operator|-
name|buf
operator|)
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|MilterLogLevel
operator|>
literal|14
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: rcpts: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* send it over */
name|response
operator|=
name|milter_command
argument_list|(
name|SMFIC_RCPT
argument_list|,
name|buf
argument_list|,
name|s
argument_list|,
name|MilterEnvRcptMacros
argument_list|,
name|e
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|sm_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* XXX */
return|return
name|response
return|;
block|}
end_function

begin_comment
comment|/* **  MILTER_DATA -- send message headers/body and gather final message results ** **	Parameters: **		e -- current envelope. **		state -- return state from response. ** **	Returns: **		response string (may be NULL) ** **	Side effects: **		- Uses e->e_dfp for access to the body **		- Can call the various milter action routines to **		  modify the envelope or message. */
end_comment

begin_define
define|#
directive|define
name|MILTER_CHECK_RESULTS
parameter_list|()
define|\
value|if (*state == SMFIR_ACCEPT || \ 	    m->mf_state == SMFS_DONE || \ 	    m->mf_state == SMFS_ERROR) \ 	{ \ 		if (m->mf_state != SMFS_ERROR) \ 			m->mf_state = SMFS_DONE; \ 		continue;
comment|/* to next filter */
value|\ 	} \ 	if (*state != SMFIR_CONTINUE) \ 	{ \ 		m->mf_state = SMFS_DONE; \ 		goto finishup; \ 	}
end_define

begin_function
name|char
modifier|*
name|milter_data
parameter_list|(
name|e
parameter_list|,
name|state
parameter_list|)
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|state
decl_stmt|;
block|{
name|bool
name|replbody
init|=
name|false
decl_stmt|;
comment|/* milter_replbody() called? */
name|bool
name|replfailed
init|=
name|false
decl_stmt|;
comment|/* milter_replbody() failed? */
name|bool
name|rewind
init|=
name|false
decl_stmt|;
comment|/* rewind data file? */
name|bool
name|dfopen
init|=
name|false
decl_stmt|;
comment|/* data file open for writing? */
name|bool
name|newfilter
decl_stmt|;
comment|/* reset on each new filter */
name|char
name|rcmd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
name|char
modifier|*
name|response
init|=
name|NULL
decl_stmt|;
name|time_t
name|eomsent
decl_stmt|;
name|ssize_t
name|rlen
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_data\n"
argument_list|)
expr_stmt|;
operator|*
name|state
operator|=
name|SMFIR_CONTINUE
expr_stmt|;
comment|/* 	**  XXX: Should actually send body chunks to each filter 	**  a chunk at a time instead of sending the whole body to 	**  each filter in turn.  However, only if the filters don't 	**  change the body. 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|InputFilters
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|milter
modifier|*
name|m
init|=
name|InputFilters
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|state
operator|!=
name|SMFIR_CONTINUE
operator|&&
operator|*
name|state
operator|!=
name|SMFIR_ACCEPT
condition|)
block|{
comment|/* 			**  A previous filter has dealt with the message, 			**  safe to stop processing the filters. 			*/
break|break;
block|}
comment|/* Now reset state for later evaluation */
operator|*
name|state
operator|=
name|SMFIR_CONTINUE
expr_stmt|;
name|newfilter
operator|=
name|true
expr_stmt|;
comment|/* previous problem? */
if|if
condition|(
name|m
operator|->
name|mf_state
operator|==
name|SMFS_ERROR
condition|)
block|{
name|MILTER_CHECK_ERROR
argument_list|(
argument|false
argument_list|,
argument|continue
argument_list|)
empty_stmt|;
break|break;
block|}
comment|/* sanity checks */
if|if
condition|(
name|m
operator|->
name|mf_sock
operator|<
literal|0
operator|||
operator|(
name|m
operator|->
name|mf_state
operator|!=
name|SMFS_OPEN
operator|&&
name|m
operator|->
name|mf_state
operator|!=
name|SMFS_INMSG
operator|)
condition|)
continue|continue;
name|m
operator|->
name|mf_state
operator|=
name|SMFS_INMSG
expr_stmt|;
comment|/* check if filter wants the headers */
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|SMFIP_NOHDRS
argument_list|,
name|m
operator|->
name|mf_pflags
argument_list|)
condition|)
block|{
name|response
operator|=
name|milter_headers
argument_list|(
name|m
argument_list|,
name|e
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|MILTER_CHECK_RESULTS
argument_list|()
expr_stmt|;
block|}
comment|/* check if filter wants EOH */
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|SMFIP_NOEOH
argument_list|,
name|m
operator|->
name|mf_pflags
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_data: eoh\n"
argument_list|)
expr_stmt|;
comment|/* send it over */
name|response
operator|=
name|milter_send_command
argument_list|(
name|m
argument_list|,
name|SMFIC_EOH
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|e
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|MILTER_CHECK_RESULTS
argument_list|()
expr_stmt|;
block|}
comment|/* check if filter wants the body */
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|SMFIP_NOBODY
argument_list|,
name|m
operator|->
name|mf_pflags
argument_list|)
operator|&&
name|e
operator|->
name|e_dfp
operator|!=
name|NULL
condition|)
block|{
name|rewind
operator|=
name|true
expr_stmt|;
name|response
operator|=
name|milter_body
argument_list|(
name|m
argument_list|,
name|e
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|MILTER_CHECK_RESULTS
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
name|_FFR_MILTER_MACROS_EOM
if|if
condition|(
name|MilterEOMMacros
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
name|milter_send_macros
argument_list|(
name|m
argument_list|,
name|MilterEOMMacros
argument_list|,
name|SMFIC_BODYEOB
argument_list|,
name|e
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_MILTER_MACROS_EOM */
comment|/* send the final body chunk */
operator|(
name|void
operator|)
name|milter_write
argument_list|(
name|m
argument_list|,
name|SMFIC_BODYEOB
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|m
operator|->
name|mf_timeout
index|[
name|SMFTO_WRITE
index|]
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* Get time EOM sent for timeout */
name|eomsent
operator|=
name|curtime
argument_list|()
expr_stmt|;
comment|/* deal with the possibility of multiple responses */
while|while
condition|(
operator|*
name|state
operator|==
name|SMFIR_CONTINUE
condition|)
block|{
comment|/* Check total timeout from EOM to final ACK/NAK */
if|if
condition|(
name|m
operator|->
name|mf_timeout
index|[
name|SMFTO_EOM
index|]
operator|>
literal|0
operator|&&
name|curtime
argument_list|()
operator|-
name|eomsent
operator|>=
name|m
operator|->
name|mf_timeout
index|[
name|SMFTO_EOM
index|]
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_data(%s): EOM ACK/NAK timeout\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"milter_data(%s): EOM ACK/NAK timeout"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|MILTER_CHECK_ERROR
argument_list|(
argument|false
argument_list|,
argument|break
argument_list|)
empty_stmt|;
break|break;
block|}
name|response
operator|=
name|milter_read
argument_list|(
name|m
argument_list|,
operator|&
name|rcmd
argument_list|,
operator|&
name|rlen
argument_list|,
name|m
operator|->
name|mf_timeout
index|[
name|SMFTO_READ
index|]
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|mf_state
operator|==
name|SMFS_ERROR
condition|)
break|break;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_data(%s): state %c\n"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
operator|(
name|char
operator|)
name|rcmd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rcmd
condition|)
block|{
case|case
name|SMFIR_REPLYCODE
case|:
name|MILTER_CHECK_REPLYCODE
argument_list|(
literal|"554 5.7.1 Command rejected"
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|12
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"milter=%s, reject=%s"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|response
argument_list|)
expr_stmt|;
operator|*
name|state
operator|=
name|rcmd
expr_stmt|;
name|m
operator|->
name|mf_state
operator|=
name|SMFS_DONE
expr_stmt|;
break|break;
case|case
name|SMFIR_REJECT
case|:
comment|/* log msg at end of function */
if|if
condition|(
name|MilterLogLevel
operator|>
literal|12
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"milter=%s, reject"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
operator|*
name|state
operator|=
name|rcmd
expr_stmt|;
name|m
operator|->
name|mf_state
operator|=
name|SMFS_DONE
expr_stmt|;
break|break;
case|case
name|SMFIR_DISCARD
case|:
if|if
condition|(
name|MilterLogLevel
operator|>
literal|12
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"milter=%s, discard"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
operator|*
name|state
operator|=
name|rcmd
expr_stmt|;
name|m
operator|->
name|mf_state
operator|=
name|SMFS_DONE
expr_stmt|;
break|break;
case|case
name|SMFIR_TEMPFAIL
case|:
if|if
condition|(
name|MilterLogLevel
operator|>
literal|12
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"milter=%s, tempfail"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
operator|*
name|state
operator|=
name|rcmd
expr_stmt|;
name|m
operator|->
name|mf_state
operator|=
name|SMFS_DONE
expr_stmt|;
break|break;
case|case
name|SMFIR_CONTINUE
case|:
case|case
name|SMFIR_ACCEPT
case|:
comment|/* this filter is done with message */
if|if
condition|(
name|replfailed
condition|)
operator|*
name|state
operator|=
name|SMFIR_TEMPFAIL
expr_stmt|;
else|else
operator|*
name|state
operator|=
name|SMFIR_ACCEPT
expr_stmt|;
name|m
operator|->
name|mf_state
operator|=
name|SMFS_DONE
expr_stmt|;
break|break;
case|case
name|SMFIR_PROGRESS
case|:
break|break;
if|#
directive|if
name|_FFR_QUARANTINE
case|case
name|SMFIR_QUARANTINE
case|:
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|SMFIF_QUARANTINE
argument_list|,
name|m
operator|->
name|mf_fflags
argument_list|)
condition|)
block|{
if|if
condition|(
name|MilterLogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"milter_data(%s): lied about quarantining, honoring request anyway"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|response
operator|==
name|NULL
condition|)
name|response
operator|=
name|newstr
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|3
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"milter=%s, quarantine=%s"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|response
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_quarmsg
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|response
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{quarantine}"
argument_list|)
argument_list|,
name|e
operator|->
name|e_quarmsg
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* _FFR_QUARANTINE */
case|case
name|SMFIR_ADDHEADER
case|:
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|SMFIF_ADDHDRS
argument_list|,
name|m
operator|->
name|mf_fflags
argument_list|)
condition|)
block|{
if|if
condition|(
name|MilterLogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"milter_data(%s): lied about adding headers, honoring request anyway"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
block|}
name|milter_addheader
argument_list|(
name|response
argument_list|,
name|rlen
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMFIR_CHGHEADER
case|:
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|SMFIF_CHGHDRS
argument_list|,
name|m
operator|->
name|mf_fflags
argument_list|)
condition|)
block|{
if|if
condition|(
name|MilterLogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"milter_data(%s): lied about changing headers, honoring request anyway"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
block|}
name|milter_changeheader
argument_list|(
name|response
argument_list|,
name|rlen
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMFIR_ADDRCPT
case|:
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|SMFIF_ADDRCPT
argument_list|,
name|m
operator|->
name|mf_fflags
argument_list|)
condition|)
block|{
if|if
condition|(
name|MilterLogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"milter_data(%s) lied about adding recipients, honoring request anyway"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
block|}
name|milter_addrcpt
argument_list|(
name|response
argument_list|,
name|rlen
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMFIR_DELRCPT
case|:
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|SMFIF_DELRCPT
argument_list|,
name|m
operator|->
name|mf_fflags
argument_list|)
condition|)
block|{
if|if
condition|(
name|MilterLogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"milter_data(%s): lied about removing recipients, honoring request anyway"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
block|}
name|milter_delrcpt
argument_list|(
name|response
argument_list|,
name|rlen
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMFIR_REPLBODY
case|:
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|SMFIF_MODBODY
argument_list|,
name|m
operator|->
name|mf_fflags
argument_list|)
condition|)
block|{
if|if
condition|(
name|MilterLogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"milter_data(%s): lied about replacing body, rejecting request and tempfailing message"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|)
expr_stmt|;
name|replfailed
operator|=
name|true
expr_stmt|;
break|break;
block|}
comment|/* already failed in attempt */
if|if
condition|(
name|replfailed
condition|)
break|break;
if|if
condition|(
operator|!
name|dfopen
condition|)
block|{
if|if
condition|(
name|milter_reopen_df
argument_list|(
name|e
argument_list|)
operator|<
literal|0
condition|)
block|{
name|replfailed
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|dfopen
operator|=
name|true
expr_stmt|;
name|rewind
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|milter_replbody
argument_list|(
name|response
argument_list|,
name|rlen
argument_list|,
name|newfilter
argument_list|,
name|e
argument_list|)
operator|<
literal|0
condition|)
name|replfailed
operator|=
name|true
expr_stmt|;
name|newfilter
operator|=
name|false
expr_stmt|;
name|replbody
operator|=
name|true
expr_stmt|;
break|break;
default|default:
comment|/* Invalid response to command */
if|if
condition|(
name|MilterLogLevel
operator|>
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"milter_data(%s): returned bogus response %c"
argument_list|,
name|m
operator|->
name|mf_name
argument_list|,
name|rcmd
argument_list|)
expr_stmt|;
name|milter_error
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rcmd
operator|!=
name|SMFIR_REPLYCODE
operator|&&
name|response
operator|!=
name|NULL
condition|)
block|{
name|sm_free
argument_list|(
name|response
argument_list|)
expr_stmt|;
comment|/* XXX */
name|response
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|mf_state
operator|==
name|SMFS_ERROR
condition|)
break|break;
block|}
if|if
condition|(
name|replbody
operator|&&
operator|!
name|replfailed
condition|)
block|{
comment|/* flush possible buffered character */
name|milter_replbody
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
operator|!
name|replbody
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|replbody
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|mf_state
operator|==
name|SMFS_ERROR
condition|)
block|{
name|MILTER_CHECK_ERROR
argument_list|(
argument|false
argument_list|,
argument|continue
argument_list|)
empty_stmt|;
goto|goto
name|finishup
goto|;
block|}
block|}
name|finishup
label|:
comment|/* leave things in the expected state if we touched it */
if|if
condition|(
name|replfailed
condition|)
block|{
if|if
condition|(
operator|*
name|state
operator|==
name|SMFIR_CONTINUE
operator|||
operator|*
name|state
operator|==
name|SMFIR_ACCEPT
condition|)
block|{
operator|*
name|state
operator|=
name|SMFIR_TEMPFAIL
expr_stmt|;
name|SM_FREE_CLR
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dfopen
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_dfp
operator|=
name|NULL
expr_stmt|;
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_HAS_DF
expr_stmt|;
name|dfopen
operator|=
name|false
expr_stmt|;
block|}
name|rewind
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dfopen
operator|&&
name|milter_reset_df
argument_list|(
name|e
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|rewind
operator|&&
name|bfrewind
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
name|ExitStat
operator|=
name|EX_IOERR
expr_stmt|;
comment|/* 		**  If filter told us to keep message but we had 		**  an error, we can't really keep it, tempfail it. 		*/
if|if
condition|(
operator|*
name|state
operator|==
name|SMFIR_CONTINUE
operator|||
operator|*
name|state
operator|==
name|SMFIR_ACCEPT
condition|)
block|{
operator|*
name|state
operator|=
name|SMFIR_TEMPFAIL
expr_stmt|;
name|SM_FREE_CLR
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
name|save_errno
expr_stmt|;
name|syserr
argument_list|(
literal|"milter_data: %s/%cf%s: read error"
argument_list|,
name|qid_printqueue
argument_list|(
name|e
operator|->
name|e_qgrp
argument_list|,
name|e
operator|->
name|e_qdir
argument_list|)
argument_list|,
name|DATAFL_LETTER
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
block|}
name|MILTER_CHECK_DONE_MSG
argument_list|()
expr_stmt|;
if|if
condition|(
name|MilterLogLevel
operator|>
literal|10
operator|&&
operator|*
name|state
operator|==
name|SMFIR_REJECT
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Milter: reject, data"
argument_list|)
expr_stmt|;
return|return
name|response
return|;
block|}
end_function

begin_comment
comment|/* **  MILTER_QUIT -- informs the filter(s) we are done and closes connection(s) ** **	Parameters: **		e -- current envelope. ** **	Returns: **		none */
end_comment

begin_function
name|void
name|milter_quit
parameter_list|(
name|e
parameter_list|)
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_quit(%s)\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|InputFilters
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|milter_quit_filter
argument_list|(
name|InputFilters
index|[
name|i
index|]
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  MILTER_ABORT -- informs the filter(s) that we are aborting current message ** **	Parameters: **		e -- current envelope. ** **	Returns: **		none */
end_comment

begin_function
name|void
name|milter_abort
parameter_list|(
name|e
parameter_list|)
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|64
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"milter_abort\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|InputFilters
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|milter
modifier|*
name|m
init|=
name|InputFilters
index|[
name|i
index|]
decl_stmt|;
comment|/* sanity checks */
if|if
condition|(
name|m
operator|->
name|mf_sock
operator|<
literal|0
operator|||
name|m
operator|->
name|mf_state
operator|!=
name|SMFS_INMSG
condition|)
continue|continue;
name|milter_abort_filter
argument_list|(
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MILTER */
end_comment

end_unit

