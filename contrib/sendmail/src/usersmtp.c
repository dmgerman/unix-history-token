begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998-2001 Sendmail, Inc. and its suppliers.  *	All rights reserved.  * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_include
include|#
directive|include
file|<sendmail.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
name|SMTP
end_if

begin_decl_stmt
specifier|static
name|char
name|id
index|[]
init|=
literal|"@(#)$Id: usersmtp.c,v 8.245.4.34 2001/06/26 21:55:23 gshapiro Exp $ (with SMTP)"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SMTP */
end_comment

begin_decl_stmt
specifier|static
name|char
name|id
index|[]
init|=
literal|"@(#)$Id: usersmtp.c,v 8.245.4.34 2001/06/26 21:55:23 gshapiro Exp $ (without SMTP)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SMTP */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! lint */
end_comment

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_if
if|#
directive|if
name|SMTP
end_if

begin_decl_stmt
specifier|static
name|void
name|datatimeout
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|esmtp_check
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|bool
operator|,
name|MAILER
operator|*
operator|,
name|MCI
operator|*
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|helo_options
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|bool
operator|,
name|MAILER
operator|*
operator|,
name|MCI
operator|*
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  USERSMTP -- run SMTP protocol from the user end. ** **	This protocol is described in RFC821. */
end_comment

begin_define
define|#
directive|define
name|REPLYTYPE
parameter_list|(
name|r
parameter_list|)
value|((r) / 100)
end_define

begin_comment
comment|/* first digit of reply code */
end_comment

begin_define
define|#
directive|define
name|REPLYCLASS
parameter_list|(
name|r
parameter_list|)
value|(((r) / 10) % 10)
end_define

begin_comment
comment|/* second digit of reply code */
end_comment

begin_define
define|#
directive|define
name|SMTPCLOSING
value|421
end_define

begin_comment
comment|/* "Service Shutting Down" */
end_comment

begin_define
define|#
directive|define
name|ENHSCN
parameter_list|(
name|e
parameter_list|,
name|d
parameter_list|)
value|(e) == NULL ? (d) : newstr(e)
end_define

begin_decl_stmt
specifier|static
name|char
name|SmtpMsgBuffer
index|[
name|MAXLINE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for commands */
end_comment

begin_decl_stmt
specifier|static
name|char
name|SmtpReplyBuffer
index|[
name|MAXLINE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for replies */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|SmtpNeedIntro
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* need "while talking" in transcript */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **  SMTPINIT -- initialize SMTP. ** **	Opens the connection and sends the initial protocol. ** **	Parameters: **		m -- mailer to create connection to. **		mci -- the mailer connection info. **		e -- the envelope. **		onlyhelo -- send only helo command? ** **	Returns: **		none. ** **	Side Effects: **		creates connection and sends initial protocol. */
end_comment

begin_function
name|void
name|smtpinit
parameter_list|(
name|m
parameter_list|,
name|mci
parameter_list|,
name|e
parameter_list|,
name|onlyhelo
parameter_list|)
name|MAILER
modifier|*
name|m
decl_stmt|;
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|bool
name|onlyhelo
decl_stmt|;
block|{
specifier|register
name|int
name|r
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|hn
decl_stmt|;
name|char
modifier|*
name|enhsc
decl_stmt|;
name|enhsc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|18
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|"smtpinit "
argument_list|)
expr_stmt|;
name|mci_dump
argument_list|(
name|mci
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Open the connection to the mailer. 	*/
name|SmtpError
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|CurHostName
operator|=
name|mci
operator|->
name|mci_host
expr_stmt|;
comment|/* XXX UGLY XXX */
if|if
condition|(
name|CurHostName
operator|==
name|NULL
condition|)
name|CurHostName
operator|=
name|MyHostName
expr_stmt|;
name|SmtpNeedIntro
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|mci
operator|->
name|mci_state
condition|)
block|{
case|case
name|MCIS_ACTIVE
case|:
comment|/* need to clear old information */
name|smtprset
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MCIS_OPEN
case|:
if|if
condition|(
operator|!
name|onlyhelo
condition|)
return|return;
break|break;
case|case
name|MCIS_ERROR
case|:
case|case
name|MCIS_QUITING
case|:
case|case
name|MCIS_SSD
case|:
comment|/* shouldn't happen */
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MCIS_CLOSED
case|:
name|syserr
argument_list|(
literal|"451 4.4.0 smtpinit: state CLOSED"
argument_list|)
expr_stmt|;
return|return;
case|case
name|MCIS_OPENING
case|:
break|break;
block|}
if|if
condition|(
name|onlyhelo
condition|)
goto|goto
name|helo
goto|;
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_OPENING
expr_stmt|;
comment|/* 	**  Get the greeting message. 	**	This should appear spontaneously.  Give it five minutes to 	**	happen. 	*/
name|SmtpPhase
operator|=
name|mci
operator|->
name|mci_phase
operator|=
literal|"client greeting"
expr_stmt|;
name|sm_setproctitle
argument_list|(
name|TRUE
argument_list|,
name|e
argument_list|,
literal|"%s %s: %s"
argument_list|,
name|qid_printname
argument_list|(
name|e
argument_list|)
argument_list|,
name|CurHostName
argument_list|,
name|mci
operator|->
name|mci_phase
argument_list|)
expr_stmt|;
name|r
operator|=
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|TimeOuts
operator|.
name|to_initial
argument_list|,
name|esmtp_check
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
goto|goto
name|tempfail1
goto|;
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|4
condition|)
goto|goto
name|tempfail2
goto|;
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|!=
literal|2
condition|)
goto|goto
name|unavailable
goto|;
comment|/* 	**  Send the HELO command. 	**	My mother taught me to always introduce myself. 	*/
name|helo
label|:
if|if
condition|(
name|bitnset
argument_list|(
name|M_ESMTP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|||
name|bitnset
argument_list|(
name|M_LMTP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_ESMTP
expr_stmt|;
name|hn
operator|=
name|mci
operator|->
name|mci_heloname
condition|?
name|mci
operator|->
name|mci_heloname
else|:
name|MyHostName
expr_stmt|;
name|tryhelo
label|:
if|if
condition|(
name|bitnset
argument_list|(
name|M_LMTP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
name|smtpmessage
argument_list|(
literal|"LHLO %s"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|hn
argument_list|)
expr_stmt|;
name|SmtpPhase
operator|=
name|mci
operator|->
name|mci_phase
operator|=
literal|"client LHLO"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_ESMTP
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
block|{
name|smtpmessage
argument_list|(
literal|"EHLO %s"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|hn
argument_list|)
expr_stmt|;
name|SmtpPhase
operator|=
name|mci
operator|->
name|mci_phase
operator|=
literal|"client EHLO"
expr_stmt|;
block|}
else|else
block|{
name|smtpmessage
argument_list|(
literal|"HELO %s"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|hn
argument_list|)
expr_stmt|;
name|SmtpPhase
operator|=
name|mci
operator|->
name|mci_phase
operator|=
literal|"client HELO"
expr_stmt|;
block|}
name|sm_setproctitle
argument_list|(
name|TRUE
argument_list|,
name|e
argument_list|,
literal|"%s %s: %s"
argument_list|,
name|qid_printname
argument_list|(
name|e
argument_list|)
argument_list|,
name|CurHostName
argument_list|,
name|mci
operator|->
name|mci_phase
argument_list|)
expr_stmt|;
name|r
operator|=
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|TimeOuts
operator|.
name|to_helo
argument_list|,
name|helo_options
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
goto|goto
name|tempfail1
goto|;
elseif|else
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|5
condition|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_ESMTP
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
operator|&&
operator|!
name|bitnset
argument_list|(
name|M_LMTP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
comment|/* try old SMTP instead */
name|mci
operator|->
name|mci_flags
operator|&=
operator|~
name|MCIF_ESMTP
expr_stmt|;
goto|goto
name|tryhelo
goto|;
block|}
goto|goto
name|unavailable
goto|;
block|}
elseif|else
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|!=
literal|2
condition|)
goto|goto
name|tempfail2
goto|;
comment|/* 	**  Check to see if we actually ended up talking to ourself. 	**  This means we didn't know about an alias or MX, or we managed 	**  to connect to an echo server. 	*/
name|p
operator|=
name|strchr
argument_list|(
operator|&
name|SmtpReplyBuffer
index|[
literal|4
index|]
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|M_NOLOOPCHECK
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|&&
operator|!
name|bitnset
argument_list|(
name|M_LMTP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|&&
name|strcasecmp
argument_list|(
operator|&
name|SmtpReplyBuffer
index|[
literal|4
index|]
argument_list|,
name|MyHostName
argument_list|)
operator|==
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"553 5.3.5 %s config error: mail loops back to me (MX problem?)"
argument_list|,
name|CurHostName
argument_list|)
expr_stmt|;
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_CONFIG
argument_list|,
literal|"5.3.5"
argument_list|,
literal|"553 5.3.5 system config error"
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_errno
operator|=
literal|0
expr_stmt|;
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	**  If this is expected to be another sendmail, send some internal 	**  commands. 	*/
if|if
condition|(
name|bitnset
argument_list|(
name|M_INTERNAL
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
comment|/* tell it to be verbose */
name|smtpmessage
argument_list|(
literal|"VERB"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|)
expr_stmt|;
name|r
operator|=
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|TimeOuts
operator|.
name|to_miscshort
argument_list|,
name|NULL
argument_list|,
operator|&
name|enhsc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
goto|goto
name|tempfail1
goto|;
block|}
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_CLOSED
condition|)
block|{
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_OPEN
expr_stmt|;
return|return;
block|}
comment|/* got a 421 error code during startup */
name|tempfail1
label|:
if|if
condition|(
name|mci
operator|->
name|mci_errno
operator|==
literal|0
condition|)
name|mci
operator|->
name|mci_errno
operator|=
name|errno
expr_stmt|;
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_TEMPFAIL
argument_list|,
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
literal|"4.4.2"
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_CLOSED
condition|)
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
name|tempfail2
label|:
if|if
condition|(
name|mci
operator|->
name|mci_errno
operator|==
literal|0
condition|)
name|mci
operator|->
name|mci_errno
operator|=
name|errno
expr_stmt|;
comment|/* XXX should use code from other end iff ENHANCEDSTATUSCODES */
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_TEMPFAIL
argument_list|,
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
literal|"4.5.0"
argument_list|)
argument_list|,
name|SmtpReplyBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_CLOSED
condition|)
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
name|unavailable
label|:
name|mci
operator|->
name|mci_errno
operator|=
name|errno
expr_stmt|;
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_UNAVAILABLE
argument_list|,
literal|"5.5.0"
argument_list|,
name|SmtpReplyBuffer
argument_list|)
expr_stmt|;
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  ESMTP_CHECK -- check to see if this implementation likes ESMTP protocol ** **	Parameters: **		line -- the response line. **		firstline -- set if this is the first line of the reply. **		m -- the mailer. **		mci -- the mailer connection info. **		e -- the envelope. ** **	Returns: **		none. */
end_comment

begin_function
specifier|static
name|void
name|esmtp_check
parameter_list|(
name|line
parameter_list|,
name|firstline
parameter_list|,
name|m
parameter_list|,
name|mci
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|bool
name|firstline
decl_stmt|;
name|MAILER
modifier|*
name|m
decl_stmt|;
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
if|if
condition|(
name|strstr
argument_list|(
name|line
argument_list|,
literal|"ESMTP"
argument_list|)
operator|!=
name|NULL
condition|)
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_ESMTP
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|line
argument_list|,
literal|"8BIT-OK"
argument_list|)
operator|!=
name|NULL
condition|)
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_8BITOK
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|SASL
end_if

begin_escape
end_escape

begin_comment
comment|/* **  STR_UNION -- create the union of two lists ** **	Parameters: **		s1, s2 -- lists of items (separated by single blanks). ** **	Returns: **		the union of both lists. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|str_union
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|hr
decl_stmt|,
modifier|*
name|h1
decl_stmt|,
modifier|*
name|h
decl_stmt|,
modifier|*
name|res
decl_stmt|;
name|int
name|l1
decl_stmt|,
name|l2
decl_stmt|,
name|rl
decl_stmt|;
if|if
condition|(
name|s1
operator|==
name|NULL
operator|||
operator|*
name|s1
operator|==
literal|'\0'
condition|)
return|return
name|s2
return|;
if|if
condition|(
name|s2
operator|==
name|NULL
operator|||
operator|*
name|s2
operator|==
literal|'\0'
condition|)
return|return
name|s1
return|;
name|l1
operator|=
name|strlen
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|l2
operator|=
name|strlen
argument_list|(
name|s2
argument_list|)
expr_stmt|;
name|rl
operator|=
name|l1
operator|+
name|l2
expr_stmt|;
name|res
operator|=
operator|(
name|char
operator|*
operator|)
name|xalloc
argument_list|(
name|rl
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|res
argument_list|,
name|s1
argument_list|,
name|rl
argument_list|)
expr_stmt|;
name|hr
operator|=
name|res
operator|+
name|l1
expr_stmt|;
name|h1
operator|=
name|s2
expr_stmt|;
name|h
operator|=
name|s2
expr_stmt|;
comment|/* walk through s2 */
while|while
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|*
name|h1
operator|!=
literal|'\0'
condition|)
block|{
comment|/* is there something after the current word? */
if|if
condition|(
operator|(
name|h
operator|=
name|strchr
argument_list|(
name|h1
argument_list|,
literal|' '
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|h
operator|=
literal|'\0'
expr_stmt|;
name|l1
operator|=
name|strlen
argument_list|(
name|h1
argument_list|)
expr_stmt|;
comment|/* does the current word appear in s1 ? */
if|if
condition|(
name|iteminlist
argument_list|(
name|h1
argument_list|,
name|s1
argument_list|,
literal|" "
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* add space as delimiter */
operator|*
name|hr
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* copy the item */
name|memcpy
argument_list|(
name|hr
argument_list|,
name|h1
argument_list|,
name|l1
argument_list|)
expr_stmt|;
comment|/* advance pointer in result list */
name|hr
operator|+=
name|l1
expr_stmt|;
operator|*
name|hr
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* there are more items */
operator|*
name|h
operator|=
literal|' '
expr_stmt|;
name|h1
operator|=
name|h
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SASL */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **  HELO_OPTIONS -- process the options on a HELO line. ** **	Parameters: **		line -- the response line. **		firstline -- set if this is the first line of the reply. **		m -- the mailer. **		mci -- the mailer connection info. **		e -- the envelope. ** **	Returns: **		none. */
end_comment

begin_function
specifier|static
name|void
name|helo_options
parameter_list|(
name|line
parameter_list|,
name|firstline
parameter_list|,
name|m
parameter_list|,
name|mci
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|bool
name|firstline
decl_stmt|;
name|MAILER
modifier|*
name|m
decl_stmt|;
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|firstline
condition|)
block|{
if|#
directive|if
name|SASL
if|if
condition|(
name|mci
operator|->
name|mci_saslcap
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|mci
operator|->
name|mci_saslcap
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_saslcap
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* SASL */
return|return;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|line
argument_list|)
operator|<
operator|(
name|SIZE_T
operator|)
literal|5
condition|)
return|return;
name|line
operator|+=
literal|4
expr_stmt|;
name|p
operator|=
name|strpbrk
argument_list|(
name|line
argument_list|,
literal|" ="
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|line
argument_list|,
literal|"size"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_SIZE
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|mci
operator|->
name|mci_maxsize
operator|=
name|atol
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|line
argument_list|,
literal|"8bitmime"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_8BITMIME
expr_stmt|;
name|mci
operator|->
name|mci_flags
operator|&=
operator|~
name|MCIF_7BIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|line
argument_list|,
literal|"expn"
argument_list|)
operator|==
literal|0
condition|)
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_EXPN
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|line
argument_list|,
literal|"dsn"
argument_list|)
operator|==
literal|0
condition|)
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_DSN
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|line
argument_list|,
literal|"enhancedstatuscodes"
argument_list|)
operator|==
literal|0
condition|)
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_ENHSTAT
expr_stmt|;
if|#
directive|if
name|STARTTLS
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|line
argument_list|,
literal|"starttls"
argument_list|)
operator|==
literal|0
condition|)
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_TLS
expr_stmt|;
endif|#
directive|endif
comment|/* STARTTLS */
if|#
directive|if
name|SASL
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|line
argument_list|,
literal|"auth"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|mci
operator|->
name|mci_saslcap
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|h
decl_stmt|;
comment|/* 				**  create the union with previous auth 				**  offerings because we recognize "auth " 				**  and "auth=" (old format). 				*/
name|h
operator|=
name|mci
operator|->
name|mci_saslcap
expr_stmt|;
name|mci
operator|->
name|mci_saslcap
operator|=
name|str_union
argument_list|(
name|h
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|mci
operator|->
name|mci_saslcap
condition|)
name|sm_free
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_AUTH
expr_stmt|;
block|}
else|else
block|{
name|int
name|l
decl_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
name|mci
operator|->
name|mci_saslcap
operator|=
operator|(
name|char
operator|*
operator|)
name|xalloc
argument_list|(
name|l
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|mci
operator|->
name|mci_saslcap
argument_list|,
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_AUTH
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* SASL */
block|}
end_function

begin_if
if|#
directive|if
name|SASL
end_if

begin_escape
end_escape

begin_comment
comment|/* **  GETSASLDATA -- process the challenges from the SASL protocol ** **	This gets the relevant sasl response data out of the reply **	from the server ** **	Parameters: **		line -- the response line. **		firstline -- set if this is the first line of the reply. **		m -- the mailer. **		mci -- the mailer connection info. **		e -- the envelope. ** **	Returns: **		none. */
end_comment

begin_function
name|void
name|getsasldata
parameter_list|(
name|line
parameter_list|,
name|firstline
parameter_list|,
name|m
parameter_list|,
name|mci
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|bool
name|firstline
decl_stmt|;
name|MAILER
modifier|*
name|m
decl_stmt|;
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/* if not a continue we don't care about it */
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|line
argument_list|)
operator|<=
literal|4
operator|)
operator|||
operator|(
name|line
index|[
literal|0
index|]
operator|!=
literal|'3'
operator|)
operator|||
operator|(
name|line
index|[
literal|1
index|]
operator|!=
literal|'3'
operator|)
operator|||
operator|(
name|line
index|[
literal|2
index|]
operator|!=
literal|'4'
operator|)
condition|)
block|{
name|mci
operator|->
name|mci_sasl_string
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
comment|/* forget about "334 " */
name|line
operator|+=
literal|4
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|out
operator|=
name|xalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|sasl_decode64
argument_list|(
name|line
argument_list|,
name|len
argument_list|,
name|out
argument_list|,
operator|(
name|u_int
operator|*
operator|)
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
operator|*
name|out
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|mci
operator|->
name|mci_sasl_string
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mci
operator|->
name|mci_sasl_string_len
operator|<=
name|len
condition|)
block|{
name|sm_free
argument_list|(
name|mci
operator|->
name|mci_sasl_string
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_sasl_string
operator|=
name|xalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|mci
operator|->
name|mci_sasl_string
operator|=
name|xalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX this is probably leaked */
name|memcpy
argument_list|(
name|mci
operator|->
name|mci_sasl_string
argument_list|,
name|out
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_sasl_string
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mci
operator|->
name|mci_sasl_string_len
operator|=
name|len
expr_stmt|;
name|sm_free
argument_list|(
name|out
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  READAUTH -- read auth value from a file ** **	Parameters: **		l -- line to define. **		filename -- name of file to read. **		safe -- if set, this is a safe read. ** **	Returns: **		line from file ** **	Side Effects: **		overwrites local static buffer. The caller should copy **		the result. ** */
end_comment

begin_comment
comment|/* lines in authinfo file */
end_comment

begin_define
define|#
directive|define
name|SASL_USER
value|1
end_define

begin_define
define|#
directive|define
name|SASL_AUTHID
value|2
end_define

begin_define
define|#
directive|define
name|SASL_PASSWORD
value|3
end_define

begin_define
define|#
directive|define
name|SASL_DEFREALM
value|4
end_define

begin_define
define|#
directive|define
name|SASL_MECH
value|5
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sasl_info_name
index|[]
init|=
block|{
literal|""
block|,
literal|"user id"
block|,
literal|"authorization id"
block|,
literal|"password"
block|,
literal|"realm"
block|,
literal|"mechanism"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|readauth
parameter_list|(
name|l
parameter_list|,
name|filename
parameter_list|,
name|safe
parameter_list|)
name|int
name|l
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|bool
name|safe
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|long
name|sff
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|lc
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
operator|||
name|filename
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
literal|""
return|;
if|#
directive|if
operator|!
name|_FFR_ALLOW_SASLINFO
comment|/* 	**  make sure we don't use a program that is not 	**  accesible to the user who specified a different authinfo file. 	**  However, currently we don't pass this info (authinfo file 	**  specified by user) around, so we just turn off program access. 	*/
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|==
literal|'|'
condition|)
block|{
specifier|auto
name|int
name|fd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|argv
index|[
name|MAXPV
operator|+
literal|1
index|]
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|strtok
argument_list|(
operator|&
name|filename
index|[
literal|1
index|]
argument_list|,
literal|" \t"
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t"
argument_list|)
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|MAXPV
condition|)
break|break;
name|argv
index|[
name|i
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
name|argv
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|pid
operator|=
name|prog_open
argument_list|(
name|argv
argument_list|,
operator|&
name|fd
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|f
operator|=
name|NULL
expr_stmt|;
else|else
name|f
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* !_FFR_ALLOW_SASLINFO */
block|{
name|pid
operator|=
operator|-
literal|1
expr_stmt|;
name|sff
operator|=
name|SFF_REGONLY
operator||
name|SFF_SAFEDIRPATH
operator||
name|SFF_NOWLINK
operator||
name|SFF_NOGWFILES
operator||
name|SFF_NOWWFILES
operator||
name|SFF_NORFILES
expr_stmt|;
if|if
condition|(
name|DontLockReadFiles
condition|)
name|sff
operator||=
name|SFF_NOLOCK
expr_stmt|;
if|#
directive|if
name|_FFR_ALLOW_SASLINFO
comment|/* 		**  XXX: make sure we don't read or open files that are not 		**  accesible to the user who specified a different authinfo 		**  file. 		*/
name|sff
operator||=
name|SFF_MUSTOWN
expr_stmt|;
else|#
directive|else
comment|/* _FFR_ALLOW_SASLINFO */
if|if
condition|(
name|safe
condition|)
name|sff
operator||=
name|SFF_OPENASROOT
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_ALLOW_SASLINFO */
name|f
operator|=
name|safefopen
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
name|sff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"readauth: cannot open %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
name|lc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|lc
operator|<
name|l
operator|&&
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|f
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'#'
condition|)
name|lc
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|waitfor
argument_list|(
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|lc
operator|<
name|l
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>=
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"SASL: error: can't read %s from %s"
argument_list|,
name|sasl_info_name
index|[
name|l
index|]
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
name|lc
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lc
operator|>=
literal|0
condition|)
name|buf
index|[
name|lc
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|95
argument_list|,
literal|6
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"readauth(%s, %d) = '%s'\n"
argument_list|,
name|filename
argument_list|,
name|l
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|__attribute__
end_ifndef

begin_define
define|#
directive|define
name|__attribute__
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! __attribute__ */
end_comment

begin_decl_stmt
specifier|static
name|int
name|getsimple
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|unsigned
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getsecret
name|__P
argument_list|(
operator|(
name|sasl_conn_t
operator|*
operator|,
name|void
operator|*
operator|,
name|int
operator|,
name|sasl_secret_t
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|saslgetrealm
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sasl_callback_t
name|callbacks
index|[]
init|=
block|{
block|{
name|SASL_CB_GETREALM
block|,
operator|&
name|saslgetrealm
block|,
name|NULL
block|}
block|,
define|#
directive|define
name|CB_GETREALM_IDX
value|0
block|{
name|SASL_CB_PASS
block|,
operator|&
name|getsecret
block|,
name|NULL
block|}
block|,
define|#
directive|define
name|CB_PASS_IDX
value|1
block|{
name|SASL_CB_USER
block|,
operator|&
name|getsimple
block|,
name|NULL
block|}
block|,
define|#
directive|define
name|CB_USER_IDX
value|2
block|{
name|SASL_CB_AUTHNAME
block|,
operator|&
name|getsimple
block|,
name|NULL
block|}
block|,
define|#
directive|define
name|CB_AUTHNAME_IDX
value|3
block|{
name|SASL_CB_VERIFYFILE
block|,
operator|&
name|safesaslfile
block|,
name|NULL
block|}
block|,
block|{
name|SASL_CB_LIST_END
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* **  GETSIMPLE -- callback to get userid or authid ** **	Parameters: **		context -- unused **		id -- what to do **		result -- (pointer to) result **		len -- (pointer to) length of result ** **	Returns: **		OK/failure values */
end_comment

begin_decl_stmt
specifier|static
name|int
name|getsimple
argument_list|(
name|context
argument_list|,
name|id
argument_list|,
name|result
argument_list|,
name|len
argument_list|)
name|void
modifier|*
name|context
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
modifier|*
name|result
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
modifier|*
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|h
decl_stmt|;
if|#
directive|if
name|SASL
operator|>
literal|10509
name|int
name|addrealm
decl_stmt|;
specifier|static
name|int
name|addedrealm
init|=
name|FALSE
decl_stmt|;
endif|#
directive|endif
comment|/* SASL> 10509 */
specifier|static
name|char
modifier|*
name|user
init|=
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|authid
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
return|return
name|SASL_BADPARAM
return|;
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|SASL_CB_USER
case|:
if|if
condition|(
name|user
operator|==
name|NULL
condition|)
block|{
name|h
operator|=
name|readauth
argument_list|(
name|SASL_USER
argument_list|,
name|SASLInfo
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|user
operator|=
name|newstr
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
operator|*
name|result
operator|=
name|user
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|95
argument_list|,
literal|5
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"AUTH username '%s'\n"
argument_list|,
operator|*
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|NULL
condition|)
operator|*
name|len
operator|=
name|user
condition|?
name|strlen
argument_list|(
name|user
argument_list|)
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|SASL_CB_AUTHNAME
case|:
if|#
directive|if
name|SASL
operator|>
literal|10509
comment|/* XXX maybe other mechanisms too?! */
name|addrealm
operator|=
name|context
operator|!=
name|NULL
operator|&&
name|strcasecmp
argument_list|(
name|context
argument_list|,
literal|"CRAM-MD5"
argument_list|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|addedrealm
operator|!=
name|addrealm
operator|&&
name|authid
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
name|SASL
operator|>
literal|10522
comment|/* 			**  digest-md5 prior to 1.5.23 doesn't copy the 			**  value it gets from the callback, but free()s 			**  it later on 			**  workaround: don't free() it here 			**  this can cause a memory leak! 			*/
name|sm_free
argument_list|(
name|authid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SASL> 10522 */
name|authid
operator|=
name|NULL
expr_stmt|;
name|addedrealm
operator|=
name|addrealm
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SASL> 10509 */
if|if
condition|(
name|authid
operator|==
name|NULL
condition|)
block|{
name|h
operator|=
name|readauth
argument_list|(
name|SASL_AUTHID
argument_list|,
name|SASLInfo
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|#
directive|if
name|SASL
operator|>
literal|10509
if|if
condition|(
name|addrealm
operator|&&
name|strchr
argument_list|(
name|h
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|size_t
name|l
decl_stmt|;
name|char
modifier|*
name|realm
decl_stmt|;
name|realm
operator|=
name|callbacks
index|[
name|CB_GETREALM_IDX
index|]
operator|.
name|context
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|h
argument_list|)
operator|+
name|strlen
argument_list|(
name|realm
argument_list|)
operator|+
literal|2
expr_stmt|;
name|authid
operator|=
name|xalloc
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|authid
argument_list|,
name|l
argument_list|,
literal|"%s@%s"
argument_list|,
name|h
argument_list|,
name|realm
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* SASL> 10509 */
name|authid
operator|=
name|newstr
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
operator|*
name|result
operator|=
name|authid
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|95
argument_list|,
literal|5
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"AUTH authid '%s'\n"
argument_list|,
operator|*
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|NULL
condition|)
operator|*
name|len
operator|=
name|authid
condition|?
name|strlen
argument_list|(
name|authid
argument_list|)
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|SASL_CB_LANGUAGE
case|:
operator|*
name|result
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|NULL
condition|)
operator|*
name|len
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
name|SASL_BADPARAM
return|;
block|}
return|return
name|SASL_OK
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  GETSECRET -- callback to get password ** **	Parameters: **		conn -- connection information **		context -- unused **		id -- what to do **		psecret -- (pointer to) result ** **	Returns: **		OK/failure values */
end_comment

begin_decl_stmt
specifier|static
name|int
name|getsecret
argument_list|(
name|conn
argument_list|,
name|context
argument_list|,
name|id
argument_list|,
name|psecret
argument_list|)
name|sasl_conn_t
modifier|*
name|conn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|context
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|sasl_secret_t
modifier|*
modifier|*
name|psecret
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|h
decl_stmt|;
name|int
name|len
decl_stmt|;
specifier|static
name|char
modifier|*
name|authpass
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|conn
operator|==
name|NULL
operator|||
name|psecret
operator|==
name|NULL
operator|||
name|id
operator|!=
name|SASL_CB_PASS
condition|)
return|return
name|SASL_BADPARAM
return|;
if|if
condition|(
name|authpass
operator|==
name|NULL
condition|)
block|{
name|h
operator|=
name|readauth
argument_list|(
name|SASL_PASSWORD
argument_list|,
name|SASLInfo
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|authpass
operator|=
name|newstr
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|authpass
argument_list|)
expr_stmt|;
operator|*
name|psecret
operator|=
operator|(
name|sasl_secret_t
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sasl_secret_t
argument_list|)
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
operator|(
operator|*
name|psecret
operator|)
operator|->
name|data
argument_list|,
name|authpass
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|psecret
operator|)
operator|->
name|len
operator|=
name|len
expr_stmt|;
return|return
name|SASL_OK
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  SAFESASLFILE -- callback for sasl: is file safe? ** **	Parameters: **		context -- pointer to context between invocations (unused) **		file -- name of file to check **		type -- type of file to check ** **	Returns: **		SASL_OK: file can be used **		SASL_CONTINUE: don't use file **		SASL_FAIL: failure (not used here) ** */
end_comment

begin_function
name|int
if|#
directive|if
name|SASL
operator|>
literal|10515
name|safesaslfile
parameter_list|(
name|context
parameter_list|,
name|file
parameter_list|,
name|type
parameter_list|)
else|#
directive|else
comment|/* SASL> 10515 */
function|safesaslfile
parameter_list|(
name|context
parameter_list|,
name|file
parameter_list|)
endif|#
directive|endif
comment|/* SASL> 10515 */
name|void
modifier|*
name|context
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
if|#
directive|if
name|SASL
operator|>
literal|10515
name|int
name|type
decl_stmt|;
endif|#
directive|endif
comment|/* SASL> 10515 */
block|{
name|long
name|sff
decl_stmt|;
name|int
name|r
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
operator|||
operator|*
name|file
operator|==
literal|'\0'
condition|)
return|return
name|SASL_OK
return|;
name|sff
operator|=
name|SFF_SAFEDIRPATH
operator||
name|SFF_NOWLINK
operator||
name|SFF_NOGWFILES
operator||
name|SFF_NOWWFILES
operator||
name|SFF_ROOTOK
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|p
operator|=
name|file
expr_stmt|;
else|else
operator|++
name|p
expr_stmt|;
if|#
directive|if
name|SASL
operator|<=
literal|10515
comment|/* everything beside libs and .conf files must not be readable */
name|r
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|<=
literal|3
operator|||
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"lib"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|r
operator|<=
literal|5
operator|||
name|strncmp
argument_list|(
name|p
operator|+
name|r
operator|-
literal|5
argument_list|,
literal|".conf"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
operator|)
if|#
directive|if
name|_FFR_UNSAFE_SASL
operator|&&
operator|!
name|bitnset
argument_list|(
name|DBS_GROUPREADABLESASLFILE
argument_list|,
name|DontBlameSendmail
argument_list|)
endif|#
directive|endif
comment|/* _FFR_UNSAFE_SASL */
condition|)
name|sff
operator||=
name|SFF_NORFILES
expr_stmt|;
else|#
directive|else
comment|/* SASL> 10515 */
comment|/* files containing passwords should be not readable */
if|if
condition|(
name|type
operator|==
name|SASL_VRFY_PASSWD
condition|)
block|{
if|#
directive|if
name|_FFR_UNSAFE_SASL
if|if
condition|(
name|bitnset
argument_list|(
name|DBS_GROUPREADABLESASLFILE
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
name|sff
operator||=
name|SFF_NOWRFILES
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* _FFR_UNSAFE_SASL */
name|sff
operator||=
name|SFF_NORFILES
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SASL<= 10515 */
name|p
operator|=
name|file
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|safefile
argument_list|(
name|p
argument_list|,
name|RunAsUid
argument_list|,
name|RunAsGid
argument_list|,
name|RunAsUserName
argument_list|,
name|sff
argument_list|,
name|S_IRUSR
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|SASL_OK
return|;
if|if
condition|(
name|LogLevel
operator|>=
literal|11
operator|||
operator|(
name|r
operator|!=
name|ENOENT
operator|&&
name|LogLevel
operator|>=
literal|9
operator|)
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"error: safesasl(%s) failed: %s"
argument_list|,
name|p
argument_list|,
name|errstring
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SASL_CONTINUE
return|;
block|}
end_function

begin_comment
comment|/* **  SASLGETREALM -- return the realm for SASL ** **	return the realm for the client ** **	Parameters: **		context -- context shared between invocations **			here: realm to return **		availrealms -- list of available realms **			{realm, realm, ...} **		result -- pointer to result ** **	Returns: **		failure/success */
end_comment

begin_function
specifier|static
name|int
name|saslgetrealm
parameter_list|(
name|context
parameter_list|,
name|id
parameter_list|,
name|availrealms
parameter_list|,
name|result
parameter_list|)
name|void
modifier|*
name|context
decl_stmt|;
name|int
name|id
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|availrealms
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|result
decl_stmt|;
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|12
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"saslgetrealm: realm %s available realms %s"
argument_list|,
name|context
operator|==
name|NULL
condition|?
literal|"<No Context>"
else|:
operator|(
name|char
operator|*
operator|)
name|context
argument_list|,
operator|(
name|availrealms
operator|==
name|NULL
operator|||
operator|*
name|availrealms
operator|==
name|NULL
operator|)
condition|?
literal|"<No Realms>"
else|:
operator|*
name|availrealms
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|==
name|NULL
condition|)
return|return
name|SASL_FAIL
return|;
comment|/* check whether context is in list? */
if|if
condition|(
name|availrealms
operator|!=
name|NULL
operator|&&
operator|*
name|availrealms
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|iteminlist
argument_list|(
name|context
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|*
name|availrealms
operator|+
literal|1
operator|)
argument_list|,
literal|" ,}"
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"saslgetrealm: realm %s not in list %s"
argument_list|,
name|context
argument_list|,
operator|*
name|availrealms
argument_list|)
expr_stmt|;
return|return
name|SASL_FAIL
return|;
block|}
block|}
operator|*
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|context
expr_stmt|;
return|return
name|SASL_OK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  ITEMINLIST -- does item appear in list? ** **	Check whether item appears in list (which must be separated by a **	character in delim) as a "word", i.e. it must appear at the begin **	of the list or after a space, and it must end with a space or the **	end of the list. ** **	Parameters: **		item -- item to search. **		list -- list of items. **		delim -- list of delimiters. ** **	Returns: **		pointer to occurrence (NULL if not found). */
end_comment

begin_function
name|char
modifier|*
name|iteminlist
parameter_list|(
name|item
parameter_list|,
name|list
parameter_list|,
name|delim
parameter_list|)
name|char
modifier|*
name|item
decl_stmt|;
name|char
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|delim
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
operator|||
operator|*
name|list
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|item
operator|==
name|NULL
operator|||
operator|*
name|item
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
name|s
operator|=
name|list
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|item
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|strncasecmp
argument_list|(
name|s
argument_list|,
name|item
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|s
index|[
name|len
index|]
operator|==
literal|'\0'
operator|||
name|strchr
argument_list|(
name|delim
argument_list|,
name|s
index|[
name|len
index|]
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
return|return
name|s
return|;
name|s
operator|=
name|strpbrk
argument_list|(
name|s
argument_list|,
name|delim
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
while|while
condition|(
operator|*
operator|++
name|s
operator|==
literal|' '
condition|)
continue|continue;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  REMOVEMECH -- remove item [rem] from list [list] ** **	Parameters: **		rem -- item to remove **		list -- list of items ** **	Returns: **		pointer to new list (NULL in case of error). */
end_comment

begin_function
name|char
modifier|*
name|removemech
parameter_list|(
name|rem
parameter_list|,
name|list
parameter_list|)
name|char
modifier|*
name|rem
decl_stmt|;
name|char
modifier|*
name|list
decl_stmt|;
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|char
modifier|*
name|needle
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|rem
operator|==
name|NULL
operator|||
operator|*
name|rem
operator|==
literal|'\0'
condition|)
block|{
comment|/* take out what? */
return|return
name|NULL
return|;
block|}
comment|/* find the item in the list */
if|if
condition|(
operator|(
name|needle
operator|=
name|iteminlist
argument_list|(
name|rem
argument_list|,
name|list
argument_list|,
literal|" "
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* not in there: return original */
return|return
name|list
return|;
block|}
comment|/* length of string without rem */
name|len
operator|=
name|strlen
argument_list|(
name|list
argument_list|)
operator|-
name|strlen
argument_list|(
name|rem
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|xalloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX leaked */
operator|*
name|ret
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ret
operator|=
name|xalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* XXX leaked */
name|memset
argument_list|(
name|ret
argument_list|,
literal|'\0'
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* copy from start to removed item */
name|memcpy
argument_list|(
name|ret
argument_list|,
name|list
argument_list|,
name|needle
operator|-
name|list
argument_list|)
expr_stmt|;
comment|/* length of rest of string past removed item */
name|len
operator|=
name|strlen
argument_list|(
name|needle
argument_list|)
operator|-
name|strlen
argument_list|(
name|rem
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* not last item -- copy into string */
name|memcpy
argument_list|(
name|ret
operator|+
operator|(
name|needle
operator|-
name|list
operator|)
argument_list|,
name|list
operator|+
operator|(
name|needle
operator|-
name|list
operator|)
operator|+
name|strlen
argument_list|(
name|rem
argument_list|)
operator|+
literal|1
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
index|[
operator|(
name|needle
operator|-
name|list
operator|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  INTERSECT -- create the intersection between two lists ** **	Parameters: **		s1, s2 -- lists of items (separated by single blanks). ** **	Returns: **		the intersection of both lists. */
end_comment

begin_function
name|char
modifier|*
name|intersect
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|hr
decl_stmt|,
modifier|*
name|h1
decl_stmt|,
modifier|*
name|h
decl_stmt|,
modifier|*
name|res
decl_stmt|;
name|int
name|l1
decl_stmt|,
name|l2
decl_stmt|,
name|rl
decl_stmt|;
if|if
condition|(
name|s1
operator|==
name|NULL
operator|||
name|s2
operator|==
name|NULL
condition|)
comment|/* NULL string(s) -> NULL result */
return|return
name|NULL
return|;
name|l1
operator|=
name|strlen
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|l2
operator|=
name|strlen
argument_list|(
name|s2
argument_list|)
expr_stmt|;
name|rl
operator|=
name|min
argument_list|(
name|l1
argument_list|,
name|l2
argument_list|)
expr_stmt|;
name|res
operator|=
operator|(
name|char
operator|*
operator|)
name|xalloc
argument_list|(
name|rl
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rl
operator|==
literal|0
condition|)
comment|/* at least one string empty? */
return|return
name|res
return|;
name|hr
operator|=
name|res
expr_stmt|;
name|h1
operator|=
name|s1
expr_stmt|;
name|h
operator|=
name|s1
expr_stmt|;
comment|/* walk through s1 */
while|while
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|*
name|h1
operator|!=
literal|'\0'
condition|)
block|{
comment|/* is there something after the current word? */
if|if
condition|(
operator|(
name|h
operator|=
name|strchr
argument_list|(
name|h1
argument_list|,
literal|' '
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|h
operator|=
literal|'\0'
expr_stmt|;
name|l1
operator|=
name|strlen
argument_list|(
name|h1
argument_list|)
expr_stmt|;
comment|/* does the current word appear in s2 ? */
if|if
condition|(
name|iteminlist
argument_list|(
name|h1
argument_list|,
name|s2
argument_list|,
literal|" "
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* add a blank if not first item */
if|if
condition|(
name|hr
operator|!=
name|res
condition|)
operator|*
name|hr
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* copy the item */
name|memcpy
argument_list|(
name|hr
argument_list|,
name|h1
argument_list|,
name|l1
argument_list|)
expr_stmt|;
comment|/* advance pointer in result list */
name|hr
operator|+=
name|l1
expr_stmt|;
operator|*
name|hr
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* there are more items */
operator|*
name|h
operator|=
literal|' '
expr_stmt|;
name|h1
operator|=
name|h
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  ATTEMPTAUTH -- try to AUTHenticate using one mechanism ** **	Parameters: **		m -- the mailer. **		mci -- the mailer connection structure. **		e -- the envelope (including the sender to specify). **		mechused - filled in with mechanism used ** **	Returns: **		EX_OK/EX_TEMPFAIL */
end_comment

begin_function
name|int
name|attemptauth
parameter_list|(
name|m
parameter_list|,
name|mci
parameter_list|,
name|e
parameter_list|,
name|mechused
parameter_list|)
name|MAILER
modifier|*
name|m
decl_stmt|;
name|MCI
modifier|*
name|mci
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
modifier|*
name|mechused
decl_stmt|;
block|{
name|int
name|saslresult
decl_stmt|,
name|smtpresult
decl_stmt|;
name|sasl_external_properties_t
name|ssf
decl_stmt|;
name|sasl_interact_t
modifier|*
name|client_interact
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|;
name|unsigned
name|int
name|outlen
decl_stmt|;
specifier|static
name|char
modifier|*
name|mechusing
decl_stmt|;
name|sasl_security_properties_t
name|ssp
decl_stmt|;
name|char
name|in64
index|[
name|MAXOUTLEN
index|]
decl_stmt|;
if|#
directive|if
name|NETINET
specifier|extern
name|SOCKADDR
name|CurHostAddr
decl_stmt|;
endif|#
directive|endif
comment|/* NETINET */
operator|*
name|mechused
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_conn
operator|!=
name|NULL
condition|)
block|{
name|sasl_dispose
argument_list|(
operator|&
operator|(
name|mci
operator|->
name|mci_conn
operator|)
argument_list|)
expr_stmt|;
comment|/* just in case, sasl_dispose() should take care of it */
name|mci
operator|->
name|mci_conn
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* make a new client sasl connection */
name|saslresult
operator|=
name|sasl_client_new
argument_list|(
name|bitnset
argument_list|(
name|M_LMTP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|?
literal|"lmtp"
else|:
literal|"smtp"
argument_list|,
name|CurHostName
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|mci
operator|->
name|mci_conn
argument_list|)
expr_stmt|;
comment|/* set properties */
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|&
name|ssp
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|ssp
argument_list|)
expr_stmt|;
if|#
directive|if
name|SFIO
comment|/* XXX should these be options settable via .cf ? */
comment|/* ssp.min_ssf = 0; is default due to memset() */
block|{
name|ssp
operator|.
name|max_ssf
operator|=
name|INT_MAX
expr_stmt|;
name|ssp
operator|.
name|maxbufsize
operator|=
name|MAXOUTLEN
expr_stmt|;
if|#
directive|if
literal|0
block|ssp.security_flags = SASL_SEC_NOPLAINTEXT;
endif|#
directive|endif
comment|/* 0 */
block|}
endif|#
directive|endif
comment|/* SFIO */
name|saslresult
operator|=
name|sasl_setprop
argument_list|(
name|mci
operator|->
name|mci_conn
argument_list|,
name|SASL_SEC_PROPS
argument_list|,
operator|&
name|ssp
argument_list|)
expr_stmt|;
if|if
condition|(
name|saslresult
operator|!=
name|SASL_OK
condition|)
return|return
name|EX_TEMPFAIL
return|;
comment|/* external security strength factor, authentication id */
name|ssf
operator|.
name|ssf
operator|=
literal|0
expr_stmt|;
name|ssf
operator|.
name|auth_id
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|_FFR_EXT_MECH
name|out
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{cert_subject}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|!=
name|NULL
operator|&&
operator|*
name|out
operator|!=
literal|'\0'
condition|)
name|ssf
operator|.
name|auth_id
operator|=
name|out
expr_stmt|;
name|out
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{cipher_bits}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|!=
name|NULL
operator|&&
operator|*
name|out
operator|!=
literal|'\0'
condition|)
name|ssf
operator|.
name|ssf
operator|=
name|atoi
argument_list|(
name|out
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_EXT_MECH */
name|saslresult
operator|=
name|sasl_setprop
argument_list|(
name|mci
operator|->
name|mci_conn
argument_list|,
name|SASL_SSF_EXTERNAL
argument_list|,
operator|&
name|ssf
argument_list|)
expr_stmt|;
if|if
condition|(
name|saslresult
operator|!=
name|SASL_OK
condition|)
return|return
name|EX_TEMPFAIL
return|;
if|#
directive|if
name|NETINET
comment|/* set local/remote ipv4 addresses */
if|if
condition|(
name|mci
operator|->
name|mci_out
operator|!=
name|NULL
operator|&&
name|CurHostAddr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|SOCKADDR_LEN_T
name|addrsize
decl_stmt|;
name|struct
name|sockaddr_in
name|saddr_l
decl_stmt|;
if|if
condition|(
name|sasl_setprop
argument_list|(
name|mci
operator|->
name|mci_conn
argument_list|,
name|SASL_IP_REMOTE
argument_list|,
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|CurHostAddr
argument_list|)
operator|!=
name|SASL_OK
condition|)
return|return
name|EX_TEMPFAIL
return|;
name|addrsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|fileno
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr_l
argument_list|,
operator|&
name|addrsize
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sasl_setprop
argument_list|(
name|mci
operator|->
name|mci_conn
argument_list|,
name|SASL_IP_LOCAL
argument_list|,
operator|&
name|saddr_l
argument_list|)
operator|!=
name|SASL_OK
condition|)
return|return
name|EX_TEMPFAIL
return|;
block|}
block|}
endif|#
directive|endif
comment|/* NETINET */
comment|/* start client side of sasl */
name|saslresult
operator|=
name|sasl_client_start
argument_list|(
name|mci
operator|->
name|mci_conn
argument_list|,
name|mci
operator|->
name|mci_saslcap
argument_list|,
name|NULL
argument_list|,
operator|&
name|client_interact
argument_list|,
operator|&
name|out
argument_list|,
operator|&
name|outlen
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|mechusing
argument_list|)
expr_stmt|;
name|callbacks
index|[
name|CB_AUTHNAME_IDX
index|]
operator|.
name|context
operator|=
name|mechusing
expr_stmt|;
if|if
condition|(
name|saslresult
operator|!=
name|SASL_OK
operator|&&
name|saslresult
operator|!=
name|SASL_CONTINUE
condition|)
block|{
if|#
directive|if
name|SFIO
if|if
condition|(
name|saslresult
operator|==
name|SASL_NOMECH
operator|&&
name|LogLevel
operator|>
literal|8
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"available AUTH mechanisms do not fulfill requirements"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SFIO */
return|return
name|EX_TEMPFAIL
return|;
block|}
operator|*
name|mechused
operator|=
name|mechusing
expr_stmt|;
comment|/* send the info across the wire */
if|if
condition|(
name|outlen
operator|>
literal|0
condition|)
block|{
name|saslresult
operator|=
name|sasl_encode64
argument_list|(
name|out
argument_list|,
name|outlen
argument_list|,
name|in64
argument_list|,
name|MAXOUTLEN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|saslresult
operator|!=
name|SASL_OK
condition|)
comment|/* internal error */
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"encode64 for AUTH failed"
argument_list|)
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
name|smtpmessage
argument_list|(
literal|"AUTH %s %s"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|mechusing
argument_list|,
name|in64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|smtpmessage
argument_list|(
literal|"AUTH %s"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|mechusing
argument_list|)
expr_stmt|;
block|}
comment|/* get the reply */
name|smtpresult
operator|=
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|TimeOuts
operator|.
name|to_datafinal
argument_list|,
name|getsasldata
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* which timeout? XXX */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* check return code from server */
if|if
condition|(
name|smtpresult
operator|==
literal|235
condition|)
block|{
name|define
argument_list|(
name|macid
argument_list|(
literal|"{auth_type}"
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|newstr
argument_list|(
name|mechusing
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|SFIO
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"SASL: outgoing connection to %.64s: mech=%.16s"
argument_list|,
name|mci
operator|->
name|mci_host
argument_list|,
name|mechusing
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !SFIO */
return|return
name|EX_OK
return|;
block|}
if|if
condition|(
name|smtpresult
operator|==
operator|-
literal|1
condition|)
return|return
name|EX_IOERR
return|;
if|if
condition|(
name|smtpresult
operator|!=
literal|334
condition|)
return|return
name|EX_TEMPFAIL
return|;
name|saslresult
operator|=
name|sasl_client_step
argument_list|(
name|mci
operator|->
name|mci_conn
argument_list|,
name|mci
operator|->
name|mci_sasl_string
argument_list|,
name|mci
operator|->
name|mci_sasl_string_len
argument_list|,
operator|&
name|client_interact
argument_list|,
operator|&
name|out
argument_list|,
operator|&
name|outlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|saslresult
operator|!=
name|SASL_OK
operator|&&
name|saslresult
operator|!=
name|SASL_CONTINUE
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|95
argument_list|,
literal|5
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"AUTH FAIL: %s (%d)\n"
argument_list|,
name|sasl_errstring
argument_list|(
name|saslresult
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|saslresult
argument_list|)
expr_stmt|;
comment|/* fail deliberately, see RFC 2254 4. */
name|smtpmessage
argument_list|(
literal|"*"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|)
expr_stmt|;
comment|/* 			**  but we should only fail for this authentication 			**  mechanism; how to do that? 			*/
name|smtpresult
operator|=
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|TimeOuts
operator|.
name|to_datafinal
argument_list|,
name|getsasldata
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
if|if
condition|(
name|outlen
operator|>
literal|0
condition|)
block|{
name|saslresult
operator|=
name|sasl_encode64
argument_list|(
name|out
argument_list|,
name|outlen
argument_list|,
name|in64
argument_list|,
name|MAXOUTLEN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|saslresult
operator|!=
name|SASL_OK
condition|)
block|{
comment|/* give an error reply to the other side! */
name|smtpmessage
argument_list|(
literal|"*"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|)
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
block|}
else|else
name|in64
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|smtpmessage
argument_list|(
literal|"%s"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|in64
argument_list|)
expr_stmt|;
name|smtpresult
operator|=
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|TimeOuts
operator|.
name|to_datafinal
argument_list|,
name|getsasldata
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* which timeout? XXX */
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  SMTPAUTH -- try to AUTHenticate ** **	This will try mechanisms in the order the sasl library decided until: **	- there are no more mechanisms **	- a mechanism succeeds **	- the sasl library fails initializing ** **	Parameters: **		m -- the mailer. **		mci -- the mailer connection info. **		e -- the envelope. ** **	Returns: **		EX_OK/EX_TEMPFAIL */
end_comment

begin_function
name|int
name|smtpauth
parameter_list|(
name|m
parameter_list|,
name|mci
parameter_list|,
name|e
parameter_list|)
name|MAILER
modifier|*
name|m
decl_stmt|;
name|MCI
modifier|*
name|mci
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|char
modifier|*
name|mechused
decl_stmt|;
name|char
modifier|*
name|h
decl_stmt|;
specifier|static
name|char
modifier|*
name|defrealm
init|=
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|mechs
init|=
name|NULL
decl_stmt|;
name|mci
operator|->
name|mci_sasl_auth
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|defrealm
operator|==
name|NULL
condition|)
block|{
name|h
operator|=
name|readauth
argument_list|(
name|SASL_DEFREALM
argument_list|,
name|SASLInfo
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|*
name|h
operator|!=
literal|'\0'
condition|)
name|defrealm
operator|=
name|newstr
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|defrealm
operator|==
name|NULL
operator|||
operator|*
name|defrealm
operator|==
literal|'\0'
condition|)
name|defrealm
operator|=
name|newstr
argument_list|(
name|macvalue
argument_list|(
literal|'j'
argument_list|,
name|CurEnv
argument_list|)
argument_list|)
expr_stmt|;
name|callbacks
index|[
name|CB_GETREALM_IDX
index|]
operator|.
name|context
operator|=
name|defrealm
expr_stmt|;
if|#
directive|if
name|_FFR_DEFAUTHINFO_MECHS
if|if
condition|(
name|mechs
operator|==
name|NULL
condition|)
block|{
name|h
operator|=
name|readauth
argument_list|(
name|SASL_MECH
argument_list|,
name|SASLInfo
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|*
name|h
operator|!=
literal|'\0'
condition|)
name|mechs
operator|=
name|newstr
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _FFR_DEFAUTHINFO_MECHS */
if|if
condition|(
name|mechs
operator|==
name|NULL
operator|||
operator|*
name|mechs
operator|==
literal|'\0'
condition|)
name|mechs
operator|=
name|AuthMechanisms
expr_stmt|;
name|mci
operator|->
name|mci_saslcap
operator|=
name|intersect
argument_list|(
name|mechs
argument_list|,
name|mci
operator|->
name|mci_saslcap
argument_list|)
expr_stmt|;
comment|/* initialize sasl client library */
name|result
operator|=
name|sasl_client_init
argument_list|(
name|callbacks
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
return|return
name|EX_TEMPFAIL
return|;
do|do
block|{
name|result
operator|=
name|attemptauth
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
operator|&
name|mechused
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|EX_OK
condition|)
name|mci
operator|->
name|mci_sasl_auth
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|result
operator|==
name|EX_TEMPFAIL
condition|)
block|{
name|mci
operator|->
name|mci_saslcap
operator|=
name|removemech
argument_list|(
name|mechused
argument_list|,
name|mci
operator|->
name|mci_saslcap
argument_list|)
expr_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_saslcap
operator|==
name|NULL
operator|||
operator|*
operator|(
name|mci
operator|->
name|mci_saslcap
operator|)
operator|==
literal|'\0'
condition|)
return|return
name|EX_TEMPFAIL
return|;
block|}
else|else
comment|/* all others for now */
return|return
name|EX_TEMPFAIL
return|;
block|}
do|while
condition|(
name|result
operator|!=
name|EX_OK
condition|)
do|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SASL */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **  SMTPMAILFROM -- send MAIL command ** **	Parameters: **		m -- the mailer. **		mci -- the mailer connection structure. **		e -- the envelope (including the sender to specify). */
end_comment

begin_function
name|int
name|smtpmailfrom
parameter_list|(
name|m
parameter_list|,
name|mci
parameter_list|,
name|e
parameter_list|)
name|MAILER
modifier|*
name|m
decl_stmt|;
name|MCI
modifier|*
name|mci
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|r
decl_stmt|;
name|char
modifier|*
name|bufp
decl_stmt|;
name|char
modifier|*
name|bodytype
decl_stmt|;
name|char
name|buf
index|[
name|MAXNAME
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|optbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|char
modifier|*
name|enhsc
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|18
argument_list|,
literal|2
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"smtpmailfrom: CurHost=%s\n"
argument_list|,
name|CurHostName
argument_list|)
expr_stmt|;
name|enhsc
operator|=
name|NULL
expr_stmt|;
comment|/* set up appropriate options to include */
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_SIZE
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
operator|&&
name|e
operator|->
name|e_msgsize
operator|>
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|optbuf
argument_list|,
sizeof|sizeof
name|optbuf
argument_list|,
literal|" SIZE=%ld"
argument_list|,
name|e
operator|->
name|e_msgsize
argument_list|)
expr_stmt|;
name|bufp
operator|=
operator|&
name|optbuf
index|[
name|strlen
argument_list|(
name|optbuf
argument_list|)
index|]
expr_stmt|;
block|}
else|else
block|{
name|optbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|bufp
operator|=
name|optbuf
expr_stmt|;
block|}
name|bodytype
operator|=
name|e
operator|->
name|e_bodytype
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_8BITMIME
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|bodytype
operator|==
name|NULL
operator|&&
name|bitset
argument_list|(
name|MM_MIME8BIT
argument_list|,
name|MimeMode
argument_list|)
operator|&&
name|bitset
argument_list|(
name|EF_HAS8BIT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_DONT_MIME
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
operator|!
name|bitnset
argument_list|(
name|M_8BITS
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|bodytype
operator|=
literal|"8BITMIME"
expr_stmt|;
if|if
condition|(
name|bodytype
operator|!=
name|NULL
operator|&&
name|SPACELEFT
argument_list|(
name|optbuf
argument_list|,
name|bufp
argument_list|)
operator|>
name|strlen
argument_list|(
name|bodytype
argument_list|)
operator|+
literal|7
condition|)
block|{
name|snprintf
argument_list|(
name|bufp
argument_list|,
name|SPACELEFT
argument_list|(
name|optbuf
argument_list|,
name|bufp
argument_list|)
argument_list|,
literal|" BODY=%s"
argument_list|,
name|bodytype
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|strlen
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|bitnset
argument_list|(
name|M_8BITS
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|||
operator|!
name|bitset
argument_list|(
name|EF_HAS8BIT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|||
name|bitset
argument_list|(
name|MCIF_8BITOK
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
block|{
comment|/* EMPTY */
comment|/* just pass it through */
block|}
if|#
directive|if
name|MIME8TO7
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|MM_CVTMIME
argument_list|,
name|MimeMode
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_DONT_MIME
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
operator|(
operator|!
name|bitset
argument_list|(
name|MM_PASS8BIT
argument_list|,
name|MimeMode
argument_list|)
operator|||
name|bitset
argument_list|(
name|EF_IS_MIME
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|)
condition|)
block|{
comment|/* must convert from 8bit MIME format to 7bit encoded */
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_CVT8TO7
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MIME8TO7 */
elseif|else
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|MM_PASS8BIT
argument_list|,
name|MimeMode
argument_list|)
condition|)
block|{
comment|/* cannot just send a 8-bit version */
specifier|extern
name|char
name|MsgBuf
index|[]
decl_stmt|;
name|usrerrenh
argument_list|(
literal|"5.6.3"
argument_list|,
literal|"%s does not support 8BITMIME"
argument_list|,
name|CurHostName
argument_list|)
expr_stmt|;
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_NOTSTICKY
argument_list|,
literal|"5.6.3"
argument_list|,
name|MsgBuf
argument_list|)
expr_stmt|;
return|return
name|EX_DATAERR
return|;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_DSN
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|e_envid
operator|!=
name|NULL
operator|&&
name|SPACELEFT
argument_list|(
name|optbuf
argument_list|,
name|bufp
argument_list|)
operator|>
name|strlen
argument_list|(
name|e
operator|->
name|e_envid
argument_list|)
operator|+
literal|7
condition|)
block|{
name|snprintf
argument_list|(
name|bufp
argument_list|,
name|SPACELEFT
argument_list|(
name|optbuf
argument_list|,
name|bufp
argument_list|)
argument_list|,
literal|" ENVID=%s"
argument_list|,
name|e
operator|->
name|e_envid
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|strlen
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
block|}
comment|/* RET= parameter */
if|if
condition|(
name|bitset
argument_list|(
name|EF_RET_PARAM
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
name|SPACELEFT
argument_list|(
name|optbuf
argument_list|,
name|bufp
argument_list|)
operator|>
literal|9
condition|)
block|{
name|snprintf
argument_list|(
name|bufp
argument_list|,
name|SPACELEFT
argument_list|(
name|optbuf
argument_list|,
name|bufp
argument_list|)
argument_list|,
literal|" RET=%s"
argument_list|,
name|bitset
argument_list|(
name|EF_NO_BODY_RETN
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|?
literal|"HDRS"
else|:
literal|"FULL"
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|strlen
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_AUTH
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
operator|&&
name|e
operator|->
name|e_auth_param
operator|!=
name|NULL
operator|&&
name|SPACELEFT
argument_list|(
name|optbuf
argument_list|,
name|bufp
argument_list|)
operator|>
name|strlen
argument_list|(
name|e
operator|->
name|e_auth_param
argument_list|)
operator|+
literal|7
if|#
directive|if
name|SASL
operator|&&
operator|(
operator|!
name|bitset
argument_list|(
name|SASL_AUTH_AUTH
argument_list|,
name|SASLOpts
argument_list|)
operator|||
name|mci
operator|->
name|mci_sasl_auth
operator|)
endif|#
directive|endif
comment|/* SASL */
condition|)
block|{
name|snprintf
argument_list|(
name|bufp
argument_list|,
name|SPACELEFT
argument_list|(
name|optbuf
argument_list|,
name|bufp
argument_list|)
argument_list|,
literal|" AUTH=%s"
argument_list|,
name|e
operator|->
name|e_auth_param
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|strlen
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Send the MAIL command. 	**	Designates the sender. 	*/
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_ACTIVE
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|EF_RESPONSE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
operator|!
name|bitnset
argument_list|(
name|M_NO_NULL_FROM
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|expand
argument_list|(
literal|"\201g"
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'<'
condition|)
block|{
comment|/* strip off<angle brackets> (put back on below) */
name|bufp
operator|=
operator|&
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|bufp
operator|==
literal|'>'
condition|)
operator|*
name|bufp
operator|=
literal|'\0'
expr_stmt|;
name|bufp
operator|=
operator|&
name|buf
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
name|bufp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|bitnset
argument_list|(
name|M_LOCALMAILER
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|->
name|m_flags
argument_list|)
operator|||
operator|!
name|bitnset
argument_list|(
name|M_FROMPATH
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
name|smtpmessage
argument_list|(
literal|"MAIL From:<%s>%s"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|bufp
argument_list|,
name|optbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|smtpmessage
argument_list|(
literal|"MAIL From:<@%s%c%s>%s"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|MyHostName
argument_list|,
operator|*
name|bufp
operator|==
literal|'@'
condition|?
literal|','
else|:
literal|':'
argument_list|,
name|bufp
argument_list|,
name|optbuf
argument_list|)
expr_stmt|;
block|}
name|SmtpPhase
operator|=
name|mci
operator|->
name|mci_phase
operator|=
literal|"client MAIL"
expr_stmt|;
name|sm_setproctitle
argument_list|(
name|TRUE
argument_list|,
name|e
argument_list|,
literal|"%s %s: %s"
argument_list|,
name|qid_printname
argument_list|(
name|e
argument_list|)
argument_list|,
name|CurHostName
argument_list|,
name|mci
operator|->
name|mci_phase
argument_list|)
expr_stmt|;
name|r
operator|=
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|TimeOuts
operator|.
name|to_mail
argument_list|,
name|NULL
argument_list|,
operator|&
name|enhsc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
comment|/* communications failure */
name|mci
operator|->
name|mci_errno
operator|=
name|errno
expr_stmt|;
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_TEMPFAIL
argument_list|,
literal|"4.4.2"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
name|SMTPCLOSING
condition|)
block|{
comment|/* service shutting down */
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_TEMPFAIL
argument_list|,
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
literal|"4.5.0"
argument_list|)
argument_list|,
name|SmtpReplyBuffer
argument_list|)
expr_stmt|;
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
elseif|else
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|4
condition|)
block|{
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_NOTSTICKY
argument_list|,
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
name|smtptodsn
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|,
name|SmtpReplyBuffer
argument_list|)
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
elseif|else
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|2
condition|)
block|{
return|return
name|EX_OK
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
literal|501
condition|)
block|{
comment|/* syntax error in arguments */
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_NOTSTICKY
argument_list|,
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
literal|"5.5.2"
argument_list|)
argument_list|,
name|SmtpReplyBuffer
argument_list|)
expr_stmt|;
return|return
name|EX_DATAERR
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
literal|553
condition|)
block|{
comment|/* mailbox name not allowed */
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_NOTSTICKY
argument_list|,
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
literal|"5.1.3"
argument_list|)
argument_list|,
name|SmtpReplyBuffer
argument_list|)
expr_stmt|;
return|return
name|EX_DATAERR
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
literal|552
condition|)
block|{
comment|/* exceeded storage allocation */
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_NOTSTICKY
argument_list|,
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
literal|"5.3.4"
argument_list|)
argument_list|,
name|SmtpReplyBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_SIZE
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
name|e
operator|->
name|e_flags
operator||=
name|EF_NO_BODY_RETN
expr_stmt|;
return|return
name|EX_UNAVAILABLE
return|;
block|}
elseif|else
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|5
condition|)
block|{
comment|/* unknown error */
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_NOTSTICKY
argument_list|,
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
literal|"5.0.0"
argument_list|)
argument_list|,
name|SmtpReplyBuffer
argument_list|)
expr_stmt|;
return|return
name|EX_UNAVAILABLE
return|;
block|}
if|if
condition|(
name|LogLevel
operator|>
literal|1
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_CRIT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%.100s: SMTP MAIL protocol error: %s"
argument_list|,
name|CurHostName
argument_list|,
name|shortenstring
argument_list|(
name|SmtpReplyBuffer
argument_list|,
literal|403
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* protocol error -- close up */
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_PROTOCOL
argument_list|,
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
literal|"5.5.1"
argument_list|)
argument_list|,
name|SmtpReplyBuffer
argument_list|)
expr_stmt|;
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|EX_PROTOCOL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  SMTPRCPT -- designate recipient. ** **	Parameters: **		to -- address of recipient. **		m -- the mailer we are sending to. **		mci -- the connection info for this transaction. **		e -- the envelope for this transaction. ** **	Returns: **		exit status corresponding to recipient status. ** **	Side Effects: **		Sends the mail via SMTP. */
end_comment

begin_function
name|int
name|smtprcpt
parameter_list|(
name|to
parameter_list|,
name|m
parameter_list|,
name|mci
parameter_list|,
name|e
parameter_list|)
name|ADDRESS
modifier|*
name|to
decl_stmt|;
specifier|register
name|MAILER
modifier|*
name|m
decl_stmt|;
name|MCI
modifier|*
name|mci
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|int
name|r
decl_stmt|;
name|char
modifier|*
name|bufp
decl_stmt|;
name|char
name|optbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|char
modifier|*
name|enhsc
decl_stmt|;
name|enhsc
operator|=
name|NULL
expr_stmt|;
name|optbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|bufp
operator|=
name|optbuf
expr_stmt|;
comment|/* 	**  warning: in the following it is assumed that the free space 	**  in bufp is sizeof optbuf 	*/
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_DSN
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
block|{
comment|/* NOTIFY= parameter */
if|if
condition|(
name|bitset
argument_list|(
name|QHASNOTIFY
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
operator|&&
name|bitset
argument_list|(
name|QPRIMARY
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
operator|&&
operator|!
name|bitnset
argument_list|(
name|M_LOCALMAILER
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
name|bool
name|firstone
init|=
name|TRUE
decl_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|bufp
argument_list|,
literal|" NOTIFY="
argument_list|,
sizeof|sizeof
name|optbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|QPINGONSUCCESS
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|bufp
argument_list|,
literal|"SUCCESS"
argument_list|,
sizeof|sizeof
name|optbuf
argument_list|)
expr_stmt|;
name|firstone
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|QPINGONFAILURE
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|firstone
condition|)
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|bufp
argument_list|,
literal|","
argument_list|,
sizeof|sizeof
name|optbuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|bufp
argument_list|,
literal|"FAILURE"
argument_list|,
sizeof|sizeof
name|optbuf
argument_list|)
expr_stmt|;
name|firstone
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|QPINGONDELAY
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|firstone
condition|)
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|bufp
argument_list|,
literal|","
argument_list|,
sizeof|sizeof
name|optbuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|bufp
argument_list|,
literal|"DELAY"
argument_list|,
sizeof|sizeof
name|optbuf
argument_list|)
expr_stmt|;
name|firstone
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|firstone
condition|)
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|bufp
argument_list|,
literal|"NEVER"
argument_list|,
sizeof|sizeof
name|optbuf
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|strlen
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
block|}
comment|/* ORCPT= parameter */
if|if
condition|(
name|to
operator|->
name|q_orcpt
operator|!=
name|NULL
operator|&&
name|SPACELEFT
argument_list|(
name|optbuf
argument_list|,
name|bufp
argument_list|)
operator|>
name|strlen
argument_list|(
name|to
operator|->
name|q_orcpt
argument_list|)
operator|+
literal|7
condition|)
block|{
name|snprintf
argument_list|(
name|bufp
argument_list|,
name|SPACELEFT
argument_list|(
name|optbuf
argument_list|,
name|bufp
argument_list|)
argument_list|,
literal|" ORCPT=%s"
argument_list|,
name|to
operator|->
name|q_orcpt
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|strlen
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
block|}
block|}
name|smtpmessage
argument_list|(
literal|"RCPT To:<%s>%s"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|to
operator|->
name|q_user
argument_list|,
name|optbuf
argument_list|)
expr_stmt|;
name|SmtpPhase
operator|=
name|mci
operator|->
name|mci_phase
operator|=
literal|"client RCPT"
expr_stmt|;
name|sm_setproctitle
argument_list|(
name|TRUE
argument_list|,
name|e
argument_list|,
literal|"%s %s: %s"
argument_list|,
name|qid_printname
argument_list|(
name|e
argument_list|)
argument_list|,
name|CurHostName
argument_list|,
name|mci
operator|->
name|mci_phase
argument_list|)
expr_stmt|;
name|r
operator|=
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|TimeOuts
operator|.
name|to_rcpt
argument_list|,
name|NULL
argument_list|,
operator|&
name|enhsc
argument_list|)
expr_stmt|;
name|to
operator|->
name|q_rstatus
operator|=
name|newstr
argument_list|(
name|SmtpReplyBuffer
argument_list|)
expr_stmt|;
name|to
operator|->
name|q_status
operator|=
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
name|smtptodsn
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|M_LMTP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|to
operator|->
name|q_statmta
operator|=
name|mci
operator|->
name|mci_host
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
operator|||
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|4
condition|)
return|return
name|EX_TEMPFAIL
return|;
elseif|else
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|2
condition|)
return|return
name|EX_OK
return|;
elseif|else
if|if
condition|(
name|r
operator|==
literal|550
condition|)
block|{
name|to
operator|->
name|q_status
operator|=
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
literal|"5.1.1"
argument_list|)
expr_stmt|;
return|return
name|EX_NOUSER
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
literal|551
condition|)
block|{
name|to
operator|->
name|q_status
operator|=
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
literal|"5.1.6"
argument_list|)
expr_stmt|;
return|return
name|EX_NOUSER
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
literal|553
condition|)
block|{
name|to
operator|->
name|q_status
operator|=
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
literal|"5.1.3"
argument_list|)
expr_stmt|;
return|return
name|EX_NOUSER
return|;
block|}
elseif|else
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|5
condition|)
block|{
return|return
name|EX_UNAVAILABLE
return|;
block|}
if|if
condition|(
name|LogLevel
operator|>
literal|1
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_CRIT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%.100s: SMTP RCPT protocol error: %s"
argument_list|,
name|CurHostName
argument_list|,
name|shortenstring
argument_list|(
name|SmtpReplyBuffer
argument_list|,
literal|403
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_PROTOCOL
argument_list|,
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
literal|"5.5.1"
argument_list|)
argument_list|,
name|SmtpReplyBuffer
argument_list|)
expr_stmt|;
return|return
name|EX_PROTOCOL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  SMTPDATA -- send the data and clean up the transaction. ** **	Parameters: **		m -- mailer being sent to. **		mci -- the mailer connection information. **		e -- the envelope for this message. ** **	Returns: **		exit status corresponding to DATA command. ** **	Side Effects: **		none. */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|CtxDataTimeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|EVENT
modifier|*
specifier|volatile
name|DataTimeout
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|smtpdata
parameter_list|(
name|m
parameter_list|,
name|mci
parameter_list|,
name|e
parameter_list|)
name|MAILER
modifier|*
name|m
decl_stmt|;
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|int
name|r
decl_stmt|;
name|int
name|rstat
decl_stmt|;
name|int
name|xstat
decl_stmt|;
name|time_t
name|timeout
decl_stmt|;
name|char
modifier|*
name|enhsc
decl_stmt|;
name|enhsc
operator|=
name|NULL
expr_stmt|;
comment|/* 	**  Send the data. 	**	First send the command and check that it is ok. 	**	Then send the data. 	**	Follow it up with a dot to terminate. 	**	Finally get the results of the transaction. 	*/
comment|/* send the command and check ok to proceed */
name|smtpmessage
argument_list|(
literal|"DATA"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|)
expr_stmt|;
name|SmtpPhase
operator|=
name|mci
operator|->
name|mci_phase
operator|=
literal|"client DATA 354"
expr_stmt|;
name|sm_setproctitle
argument_list|(
name|TRUE
argument_list|,
name|e
argument_list|,
literal|"%s %s: %s"
argument_list|,
name|qid_printname
argument_list|(
name|e
argument_list|)
argument_list|,
name|CurHostName
argument_list|,
name|mci
operator|->
name|mci_phase
argument_list|)
expr_stmt|;
name|r
operator|=
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|TimeOuts
operator|.
name|to_datainit
argument_list|,
name|NULL
argument_list|,
operator|&
name|enhsc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
operator|||
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|4
condition|)
block|{
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
elseif|else
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|5
condition|)
block|{
name|smtprset
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|EX_UNAVAILABLE
return|;
block|}
elseif|else
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|!=
literal|3
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|1
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_CRIT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%.100s: SMTP DATA-1 protocol error: %s"
argument_list|,
name|CurHostName
argument_list|,
name|shortenstring
argument_list|(
name|SmtpReplyBuffer
argument_list|,
literal|403
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|smtprset
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_PROTOCOL
argument_list|,
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
literal|"5.5.1"
argument_list|)
argument_list|,
name|SmtpReplyBuffer
argument_list|)
expr_stmt|;
return|return
name|EX_PROTOCOL
return|;
block|}
comment|/* 	**  Set timeout around data writes.  Make it at least large 	**  enough for DNS timeouts on all recipients plus some fudge 	**  factor.  The main thing is that it should not be infinite. 	*/
if|if
condition|(
name|setjmp
argument_list|(
name|CtxDataTimeout
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mci
operator|->
name|mci_errno
operator|=
name|errno
expr_stmt|;
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_ERROR
expr_stmt|;
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_TEMPFAIL
argument_list|,
literal|"4.4.2"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		**  If putbody() couldn't finish due to a timeout, 		**  rewind it here in the timeout handler.  See 		**  comments at the end of putbody() for reasoning. 		*/
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|bfrewind
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|mci
operator|->
name|mci_errno
expr_stmt|;
name|syserr
argument_list|(
literal|"451 4.4.1 timeout writing message to %s"
argument_list|,
name|CurHostName
argument_list|)
expr_stmt|;
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|18
argument_list|,
literal|101
argument_list|)
condition|)
block|{
comment|/* simulate a DATA timeout */
name|timeout
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|timeout
operator|=
name|DATA_PROGRESS_TIMEOUT
expr_stmt|;
name|DataTimeout
operator|=
name|setevent
argument_list|(
name|timeout
argument_list|,
name|datatimeout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	**  Output the actual message. 	*/
call|(
modifier|*
name|e
operator|->
name|e_puthdr
call|)
argument_list|(
name|mci
argument_list|,
name|e
operator|->
name|e_header
argument_list|,
name|e
argument_list|,
name|M87F_OUTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|18
argument_list|,
literal|101
argument_list|)
condition|)
block|{
comment|/* simulate a DATA timeout */
operator|(
name|void
operator|)
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|e
operator|->
name|e_putbody
call|)
argument_list|(
name|mci
argument_list|,
name|e
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	**  Cleanup after sending message. 	*/
if|if
condition|(
name|DataTimeout
operator|!=
name|NULL
condition|)
name|clrevent
argument_list|(
name|DataTimeout
argument_list|)
expr_stmt|;
if|#
directive|if
name|_FFR_CATCH_BROKEN_MTAS
block|{
name|fd_set
name|readfds
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|fileno
argument_list|(
name|mci
operator|->
name|mci_in
argument_list|)
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|fileno
argument_list|(
name|mci
operator|->
name|mci_in
argument_list|)
operator|+
literal|1
argument_list|,
name|FDSET_CAST
operator|&
name|readfds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|timeout
argument_list|)
operator|>
literal|0
operator|&&
name|FD_ISSET
argument_list|(
name|fileno
argument_list|(
name|mci
operator|->
name|mci_in
argument_list|)
argument_list|,
operator|&
name|readfds
argument_list|)
condition|)
block|{
comment|/* terminate the message */
name|fprintf
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
literal|".%s"
argument_list|,
name|m
operator|->
name|m_eol
argument_list|)
expr_stmt|;
if|if
condition|(
name|TrafficLogFile
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|TrafficLogFile
argument_list|,
literal|"%05d>>> .\n"
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|nmessage
argument_list|(
literal|">>> ."
argument_list|)
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_CRIT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%.100s: SMTP DATA-1 protocol error: remote server returned response before final dot"
argument_list|,
name|CurHostName
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_errno
operator|=
name|EIO
expr_stmt|;
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_ERROR
expr_stmt|;
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_PROTOCOL
argument_list|,
literal|"5.5.0"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|EX_PROTOCOL
return|;
block|}
block|}
endif|#
directive|endif
comment|/* _FFR_CATCH_BROKEN_MTAS */
if|if
condition|(
name|ferror
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|)
condition|)
block|{
comment|/* error during processing -- don't send the dot */
name|mci
operator|->
name|mci_errno
operator|=
name|EIO
expr_stmt|;
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_ERROR
expr_stmt|;
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_IOERR
argument_list|,
literal|"4.4.2"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|EX_IOERR
return|;
block|}
comment|/* terminate the message */
name|fprintf
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
literal|".%s"
argument_list|,
name|m
operator|->
name|m_eol
argument_list|)
expr_stmt|;
if|if
condition|(
name|TrafficLogFile
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|TrafficLogFile
argument_list|,
literal|"%05d>>> .\n"
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|nmessage
argument_list|(
literal|">>> ."
argument_list|)
expr_stmt|;
comment|/* check for the results of the transaction */
name|SmtpPhase
operator|=
name|mci
operator|->
name|mci_phase
operator|=
literal|"client DATA status"
expr_stmt|;
name|sm_setproctitle
argument_list|(
name|TRUE
argument_list|,
name|e
argument_list|,
literal|"%s %s: %s"
argument_list|,
name|qid_printname
argument_list|(
name|e
argument_list|)
argument_list|,
name|CurHostName
argument_list|,
name|mci
operator|->
name|mci_phase
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitnset
argument_list|(
name|M_LMTP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
return|return
name|EX_OK
return|;
name|r
operator|=
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|TimeOuts
operator|.
name|to_datafinal
argument_list|,
name|NULL
argument_list|,
operator|&
name|enhsc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_OPEN
expr_stmt|;
name|xstat
operator|=
name|EX_NOTSTICKY
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|452
condition|)
name|rstat
operator|=
name|EX_TEMPFAIL
expr_stmt|;
elseif|else
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|4
condition|)
name|rstat
operator|=
name|xstat
operator|=
name|EX_TEMPFAIL
expr_stmt|;
elseif|else
if|if
condition|(
name|REPLYCLASS
argument_list|(
name|r
argument_list|)
operator|!=
literal|5
condition|)
name|rstat
operator|=
name|xstat
operator|=
name|EX_PROTOCOL
expr_stmt|;
elseif|else
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|2
condition|)
name|rstat
operator|=
name|xstat
operator|=
name|EX_OK
expr_stmt|;
elseif|else
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|5
condition|)
name|rstat
operator|=
name|EX_UNAVAILABLE
expr_stmt|;
else|else
name|rstat
operator|=
name|EX_PROTOCOL
expr_stmt|;
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|xstat
argument_list|,
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
name|smtptodsn
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|,
name|SmtpReplyBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_statmsg
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|e
operator|->
name|e_statmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_ENHSTAT
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
operator|&&
operator|(
name|r
operator|=
name|isenhsc
argument_list|(
name|SmtpReplyBuffer
operator|+
literal|4
argument_list|,
literal|' '
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|r
operator|+=
literal|5
expr_stmt|;
else|else
name|r
operator|=
literal|4
expr_stmt|;
name|e
operator|->
name|e_statmsg
operator|=
name|newstr
argument_list|(
operator|&
name|SmtpReplyBuffer
index|[
name|r
index|]
argument_list|)
expr_stmt|;
name|SmtpPhase
operator|=
name|mci
operator|->
name|mci_phase
operator|=
literal|"idle"
expr_stmt|;
name|sm_setproctitle
argument_list|(
name|TRUE
argument_list|,
name|e
argument_list|,
literal|"%s: %s"
argument_list|,
name|CurHostName
argument_list|,
name|mci
operator|->
name|mci_phase
argument_list|)
expr_stmt|;
if|if
condition|(
name|rstat
operator|!=
name|EX_PROTOCOL
condition|)
return|return
name|rstat
return|;
if|if
condition|(
name|LogLevel
operator|>
literal|1
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_CRIT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%.100s: SMTP DATA-2 protocol error: %s"
argument_list|,
name|CurHostName
argument_list|,
name|shortenstring
argument_list|(
name|SmtpReplyBuffer
argument_list|,
literal|403
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rstat
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|datatimeout
parameter_list|()
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
comment|/* 	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD 	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE 	**	DOING. 	*/
if|if
condition|(
name|DataProgress
condition|)
block|{
name|time_t
name|timeout
decl_stmt|;
comment|/* check back again later */
if|if
condition|(
name|tTd
argument_list|(
literal|18
argument_list|,
literal|101
argument_list|)
condition|)
block|{
comment|/* simulate a DATA timeout */
name|timeout
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|timeout
operator|=
name|DATA_PROGRESS_TIMEOUT
expr_stmt|;
comment|/* reset the timeout */
name|DataTimeout
operator|=
name|sigsafe_setevent
argument_list|(
name|timeout
argument_list|,
name|datatimeout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DataProgress
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* event is done */
name|DataTimeout
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* if no progress was made or problem resetting event, die now */
if|if
condition|(
name|DataTimeout
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ETIMEDOUT
expr_stmt|;
name|longjmp
argument_list|(
name|CtxDataTimeout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
name|save_errno
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  SMTPGETSTAT -- get status code from DATA in LMTP ** **	Parameters: **		m -- the mailer to which we are sending the message. **		mci -- the mailer connection structure. **		e -- the current envelope. ** **	Returns: **		The exit status corresponding to the reply code. */
end_comment

begin_function
name|int
name|smtpgetstat
parameter_list|(
name|m
parameter_list|,
name|mci
parameter_list|,
name|e
parameter_list|)
name|MAILER
modifier|*
name|m
decl_stmt|;
name|MCI
modifier|*
name|mci
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|r
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|enhsc
decl_stmt|;
name|enhsc
operator|=
name|NULL
expr_stmt|;
comment|/* check for the results of the transaction */
name|r
operator|=
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|TimeOuts
operator|.
name|to_datafinal
argument_list|,
name|NULL
argument_list|,
operator|&
name|enhsc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|4
condition|)
name|status
operator|=
name|EX_TEMPFAIL
expr_stmt|;
elseif|else
if|if
condition|(
name|REPLYCLASS
argument_list|(
name|r
argument_list|)
operator|!=
literal|5
condition|)
name|status
operator|=
name|EX_PROTOCOL
expr_stmt|;
elseif|else
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|2
condition|)
name|status
operator|=
name|EX_OK
expr_stmt|;
elseif|else
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|5
condition|)
name|status
operator|=
name|EX_UNAVAILABLE
expr_stmt|;
else|else
name|status
operator|=
name|EX_PROTOCOL
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_statmsg
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|e
operator|->
name|e_statmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_ENHSTAT
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
operator|&&
operator|(
name|r
operator|=
name|isenhsc
argument_list|(
name|SmtpReplyBuffer
operator|+
literal|4
argument_list|,
literal|' '
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|r
operator|+=
literal|5
expr_stmt|;
else|else
name|r
operator|=
literal|4
expr_stmt|;
name|e
operator|->
name|e_statmsg
operator|=
name|newstr
argument_list|(
operator|&
name|SmtpReplyBuffer
index|[
name|r
index|]
argument_list|)
expr_stmt|;
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|status
argument_list|,
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
name|smtptodsn
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|,
name|SmtpReplyBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|1
operator|&&
name|status
operator|==
name|EX_PROTOCOL
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_CRIT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%.100s: SMTP DATA-3 protocol error: %s"
argument_list|,
name|CurHostName
argument_list|,
name|shortenstring
argument_list|(
name|SmtpReplyBuffer
argument_list|,
literal|403
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  SMTPQUIT -- close the SMTP connection. ** **	Parameters: **		m -- a pointer to the mailer. **		mci -- the mailer connection information. **		e -- the current envelope. ** **	Returns: **		none. ** **	Side Effects: **		sends the final protocol and closes the connection. */
end_comment

begin_function
name|void
name|smtpquit
parameter_list|(
name|m
parameter_list|,
name|mci
parameter_list|,
name|e
parameter_list|)
specifier|register
name|MAILER
modifier|*
name|m
decl_stmt|;
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|bool
name|oldSuprErrs
init|=
name|SuprErrs
decl_stmt|;
name|int
name|rcode
decl_stmt|;
name|CurHostName
operator|=
name|mci
operator|->
name|mci_host
expr_stmt|;
comment|/* XXX UGLY XXX */
if|if
condition|(
name|CurHostName
operator|==
name|NULL
condition|)
name|CurHostName
operator|=
name|MyHostName
expr_stmt|;
comment|/* 	**	Suppress errors here -- we may be processing a different 	**	job when we do the quit connection, and we don't want the 	**	new job to be penalized for something that isn't it's 	**	problem. 	*/
name|SuprErrs
operator|=
name|TRUE
expr_stmt|;
comment|/* send the quit message if we haven't gotten I/O error */
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_ERROR
operator|&&
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_QUITING
condition|)
block|{
name|int
name|origstate
init|=
name|mci
operator|->
name|mci_state
decl_stmt|;
name|SmtpPhase
operator|=
literal|"client QUIT"
expr_stmt|;
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_QUITING
expr_stmt|;
name|smtpmessage
argument_list|(
literal|"QUIT"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|TimeOuts
operator|.
name|to_quit
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SuprErrs
operator|=
name|oldSuprErrs
expr_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|==
name|MCIS_CLOSED
operator|||
name|origstate
operator|==
name|MCIS_CLOSED
condition|)
return|return;
block|}
comment|/* now actually close the connection and pick up the zombie */
name|rcode
operator|=
name|endmailer
argument_list|(
name|mci
argument_list|,
name|e
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcode
operator|!=
name|EX_OK
condition|)
block|{
name|char
modifier|*
name|mailer
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_mailer
operator|!=
name|NULL
operator|&&
name|mci
operator|->
name|mci_mailer
operator|->
name|m_name
operator|!=
name|NULL
condition|)
name|mailer
operator|=
name|mci
operator|->
name|mci_mailer
operator|->
name|m_name
expr_stmt|;
comment|/* look for naughty mailers */
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"smtpquit: mailer%s%s exited with exit value %d"
argument_list|,
name|mailer
operator|==
name|NULL
condition|?
literal|""
else|:
literal|" "
argument_list|,
name|mailer
operator|==
name|NULL
condition|?
literal|""
else|:
name|mailer
argument_list|,
name|rcode
argument_list|)
expr_stmt|;
block|}
name|SuprErrs
operator|=
name|oldSuprErrs
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  SMTPRSET -- send a RSET (reset) command ** **	Parameters: **		m -- a pointer to the mailer. **		mci -- the mailer connection information. **		e -- the current envelope. ** **	Returns: **		none. ** **	Side Effects: **		closes the connection if there is no reply to RSET. */
end_comment

begin_function
name|void
name|smtprset
parameter_list|(
name|m
parameter_list|,
name|mci
parameter_list|,
name|e
parameter_list|)
specifier|register
name|MAILER
modifier|*
name|m
decl_stmt|;
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|r
decl_stmt|;
name|CurHostName
operator|=
name|mci
operator|->
name|mci_host
expr_stmt|;
comment|/* XXX UGLY XXX */
if|if
condition|(
name|CurHostName
operator|==
name|NULL
condition|)
name|CurHostName
operator|=
name|MyHostName
expr_stmt|;
name|SmtpPhase
operator|=
literal|"client RSET"
expr_stmt|;
name|smtpmessage
argument_list|(
literal|"RSET"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|)
expr_stmt|;
name|r
operator|=
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|TimeOuts
operator|.
name|to_rset
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_ERROR
expr_stmt|;
else|else
block|{
comment|/* 		**  Any response is deemed to be acceptable. 		**  The standard does not state the proper action 		**  to take when a value other than 250 is received. 		** 		**  However, if 421 is returned for the RSET, leave 		**  mci_state as MCIS_SSD (set in reply()). 		*/
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_SSD
condition|)
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_OPEN
expr_stmt|;
return|return;
block|}
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  SMTPPROBE -- check the connection state ** **	Parameters: **		mci -- the mailer connection information. ** **	Returns: **		none. ** **	Side Effects: **		closes the connection if there is no reply to RSET. */
end_comment

begin_function
name|int
name|smtpprobe
parameter_list|(
name|mci
parameter_list|)
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
block|{
name|int
name|r
decl_stmt|;
name|MAILER
modifier|*
name|m
init|=
name|mci
operator|->
name|mci_mailer
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
specifier|extern
name|ENVELOPE
name|BlankEnvelope
decl_stmt|;
name|CurHostName
operator|=
name|mci
operator|->
name|mci_host
expr_stmt|;
comment|/* XXX UGLY XXX */
if|if
condition|(
name|CurHostName
operator|==
name|NULL
condition|)
name|CurHostName
operator|=
name|MyHostName
expr_stmt|;
name|e
operator|=
operator|&
name|BlankEnvelope
expr_stmt|;
name|SmtpPhase
operator|=
literal|"client probe"
expr_stmt|;
name|smtpmessage
argument_list|(
literal|"RSET"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|)
expr_stmt|;
name|r
operator|=
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|TimeOuts
operator|.
name|to_miscshort
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
operator|||
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|!=
literal|2
condition|)
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  REPLY -- read arpanet reply ** **	Parameters: **		m -- the mailer we are reading the reply from. **		mci -- the mailer connection info structure. **		e -- the current envelope. **		timeout -- the timeout for reads. **		pfunc -- processing function called on each line of response. **			If null, no special processing is done. ** **	Returns: **		reply code it reads. ** **	Side Effects: **		flushes the mail file. */
end_comment

begin_decl_stmt
name|int
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|timeout
argument_list|,
name|pfunc
argument_list|,
name|enhstat
argument_list|)
name|MAILER
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MCI
modifier|*
name|mci
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|time_t
name|timeout
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|pfunc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
modifier|*
name|enhstat
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|bufp
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|;
name|bool
name|firstline
init|=
name|TRUE
decl_stmt|;
name|char
name|junkbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
specifier|static
name|char
name|enhstatcode
index|[
name|ENHSCLEN
index|]
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_out
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|18
argument_list|,
literal|1
argument_list|)
condition|)
name|dprintf
argument_list|(
literal|"reply\n"
argument_list|)
expr_stmt|;
comment|/* 	**  Read the input line, being careful not to hang. 	*/
name|bufp
operator|=
name|SmtpReplyBuffer
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* actually do the read */
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|)
expr_stmt|;
comment|/* for debugging */
comment|/* if we are in the process of closing just give the code */
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|==
name|MCIS_CLOSED
condition|)
return|return
name|SMTPCLOSING
return|;
if|if
condition|(
name|mci
operator|->
name|mci_out
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|)
expr_stmt|;
comment|/* get the line from the other side */
name|p
operator|=
name|sfgets
argument_list|(
name|bufp
argument_list|,
name|MAXLINE
argument_list|,
name|mci
operator|->
name|mci_in
argument_list|,
name|timeout
argument_list|,
name|SmtpPhase
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_lastuse
operator|=
name|curtime
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|bool
name|oldholderrs
decl_stmt|;
specifier|extern
name|char
name|MsgBuf
index|[]
decl_stmt|;
comment|/* if the remote end closed early, fake an error */
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
ifdef|#
directive|ifdef
name|ECONNRESET
name|errno
operator|=
name|ECONNRESET
expr_stmt|;
else|#
directive|else
comment|/* ECONNRESET */
name|errno
operator|=
name|EPIPE
expr_stmt|;
endif|#
directive|endif
comment|/* ECONNRESET */
name|mci
operator|->
name|mci_errno
operator|=
name|errno
expr_stmt|;
name|oldholderrs
operator|=
name|HoldErrs
expr_stmt|;
name|HoldErrs
operator|=
name|TRUE
expr_stmt|;
name|usrerr
argument_list|(
literal|"451 4.4.1 reply: read error from %s"
argument_list|,
name|CurHostName
operator|==
name|NULL
condition|?
literal|"NO_HOST"
else|:
name|CurHostName
argument_list|)
expr_stmt|;
comment|/* errors on QUIT should not be persistent */
if|if
condition|(
name|strncmp
argument_list|(
name|SmtpMsgBuffer
argument_list|,
literal|"QUIT"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_TEMPFAIL
argument_list|,
literal|"4.4.2"
argument_list|,
name|MsgBuf
argument_list|)
expr_stmt|;
comment|/* if debugging, pause so we can see state */
if|if
condition|(
name|tTd
argument_list|(
literal|18
argument_list|,
literal|100
argument_list|)
condition|)
operator|(
name|void
operator|)
name|pause
argument_list|()
expr_stmt|;
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_ERROR
expr_stmt|;
name|save_errno
operator|=
name|errno
expr_stmt|;
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|#
directive|if
name|XDEBUG
block|{
name|char
name|wbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|int
name|wbufleft
init|=
sizeof|sizeof
name|wbuf
decl_stmt|;
name|p
operator|=
name|wbuf
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_to
operator|!=
name|NULL
condition|)
block|{
name|int
name|plen
decl_stmt|;
name|snprintf
argument_list|(
name|p
argument_list|,
name|wbufleft
argument_list|,
literal|"%s... "
argument_list|,
name|shortenstring
argument_list|(
name|e
operator|->
name|e_to
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|)
expr_stmt|;
name|plen
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|plen
expr_stmt|;
name|wbufleft
operator|-=
name|plen
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|p
argument_list|,
name|wbufleft
argument_list|,
literal|"reply(%.100s) during %s"
argument_list|,
name|CurHostName
operator|==
name|NULL
condition|?
literal|"NO_HOST"
else|:
name|CurHostName
argument_list|,
name|SmtpPhase
argument_list|)
expr_stmt|;
name|checkfd012
argument_list|(
name|wbuf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* XDEBUG */
name|errno
operator|=
name|save_errno
expr_stmt|;
name|HoldErrs
operator|=
name|oldholderrs
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|fixcrlf
argument_list|(
name|bufp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* EHLO failure is not a real error */
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
operator|&&
operator|(
name|bufp
index|[
literal|0
index|]
operator|==
literal|'4'
operator|||
operator|(
name|bufp
index|[
literal|0
index|]
operator|==
literal|'5'
operator|&&
name|strncmp
argument_list|(
name|SmtpMsgBuffer
argument_list|,
literal|"EHLO"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* serious error -- log the previous command */
if|if
condition|(
name|SmtpNeedIntro
condition|)
block|{
comment|/* inform user who we are chatting with */
name|fprintf
argument_list|(
name|CurEnv
operator|->
name|e_xfp
argument_list|,
literal|"... while talking to %s:\n"
argument_list|,
name|CurHostName
operator|==
name|NULL
condition|?
literal|"NO_HOST"
else|:
name|CurHostName
argument_list|)
expr_stmt|;
name|SmtpNeedIntro
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|SmtpMsgBuffer
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|fprintf
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
literal|">>> %s\n"
argument_list|,
name|SmtpMsgBuffer
argument_list|)
expr_stmt|;
name|SmtpMsgBuffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* now log the message as from the other side */
name|fprintf
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
literal|"<<< %s\n"
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
block|}
comment|/* display the input for verbose mode */
if|if
condition|(
name|Verbose
condition|)
name|nmessage
argument_list|(
literal|"050 %s"
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
comment|/* ignore improperly formatted input */
if|if
condition|(
operator|!
name|ISSMTPREPLY
argument_list|(
name|bufp
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_ENHSTAT
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
operator|&&
name|enhstat
operator|!=
name|NULL
operator|&&
name|extenhsc
argument_list|(
name|bufp
operator|+
literal|4
argument_list|,
literal|' '
argument_list|,
name|enhstatcode
argument_list|)
operator|>
literal|0
condition|)
operator|*
name|enhstat
operator|=
name|enhstatcode
expr_stmt|;
comment|/* process the line */
if|if
condition|(
name|pfunc
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|pfunc
call|)
argument_list|(
name|bufp
argument_list|,
name|firstline
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|firstline
operator|=
name|FALSE
expr_stmt|;
comment|/* decode the reply code */
name|r
operator|=
name|atoi
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
comment|/* extra semantics: 0xx codes are "informational" */
if|if
condition|(
name|r
operator|<
literal|100
condition|)
continue|continue;
comment|/* if no continuation lines, return this line */
if|if
condition|(
name|bufp
index|[
literal|3
index|]
operator|!=
literal|'-'
condition|)
break|break;
comment|/* first line of real reply -- ignore rest */
name|bufp
operator|=
name|junkbuf
expr_stmt|;
block|}
comment|/* 	**  Now look at SmtpReplyBuffer -- only care about the first 	**  line of the response from here on out. 	*/
comment|/* save temporary failure messages for posterity */
if|if
condition|(
name|SmtpReplyBuffer
index|[
literal|0
index|]
operator|==
literal|'4'
operator|&&
operator|(
name|bitnset
argument_list|(
name|M_LMTP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|||
name|SmtpError
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
name|snprintf
argument_list|(
name|SmtpError
argument_list|,
sizeof|sizeof
name|SmtpError
argument_list|,
literal|"%s"
argument_list|,
name|SmtpReplyBuffer
argument_list|)
expr_stmt|;
comment|/* reply code 421 is "Service Shutting Down" */
if|if
condition|(
name|r
operator|==
name|SMTPCLOSING
operator|&&
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_SSD
condition|)
block|{
comment|/* send the quit protocol */
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_SSD
expr_stmt|;
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  SMTPMESSAGE -- send message to server ** **	Parameters: **		f -- format **		m -- the mailer to control formatting. **		a, b, c -- parameters ** **	Returns: **		none. ** **	Side Effects: **		writes message to mci->mci_out. */
end_comment

begin_comment
comment|/*VARARGS1*/
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|smtpmessage
parameter_list|(
name|char
modifier|*
name|f
parameter_list|,
name|MAILER
modifier|*
name|m
parameter_list|,
name|MCI
modifier|*
name|mci
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
comment|/* __STDC__ */
function|smtpmessage
parameter_list|(
name|f
parameter_list|,
name|m
parameter_list|,
name|mci
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|f
decl_stmt|;
name|MAILER
modifier|*
name|m
decl_stmt|;
name|MCI
modifier|*
name|mci
decl_stmt|;
function|va_dcl
endif|#
directive|endif
comment|/* __STDC__ */
block|{
name|VA_LOCAL_DECL
name|VA_START
argument_list|(
name|mci
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|vsnprintf
argument_list|(
name|SmtpMsgBuffer
argument_list|,
sizeof|sizeof
name|SmtpMsgBuffer
argument_list|,
name|f
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_END
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|18
argument_list|,
literal|1
argument_list|)
operator|||
name|Verbose
condition|)
name|nmessage
argument_list|(
literal|">>> %s"
argument_list|,
name|SmtpMsgBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|TrafficLogFile
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|TrafficLogFile
argument_list|,
literal|"%05d>>> %s\n"
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|,
name|SmtpMsgBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_out
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
literal|"%s%s"
argument_list|,
name|SmtpMsgBuffer
argument_list|,
name|m
operator|==
name|NULL
condition|?
literal|"\r\n"
else|:
name|m
operator|->
name|m_eol
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tTd
argument_list|(
literal|18
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|"smtpmessage: NULL mci_out\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SMTP */
end_comment

end_unit

