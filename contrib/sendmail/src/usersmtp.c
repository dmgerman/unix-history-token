begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998-2006 Sendmail, Inc. and its suppliers.  *	All rights reserved.  * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_include
include|#
directive|include
file|<sendmail.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: usersmtp.c,v 8.469 2006/12/13 20:11:15 ca Exp $"
argument_list|)
end_macro

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_decl_stmt
specifier|static
name|void
name|esmtp_check
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|bool
operator|,
name|MAILER
operator|*
operator|,
name|MCI
operator|*
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|helo_options
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|bool
operator|,
name|MAILER
operator|*
operator|,
name|MCI
operator|*
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|smtprcptstat
name|__P
argument_list|(
operator|(
name|ADDRESS
operator|*
operator|,
name|MAILER
operator|*
operator|,
name|MCI
operator|*
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|SASL
end_if

begin_decl_stmt
specifier|extern
name|void
modifier|*
name|sm_sasl_malloc
name|__P
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|sm_sasl_free
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SASL */
end_comment

begin_comment
comment|/* **  USERSMTP -- run SMTP protocol from the user end. ** **	This protocol is described in RFC821. */
end_comment

begin_define
define|#
directive|define
name|REPLYCLASS
parameter_list|(
name|r
parameter_list|)
value|(((r) / 10) % 10)
end_define

begin_comment
comment|/* second digit of reply code */
end_comment

begin_define
define|#
directive|define
name|SMTPCLOSING
value|421
end_define

begin_comment
comment|/* "Service Shutting Down" */
end_comment

begin_define
define|#
directive|define
name|ENHSCN
parameter_list|(
name|e
parameter_list|,
name|d
parameter_list|)
value|((e) == NULL ? (d) : (e))
end_define

begin_define
define|#
directive|define
name|ENHSCN_RPOOL
parameter_list|(
name|e
parameter_list|,
name|d
parameter_list|,
name|rpool
parameter_list|)
define|\
value|((e) == NULL ? (d) : sm_rpool_strdup_x(rpool, e))
end_define

begin_decl_stmt
specifier|static
name|char
name|SmtpMsgBuffer
index|[
name|MAXLINE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for commands */
end_comment

begin_decl_stmt
specifier|static
name|char
name|SmtpReplyBuffer
index|[
name|MAXLINE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for replies */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|SmtpNeedIntro
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* need "while talking" in transcript */
end_comment

begin_comment
comment|/* **  SMTPINIT -- initialize SMTP. ** **	Opens the connection and sends the initial protocol. ** **	Parameters: **		m -- mailer to create connection to. **		mci -- the mailer connection info. **		e -- the envelope. **		onlyhelo -- send only helo command? ** **	Returns: **		none. ** **	Side Effects: **		creates connection and sends initial protocol. */
end_comment

begin_function
name|void
name|smtpinit
parameter_list|(
name|m
parameter_list|,
name|mci
parameter_list|,
name|e
parameter_list|,
name|onlyhelo
parameter_list|)
name|MAILER
modifier|*
name|m
decl_stmt|;
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|bool
name|onlyhelo
decl_stmt|;
block|{
specifier|register
name|int
name|r
decl_stmt|;
name|int
name|state
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|hn
decl_stmt|;
name|char
modifier|*
name|enhsc
decl_stmt|;
name|enhsc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|18
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"smtpinit "
argument_list|)
expr_stmt|;
name|mci_dump
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|mci
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Open the connection to the mailer. 	*/
name|SmtpError
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SmtpMsgBuffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|CurHostName
operator|=
name|mci
operator|->
name|mci_host
expr_stmt|;
comment|/* XXX UGLY XXX */
if|if
condition|(
name|CurHostName
operator|==
name|NULL
condition|)
name|CurHostName
operator|=
name|MyHostName
expr_stmt|;
name|SmtpNeedIntro
operator|=
name|true
expr_stmt|;
name|state
operator|=
name|mci
operator|->
name|mci_state
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|MCIS_MAIL
case|:
case|case
name|MCIS_RCPT
case|:
case|case
name|MCIS_DATA
case|:
comment|/* need to clear old information */
name|smtprset
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MCIS_OPEN
case|:
if|if
condition|(
operator|!
name|onlyhelo
condition|)
return|return;
break|break;
case|case
name|MCIS_ERROR
case|:
case|case
name|MCIS_QUITING
case|:
case|case
name|MCIS_SSD
case|:
comment|/* shouldn't happen */
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|MCIS_CLOSED
case|:
name|syserr
argument_list|(
literal|"451 4.4.0 smtpinit: state CLOSED (was %d)"
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return;
case|case
name|MCIS_OPENING
case|:
break|break;
block|}
if|if
condition|(
name|onlyhelo
condition|)
goto|goto
name|helo
goto|;
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_OPENING
expr_stmt|;
name|clrsessenvelope
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* 	**  Get the greeting message. 	**	This should appear spontaneously.  Give it five minutes to 	**	happen. 	*/
name|SmtpPhase
operator|=
name|mci
operator|->
name|mci_phase
operator|=
literal|"client greeting"
expr_stmt|;
name|sm_setproctitle
argument_list|(
name|true
argument_list|,
name|e
argument_list|,
literal|"%s %s: %s"
argument_list|,
name|qid_printname
argument_list|(
name|e
argument_list|)
argument_list|,
name|CurHostName
argument_list|,
name|mci
operator|->
name|mci_phase
argument_list|)
expr_stmt|;
name|r
operator|=
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|TimeOuts
operator|.
name|to_initial
argument_list|,
name|esmtp_check
argument_list|,
name|NULL
argument_list|,
name|XS_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
goto|goto
name|tempfail1
goto|;
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|4
condition|)
goto|goto
name|tempfail2
goto|;
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|!=
literal|2
condition|)
goto|goto
name|unavailable
goto|;
comment|/* 	**  Send the HELO command. 	**	My mother taught me to always introduce myself. 	*/
name|helo
label|:
if|if
condition|(
name|bitnset
argument_list|(
name|M_ESMTP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|||
name|bitnset
argument_list|(
name|M_LMTP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_ESMTP
expr_stmt|;
name|hn
operator|=
name|mci
operator|->
name|mci_heloname
condition|?
name|mci
operator|->
name|mci_heloname
else|:
name|MyHostName
expr_stmt|;
name|tryhelo
label|:
if|#
directive|if
name|_FFR_IGNORE_EXT_ON_HELO
name|mci
operator|->
name|mci_flags
operator|&=
operator|~
name|MCIF_HELO
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_IGNORE_EXT_ON_HELO */
if|if
condition|(
name|bitnset
argument_list|(
name|M_LMTP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
name|smtpmessage
argument_list|(
literal|"LHLO %s"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|hn
argument_list|)
expr_stmt|;
name|SmtpPhase
operator|=
name|mci
operator|->
name|mci_phase
operator|=
literal|"client LHLO"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_ESMTP
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
operator|&&
operator|!
name|bitnset
argument_list|(
name|M_FSMTP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
name|smtpmessage
argument_list|(
literal|"EHLO %s"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|hn
argument_list|)
expr_stmt|;
name|SmtpPhase
operator|=
name|mci
operator|->
name|mci_phase
operator|=
literal|"client EHLO"
expr_stmt|;
block|}
else|else
block|{
name|smtpmessage
argument_list|(
literal|"HELO %s"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|hn
argument_list|)
expr_stmt|;
name|SmtpPhase
operator|=
name|mci
operator|->
name|mci_phase
operator|=
literal|"client HELO"
expr_stmt|;
if|#
directive|if
name|_FFR_IGNORE_EXT_ON_HELO
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_HELO
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_IGNORE_EXT_ON_HELO */
block|}
name|sm_setproctitle
argument_list|(
name|true
argument_list|,
name|e
argument_list|,
literal|"%s %s: %s"
argument_list|,
name|qid_printname
argument_list|(
name|e
argument_list|)
argument_list|,
name|CurHostName
argument_list|,
name|mci
operator|->
name|mci_phase
argument_list|)
expr_stmt|;
name|r
operator|=
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|bitnset
argument_list|(
name|M_LMTP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|?
name|TimeOuts
operator|.
name|to_lhlo
else|:
name|TimeOuts
operator|.
name|to_helo
argument_list|,
name|helo_options
argument_list|,
name|NULL
argument_list|,
name|XS_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
goto|goto
name|tempfail1
goto|;
elseif|else
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|5
condition|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_ESMTP
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
operator|&&
operator|!
name|bitnset
argument_list|(
name|M_LMTP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
comment|/* try old SMTP instead */
name|mci
operator|->
name|mci_flags
operator|&=
operator|~
name|MCIF_ESMTP
expr_stmt|;
goto|goto
name|tryhelo
goto|;
block|}
goto|goto
name|unavailable
goto|;
block|}
elseif|else
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|!=
literal|2
condition|)
goto|goto
name|tempfail2
goto|;
comment|/* 	**  Check to see if we actually ended up talking to ourself. 	**  This means we didn't know about an alias or MX, or we managed 	**  to connect to an echo server. 	*/
name|p
operator|=
name|strchr
argument_list|(
operator|&
name|SmtpReplyBuffer
index|[
literal|4
index|]
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|M_NOLOOPCHECK
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|&&
operator|!
name|bitnset
argument_list|(
name|M_LMTP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|&&
name|sm_strcasecmp
argument_list|(
operator|&
name|SmtpReplyBuffer
index|[
literal|4
index|]
argument_list|,
name|MyHostName
argument_list|)
operator|==
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"553 5.3.5 %s config error: mail loops back to me (MX problem?)"
argument_list|,
name|CurHostName
argument_list|)
expr_stmt|;
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_CONFIG
argument_list|,
literal|"5.3.5"
argument_list|,
literal|"553 5.3.5 system config error"
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_errno
operator|=
literal|0
expr_stmt|;
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	**  If this is expected to be another sendmail, send some internal 	**  commands. 	**  If we're running as MSP, "propagate" -v flag if possible. 	*/
if|if
condition|(
operator|(
name|UseMSP
operator|&&
name|Verbose
operator|&&
name|bitset
argument_list|(
name|MCIF_VERB
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
operator|)
if|#
directive|if
operator|!
name|_FFR_DEPRECATE_MAILER_FLAG_I
operator|||
name|bitnset
argument_list|(
name|M_INTERNAL
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
endif|#
directive|endif
comment|/* !_FFR_DEPRECATE_MAILER_FLAG_I */
condition|)
block|{
comment|/* tell it to be verbose */
name|smtpmessage
argument_list|(
literal|"VERB"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|)
expr_stmt|;
name|r
operator|=
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|TimeOuts
operator|.
name|to_miscshort
argument_list|,
name|NULL
argument_list|,
operator|&
name|enhsc
argument_list|,
name|XS_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
goto|goto
name|tempfail1
goto|;
block|}
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_CLOSED
condition|)
block|{
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_OPEN
expr_stmt|;
return|return;
block|}
comment|/* got a 421 error code during startup */
name|tempfail1
label|:
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_TEMPFAIL
argument_list|,
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
literal|"4.4.2"
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_CLOSED
condition|)
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
name|tempfail2
label|:
comment|/* XXX should use code from other end iff ENHANCEDSTATUSCODES */
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_TEMPFAIL
argument_list|,
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
literal|"4.5.0"
argument_list|)
argument_list|,
name|SmtpReplyBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_CLOSED
condition|)
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
name|unavailable
label|:
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_UNAVAILABLE
argument_list|,
literal|"5.5.0"
argument_list|,
name|SmtpReplyBuffer
argument_list|)
expr_stmt|;
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* **  ESMTP_CHECK -- check to see if this implementation likes ESMTP protocol ** **	Parameters: **		line -- the response line. **		firstline -- set if this is the first line of the reply. **		m -- the mailer. **		mci -- the mailer connection info. **		e -- the envelope. ** **	Returns: **		none. */
end_comment

begin_function
specifier|static
name|void
name|esmtp_check
parameter_list|(
name|line
parameter_list|,
name|firstline
parameter_list|,
name|m
parameter_list|,
name|mci
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|bool
name|firstline
decl_stmt|;
name|MAILER
modifier|*
name|m
decl_stmt|;
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
if|if
condition|(
name|strstr
argument_list|(
name|line
argument_list|,
literal|"ESMTP"
argument_list|)
operator|!=
name|NULL
condition|)
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_ESMTP
expr_stmt|;
comment|/* 	**  Dirty hack below. Quoting the author: 	**  This was a response to people who wanted SMTP transmission to be 	**  just-send-8 by default.  Essentially, you could put this tag into 	**  your greeting message to behave as though the F=8 flag was set on 	**  the mailer. 	*/
if|if
condition|(
name|strstr
argument_list|(
name|line
argument_list|,
literal|"8BIT-OK"
argument_list|)
operator|!=
name|NULL
condition|)
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_8BITOK
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|SASL
end_if

begin_comment
comment|/* specify prototype so compiler can check calls */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|str_union
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|SM_RPOOL_T
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  STR_UNION -- create the union of two lists ** **	Parameters: **		s1, s2 -- lists of items (separated by single blanks). **		rpool -- resource pool from which result is allocated. ** **	Returns: **		the union of both lists. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|str_union
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|rpool
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_decl_stmt
name|SM_RPOOL_T
modifier|*
name|rpool
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|hr
decl_stmt|,
modifier|*
name|h1
decl_stmt|,
modifier|*
name|h
decl_stmt|,
modifier|*
name|res
decl_stmt|;
name|int
name|l1
decl_stmt|,
name|l2
decl_stmt|,
name|rl
decl_stmt|;
if|if
condition|(
name|s1
operator|==
name|NULL
operator|||
operator|*
name|s1
operator|==
literal|'\0'
condition|)
return|return
name|s2
return|;
if|if
condition|(
name|s2
operator|==
name|NULL
operator|||
operator|*
name|s2
operator|==
literal|'\0'
condition|)
return|return
name|s1
return|;
name|l1
operator|=
name|strlen
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|l2
operator|=
name|strlen
argument_list|(
name|s2
argument_list|)
expr_stmt|;
name|rl
operator|=
name|l1
operator|+
name|l2
expr_stmt|;
name|res
operator|=
operator|(
name|char
operator|*
operator|)
name|sm_rpool_malloc
argument_list|(
name|rpool
argument_list|,
name|rl
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|l1
operator|>
name|l2
condition|)
return|return
name|s1
return|;
return|return
name|s2
return|;
block|}
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|res
argument_list|,
name|s1
argument_list|,
name|rl
argument_list|)
expr_stmt|;
name|hr
operator|=
name|res
operator|+
name|l1
expr_stmt|;
name|h1
operator|=
name|s2
expr_stmt|;
name|h
operator|=
name|s2
expr_stmt|;
comment|/* walk through s2 */
while|while
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|*
name|h1
operator|!=
literal|'\0'
condition|)
block|{
comment|/* is there something after the current word? */
if|if
condition|(
operator|(
name|h
operator|=
name|strchr
argument_list|(
name|h1
argument_list|,
literal|' '
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|h
operator|=
literal|'\0'
expr_stmt|;
name|l1
operator|=
name|strlen
argument_list|(
name|h1
argument_list|)
expr_stmt|;
comment|/* does the current word appear in s1 ? */
if|if
condition|(
name|iteminlist
argument_list|(
name|h1
argument_list|,
name|s1
argument_list|,
literal|" "
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* add space as delimiter */
operator|*
name|hr
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* copy the item */
name|memcpy
argument_list|(
name|hr
argument_list|,
name|h1
argument_list|,
name|l1
argument_list|)
expr_stmt|;
comment|/* advance pointer in result list */
name|hr
operator|+=
name|l1
expr_stmt|;
operator|*
name|hr
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* there are more items */
operator|*
name|h
operator|=
literal|' '
expr_stmt|;
name|h1
operator|=
name|h
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SASL */
end_comment

begin_comment
comment|/* **  HELO_OPTIONS -- process the options on a HELO line. ** **	Parameters: **		line -- the response line. **		firstline -- set if this is the first line of the reply. **		m -- the mailer. **		mci -- the mailer connection info. **		e -- the envelope (unused). ** **	Returns: **		none. */
end_comment

begin_function
specifier|static
name|void
name|helo_options
parameter_list|(
name|line
parameter_list|,
name|firstline
parameter_list|,
name|m
parameter_list|,
name|mci
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|bool
name|firstline
decl_stmt|;
name|MAILER
modifier|*
name|m
decl_stmt|;
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|#
directive|if
name|_FFR_IGNORE_EXT_ON_HELO
specifier|static
name|bool
name|logged
init|=
name|false
decl_stmt|;
endif|#
directive|endif
comment|/* _FFR_IGNORE_EXT_ON_HELO */
if|if
condition|(
name|firstline
condition|)
block|{
if|#
directive|if
name|SASL
name|mci
operator|->
name|mci_saslcap
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* SASL */
if|#
directive|if
name|_FFR_IGNORE_EXT_ON_HELO
name|logged
operator|=
name|false
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_IGNORE_EXT_ON_HELO */
return|return;
block|}
if|#
directive|if
name|_FFR_IGNORE_EXT_ON_HELO
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_HELO
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|8
operator|&&
operator|!
name|logged
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"server=%s [%s] returned extensions despite HELO command"
argument_list|,
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{server_name}"
argument_list|)
argument_list|,
name|e
argument_list|)
argument_list|,
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{server_addr}"
argument_list|)
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|logged
operator|=
name|true
expr_stmt|;
block|}
return|return;
block|}
endif|#
directive|endif
comment|/* _FFR_IGNORE_EXT_ON_HELO */
if|if
condition|(
name|strlen
argument_list|(
name|line
argument_list|)
operator|<
literal|5
condition|)
return|return;
name|line
operator|+=
literal|4
expr_stmt|;
name|p
operator|=
name|strpbrk
argument_list|(
name|line
argument_list|,
literal|" ="
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|line
argument_list|,
literal|"size"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_SIZE
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|mci
operator|->
name|mci_maxsize
operator|=
name|atol
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|line
argument_list|,
literal|"8bitmime"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_8BITMIME
expr_stmt|;
name|mci
operator|->
name|mci_flags
operator|&=
operator|~
name|MCIF_7BIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|line
argument_list|,
literal|"expn"
argument_list|)
operator|==
literal|0
condition|)
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_EXPN
expr_stmt|;
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|line
argument_list|,
literal|"dsn"
argument_list|)
operator|==
literal|0
condition|)
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_DSN
expr_stmt|;
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|line
argument_list|,
literal|"enhancedstatuscodes"
argument_list|)
operator|==
literal|0
condition|)
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_ENHSTAT
expr_stmt|;
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|line
argument_list|,
literal|"pipelining"
argument_list|)
operator|==
literal|0
condition|)
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_PIPELINED
expr_stmt|;
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|line
argument_list|,
literal|"verb"
argument_list|)
operator|==
literal|0
condition|)
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_VERB
expr_stmt|;
if|#
directive|if
name|STARTTLS
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|line
argument_list|,
literal|"starttls"
argument_list|)
operator|==
literal|0
condition|)
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_TLS
expr_stmt|;
endif|#
directive|endif
comment|/* STARTTLS */
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|line
argument_list|,
literal|"deliverby"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_DLVR_BY
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|mci
operator|->
name|mci_min_by
operator|=
name|atol
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|SASL
elseif|else
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|line
argument_list|,
literal|"auth"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|mci
operator|->
name|mci_saslcap
operator|!=
name|NULL
condition|)
block|{
comment|/* 				**  Create the union with previous auth 				**  offerings because we recognize "auth " 				**  and "auth=" (old format). 				*/
name|mci
operator|->
name|mci_saslcap
operator|=
name|str_union
argument_list|(
name|mci
operator|->
name|mci_saslcap
argument_list|,
name|p
argument_list|,
name|mci
operator|->
name|mci_rpool
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_AUTH
expr_stmt|;
block|}
else|else
block|{
name|int
name|l
decl_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
name|mci
operator|->
name|mci_saslcap
operator|=
operator|(
name|char
operator|*
operator|)
name|sm_rpool_malloc
argument_list|(
name|mci
operator|->
name|mci_rpool
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_saslcap
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|mci
operator|->
name|mci_saslcap
argument_list|,
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_AUTH
expr_stmt|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
comment|/* SASL */
block|}
end_function

begin_if
if|#
directive|if
name|SASL
end_if

begin_decl_stmt
specifier|static
name|int
name|getsimple
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|unsigned
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getsecret
name|__P
argument_list|(
operator|(
name|sasl_conn_t
operator|*
operator|,
name|void
operator|*
operator|,
name|int
operator|,
name|sasl_secret_t
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|saslgetrealm
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|readauth
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|bool
operator|,
name|SASL_AI_T
operator|*
name|m
operator|,
name|SM_RPOOL_T
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getauth
name|__P
argument_list|(
operator|(
name|MCI
operator|*
operator|,
name|ENVELOPE
operator|*
operator|,
name|SASL_AI_T
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|removemech
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|SM_RPOOL_T
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|attemptauth
name|__P
argument_list|(
operator|(
name|MAILER
operator|*
operator|,
name|MCI
operator|*
operator|,
name|ENVELOPE
operator|*
operator|,
name|SASL_AI_T
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sasl_callback_t
name|callbacks
index|[]
init|=
block|{
block|{
name|SASL_CB_GETREALM
block|,
operator|&
name|saslgetrealm
block|,
name|NULL
block|}
block|,
define|#
directive|define
name|CB_GETREALM_IDX
value|0
block|{
name|SASL_CB_PASS
block|,
operator|&
name|getsecret
block|,
name|NULL
block|}
block|,
define|#
directive|define
name|CB_PASS_IDX
value|1
block|{
name|SASL_CB_USER
block|,
operator|&
name|getsimple
block|,
name|NULL
block|}
block|,
define|#
directive|define
name|CB_USER_IDX
value|2
block|{
name|SASL_CB_AUTHNAME
block|,
operator|&
name|getsimple
block|,
name|NULL
block|}
block|,
define|#
directive|define
name|CB_AUTHNAME_IDX
value|3
block|{
name|SASL_CB_VERIFYFILE
block|,
operator|&
name|safesaslfile
block|,
name|NULL
block|}
block|,
define|#
directive|define
name|CB_SAFESASL_IDX
value|4
block|{
name|SASL_CB_LIST_END
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  INIT_SASL_CLIENT -- initialize client side of Cyrus-SASL ** **	Parameters: **		none. ** **	Returns: **		SASL_OK -- if successful. **		SASL error code -- otherwise. ** **	Side Effects: **		checks/sets sasl_clt_init. ** **	Note: **	Callbacks are ignored if sasl_client_init() has **	been called before (by a library such as libnss_ldap) */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|sasl_clt_init
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|init_sasl_client
parameter_list|()
block|{
name|int
name|result
decl_stmt|;
if|if
condition|(
name|sasl_clt_init
condition|)
return|return
name|SASL_OK
return|;
name|result
operator|=
name|sasl_client_init
argument_list|(
name|callbacks
argument_list|)
expr_stmt|;
comment|/* should we retry later again or just remember that it failed? */
if|if
condition|(
name|result
operator|==
name|SASL_OK
condition|)
name|sasl_clt_init
operator|=
name|true
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* **  STOP_SASL_CLIENT -- shutdown client side of Cyrus-SASL ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		checks/sets sasl_clt_init. */
end_comment

begin_function
name|void
name|stop_sasl_client
parameter_list|()
block|{
if|if
condition|(
operator|!
name|sasl_clt_init
condition|)
return|return;
name|sasl_clt_init
operator|=
name|false
expr_stmt|;
name|sasl_done
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  GETSASLDATA -- process the challenges from the SASL protocol ** **	This gets the relevant sasl response data out of the reply **	from the server. ** **	Parameters: **		line -- the response line. **		firstline -- set if this is the first line of the reply. **		m -- the mailer. **		mci -- the mailer connection info. **		e -- the envelope (unused). ** **	Returns: **		none. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|getsasldata
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|bool
operator|,
name|MAILER
operator|*
operator|,
name|MCI
operator|*
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|getsasldata
parameter_list|(
name|line
parameter_list|,
name|firstline
parameter_list|,
name|m
parameter_list|,
name|mci
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|bool
name|firstline
decl_stmt|;
name|MAILER
modifier|*
name|m
decl_stmt|;
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|int
name|result
decl_stmt|;
if|#
directive|if
name|SASL
operator|<
literal|20000
name|char
modifier|*
name|out
decl_stmt|;
endif|#
directive|endif
comment|/* SASL< 20000 */
comment|/* if not a continue we don't care about it */
name|len
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|<=
literal|4
operator|)
operator|||
operator|(
name|line
index|[
literal|0
index|]
operator|!=
literal|'3'
operator|)
operator|||
operator|!
name|isascii
argument_list|(
name|line
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
name|line
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|isascii
argument_list|(
name|line
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
name|line
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|SM_FREE_CLR
argument_list|(
name|mci
operator|->
name|mci_sasl_string
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* forget about "334 " */
name|line
operator|+=
literal|4
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
if|#
directive|if
name|SASL
operator|>=
literal|20000
comment|/* XXX put this into a macro/function? It's duplicated below */
if|if
condition|(
name|mci
operator|->
name|mci_sasl_string
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mci
operator|->
name|mci_sasl_string_len
operator|<=
name|len
condition|)
block|{
name|sm_free
argument_list|(
name|mci
operator|->
name|mci_sasl_string
argument_list|)
expr_stmt|;
comment|/* XXX */
name|mci
operator|->
name|mci_sasl_string
operator|=
name|xalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|mci
operator|->
name|mci_sasl_string
operator|=
name|xalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|sasl_decode64
argument_list|(
name|line
argument_list|,
name|len
argument_list|,
name|mci
operator|->
name|mci_sasl_string
argument_list|,
name|len
operator|+
literal|1
argument_list|,
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|&
name|mci
operator|->
name|mci_sasl_string_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
block|{
name|mci
operator|->
name|mci_sasl_string_len
operator|=
literal|0
expr_stmt|;
operator|*
name|mci
operator|->
name|mci_sasl_string
operator|=
literal|'\0'
expr_stmt|;
block|}
else|#
directive|else
comment|/* SASL>= 20000 */
name|out
operator|=
operator|(
name|char
operator|*
operator|)
name|sm_rpool_malloc_x
argument_list|(
name|mci
operator|->
name|mci_rpool
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|sasl_decode64
argument_list|(
name|line
argument_list|,
name|len
argument_list|,
name|out
argument_list|,
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
operator|*
name|out
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* 	**  mci_sasl_string is "shared" with Cyrus-SASL library; hence 	**	it can't be in an rpool unless we use the same memory 	**	management mechanism (with same rpool!) for Cyrus SASL. 	*/
if|if
condition|(
name|mci
operator|->
name|mci_sasl_string
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mci
operator|->
name|mci_sasl_string_len
operator|<=
name|len
condition|)
block|{
name|sm_free
argument_list|(
name|mci
operator|->
name|mci_sasl_string
argument_list|)
expr_stmt|;
comment|/* XXX */
name|mci
operator|->
name|mci_sasl_string
operator|=
name|xalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|mci
operator|->
name|mci_sasl_string
operator|=
name|xalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|mci
operator|->
name|mci_sasl_string
argument_list|,
name|out
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_sasl_string
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mci
operator|->
name|mci_sasl_string_len
operator|=
name|len
expr_stmt|;
endif|#
directive|endif
comment|/* SASL>= 20000 */
return|return;
block|}
end_function

begin_comment
comment|/* **  READAUTH -- read auth values from a file ** **	Parameters: **		filename -- name of file to read. **		safe -- if set, this is a safe read. **		sai -- where to store auth_info. **		rpool -- resource pool for sai. ** **	Returns: **		EX_OK -- data succesfully read. **		EX_UNAVAILABLE -- no valid filename. **		EX_TEMPFAIL -- temporary failure. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sasl_info_name
index|[]
init|=
block|{
literal|"user id"
block|,
literal|"authentication id"
block|,
literal|"password"
block|,
literal|"realm"
block|,
literal|"mechlist"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|readauth
parameter_list|(
name|filename
parameter_list|,
name|safe
parameter_list|,
name|sai
parameter_list|,
name|rpool
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|bool
name|safe
decl_stmt|;
name|SASL_AI_T
modifier|*
name|sai
decl_stmt|;
name|SM_RPOOL_T
modifier|*
name|rpool
decl_stmt|;
block|{
name|SM_FILE_T
modifier|*
name|f
decl_stmt|;
name|long
name|sff
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|lc
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
operator|||
name|filename
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|EX_UNAVAILABLE
return|;
if|#
directive|if
operator|!
name|_FFR_ALLOW_SASLINFO
comment|/* 	**  make sure we don't use a program that is not 	**  accesible to the user who specified a different authinfo file. 	**  However, currently we don't pass this info (authinfo file 	**  specified by user) around, so we just turn off program access. 	*/
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|==
literal|'|'
condition|)
block|{
specifier|auto
name|int
name|fd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|argv
index|[
name|MAXPV
operator|+
literal|1
index|]
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|strtok
argument_list|(
operator|&
name|filename
index|[
literal|1
index|]
argument_list|,
literal|" \t"
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t"
argument_list|)
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|MAXPV
condition|)
break|break;
name|argv
index|[
name|i
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
name|argv
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|pid
operator|=
name|prog_open
argument_list|(
name|argv
argument_list|,
operator|&
name|fd
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|f
operator|=
name|NULL
expr_stmt|;
else|else
name|f
operator|=
name|sm_io_open
argument_list|(
name|SmFtStdiofd
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|fd
argument_list|,
name|SM_IO_RDONLY
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* !_FFR_ALLOW_SASLINFO */
block|{
name|pid
operator|=
operator|-
literal|1
expr_stmt|;
name|sff
operator|=
name|SFF_REGONLY
operator||
name|SFF_SAFEDIRPATH
operator||
name|SFF_NOWLINK
operator||
name|SFF_NOGWFILES
operator||
name|SFF_NOWWFILES
operator||
name|SFF_NOWRFILES
expr_stmt|;
if|#
directive|if
name|_FFR_GROUPREADABLEAUTHINFOFILE
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|DBS_GROUPREADABLEAUTHINFOFILE
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
endif|#
directive|endif
comment|/* _FFR_GROUPREADABLEAUTHINFOFILE */
name|sff
operator||=
name|SFF_NOGRFILES
expr_stmt|;
if|if
condition|(
name|DontLockReadFiles
condition|)
name|sff
operator||=
name|SFF_NOLOCK
expr_stmt|;
if|#
directive|if
name|_FFR_ALLOW_SASLINFO
comment|/* 		**  XXX: make sure we don't read or open files that are not 		**  accesible to the user who specified a different authinfo 		**  file. 		*/
name|sff
operator||=
name|SFF_MUSTOWN
expr_stmt|;
else|#
directive|else
comment|/* _FFR_ALLOW_SASLINFO */
if|if
condition|(
name|safe
condition|)
name|sff
operator||=
name|SFF_OPENASROOT
expr_stmt|;
endif|#
directive|endif
comment|/* _FFR_ALLOW_SASLINFO */
name|f
operator|=
name|safefopen
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
name|sff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"AUTH=client, error: can't open %s: %s"
argument_list|,
name|filename
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
name|lc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|lc
operator|<=
name|SASL_MECHLIST
operator|&&
name|sm_io_fgets
argument_list|(
name|f
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'#'
condition|)
block|{
operator|(
operator|*
name|sai
operator|)
index|[
name|lc
index|]
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|rpool
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|strchr
argument_list|(
operator|(
operator|*
name|sai
operator|)
index|[
name|lc
index|]
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|lc
operator|++
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|f
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|waitfor
argument_list|(
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|lc
operator|<
name|SASL_PASSWORD
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"AUTH=client, error: can't read %s from %s"
argument_list|,
name|sasl_info_name
index|[
name|lc
operator|+
literal|1
index|]
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
return|return
name|EX_OK
return|;
block|}
end_function

begin_comment
comment|/* **  GETAUTH -- get authinfo from ruleset call ** **	{server_name}, {server_addr} must be set ** **	Parameters: **		mci -- the mailer connection structure. **		e -- the envelope (including the sender to specify). **		sai -- pointer to authinfo (result). ** **	Returns: **		EX_OK -- ruleset was succesfully called, data may not **			be available, sai must be checked. **		EX_UNAVAILABLE -- ruleset unavailable (or failed). **		EX_TEMPFAIL -- temporary failure (from ruleset). ** **	Side Effects: **		Fills in sai if successful. */
end_comment

begin_function
specifier|static
name|int
name|getauth
parameter_list|(
name|mci
parameter_list|,
name|e
parameter_list|,
name|sai
parameter_list|)
name|MCI
modifier|*
name|mci
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|SASL_AI_T
modifier|*
name|sai
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|r
decl_stmt|,
name|l
decl_stmt|,
name|got
decl_stmt|,
name|ret
decl_stmt|;
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
name|char
name|pvpbuf
index|[
name|PSBUFSIZE
index|]
decl_stmt|;
name|r
operator|=
name|rscap
argument_list|(
literal|"authinfo"
argument_list|,
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{server_name}"
argument_list|)
argument_list|,
name|e
argument_list|)
argument_list|,
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{server_addr}"
argument_list|)
argument_list|,
name|e
argument_list|)
argument_list|,
name|e
argument_list|,
operator|&
name|pvp
argument_list|,
name|pvpbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pvpbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|EX_OK
condition|)
return|return
name|EX_UNAVAILABLE
return|;
comment|/* other than expected return value: ok (i.e., no auth) */
if|if
condition|(
name|pvp
operator|==
name|NULL
operator|||
name|pvp
index|[
literal|0
index|]
operator|==
name|NULL
operator|||
operator|(
name|pvp
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|&
literal|0377
operator|)
operator|!=
name|CANONNET
condition|)
return|return
name|EX_OK
return|;
if|if
condition|(
name|pvp
index|[
literal|1
index|]
operator|!=
name|NULL
operator|&&
name|sm_strncasecmp
argument_list|(
name|pvp
index|[
literal|1
index|]
argument_list|,
literal|"temp"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
name|EX_TEMPFAIL
return|;
comment|/* 	**  parse the data, put it into sai 	**  format: "TDstring" (including the '"' !) 	**  where T is a tag: 'U', ... 	**  D is a delimiter: ':' or '=' 	*/
name|ret
operator|=
name|EX_OK
expr_stmt|;
comment|/* default return value */
name|i
operator|=
literal|0
expr_stmt|;
name|got
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|SASL_ENTRIES
condition|)
block|{
if|if
condition|(
name|pvp
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|pvp
index|[
name|i
operator|+
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|'"'
condition|)
break|break;
switch|switch
condition|(
name|pvp
index|[
name|i
operator|+
literal|1
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'U'
case|:
case|case
literal|'u'
case|:
name|r
operator|=
name|SASL_USER
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
case|case
literal|'i'
case|:
name|r
operator|=
name|SASL_AUTHID
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
case|case
literal|'p'
case|:
name|r
operator|=
name|SASL_PASSWORD
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
case|case
literal|'r'
case|:
name|r
operator|=
name|SASL_DEFREALM
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
case|case
literal|'m'
case|:
name|r
operator|=
name|SASL_MECHLIST
expr_stmt|;
break|break;
default|default:
goto|goto
name|fail
goto|;
block|}
name|l
operator|=
name|strlen
argument_list|(
name|pvp
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* check syntax */
if|if
condition|(
name|l
operator|<=
literal|3
operator|||
name|pvp
index|[
name|i
operator|+
literal|1
index|]
index|[
name|l
operator|-
literal|1
index|]
operator|!=
literal|'"'
condition|)
goto|goto
name|fail
goto|;
comment|/* remove closing quote */
name|pvp
index|[
name|i
operator|+
literal|1
index|]
index|[
name|l
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* remove "TD and " */
name|l
operator|-=
literal|4
expr_stmt|;
operator|(
operator|*
name|sai
operator|)
index|[
name|r
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|sm_rpool_malloc
argument_list|(
name|mci
operator|->
name|mci_rpool
argument_list|,
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|sai
operator|)
index|[
name|r
index|]
operator|==
name|NULL
condition|)
goto|goto
name|tempfail
goto|;
if|if
condition|(
name|pvp
index|[
name|i
operator|+
literal|1
index|]
index|[
literal|2
index|]
operator|==
literal|':'
condition|)
block|{
comment|/* ':text' (just copy) */
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
operator|(
operator|*
name|sai
operator|)
index|[
name|r
index|]
argument_list|,
name|pvp
index|[
name|i
operator|+
literal|1
index|]
operator|+
literal|3
argument_list|,
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
name|got
operator||=
literal|1
operator|<<
name|r
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pvp
index|[
name|i
operator|+
literal|1
index|]
index|[
literal|2
index|]
operator|==
literal|'='
condition|)
block|{
name|unsigned
name|int
name|len
decl_stmt|;
comment|/* '=base64' (decode) */
if|#
directive|if
name|SASL
operator|>=
literal|20000
name|ret
operator|=
name|sasl_decode64
argument_list|(
name|pvp
index|[
name|i
operator|+
literal|1
index|]
operator|+
literal|3
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|l
argument_list|,
operator|(
operator|*
name|sai
operator|)
index|[
name|r
index|]
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|l
operator|+
literal|1
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SASL>= 20000 */
name|ret
operator|=
name|sasl_decode64
argument_list|(
name|pvp
index|[
name|i
operator|+
literal|1
index|]
operator|+
literal|3
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|l
argument_list|,
operator|(
operator|*
name|sai
operator|)
index|[
name|r
index|]
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SASL>= 20000 */
if|if
condition|(
name|ret
operator|!=
name|SASL_OK
condition|)
goto|goto
name|fail
goto|;
name|got
operator||=
literal|1
operator|<<
name|r
expr_stmt|;
block|}
else|else
goto|goto
name|fail
goto|;
if|if
condition|(
name|tTd
argument_list|(
literal|95
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|NOQID
argument_list|,
literal|"getauth %s=%s"
argument_list|,
name|sasl_info_name
index|[
name|r
index|]
argument_list|,
operator|(
operator|*
name|sai
operator|)
index|[
name|r
index|]
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
comment|/* did we get the expected data? */
comment|/* XXX: EXTERNAL mechanism only requires (and only uses) SASL_USER */
if|if
condition|(
operator|!
operator|(
name|bitset
argument_list|(
name|SASL_USER_BIT
operator||
name|SASL_AUTHID_BIT
argument_list|,
name|got
argument_list|)
operator|&&
name|bitset
argument_list|(
name|SASL_PASSWORD_BIT
argument_list|,
name|got
argument_list|)
operator|)
condition|)
goto|goto
name|fail
goto|;
comment|/* no authid? copy uid */
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|SASL_AUTHID_BIT
argument_list|,
name|got
argument_list|)
condition|)
block|{
name|l
operator|=
name|strlen
argument_list|(
operator|(
operator|*
name|sai
operator|)
index|[
name|SASL_USER
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|(
operator|*
name|sai
operator|)
index|[
name|SASL_AUTHID
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|sm_rpool_malloc
argument_list|(
name|mci
operator|->
name|mci_rpool
argument_list|,
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|sai
operator|)
index|[
name|SASL_AUTHID
index|]
operator|==
name|NULL
condition|)
goto|goto
name|tempfail
goto|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
operator|(
operator|*
name|sai
operator|)
index|[
name|SASL_AUTHID
index|]
argument_list|,
operator|(
operator|*
name|sai
operator|)
index|[
name|SASL_USER
index|]
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
comment|/* no uid? copy authid */
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|SASL_USER_BIT
argument_list|,
name|got
argument_list|)
condition|)
block|{
name|l
operator|=
name|strlen
argument_list|(
operator|(
operator|*
name|sai
operator|)
index|[
name|SASL_AUTHID
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|(
operator|*
name|sai
operator|)
index|[
name|SASL_USER
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|sm_rpool_malloc
argument_list|(
name|mci
operator|->
name|mci_rpool
argument_list|,
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|sai
operator|)
index|[
name|SASL_USER
index|]
operator|==
name|NULL
condition|)
goto|goto
name|tempfail
goto|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
operator|(
operator|*
name|sai
operator|)
index|[
name|SASL_USER
index|]
argument_list|,
operator|(
operator|*
name|sai
operator|)
index|[
name|SASL_AUTHID
index|]
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
return|return
name|EX_OK
return|;
name|tempfail
label|:
name|ret
operator|=
name|EX_TEMPFAIL
expr_stmt|;
name|fail
label|:
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"AUTH=client, relay=%.64s [%.16s], authinfo %sfailed"
argument_list|,
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{server_name}"
argument_list|)
argument_list|,
name|e
argument_list|)
argument_list|,
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{server_addr}"
argument_list|)
argument_list|,
name|e
argument_list|)
argument_list|,
name|ret
operator|==
name|EX_TEMPFAIL
condition|?
literal|"temp"
else|:
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|SASL_MECHLIST
condition|;
name|i
operator|++
control|)
operator|(
operator|*
name|sai
operator|)
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* just clear; rpool */
return|return
name|ret
return|;
block|}
end_function

begin_if
if|#
directive|if
name|SASL
operator|>=
literal|20000
end_if

begin_comment
comment|/* **  GETSIMPLE -- callback to get userid or authid ** **	Parameters: **		context -- sai **		id -- what to do **		result -- (pointer to) result **		len -- (pointer to) length of result ** **	Returns: **		OK/failure values */
end_comment

begin_function
specifier|static
name|int
name|getsimple
parameter_list|(
name|context
parameter_list|,
name|id
parameter_list|,
name|result
parameter_list|,
name|len
parameter_list|)
name|void
modifier|*
name|context
decl_stmt|;
name|int
name|id
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|result
decl_stmt|;
name|unsigned
modifier|*
name|len
decl_stmt|;
block|{
name|SASL_AI_T
modifier|*
name|sai
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
operator|||
name|context
operator|==
name|NULL
condition|)
return|return
name|SASL_BADPARAM
return|;
name|sai
operator|=
operator|(
name|SASL_AI_T
operator|*
operator|)
name|context
expr_stmt|;
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|SASL_CB_USER
case|:
operator|*
name|result
operator|=
operator|(
operator|*
name|sai
operator|)
index|[
name|SASL_USER
index|]
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|95
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|NOQID
argument_list|,
literal|"AUTH username '%s'"
argument_list|,
operator|*
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|NULL
condition|)
operator|*
name|len
operator|=
operator|*
name|result
operator|!=
name|NULL
condition|?
name|strlen
argument_list|(
operator|*
name|result
argument_list|)
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|SASL_CB_AUTHNAME
case|:
operator|*
name|result
operator|=
operator|(
operator|*
name|sai
operator|)
index|[
name|SASL_AUTHID
index|]
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|95
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|NOQID
argument_list|,
literal|"AUTH authid '%s'"
argument_list|,
operator|*
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|NULL
condition|)
operator|*
name|len
operator|=
operator|*
name|result
operator|!=
name|NULL
condition|?
name|strlen
argument_list|(
operator|*
name|result
argument_list|)
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|SASL_CB_LANGUAGE
case|:
operator|*
name|result
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|NULL
condition|)
operator|*
name|len
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
name|SASL_BADPARAM
return|;
block|}
return|return
name|SASL_OK
return|;
block|}
end_function

begin_comment
comment|/* **  GETSECRET -- callback to get password ** **	Parameters: **		conn -- connection information **		context -- sai **		id -- what to do **		psecret -- (pointer to) result ** **	Returns: **		OK/failure values */
end_comment

begin_function_decl
specifier|static
name|int
name|getsecret
parameter_list|(
name|conn
parameter_list|,
name|context
parameter_list|,
name|id
parameter_list|,
name|psecret
parameter_list|)
name|sasl_conn_t
modifier|*
name|conn
decl_stmt|;
function_decl|SM_UNUSED
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|sasl_secret_t
modifier|*
modifier|*
name|psecret
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|authpass
decl_stmt|;
name|MCI
modifier|*
name|mci
decl_stmt|;
if|if
condition|(
name|conn
operator|==
name|NULL
operator|||
name|psecret
operator|==
name|NULL
operator|||
name|id
operator|!=
name|SASL_CB_PASS
condition|)
return|return
name|SASL_BADPARAM
return|;
name|mci
operator|=
operator|(
name|MCI
operator|*
operator|)
name|context
expr_stmt|;
name|authpass
operator|=
name|mci
operator|->
name|mci_sai
index|[
name|SASL_PASSWORD
index|]
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|authpass
argument_list|)
expr_stmt|;
comment|/* 	**  use an rpool because we are responsible for free()ing the secret, 	**  but we can't free() it until after the auth completes 	*/
operator|*
name|psecret
operator|=
operator|(
name|sasl_secret_t
operator|*
operator|)
name|sm_rpool_malloc
argument_list|(
name|mci
operator|->
name|mci_rpool
argument_list|,
sizeof|sizeof
argument_list|(
name|sasl_secret_t
argument_list|)
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|psecret
operator|==
name|NULL
condition|)
return|return
name|SASL_FAIL
return|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|*
name|psecret
operator|)
operator|->
name|data
argument_list|,
name|authpass
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|psecret
operator|)
operator|->
name|len
operator|=
operator|(
name|unsigned
name|long
operator|)
name|len
expr_stmt|;
return|return
name|SASL_OK
return|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SASL>= 20000 */
end_comment

begin_comment
comment|/* **  GETSIMPLE -- callback to get userid or authid ** **	Parameters: **		context -- sai **		id -- what to do **		result -- (pointer to) result **		len -- (pointer to) length of result ** **	Returns: **		OK/failure values */
end_comment

begin_function
specifier|static
name|int
name|getsimple
parameter_list|(
name|context
parameter_list|,
name|id
parameter_list|,
name|result
parameter_list|,
name|len
parameter_list|)
name|void
modifier|*
name|context
decl_stmt|;
name|int
name|id
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|result
decl_stmt|;
name|unsigned
modifier|*
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|h
decl_stmt|,
modifier|*
name|s
decl_stmt|;
if|#
directive|if
name|SASL
operator|>
literal|10509
name|bool
name|addrealm
decl_stmt|;
endif|#
directive|endif
comment|/* SASL> 10509 */
name|size_t
name|l
decl_stmt|;
name|SASL_AI_T
modifier|*
name|sai
decl_stmt|;
name|char
modifier|*
name|authid
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
operator|||
name|context
operator|==
name|NULL
condition|)
return|return
name|SASL_BADPARAM
return|;
name|sai
operator|=
operator|(
name|SASL_AI_T
operator|*
operator|)
name|context
expr_stmt|;
comment|/* 	**  Unfortunately it is not clear whether this routine should 	**  return a copy of a string or just a pointer to a string. 	**  The Cyrus-SASL plugins treat these return values differently, e.g., 	**  plugins/cram.c free()s authid, plugings/digestmd5.c does not. 	**  The best solution to this problem is to fix Cyrus-SASL, but it 	**  seems there is nobody who creates patches... Hello CMU!? 	**  The second best solution is to have flags that tell this routine 	**  whether to return an malloc()ed copy. 	**  The next best solution is to always return an malloc()ed copy, 	**  and suffer from some memory leak, which is ugly for persistent 	**  queue runners. 	**  For now we go with the last solution... 	**  We can't use rpools (which would avoid this particular problem) 	**  as explained in sasl.c. 	*/
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|SASL_CB_USER
case|:
name|l
operator|=
name|strlen
argument_list|(
operator|(
operator|*
name|sai
operator|)
index|[
name|SASL_USER
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|s
operator|=
name|sm_sasl_malloc
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|len
operator|!=
name|NULL
condition|)
operator|*
name|len
operator|=
literal|0
expr_stmt|;
operator|*
name|result
operator|=
name|NULL
expr_stmt|;
return|return
name|SASL_NOMEM
return|;
block|}
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|s
argument_list|,
operator|(
operator|*
name|sai
operator|)
index|[
name|SASL_USER
index|]
argument_list|,
name|l
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|95
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|NOQID
argument_list|,
literal|"AUTH username '%s'"
argument_list|,
operator|*
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|NULL
condition|)
operator|*
name|len
operator|=
operator|*
name|result
operator|!=
name|NULL
condition|?
name|strlen
argument_list|(
operator|*
name|result
argument_list|)
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|SASL_CB_AUTHNAME
case|:
name|h
operator|=
operator|(
operator|*
name|sai
operator|)
index|[
name|SASL_AUTHID
index|]
expr_stmt|;
if|#
directive|if
name|SASL
operator|>
literal|10509
comment|/* XXX maybe other mechanisms too?! */
name|addrealm
operator|=
operator|(
operator|*
name|sai
operator|)
index|[
name|SASL_MECH
index|]
operator|!=
name|NULL
operator|&&
name|sm_strcasecmp
argument_list|(
operator|(
operator|*
name|sai
operator|)
index|[
name|SASL_MECH
index|]
argument_list|,
literal|"CRAM-MD5"
argument_list|)
operator|==
literal|0
expr_stmt|;
comment|/* 		**  Add realm to authentication id unless authid contains 		**  '@' (i.e., a realm) or the default realm is empty. 		*/
if|if
condition|(
name|addrealm
operator|&&
name|h
operator|!=
name|NULL
operator|&&
name|strchr
argument_list|(
name|h
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* has this been done before? */
if|if
condition|(
operator|(
operator|*
name|sai
operator|)
index|[
name|SASL_ID_REALM
index|]
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|realm
decl_stmt|;
name|realm
operator|=
operator|(
operator|*
name|sai
operator|)
index|[
name|SASL_DEFREALM
index|]
expr_stmt|;
comment|/* do not add an empty realm */
if|if
condition|(
operator|*
name|realm
operator|==
literal|'\0'
condition|)
block|{
name|authid
operator|=
name|h
expr_stmt|;
operator|(
operator|*
name|sai
operator|)
index|[
name|SASL_ID_REALM
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|l
operator|=
name|strlen
argument_list|(
name|h
argument_list|)
operator|+
name|strlen
argument_list|(
name|realm
argument_list|)
operator|+
literal|2
expr_stmt|;
comment|/* should use rpool, but from where? */
name|authid
operator|=
name|sm_sasl_malloc
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|authid
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|authid
argument_list|,
name|l
argument_list|,
literal|"%s@%s"
argument_list|,
name|h
argument_list|,
name|realm
argument_list|)
expr_stmt|;
operator|(
operator|*
name|sai
operator|)
index|[
name|SASL_ID_REALM
index|]
operator|=
name|authid
expr_stmt|;
block|}
else|else
block|{
name|authid
operator|=
name|h
expr_stmt|;
operator|(
operator|*
name|sai
operator|)
index|[
name|SASL_ID_REALM
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
else|else
name|authid
operator|=
operator|(
operator|*
name|sai
operator|)
index|[
name|SASL_ID_REALM
index|]
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* SASL> 10509 */
name|authid
operator|=
name|h
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|authid
argument_list|)
operator|+
literal|1
expr_stmt|;
name|s
operator|=
name|sm_sasl_malloc
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|len
operator|!=
name|NULL
condition|)
operator|*
name|len
operator|=
literal|0
expr_stmt|;
operator|*
name|result
operator|=
name|NULL
expr_stmt|;
return|return
name|SASL_NOMEM
return|;
block|}
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|s
argument_list|,
name|authid
argument_list|,
name|l
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|95
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|NOQID
argument_list|,
literal|"AUTH authid '%s'"
argument_list|,
operator|*
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|NULL
condition|)
operator|*
name|len
operator|=
name|authid
condition|?
name|strlen
argument_list|(
name|authid
argument_list|)
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|SASL_CB_LANGUAGE
case|:
operator|*
name|result
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|NULL
condition|)
operator|*
name|len
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
name|SASL_BADPARAM
return|;
block|}
return|return
name|SASL_OK
return|;
block|}
end_function

begin_comment
comment|/* **  GETSECRET -- callback to get password ** **	Parameters: **		conn -- connection information **		context -- sai **		id -- what to do **		psecret -- (pointer to) result ** **	Returns: **		OK/failure values */
end_comment

begin_function_decl
specifier|static
name|int
name|getsecret
parameter_list|(
name|conn
parameter_list|,
name|context
parameter_list|,
name|id
parameter_list|,
name|psecret
parameter_list|)
name|sasl_conn_t
modifier|*
name|conn
decl_stmt|;
function_decl|SM_UNUSED
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|sasl_secret_t
modifier|*
modifier|*
name|psecret
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|authpass
decl_stmt|;
name|SASL_AI_T
modifier|*
name|sai
decl_stmt|;
if|if
condition|(
name|conn
operator|==
name|NULL
operator|||
name|psecret
operator|==
name|NULL
operator|||
name|id
operator|!=
name|SASL_CB_PASS
condition|)
return|return
name|SASL_BADPARAM
return|;
name|sai
operator|=
operator|(
name|SASL_AI_T
operator|*
operator|)
name|context
expr_stmt|;
name|authpass
operator|=
operator|(
operator|*
name|sai
operator|)
index|[
name|SASL_PASSWORD
index|]
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|authpass
argument_list|)
expr_stmt|;
operator|*
name|psecret
operator|=
operator|(
name|sasl_secret_t
operator|*
operator|)
name|sm_sasl_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sasl_secret_t
argument_list|)
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|psecret
operator|==
name|NULL
condition|)
return|return
name|SASL_FAIL
return|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
operator|(
operator|*
name|psecret
operator|)
operator|->
name|data
argument_list|,
name|authpass
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|psecret
operator|)
operator|->
name|len
operator|=
operator|(
name|unsigned
name|long
operator|)
name|len
expr_stmt|;
return|return
name|SASL_OK
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SASL>= 20000 */
end_comment

begin_comment
comment|/* **  SAFESASLFILE -- callback for sasl: is file safe? ** **	Parameters: **		context -- pointer to context between invocations (unused) **		file -- name of file to check **		type -- type of file to check ** **	Returns: **		SASL_OK -- file can be used **		SASL_CONTINUE -- don't use file **		SASL_FAIL -- failure (not used here) ** */
end_comment

begin_function
name|int
if|#
directive|if
name|SASL
operator|>
literal|10515
name|safesaslfile
parameter_list|(
name|context
parameter_list|,
name|file
parameter_list|,
name|type
parameter_list|)
else|#
directive|else
comment|/* SASL> 10515 */
function|safesaslfile
parameter_list|(
name|context
parameter_list|,
name|file
parameter_list|)
endif|#
directive|endif
comment|/* SASL> 10515 */
name|void
modifier|*
name|context
decl_stmt|;
if|#
directive|if
name|SASL
operator|>=
literal|20000
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
else|#
directive|else
comment|/* SASL>= 20000 */
name|char
modifier|*
name|file
decl_stmt|;
endif|#
directive|endif
comment|/* SASL>= 20000 */
if|#
directive|if
name|SASL
operator|>
literal|10515
if|#
directive|if
name|SASL
operator|>=
literal|20000
name|sasl_verify_type_t
name|type
decl_stmt|;
else|#
directive|else
comment|/* SASL>= 20000 */
name|int
name|type
decl_stmt|;
endif|#
directive|endif
comment|/* SASL>= 20000 */
endif|#
directive|endif
comment|/* SASL> 10515 */
block|{
name|long
name|sff
decl_stmt|;
name|int
name|r
decl_stmt|;
if|#
directive|if
name|SASL
operator|<=
literal|10515
name|size_t
name|len
decl_stmt|;
endif|#
directive|endif
comment|/* SASL<= 10515 */
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
operator|||
operator|*
name|file
operator|==
literal|'\0'
condition|)
return|return
name|SASL_OK
return|;
name|sff
operator|=
name|SFF_SAFEDIRPATH
operator||
name|SFF_NOWLINK
operator||
name|SFF_NOWWFILES
operator||
name|SFF_ROOTOK
expr_stmt|;
if|#
directive|if
name|SASL
operator|<=
literal|10515
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|p
operator|=
name|file
expr_stmt|;
else|else
operator|++
name|p
expr_stmt|;
comment|/* everything beside libs and .conf files must not be readable */
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|<=
literal|3
operator|||
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"lib"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|len
operator|<=
literal|5
operator|||
name|strncmp
argument_list|(
name|p
operator|+
name|len
operator|-
literal|5
argument_list|,
literal|".conf"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|DBS_GROUPREADABLESASLDBFILE
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
name|sff
operator||=
name|SFF_NORFILES
expr_stmt|;
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|DBS_GROUPWRITABLESASLDBFILE
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
name|sff
operator||=
name|SFF_NOGWFILES
expr_stmt|;
block|}
else|#
directive|else
comment|/* SASL<= 10515 */
comment|/* files containing passwords should be not readable */
if|if
condition|(
name|type
operator|==
name|SASL_VRFY_PASSWD
condition|)
block|{
if|if
condition|(
name|bitnset
argument_list|(
name|DBS_GROUPREADABLESASLDBFILE
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
name|sff
operator||=
name|SFF_NOWRFILES
expr_stmt|;
else|else
name|sff
operator||=
name|SFF_NORFILES
expr_stmt|;
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|DBS_GROUPWRITABLESASLDBFILE
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
name|sff
operator||=
name|SFF_NOGWFILES
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SASL<= 10515 */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|file
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|safefile
argument_list|(
name|p
argument_list|,
name|RunAsUid
argument_list|,
name|RunAsGid
argument_list|,
name|RunAsUserName
argument_list|,
name|sff
argument_list|,
name|S_IRUSR
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|SASL_OK
return|;
if|if
condition|(
name|LogLevel
operator|>
operator|(
name|r
operator|!=
name|ENOENT
condition|?
literal|8
else|:
literal|10
operator|)
condition|)
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"error: safesasl(%s) failed: %s"
argument_list|,
name|p
argument_list|,
name|sm_errstring
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SASL_CONTINUE
return|;
block|}
end_function

begin_comment
comment|/* **  SASLGETREALM -- return the realm for SASL ** **	return the realm for the client ** **	Parameters: **		context -- context shared between invocations **		availrealms -- list of available realms **			{realm, realm, ...} **		result -- pointer to result ** **	Returns: **		failure/success */
end_comment

begin_function
specifier|static
name|int
name|saslgetrealm
parameter_list|(
name|context
parameter_list|,
name|id
parameter_list|,
name|availrealms
parameter_list|,
name|result
parameter_list|)
name|void
modifier|*
name|context
decl_stmt|;
name|int
name|id
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|availrealms
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|result
decl_stmt|;
block|{
name|char
modifier|*
name|r
decl_stmt|;
name|SASL_AI_T
modifier|*
name|sai
decl_stmt|;
name|sai
operator|=
operator|(
name|SASL_AI_T
operator|*
operator|)
name|context
expr_stmt|;
if|if
condition|(
name|sai
operator|==
name|NULL
condition|)
return|return
name|SASL_FAIL
return|;
name|r
operator|=
operator|(
operator|*
name|sai
operator|)
index|[
name|SASL_DEFREALM
index|]
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|12
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"AUTH=client, realm=%s, available realms=%s"
argument_list|,
name|r
operator|==
name|NULL
condition|?
literal|"<No Realm>"
else|:
name|r
argument_list|,
operator|(
name|availrealms
operator|==
name|NULL
operator|||
operator|*
name|availrealms
operator|==
name|NULL
operator|)
condition|?
literal|"<No Realms>"
else|:
operator|*
name|availrealms
argument_list|)
expr_stmt|;
comment|/* check whether context is in list */
if|if
condition|(
name|availrealms
operator|!=
name|NULL
operator|&&
operator|*
name|availrealms
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|iteminlist
argument_list|(
name|context
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|*
name|availrealms
operator|+
literal|1
operator|)
argument_list|,
literal|" ,}"
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"AUTH=client, realm=%s not in list=%s"
argument_list|,
name|r
argument_list|,
operator|*
name|availrealms
argument_list|)
expr_stmt|;
return|return
name|SASL_FAIL
return|;
block|}
block|}
operator|*
name|result
operator|=
name|r
expr_stmt|;
return|return
name|SASL_OK
return|;
block|}
end_function

begin_comment
comment|/* **  ITEMINLIST -- does item appear in list? ** **	Check whether item appears in list (which must be separated by a **	character in delim) as a "word", i.e. it must appear at the begin **	of the list or after a space, and it must end with a space or the **	end of the list. ** **	Parameters: **		item -- item to search. **		list -- list of items. **		delim -- list of delimiters. ** **	Returns: **		pointer to occurrence (NULL if not found). */
end_comment

begin_function
name|char
modifier|*
name|iteminlist
parameter_list|(
name|item
parameter_list|,
name|list
parameter_list|,
name|delim
parameter_list|)
name|char
modifier|*
name|item
decl_stmt|;
name|char
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|delim
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
operator|||
operator|*
name|list
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|item
operator|==
name|NULL
operator|||
operator|*
name|item
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
name|s
operator|=
name|list
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|item
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|sm_strncasecmp
argument_list|(
name|s
argument_list|,
name|item
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|s
index|[
name|len
index|]
operator|==
literal|'\0'
operator|||
name|strchr
argument_list|(
name|delim
argument_list|,
name|s
index|[
name|len
index|]
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
return|return
name|s
return|;
name|s
operator|=
name|strpbrk
argument_list|(
name|s
argument_list|,
name|delim
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
while|while
condition|(
operator|*
operator|++
name|s
operator|==
literal|' '
condition|)
continue|continue;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  REMOVEMECH -- remove item [rem] from list [list] ** **	Parameters: **		rem -- item to remove **		list -- list of items **		rpool -- resource pool from which result is allocated. ** **	Returns: **		pointer to new list (NULL in case of error). */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|removemech
parameter_list|(
name|rem
parameter_list|,
name|list
parameter_list|,
name|rpool
parameter_list|)
name|char
modifier|*
name|rem
decl_stmt|;
name|char
modifier|*
name|list
decl_stmt|;
name|SM_RPOOL_T
modifier|*
name|rpool
decl_stmt|;
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|char
modifier|*
name|needle
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|rem
operator|==
name|NULL
operator|||
operator|*
name|rem
operator|==
literal|'\0'
condition|)
block|{
comment|/* take out what? */
return|return
name|NULL
return|;
block|}
comment|/* find the item in the list */
if|if
condition|(
operator|(
name|needle
operator|=
name|iteminlist
argument_list|(
name|rem
argument_list|,
name|list
argument_list|,
literal|" "
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* not in there: return original */
return|return
name|list
return|;
block|}
comment|/* length of string without rem */
name|len
operator|=
name|strlen
argument_list|(
name|list
argument_list|)
operator|-
name|strlen
argument_list|(
name|rem
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|ret
operator|=
operator|(
name|char
operator|*
operator|)
name|sm_rpool_malloc_x
argument_list|(
name|rpool
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|ret
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ret
return|;
block|}
name|ret
operator|=
operator|(
name|char
operator|*
operator|)
name|sm_rpool_malloc_x
argument_list|(
name|rpool
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ret
argument_list|,
literal|'\0'
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* copy from start to removed item */
name|memcpy
argument_list|(
name|ret
argument_list|,
name|list
argument_list|,
name|needle
operator|-
name|list
argument_list|)
expr_stmt|;
comment|/* length of rest of string past removed item */
name|len
operator|=
name|strlen
argument_list|(
name|needle
argument_list|)
operator|-
name|strlen
argument_list|(
name|rem
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* not last item -- copy into string */
name|memcpy
argument_list|(
name|ret
operator|+
operator|(
name|needle
operator|-
name|list
operator|)
argument_list|,
name|list
operator|+
operator|(
name|needle
operator|-
name|list
operator|)
operator|+
name|strlen
argument_list|(
name|rem
argument_list|)
operator|+
literal|1
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
index|[
operator|(
name|needle
operator|-
name|list
operator|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* **  ATTEMPTAUTH -- try to AUTHenticate using one mechanism ** **	Parameters: **		m -- the mailer. **		mci -- the mailer connection structure. **		e -- the envelope (including the sender to specify). **		sai - sasl authinfo ** **	Returns: **		EX_OK -- authentication was successful. **		EX_NOPERM -- authentication failed. **		EX_IOERR -- authentication dialogue failed (I/O problem?). **		EX_TEMPFAIL -- temporary failure. ** */
end_comment

begin_function
specifier|static
name|int
name|attemptauth
parameter_list|(
name|m
parameter_list|,
name|mci
parameter_list|,
name|e
parameter_list|,
name|sai
parameter_list|)
name|MAILER
modifier|*
name|m
decl_stmt|;
name|MCI
modifier|*
name|mci
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|SASL_AI_T
modifier|*
name|sai
decl_stmt|;
block|{
name|int
name|saslresult
decl_stmt|,
name|smtpresult
decl_stmt|;
if|#
directive|if
name|SASL
operator|>=
literal|20000
name|sasl_ssf_t
name|ssf
decl_stmt|;
specifier|const
name|char
modifier|*
name|auth_id
decl_stmt|;
specifier|const
name|char
modifier|*
name|out
decl_stmt|;
else|#
directive|else
comment|/* SASL>= 20000 */
name|sasl_external_properties_t
name|ssf
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|;
endif|#
directive|endif
comment|/* SASL>= 20000 */
name|unsigned
name|int
name|outlen
decl_stmt|;
name|sasl_interact_t
modifier|*
name|client_interact
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|mechusing
decl_stmt|;
name|sasl_security_properties_t
name|ssp
decl_stmt|;
name|char
name|in64
index|[
name|MAXOUTLEN
index|]
decl_stmt|;
if|#
directive|if
name|NETINET
operator|||
operator|(
name|NETINET6
operator|&&
name|SASL
operator|>=
literal|20000
operator|)
specifier|extern
name|SOCKADDR
name|CurHostAddr
decl_stmt|;
endif|#
directive|endif
comment|/* NETINET || (NETINET6&& SASL>= 20000) */
comment|/* no mechanism selected (yet) */
operator|(
operator|*
name|sai
operator|)
index|[
name|SASL_MECH
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* dispose old connection */
if|if
condition|(
name|mci
operator|->
name|mci_conn
operator|!=
name|NULL
condition|)
name|sasl_dispose
argument_list|(
operator|&
operator|(
name|mci
operator|->
name|mci_conn
operator|)
argument_list|)
expr_stmt|;
comment|/* make a new client sasl connection */
if|#
directive|if
name|SASL
operator|>=
literal|20000
comment|/* 	**  We provide the callbacks again because global callbacks in 	**  sasl_client_init() are ignored if SASL has been initialized 	**  before, for example, by a library such as libnss-ldap. 	*/
name|saslresult
operator|=
name|sasl_client_new
argument_list|(
name|bitnset
argument_list|(
name|M_LMTP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|?
literal|"lmtp"
else|:
literal|"smtp"
argument_list|,
name|CurHostName
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|callbacks
argument_list|,
literal|0
argument_list|,
operator|&
name|mci
operator|->
name|mci_conn
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SASL>= 20000 */
name|saslresult
operator|=
name|sasl_client_new
argument_list|(
name|bitnset
argument_list|(
name|M_LMTP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|?
literal|"lmtp"
else|:
literal|"smtp"
argument_list|,
name|CurHostName
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|mci
operator|->
name|mci_conn
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SASL>= 20000 */
if|if
condition|(
name|saslresult
operator|!=
name|SASL_OK
condition|)
return|return
name|EX_TEMPFAIL
return|;
comment|/* set properties */
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|&
name|ssp
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|ssp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX should these be options settable via .cf ? */
block|{
name|ssp
operator|.
name|max_ssf
operator|=
name|MaxSLBits
expr_stmt|;
name|ssp
operator|.
name|maxbufsize
operator|=
name|MAXOUTLEN
expr_stmt|;
if|#
directive|if
literal|0
block|ssp.security_flags = SASL_SEC_NOPLAINTEXT;
endif|#
directive|endif
comment|/* 0 */
block|}
name|saslresult
operator|=
name|sasl_setprop
argument_list|(
name|mci
operator|->
name|mci_conn
argument_list|,
name|SASL_SEC_PROPS
argument_list|,
operator|&
name|ssp
argument_list|)
expr_stmt|;
if|if
condition|(
name|saslresult
operator|!=
name|SASL_OK
condition|)
return|return
name|EX_TEMPFAIL
return|;
if|#
directive|if
name|SASL
operator|>=
literal|20000
comment|/* external security strength factor, authentication id */
name|ssf
operator|=
literal|0
expr_stmt|;
name|auth_id
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|STARTTLS
name|out
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{cert_subject}"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|!=
name|NULL
operator|&&
operator|*
name|out
operator|!=
literal|'\0'
condition|)
name|auth_id
operator|=
name|out
expr_stmt|;
name|out
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{cipher_bits}"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|!=
name|NULL
operator|&&
operator|*
name|out
operator|!=
literal|'\0'
condition|)
name|ssf
operator|=
name|atoi
argument_list|(
name|out
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* STARTTLS */
name|saslresult
operator|=
name|sasl_setprop
argument_list|(
name|mci
operator|->
name|mci_conn
argument_list|,
name|SASL_SSF_EXTERNAL
argument_list|,
operator|&
name|ssf
argument_list|)
expr_stmt|;
if|if
condition|(
name|saslresult
operator|!=
name|SASL_OK
condition|)
return|return
name|EX_TEMPFAIL
return|;
name|saslresult
operator|=
name|sasl_setprop
argument_list|(
name|mci
operator|->
name|mci_conn
argument_list|,
name|SASL_AUTH_EXTERNAL
argument_list|,
name|auth_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|saslresult
operator|!=
name|SASL_OK
condition|)
return|return
name|EX_TEMPFAIL
return|;
if|#
directive|if
name|NETINET
operator|||
name|NETINET6
comment|/* set local/remote ipv4 addresses */
if|if
condition|(
name|mci
operator|->
name|mci_out
operator|!=
name|NULL
operator|&&
operator|(
if|#
directive|if
name|NETINET6
name|CurHostAddr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
operator|||
endif|#
directive|endif
comment|/* NETINET6 */
name|CurHostAddr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
operator|)
condition|)
block|{
name|SOCKADDR_LEN_T
name|addrsize
decl_stmt|;
name|SOCKADDR
name|saddr_l
decl_stmt|;
name|char
name|localip
index|[
literal|60
index|]
decl_stmt|,
name|remoteip
index|[
literal|60
index|]
decl_stmt|;
switch|switch
condition|(
name|CurHostAddr
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|addrsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|NETINET6
case|case
name|AF_INET6
case|:
name|addrsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NETINET6 */
default|default:
break|break;
block|}
if|if
condition|(
name|iptostring
argument_list|(
operator|&
name|CurHostAddr
argument_list|,
name|addrsize
argument_list|,
name|remoteip
argument_list|,
sizeof|sizeof
argument_list|(
name|remoteip
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|sasl_setprop
argument_list|(
name|mci
operator|->
name|mci_conn
argument_list|,
name|SASL_IPREMOTEPORT
argument_list|,
name|remoteip
argument_list|)
operator|!=
name|SASL_OK
condition|)
return|return
name|EX_TEMPFAIL
return|;
block|}
name|addrsize
operator|=
sizeof|sizeof
argument_list|(
name|saddr_l
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|sm_io_getinfo
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr_l
argument_list|,
operator|&
name|addrsize
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|iptostring
argument_list|(
operator|&
name|saddr_l
argument_list|,
name|addrsize
argument_list|,
name|localip
argument_list|,
sizeof|sizeof
argument_list|(
name|localip
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|sasl_setprop
argument_list|(
name|mci
operator|->
name|mci_conn
argument_list|,
name|SASL_IPLOCALPORT
argument_list|,
name|localip
argument_list|)
operator|!=
name|SASL_OK
condition|)
return|return
name|EX_TEMPFAIL
return|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* NETINET || NETINET6 */
comment|/* start client side of sasl */
name|saslresult
operator|=
name|sasl_client_start
argument_list|(
name|mci
operator|->
name|mci_conn
argument_list|,
name|mci
operator|->
name|mci_saslcap
argument_list|,
operator|&
name|client_interact
argument_list|,
operator|&
name|out
argument_list|,
operator|&
name|outlen
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|mechusing
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SASL>= 20000 */
comment|/* external security strength factor, authentication id */
name|ssf
operator|.
name|ssf
operator|=
literal|0
expr_stmt|;
name|ssf
operator|.
name|auth_id
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|STARTTLS
name|out
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{cert_subject}"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|!=
name|NULL
operator|&&
operator|*
name|out
operator|!=
literal|'\0'
condition|)
name|ssf
operator|.
name|auth_id
operator|=
name|out
expr_stmt|;
name|out
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{cipher_bits}"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|!=
name|NULL
operator|&&
operator|*
name|out
operator|!=
literal|'\0'
condition|)
name|ssf
operator|.
name|ssf
operator|=
name|atoi
argument_list|(
name|out
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* STARTTLS */
name|saslresult
operator|=
name|sasl_setprop
argument_list|(
name|mci
operator|->
name|mci_conn
argument_list|,
name|SASL_SSF_EXTERNAL
argument_list|,
operator|&
name|ssf
argument_list|)
expr_stmt|;
if|if
condition|(
name|saslresult
operator|!=
name|SASL_OK
condition|)
return|return
name|EX_TEMPFAIL
return|;
if|#
directive|if
name|NETINET
comment|/* set local/remote ipv4 addresses */
if|if
condition|(
name|mci
operator|->
name|mci_out
operator|!=
name|NULL
operator|&&
name|CurHostAddr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|SOCKADDR_LEN_T
name|addrsize
decl_stmt|;
name|struct
name|sockaddr_in
name|saddr_l
decl_stmt|;
if|if
condition|(
name|sasl_setprop
argument_list|(
name|mci
operator|->
name|mci_conn
argument_list|,
name|SASL_IP_REMOTE
argument_list|,
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|CurHostAddr
argument_list|)
operator|!=
name|SASL_OK
condition|)
return|return
name|EX_TEMPFAIL
return|;
name|addrsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|sm_io_getinfo
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saddr_l
argument_list|,
operator|&
name|addrsize
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sasl_setprop
argument_list|(
name|mci
operator|->
name|mci_conn
argument_list|,
name|SASL_IP_LOCAL
argument_list|,
operator|&
name|saddr_l
argument_list|)
operator|!=
name|SASL_OK
condition|)
return|return
name|EX_TEMPFAIL
return|;
block|}
block|}
endif|#
directive|endif
comment|/* NETINET */
comment|/* start client side of sasl */
name|saslresult
operator|=
name|sasl_client_start
argument_list|(
name|mci
operator|->
name|mci_conn
argument_list|,
name|mci
operator|->
name|mci_saslcap
argument_list|,
name|NULL
argument_list|,
operator|&
name|client_interact
argument_list|,
operator|&
name|out
argument_list|,
operator|&
name|outlen
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|mechusing
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SASL>= 20000 */
if|if
condition|(
name|saslresult
operator|!=
name|SASL_OK
operator|&&
name|saslresult
operator|!=
name|SASL_CONTINUE
condition|)
block|{
if|if
condition|(
name|saslresult
operator|==
name|SASL_NOMECH
operator|&&
name|LogLevel
operator|>
literal|8
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"AUTH=client, available mechanisms do not fulfill requirements"
argument_list|)
expr_stmt|;
block|}
return|return
name|EX_TEMPFAIL
return|;
block|}
comment|/* just point current mechanism to the data in the sasl library */
operator|(
operator|*
name|sai
operator|)
index|[
name|SASL_MECH
index|]
operator|=
name|mechusing
expr_stmt|;
comment|/* send the info across the wire */
if|if
condition|(
name|out
operator|==
name|NULL
comment|/* login and digest-md5 up to 1.5.28 set out="" */
operator|||
operator|(
name|outlen
operator|==
literal|0
operator|&&
operator|(
name|sm_strcasecmp
argument_list|(
name|mechusing
argument_list|,
literal|"LOGIN"
argument_list|)
operator|==
literal|0
operator|||
name|sm_strcasecmp
argument_list|(
name|mechusing
argument_list|,
literal|"DIGEST-MD5"
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* no initial response */
name|smtpmessage
argument_list|(
literal|"AUTH %s"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|mechusing
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|outlen
operator|==
literal|0
condition|)
block|{
comment|/* 		**  zero-length initial response, per RFC 2554 4.: 		**  "Unlike a zero-length client answer to a 334 reply, a zero- 		**  length initial response is sent as a single equals sign" 		*/
name|smtpmessage
argument_list|(
literal|"AUTH %s ="
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|mechusing
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|saslresult
operator|=
name|sasl_encode64
argument_list|(
name|out
argument_list|,
name|outlen
argument_list|,
name|in64
argument_list|,
name|MAXOUTLEN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|saslresult
operator|!=
name|SASL_OK
condition|)
comment|/* internal error */
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"encode64 for AUTH failed"
argument_list|)
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
name|smtpmessage
argument_list|(
literal|"AUTH %s %s"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|mechusing
argument_list|,
name|in64
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|SASL
operator|<
literal|20000
name|sm_sasl_free
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|/* XXX only if no rpool is used */
endif|#
directive|endif
comment|/* SASL< 20000 */
comment|/* get the reply */
name|smtpresult
operator|=
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|TimeOuts
operator|.
name|to_auth
argument_list|,
name|getsasldata
argument_list|,
name|NULL
argument_list|,
name|XS_AUTH
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* check return code from server */
if|if
condition|(
name|smtpresult
operator|==
literal|235
condition|)
block|{
name|macdefine
argument_list|(
operator|&
name|mci
operator|->
name|mci_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{auth_type}"
argument_list|)
argument_list|,
name|mechusing
argument_list|)
expr_stmt|;
return|return
name|EX_OK
return|;
block|}
if|if
condition|(
name|smtpresult
operator|==
operator|-
literal|1
condition|)
return|return
name|EX_IOERR
return|;
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|smtpresult
argument_list|)
operator|==
literal|5
condition|)
return|return
name|EX_NOPERM
return|;
comment|/* ugly, but ... */
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|smtpresult
argument_list|)
operator|!=
literal|3
condition|)
block|{
comment|/* should we fail deliberately, see RFC 2554 4. ? */
comment|/* smtpmessage("*", m, mci); */
return|return
name|EX_TEMPFAIL
return|;
block|}
name|saslresult
operator|=
name|sasl_client_step
argument_list|(
name|mci
operator|->
name|mci_conn
argument_list|,
name|mci
operator|->
name|mci_sasl_string
argument_list|,
name|mci
operator|->
name|mci_sasl_string_len
argument_list|,
operator|&
name|client_interact
argument_list|,
operator|&
name|out
argument_list|,
operator|&
name|outlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|saslresult
operator|!=
name|SASL_OK
operator|&&
name|saslresult
operator|!=
name|SASL_CONTINUE
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|95
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"AUTH FAIL=%s (%d)\n"
argument_list|,
name|sasl_errstring
argument_list|(
name|saslresult
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|saslresult
argument_list|)
expr_stmt|;
comment|/* fail deliberately, see RFC 2554 4. */
name|smtpmessage
argument_list|(
literal|"*"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|)
expr_stmt|;
comment|/* 			**  but we should only fail for this authentication 			**  mechanism; how to do that? 			*/
name|smtpresult
operator|=
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|TimeOuts
operator|.
name|to_auth
argument_list|,
name|getsasldata
argument_list|,
name|NULL
argument_list|,
name|XS_AUTH
argument_list|)
expr_stmt|;
return|return
name|EX_NOPERM
return|;
block|}
if|if
condition|(
name|outlen
operator|>
literal|0
condition|)
block|{
name|saslresult
operator|=
name|sasl_encode64
argument_list|(
name|out
argument_list|,
name|outlen
argument_list|,
name|in64
argument_list|,
name|MAXOUTLEN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|saslresult
operator|!=
name|SASL_OK
condition|)
block|{
comment|/* give an error reply to the other side! */
name|smtpmessage
argument_list|(
literal|"*"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|)
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
block|}
else|else
name|in64
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|#
directive|if
name|SASL
operator|<
literal|20000
name|sm_sasl_free
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|/* XXX only if no rpool is used */
endif|#
directive|endif
comment|/* SASL< 20000 */
name|smtpmessage
argument_list|(
literal|"%s"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|in64
argument_list|)
expr_stmt|;
name|smtpresult
operator|=
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|TimeOuts
operator|.
name|to_auth
argument_list|,
name|getsasldata
argument_list|,
name|NULL
argument_list|,
name|XS_AUTH
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* **  SMTPAUTH -- try to AUTHenticate ** **	This will try mechanisms in the order the sasl library decided until: **	- there are no more mechanisms **	- a mechanism succeeds **	- the sasl library fails initializing ** **	Parameters: **		m -- the mailer. **		mci -- the mailer connection info. **		e -- the envelope. ** **	Returns: **		EX_OK -- authentication was successful **		EX_UNAVAILABLE -- authentication not possible, e.g., **			no data available. **		EX_NOPERM -- authentication failed. **		EX_TEMPFAIL -- temporary failure. ** **	Notice: AuthInfo is used for all connections, hence we must **		return EX_TEMPFAIL only if we really want to retry, i.e., **		iff getauth() tempfailed or getauth() was used and **		authentication tempfailed. */
end_comment

begin_function
name|int
name|smtpauth
parameter_list|(
name|m
parameter_list|,
name|mci
parameter_list|,
name|e
parameter_list|)
name|MAILER
modifier|*
name|m
decl_stmt|;
name|MCI
modifier|*
name|mci
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bool
name|usedgetauth
decl_stmt|;
name|mci
operator|->
name|mci_sasl_auth
operator|=
name|false
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SASL_MECH
condition|;
name|i
operator|++
control|)
name|mci
operator|->
name|mci_sai
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|getauth
argument_list|(
name|mci
argument_list|,
name|e
argument_list|,
operator|&
operator|(
name|mci
operator|->
name|mci_sai
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|EX_TEMPFAIL
condition|)
return|return
name|result
return|;
name|usedgetauth
operator|=
name|true
expr_stmt|;
comment|/* no data available: don't try to authenticate */
if|if
condition|(
name|result
operator|==
name|EX_OK
operator|&&
name|mci
operator|->
name|mci_sai
index|[
name|SASL_AUTHID
index|]
operator|==
name|NULL
condition|)
return|return
name|result
return|;
if|if
condition|(
name|result
operator|!=
name|EX_OK
condition|)
block|{
if|if
condition|(
name|SASLInfo
operator|==
name|NULL
condition|)
return|return
name|EX_UNAVAILABLE
return|;
comment|/* read authinfo from file */
name|result
operator|=
name|readauth
argument_list|(
name|SASLInfo
argument_list|,
name|true
argument_list|,
operator|&
operator|(
name|mci
operator|->
name|mci_sai
operator|)
argument_list|,
name|mci
operator|->
name|mci_rpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|EX_OK
condition|)
return|return
name|result
return|;
name|usedgetauth
operator|=
name|false
expr_stmt|;
block|}
comment|/* check whether sufficient data is available */
if|if
condition|(
name|mci
operator|->
name|mci_sai
index|[
name|SASL_PASSWORD
index|]
operator|==
name|NULL
operator|||
operator|*
operator|(
name|mci
operator|->
name|mci_sai
operator|)
index|[
name|SASL_PASSWORD
index|]
operator|==
literal|'\0'
condition|)
return|return
name|EX_UNAVAILABLE
return|;
if|if
condition|(
operator|(
name|mci
operator|->
name|mci_sai
index|[
name|SASL_AUTHID
index|]
operator|==
name|NULL
operator|||
operator|*
operator|(
name|mci
operator|->
name|mci_sai
operator|)
index|[
name|SASL_AUTHID
index|]
operator|==
literal|'\0'
operator|)
operator|&&
operator|(
name|mci
operator|->
name|mci_sai
index|[
name|SASL_USER
index|]
operator|==
name|NULL
operator|||
operator|*
operator|(
name|mci
operator|->
name|mci_sai
operator|)
index|[
name|SASL_USER
index|]
operator|==
literal|'\0'
operator|)
condition|)
return|return
name|EX_UNAVAILABLE
return|;
comment|/* set the context for the callback function to sai */
if|#
directive|if
name|SASL
operator|>=
literal|20000
name|callbacks
index|[
name|CB_PASS_IDX
index|]
operator|.
name|context
operator|=
operator|(
name|void
operator|*
operator|)
name|mci
expr_stmt|;
else|#
directive|else
comment|/* SASL>= 20000 */
name|callbacks
index|[
name|CB_PASS_IDX
index|]
operator|.
name|context
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|mci
operator|->
name|mci_sai
expr_stmt|;
endif|#
directive|endif
comment|/* SASL>= 20000 */
name|callbacks
index|[
name|CB_USER_IDX
index|]
operator|.
name|context
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|mci
operator|->
name|mci_sai
expr_stmt|;
name|callbacks
index|[
name|CB_AUTHNAME_IDX
index|]
operator|.
name|context
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|mci
operator|->
name|mci_sai
expr_stmt|;
name|callbacks
index|[
name|CB_GETREALM_IDX
index|]
operator|.
name|context
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|mci
operator|->
name|mci_sai
expr_stmt|;
if|#
directive|if
literal|0
block|callbacks[CB_SAFESASL_IDX].context = (void *)&mci->mci_sai;
endif|#
directive|endif
comment|/* 0 */
comment|/* set default value for realm */
if|if
condition|(
operator|(
name|mci
operator|->
name|mci_sai
operator|)
index|[
name|SASL_DEFREALM
index|]
operator|==
name|NULL
condition|)
operator|(
name|mci
operator|->
name|mci_sai
operator|)
index|[
name|SASL_DEFREALM
index|]
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|macvalue
argument_list|(
literal|'j'
argument_list|,
name|CurEnv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set default value for list of mechanism to use */
if|if
condition|(
operator|(
name|mci
operator|->
name|mci_sai
operator|)
index|[
name|SASL_MECHLIST
index|]
operator|==
name|NULL
operator|||
operator|*
operator|(
name|mci
operator|->
name|mci_sai
operator|)
index|[
name|SASL_MECHLIST
index|]
operator|==
literal|'\0'
condition|)
operator|(
name|mci
operator|->
name|mci_sai
operator|)
index|[
name|SASL_MECHLIST
index|]
operator|=
name|AuthMechanisms
expr_stmt|;
comment|/* create list of mechanisms to try */
name|mci
operator|->
name|mci_saslcap
operator|=
name|intersect
argument_list|(
operator|(
name|mci
operator|->
name|mci_sai
operator|)
index|[
name|SASL_MECHLIST
index|]
argument_list|,
name|mci
operator|->
name|mci_saslcap
argument_list|,
name|mci
operator|->
name|mci_rpool
argument_list|)
expr_stmt|;
comment|/* initialize sasl client library */
name|result
operator|=
name|init_sasl_client
argument_list|()
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SASL_OK
condition|)
return|return
name|usedgetauth
condition|?
name|EX_TEMPFAIL
else|:
name|EX_UNAVAILABLE
return|;
do|do
block|{
name|result
operator|=
name|attemptauth
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
operator|&
operator|(
name|mci
operator|->
name|mci_sai
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|EX_OK
condition|)
name|mci
operator|->
name|mci_sasl_auth
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|result
operator|==
name|EX_TEMPFAIL
operator|||
name|result
operator|==
name|EX_NOPERM
condition|)
block|{
name|mci
operator|->
name|mci_saslcap
operator|=
name|removemech
argument_list|(
operator|(
name|mci
operator|->
name|mci_sai
operator|)
index|[
name|SASL_MECH
index|]
argument_list|,
name|mci
operator|->
name|mci_saslcap
argument_list|,
name|mci
operator|->
name|mci_rpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_saslcap
operator|==
name|NULL
operator|||
operator|*
operator|(
name|mci
operator|->
name|mci_saslcap
operator|)
operator|==
literal|'\0'
condition|)
return|return
name|usedgetauth
condition|?
name|result
else|:
name|EX_UNAVAILABLE
return|;
block|}
else|else
return|return
name|result
return|;
block|}
do|while
condition|(
name|result
operator|!=
name|EX_OK
condition|)
do|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SASL */
end_comment

begin_comment
comment|/* **  SMTPMAILFROM -- send MAIL command ** **	Parameters: **		m -- the mailer. **		mci -- the mailer connection structure. **		e -- the envelope (including the sender to specify). */
end_comment

begin_function
name|int
name|smtpmailfrom
parameter_list|(
name|m
parameter_list|,
name|mci
parameter_list|,
name|e
parameter_list|)
name|MAILER
modifier|*
name|m
decl_stmt|;
name|MCI
modifier|*
name|mci
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|r
decl_stmt|;
name|char
modifier|*
name|bufp
decl_stmt|;
name|char
modifier|*
name|bodytype
decl_stmt|;
name|char
modifier|*
name|enhsc
decl_stmt|;
name|char
name|buf
index|[
name|MAXNAME
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|optbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|18
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"smtpmailfrom: CurHost=%s\n"
argument_list|,
name|CurHostName
argument_list|)
expr_stmt|;
name|enhsc
operator|=
name|NULL
expr_stmt|;
comment|/* 	**  Check if connection is gone, if so 	**  it's a tempfail and we use mci_errno 	**  for the reason. 	*/
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|==
name|MCIS_CLOSED
condition|)
block|{
name|errno
operator|=
name|mci
operator|->
name|mci_errno
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
comment|/* set up appropriate options to include */
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_SIZE
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
operator|&&
name|e
operator|->
name|e_msgsize
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|optbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|optbuf
argument_list|)
argument_list|,
literal|" SIZE=%ld"
argument_list|,
name|e
operator|->
name|e_msgsize
argument_list|)
expr_stmt|;
name|bufp
operator|=
operator|&
name|optbuf
index|[
name|strlen
argument_list|(
name|optbuf
argument_list|)
index|]
expr_stmt|;
block|}
else|else
block|{
name|optbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|bufp
operator|=
name|optbuf
expr_stmt|;
block|}
name|bodytype
operator|=
name|e
operator|->
name|e_bodytype
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_8BITMIME
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|bodytype
operator|==
name|NULL
operator|&&
name|bitset
argument_list|(
name|MM_MIME8BIT
argument_list|,
name|MimeMode
argument_list|)
operator|&&
name|bitset
argument_list|(
name|EF_HAS8BIT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_DONT_MIME
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
operator|!
name|bitnset
argument_list|(
name|M_8BITS
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|bodytype
operator|=
literal|"8BITMIME"
expr_stmt|;
if|if
condition|(
name|bodytype
operator|!=
name|NULL
operator|&&
name|SPACELEFT
argument_list|(
name|optbuf
argument_list|,
name|bufp
argument_list|)
operator|>
name|strlen
argument_list|(
name|bodytype
argument_list|)
operator|+
literal|7
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|bufp
argument_list|,
name|SPACELEFT
argument_list|(
name|optbuf
argument_list|,
name|bufp
argument_list|)
argument_list|,
literal|" BODY=%s"
argument_list|,
name|bodytype
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|strlen
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|bitnset
argument_list|(
name|M_8BITS
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|||
operator|!
name|bitset
argument_list|(
name|EF_HAS8BIT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|||
name|bitset
argument_list|(
name|MCIF_8BITOK
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
block|{
comment|/* EMPTY */
comment|/* just pass it through */
block|}
if|#
directive|if
name|MIME8TO7
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|MM_CVTMIME
argument_list|,
name|MimeMode
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_DONT_MIME
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
operator|(
operator|!
name|bitset
argument_list|(
name|MM_PASS8BIT
argument_list|,
name|MimeMode
argument_list|)
operator|||
name|bitset
argument_list|(
name|EF_IS_MIME
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|)
condition|)
block|{
comment|/* must convert from 8bit MIME format to 7bit encoded */
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_CVT8TO7
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MIME8TO7 */
elseif|else
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|MM_PASS8BIT
argument_list|,
name|MimeMode
argument_list|)
condition|)
block|{
comment|/* cannot just send a 8-bit version */
specifier|extern
name|char
name|MsgBuf
index|[]
decl_stmt|;
name|usrerrenh
argument_list|(
literal|"5.6.3"
argument_list|,
literal|"%s does not support 8BITMIME"
argument_list|,
name|CurHostName
argument_list|)
expr_stmt|;
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_NOTSTICKY
argument_list|,
literal|"5.6.3"
argument_list|,
name|MsgBuf
argument_list|)
expr_stmt|;
return|return
name|EX_DATAERR
return|;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_DSN
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|e_envid
operator|!=
name|NULL
operator|&&
name|SPACELEFT
argument_list|(
name|optbuf
argument_list|,
name|bufp
argument_list|)
operator|>
name|strlen
argument_list|(
name|e
operator|->
name|e_envid
argument_list|)
operator|+
literal|7
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|bufp
argument_list|,
name|SPACELEFT
argument_list|(
name|optbuf
argument_list|,
name|bufp
argument_list|)
argument_list|,
literal|" ENVID=%s"
argument_list|,
name|e
operator|->
name|e_envid
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|strlen
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
block|}
comment|/* RET= parameter */
if|if
condition|(
name|bitset
argument_list|(
name|EF_RET_PARAM
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
name|SPACELEFT
argument_list|(
name|optbuf
argument_list|,
name|bufp
argument_list|)
operator|>
literal|9
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|bufp
argument_list|,
name|SPACELEFT
argument_list|(
name|optbuf
argument_list|,
name|bufp
argument_list|)
argument_list|,
literal|" RET=%s"
argument_list|,
name|bitset
argument_list|(
name|EF_NO_BODY_RETN
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|?
literal|"HDRS"
else|:
literal|"FULL"
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|strlen
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_AUTH
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
operator|&&
name|e
operator|->
name|e_auth_param
operator|!=
name|NULL
operator|&&
name|SPACELEFT
argument_list|(
name|optbuf
argument_list|,
name|bufp
argument_list|)
operator|>
name|strlen
argument_list|(
name|e
operator|->
name|e_auth_param
argument_list|)
operator|+
literal|7
if|#
directive|if
name|SASL
operator|&&
operator|(
operator|!
name|bitset
argument_list|(
name|SASL_AUTH_AUTH
argument_list|,
name|SASLOpts
argument_list|)
operator|||
name|mci
operator|->
name|mci_sasl_auth
operator|)
endif|#
directive|endif
comment|/* SASL */
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|bufp
argument_list|,
name|SPACELEFT
argument_list|(
name|optbuf
argument_list|,
name|bufp
argument_list|)
argument_list|,
literal|" AUTH=%s"
argument_list|,
name|e
operator|->
name|e_auth_param
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|strlen
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  17 is the max length required, we could use log() to compute 	**  the exact length (and check IS_DLVR_TRACE()) 	*/
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_DLVR_BY
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
operator|&&
name|IS_DLVR_BY
argument_list|(
name|e
argument_list|)
operator|&&
name|SPACELEFT
argument_list|(
name|optbuf
argument_list|,
name|bufp
argument_list|)
operator|>
literal|17
condition|)
block|{
name|long
name|dby
decl_stmt|;
comment|/* 		**  Avoid problems with delays (for R) since the check 		**  in deliver() whether min-deliver-time is sufficient. 		**  Alternatively we could pass the computed time to this 		**  function. 		*/
name|dby
operator|=
name|e
operator|->
name|e_deliver_by
operator|-
operator|(
name|curtime
argument_list|()
operator|-
name|e
operator|->
name|e_ctime
operator|)
expr_stmt|;
if|if
condition|(
name|dby
operator|<=
literal|0
operator|&&
name|IS_DLVR_RETURN
argument_list|(
name|e
argument_list|)
condition|)
name|dby
operator|=
name|mci
operator|->
name|mci_min_by
operator|<=
literal|0
condition|?
literal|1
else|:
name|mci
operator|->
name|mci_min_by
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|bufp
argument_list|,
name|SPACELEFT
argument_list|(
name|optbuf
argument_list|,
name|bufp
argument_list|)
argument_list|,
literal|" BY=%ld;%c%s"
argument_list|,
name|dby
argument_list|,
name|IS_DLVR_RETURN
argument_list|(
name|e
argument_list|)
condition|?
literal|'R'
else|:
literal|'N'
argument_list|,
name|IS_DLVR_TRACE
argument_list|(
name|e
argument_list|)
condition|?
literal|"T"
else|:
literal|""
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|strlen
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Send the MAIL command. 	**	Designates the sender. 	*/
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_MAIL
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|EF_RESPONSE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
operator|!
name|bitnset
argument_list|(
name|M_NO_NULL_FROM
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|expand
argument_list|(
literal|"\201g"
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'<'
condition|)
block|{
comment|/* strip off<angle brackets> (put back on below) */
name|bufp
operator|=
operator|&
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|bufp
operator|==
literal|'>'
condition|)
operator|*
name|bufp
operator|=
literal|'\0'
expr_stmt|;
name|bufp
operator|=
operator|&
name|buf
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
name|bufp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|bitnset
argument_list|(
name|M_LOCALMAILER
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|->
name|m_flags
argument_list|)
operator|||
operator|!
name|bitnset
argument_list|(
name|M_FROMPATH
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
name|smtpmessage
argument_list|(
literal|"MAIL From:<%s>%s"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|bufp
argument_list|,
name|optbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|smtpmessage
argument_list|(
literal|"MAIL From:<@%s%c%s>%s"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|MyHostName
argument_list|,
operator|*
name|bufp
operator|==
literal|'@'
condition|?
literal|','
else|:
literal|':'
argument_list|,
name|bufp
argument_list|,
name|optbuf
argument_list|)
expr_stmt|;
block|}
name|SmtpPhase
operator|=
name|mci
operator|->
name|mci_phase
operator|=
literal|"client MAIL"
expr_stmt|;
name|sm_setproctitle
argument_list|(
name|true
argument_list|,
name|e
argument_list|,
literal|"%s %s: %s"
argument_list|,
name|qid_printname
argument_list|(
name|e
argument_list|)
argument_list|,
name|CurHostName
argument_list|,
name|mci
operator|->
name|mci_phase
argument_list|)
expr_stmt|;
name|r
operator|=
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|TimeOuts
operator|.
name|to_mail
argument_list|,
name|NULL
argument_list|,
operator|&
name|enhsc
argument_list|,
name|XS_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
comment|/* communications failure */
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_TEMPFAIL
argument_list|,
literal|"4.4.2"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
name|SMTPCLOSING
condition|)
block|{
comment|/* service shutting down: handled by reply() */
return|return
name|EX_TEMPFAIL
return|;
block|}
elseif|else
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|4
condition|)
block|{
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_NOTSTICKY
argument_list|,
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
name|smtptodsn
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|,
name|SmtpReplyBuffer
argument_list|)
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
elseif|else
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|2
condition|)
block|{
return|return
name|EX_OK
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
literal|501
condition|)
block|{
comment|/* syntax error in arguments */
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_NOTSTICKY
argument_list|,
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
literal|"5.5.2"
argument_list|)
argument_list|,
name|SmtpReplyBuffer
argument_list|)
expr_stmt|;
return|return
name|EX_DATAERR
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
literal|553
condition|)
block|{
comment|/* mailbox name not allowed */
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_NOTSTICKY
argument_list|,
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
literal|"5.1.3"
argument_list|)
argument_list|,
name|SmtpReplyBuffer
argument_list|)
expr_stmt|;
return|return
name|EX_DATAERR
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
literal|552
condition|)
block|{
comment|/* exceeded storage allocation */
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_NOTSTICKY
argument_list|,
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
literal|"5.3.4"
argument_list|)
argument_list|,
name|SmtpReplyBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_SIZE
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
name|e
operator|->
name|e_flags
operator||=
name|EF_NO_BODY_RETN
expr_stmt|;
return|return
name|EX_UNAVAILABLE
return|;
block|}
elseif|else
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|5
condition|)
block|{
comment|/* unknown error */
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_NOTSTICKY
argument_list|,
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
literal|"5.0.0"
argument_list|)
argument_list|,
name|SmtpReplyBuffer
argument_list|)
expr_stmt|;
return|return
name|EX_UNAVAILABLE
return|;
block|}
if|if
condition|(
name|LogLevel
operator|>
literal|1
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_CRIT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%.100s: SMTP MAIL protocol error: %s"
argument_list|,
name|CurHostName
argument_list|,
name|shortenstring
argument_list|(
name|SmtpReplyBuffer
argument_list|,
literal|403
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* protocol error -- close up */
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_PROTOCOL
argument_list|,
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
literal|"5.5.1"
argument_list|)
argument_list|,
name|SmtpReplyBuffer
argument_list|)
expr_stmt|;
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|EX_PROTOCOL
return|;
block|}
end_function

begin_comment
comment|/* **  SMTPRCPT -- designate recipient. ** **	Parameters: **		to -- address of recipient. **		m -- the mailer we are sending to. **		mci -- the connection info for this transaction. **		e -- the envelope for this transaction. ** **	Returns: **		exit status corresponding to recipient status. ** **	Side Effects: **		Sends the mail via SMTP. */
end_comment

begin_function
name|int
name|smtprcpt
parameter_list|(
name|to
parameter_list|,
name|m
parameter_list|,
name|mci
parameter_list|,
name|e
parameter_list|,
name|ctladdr
parameter_list|,
name|xstart
parameter_list|)
name|ADDRESS
modifier|*
name|to
decl_stmt|;
specifier|register
name|MAILER
modifier|*
name|m
decl_stmt|;
name|MCI
modifier|*
name|mci
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|ADDRESS
modifier|*
name|ctladdr
decl_stmt|;
name|time_t
name|xstart
decl_stmt|;
block|{
name|char
modifier|*
name|bufp
decl_stmt|;
name|char
name|optbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
if|#
directive|if
name|PIPELINING
comment|/* 	**  If there is status waiting from the other end, read it. 	**  This should normally happen because of SMTP pipelining. 	*/
while|while
condition|(
name|mci
operator|->
name|mci_nextaddr
operator|!=
name|NULL
operator|&&
name|sm_io_getinfo
argument_list|(
name|mci
operator|->
name|mci_in
argument_list|,
name|SM_IO_IS_READABLE
argument_list|,
name|NULL
argument_list|)
operator|>
literal|0
condition|)
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
name|smtprcptstat
argument_list|(
name|mci
operator|->
name|mci_nextaddr
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|EX_OK
condition|)
block|{
name|markfailure
argument_list|(
name|e
argument_list|,
name|mci
operator|->
name|mci_nextaddr
argument_list|,
name|mci
argument_list|,
name|r
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|giveresponse
argument_list|(
name|r
argument_list|,
name|mci
operator|->
name|mci_nextaddr
operator|->
name|q_status
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|ctladdr
argument_list|,
name|xstart
argument_list|,
name|e
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
name|mci
operator|->
name|mci_nextaddr
operator|=
name|mci
operator|->
name|mci_nextaddr
operator|->
name|q_pchain
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PIPELINING */
comment|/* 	**  Check if connection is gone, if so 	**  it's a tempfail and we use mci_errno 	**  for the reason. 	*/
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|==
name|MCIS_CLOSED
condition|)
block|{
name|errno
operator|=
name|mci
operator|->
name|mci_errno
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
name|optbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|bufp
operator|=
name|optbuf
expr_stmt|;
comment|/* 	**  Warning: in the following it is assumed that the free space 	**  in bufp is sizeof(optbuf) 	*/
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_DSN
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_DLVR_NOTIFY
argument_list|(
name|e
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|MCIF_DLVR_BY
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
block|{
comment|/* RFC 2852: 4.1.4.2 */
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QHASNOTIFY
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
condition|)
name|to
operator|->
name|q_flags
operator||=
name|QPINGONFAILURE
operator||
name|QPINGONDELAY
operator||
name|QHASNOTIFY
expr_stmt|;
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|QPINGONSUCCESS
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
operator|||
name|bitset
argument_list|(
name|QPINGONFAILURE
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
operator|||
name|bitset
argument_list|(
name|QPINGONDELAY
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
condition|)
name|to
operator|->
name|q_flags
operator||=
name|QPINGONDELAY
expr_stmt|;
block|}
comment|/* NOTIFY= parameter */
if|if
condition|(
name|bitset
argument_list|(
name|QHASNOTIFY
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
operator|&&
name|bitset
argument_list|(
name|QPRIMARY
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
operator|&&
operator|!
name|bitnset
argument_list|(
name|M_LOCALMAILER
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
name|bool
name|firstone
init|=
name|true
decl_stmt|;
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|bufp
argument_list|,
literal|" NOTIFY="
argument_list|,
sizeof|sizeof
argument_list|(
name|optbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|QPINGONSUCCESS
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|bufp
argument_list|,
literal|"SUCCESS"
argument_list|,
sizeof|sizeof
argument_list|(
name|optbuf
argument_list|)
argument_list|)
expr_stmt|;
name|firstone
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|QPINGONFAILURE
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|firstone
condition|)
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|bufp
argument_list|,
literal|","
argument_list|,
sizeof|sizeof
argument_list|(
name|optbuf
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|bufp
argument_list|,
literal|"FAILURE"
argument_list|,
sizeof|sizeof
argument_list|(
name|optbuf
argument_list|)
argument_list|)
expr_stmt|;
name|firstone
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|QPINGONDELAY
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|firstone
condition|)
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|bufp
argument_list|,
literal|","
argument_list|,
sizeof|sizeof
argument_list|(
name|optbuf
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|bufp
argument_list|,
literal|"DELAY"
argument_list|,
sizeof|sizeof
argument_list|(
name|optbuf
argument_list|)
argument_list|)
expr_stmt|;
name|firstone
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|firstone
condition|)
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|bufp
argument_list|,
literal|"NEVER"
argument_list|,
sizeof|sizeof
argument_list|(
name|optbuf
argument_list|)
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|strlen
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
block|}
comment|/* ORCPT= parameter */
if|if
condition|(
name|to
operator|->
name|q_orcpt
operator|!=
name|NULL
operator|&&
name|SPACELEFT
argument_list|(
name|optbuf
argument_list|,
name|bufp
argument_list|)
operator|>
name|strlen
argument_list|(
name|to
operator|->
name|q_orcpt
argument_list|)
operator|+
literal|7
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|bufp
argument_list|,
name|SPACELEFT
argument_list|(
name|optbuf
argument_list|,
name|bufp
argument_list|)
argument_list|,
literal|" ORCPT=%s"
argument_list|,
name|to
operator|->
name|q_orcpt
argument_list|)
expr_stmt|;
name|bufp
operator|+=
name|strlen
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
block|}
block|}
name|smtpmessage
argument_list|(
literal|"RCPT To:<%s>%s"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|to
operator|->
name|q_user
argument_list|,
name|optbuf
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_RCPT
expr_stmt|;
name|SmtpPhase
operator|=
name|mci
operator|->
name|mci_phase
operator|=
literal|"client RCPT"
expr_stmt|;
name|sm_setproctitle
argument_list|(
name|true
argument_list|,
name|e
argument_list|,
literal|"%s %s: %s"
argument_list|,
name|qid_printname
argument_list|(
name|e
argument_list|)
argument_list|,
name|CurHostName
argument_list|,
name|mci
operator|->
name|mci_phase
argument_list|)
expr_stmt|;
if|#
directive|if
name|PIPELINING
comment|/* 	**  If running SMTP pipelining, we will pick up status later 	*/
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_PIPELINED
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
return|return
name|EX_OK
return|;
endif|#
directive|endif
comment|/* PIPELINING */
return|return
name|smtprcptstat
argument_list|(
name|to
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  SMTPRCPTSTAT -- get recipient status ** **	This is only called during SMTP pipelining ** **	Parameters: **		to -- address of recipient. **		m -- mailer being sent to. **		mci -- the mailer connection information. **		e -- the envelope for this message. ** **	Returns: **		EX_* -- protocol status */
end_comment

begin_function
specifier|static
name|int
name|smtprcptstat
parameter_list|(
name|to
parameter_list|,
name|m
parameter_list|,
name|mci
parameter_list|,
name|e
parameter_list|)
name|ADDRESS
modifier|*
name|to
decl_stmt|;
name|MAILER
modifier|*
name|m
decl_stmt|;
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|r
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
name|char
modifier|*
name|enhsc
decl_stmt|;
comment|/* 	**  Check if connection is gone, if so 	**  it's a tempfail and we use mci_errno 	**  for the reason. 	*/
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|==
name|MCIS_CLOSED
condition|)
block|{
name|errno
operator|=
name|mci
operator|->
name|mci_errno
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
name|enhsc
operator|=
name|NULL
expr_stmt|;
name|r
operator|=
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|TimeOuts
operator|.
name|to_rcpt
argument_list|,
name|NULL
argument_list|,
operator|&
name|enhsc
argument_list|,
name|XS_DEFAULT
argument_list|)
expr_stmt|;
name|save_errno
operator|=
name|errno
expr_stmt|;
name|to
operator|->
name|q_rstatus
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|SmtpReplyBuffer
argument_list|)
expr_stmt|;
name|to
operator|->
name|q_status
operator|=
name|ENHSCN_RPOOL
argument_list|(
name|enhsc
argument_list|,
name|smtptodsn
argument_list|(
name|r
argument_list|)
argument_list|,
name|e
operator|->
name|e_rpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|M_LMTP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|to
operator|->
name|q_statmta
operator|=
name|mci
operator|->
name|mci_host
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
operator|||
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|4
condition|)
block|{
name|mci
operator|->
name|mci_retryrcpt
operator|=
name|true
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
elseif|else
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|2
condition|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|mci
operator|->
name|mci_tolist
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
operator|*
name|t
operator|++
operator|=
literal|','
expr_stmt|;
for|for
control|(
name|p
operator|=
name|to
operator|->
name|q_paddr
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|*
name|t
operator|++
operator|=
operator|*
name|p
operator|++
control|)
continue|continue;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
name|mci
operator|->
name|mci_tolist
operator|=
name|t
expr_stmt|;
block|}
if|#
directive|if
name|PIPELINING
name|mci
operator|->
name|mci_okrcpts
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* PIPELINING */
return|return
name|EX_OK
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
literal|550
condition|)
block|{
name|to
operator|->
name|q_status
operator|=
name|ENHSCN_RPOOL
argument_list|(
name|enhsc
argument_list|,
literal|"5.1.1"
argument_list|,
name|e
operator|->
name|e_rpool
argument_list|)
expr_stmt|;
return|return
name|EX_NOUSER
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
literal|551
condition|)
block|{
name|to
operator|->
name|q_status
operator|=
name|ENHSCN_RPOOL
argument_list|(
name|enhsc
argument_list|,
literal|"5.1.6"
argument_list|,
name|e
operator|->
name|e_rpool
argument_list|)
expr_stmt|;
return|return
name|EX_NOUSER
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
literal|553
condition|)
block|{
name|to
operator|->
name|q_status
operator|=
name|ENHSCN_RPOOL
argument_list|(
name|enhsc
argument_list|,
literal|"5.1.3"
argument_list|,
name|e
operator|->
name|e_rpool
argument_list|)
expr_stmt|;
return|return
name|EX_NOUSER
return|;
block|}
elseif|else
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|5
condition|)
block|{
return|return
name|EX_UNAVAILABLE
return|;
block|}
if|if
condition|(
name|LogLevel
operator|>
literal|1
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_CRIT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%.100s: SMTP RCPT protocol error: %s"
argument_list|,
name|CurHostName
argument_list|,
name|shortenstring
argument_list|(
name|SmtpReplyBuffer
argument_list|,
literal|403
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_PROTOCOL
argument_list|,
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
literal|"5.5.1"
argument_list|)
argument_list|,
name|SmtpReplyBuffer
argument_list|)
expr_stmt|;
return|return
name|EX_PROTOCOL
return|;
block|}
end_function

begin_comment
comment|/* **  SMTPDATA -- send the data and clean up the transaction. ** **	Parameters: **		m -- mailer being sent to. **		mci -- the mailer connection information. **		e -- the envelope for this message. ** **	Returns: **		exit status corresponding to DATA command. */
end_comment

begin_function
name|int
name|smtpdata
parameter_list|(
name|m
parameter_list|,
name|mci
parameter_list|,
name|e
parameter_list|,
name|ctladdr
parameter_list|,
name|xstart
parameter_list|)
name|MAILER
modifier|*
name|m
decl_stmt|;
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|ADDRESS
modifier|*
name|ctladdr
decl_stmt|;
name|time_t
name|xstart
decl_stmt|;
block|{
specifier|register
name|int
name|r
decl_stmt|;
name|int
name|rstat
decl_stmt|;
name|int
name|xstat
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|char
modifier|*
name|enhsc
decl_stmt|;
comment|/* 	**  Check if connection is gone, if so 	**  it's a tempfail and we use mci_errno 	**  for the reason. 	*/
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|==
name|MCIS_CLOSED
condition|)
block|{
name|errno
operator|=
name|mci
operator|->
name|mci_errno
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
name|enhsc
operator|=
name|NULL
expr_stmt|;
comment|/* 	**  Send the data. 	**	First send the command and check that it is ok. 	**	Then send the data (if there are valid recipients). 	**	Follow it up with a dot to terminate. 	**	Finally get the results of the transaction. 	*/
comment|/* send the command and check ok to proceed */
name|smtpmessage
argument_list|(
literal|"DATA"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|)
expr_stmt|;
if|#
directive|if
name|PIPELINING
if|if
condition|(
name|mci
operator|->
name|mci_nextaddr
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|oldto
init|=
name|e
operator|->
name|e_to
decl_stmt|;
comment|/* pick up any pending RCPT responses for SMTP pipelining */
while|while
condition|(
name|mci
operator|->
name|mci_nextaddr
operator|!=
name|NULL
condition|)
block|{
name|int
name|r
decl_stmt|;
name|e
operator|->
name|e_to
operator|=
name|mci
operator|->
name|mci_nextaddr
operator|->
name|q_paddr
expr_stmt|;
name|r
operator|=
name|smtprcptstat
argument_list|(
name|mci
operator|->
name|mci_nextaddr
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|EX_OK
condition|)
block|{
name|markfailure
argument_list|(
name|e
argument_list|,
name|mci
operator|->
name|mci_nextaddr
argument_list|,
name|mci
argument_list|,
name|r
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|giveresponse
argument_list|(
name|r
argument_list|,
name|mci
operator|->
name|mci_nextaddr
operator|->
name|q_status
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|ctladdr
argument_list|,
name|xstart
argument_list|,
name|e
argument_list|,
name|mci
operator|->
name|mci_nextaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|EX_TEMPFAIL
condition|)
name|mci
operator|->
name|mci_nextaddr
operator|->
name|q_state
operator|=
name|QS_RETRY
expr_stmt|;
block|}
name|mci
operator|->
name|mci_nextaddr
operator|=
name|mci
operator|->
name|mci_nextaddr
operator|->
name|q_pchain
expr_stmt|;
block|}
name|e
operator|->
name|e_to
operator|=
name|oldto
expr_stmt|;
comment|/* 		**  Connection might be closed in response to a RCPT command, 		**  i.e., the server responded with 421. In that case (at 		**  least) one RCPT has a temporary failure, hence we don't 		**  need to check mci_okrcpts (as it is done below) to figure 		**  out which error to return. 		*/
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|==
name|MCIS_CLOSED
condition|)
block|{
name|errno
operator|=
name|mci
operator|->
name|mci_errno
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
block|}
endif|#
directive|endif
comment|/* PIPELINING */
comment|/* now proceed with DATA phase */
name|SmtpPhase
operator|=
name|mci
operator|->
name|mci_phase
operator|=
literal|"client DATA 354"
expr_stmt|;
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_DATA
expr_stmt|;
name|sm_setproctitle
argument_list|(
name|true
argument_list|,
name|e
argument_list|,
literal|"%s %s: %s"
argument_list|,
name|qid_printname
argument_list|(
name|e
argument_list|)
argument_list|,
name|CurHostName
argument_list|,
name|mci
operator|->
name|mci_phase
argument_list|)
expr_stmt|;
name|r
operator|=
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|TimeOuts
operator|.
name|to_datainit
argument_list|,
name|NULL
argument_list|,
operator|&
name|enhsc
argument_list|,
name|XS_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
operator|||
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|r
operator|>=
literal|0
condition|)
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|errno
operator|=
name|mci
operator|->
name|mci_errno
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
elseif|else
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|5
condition|)
block|{
name|smtprset
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|#
directive|if
name|PIPELINING
if|if
condition|(
name|mci
operator|->
name|mci_okrcpts
operator|<=
literal|0
condition|)
return|return
name|mci
operator|->
name|mci_retryrcpt
condition|?
name|EX_TEMPFAIL
else|:
name|EX_UNAVAILABLE
return|;
endif|#
directive|endif
comment|/* PIPELINING */
return|return
name|EX_UNAVAILABLE
return|;
block|}
elseif|else
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|!=
literal|3
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|1
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_CRIT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%.100s: SMTP DATA-1 protocol error: %s"
argument_list|,
name|CurHostName
argument_list|,
name|shortenstring
argument_list|(
name|SmtpReplyBuffer
argument_list|,
literal|403
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|smtprset
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_PROTOCOL
argument_list|,
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
literal|"5.5.1"
argument_list|)
argument_list|,
name|SmtpReplyBuffer
argument_list|)
expr_stmt|;
if|#
directive|if
name|PIPELINING
if|if
condition|(
name|mci
operator|->
name|mci_okrcpts
operator|<=
literal|0
condition|)
return|return
name|mci
operator|->
name|mci_retryrcpt
condition|?
name|EX_TEMPFAIL
else|:
name|EX_PROTOCOL
return|;
endif|#
directive|endif
comment|/* PIPELINING */
return|return
name|EX_PROTOCOL
return|;
block|}
if|#
directive|if
name|PIPELINING
if|if
condition|(
name|mci
operator|->
name|mci_okrcpts
operator|>
literal|0
condition|)
block|{
endif|#
directive|endif
comment|/* PIPELINING */
comment|/* 	**  Set timeout around data writes.  Make it at least large 	**  enough for DNS timeouts on all recipients plus some fudge 	**  factor.  The main thing is that it should not be infinite. 	*/
if|if
condition|(
name|tTd
argument_list|(
literal|18
argument_list|,
literal|101
argument_list|)
condition|)
block|{
comment|/* simulate a DATA timeout */
name|timeout
operator|=
literal|10
expr_stmt|;
block|}
else|else
name|timeout
operator|=
name|DATA_PROGRESS_TIMEOUT
operator|*
literal|1000
expr_stmt|;
name|sm_io_setinfo
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
name|SM_IO_WHAT_TIMEOUT
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
comment|/* 	**  Output the actual message. 	*/
if|if
condition|(
operator|!
call|(
modifier|*
name|e
operator|->
name|e_puthdr
call|)
argument_list|(
name|mci
argument_list|,
name|e
operator|->
name|e_header
argument_list|,
name|e
argument_list|,
name|M87F_OUTER
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
if|if
condition|(
name|tTd
argument_list|(
literal|18
argument_list|,
literal|101
argument_list|)
condition|)
block|{
comment|/* simulate a DATA timeout */
operator|(
name|void
operator|)
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
call|(
modifier|*
name|e
operator|->
name|e_putbody
call|)
argument_list|(
name|mci
argument_list|,
name|e
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
comment|/* 	**  Cleanup after sending message. 	*/
if|#
directive|if
name|PIPELINING
block|}
endif|#
directive|endif
comment|/* PIPELINING */
if|#
directive|if
name|_FFR_CATCH_BROKEN_MTAS
if|if
condition|(
name|sm_io_getinfo
argument_list|(
name|mci
operator|->
name|mci_in
argument_list|,
name|SM_IO_IS_READABLE
argument_list|,
name|NULL
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* terminate the message */
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|".%s"
argument_list|,
name|m
operator|->
name|m_eol
argument_list|)
expr_stmt|;
if|if
condition|(
name|TrafficLogFile
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|TrafficLogFile
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%05d>>> .\n"
argument_list|,
operator|(
name|int
operator|)
name|CurrentPid
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|nmessage
argument_list|(
literal|">>> ."
argument_list|)
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_CRIT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%.100s: SMTP DATA-1 protocol error: remote server returned response before final dot"
argument_list|,
name|CurHostName
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_errno
operator|=
name|EIO
expr_stmt|;
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_ERROR
expr_stmt|;
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_PROTOCOL
argument_list|,
literal|"5.5.0"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|EX_PROTOCOL
return|;
block|}
endif|#
directive|endif
comment|/* _FFR_CATCH_BROKEN_MTAS */
if|if
condition|(
name|sm_io_error
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|)
condition|)
block|{
comment|/* error during processing -- don't send the dot */
name|mci
operator|->
name|mci_errno
operator|=
name|EIO
expr_stmt|;
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_ERROR
expr_stmt|;
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_IOERR
argument_list|,
literal|"4.4.2"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|EX_IOERR
return|;
block|}
comment|/* terminate the message */
if|if
condition|(
name|sm_io_fprintf
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|".%s"
argument_list|,
name|m
operator|->
name|m_eol
argument_list|)
operator|==
name|SM_IO_EOF
condition|)
goto|goto
name|writeerr
goto|;
if|if
condition|(
name|TrafficLogFile
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|TrafficLogFile
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%05d>>> .\n"
argument_list|,
operator|(
name|int
operator|)
name|CurrentPid
argument_list|)
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|nmessage
argument_list|(
literal|">>> ."
argument_list|)
expr_stmt|;
comment|/* check for the results of the transaction */
name|SmtpPhase
operator|=
name|mci
operator|->
name|mci_phase
operator|=
literal|"client DATA status"
expr_stmt|;
name|sm_setproctitle
argument_list|(
name|true
argument_list|,
name|e
argument_list|,
literal|"%s %s: %s"
argument_list|,
name|qid_printname
argument_list|(
name|e
argument_list|)
argument_list|,
name|CurHostName
argument_list|,
name|mci
operator|->
name|mci_phase
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitnset
argument_list|(
name|M_LMTP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
return|return
name|EX_OK
return|;
name|r
operator|=
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|TimeOuts
operator|.
name|to_datafinal
argument_list|,
name|NULL
argument_list|,
operator|&
name|enhsc
argument_list|,
name|XS_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
name|EX_TEMPFAIL
return|;
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|==
name|MCIS_DATA
condition|)
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_OPEN
expr_stmt|;
name|xstat
operator|=
name|EX_NOTSTICKY
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|452
condition|)
name|rstat
operator|=
name|EX_TEMPFAIL
expr_stmt|;
elseif|else
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|4
condition|)
name|rstat
operator|=
name|xstat
operator|=
name|EX_TEMPFAIL
expr_stmt|;
elseif|else
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|2
condition|)
name|rstat
operator|=
name|xstat
operator|=
name|EX_OK
expr_stmt|;
elseif|else
if|if
condition|(
name|REPLYCLASS
argument_list|(
name|r
argument_list|)
operator|!=
literal|5
condition|)
name|rstat
operator|=
name|xstat
operator|=
name|EX_PROTOCOL
expr_stmt|;
elseif|else
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|5
condition|)
name|rstat
operator|=
name|EX_UNAVAILABLE
expr_stmt|;
else|else
name|rstat
operator|=
name|EX_PROTOCOL
expr_stmt|;
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|xstat
argument_list|,
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
name|smtptodsn
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|,
name|SmtpReplyBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_ENHSTAT
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
operator|&&
operator|(
name|r
operator|=
name|isenhsc
argument_list|(
name|SmtpReplyBuffer
operator|+
literal|4
argument_list|,
literal|' '
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|r
operator|+=
literal|5
expr_stmt|;
else|else
name|r
operator|=
literal|4
expr_stmt|;
name|e
operator|->
name|e_statmsg
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
operator|&
name|SmtpReplyBuffer
index|[
name|r
index|]
argument_list|)
expr_stmt|;
name|SmtpPhase
operator|=
name|mci
operator|->
name|mci_phase
operator|=
literal|"idle"
expr_stmt|;
name|sm_setproctitle
argument_list|(
name|true
argument_list|,
name|e
argument_list|,
literal|"%s: %s"
argument_list|,
name|CurHostName
argument_list|,
name|mci
operator|->
name|mci_phase
argument_list|)
expr_stmt|;
if|if
condition|(
name|rstat
operator|!=
name|EX_PROTOCOL
condition|)
return|return
name|rstat
return|;
if|if
condition|(
name|LogLevel
operator|>
literal|1
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_CRIT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%.100s: SMTP DATA-2 protocol error: %s"
argument_list|,
name|CurHostName
argument_list|,
name|shortenstring
argument_list|(
name|SmtpReplyBuffer
argument_list|,
literal|403
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rstat
return|;
name|writeerr
label|:
name|mci
operator|->
name|mci_errno
operator|=
name|errno
expr_stmt|;
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_ERROR
expr_stmt|;
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_TEMPFAIL
argument_list|,
literal|"4.4.2"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	**  If putbody() couldn't finish due to a timeout, 	**  rewind it here in the timeout handler.  See 	**  comments at the end of putbody() for reasoning. 	*/
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|bfrewind
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|mci
operator|->
name|mci_errno
expr_stmt|;
name|syserr
argument_list|(
literal|"451 4.4.1 timeout writing message to %s"
argument_list|,
name|CurHostName
argument_list|)
expr_stmt|;
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
end_function

begin_comment
comment|/* **  SMTPGETSTAT -- get status code from DATA in LMTP ** **	Parameters: **		m -- the mailer to which we are sending the message. **		mci -- the mailer connection structure. **		e -- the current envelope. ** **	Returns: **		The exit status corresponding to the reply code. */
end_comment

begin_function
name|int
name|smtpgetstat
parameter_list|(
name|m
parameter_list|,
name|mci
parameter_list|,
name|e
parameter_list|)
name|MAILER
modifier|*
name|m
decl_stmt|;
name|MCI
modifier|*
name|mci
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|r
decl_stmt|;
name|int
name|off
decl_stmt|;
name|int
name|status
decl_stmt|,
name|xstat
decl_stmt|;
name|char
modifier|*
name|enhsc
decl_stmt|;
name|enhsc
operator|=
name|NULL
expr_stmt|;
comment|/* check for the results of the transaction */
name|r
operator|=
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|TimeOuts
operator|.
name|to_datafinal
argument_list|,
name|NULL
argument_list|,
operator|&
name|enhsc
argument_list|,
name|XS_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
name|EX_TEMPFAIL
return|;
name|xstat
operator|=
name|EX_NOTSTICKY
expr_stmt|;
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|4
condition|)
name|status
operator|=
name|EX_TEMPFAIL
expr_stmt|;
elseif|else
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|2
condition|)
name|status
operator|=
name|xstat
operator|=
name|EX_OK
expr_stmt|;
elseif|else
if|if
condition|(
name|REPLYCLASS
argument_list|(
name|r
argument_list|)
operator|!=
literal|5
condition|)
name|status
operator|=
name|xstat
operator|=
name|EX_PROTOCOL
expr_stmt|;
elseif|else
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|==
literal|5
condition|)
name|status
operator|=
name|EX_UNAVAILABLE
expr_stmt|;
else|else
name|status
operator|=
name|EX_PROTOCOL
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_ENHSTAT
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
operator|&&
operator|(
name|off
operator|=
name|isenhsc
argument_list|(
name|SmtpReplyBuffer
operator|+
literal|4
argument_list|,
literal|' '
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|off
operator|+=
literal|5
expr_stmt|;
else|else
name|off
operator|=
literal|4
expr_stmt|;
name|e
operator|->
name|e_statmsg
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
operator|&
name|SmtpReplyBuffer
index|[
name|off
index|]
argument_list|)
expr_stmt|;
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|xstat
argument_list|,
name|ENHSCN
argument_list|(
name|enhsc
argument_list|,
name|smtptodsn
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|,
name|SmtpReplyBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|1
operator|&&
name|status
operator|==
name|EX_PROTOCOL
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_CRIT
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%.100s: SMTP DATA-3 protocol error: %s"
argument_list|,
name|CurHostName
argument_list|,
name|shortenstring
argument_list|(
name|SmtpReplyBuffer
argument_list|,
literal|403
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* **  SMTPQUIT -- close the SMTP connection. ** **	Parameters: **		m -- a pointer to the mailer. **		mci -- the mailer connection information. **		e -- the current envelope. ** **	Returns: **		none. ** **	Side Effects: **		sends the final protocol and closes the connection. */
end_comment

begin_function
name|void
name|smtpquit
parameter_list|(
name|m
parameter_list|,
name|mci
parameter_list|,
name|e
parameter_list|)
specifier|register
name|MAILER
modifier|*
name|m
decl_stmt|;
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|bool
name|oldSuprErrs
init|=
name|SuprErrs
decl_stmt|;
name|int
name|rcode
decl_stmt|;
name|char
modifier|*
name|oldcurhost
decl_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|==
name|MCIS_CLOSED
condition|)
block|{
name|mci_close
argument_list|(
name|mci
argument_list|,
literal|"smtpquit:1"
argument_list|)
expr_stmt|;
return|return;
block|}
name|oldcurhost
operator|=
name|CurHostName
expr_stmt|;
name|CurHostName
operator|=
name|mci
operator|->
name|mci_host
expr_stmt|;
comment|/* XXX UGLY XXX */
if|if
condition|(
name|CurHostName
operator|==
name|NULL
condition|)
name|CurHostName
operator|=
name|MyHostName
expr_stmt|;
if|#
directive|if
name|PIPELINING
name|mci
operator|->
name|mci_okrcpts
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* PIPELINING */
comment|/* 	**	Suppress errors here -- we may be processing a different 	**	job when we do the quit connection, and we don't want the 	**	new job to be penalized for something that isn't it's 	**	problem. 	*/
name|SuprErrs
operator|=
name|true
expr_stmt|;
comment|/* send the quit message if we haven't gotten I/O error */
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_ERROR
operator|&&
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_QUITING
condition|)
block|{
name|SmtpPhase
operator|=
literal|"client QUIT"
expr_stmt|;
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_QUITING
expr_stmt|;
name|smtpmessage
argument_list|(
literal|"QUIT"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|TimeOuts
operator|.
name|to_quit
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|XS_DEFAULT
argument_list|)
expr_stmt|;
name|SuprErrs
operator|=
name|oldSuprErrs
expr_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|==
name|MCIS_CLOSED
condition|)
goto|goto
name|end
goto|;
block|}
comment|/* now actually close the connection and pick up the zombie */
name|rcode
operator|=
name|endmailer
argument_list|(
name|mci
argument_list|,
name|e
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcode
operator|!=
name|EX_OK
condition|)
block|{
name|char
modifier|*
name|mailer
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_mailer
operator|!=
name|NULL
operator|&&
name|mci
operator|->
name|mci_mailer
operator|->
name|m_name
operator|!=
name|NULL
condition|)
name|mailer
operator|=
name|mci
operator|->
name|mci_mailer
operator|->
name|m_name
expr_stmt|;
comment|/* look for naughty mailers */
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"smtpquit: mailer%s%s exited with exit value %d"
argument_list|,
name|mailer
operator|==
name|NULL
condition|?
literal|""
else|:
literal|" "
argument_list|,
name|mailer
operator|==
name|NULL
condition|?
literal|""
else|:
name|mailer
argument_list|,
name|rcode
argument_list|)
expr_stmt|;
block|}
name|SuprErrs
operator|=
name|oldSuprErrs
expr_stmt|;
name|end
label|:
name|CurHostName
operator|=
name|oldcurhost
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* **  SMTPRSET -- send a RSET (reset) command ** **	Parameters: **		m -- a pointer to the mailer. **		mci -- the mailer connection information. **		e -- the current envelope. ** **	Returns: **		none. ** **	Side Effects: **		closes the connection if there is no reply to RSET. */
end_comment

begin_function
name|void
name|smtprset
parameter_list|(
name|m
parameter_list|,
name|mci
parameter_list|,
name|e
parameter_list|)
specifier|register
name|MAILER
modifier|*
name|m
decl_stmt|;
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|r
decl_stmt|;
name|CurHostName
operator|=
name|mci
operator|->
name|mci_host
expr_stmt|;
comment|/* XXX UGLY XXX */
if|if
condition|(
name|CurHostName
operator|==
name|NULL
condition|)
name|CurHostName
operator|=
name|MyHostName
expr_stmt|;
if|#
directive|if
name|PIPELINING
name|mci
operator|->
name|mci_okrcpts
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* PIPELINING */
comment|/* 	**  Check if connection is gone, if so 	**  it's a tempfail and we use mci_errno 	**  for the reason. 	*/
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|==
name|MCIS_CLOSED
condition|)
block|{
name|errno
operator|=
name|mci
operator|->
name|mci_errno
expr_stmt|;
return|return;
block|}
name|SmtpPhase
operator|=
literal|"client RSET"
expr_stmt|;
name|smtpmessage
argument_list|(
literal|"RSET"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|)
expr_stmt|;
name|r
operator|=
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|TimeOuts
operator|.
name|to_rset
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|XS_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return;
comment|/* 	**  Any response is deemed to be acceptable. 	**  The standard does not state the proper action 	**  to take when a value other than 250 is received. 	** 	**  However, if 421 is returned for the RSET, leave 	**  mci_state alone (MCIS_SSD can be set in reply() 	**  and MCIS_CLOSED can be set in smtpquit() if 	**  reply() gets a 421 and calls smtpquit()). 	*/
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_SSD
operator|&&
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_CLOSED
condition|)
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_OPEN
expr_stmt|;
elseif|else
if|if
condition|(
name|mci
operator|->
name|mci_exitstat
operator|==
name|EX_OK
condition|)
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_TEMPFAIL
argument_list|,
literal|"4.5.0"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  SMTPPROBE -- check the connection state ** **	Parameters: **		mci -- the mailer connection information. ** **	Returns: **		none. ** **	Side Effects: **		closes the connection if there is no reply to RSET. */
end_comment

begin_function
name|int
name|smtpprobe
parameter_list|(
name|mci
parameter_list|)
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
block|{
name|int
name|r
decl_stmt|;
name|MAILER
modifier|*
name|m
init|=
name|mci
operator|->
name|mci_mailer
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
specifier|extern
name|ENVELOPE
name|BlankEnvelope
decl_stmt|;
name|CurHostName
operator|=
name|mci
operator|->
name|mci_host
expr_stmt|;
comment|/* XXX UGLY XXX */
if|if
condition|(
name|CurHostName
operator|==
name|NULL
condition|)
name|CurHostName
operator|=
name|MyHostName
expr_stmt|;
name|e
operator|=
operator|&
name|BlankEnvelope
expr_stmt|;
name|SmtpPhase
operator|=
literal|"client probe"
expr_stmt|;
name|smtpmessage
argument_list|(
literal|"RSET"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|)
expr_stmt|;
name|r
operator|=
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|TimeOuts
operator|.
name|to_miscshort
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|XS_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|r
argument_list|)
operator|!=
literal|2
condition|)
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* **  REPLY -- read arpanet reply ** **	Parameters: **		m -- the mailer we are reading the reply from. **		mci -- the mailer connection info structure. **		e -- the current envelope. **		timeout -- the timeout for reads. **		pfunc -- processing function called on each line of response. **			If null, no special processing is done. **		enhstat -- optional, returns enhanced error code string (if set) **		rtype -- type of SmtpMsgBuffer: does it contains secret data? ** **	Returns: **		reply code it reads. ** **	Side Effects: **		flushes the mail file. */
end_comment

begin_function_decl
name|int
name|reply
parameter_list|(
name|m
parameter_list|,
name|mci
parameter_list|,
name|e
parameter_list|,
name|timeout
parameter_list|,
name|pfunc
parameter_list|,
name|enhstat
parameter_list|,
name|rtype
parameter_list|)
name|MAILER
modifier|*
name|m
decl_stmt|;
name|MCI
modifier|*
name|mci
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|time_t
name|timeout
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*pfunc
end_function_decl

begin_expr_stmt
unit|)
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|bool
operator|,
name|MAILER
operator|*
operator|,
name|MCI
operator|*
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|enhstat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rtype
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|bufp
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|;
name|bool
name|firstline
init|=
name|true
decl_stmt|;
name|char
name|junkbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
specifier|static
name|char
name|enhstatcode
index|[
name|ENHSCLEN
index|]
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
comment|/* 	**  Flush the output before reading response. 	** 	**	For SMTP pipelining, it would be better if we didn't do 	**	this if there was already data waiting to be read.  But 	**	to do it properly means pushing it to the I/O library, 	**	since it really needs to be done below the buffer layer. 	*/
if|if
condition|(
name|mci
operator|->
name|mci_out
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_flush
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|18
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"reply\n"
argument_list|)
expr_stmt|;
comment|/* 	**  Read the input line, being careful not to hang. 	*/
name|bufp
operator|=
name|SmtpReplyBuffer
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* actually do the read */
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
condition|)
comment|/* for debugging */
operator|(
name|void
operator|)
name|sm_io_flush
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
comment|/* if we are in the process of closing just give the code */
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|==
name|MCIS_CLOSED
condition|)
return|return
name|SMTPCLOSING
return|;
comment|/* don't try to read from a non-existent fd */
if|if
condition|(
name|mci
operator|->
name|mci_in
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|mci
operator|->
name|mci_errno
operator|==
literal|0
condition|)
name|mci
operator|->
name|mci_errno
operator|=
name|EBADF
expr_stmt|;
comment|/* errors on QUIT should be ignored */
if|if
condition|(
name|strncmp
argument_list|(
name|SmtpMsgBuffer
argument_list|,
literal|"QUIT"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|mci
operator|->
name|mci_errno
expr_stmt|;
name|mci_close
argument_list|(
name|mci
argument_list|,
literal|"reply:1"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_ERROR
expr_stmt|;
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|errno
operator|=
name|mci
operator|->
name|mci_errno
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|mci
operator|->
name|mci_out
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_flush
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
comment|/* get the line from the other side */
name|p
operator|=
name|sfgets
argument_list|(
name|bufp
argument_list|,
name|MAXLINE
argument_list|,
name|mci
operator|->
name|mci_in
argument_list|,
name|timeout
argument_list|,
name|SmtpPhase
argument_list|)
expr_stmt|;
name|save_errno
operator|=
name|errno
expr_stmt|;
name|mci
operator|->
name|mci_lastuse
operator|=
name|curtime
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|bool
name|oldholderrs
decl_stmt|;
specifier|extern
name|char
name|MsgBuf
index|[]
decl_stmt|;
comment|/* errors on QUIT should be ignored */
if|if
condition|(
name|strncmp
argument_list|(
name|SmtpMsgBuffer
argument_list|,
literal|"QUIT"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mci_close
argument_list|(
name|mci
argument_list|,
literal|"reply:2"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* if the remote end closed early, fake an error */
name|errno
operator|=
name|save_errno
expr_stmt|;
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|SmtpReplyBuffer
argument_list|,
sizeof|sizeof
argument_list|(
name|SmtpReplyBuffer
argument_list|)
argument_list|,
literal|"421 4.4.1 Connection reset by %s"
argument_list|,
name|CURHOSTNAME
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ECONNRESET
name|errno
operator|=
name|ECONNRESET
expr_stmt|;
else|#
directive|else
comment|/* ECONNRESET */
name|errno
operator|=
name|EPIPE
expr_stmt|;
endif|#
directive|endif
comment|/* ECONNRESET */
block|}
name|mci
operator|->
name|mci_errno
operator|=
name|errno
expr_stmt|;
name|oldholderrs
operator|=
name|HoldErrs
expr_stmt|;
name|HoldErrs
operator|=
name|true
expr_stmt|;
name|usrerr
argument_list|(
literal|"451 4.4.1 reply: read error from %s"
argument_list|,
name|CURHOSTNAME
argument_list|)
expr_stmt|;
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_TEMPFAIL
argument_list|,
literal|"4.4.2"
argument_list|,
name|MsgBuf
argument_list|)
expr_stmt|;
comment|/* if debugging, pause so we can see state */
if|if
condition|(
name|tTd
argument_list|(
literal|18
argument_list|,
literal|100
argument_list|)
condition|)
operator|(
name|void
operator|)
name|pause
argument_list|()
expr_stmt|;
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_ERROR
expr_stmt|;
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|#
directive|if
name|XDEBUG
block|{
name|char
name|wbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|p
operator|=
name|wbuf
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_to
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|p
argument_list|,
name|SPACELEFT
argument_list|(
name|wbuf
argument_list|,
name|p
argument_list|)
argument_list|,
literal|"%s... "
argument_list|,
name|shortenstring
argument_list|(
name|e
operator|->
name|e_to
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|p
argument_list|,
name|SPACELEFT
argument_list|(
name|wbuf
argument_list|,
name|p
argument_list|)
argument_list|,
literal|"reply(%.100s) during %s"
argument_list|,
name|CURHOSTNAME
argument_list|,
name|SmtpPhase
argument_list|)
expr_stmt|;
name|checkfd012
argument_list|(
name|wbuf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* XDEBUG */
name|HoldErrs
operator|=
name|oldholderrs
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|fixcrlf
argument_list|(
name|bufp
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* EHLO failure is not a real error */
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
operator|&&
operator|(
name|bufp
index|[
literal|0
index|]
operator|==
literal|'4'
operator|||
operator|(
name|bufp
index|[
literal|0
index|]
operator|==
literal|'5'
operator|&&
name|strncmp
argument_list|(
name|SmtpMsgBuffer
argument_list|,
literal|"EHLO"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* serious error -- log the previous command */
if|if
condition|(
name|SmtpNeedIntro
condition|)
block|{
comment|/* inform user who we are chatting with */
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|CurEnv
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"... while talking to %s:\n"
argument_list|,
name|CURHOSTNAME
argument_list|)
expr_stmt|;
name|SmtpNeedIntro
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|SmtpMsgBuffer
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|">>> %s\n"
argument_list|,
operator|(
name|rtype
operator|==
name|XS_STARTTLS
operator|)
condition|?
literal|"STARTTLS dialogue"
else|:
operator|(
operator|(
name|rtype
operator|==
name|XS_AUTH
operator|)
condition|?
literal|"AUTH dialogue"
else|:
name|SmtpMsgBuffer
operator|)
argument_list|)
expr_stmt|;
name|SmtpMsgBuffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* now log the message as from the other side */
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"<<< %s\n"
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
block|}
comment|/* display the input for verbose mode */
if|if
condition|(
name|Verbose
condition|)
name|nmessage
argument_list|(
literal|"050 %s"
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
comment|/* ignore improperly formatted input */
if|if
condition|(
operator|!
name|ISSMTPREPLY
argument_list|(
name|bufp
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_ENHSTAT
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
operator|&&
name|enhstat
operator|!=
name|NULL
operator|&&
name|extenhsc
argument_list|(
name|bufp
operator|+
literal|4
argument_list|,
literal|' '
argument_list|,
name|enhstatcode
argument_list|)
operator|>
literal|0
condition|)
operator|*
name|enhstat
operator|=
name|enhstatcode
expr_stmt|;
comment|/* process the line */
if|if
condition|(
name|pfunc
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|pfunc
call|)
argument_list|(
name|bufp
argument_list|,
name|firstline
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|firstline
operator|=
name|false
expr_stmt|;
comment|/* decode the reply code */
name|r
operator|=
name|atoi
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
comment|/* extra semantics: 0xx codes are "informational" */
if|if
condition|(
name|r
operator|<
literal|100
condition|)
continue|continue;
comment|/* if no continuation lines, return this line */
if|if
condition|(
name|bufp
index|[
literal|3
index|]
operator|!=
literal|'-'
condition|)
break|break;
comment|/* first line of real reply -- ignore rest */
name|bufp
operator|=
name|junkbuf
expr_stmt|;
block|}
comment|/* 	**  Now look at SmtpReplyBuffer -- only care about the first 	**  line of the response from here on out. 	*/
comment|/* save temporary failure messages for posterity */
if|if
condition|(
name|SmtpReplyBuffer
index|[
literal|0
index|]
operator|==
literal|'4'
condition|)
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|SmtpError
argument_list|,
name|SmtpReplyBuffer
argument_list|,
sizeof|sizeof
argument_list|(
name|SmtpError
argument_list|)
argument_list|)
expr_stmt|;
comment|/* reply code 421 is "Service Shutting Down" */
if|if
condition|(
name|r
operator|==
name|SMTPCLOSING
operator|&&
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_SSD
operator|&&
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_QUITING
condition|)
block|{
comment|/* send the quit protocol */
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_SSD
expr_stmt|;
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_block

begin_comment
comment|/* **  SMTPMESSAGE -- send message to server ** **	Parameters: **		f -- format **		m -- the mailer to control formatting. **		a, b, c -- parameters ** **	Returns: **		none. ** **	Side Effects: **		writes message to mci->mci_out. */
end_comment

begin_comment
comment|/*VARARGS1*/
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|smtpmessage
parameter_list|(
name|char
modifier|*
name|f
parameter_list|,
name|MAILER
modifier|*
name|m
parameter_list|,
name|MCI
modifier|*
name|mci
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
comment|/* __STDC__ */
function|smtpmessage
parameter_list|(
name|f
parameter_list|,
name|m
parameter_list|,
name|mci
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|f
decl_stmt|;
name|MAILER
modifier|*
name|m
decl_stmt|;
name|MCI
modifier|*
name|mci
decl_stmt|;
function|va_dcl
endif|#
directive|endif
comment|/* __STDC__ */
block|{
name|SM_VA_LOCAL_DECL
name|SM_VA_START
argument_list|(
name|ap
argument_list|,
name|mci
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|sm_vsnprintf
argument_list|(
name|SmtpMsgBuffer
argument_list|,
sizeof|sizeof
argument_list|(
name|SmtpMsgBuffer
argument_list|)
argument_list|,
name|f
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|SM_VA_END
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|18
argument_list|,
literal|1
argument_list|)
operator|||
name|Verbose
condition|)
name|nmessage
argument_list|(
literal|">>> %s"
argument_list|,
name|SmtpMsgBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|TrafficLogFile
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|TrafficLogFile
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%05d>>> %s\n"
argument_list|,
operator|(
name|int
operator|)
name|CurrentPid
argument_list|,
name|SmtpMsgBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_out
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s%s"
argument_list|,
name|SmtpMsgBuffer
argument_list|,
name|m
operator|==
name|NULL
condition|?
literal|"\r\n"
else|:
name|m
operator|->
name|m_eol
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tTd
argument_list|(
literal|18
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"smtpmessage: NULL mci_out\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

