begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998-2006 Sendmail, Inc. and its suppliers.  *	All rights reserved.  * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  */
end_comment

begin_include
include|#
directive|include
file|<sendmail.h>
end_include

begin_include
include|#
directive|include
file|<sm/time.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: deliver.c,v 8.1000 2006/03/02 01:37:39 ca Exp $"
argument_list|)
end_macro

begin_if
if|#
directive|if
name|HASSETUSERCONTEXT
end_if

begin_include
include|#
directive|include
file|<login_cap.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HASSETUSERCONTEXT */
end_comment

begin_if
if|#
directive|if
name|NETINET
operator|||
name|NETINET6
end_if

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NETINET || NETINET6 */
end_comment

begin_if
if|#
directive|if
name|STARTTLS
operator|||
name|SASL
end_if

begin_include
include|#
directive|include
file|"sfsasl.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STARTTLS || SASL */
end_comment

begin_decl_stmt
specifier|static
name|int
name|deliver
name|__P
argument_list|(
operator|(
name|ENVELOPE
operator|*
operator|,
name|ADDRESS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dup_queue_file
name|__P
argument_list|(
operator|(
name|ENVELOPE
operator|*
operator|,
name|ENVELOPE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mailfiletimeout
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|endwaittimeout
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parse_hostsignature
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|MAILER
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sendenvelope
name|__P
argument_list|(
operator|(
name|ENVELOPE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|MCI
modifier|*
name|mci_new
name|__P
argument_list|(
operator|(
name|SM_RPOOL_T
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|coloncmp
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|STARTTLS
end_if

begin_decl_stmt
specifier|static
name|int
name|starttls
name|__P
argument_list|(
operator|(
name|MAILER
operator|*
operator|,
name|MCI
operator|*
operator|,
name|ENVELOPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|endtlsclt
name|__P
argument_list|(
operator|(
name|MCI
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STARTTLS */
end_comment

begin_if
if|#
directive|if
name|STARTTLS
operator|||
name|SASL
end_if

begin_decl_stmt
specifier|static
name|bool
name|iscltflgset
name|__P
argument_list|(
operator|(
name|ENVELOPE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STARTTLS || SASL */
end_comment

begin_comment
comment|/* **  SENDALL -- actually send all the messages. ** **	Parameters: **		e -- the envelope to send. **		mode -- the delivery mode to use.  If SM_DEFAULT, use **			the current e->e_sendmode. ** **	Returns: **		none. ** **	Side Effects: **		Scans the send lists and sends everything it finds. **		Delivers any appropriate error messages. **		If we are running in a non-interactive mode, takes the **			appropriate action. */
end_comment

begin_function
name|void
name|sendall
parameter_list|(
name|e
parameter_list|,
name|mode
parameter_list|)
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|owner
decl_stmt|;
name|int
name|otherowners
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|ee
decl_stmt|;
name|ENVELOPE
modifier|*
name|splitenv
init|=
name|NULL
decl_stmt|;
name|int
name|oldverbose
init|=
name|Verbose
decl_stmt|;
name|bool
name|somedeliveries
init|=
name|false
decl_stmt|,
name|expensive
init|=
name|false
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
comment|/* 	**  If this message is to be discarded, don't bother sending 	**  the message at all. 	*/
if|if
condition|(
name|bitset
argument_list|(
name|EF_DISCARD
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"sendall: discarding id %s\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_CLRQUEUE
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|logundelrcpts
argument_list|(
name|e
argument_list|,
literal|"discarded"
argument_list|,
literal|9
argument_list|,
name|true
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|LogLevel
operator|>
literal|4
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"discarded"
argument_list|)
expr_stmt|;
name|markstats
argument_list|(
name|e
argument_list|,
name|NULL
argument_list|,
name|STATS_REJECT
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	**  If we have had global, fatal errors, don't bother sending 	**  the message at all if we are in SMTP mode.  Local errors 	**  (e.g., a single address failing) will still cause the other 	**  addresses to be sent. 	*/
if|if
condition|(
name|bitset
argument_list|(
name|EF_FATALERRS
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
operator|(
name|OpMode
operator|==
name|MD_SMTP
operator|||
name|OpMode
operator|==
name|MD_DAEMON
operator|)
condition|)
block|{
name|e
operator|->
name|e_flags
operator||=
name|EF_CLRQUEUE
expr_stmt|;
return|return;
block|}
comment|/* determine actual delivery mode */
if|if
condition|(
name|mode
operator|==
name|SM_DEFAULT
condition|)
block|{
name|mode
operator|=
name|e
operator|->
name|e_sendmode
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|SM_VERIFY
operator|&&
name|mode
operator|!=
name|SM_DEFER
operator|&&
name|shouldqueue
argument_list|(
name|e
operator|->
name|e_msgpriority
argument_list|,
name|e
operator|->
name|e_ctime
argument_list|)
condition|)
name|mode
operator|=
name|SM_QUEUE
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"\n===== SENDALL: mode %c, id %s, e_from "
argument_list|,
name|mode
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
operator|&
name|e
operator|->
name|e_from
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"\te_flags = "
argument_list|)
expr_stmt|;
name|printenvflags
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"sendqueue:\n"
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|e
operator|->
name|e_sendqueue
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Do any preprocessing necessary for the mode we are running. 	**	Check to make sure the hop count is reasonable. 	**	Delete sends to the sender in mailing lists. 	*/
name|CurEnv
operator|=
name|e
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|62
argument_list|,
literal|1
argument_list|)
condition|)
name|checkfds
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_hopcount
operator|>
name|MaxHopCount
condition|)
block|{
name|char
modifier|*
name|recip
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|e_sendqueue
operator|!=
name|NULL
operator|&&
name|e
operator|->
name|e_sendqueue
operator|->
name|q_paddr
operator|!=
name|NULL
condition|)
name|recip
operator|=
name|e
operator|->
name|e_sendqueue
operator|->
name|q_paddr
expr_stmt|;
else|else
name|recip
operator|=
literal|"(nobody)"
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|queueup
argument_list|(
name|e
argument_list|,
name|WILL_BE_QUEUED
argument_list|(
name|mode
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_FATALERRS
operator||
name|EF_PM_NOTIFY
operator||
name|EF_CLRQUEUE
expr_stmt|;
name|ExitStat
operator|=
name|EX_UNAVAILABLE
expr_stmt|;
name|syserr
argument_list|(
literal|"554 5.4.6 Too many hops %d (%d max): from %s via %s, to %s"
argument_list|,
name|e
operator|->
name|e_hopcount
argument_list|,
name|MaxHopCount
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|,
name|RealHostName
operator|==
name|NULL
condition|?
literal|"localhost"
else|:
name|RealHostName
argument_list|,
name|recip
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|QS_IS_DEAD
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
condition|)
continue|continue;
name|q
operator|->
name|q_state
operator|=
name|QS_BADADDR
expr_stmt|;
name|q
operator|->
name|q_status
operator|=
literal|"5.4.6"
expr_stmt|;
name|q
operator|->
name|q_rstatus
operator|=
literal|"554 5.4.6 Too many hops"
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	**  Do sender deletion. 	** 	**	If the sender should be queued up, skip this. 	**	This can happen if the name server is hosed when you 	**	are trying to send mail.  The result is that the sender 	**	is instantiated in the queue as a recipient. 	*/
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|EF_METOO
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
operator|!
name|QS_IS_QUEUEUP
argument_list|(
name|e
operator|->
name|e_from
operator|.
name|q_state
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"sendall: QS_SENDER "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
operator|&
name|e
operator|->
name|e_from
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|e_from
operator|.
name|q_state
operator|=
name|QS_SENDER
expr_stmt|;
operator|(
name|void
operator|)
name|recipient
argument_list|(
operator|&
name|e
operator|->
name|e_from
argument_list|,
operator|&
name|e
operator|->
name|e_sendqueue
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Handle alias owners. 	** 	**	We scan up the q_alias chain looking for owners. 	**	We discard owners that are the same as the return path. 	*/
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
specifier|register
name|struct
name|address
modifier|*
name|a
decl_stmt|;
for|for
control|(
name|a
operator|=
name|q
init|;
name|a
operator|!=
name|NULL
operator|&&
name|a
operator|->
name|q_owner
operator|==
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|q_alias
control|)
continue|continue;
if|if
condition|(
name|a
operator|!=
name|NULL
condition|)
name|q
operator|->
name|q_owner
operator|=
name|a
operator|->
name|q_owner
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|q_owner
operator|!=
name|NULL
operator|&&
operator|!
name|QS_IS_DEAD
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|q
operator|->
name|q_owner
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|)
operator|==
literal|0
condition|)
name|q
operator|->
name|q_owner
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|25
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"\nAfter first owner pass, sendq =\n"
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|e
operator|->
name|e_sendqueue
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|owner
operator|=
literal|""
expr_stmt|;
name|otherowners
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|owner
operator|!=
name|NULL
operator|&&
name|otherowners
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|28
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"owner = \"%s\", otherowners = %d\n"
argument_list|,
name|owner
argument_list|,
name|otherowners
argument_list|)
expr_stmt|;
name|owner
operator|=
name|NULL
expr_stmt|;
name|otherowners
operator|=
name|bitset
argument_list|(
name|EF_SENDRECEIPT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|30
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"Checking "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|q
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|QS_IS_DEAD
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|30
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"    ... QS_IS_DEAD\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|29
argument_list|)
operator|&&
operator|!
name|tTd
argument_list|(
literal|13
argument_list|,
literal|30
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"Checking "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|q
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|->
name|q_owner
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|owner
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|40
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"    ... First owner = \"%s\"\n"
argument_list|,
name|q
operator|->
name|q_owner
argument_list|)
expr_stmt|;
name|owner
operator|=
name|q
operator|->
name|q_owner
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|owner
operator|!=
name|q
operator|->
name|q_owner
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|owner
argument_list|,
name|q
operator|->
name|q_owner
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|40
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"    ... Same owner = \"%s\"\n"
argument_list|,
name|owner
argument_list|)
expr_stmt|;
comment|/* make future comparisons cheap */
name|q
operator|->
name|q_owner
operator|=
name|owner
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|40
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"    ... Another owner \"%s\"\n"
argument_list|,
name|q
operator|->
name|q_owner
argument_list|)
expr_stmt|;
name|otherowners
operator|++
expr_stmt|;
block|}
name|owner
operator|=
name|q
operator|->
name|q_owner
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|40
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"    ... Same owner = \"%s\"\n"
argument_list|,
name|owner
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|40
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"    ... Null owner\n"
argument_list|)
expr_stmt|;
name|otherowners
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|QS_IS_BADADDR
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|30
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"    ... QS_IS_BADADDR\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|QS_IS_QUEUEUP
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
condition|)
block|{
name|MAILER
modifier|*
name|m
init|=
name|q
operator|->
name|q_mailer
decl_stmt|;
comment|/* 				**  If we have temporary address failures 				**  (e.g., dns failure) and a fallback MX is 				**  set, send directly to the fallback MX host. 				*/
if|if
condition|(
name|FallbackMX
operator|!=
name|NULL
operator|&&
operator|!
name|wordinclass
argument_list|(
name|FallbackMX
argument_list|,
literal|'w'
argument_list|)
operator|&&
name|mode
operator|!=
name|SM_VERIFY
operator|&&
operator|!
name|bitnset
argument_list|(
name|M_NOMX
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|m
operator|->
name|m_mailer
argument_list|,
literal|"[IPC]"
argument_list|)
operator|==
literal|0
operator|&&
name|m
operator|->
name|m_argv
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|m
operator|->
name|m_argv
index|[
literal|0
index|]
argument_list|,
literal|"TCP"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|30
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"    ... FallbackMX\n"
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|FallbackMX
argument_list|)
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|sm_rpool_malloc_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|p
argument_list|,
name|FallbackMX
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|q
operator|->
name|q_state
operator|=
name|QS_OK
expr_stmt|;
name|q
operator|->
name|q_host
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|30
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"    ... QS_IS_QUEUEUP\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 			**  If this mailer is expensive, and if we don't 			**  want to make connections now, just mark these 			**  addresses and return.  This is useful if we 			**  want to batch connections to reduce load.  This 			**  will cause the messages to be queued up, and a 			**  daemon will come along to send the messages later. 			*/
if|if
condition|(
name|NoConnect
operator|&&
operator|!
name|Verbose
operator|&&
name|bitnset
argument_list|(
name|M_EXPENSIVE
argument_list|,
name|q
operator|->
name|q_mailer
operator|->
name|m_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|30
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"    ... expensive\n"
argument_list|)
expr_stmt|;
name|q
operator|->
name|q_state
operator|=
name|QS_QUEUEUP
expr_stmt|;
name|expensive
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitnset
argument_list|(
name|M_HOLD
argument_list|,
name|q
operator|->
name|q_mailer
operator|->
name|m_flags
argument_list|)
operator|&&
name|QueueLimitId
operator|==
name|NULL
operator|&&
name|QueueLimitSender
operator|==
name|NULL
operator|&&
name|QueueLimitRecipient
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|30
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"    ... hold\n"
argument_list|)
expr_stmt|;
name|q
operator|->
name|q_state
operator|=
name|QS_QUEUEUP
expr_stmt|;
name|expensive
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QueueMode
operator|!=
name|QM_QUARANTINE
operator|&&
name|e
operator|->
name|e_quarmsg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|30
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"    ... quarantine: %s\n"
argument_list|,
name|e
operator|->
name|e_quarmsg
argument_list|)
expr_stmt|;
name|q
operator|->
name|q_state
operator|=
name|QS_QUEUEUP
expr_stmt|;
name|expensive
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|30
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"    ... deliverable\n"
argument_list|)
expr_stmt|;
name|somedeliveries
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|owner
operator|!=
name|NULL
operator|&&
name|otherowners
operator|>
literal|0
condition|)
block|{
comment|/* 			**  Split this envelope into two. 			*/
name|ee
operator|=
operator|(
name|ENVELOPE
operator|*
operator|)
name|sm_rpool_malloc_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
sizeof|sizeof
expr|*
name|ee
argument_list|)
expr_stmt|;
name|STRUCTCOPY
argument_list|(
operator|*
name|e
argument_list|,
operator|*
name|ee
argument_list|)
expr_stmt|;
name|ee
operator|->
name|e_message
operator|=
name|NULL
expr_stmt|;
name|ee
operator|->
name|e_id
operator|=
name|NULL
expr_stmt|;
name|assign_queueid
argument_list|(
name|ee
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"sendall: split %s into %s, owner = \"%s\", otherowners = %d\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|ee
operator|->
name|e_id
argument_list|,
name|owner
argument_list|,
name|otherowners
argument_list|)
expr_stmt|;
name|ee
operator|->
name|e_header
operator|=
name|copyheader
argument_list|(
name|e
operator|->
name|e_header
argument_list|,
name|ee
operator|->
name|e_rpool
argument_list|)
expr_stmt|;
name|ee
operator|->
name|e_sendqueue
operator|=
name|copyqueue
argument_list|(
name|e
operator|->
name|e_sendqueue
argument_list|,
name|ee
operator|->
name|e_rpool
argument_list|)
expr_stmt|;
name|ee
operator|->
name|e_errorqueue
operator|=
name|copyqueue
argument_list|(
name|e
operator|->
name|e_errorqueue
argument_list|,
name|ee
operator|->
name|e_rpool
argument_list|)
expr_stmt|;
name|ee
operator|->
name|e_flags
operator|=
name|e
operator|->
name|e_flags
operator|&
operator|~
operator|(
name|EF_INQUEUE
operator||
name|EF_CLRQUEUE
operator||
name|EF_FATALERRS
operator||
name|EF_SENDRECEIPT
operator||
name|EF_RET_PARAM
operator|)
expr_stmt|;
name|ee
operator|->
name|e_flags
operator||=
name|EF_NORECEIPT
expr_stmt|;
name|setsender
argument_list|(
name|owner
argument_list|,
name|ee
argument_list|,
name|NULL
argument_list|,
literal|'\0'
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"sendall(split): QS_SENDER "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
operator|&
name|ee
operator|->
name|e_from
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|ee
operator|->
name|e_from
operator|.
name|q_state
operator|=
name|QS_SENDER
expr_stmt|;
name|ee
operator|->
name|e_dfp
operator|=
name|NULL
expr_stmt|;
name|ee
operator|->
name|e_lockfp
operator|=
name|NULL
expr_stmt|;
name|ee
operator|->
name|e_xfp
operator|=
name|NULL
expr_stmt|;
name|ee
operator|->
name|e_qgrp
operator|=
name|e
operator|->
name|e_qgrp
expr_stmt|;
name|ee
operator|->
name|e_qdir
operator|=
name|e
operator|->
name|e_qdir
expr_stmt|;
name|ee
operator|->
name|e_errormode
operator|=
name|EM_MAIL
expr_stmt|;
name|ee
operator|->
name|e_sibling
operator|=
name|splitenv
expr_stmt|;
name|ee
operator|->
name|e_statmsg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_quarmsg
operator|!=
name|NULL
condition|)
name|ee
operator|->
name|e_quarmsg
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|ee
operator|->
name|e_rpool
argument_list|,
name|e
operator|->
name|e_quarmsg
argument_list|)
expr_stmt|;
name|splitenv
operator|=
name|ee
expr_stmt|;
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|q
operator|->
name|q_owner
operator|==
name|owner
condition|)
block|{
name|q
operator|->
name|q_state
operator|=
name|QS_CLONED
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|6
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"\t... stripping %s from original envelope\n"
argument_list|,
name|q
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|q
operator|=
name|ee
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|q
operator|->
name|q_owner
operator|!=
name|owner
condition|)
block|{
name|q
operator|->
name|q_state
operator|=
name|QS_CLONED
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|6
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"\t... dropping %s from cloned envelope\n"
argument_list|,
name|q
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* clear DSN parameters */
name|q
operator|->
name|q_flags
operator|&=
operator|~
operator|(
name|QHASNOTIFY
operator||
name|Q_PINGFLAGS
operator|)
expr_stmt|;
name|q
operator|->
name|q_flags
operator||=
name|DefaultNotify
operator|&
operator|~
name|QPINGONSUCCESS
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|6
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"\t... moving %s to cloned envelope\n"
argument_list|,
name|q
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mode
operator|!=
name|SM_VERIFY
operator|&&
name|bitset
argument_list|(
name|EF_HAS_DF
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|dup_queue_file
argument_list|(
name|e
argument_list|,
name|ee
argument_list|,
name|DATAFL_LETTER
argument_list|)
expr_stmt|;
comment|/* 			**  Give the split envelope access to the parent 			**  transcript file for errors obtained while 			**  processing the recipients (done before the 			**  envelope splitting). 			*/
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
condition|)
name|ee
operator|->
name|e_xfp
operator|=
name|sm_io_dup
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|)
expr_stmt|;
comment|/* failed to dup e->e_xfp, start a new transcript */
if|if
condition|(
name|ee
operator|->
name|e_xfp
operator|==
name|NULL
condition|)
name|openxscript
argument_list|(
name|ee
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|SM_VERIFY
operator|&&
name|LogLevel
operator|>
literal|4
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%s: clone: owner=%s"
argument_list|,
name|ee
operator|->
name|e_id
argument_list|,
name|owner
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|owner
operator|!=
name|NULL
condition|)
block|{
name|setsender
argument_list|(
name|owner
argument_list|,
name|e
argument_list|,
name|NULL
argument_list|,
literal|'\0'
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"sendall(owner): QS_SENDER "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
operator|&
name|e
operator|->
name|e_from
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|e_from
operator|.
name|q_state
operator|=
name|QS_SENDER
expr_stmt|;
name|e
operator|->
name|e_errormode
operator|=
name|EM_MAIL
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_NORECEIPT
expr_stmt|;
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_FATALERRS
expr_stmt|;
block|}
comment|/* if nothing to be delivered, just queue up everything */
if|if
condition|(
operator|!
name|somedeliveries
operator|&&
operator|!
name|WILL_BE_QUEUED
argument_list|(
name|mode
argument_list|)
operator|&&
name|mode
operator|!=
name|SM_VERIFY
condition|)
block|{
name|time_t
name|now
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|29
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"No deliveries: auto-queuing\n"
argument_list|)
expr_stmt|;
name|mode
operator|=
name|SM_QUEUE
expr_stmt|;
name|now
operator|=
name|curtime
argument_list|()
expr_stmt|;
comment|/* treat this as a delivery in terms of counting tries */
name|e
operator|->
name|e_dtime
operator|=
name|now
expr_stmt|;
if|if
condition|(
operator|!
name|expensive
condition|)
name|e
operator|->
name|e_ntries
operator|++
expr_stmt|;
for|for
control|(
name|ee
operator|=
name|splitenv
init|;
name|ee
operator|!=
name|NULL
condition|;
name|ee
operator|=
name|ee
operator|->
name|e_sibling
control|)
block|{
name|ee
operator|->
name|e_dtime
operator|=
name|now
expr_stmt|;
if|if
condition|(
operator|!
name|expensive
condition|)
name|ee
operator|->
name|e_ntries
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|WILL_BE_QUEUED
argument_list|(
name|mode
argument_list|)
operator|||
name|mode
operator|==
name|SM_FORK
operator|||
operator|(
name|mode
operator|!=
name|SM_VERIFY
operator|&&
operator|(
name|SuperSafe
operator|==
name|SAFE_REALLY
operator|||
name|SuperSafe
operator|==
name|SAFE_REALLY_POSTMILTER
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|!
name|bitset
argument_list|(
name|EF_INQUEUE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|||
name|splitenv
operator|!=
name|NULL
operator|)
condition|)
block|{
name|bool
name|msync
decl_stmt|;
comment|/* 		**  Be sure everything is instantiated in the queue. 		**  Split envelopes first in case the machine crashes. 		**  If the original were done first, we may lose 		**  recipients. 		*/
if|#
directive|if
operator|!
name|HASFLOCK
name|msync
operator|=
name|false
expr_stmt|;
else|#
directive|else
comment|/* !HASFLOCK */
name|msync
operator|=
name|mode
operator|==
name|SM_FORK
expr_stmt|;
endif|#
directive|endif
comment|/* !HASFLOCK */
for|for
control|(
name|ee
operator|=
name|splitenv
init|;
name|ee
operator|!=
name|NULL
condition|;
name|ee
operator|=
name|ee
operator|->
name|e_sibling
control|)
name|queueup
argument_list|(
name|ee
argument_list|,
name|WILL_BE_QUEUED
argument_list|(
name|mode
argument_list|)
argument_list|,
name|msync
argument_list|)
expr_stmt|;
name|queueup
argument_list|(
name|e
argument_list|,
name|WILL_BE_QUEUED
argument_list|(
name|mode
argument_list|)
argument_list|,
name|msync
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|62
argument_list|,
literal|10
argument_list|)
condition|)
name|checkfds
argument_list|(
literal|"after envelope splitting"
argument_list|)
expr_stmt|;
comment|/* 	**  If we belong in background, fork now. 	*/
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|20
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"sendall: final mode = %c\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|21
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"\n================ Final Send Queue(s) =====================\n"
argument_list|)
expr_stmt|;
name|sm_dprintf
argument_list|(
literal|"\n  *** Envelope %s, e_from=%s ***\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|e
operator|->
name|e_sendqueue
argument_list|,
name|true
argument_list|)
expr_stmt|;
for|for
control|(
name|ee
operator|=
name|splitenv
init|;
name|ee
operator|!=
name|NULL
condition|;
name|ee
operator|=
name|ee
operator|->
name|e_sibling
control|)
block|{
name|sm_dprintf
argument_list|(
literal|"\n  *** Envelope %s, e_from=%s ***\n"
argument_list|,
name|ee
operator|->
name|e_id
argument_list|,
name|ee
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|ee
operator|->
name|e_sendqueue
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|sm_dprintf
argument_list|(
literal|"==========================================================\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SM_VERIFY
case|:
name|Verbose
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|SM_QUEUE
case|:
case|case
name|SM_DEFER
case|:
if|#
directive|if
name|HASFLOCK
name|queueonly
label|:
endif|#
directive|endif
comment|/* HASFLOCK */
if|if
condition|(
name|e
operator|->
name|e_nrcpts
operator|>
literal|0
condition|)
name|e
operator|->
name|e_flags
operator||=
name|EF_INQUEUE
expr_stmt|;
name|dropenvelope
argument_list|(
name|e
argument_list|,
name|splitenv
operator|!=
name|NULL
argument_list|,
name|true
argument_list|)
expr_stmt|;
for|for
control|(
name|ee
operator|=
name|splitenv
init|;
name|ee
operator|!=
name|NULL
condition|;
name|ee
operator|=
name|ee
operator|->
name|e_sibling
control|)
block|{
if|if
condition|(
name|ee
operator|->
name|e_nrcpts
operator|>
literal|0
condition|)
name|ee
operator|->
name|e_flags
operator||=
name|EF_INQUEUE
expr_stmt|;
name|dropenvelope
argument_list|(
name|ee
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|SM_FORK
case|:
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_flush
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|HASFLOCK
comment|/* 		**  Since fcntl locking has the interesting semantic that 		**  the lock is owned by a process, not by an open file 		**  descriptor, we have to flush this to the queue, and 		**  then restart from scratch in the child. 		*/
block|{
comment|/* save id for future use */
name|char
modifier|*
name|qid
init|=
name|e
operator|->
name|e_id
decl_stmt|;
comment|/* now drop the envelope in the parent */
name|e
operator|->
name|e_flags
operator||=
name|EF_INQUEUE
expr_stmt|;
name|dropenvelope
argument_list|(
name|e
argument_list|,
name|splitenv
operator|!=
name|NULL
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* arrange to reacquire lock after fork */
name|e
operator|->
name|e_id
operator|=
name|qid
expr_stmt|;
block|}
for|for
control|(
name|ee
operator|=
name|splitenv
init|;
name|ee
operator|!=
name|NULL
condition|;
name|ee
operator|=
name|ee
operator|->
name|e_sibling
control|)
block|{
comment|/* save id for future use */
name|char
modifier|*
name|qid
init|=
name|ee
operator|->
name|e_id
decl_stmt|;
comment|/* drop envelope in parent */
name|ee
operator|->
name|e_flags
operator||=
name|EF_INQUEUE
expr_stmt|;
name|dropenvelope
argument_list|(
name|ee
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* and save qid for reacquisition */
name|ee
operator|->
name|e_id
operator|=
name|qid
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !HASFLOCK */
comment|/* 		**  Since the delivery may happen in a child and the parent 		**  does not wait, the parent may close the maps thereby 		**  removing any shared memory used by the map.  Therefore, 		**  close the maps now so the child will dynamically open 		**  them if necessary. 		*/
name|closemaps
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"deliver: fork 1"
argument_list|)
expr_stmt|;
if|#
directive|if
name|HASFLOCK
goto|goto
name|queueonly
goto|;
else|#
directive|else
comment|/* HASFLOCK */
name|e
operator|->
name|e_id
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ee
operator|=
name|splitenv
init|;
name|ee
operator|!=
name|NULL
condition|;
name|ee
operator|=
name|ee
operator|->
name|e_sibling
control|)
name|ee
operator|->
name|e_id
operator|=
name|NULL
expr_stmt|;
return|return;
endif|#
directive|endif
comment|/* HASFLOCK */
block|}
elseif|else
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
block|{
if|#
directive|if
name|HASFLOCK
comment|/* be sure we leave the temp files to our child */
comment|/* close any random open files in the envelope */
name|closexscript
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_dfp
operator|=
name|NULL
expr_stmt|;
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_HAS_DF
expr_stmt|;
comment|/* can't call unlockqueue to avoid unlink of xfp */
if|if
condition|(
name|e
operator|->
name|e_lockfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|e
operator|->
name|e_lockfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
else|else
name|syserr
argument_list|(
literal|"%s: sendall: null lockfp"
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_lockfp
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* HASFLOCK */
comment|/* make sure the parent doesn't own the envelope */
name|e
operator|->
name|e_id
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|USE_DOUBLE_FORK
comment|/* catch intermediate zombie */
operator|(
name|void
operator|)
name|waitfor
argument_list|(
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_DOUBLE_FORK */
return|return;
block|}
comment|/* Reset global flags */
name|RestartRequest
operator|=
name|NULL
expr_stmt|;
name|RestartWorkGroup
operator|=
name|false
expr_stmt|;
name|ShutdownRequest
operator|=
name|NULL
expr_stmt|;
name|PendingSignal
operator|=
literal|0
expr_stmt|;
comment|/* 		**  Initialize exception stack and default exception 		**  handler for child process. 		*/
name|sm_exc_newthread
argument_list|(
name|fatal_error
argument_list|)
expr_stmt|;
comment|/* 		**  Since we have accepted responsbility for the message, 		**  change the SIGTERM handler.  intsig() (the old handler) 		**  would remove the envelope if this was a command line 		**  message submission. 		*/
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_DOUBLE_FORK
comment|/* double fork to avoid zombies */
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
name|save_errno
operator|=
name|errno
expr_stmt|;
endif|#
directive|endif
comment|/* USE_DOUBLE_FORK */
name|CurrentPid
operator|=
name|getpid
argument_list|()
expr_stmt|;
comment|/* be sure we are immune from the terminal */
name|disconnect
argument_list|(
literal|2
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|clearstats
argument_list|()
expr_stmt|;
comment|/* prevent parent from waiting if there was an error */
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|save_errno
expr_stmt|;
name|syserr
argument_list|(
literal|"deliver: fork 2"
argument_list|)
expr_stmt|;
if|#
directive|if
name|HASFLOCK
name|e
operator|->
name|e_flags
operator||=
name|EF_INQUEUE
expr_stmt|;
else|#
directive|else
comment|/* HASFLOCK */
name|e
operator|->
name|e_id
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* HASFLOCK */
name|finis
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
block|}
comment|/* be sure to give error messages in child */
name|QuickAbort
operator|=
name|false
expr_stmt|;
comment|/* 		**  Close any cached connections. 		** 		**	We don't send the QUIT protocol because the parent 		**	still knows about the connection. 		** 		**	This should only happen when delivering an error 		**	message. 		*/
name|mci_flush
argument_list|(
name|false
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
name|HASFLOCK
break|break;
else|#
directive|else
comment|/* HASFLOCK */
comment|/* 		**  Now reacquire and run the various queue files. 		*/
for|for
control|(
name|ee
operator|=
name|splitenv
init|;
name|ee
operator|!=
name|NULL
condition|;
name|ee
operator|=
name|ee
operator|->
name|e_sibling
control|)
block|{
name|ENVELOPE
modifier|*
name|sibling
init|=
name|ee
operator|->
name|e_sibling
decl_stmt|;
operator|(
name|void
operator|)
name|dowork
argument_list|(
name|ee
operator|->
name|e_qgrp
argument_list|,
name|ee
operator|->
name|e_qdir
argument_list|,
name|ee
operator|->
name|e_id
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|ee
argument_list|)
expr_stmt|;
name|ee
operator|->
name|e_sibling
operator|=
name|sibling
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|dowork
argument_list|(
name|e
operator|->
name|e_qgrp
argument_list|,
name|e
operator|->
name|e_qdir
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HASFLOCK */
block|}
name|sendenvelope
argument_list|(
name|e
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|dropenvelope
argument_list|(
name|e
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
for|for
control|(
name|ee
operator|=
name|splitenv
init|;
name|ee
operator|!=
name|NULL
condition|;
name|ee
operator|=
name|ee
operator|->
name|e_sibling
control|)
block|{
name|CurEnv
operator|=
name|ee
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|SM_VERIFY
condition|)
name|openxscript
argument_list|(
name|ee
argument_list|)
expr_stmt|;
name|sendenvelope
argument_list|(
name|ee
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|dropenvelope
argument_list|(
name|ee
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|CurEnv
operator|=
name|e
expr_stmt|;
name|Verbose
operator|=
name|oldverbose
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|SM_FORK
condition|)
name|finis
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sendenvelope
parameter_list|(
name|e
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
name|bool
name|didany
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|10
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"sendenvelope(%s) e_flags=0x%lx\n"
argument_list|,
name|e
operator|->
name|e_id
operator|==
name|NULL
condition|?
literal|"[NOQUEUE]"
else|:
name|e
operator|->
name|e_id
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|80
condition|)
name|sm_syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"sendenvelope, flags=0x%lx"
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
expr_stmt|;
comment|/* 	**  If we have had global, fatal errors, don't bother sending 	**  the message at all if we are in SMTP mode.  Local errors 	**  (e.g., a single address failing) will still cause the other 	**  addresses to be sent. 	*/
if|if
condition|(
name|bitset
argument_list|(
name|EF_FATALERRS
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
operator|(
name|OpMode
operator|==
name|MD_SMTP
operator|||
name|OpMode
operator|==
name|MD_DAEMON
operator|)
condition|)
block|{
name|e
operator|->
name|e_flags
operator||=
name|EF_CLRQUEUE
expr_stmt|;
return|return;
block|}
comment|/* 	**  Don't attempt deliveries if we want to bounce now 	**  or if deliver-by time is exceeded. 	*/
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|EF_RESPONSE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
operator|(
name|TimeOuts
operator|.
name|to_q_return
index|[
name|e
operator|->
name|e_timeoutclass
index|]
operator|==
name|NOW
operator|||
operator|(
name|IS_DLVR_RETURN
argument_list|(
name|e
argument_list|)
operator|&&
name|e
operator|->
name|e_deliver_by
operator|>
literal|0
operator|&&
name|curtime
argument_list|()
operator|>
name|e
operator|->
name|e_ctime
operator|+
name|e
operator|->
name|e_deliver_by
operator|)
operator|)
condition|)
return|return;
comment|/* 	**  Run through the list and send everything. 	** 	**	Set EF_GLOBALERRS so that error messages during delivery 	**	result in returned mail. 	*/
name|e
operator|->
name|e_nsent
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_GLOBALERRS
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{envid}"
argument_list|)
argument_list|,
name|e
operator|->
name|e_envid
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{bodytype}"
argument_list|)
argument_list|,
name|e
operator|->
name|e_bodytype
argument_list|)
expr_stmt|;
name|didany
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|EF_SPLIT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|ENVELOPE
modifier|*
name|oldsib
decl_stmt|;
name|ENVELOPE
modifier|*
name|ee
decl_stmt|;
comment|/* 		**  Save old sibling and set it to NULL to avoid 		**  queueing up the same envelopes again. 		**  This requires that envelopes in that list have 		**  been take care of before (or at some other place). 		*/
name|oldsib
operator|=
name|e
operator|->
name|e_sibling
expr_stmt|;
name|e
operator|->
name|e_sibling
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|split_by_recipient
argument_list|(
name|e
argument_list|)
operator|&&
name|bitset
argument_list|(
name|EF_FATALERRS
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|OpMode
operator|==
name|MD_SMTP
operator|||
name|OpMode
operator|==
name|MD_DAEMON
condition|)
name|e
operator|->
name|e_flags
operator||=
name|EF_CLRQUEUE
expr_stmt|;
return|return;
block|}
for|for
control|(
name|ee
operator|=
name|e
operator|->
name|e_sibling
init|;
name|ee
operator|!=
name|NULL
condition|;
name|ee
operator|=
name|ee
operator|->
name|e_sibling
control|)
name|queueup
argument_list|(
name|ee
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* clean up */
for|for
control|(
name|ee
operator|=
name|e
operator|->
name|e_sibling
init|;
name|ee
operator|!=
name|NULL
condition|;
name|ee
operator|=
name|ee
operator|->
name|e_sibling
control|)
block|{
comment|/* now unlock the job */
name|closexscript
argument_list|(
name|ee
argument_list|)
expr_stmt|;
name|unlockqueue
argument_list|(
name|ee
argument_list|)
expr_stmt|;
comment|/* this envelope is marked unused */
if|if
condition|(
name|ee
operator|->
name|e_dfp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|ee
operator|->
name|e_dfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
name|ee
operator|->
name|e_dfp
operator|=
name|NULL
expr_stmt|;
block|}
name|ee
operator|->
name|e_id
operator|=
name|NULL
expr_stmt|;
name|ee
operator|->
name|e_flags
operator|&=
operator|~
name|EF_HAS_DF
expr_stmt|;
block|}
name|e
operator|->
name|e_sibling
operator|=
name|oldsib
expr_stmt|;
block|}
comment|/* now run through the queue */
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|#
directive|if
name|XDEBUG
name|char
name|wbuf
index|[
name|MAXNAME
operator|+
literal|20
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|wbuf
argument_list|,
sizeof|sizeof
name|wbuf
argument_list|,
literal|"sendall(%.*s)"
argument_list|,
name|MAXNAME
argument_list|,
name|q
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
name|checkfd012
argument_list|(
name|wbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XDEBUG */
if|if
condition|(
name|mode
operator|==
name|SM_VERIFY
condition|)
block|{
name|e
operator|->
name|e_to
operator|=
name|q
operator|->
name|q_paddr
expr_stmt|;
if|if
condition|(
name|QS_IS_SENDABLE
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|q_host
operator|!=
name|NULL
operator|&&
name|q
operator|->
name|q_host
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|message
argument_list|(
literal|"deliverable: mailer %s, host %s, user %s"
argument_list|,
name|q
operator|->
name|q_mailer
operator|->
name|m_name
argument_list|,
name|q
operator|->
name|q_host
argument_list|,
name|q
operator|->
name|q_user
argument_list|)
expr_stmt|;
else|else
name|message
argument_list|(
literal|"deliverable: mailer %s, user %s"
argument_list|,
name|q
operator|->
name|q_mailer
operator|->
name|m_name
argument_list|,
name|q
operator|->
name|q_user
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|QS_IS_OK
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
condition|)
block|{
comment|/* 			**  Checkpoint the send list every few addresses 			*/
if|if
condition|(
name|CheckpointInterval
operator|>
literal|0
operator|&&
name|e
operator|->
name|e_nsent
operator|>=
name|CheckpointInterval
condition|)
block|{
name|queueup
argument_list|(
name|e
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_nsent
operator|=
literal|0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|deliver
argument_list|(
name|e
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|didany
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|didany
condition|)
block|{
name|e
operator|->
name|e_dtime
operator|=
name|curtime
argument_list|()
expr_stmt|;
name|e
operator|->
name|e_ntries
operator|++
expr_stmt|;
block|}
if|#
directive|if
name|XDEBUG
name|checkfd012
argument_list|(
literal|"end of sendenvelope"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XDEBUG */
block|}
end_function

begin_if
if|#
directive|if
name|REQUIRES_DIR_FSYNC
end_if

begin_comment
comment|/* **  SYNC_DIR -- fsync a directory based on a filename ** **	Parameters: **		filename -- path of file **		panic -- panic? ** **	Returns: **		none */
end_comment

begin_function
name|void
name|sync_dir
parameter_list|(
name|filename
parameter_list|,
name|panic
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|bool
name|panic
decl_stmt|;
block|{
name|int
name|dirfd
decl_stmt|;
name|char
modifier|*
name|dirp
decl_stmt|;
name|char
name|dir
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|RequiresDirfsync
condition|)
return|return;
comment|/* filesystems which require the directory be synced */
name|dirp
operator|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sm_strlcpy
argument_list|(
name|dir
argument_list|,
name|filename
argument_list|,
sizeof|sizeof
name|dir
argument_list|)
operator|>=
sizeof|sizeof
name|dir
condition|)
return|return;
name|dir
index|[
name|dirp
operator|-
name|filename
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dirp
operator|=
name|dir
expr_stmt|;
block|}
else|else
name|dirp
operator|=
literal|"."
expr_stmt|;
name|dirfd
operator|=
name|open
argument_list|(
name|dirp
argument_list|,
name|O_RDONLY
argument_list|,
literal|0700
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|40
argument_list|,
literal|32
argument_list|)
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"sync_dir: %s: fsync(%d)"
argument_list|,
name|dirp
argument_list|,
name|dirfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirfd
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|fsync
argument_list|(
name|dirfd
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|panic
condition|)
name|syserr
argument_list|(
literal|"!sync_dir: cannot fsync directory %s"
argument_list|,
name|dirp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|LogLevel
operator|>
literal|1
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"sync_dir: cannot fsync directory %s: %s"
argument_list|,
name|dirp
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|dirfd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REQUIRES_DIR_FSYNC */
end_comment

begin_comment
comment|/* **  DUP_QUEUE_FILE -- duplicate a queue file into a split queue ** **	Parameters: **		e -- the existing envelope **		ee -- the new envelope **		type -- the queue file type (e.g., DATAFL_LETTER) ** **	Returns: **		none */
end_comment

begin_function
specifier|static
name|void
name|dup_queue_file
parameter_list|(
name|e
parameter_list|,
name|ee
parameter_list|,
name|type
parameter_list|)
name|ENVELOPE
modifier|*
name|e
decl_stmt|,
decl|*
name|ee
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|f1buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|f2buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|ee
operator|->
name|e_dfp
operator|=
name|NULL
expr_stmt|;
name|ee
operator|->
name|e_xfp
operator|=
name|NULL
expr_stmt|;
comment|/* 	**  Make sure both are in the same directory. 	*/
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|f1buf
argument_list|,
name|queuename
argument_list|(
name|e
argument_list|,
name|type
argument_list|)
argument_list|,
sizeof|sizeof
name|f1buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|f2buf
argument_list|,
name|queuename
argument_list|(
name|ee
argument_list|,
name|type
argument_list|)
argument_list|,
sizeof|sizeof
name|f2buf
argument_list|)
expr_stmt|;
comment|/* Force the df to disk if it's not there yet */
if|if
condition|(
name|type
operator|==
name|DATAFL_LETTER
operator|&&
name|e
operator|->
name|e_dfp
operator|!=
name|NULL
operator|&&
name|sm_io_setinfo
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
name|SM_BF_COMMIT
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINVAL
condition|)
block|{
name|syserr
argument_list|(
literal|"!dup_queue_file: can't commit %s"
argument_list|,
name|f1buf
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|link
argument_list|(
name|f1buf
argument_list|,
name|f2buf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|syserr
argument_list|(
literal|"sendall: link(%s, %s)"
argument_list|,
name|f1buf
argument_list|,
name|f2buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_errno
operator|==
name|EEXIST
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|f2buf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"!sendall: unlink(%s): permanent"
argument_list|,
name|f2buf
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|link
argument_list|(
name|f1buf
argument_list|,
name|f2buf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"!sendall: link(%s, %s): permanent"
argument_list|,
name|f1buf
argument_list|,
name|f2buf
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
block|}
name|SYNC_DIR
argument_list|(
name|f2buf
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **  DOFORK -- do a fork, retrying a couple of times on failure. ** **	This MUST be a macro, since after a vfork we are running **	two processes on the same stack!!! ** **	Parameters: **		none. ** **	Returns: **		From a macro???  You've got to be kidding! ** **	Side Effects: **		Modifies the ==> LOCAL<== variable 'pid', leaving: **			pid of child in parent, zero in child. **			-1 on unrecoverable error. ** **	Notes: **		I'm awfully sorry this looks so awful.  That's **		vfork for you..... */
end_comment

begin_define
define|#
directive|define
name|NFORKTRIES
value|5
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|FORK
end_ifndef

begin_define
define|#
directive|define
name|FORK
value|fork
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! FORK */
end_comment

begin_define
define|#
directive|define
name|DOFORK
parameter_list|(
name|fORKfN
parameter_list|)
define|\
value|{\ 	register int i;\ \ 	for (i = NFORKTRIES; --i>= 0; )\ 	{\ 		pid = fORKfN();\ 		if (pid>= 0)\ 			break;\ 		if (i> 0)\ 			(void) sleep((unsigned) NFORKTRIES - i);\ 	}\ }
end_define

begin_comment
comment|/* **  DOFORK -- simple fork interface to DOFORK. ** **	Parameters: **		none. ** **	Returns: **		pid of child in parent. **		zero in child. **		-1 on error. ** **	Side Effects: **		returns twice, once in parent and once in child. */
end_comment

begin_function
name|pid_t
name|dofork
parameter_list|()
block|{
specifier|register
name|pid_t
name|pid
init|=
operator|-
literal|1
decl_stmt|;
name|DOFORK
argument_list|(
name|fork
argument_list|)
expr_stmt|;
return|return
name|pid
return|;
block|}
end_function

begin_comment
comment|/* **  COLONCMP -- compare host-signatures up to first ':' or EOS ** **	This takes two strings which happen to be host-signatures and **	compares them. If the lowest preference portions of the MX-RR's **	match (up to ':' or EOS, whichever is first), then we have **	match. This is used for coattail-piggybacking messages during **	message delivery. **	If the signatures are the same up to the first ':' the remainder of **	the signatures are then compared with a normal strcmp(). This saves **	re-examining the first part of the signatures. ** **	Parameters: **		a - first host-signature **		b - second host-signature ** **	Returns: **		HS_MATCH_NO -- no "match". **		HS_MATCH_FIRST -- "match" for the first MX preference **			(up to the first colon (':')). **		HS_MATCH_FULL -- match for the entire MX record. ** **	Side Effects: **		none. */
end_comment

begin_define
define|#
directive|define
name|HS_MATCH_NO
value|0
end_define

begin_define
define|#
directive|define
name|HS_MATCH_FIRST
value|1
end_define

begin_define
define|#
directive|define
name|HS_MATCH_FULL
value|2
end_define

begin_function
specifier|static
name|int
name|coloncmp
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
specifier|const
name|char
modifier|*
name|a
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|b
decl_stmt|;
block|{
name|int
name|ret
init|=
name|HS_MATCH_NO
decl_stmt|;
name|int
name|braclev
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|a
operator|==
operator|*
name|b
operator|++
condition|)
block|{
comment|/* Need to account for IPv6 bracketed addresses */
if|if
condition|(
operator|*
name|a
operator|==
literal|'['
condition|)
name|braclev
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|a
operator|==
literal|']'
operator|&&
name|braclev
operator|>
literal|0
condition|)
name|braclev
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|a
operator|==
literal|':'
operator|&&
name|braclev
operator|<=
literal|0
condition|)
block|{
name|ret
operator|=
name|HS_MATCH_FIRST
expr_stmt|;
name|a
operator|++
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|a
operator|==
literal|'\0'
condition|)
return|return
name|HS_MATCH_FULL
return|;
comment|/* a full match */
name|a
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|HS_MATCH_NO
operator|&&
name|braclev
operator|<=
literal|0
operator|&&
operator|(
operator|(
operator|*
name|a
operator|==
literal|'\0'
operator|&&
operator|*
operator|(
name|b
operator|-
literal|1
operator|)
operator|==
literal|':'
operator|)
operator|||
operator|(
operator|*
name|a
operator|==
literal|':'
operator|&&
operator|*
operator|(
name|b
operator|-
literal|1
operator|)
operator|==
literal|'\0'
operator|)
operator|)
condition|)
return|return
name|HS_MATCH_FIRST
return|;
if|if
condition|(
name|ret
operator|==
name|HS_MATCH_FIRST
operator|&&
name|strcmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|==
literal|0
condition|)
return|return
name|HS_MATCH_FULL
return|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* **  SHOULD_TRY_FBSH -- Should try FallbackSmartHost? ** **	Parameters: **		e -- envelope **		tried_fallbacksmarthost -- has been tried already? (in/out) **		hostbuf -- buffer for hostname (expand FallbackSmartHost) (out) **		hbsz -- size of hostbuf **		status -- current delivery status ** **	Returns: **		true iff FallbackSmartHost should be tried. */
end_comment

begin_function
specifier|static
name|bool
name|should_try_fbsh
parameter_list|(
name|e
parameter_list|,
name|tried_fallbacksmarthost
parameter_list|,
name|hostbuf
parameter_list|,
name|hbsz
parameter_list|,
name|status
parameter_list|)
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|bool
modifier|*
name|tried_fallbacksmarthost
decl_stmt|;
name|char
modifier|*
name|hostbuf
decl_stmt|;
name|size_t
name|hbsz
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
comment|/* 	**  If the host was not found or a temporary failure occurred 	**  and a FallbackSmartHost is defined (and we have not yet 	**  tried it), then make one last try with it as the host. 	*/
if|if
condition|(
operator|(
name|status
operator|==
name|EX_NOHOST
operator|||
name|status
operator|==
name|EX_TEMPFAIL
operator|)
operator|&&
name|FallbackSmartHost
operator|!=
name|NULL
operator|&&
operator|!
operator|*
name|tried_fallbacksmarthost
condition|)
block|{
operator|*
name|tried_fallbacksmarthost
operator|=
name|true
expr_stmt|;
name|expand
argument_list|(
name|FallbackSmartHost
argument_list|,
name|hostbuf
argument_list|,
name|hbsz
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wordinclass
argument_list|(
name|hostbuf
argument_list|,
literal|'w'
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"one last try with FallbackSmartHost %s\n"
argument_list|,
name|hostbuf
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* **  DELIVER -- Deliver a message to a list of addresses. ** **	This routine delivers to everyone on the same host as the **	user on the head of the list.  It is clever about mailers **	that don't handle multiple users.  It is NOT guaranteed **	that it will deliver to all these addresses however -- so **	deliver should be called once for each address on the **	list. **	Deliver tries to be as opportunistic as possible about piggybacking **	messages. Some definitions to make understanding easier follow below. **	Piggybacking occurs when an existing connection to a mail host can **	be used to send the same message to more than one recipient at the **	same time. So "no piggybacking" means one message for one recipient **	per connection. "Intentional piggybacking" happens when the **	recipients' host address (not the mail host address) is used to **	attempt piggybacking. Recipients with the same host address **	have the same mail host. "Coincidental piggybacking" relies on **	piggybacking based on all the mail host addresses in the MX-RR. This **	is "coincidental" in the fact it could not be predicted until the **	MX Resource Records for the hosts were obtained and examined. For **	example (preference order and equivalence is important, not values): **		domain1 IN MX 10 mxhost-A **			IN MX 20 mxhost-B **		domain2 IN MX  4 mxhost-A **			IN MX  8 mxhost-B **	Domain1 and domain2 can piggyback the same message to mxhost-A or **	mxhost-B (if mxhost-A cannot be reached). **	"Coattail piggybacking" relaxes the strictness of "coincidental **	piggybacking" in the hope that most significant (lowest value) **	MX preference host(s) can create more piggybacking. For example **	(again, preference order and equivalence is important, not values): **		domain3 IN MX 100 mxhost-C **			IN MX 100 mxhost-D **			IN MX 200 mxhost-E **		domain4 IN MX  50 mxhost-C **			IN MX  50 mxhost-D **			IN MX  80 mxhost-F **	A message for domain3 and domain4 can piggyback to mxhost-C if mxhost-C **	is available. Same with mxhost-D because in both RR's the preference **	value is the same as mxhost-C, respectively. **	So deliver attempts coattail piggybacking when possible. If the **	first MX preference level hosts cannot be used then the piggybacking **	reverts to coincidental piggybacking. Using the above example you **	cannot deliver to mxhost-F for domain3 regardless of preference value. **	("Coattail" from "riding on the coattails of your predecessor" meaning **	gaining benefit from a predecessor effort with no or little addition **	effort. The predecessor here being the preceding MX RR). ** **	Parameters: **		e -- the envelope to deliver. **		firstto -- head of the address list to deliver to. ** **	Returns: **		zero -- successfully delivered. **		else -- some failure, see ExitStat for more info. ** **	Side Effects: **		The standard input is passed off to someone. */
end_comment

begin_function
specifier|static
name|int
name|deliver
parameter_list|(
name|e
parameter_list|,
name|firstto
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|ADDRESS
modifier|*
name|firstto
decl_stmt|;
block|{
name|char
modifier|*
name|host
decl_stmt|;
comment|/* host being sent to */
name|char
modifier|*
name|user
decl_stmt|;
comment|/* user being sent to */
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|mvp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|MAILER
modifier|*
name|m
decl_stmt|;
comment|/* mailer for this recipient */
name|ADDRESS
modifier|*
specifier|volatile
name|ctladdr
decl_stmt|;
if|#
directive|if
name|HASSETUSERCONTEXT
name|ADDRESS
modifier|*
specifier|volatile
name|contextaddr
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* HASSETUSERCONTEXT */
specifier|register
name|MCI
modifier|*
specifier|volatile
name|mci
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|SM_NONVOLATILE
name|to
init|=
name|firstto
decl_stmt|;
specifier|volatile
name|bool
name|clever
init|=
name|false
decl_stmt|;
comment|/* running user smtp to this mailer */
name|ADDRESS
modifier|*
specifier|volatile
name|tochain
init|=
name|NULL
decl_stmt|;
comment|/* users chain in this mailer call */
name|int
name|rcode
decl_stmt|;
comment|/* response code */
name|SM_NONVOLATILE
name|int
name|lmtp_rcode
init|=
name|EX_OK
decl_stmt|;
name|SM_NONVOLATILE
name|int
name|nummxhosts
init|=
literal|0
decl_stmt|;
comment|/* number of MX hosts available */
name|SM_NONVOLATILE
name|int
name|hostnum
init|=
literal|0
decl_stmt|;
comment|/* current MX host index */
name|char
modifier|*
name|firstsig
decl_stmt|;
comment|/* signature of firstto */
specifier|volatile
name|pid_t
name|pid
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
specifier|volatile
name|curhost
decl_stmt|;
name|SM_NONVOLATILE
name|unsigned
name|short
name|port
init|=
literal|0
decl_stmt|;
name|SM_NONVOLATILE
name|time_t
name|enough
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|NETUNIX
name|char
modifier|*
name|SM_NONVOLATILE
name|mux_path
init|=
name|NULL
decl_stmt|;
comment|/* path to UNIX domain socket */
endif|#
directive|endif
comment|/* NETUNIX */
name|time_t
name|xstart
decl_stmt|;
name|bool
name|suidwarn
decl_stmt|;
name|bool
name|anyok
decl_stmt|;
comment|/* at least one address was OK */
name|SM_NONVOLATILE
name|bool
name|goodmxfound
init|=
name|false
decl_stmt|;
comment|/* at least one MX was OK */
name|bool
name|ovr
decl_stmt|;
name|bool
name|quarantine
decl_stmt|;
name|int
name|strsize
decl_stmt|;
name|int
name|rcptcount
decl_stmt|;
name|int
name|ret
decl_stmt|;
specifier|static
name|int
name|tobufsize
init|=
literal|0
decl_stmt|;
specifier|static
name|char
modifier|*
name|tobuf
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|rpath
decl_stmt|;
comment|/* translated return path */
name|int
name|mpvect
index|[
literal|2
index|]
decl_stmt|;
name|int
name|rpvect
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|mxhosts
index|[
name|MAXMXHOSTS
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|pv
index|[
name|MAXPV
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|buf
index|[
name|MAXNAME
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|cbuf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|QS_IS_OK
argument_list|(
name|to
operator|->
name|q_state
argument_list|)
condition|)
return|return
literal|0
return|;
name|suidwarn
operator|=
name|geteuid
argument_list|()
operator|==
literal|0
expr_stmt|;
name|m
operator|=
name|to
operator|->
name|q_mailer
expr_stmt|;
name|host
operator|=
name|to
operator|->
name|q_host
expr_stmt|;
name|CurEnv
operator|=
name|e
expr_stmt|;
comment|/* just in case */
name|e
operator|->
name|e_statmsg
operator|=
name|NULL
expr_stmt|;
name|SmtpError
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|xstart
operator|=
name|curtime
argument_list|()
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|10
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"\n--deliver, id=%s, mailer=%s, host=`%s', first user=`%s'\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|m
operator|->
name|m_name
argument_list|,
name|host
argument_list|,
name|to
operator|->
name|q_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|10
argument_list|,
literal|100
argument_list|)
condition|)
name|printopenfds
argument_list|(
name|false
argument_list|)
expr_stmt|;
comment|/* 	**  Clear {client_*} macros if this is a bounce message to 	**  prevent rejection by check_compat ruleset. 	*/
if|if
condition|(
name|bitset
argument_list|(
name|EF_RESPONSE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{client_name}"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{client_ptr}"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{client_addr}"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{client_port}"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{client_resolve}"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|SM_TRY
block|{
name|ADDRESS
modifier|*
name|skip_back
init|=
name|NULL
decl_stmt|;
comment|/* 	**  Do initial argv setup. 	**	Insert the mailer name.  Notice that $x expansion is 	**	NOT done on the mailer name.  Then, if the mailer has 	**	a picky -f flag, we insert it as appropriate.  This 	**	code does not check for 'pv' overflow; this places a 	**	manifest lower limit of 4 for MAXPV. 	**		The from address rewrite is expected to make 	**		the address relative to the other end. 	*/
comment|/* rewrite from address, using rewriting rules */
name|rcode
operator|=
name|EX_OK
expr_stmt|;
if|if
condition|(
name|bitnset
argument_list|(
name|M_UDBENVELOPE
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|->
name|m_flags
argument_list|)
condition|)
name|p
operator|=
name|e
operator|->
name|e_sender
expr_stmt|;
else|else
name|p
operator|=
name|e
operator|->
name|e_from
operator|.
name|q_paddr
expr_stmt|;
name|rpath
operator|=
name|remotename
argument_list|(
name|p
argument_list|,
name|m
argument_list|,
name|RF_SENDERADDR
operator||
name|RF_CANONICAL
argument_list|,
operator|&
name|rcode
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|rpath
argument_list|)
operator|>
name|MAXSHORTSTR
condition|)
block|{
name|rpath
operator|=
name|shortenstring
argument_list|(
name|rpath
argument_list|,
name|MAXSHORTSTR
argument_list|)
expr_stmt|;
comment|/* avoid bogus errno */
name|errno
operator|=
literal|0
expr_stmt|;
name|syserr
argument_list|(
literal|"remotename: huge return path %s"
argument_list|,
name|rpath
argument_list|)
expr_stmt|;
block|}
name|rpath
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|rpath
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'g'
argument_list|,
name|rpath
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'h'
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|Errors
operator|=
literal|0
expr_stmt|;
name|pvp
operator|=
name|pv
expr_stmt|;
operator|*
name|pvp
operator|++
operator|=
name|m
operator|->
name|m_argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* ignore long term host status information if mailer flag W is set */
if|if
condition|(
name|bitnset
argument_list|(
name|M_NOHOSTSTAT
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|IgnoreHostStatus
operator|=
name|true
expr_stmt|;
comment|/* insert -f or -r flag as appropriate */
if|if
condition|(
name|FromFlag
operator|&&
operator|(
name|bitnset
argument_list|(
name|M_FOPT
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|||
name|bitnset
argument_list|(
name|M_ROPT
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|bitnset
argument_list|(
name|M_FOPT
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
operator|*
name|pvp
operator|++
operator|=
literal|"-f"
expr_stmt|;
else|else
operator|*
name|pvp
operator|++
operator|=
literal|"-r"
expr_stmt|;
operator|*
name|pvp
operator|++
operator|=
name|rpath
expr_stmt|;
block|}
comment|/* 	**  Append the other fixed parts of the argv.  These run 	**  up to the first entry containing "$u".  There can only 	**  be one of these, and there are only a few more slots 	**  in the pv after it. 	*/
for|for
control|(
name|mvp
operator|=
name|m
operator|->
name|m_argv
init|;
operator|(
name|p
operator|=
operator|*
operator|++
name|mvp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
comment|/* can't use strchr here because of sign extension problems */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|++
operator|&
literal|0377
operator|)
operator|==
name|MACROEXPAND
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'u'
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
break|break;
comment|/* this entry is safe -- go ahead and process it */
name|expand
argument_list|(
operator|*
name|mvp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|e
argument_list|)
expr_stmt|;
operator|*
name|pvp
operator|++
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|>=
operator|&
name|pv
index|[
name|MAXPV
operator|-
literal|3
index|]
condition|)
block|{
name|syserr
argument_list|(
literal|"554 5.3.5 Too many parameters to %s before $u"
argument_list|,
name|pv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|rcode
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
comment|/* 	**  If we have no substitution for the user name in the argument 	**  list, we know that we must supply the names otherwise -- and 	**  SMTP is the answer!! 	*/
if|if
condition|(
operator|*
name|mvp
operator|==
name|NULL
condition|)
block|{
comment|/* running LMTP or SMTP */
name|clever
operator|=
name|true
expr_stmt|;
operator|*
name|pvp
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitnset
argument_list|(
name|M_LMTP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
comment|/* not running LMTP */
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NULL
argument_list|,
literal|"Warning: mailer %s: LMTP flag (F=z) turned off"
argument_list|,
name|m
operator|->
name|m_name
argument_list|)
expr_stmt|;
name|clrbitn
argument_list|(
name|M_LMTP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  At this point *mvp points to the argument with $u.  We 	**  run through our address list and append all the addresses 	**  we can.  If we run out of space, do not fret!  We can 	**  always send another copy later. 	*/
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
name|strsize
operator|=
literal|2
expr_stmt|;
name|rcptcount
operator|=
literal|0
expr_stmt|;
name|ctladdr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|firstto
operator|->
name|q_signature
operator|==
name|NULL
condition|)
name|firstto
operator|->
name|q_signature
operator|=
name|hostsignature
argument_list|(
name|firstto
operator|->
name|q_mailer
argument_list|,
name|firstto
operator|->
name|q_host
argument_list|)
expr_stmt|;
name|firstsig
operator|=
name|firstto
operator|->
name|q_signature
expr_stmt|;
for|for
control|(
init|;
name|to
operator|!=
name|NULL
condition|;
name|to
operator|=
name|to
operator|->
name|q_next
control|)
block|{
comment|/* avoid sending multiple recipients to dumb mailers */
if|if
condition|(
name|tochain
operator|!=
name|NULL
operator|&&
operator|!
name|bitnset
argument_list|(
name|M_MUSER
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
break|break;
comment|/* if already sent or not for this host, don't send */
if|if
condition|(
operator|!
name|QS_IS_OK
argument_list|(
name|to
operator|->
name|q_state
argument_list|)
condition|)
comment|/* already sent; look at next */
continue|continue;
comment|/* 		**  Must be same mailer to keep grouping rcpts. 		**  If mailers don't match: continue; sendqueue is not 		**  sorted by mailers, so don't break; 		*/
if|if
condition|(
name|to
operator|->
name|q_mailer
operator|!=
name|firstto
operator|->
name|q_mailer
condition|)
continue|continue;
if|if
condition|(
name|to
operator|->
name|q_signature
operator|==
name|NULL
condition|)
comment|/* for safety */
name|to
operator|->
name|q_signature
operator|=
name|hostsignature
argument_list|(
name|to
operator|->
name|q_mailer
argument_list|,
name|to
operator|->
name|q_host
argument_list|)
expr_stmt|;
comment|/* 		**  This is for coincidental and tailcoat piggybacking messages 		**  to the same mail host. While the signatures are identical 		**  (that's the MX-RR's are identical) we can do coincidental 		**  piggybacking. We try hard for coattail piggybacking 		**  with the same mail host when the next recipient has the 		**  same host at lowest preference. It may be that this 		**  won't work out, so 'skip_back' is maintained if a backup 		**  to coincidental piggybacking or full signature must happen. 		*/
name|ret
operator|=
name|firstto
operator|==
name|to
condition|?
name|HS_MATCH_FULL
else|:
name|coloncmp
argument_list|(
name|to
operator|->
name|q_signature
argument_list|,
name|firstsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|HS_MATCH_FULL
condition|)
name|skip_back
operator|=
name|to
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
name|HS_MATCH_NO
condition|)
break|break;
if|if
condition|(
operator|!
name|clever
condition|)
block|{
comment|/* avoid overflowing tobuf */
name|strsize
operator|+=
name|strlen
argument_list|(
name|to
operator|->
name|q_paddr
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|strsize
operator|>
name|TOBUFSIZE
condition|)
break|break;
block|}
if|if
condition|(
operator|++
name|rcptcount
operator|>
name|to
operator|->
name|q_mailer
operator|->
name|m_maxrcpt
condition|)
break|break;
if|if
condition|(
name|tTd
argument_list|(
literal|10
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"\nsend to "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|to
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
comment|/* compute effective uid/gid when sending */
if|if
condition|(
name|bitnset
argument_list|(
name|M_RUNASRCPT
argument_list|,
name|to
operator|->
name|q_mailer
operator|->
name|m_flags
argument_list|)
condition|)
if|#
directive|if
name|HASSETUSERCONTEXT
name|contextaddr
operator|=
name|ctladdr
operator|=
name|getctladdr
argument_list|(
name|to
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* HASSETUSERCONTEXT */
name|ctladdr
operator|=
name|getctladdr
argument_list|(
name|to
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HASSETUSERCONTEXT */
if|if
condition|(
name|tTd
argument_list|(
literal|10
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"ctladdr="
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|ctladdr
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|user
operator|=
name|to
operator|->
name|q_user
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|to
operator|->
name|q_paddr
expr_stmt|;
comment|/* 		**  Check to see that these people are allowed to 		**  talk to each other. 		**  Check also for overflow of e_msgsize. 		*/
if|if
condition|(
name|m
operator|->
name|m_maxsize
operator|!=
literal|0
operator|&&
operator|(
name|e
operator|->
name|e_msgsize
operator|>
name|m
operator|->
name|m_maxsize
operator|||
name|e
operator|->
name|e_msgsize
operator|<
literal|0
operator|)
condition|)
block|{
name|e
operator|->
name|e_flags
operator||=
name|EF_NO_BODY_RETN
expr_stmt|;
if|if
condition|(
name|bitnset
argument_list|(
name|M_LOCALMAILER
argument_list|,
name|to
operator|->
name|q_mailer
operator|->
name|m_flags
argument_list|)
condition|)
name|to
operator|->
name|q_status
operator|=
literal|"5.2.3"
expr_stmt|;
else|else
name|to
operator|->
name|q_status
operator|=
literal|"5.3.4"
expr_stmt|;
comment|/* set to->q_rstatus = NULL; or to the following? */
name|usrerrenh
argument_list|(
name|to
operator|->
name|q_status
argument_list|,
literal|"552 Message is too large; %ld bytes max"
argument_list|,
name|m
operator|->
name|m_maxsize
argument_list|)
expr_stmt|;
name|markfailure
argument_list|(
name|e
argument_list|,
name|to
argument_list|,
name|NULL
argument_list|,
name|EX_UNAVAILABLE
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|giveresponse
argument_list|(
name|EX_UNAVAILABLE
argument_list|,
name|to
operator|->
name|q_status
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|ctladdr
argument_list|,
name|xstart
argument_list|,
name|e
argument_list|,
name|to
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|SM_SET_H_ERRNO
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ovr
operator|=
name|true
expr_stmt|;
comment|/* do config file checking of compatibility */
name|quarantine
operator|=
operator|(
name|e
operator|->
name|e_quarmsg
operator|!=
name|NULL
operator|)
expr_stmt|;
name|rcode
operator|=
name|rscheck
argument_list|(
literal|"check_compat"
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|,
name|to
operator|->
name|q_paddr
argument_list|,
name|e
argument_list|,
name|RSF_RMCOMM
operator||
name|RSF_COUNT
argument_list|,
literal|3
argument_list|,
name|NULL
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcode
operator|==
name|EX_OK
condition|)
block|{
comment|/* do in-code checking if not discarding */
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|EF_DISCARD
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|rcode
operator|=
name|checkcompat
argument_list|(
name|to
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|ovr
operator|=
name|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rcode
operator|!=
name|EX_OK
condition|)
block|{
name|markfailure
argument_list|(
name|e
argument_list|,
name|to
argument_list|,
name|NULL
argument_list|,
name|rcode
argument_list|,
name|ovr
argument_list|)
expr_stmt|;
name|giveresponse
argument_list|(
name|rcode
argument_list|,
name|to
operator|->
name|q_status
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|ctladdr
argument_list|,
name|xstart
argument_list|,
name|e
argument_list|,
name|to
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|quarantine
operator|&&
name|e
operator|->
name|e_quarmsg
operator|!=
name|NULL
condition|)
block|{
comment|/* 			**  check_compat or checkcompat() has tried 			**  to quarantine but that isn't supported. 			**  Revert the attempt. 			*/
name|e
operator|->
name|e_quarmsg
operator|=
name|NULL
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{quarantine}"
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|EF_DISCARD
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|10
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"deliver: discarding recipient "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|to
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
comment|/* pretend the message was sent */
comment|/* XXX should we log something here? */
name|to
operator|->
name|q_state
operator|=
name|QS_DISCARDED
expr_stmt|;
comment|/* 			**  Remove discard bit to prevent discard of 			**  future recipients.  This is safe because the 			**  true "global discard" has been handled before 			**  we get here. 			*/
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_DISCARD
expr_stmt|;
continue|continue;
block|}
comment|/* 		**  Strip quote bits from names if the mailer is dumb 		**	about them. 		*/
if|if
condition|(
name|bitnset
argument_list|(
name|M_STRIPQ
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
name|stripquotes
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|stripquotes
argument_list|(
name|host
argument_list|)
expr_stmt|;
block|}
comment|/* 		**  Strip all leading backslashes if requested and the 		**  next character is alphanumerical (the latter can 		**  probably relaxed a bit, see RFC2821). 		*/
if|if
condition|(
name|bitnset
argument_list|(
name|M_STRIPBACKSL
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|&&
name|user
index|[
literal|0
index|]
operator|==
literal|'\\'
condition|)
name|stripbackslash
argument_list|(
name|user
argument_list|)
expr_stmt|;
comment|/* hack attack -- delivermail compatibility */
if|if
condition|(
name|m
operator|==
name|ProgMailer
operator|&&
operator|*
name|user
operator|==
literal|'|'
condition|)
name|user
operator|++
expr_stmt|;
comment|/* 		**  If an error message has already been given, don't 		**	bother to send to this address. 		** 		**>>>>>>>>>> This clause assumes that the local mailer 		**>> NOTE>> cannot do any further aliasing; that 		**>>>>>>>>>> function is subsumed by sendmail. 		*/
if|if
condition|(
operator|!
name|QS_IS_OK
argument_list|(
name|to
operator|->
name|q_state
argument_list|)
condition|)
continue|continue;
comment|/* 		**  See if this user name is "special". 		**	If the user name has a slash in it, assume that this 		**	is a file -- send it off without further ado.  Note 		**	that this type of addresses is not processed along 		**	with the others, so we fudge on the To person. 		*/
if|if
condition|(
name|strcmp
argument_list|(
name|m
operator|->
name|m_mailer
argument_list|,
literal|"[FILE]"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'u'
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|p
operator|=
name|to
operator|->
name|q_home
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|&&
name|ctladdr
operator|!=
name|NULL
condition|)
name|p
operator|=
name|ctladdr
operator|->
name|q_home
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'z'
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|expand
argument_list|(
name|m
operator|->
name|m_argv
index|[
literal|1
index|]
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|>
literal|0
condition|)
name|rcode
operator|=
name|mailfile
argument_list|(
name|buf
argument_list|,
name|m
argument_list|,
name|ctladdr
argument_list|,
name|SFF_CREAT
argument_list|,
name|e
argument_list|)
expr_stmt|;
else|else
block|{
name|syserr
argument_list|(
literal|"empty filename specification for mailer %s"
argument_list|,
name|m
operator|->
name|m_name
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|EX_CONFIG
expr_stmt|;
block|}
name|giveresponse
argument_list|(
name|rcode
argument_list|,
name|to
operator|->
name|q_status
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|ctladdr
argument_list|,
name|xstart
argument_list|,
name|e
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|markfailure
argument_list|(
name|e
argument_list|,
name|to
argument_list|,
name|NULL
argument_list|,
name|rcode
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_nsent
operator|++
expr_stmt|;
if|if
condition|(
name|rcode
operator|==
name|EX_OK
condition|)
block|{
name|to
operator|->
name|q_state
operator|=
name|QS_SENT
expr_stmt|;
if|if
condition|(
name|bitnset
argument_list|(
name|M_LOCALMAILER
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|&&
name|bitset
argument_list|(
name|QPINGONSUCCESS
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
condition|)
block|{
name|to
operator|->
name|q_flags
operator||=
name|QDELIVERED
expr_stmt|;
name|to
operator|->
name|q_status
operator|=
literal|"2.1.5"
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s... Successfully delivered\n"
argument_list|,
name|to
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
block|}
block|}
name|to
operator|->
name|q_statdate
operator|=
name|curtime
argument_list|()
expr_stmt|;
name|markstats
argument_list|(
name|e
argument_list|,
name|to
argument_list|,
name|STATS_NORMAL
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		**  Address is verified -- add this user to mailer 		**  argv, and add it to the print list of recipients. 		*/
comment|/* link together the chain of recipients */
name|to
operator|->
name|q_tchain
operator|=
name|tochain
expr_stmt|;
name|tochain
operator|=
name|to
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
literal|"[CHAIN]"
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'u'
argument_list|,
name|user
argument_list|)
expr_stmt|;
comment|/* to user */
name|p
operator|=
name|to
operator|->
name|q_home
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|&&
name|ctladdr
operator|!=
name|NULL
condition|)
name|p
operator|=
name|ctladdr
operator|->
name|q_home
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'z'
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* user's home */
comment|/* set the ${dsn_notify} macro if applicable */
if|if
condition|(
name|bitset
argument_list|(
name|QHASNOTIFY
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
condition|)
block|{
name|char
name|notify
index|[
name|MAXLINE
index|]
decl_stmt|;
name|notify
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|QPINGONSUCCESS
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|notify
argument_list|,
literal|"SUCCESS,"
argument_list|,
sizeof|sizeof
name|notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|QPINGONFAILURE
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|notify
argument_list|,
literal|"FAILURE,"
argument_list|,
sizeof|sizeof
name|notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|QPINGONDELAY
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|notify
argument_list|,
literal|"DELAY,"
argument_list|,
sizeof|sizeof
name|notify
argument_list|)
expr_stmt|;
comment|/* Set to NEVER or drop trailing comma */
if|if
condition|(
name|notify
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|notify
argument_list|,
literal|"NEVER"
argument_list|,
sizeof|sizeof
name|notify
argument_list|)
expr_stmt|;
else|else
name|notify
index|[
name|strlen
argument_list|(
name|notify
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{dsn_notify}"
argument_list|)
argument_list|,
name|notify
argument_list|)
expr_stmt|;
block|}
else|else
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{dsn_notify}"
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		**  Expand out this user into argument list. 		*/
if|if
condition|(
operator|!
name|clever
condition|)
block|{
name|expand
argument_list|(
operator|*
name|mvp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|e
argument_list|)
expr_stmt|;
operator|*
name|pvp
operator|++
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|>=
operator|&
name|pv
index|[
name|MAXPV
operator|-
literal|2
index|]
condition|)
block|{
comment|/* allow some space for trailing parms */
break|break;
block|}
block|}
block|}
comment|/* see if any addresses still exist */
if|if
condition|(
name|tochain
operator|==
name|NULL
condition|)
block|{
name|rcode
operator|=
literal|0
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* print out messages as full list */
name|strsize
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|to
operator|=
name|tochain
init|;
name|to
operator|!=
name|NULL
condition|;
name|to
operator|=
name|to
operator|->
name|q_tchain
control|)
name|strsize
operator|+=
name|strlen
argument_list|(
name|to
operator|->
name|q_paddr
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|strsize
operator|<
name|TOBUFSIZE
condition|)
name|strsize
operator|=
name|TOBUFSIZE
expr_stmt|;
if|if
condition|(
name|strsize
operator|>
name|tobufsize
condition|)
block|{
name|SM_FREE_CLR
argument_list|(
name|tobuf
argument_list|)
expr_stmt|;
name|tobuf
operator|=
name|sm_pmalloc_x
argument_list|(
name|strsize
argument_list|)
expr_stmt|;
name|tobufsize
operator|=
name|strsize
expr_stmt|;
block|}
name|p
operator|=
name|tobuf
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|to
operator|=
name|tochain
init|;
name|to
operator|!=
name|NULL
condition|;
name|to
operator|=
name|to
operator|->
name|q_tchain
control|)
block|{
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|p
argument_list|,
name|tobufsize
operator|-
operator|(
name|p
operator|-
name|tobuf
operator|)
argument_list|,
literal|2
argument_list|,
literal|","
argument_list|,
name|to
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|e_to
operator|=
name|tobuf
operator|+
literal|1
expr_stmt|;
comment|/* 	**  Fill out any parameters after the $u parameter. 	*/
if|if
condition|(
operator|!
name|clever
condition|)
block|{
while|while
condition|(
operator|*
operator|++
name|mvp
operator|!=
name|NULL
condition|)
block|{
name|expand
argument_list|(
operator|*
name|mvp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|e
argument_list|)
expr_stmt|;
operator|*
name|pvp
operator|++
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|>=
operator|&
name|pv
index|[
name|MAXPV
index|]
condition|)
name|syserr
argument_list|(
literal|"554 5.3.0 deliver: pv overflow after $u for %s"
argument_list|,
name|pv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|pvp
operator|++
operator|=
name|NULL
expr_stmt|;
comment|/* 	**  Call the mailer. 	**	The argument vector gets built, pipes 	**	are created as necessary, and we fork& exec as 	**	appropriate. 	**	If we are running SMTP, we just need to clean up. 	*/
comment|/* XXX this seems a bit wierd */
if|if
condition|(
name|ctladdr
operator|==
name|NULL
operator|&&
name|m
operator|!=
name|ProgMailer
operator|&&
name|m
operator|!=
name|FileMailer
operator|&&
name|bitset
argument_list|(
name|QGOODUID
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_flags
argument_list|)
condition|)
name|ctladdr
operator|=
operator|&
name|e
operator|->
name|e_from
expr_stmt|;
if|#
directive|if
name|NAMED_BIND
if|if
condition|(
name|ConfigLevel
operator|<
literal|2
condition|)
name|_res
operator|.
name|options
operator|&=
operator|~
operator|(
name|RES_DEFNAMES
operator||
name|RES_DNSRCH
operator|)
expr_stmt|;
comment|/* XXX */
endif|#
directive|endif
comment|/* NAMED_BIND */
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"openmailer:"
argument_list|)
expr_stmt|;
name|printav
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|pv
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|SM_SET_H_ERRNO
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|CurHostName
operator|=
name|NULL
expr_stmt|;
comment|/* 	**  Deal with the special case of mail handled through an IPC 	**  connection. 	**	In this case we don't actually fork.  We must be 	**	running SMTP for this to work.  We will return a 	**	zero pid to indicate that we are running IPC. 	**  We also handle a debug version that just talks to stdin/out. 	*/
name|curhost
operator|=
name|NULL
expr_stmt|;
name|SmtpPhase
operator|=
name|NULL
expr_stmt|;
name|mci
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|XDEBUG
block|{
name|char
name|wbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
comment|/* make absolutely certain 0, 1, and 2 are in use */
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|wbuf
argument_list|,
sizeof|sizeof
name|wbuf
argument_list|,
literal|"%s... openmailer(%s)"
argument_list|,
name|shortenstring
argument_list|(
name|e
operator|->
name|e_to
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|,
name|m
operator|->
name|m_name
argument_list|)
expr_stmt|;
name|checkfd012
argument_list|(
name|wbuf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* XDEBUG */
comment|/* check for 8-bit available */
if|if
condition|(
name|bitset
argument_list|(
name|EF_HAS8BIT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
name|bitnset
argument_list|(
name|M_7BITS
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|&&
operator|(
name|bitset
argument_list|(
name|EF_DONT_MIME
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|||
operator|!
operator|(
name|bitset
argument_list|(
name|MM_MIME8BIT
argument_list|,
name|MimeMode
argument_list|)
operator|||
operator|(
name|bitset
argument_list|(
name|EF_IS_MIME
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
name|bitset
argument_list|(
name|MM_CVTMIME
argument_list|,
name|MimeMode
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|e
operator|->
name|e_status
operator|=
literal|"5.6.3"
expr_stmt|;
name|usrerrenh
argument_list|(
name|e
operator|->
name|e_status
argument_list|,
literal|"554 Cannot send 8-bit data to 7-bit destination"
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|EX_DATAERR
expr_stmt|;
goto|goto
name|give_up
goto|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|62
argument_list|,
literal|8
argument_list|)
condition|)
name|checkfds
argument_list|(
literal|"before delivery"
argument_list|)
expr_stmt|;
comment|/* check for Local Person Communication -- not for mortals!!! */
if|if
condition|(
name|strcmp
argument_list|(
name|m
operator|->
name|m_mailer
argument_list|,
literal|"[LPC]"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|clever
condition|)
block|{
comment|/* flush any expired connections */
operator|(
name|void
operator|)
name|mci_scan
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* try to get a cached connection or just a slot */
name|mci
operator|=
name|mci_get
argument_list|(
name|m
operator|->
name|m_name
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_host
operator|==
name|NULL
condition|)
name|mci
operator|->
name|mci_host
operator|=
name|m
operator|->
name|m_name
expr_stmt|;
name|CurHostName
operator|=
name|mci
operator|->
name|mci_host
expr_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_CLOSED
condition|)
block|{
name|message
argument_list|(
literal|"Using cached SMTP/LPC connection for %s..."
argument_list|,
name|m
operator|->
name|m_name
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_deliveries
operator|++
expr_stmt|;
goto|goto
name|do_transfer
goto|;
block|}
block|}
else|else
block|{
name|mci
operator|=
name|mci_new
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|)
expr_stmt|;
block|}
name|mci
operator|->
name|mci_in
operator|=
name|smioin
expr_stmt|;
name|mci
operator|->
name|mci_out
operator|=
name|smioout
expr_stmt|;
name|mci
operator|->
name|mci_mailer
operator|=
name|m
expr_stmt|;
name|mci
operator|->
name|mci_host
operator|=
name|m
operator|->
name|m_name
expr_stmt|;
if|if
condition|(
name|clever
condition|)
block|{
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_OPENING
expr_stmt|;
name|mci_cache
argument_list|(
name|mci
argument_list|)
expr_stmt|;
block|}
else|else
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_OPEN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|m
operator|->
name|m_mailer
argument_list|,
literal|"[IPC]"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pv
index|[
literal|0
index|]
operator|==
name|NULL
operator|||
name|pv
index|[
literal|1
index|]
operator|==
name|NULL
operator|||
name|pv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|syserr
argument_list|(
literal|"null destination for %s mailer"
argument_list|,
name|m
operator|->
name|m_mailer
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|EX_CONFIG
expr_stmt|;
goto|goto
name|give_up
goto|;
block|}
if|#
directive|if
name|NETUNIX
if|if
condition|(
name|strcmp
argument_list|(
name|pv
index|[
literal|0
index|]
argument_list|,
literal|"FILE"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|curhost
operator|=
name|CurHostName
operator|=
literal|"localhost"
expr_stmt|;
name|mux_path
operator|=
name|pv
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* NETUNIX */
block|{
name|CurHostName
operator|=
name|pv
index|[
literal|1
index|]
expr_stmt|;
name|curhost
operator|=
name|hostsignature
argument_list|(
name|m
argument_list|,
name|pv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curhost
operator|==
name|NULL
operator|||
name|curhost
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|syserr
argument_list|(
literal|"null host signature for %s"
argument_list|,
name|pv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|EX_CONFIG
expr_stmt|;
goto|goto
name|give_up
goto|;
block|}
if|if
condition|(
operator|!
name|clever
condition|)
block|{
name|syserr
argument_list|(
literal|"554 5.3.5 non-clever IPC"
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|EX_CONFIG
expr_stmt|;
goto|goto
name|give_up
goto|;
block|}
if|if
condition|(
name|pv
index|[
literal|2
index|]
operator|!=
name|NULL
if|#
directive|if
name|NETUNIX
operator|&&
name|mux_path
operator|==
name|NULL
endif|#
directive|endif
comment|/* NETUNIX */
condition|)
block|{
name|port
operator|=
name|htons
argument_list|(
operator|(
name|unsigned
name|short
operator|)
name|atoi
argument_list|(
name|pv
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|NO_GETSERVBYNAME
name|syserr
argument_list|(
literal|"Invalid port number: %s"
argument_list|,
name|pv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* NO_GETSERVBYNAME */
name|struct
name|servent
modifier|*
name|sp
init|=
name|getservbyname
argument_list|(
name|pv
index|[
literal|2
index|]
argument_list|,
literal|"tcp"
argument_list|)
decl_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"Service %s unknown"
argument_list|,
name|pv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
name|port
operator|=
name|sp
operator|->
name|s_port
expr_stmt|;
endif|#
directive|endif
comment|/* NO_GETSERVBYNAME */
block|}
block|}
name|nummxhosts
operator|=
name|parse_hostsignature
argument_list|(
name|curhost
argument_list|,
name|mxhosts
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|TimeOuts
operator|.
name|to_aconnect
operator|>
literal|0
condition|)
name|enough
operator|=
name|curtime
argument_list|()
operator|+
name|TimeOuts
operator|.
name|to_aconnect
expr_stmt|;
name|tryhost
label|:
while|while
condition|(
name|hostnum
operator|<
name|nummxhosts
condition|)
block|{
name|char
name|sep
init|=
literal|':'
decl_stmt|;
name|char
modifier|*
name|endp
decl_stmt|;
specifier|static
name|char
name|hostbuf
index|[
name|MAXNAME
operator|+
literal|1
index|]
decl_stmt|;
name|bool
name|tried_fallbacksmarthost
init|=
name|false
decl_stmt|;
if|#
directive|if
name|NETINET6
if|if
condition|(
operator|*
name|mxhosts
index|[
name|hostnum
index|]
operator|==
literal|'['
condition|)
block|{
name|endp
operator|=
name|strchr
argument_list|(
name|mxhosts
index|[
name|hostnum
index|]
operator|+
literal|1
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|!=
name|NULL
condition|)
name|endp
operator|=
name|strpbrk
argument_list|(
name|endp
operator|+
literal|1
argument_list|,
literal|":,"
argument_list|)
expr_stmt|;
block|}
else|else
name|endp
operator|=
name|strpbrk
argument_list|(
name|mxhosts
index|[
name|hostnum
index|]
argument_list|,
literal|":,"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* NETINET6 */
name|endp
operator|=
name|strpbrk
argument_list|(
name|mxhosts
index|[
name|hostnum
index|]
argument_list|,
literal|":,"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NETINET6 */
if|if
condition|(
name|endp
operator|!=
name|NULL
condition|)
block|{
name|sep
operator|=
operator|*
name|endp
expr_stmt|;
operator|*
name|endp
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|hostnum
operator|==
literal|1
operator|&&
name|skip_back
operator|!=
name|NULL
condition|)
block|{
comment|/* 				**  Coattail piggybacking is no longer an 				**  option with the mail host next to be tried 				**  no longer the lowest MX preference 				**  (hostnum == 1 meaning we're on the second 				**  preference). We do not try to coattail 				**  piggyback more than the first MX preference. 				**  Revert 'tochain' to last location for 				**  coincidental piggybacking. This works this 				**  easily because the q_tchain kept getting 				**  added to the top of the linked list. 				*/
name|tochain
operator|=
name|skip_back
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|mxhosts
index|[
name|hostnum
index|]
operator|==
literal|'\0'
condition|)
block|{
name|syserr
argument_list|(
literal|"deliver: null host name in signature"
argument_list|)
expr_stmt|;
name|hostnum
operator|++
expr_stmt|;
if|if
condition|(
name|endp
operator|!=
name|NULL
condition|)
operator|*
name|endp
operator|=
name|sep
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|hostbuf
argument_list|,
name|mxhosts
index|[
name|hostnum
index|]
argument_list|,
sizeof|sizeof
name|hostbuf
argument_list|)
expr_stmt|;
name|hostnum
operator|++
expr_stmt|;
if|if
condition|(
name|endp
operator|!=
name|NULL
condition|)
operator|*
name|endp
operator|=
name|sep
expr_stmt|;
name|one_last_try
label|:
comment|/* see if we already know that this host is fried */
name|CurHostName
operator|=
name|hostbuf
expr_stmt|;
name|mci
operator|=
name|mci_get
argument_list|(
name|hostbuf
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_CLOSED
condition|)
block|{
name|char
modifier|*
name|type
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"openmailer: "
argument_list|)
expr_stmt|;
name|mci_dump
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|mci
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|CurHostName
operator|=
name|mci
operator|->
name|mci_host
expr_stmt|;
if|if
condition|(
name|bitnset
argument_list|(
name|M_LMTP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|type
operator|=
literal|"L"
expr_stmt|;
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_ESMTP
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
name|type
operator|=
literal|"ES"
expr_stmt|;
else|else
name|type
operator|=
literal|"S"
expr_stmt|;
name|message
argument_list|(
literal|"Using cached %sMTP connection to %s via %s..."
argument_list|,
name|type
argument_list|,
name|hostbuf
argument_list|,
name|m
operator|->
name|m_name
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_deliveries
operator|++
expr_stmt|;
break|break;
block|}
name|mci
operator|->
name|mci_mailer
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_exitstat
operator|!=
name|EX_OK
condition|)
block|{
if|if
condition|(
name|mci
operator|->
name|mci_exitstat
operator|==
name|EX_TEMPFAIL
condition|)
name|goodmxfound
operator|=
name|true
expr_stmt|;
comment|/* Try FallbackSmartHost? */
if|if
condition|(
name|should_try_fbsh
argument_list|(
name|e
argument_list|,
operator|&
name|tried_fallbacksmarthost
argument_list|,
name|hostbuf
argument_list|,
sizeof|sizeof
name|hostbuf
argument_list|,
name|mci
operator|->
name|mci_exitstat
argument_list|)
condition|)
goto|goto
name|one_last_try
goto|;
continue|continue;
block|}
if|if
condition|(
name|mci_lock_host
argument_list|(
name|mci
argument_list|)
operator|!=
name|EX_OK
condition|)
block|{
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|EX_TEMPFAIL
argument_list|,
literal|"4.4.5"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|goodmxfound
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
comment|/* try the connection */
name|sm_setproctitle
argument_list|(
name|true
argument_list|,
name|e
argument_list|,
literal|"%s %s: %s"
argument_list|,
name|qid_printname
argument_list|(
name|e
argument_list|)
argument_list|,
name|hostbuf
argument_list|,
literal|"user open"
argument_list|)
expr_stmt|;
if|#
directive|if
name|NETUNIX
if|if
condition|(
name|mux_path
operator|!=
name|NULL
condition|)
block|{
name|message
argument_list|(
literal|"Connecting to %s via %s..."
argument_list|,
name|mux_path
argument_list|,
name|m
operator|->
name|m_name
argument_list|)
expr_stmt|;
name|i
operator|=
name|makeconnection_ds
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mux_path
argument_list|,
name|mci
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* NETUNIX */
block|{
if|if
condition|(
name|port
operator|==
literal|0
condition|)
name|message
argument_list|(
literal|"Connecting to %s via %s..."
argument_list|,
name|hostbuf
argument_list|,
name|m
operator|->
name|m_name
argument_list|)
expr_stmt|;
else|else
name|message
argument_list|(
literal|"Connecting to %s port %d via %s..."
argument_list|,
name|hostbuf
argument_list|,
name|ntohs
argument_list|(
name|port
argument_list|)
argument_list|,
name|m
operator|->
name|m_name
argument_list|)
expr_stmt|;
name|i
operator|=
name|makeconnection
argument_list|(
name|hostbuf
argument_list|,
name|port
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|enough
argument_list|)
expr_stmt|;
block|}
name|mci
operator|->
name|mci_errno
operator|=
name|errno
expr_stmt|;
name|mci
operator|->
name|mci_lastuse
operator|=
name|curtime
argument_list|()
expr_stmt|;
name|mci
operator|->
name|mci_deliveries
operator|=
literal|0
expr_stmt|;
name|mci
operator|->
name|mci_exitstat
operator|=
name|i
expr_stmt|;
if|#
directive|if
name|NAMED_BIND
name|mci
operator|->
name|mci_herrno
operator|=
name|h_errno
expr_stmt|;
endif|#
directive|endif
comment|/* NAMED_BIND */
comment|/* 			**  Have we tried long enough to get a connection? 			**	If yes, skip to the fallback MX hosts 			**	(if existent). 			*/
if|if
condition|(
name|enough
operator|>
literal|0
operator|&&
name|mci
operator|->
name|mci_lastuse
operator|>=
name|enough
condition|)
block|{
name|int
name|h
decl_stmt|;
if|#
directive|if
name|NAMED_BIND
specifier|extern
name|int
name|NumFallbackMXHosts
decl_stmt|;
else|#
directive|else
comment|/* NAMED_BIND */
specifier|const
name|int
name|NumFallbackMXHosts
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* NAMED_BIND */
if|if
condition|(
name|hostnum
operator|<
name|nummxhosts
operator|&&
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Timeout.to_aconnect occurred before exhausting all addresses"
argument_list|)
expr_stmt|;
comment|/* turn off timeout if fallback available */
if|if
condition|(
name|NumFallbackMXHosts
operator|>
literal|0
condition|)
name|enough
operator|=
literal|0
expr_stmt|;
comment|/* skip to a fallback MX host */
name|h
operator|=
name|nummxhosts
operator|-
name|NumFallbackMXHosts
expr_stmt|;
if|if
condition|(
name|hostnum
operator|<
name|h
condition|)
name|hostnum
operator|=
name|h
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|EX_OK
condition|)
block|{
name|goodmxfound
operator|=
name|true
expr_stmt|;
name|markstats
argument_list|(
name|e
argument_list|,
name|firstto
argument_list|,
name|STATS_CONNECT
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_OPENING
expr_stmt|;
name|mci_cache
argument_list|(
name|mci
argument_list|)
expr_stmt|;
if|if
condition|(
name|TrafficLogFile
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|TrafficLogFile
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%05d === CONNECT %s\n"
argument_list|,
operator|(
name|int
operator|)
name|CurrentPid
argument_list|,
name|hostbuf
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* Try FallbackSmartHost? */
if|if
condition|(
name|should_try_fbsh
argument_list|(
name|e
argument_list|,
operator|&
name|tried_fallbacksmarthost
argument_list|,
name|hostbuf
argument_list|,
sizeof|sizeof
name|hostbuf
argument_list|,
name|i
argument_list|)
condition|)
goto|goto
name|one_last_try
goto|;
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"openmailer: makeconnection => stat=%d, errno=%d\n"
argument_list|,
name|i
argument_list|,
name|errno
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|EX_TEMPFAIL
condition|)
name|goodmxfound
operator|=
name|true
expr_stmt|;
name|mci_unlock_host
argument_list|(
name|mci
argument_list|)
expr_stmt|;
block|}
comment|/* enter status of this host */
name|setstat
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* should print some message here for -v mode */
block|}
if|if
condition|(
name|mci
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"deliver: no host name"
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|EX_SOFTWARE
expr_stmt|;
goto|goto
name|give_up
goto|;
block|}
name|mci
operator|->
name|mci_pid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* flush any expired connections */
operator|(
name|void
operator|)
name|mci_scan
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|mci
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bitnset
argument_list|(
name|M_LMTP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
comment|/* try to get a cached connection */
name|mci
operator|=
name|mci_get
argument_list|(
name|m
operator|->
name|m_name
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_host
operator|==
name|NULL
condition|)
name|mci
operator|->
name|mci_host
operator|=
name|m
operator|->
name|m_name
expr_stmt|;
name|CurHostName
operator|=
name|mci
operator|->
name|mci_host
expr_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_CLOSED
condition|)
block|{
name|message
argument_list|(
literal|"Using cached LMTP connection for %s..."
argument_list|,
name|m
operator|->
name|m_name
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_deliveries
operator|++
expr_stmt|;
goto|goto
name|do_transfer
goto|;
block|}
block|}
comment|/* announce the connection to verbose listeners */
if|if
condition|(
name|host
operator|==
name|NULL
operator|||
name|host
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|message
argument_list|(
literal|"Connecting to %s..."
argument_list|,
name|m
operator|->
name|m_name
argument_list|)
expr_stmt|;
else|else
name|message
argument_list|(
literal|"Connecting to %s via %s..."
argument_list|,
name|host
argument_list|,
name|m
operator|->
name|m_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TrafficLogFile
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|TrafficLogFile
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%05d === EXEC"
argument_list|,
operator|(
name|int
operator|)
name|CurrentPid
argument_list|)
expr_stmt|;
for|for
control|(
name|av
operator|=
name|pv
init|;
operator|*
name|av
operator|!=
name|NULL
condition|;
name|av
operator|++
control|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|TrafficLogFile
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|" %s"
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|TrafficLogFile
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|XDEBUG
name|checkfd012
argument_list|(
literal|"before creating mail pipe"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XDEBUG */
comment|/* create a pipe to shove the mail through */
if|if
condition|(
name|pipe
argument_list|(
name|mpvect
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"%s... openmailer(%s): pipe (to mailer)"
argument_list|,
name|shortenstring
argument_list|(
name|e
operator|->
name|e_to
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|,
name|m
operator|->
name|m_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"openmailer: NULL\n"
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|EX_OSERR
expr_stmt|;
goto|goto
name|give_up
goto|;
block|}
if|#
directive|if
name|XDEBUG
comment|/* make sure we didn't get one of the standard I/O files */
if|if
condition|(
name|mpvect
index|[
literal|0
index|]
operator|<
literal|3
operator|||
name|mpvect
index|[
literal|1
index|]
operator|<
literal|3
condition|)
block|{
name|syserr
argument_list|(
literal|"%s... openmailer(%s): bogus mpvect %d %d"
argument_list|,
name|shortenstring
argument_list|(
name|e
operator|->
name|e_to
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|,
name|m
operator|->
name|m_name
argument_list|,
name|mpvect
index|[
literal|0
index|]
argument_list|,
name|mpvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printopenfds
argument_list|(
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"openmailer: NULL\n"
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|EX_OSERR
expr_stmt|;
goto|goto
name|give_up
goto|;
block|}
comment|/* make sure system call isn't dead meat */
name|checkfdopen
argument_list|(
name|mpvect
index|[
literal|0
index|]
argument_list|,
literal|"mpvect[0]"
argument_list|)
expr_stmt|;
name|checkfdopen
argument_list|(
name|mpvect
index|[
literal|1
index|]
argument_list|,
literal|"mpvect[1]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpvect
index|[
literal|0
index|]
operator|==
name|mpvect
index|[
literal|1
index|]
operator|||
operator|(
name|e
operator|->
name|e_lockfp
operator|!=
name|NULL
operator|&&
operator|(
name|mpvect
index|[
literal|0
index|]
operator|==
name|sm_io_getinfo
argument_list|(
name|e
operator|->
name|e_lockfp
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
operator|||
name|mpvect
index|[
literal|1
index|]
operator|==
name|sm_io_getinfo
argument_list|(
name|e
operator|->
name|e_lockfp
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|e_lockfp
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"%s... openmailer(%s): overlapping mpvect %d %d"
argument_list|,
name|shortenstring
argument_list|(
name|e
operator|->
name|e_to
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|,
name|m
operator|->
name|m_name
argument_list|,
name|mpvect
index|[
literal|0
index|]
argument_list|,
name|mpvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|syserr
argument_list|(
literal|"%s... openmailer(%s): overlapping mpvect %d %d, lockfp = %d"
argument_list|,
name|shortenstring
argument_list|(
name|e
operator|->
name|e_to
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|,
name|m
operator|->
name|m_name
argument_list|,
name|mpvect
index|[
literal|0
index|]
argument_list|,
name|mpvect
index|[
literal|1
index|]
argument_list|,
name|sm_io_getinfo
argument_list|(
name|e
operator|->
name|e_lockfp
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* XDEBUG */
comment|/* create a return pipe */
if|if
condition|(
name|pipe
argument_list|(
name|rpvect
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"%s... openmailer(%s): pipe (from mailer)"
argument_list|,
name|shortenstring
argument_list|(
name|e
operator|->
name|e_to
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|,
name|m
operator|->
name|m_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|mpvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|mpvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"openmailer: NULL\n"
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|EX_OSERR
expr_stmt|;
goto|goto
name|give_up
goto|;
block|}
if|#
directive|if
name|XDEBUG
name|checkfdopen
argument_list|(
name|rpvect
index|[
literal|0
index|]
argument_list|,
literal|"rpvect[0]"
argument_list|)
expr_stmt|;
name|checkfdopen
argument_list|(
name|rpvect
index|[
literal|1
index|]
argument_list|,
literal|"rpvect[1]"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XDEBUG */
comment|/* 		**  Actually fork the mailer process. 		**	DOFORK is clever about retrying. 		** 		**	Dispose of SIGCHLD signal catchers that may be laying 		**	around so that endmailer will get it. 		*/
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
condition|)
comment|/* for debugging */
operator|(
name|void
operator|)
name|sm_io_flush
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_flush
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|DOFORK
argument_list|(
name|FORK
argument_list|)
expr_stmt|;
comment|/* pid is set by DOFORK */
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
comment|/* failure */
name|syserr
argument_list|(
literal|"%s... openmailer(%s): cannot fork"
argument_list|,
name|shortenstring
argument_list|(
name|e
operator|->
name|e_to
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|,
name|m
operator|->
name|m_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|mpvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|mpvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|rpvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|rpvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"openmailer: NULL\n"
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|EX_OSERR
expr_stmt|;
goto|goto
name|give_up
goto|;
block|}
elseif|else
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|int
name|save_errno
decl_stmt|;
name|int
name|sff
decl_stmt|;
name|int
name|new_euid
init|=
name|NO_UID
decl_stmt|;
name|int
name|new_ruid
init|=
name|NO_UID
decl_stmt|;
name|int
name|new_gid
init|=
name|NO_GID
decl_stmt|;
name|char
modifier|*
name|user
init|=
name|NULL
decl_stmt|;
name|struct
name|stat
name|stb
decl_stmt|;
specifier|extern
name|int
name|DtableSize
decl_stmt|;
name|CurrentPid
operator|=
name|getpid
argument_list|()
expr_stmt|;
comment|/* clear the events to turn off SIGALRMs */
name|sm_clear_events
argument_list|()
expr_stmt|;
comment|/* Reset global flags */
name|RestartRequest
operator|=
name|NULL
expr_stmt|;
name|RestartWorkGroup
operator|=
name|false
expr_stmt|;
name|ShutdownRequest
operator|=
name|NULL
expr_stmt|;
name|PendingSignal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_lockfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|sm_io_getinfo
argument_list|(
name|e
operator|->
name|e_lockfp
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* child -- set up input& exec mailer */
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGALRM
argument_list|,
name|sm_signal_noop
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGUSR1
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGUSR1
argument_list|,
name|sm_signal_noop
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SIGUSR1 */
if|if
condition|(
name|m
operator|!=
name|FileMailer
operator|||
name|stat
argument_list|(
name|tochain
operator|->
name|q_user
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
name|stb
operator|.
name|st_mode
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|HASSETUSERCONTEXT
comment|/* 			**  Set user resources. 			*/
if|if
condition|(
name|contextaddr
operator|!=
name|NULL
condition|)
block|{
name|int
name|sucflags
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
if|if
condition|(
name|contextaddr
operator|->
name|q_ruser
operator|!=
name|NULL
condition|)
name|pwd
operator|=
name|sm_getpwnam
argument_list|(
name|contextaddr
operator|->
name|q_ruser
argument_list|)
expr_stmt|;
else|else
name|pwd
operator|=
name|sm_getpwnam
argument_list|(
name|contextaddr
operator|->
name|q_user
argument_list|)
expr_stmt|;
name|sucflags
operator|=
name|LOGIN_SETRESOURCES
operator||
name|LOGIN_SETPRIORITY
expr_stmt|;
ifdef|#
directive|ifdef
name|LOGIN_SETMAC
name|sucflags
operator||=
name|LOGIN_SETMAC
expr_stmt|;
endif|#
directive|endif
comment|/* LOGIN_SETMAC */
if|if
condition|(
name|pwd
operator|!=
name|NULL
operator|&&
name|setusercontext
argument_list|(
name|NULL
argument_list|,
name|pwd
argument_list|,
name|pwd
operator|->
name|pw_uid
argument_list|,
name|sucflags
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|suidwarn
condition|)
block|{
name|syserr
argument_list|(
literal|"openmailer: setusercontext() failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_TEMPFAIL
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* HASSETUSERCONTEXT */
if|#
directive|if
name|HASNICE
comment|/* tweak niceness */
if|if
condition|(
name|m
operator|->
name|m_nice
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|nice
argument_list|(
name|m
operator|->
name|m_nice
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HASNICE */
comment|/* reset group id */
if|if
condition|(
name|bitnset
argument_list|(
name|M_SPECIFIC_UID
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_gid
operator|==
name|NO_GID
condition|)
name|new_gid
operator|=
name|RunAsGid
expr_stmt|;
else|else
name|new_gid
operator|=
name|m
operator|->
name|m_gid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|S_ISGID
argument_list|,
name|stb
operator|.
name|st_mode
argument_list|)
condition|)
name|new_gid
operator|=
name|stb
operator|.
name|st_gid
expr_stmt|;
elseif|else
if|if
condition|(
name|ctladdr
operator|!=
name|NULL
operator|&&
name|ctladdr
operator|->
name|q_gid
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|DontInitGroups
condition|)
block|{
name|user
operator|=
name|ctladdr
operator|->
name|q_ruser
expr_stmt|;
if|if
condition|(
name|user
operator|==
name|NULL
condition|)
name|user
operator|=
name|ctladdr
operator|->
name|q_user
expr_stmt|;
if|if
condition|(
name|initgroups
argument_list|(
name|user
argument_list|,
name|ctladdr
operator|->
name|q_gid
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|suidwarn
condition|)
block|{
name|syserr
argument_list|(
literal|"openmailer: initgroups(%s, %d) failed"
argument_list|,
name|user
argument_list|,
name|ctladdr
operator|->
name|q_gid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_TEMPFAIL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|GIDSET_T
name|gidset
index|[
literal|1
index|]
decl_stmt|;
name|gidset
index|[
literal|0
index|]
operator|=
name|ctladdr
operator|->
name|q_gid
expr_stmt|;
if|if
condition|(
name|setgroups
argument_list|(
literal|1
argument_list|,
name|gidset
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|suidwarn
condition|)
block|{
name|syserr
argument_list|(
literal|"openmailer: setgroups() failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_TEMPFAIL
argument_list|)
expr_stmt|;
block|}
block|}
name|new_gid
operator|=
name|ctladdr
operator|->
name|q_gid
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|DontInitGroups
condition|)
block|{
name|user
operator|=
name|DefUser
expr_stmt|;
if|if
condition|(
name|initgroups
argument_list|(
name|DefUser
argument_list|,
name|DefGid
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|suidwarn
condition|)
block|{
name|syserr
argument_list|(
literal|"openmailer: initgroups(%s, %d) failed"
argument_list|,
name|DefUser
argument_list|,
name|DefGid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_TEMPFAIL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|GIDSET_T
name|gidset
index|[
literal|1
index|]
decl_stmt|;
name|gidset
index|[
literal|0
index|]
operator|=
name|DefGid
expr_stmt|;
if|if
condition|(
name|setgroups
argument_list|(
literal|1
argument_list|,
name|gidset
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|suidwarn
condition|)
block|{
name|syserr
argument_list|(
literal|"openmailer: setgroups() failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_TEMPFAIL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
operator|->
name|m_gid
operator|==
name|NO_GID
condition|)
name|new_gid
operator|=
name|DefGid
expr_stmt|;
else|else
name|new_gid
operator|=
name|m
operator|->
name|m_gid
expr_stmt|;
block|}
if|if
condition|(
name|new_gid
operator|!=
name|NO_GID
condition|)
block|{
if|if
condition|(
name|RunAsUid
operator|!=
literal|0
operator|&&
name|bitnset
argument_list|(
name|M_SPECIFIC_UID
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|&&
name|new_gid
operator|!=
name|getgid
argument_list|()
operator|&&
name|new_gid
operator|!=
name|getegid
argument_list|()
condition|)
block|{
comment|/* Only root can change the gid */
name|syserr
argument_list|(
literal|"openmailer: insufficient privileges to change gid, RunAsUid=%d, new_gid=%d, gid=%d, egid=%d"
argument_list|,
operator|(
name|int
operator|)
name|RunAsUid
argument_list|,
operator|(
name|int
operator|)
name|new_gid
argument_list|,
operator|(
name|int
operator|)
name|getgid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getegid
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_TEMPFAIL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setgid
argument_list|(
name|new_gid
argument_list|)
operator|<
literal|0
operator|&&
name|suidwarn
condition|)
block|{
name|syserr
argument_list|(
literal|"openmailer: setgid(%ld) failed"
argument_list|,
operator|(
name|long
operator|)
name|new_gid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_TEMPFAIL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* change root to some "safe" directory */
if|if
condition|(
name|m
operator|->
name|m_rootdir
operator|!=
name|NULL
condition|)
block|{
name|expand
argument_list|(
name|m
operator|->
name|m_rootdir
argument_list|,
name|cbuf
argument_list|,
sizeof|sizeof
name|cbuf
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|20
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"openmailer: chroot %s\n"
argument_list|,
name|cbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|chroot
argument_list|(
name|cbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"openmailer: Cannot chroot(%s)"
argument_list|,
name|cbuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_TEMPFAIL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chdir
argument_list|(
literal|"/"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"openmailer: cannot chdir(/)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_TEMPFAIL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* reset user id */
name|endpwent
argument_list|()
expr_stmt|;
name|sm_mbdb_terminate
argument_list|()
expr_stmt|;
if|if
condition|(
name|bitnset
argument_list|(
name|M_SPECIFIC_UID
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_uid
operator|==
name|NO_UID
condition|)
name|new_euid
operator|=
name|RunAsUid
expr_stmt|;
else|else
name|new_euid
operator|=
name|m
operator|->
name|m_uid
expr_stmt|;
comment|/* 				**  Undo the effects of the uid change in main 				**  for signal handling.  The real uid may 				**  be used by mailer in adding a "From " 				**  line. 				*/
if|if
condition|(
name|RealUid
operator|!=
literal|0
operator|&&
name|RealUid
operator|!=
name|getuid
argument_list|()
condition|)
block|{
if|#
directive|if
name|MAILER_SETUID_METHOD
operator|==
name|USE_SETEUID
if|#
directive|if
name|HASSETREUID
if|if
condition|(
name|setreuid
argument_list|(
name|RealUid
argument_list|,
name|geteuid
argument_list|()
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"openmailer: setreuid(%d, %d) failed"
argument_list|,
operator|(
name|int
operator|)
name|RealUid
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HASSETREUID */
endif|#
directive|endif
comment|/* MAILER_SETUID_METHOD == USE_SETEUID */
if|#
directive|if
name|MAILER_SETUID_METHOD
operator|==
name|USE_SETREUID
name|new_ruid
operator|=
name|RealUid
expr_stmt|;
endif|#
directive|endif
comment|/* MAILER_SETUID_METHOD == USE_SETREUID */
block|}
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|S_ISUID
argument_list|,
name|stb
operator|.
name|st_mode
argument_list|)
condition|)
name|new_ruid
operator|=
name|stb
operator|.
name|st_uid
expr_stmt|;
elseif|else
if|if
condition|(
name|ctladdr
operator|!=
name|NULL
operator|&&
name|ctladdr
operator|->
name|q_uid
operator|!=
literal|0
condition|)
name|new_ruid
operator|=
name|ctladdr
operator|->
name|q_uid
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|->
name|m_uid
operator|!=
name|NO_UID
condition|)
name|new_ruid
operator|=
name|m
operator|->
name|m_uid
expr_stmt|;
else|else
name|new_ruid
operator|=
name|DefUid
expr_stmt|;
if|#
directive|if
name|_FFR_USE_SETLOGIN
comment|/* run disconnected from terminal and set login name */
if|if
condition|(
name|setsid
argument_list|()
operator|>=
literal|0
operator|&&
name|ctladdr
operator|!=
name|NULL
operator|&&
name|ctladdr
operator|->
name|q_uid
operator|!=
literal|0
operator|&&
name|new_euid
operator|==
name|ctladdr
operator|->
name|q_uid
condition|)
block|{
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|pwd
operator|=
name|sm_getpwuid
argument_list|(
name|ctladdr
operator|->
name|q_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|!=
name|NULL
operator|&&
name|suidwarn
condition|)
operator|(
name|void
operator|)
name|setlogin
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _FFR_USE_SETLOGIN */
if|if
condition|(
name|new_euid
operator|!=
name|NO_UID
condition|)
block|{
if|if
condition|(
name|RunAsUid
operator|!=
literal|0
operator|&&
name|new_euid
operator|!=
name|RunAsUid
condition|)
block|{
comment|/* Only root can change the uid */
name|syserr
argument_list|(
literal|"openmailer: insufficient privileges to change uid, new_euid=%d, RunAsUid=%d"
argument_list|,
operator|(
name|int
operator|)
name|new_euid
argument_list|,
operator|(
name|int
operator|)
name|RunAsUid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_TEMPFAIL
argument_list|)
expr_stmt|;
block|}
name|vendor_set_uid
argument_list|(
name|new_euid
argument_list|)
expr_stmt|;
if|#
directive|if
name|MAILER_SETUID_METHOD
operator|==
name|USE_SETEUID
if|if
condition|(
name|seteuid
argument_list|(
name|new_euid
argument_list|)
operator|<
literal|0
operator|&&
name|suidwarn
condition|)
block|{
name|syserr
argument_list|(
literal|"openmailer: seteuid(%ld) failed"
argument_list|,
operator|(
name|long
operator|)
name|new_euid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_TEMPFAIL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MAILER_SETUID_METHOD == USE_SETEUID */
if|#
directive|if
name|MAILER_SETUID_METHOD
operator|==
name|USE_SETREUID
if|if
condition|(
name|setreuid
argument_list|(
name|new_ruid
argument_list|,
name|new_euid
argument_list|)
operator|<
literal|0
operator|&&
name|suidwarn
condition|)
block|{
name|syserr
argument_list|(
literal|"openmailer: setreuid(%ld, %ld) failed"
argument_list|,
operator|(
name|long
operator|)
name|new_ruid
argument_list|,
operator|(
name|long
operator|)
name|new_euid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_TEMPFAIL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MAILER_SETUID_METHOD == USE_SETREUID */
if|#
directive|if
name|MAILER_SETUID_METHOD
operator|==
name|USE_SETUID
if|if
condition|(
name|new_euid
operator|!=
name|geteuid
argument_list|()
operator|&&
name|setuid
argument_list|(
name|new_euid
argument_list|)
operator|<
literal|0
operator|&&
name|suidwarn
condition|)
block|{
name|syserr
argument_list|(
literal|"openmailer: setuid(%ld) failed"
argument_list|,
operator|(
name|long
operator|)
name|new_euid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_TEMPFAIL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MAILER_SETUID_METHOD == USE_SETUID */
block|}
elseif|else
if|if
condition|(
name|new_ruid
operator|!=
name|NO_UID
condition|)
block|{
name|vendor_set_uid
argument_list|(
name|new_ruid
argument_list|)
expr_stmt|;
if|if
condition|(
name|setuid
argument_list|(
name|new_ruid
argument_list|)
operator|<
literal|0
operator|&&
name|suidwarn
condition|)
block|{
name|syserr
argument_list|(
literal|"openmailer: setuid(%ld) failed"
argument_list|,
operator|(
name|long
operator|)
name|new_ruid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_TEMPFAIL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"openmailer: running as r/euid=%d/%d, r/egid=%d/%d\n"
argument_list|,
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getgid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getegid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* move into some "safe" directory */
if|if
condition|(
name|m
operator|->
name|m_execdir
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|p
operator|=
name|m
operator|->
name|m_execdir
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|q
control|)
block|{
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|expand
argument_list|(
name|p
argument_list|,
name|cbuf
argument_list|,
sizeof|sizeof
name|cbuf
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
operator|*
name|q
operator|++
operator|=
literal|':'
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|20
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"openmailer: trydir %s\n"
argument_list|,
name|cbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|chdir
argument_list|(
name|cbuf
argument_list|)
operator|>=
literal|0
condition|)
break|break;
block|}
block|}
comment|/* Check safety of program to be run */
name|sff
operator|=
name|SFF_ROOTOK
operator||
name|SFF_EXECOK
expr_stmt|;
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|DBS_RUNWRITABLEPROGRAM
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
name|sff
operator||=
name|SFF_NOGWFILES
operator||
name|SFF_NOWWFILES
expr_stmt|;
if|if
condition|(
name|bitnset
argument_list|(
name|DBS_RUNPROGRAMINUNSAFEDIRPATH
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
name|sff
operator||=
name|SFF_NOPATHCHECK
expr_stmt|;
else|else
name|sff
operator||=
name|SFF_SAFEDIRPATH
expr_stmt|;
name|ret
operator|=
name|safefile
argument_list|(
name|m
operator|->
name|m_mailer
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|getgid
argument_list|()
argument_list|,
name|user
argument_list|,
name|sff
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Warning: program %s unsafe: %s"
argument_list|,
name|m
operator|->
name|m_mailer
argument_list|,
name|sm_errstring
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
comment|/* arrange to filter std& diag output of command */
operator|(
name|void
operator|)
name|close
argument_list|(
name|rpvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|rpvect
index|[
literal|1
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"%s... openmailer(%s): cannot dup pipe %d for stdout"
argument_list|,
name|shortenstring
argument_list|(
name|e
operator|->
name|e_to
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|,
name|m
operator|->
name|m_name
argument_list|,
name|rpvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|rpvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|STDERR_FILENO
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"%s... openmailer(%s): cannot dup stdout for stderr"
argument_list|,
name|shortenstring
argument_list|(
name|e
operator|->
name|e_to
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|,
name|m
operator|->
name|m_name
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
comment|/* arrange to get standard input */
operator|(
name|void
operator|)
name|close
argument_list|(
name|mpvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|mpvect
index|[
literal|0
index|]
argument_list|,
name|STDIN_FILENO
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"%s... openmailer(%s): cannot dup pipe %d for stdin"
argument_list|,
name|shortenstring
argument_list|(
name|e
operator|->
name|e_to
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|,
name|m
operator|->
name|m_name
argument_list|,
name|mpvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|mpvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* arrange for all the files to be closed */
name|sm_close_on_exec
argument_list|(
name|STDERR_FILENO
operator|+
literal|1
argument_list|,
name|DtableSize
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|_FFR_USE_SETLOGIN
comment|/* run disconnected from terminal */
operator|(
name|void
operator|)
name|setsid
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* !_FFR_USE_SETLOGIN */
comment|/* try to execute the mailer */
operator|(
name|void
operator|)
name|execve
argument_list|(
name|m
operator|->
name|m_mailer
argument_list|,
operator|(
name|ARGV_T
operator|)
name|pv
argument_list|,
operator|(
name|ARGV_T
operator|)
name|UserEnviron
argument_list|)
expr_stmt|;
name|save_errno
operator|=
name|errno
expr_stmt|;
name|syserr
argument_list|(
literal|"Cannot exec %s"
argument_list|,
name|m
operator|->
name|m_mailer
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitnset
argument_list|(
name|M_LOCALMAILER
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|||
name|transienterror
argument_list|(
name|save_errno
argument_list|)
condition|)
name|_exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
comment|/* 		**  Set up return value. 		*/
if|if
condition|(
name|mci
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|clever
condition|)
block|{
comment|/* 				**  Allocate from general heap, not 				**  envelope rpool, because this mci 				**  is going to be cached. 				*/
name|mci
operator|=
name|mci_new
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				**  Prevent a storage leak by allocating 				**  this from the envelope rpool. 				*/
name|mci
operator|=
name|mci_new
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|)
expr_stmt|;
block|}
block|}
name|mci
operator|->
name|mci_mailer
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|clever
condition|)
block|{
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_OPENING
expr_stmt|;
name|mci_cache
argument_list|(
name|mci
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_OPEN
expr_stmt|;
block|}
name|mci
operator|->
name|mci_pid
operator|=
name|pid
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|mpvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_out
operator|=
name|sm_io_open
argument_list|(
name|SmFtStdiofd
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|mpvect
index|[
literal|1
index|]
operator|)
argument_list|,
name|SM_IO_WRONLY_B
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_out
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"deliver: cannot create mailer output channel, fd=%d"
argument_list|,
name|mpvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|mpvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|rpvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|rpvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|EX_OSERR
expr_stmt|;
goto|goto
name|give_up
goto|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|rpvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_in
operator|=
name|sm_io_open
argument_list|(
name|SmFtStdiofd
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|rpvect
index|[
literal|0
index|]
operator|)
argument_list|,
name|SM_IO_RDONLY_B
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_in
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"deliver: cannot create mailer input channel, fd=%d"
argument_list|,
name|mpvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|rpvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_out
operator|=
name|NULL
expr_stmt|;
name|rcode
operator|=
name|EX_OSERR
expr_stmt|;
goto|goto
name|give_up
goto|;
block|}
block|}
comment|/* 	**  If we are in SMTP opening state, send initial protocol. 	*/
if|if
condition|(
name|bitnset
argument_list|(
name|M_7BITS
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|&&
operator|(
operator|!
name|clever
operator|||
name|mci
operator|->
name|mci_state
operator|==
name|MCIS_OPENING
operator|)
condition|)
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_7BIT
expr_stmt|;
if|if
condition|(
name|clever
operator|&&
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_CLOSED
condition|)
block|{
if|#
directive|if
name|STARTTLS
operator|||
name|SASL
name|int
name|dotpos
decl_stmt|;
name|char
modifier|*
name|srvname
decl_stmt|;
specifier|extern
name|SOCKADDR
name|CurHostAddr
decl_stmt|;
endif|#
directive|endif
comment|/* STARTTLS || SASL */
if|#
directive|if
name|SASL
define|#
directive|define
name|DONE_AUTH
parameter_list|(
name|f
parameter_list|)
value|bitset(MCIF_AUTHACT, f)
endif|#
directive|endif
comment|/* SASL */
if|#
directive|if
name|STARTTLS
define|#
directive|define
name|DONE_STARTTLS
parameter_list|(
name|f
parameter_list|)
value|bitset(MCIF_TLSACT, f)
endif|#
directive|endif
comment|/* STARTTLS */
define|#
directive|define
name|ONLY_HELO
parameter_list|(
name|f
parameter_list|)
value|bitset(MCIF_ONLY_EHLO, f)
define|#
directive|define
name|SET_HELO
parameter_list|(
name|f
parameter_list|)
value|f |= MCIF_ONLY_EHLO
define|#
directive|define
name|CLR_HELO
parameter_list|(
name|f
parameter_list|)
value|f&= ~MCIF_ONLY_EHLO
if|#
directive|if
name|STARTTLS
operator|||
name|SASL
comment|/* don't use CurHostName, it is changed in many places */
if|if
condition|(
name|mci
operator|->
name|mci_host
operator|!=
name|NULL
condition|)
block|{
name|srvname
operator|=
name|mci
operator|->
name|mci_host
expr_stmt|;
name|dotpos
operator|=
name|strlen
argument_list|(
name|srvname
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dotpos
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|srvname
index|[
name|dotpos
index|]
operator|==
literal|'.'
condition|)
name|srvname
index|[
name|dotpos
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|dotpos
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mci
operator|->
name|mci_mailer
operator|!=
name|NULL
condition|)
block|{
name|srvname
operator|=
name|mci
operator|->
name|mci_mailer
operator|->
name|m_name
expr_stmt|;
name|dotpos
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|srvname
operator|=
literal|"local"
expr_stmt|;
name|dotpos
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* don't set {server_name} to NULL or "": see getauth() */
name|macdefine
argument_list|(
operator|&
name|mci
operator|->
name|mci_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{server_name}"
argument_list|)
argument_list|,
name|srvname
argument_list|)
expr_stmt|;
comment|/* CurHostAddr is set by makeconnection() and mci_get() */
if|if
condition|(
name|CurHostAddr
operator|.
name|sa
operator|.
name|sa_family
operator|!=
literal|0
condition|)
block|{
name|macdefine
argument_list|(
operator|&
name|mci
operator|->
name|mci_macro
argument_list|,
name|A_TEMP
argument_list|,
name|macid
argument_list|(
literal|"{server_addr}"
argument_list|)
argument_list|,
name|anynet_ntoa
argument_list|(
operator|&
name|CurHostAddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mci
operator|->
name|mci_mailer
operator|!=
name|NULL
condition|)
block|{
comment|/* mailer name is unique, use it as address */
name|macdefine
argument_list|(
operator|&
name|mci
operator|->
name|mci_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{server_addr}"
argument_list|)
argument_list|,
name|mci
operator|->
name|mci_mailer
operator|->
name|m_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* don't set it to NULL or "": see getauth() */
name|macdefine
argument_list|(
operator|&
name|mci
operator|->
name|mci_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{server_addr}"
argument_list|)
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
comment|/* undo change of srvname (mci->mci_host) */
if|if
condition|(
name|dotpos
operator|>=
literal|0
condition|)
name|srvname
index|[
name|dotpos
index|]
operator|=
literal|'.'
expr_stmt|;
name|reconnect
label|:
comment|/* after switching to an encrypted connection */
endif|#
directive|endif
comment|/* STARTTLS || SASL */
comment|/* set the current connection information */
name|e
operator|->
name|e_mci
operator|=
name|mci
expr_stmt|;
if|#
directive|if
name|SASL
name|mci
operator|->
name|mci_saslcap
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* SASL */
name|smtpinit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|ONLY_HELO
argument_list|(
name|mci
operator|->
name|mci_flags
argument_list|)
argument_list|)
expr_stmt|;
name|CLR_HELO
argument_list|(
name|mci
operator|->
name|mci_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_DLVR_RETURN
argument_list|(
name|e
argument_list|)
condition|)
block|{
comment|/* 			**  Check whether other side can deliver e-mail 			**  fast enough 			*/
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|MCIF_DLVR_BY
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
block|{
name|e
operator|->
name|e_status
operator|=
literal|"5.4.7"
expr_stmt|;
name|usrerrenh
argument_list|(
name|e
operator|->
name|e_status
argument_list|,
literal|"554 Server does not support Deliver By"
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|EX_UNAVAILABLE
expr_stmt|;
goto|goto
name|give_up
goto|;
block|}
if|if
condition|(
name|e
operator|->
name|e_deliver_by
operator|>
literal|0
operator|&&
name|e
operator|->
name|e_deliver_by
operator|-
operator|(
name|curtime
argument_list|()
operator|-
name|e
operator|->
name|e_ctime
operator|)
operator|<
name|mci
operator|->
name|mci_min_by
condition|)
block|{
name|e
operator|->
name|e_status
operator|=
literal|"5.4.7"
expr_stmt|;
name|usrerrenh
argument_list|(
name|e
operator|->
name|e_status
argument_list|,
literal|"554 Message can't be delivered in time; %ld< %ld"
argument_list|,
name|e
operator|->
name|e_deliver_by
operator|-
operator|(
name|curtime
argument_list|()
operator|-
name|e
operator|->
name|e_ctime
operator|)
argument_list|,
name|mci
operator|->
name|mci_min_by
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|EX_UNAVAILABLE
expr_stmt|;
goto|goto
name|give_up
goto|;
block|}
block|}
if|#
directive|if
name|STARTTLS
comment|/* first TLS then AUTH to provide a security layer */
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_CLOSED
operator|&&
operator|!
name|DONE_STARTTLS
argument_list|(
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
block|{
name|int
name|olderrors
decl_stmt|;
name|bool
name|usetls
decl_stmt|;
name|bool
name|saveQuickAbort
init|=
name|QuickAbort
decl_stmt|;
name|bool
name|saveSuprErrs
init|=
name|SuprErrs
decl_stmt|;
name|char
modifier|*
name|host
init|=
name|NULL
decl_stmt|;
name|rcode
operator|=
name|EX_OK
expr_stmt|;
name|usetls
operator|=
name|bitset
argument_list|(
name|MCIF_TLS
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|usetls
condition|)
name|usetls
operator|=
operator|!
name|iscltflgset
argument_list|(
name|e
argument_list|,
name|D_NOTLS
argument_list|)
expr_stmt|;
if|if
condition|(
name|usetls
condition|)
block|{
name|host
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{server_name}"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|olderrors
operator|=
name|Errors
expr_stmt|;
name|QuickAbort
operator|=
name|false
expr_stmt|;
name|SuprErrs
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|rscheck
argument_list|(
literal|"try_tls"
argument_list|,
name|host
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
name|RSF_RMCOMM
argument_list|,
literal|7
argument_list|,
name|host
argument_list|,
name|NOQID
argument_list|)
operator|!=
name|EX_OK
operator|||
name|Errors
operator|>
name|olderrors
condition|)
name|usetls
operator|=
name|false
expr_stmt|;
name|SuprErrs
operator|=
name|saveSuprErrs
expr_stmt|;
name|QuickAbort
operator|=
name|saveQuickAbort
expr_stmt|;
block|}
if|if
condition|(
name|usetls
condition|)
block|{
if|if
condition|(
operator|(
name|rcode
operator|=
name|starttls
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
operator|)
operator|==
name|EX_OK
condition|)
block|{
comment|/* start again without STARTTLS */
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_TLSACT
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|s
decl_stmt|;
comment|/* 					**  TLS negotation failed, what to do? 					**  fall back to unencrypted connection 					**  or abort? How to decide? 					**  set a macro and call a ruleset. 					*/
name|mci
operator|->
name|mci_flags
operator|&=
operator|~
name|MCIF_TLS
expr_stmt|;
switch|switch
condition|(
name|rcode
condition|)
block|{
case|case
name|EX_TEMPFAIL
case|:
name|s
operator|=
literal|"TEMP"
expr_stmt|;
break|break;
case|case
name|EX_USAGE
case|:
name|s
operator|=
literal|"USAGE"
expr_stmt|;
break|break;
case|case
name|EX_PROTOCOL
case|:
name|s
operator|=
literal|"PROTOCOL"
expr_stmt|;
break|break;
case|case
name|EX_SOFTWARE
case|:
name|s
operator|=
literal|"SOFTWARE"
expr_stmt|;
break|break;
case|case
name|EX_UNAVAILABLE
case|:
name|s
operator|=
literal|"NONE"
expr_stmt|;
break|break;
comment|/* everything else is a failure */
default|default:
name|s
operator|=
literal|"FAILURE"
expr_stmt|;
name|rcode
operator|=
name|EX_TEMPFAIL
expr_stmt|;
block|}
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{verify}"
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
name|macid
argument_list|(
literal|"{verify}"
argument_list|)
argument_list|,
literal|"NONE"
argument_list|)
expr_stmt|;
name|olderrors
operator|=
name|Errors
expr_stmt|;
name|QuickAbort
operator|=
name|false
expr_stmt|;
name|SuprErrs
operator|=
name|true
expr_stmt|;
comment|/* 			**  rcode == EX_SOFTWARE is special: 			**  the TLS negotation failed 			**  we have to drop the connection no matter what 			**  However, we call tls_server to give it the chance 			**  to log the problem and return an appropriate 			**  error code. 			*/
if|if
condition|(
name|rscheck
argument_list|(
literal|"tls_server"
argument_list|,
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{verify}"
argument_list|)
argument_list|,
name|e
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
name|RSF_RMCOMM
operator||
name|RSF_COUNT
argument_list|,
literal|5
argument_list|,
name|host
argument_list|,
name|NOQID
argument_list|)
operator|!=
name|EX_OK
operator|||
name|Errors
operator|>
name|olderrors
operator|||
name|rcode
operator|==
name|EX_SOFTWARE
condition|)
block|{
name|char
name|enhsc
index|[
name|ENHSCLEN
index|]
decl_stmt|;
specifier|extern
name|char
name|MsgBuf
index|[]
decl_stmt|;
if|if
condition|(
name|ISSMTPCODE
argument_list|(
name|MsgBuf
argument_list|)
operator|&&
name|extenhsc
argument_list|(
name|MsgBuf
operator|+
literal|4
argument_list|,
literal|' '
argument_list|,
name|enhsc
argument_list|)
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|MsgBuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
literal|"403 4.7.0 server not authenticated."
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|enhsc
argument_list|,
literal|"4.7.0"
argument_list|,
sizeof|sizeof
name|enhsc
argument_list|)
expr_stmt|;
block|}
name|SuprErrs
operator|=
name|saveSuprErrs
expr_stmt|;
name|QuickAbort
operator|=
name|saveQuickAbort
expr_stmt|;
if|if
condition|(
name|rcode
operator|==
name|EX_SOFTWARE
condition|)
block|{
comment|/* drop the connection */
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_QUITING
expr_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_in
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|mci
operator|->
name|mci_in
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_in
operator|=
name|NULL
expr_stmt|;
block|}
name|mci
operator|->
name|mci_flags
operator|&=
operator|~
name|MCIF_TLSACT
expr_stmt|;
operator|(
name|void
operator|)
name|endmailer
argument_list|(
name|mci
argument_list|,
name|e
argument_list|,
name|pv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* abort transfer */
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|/* avoid bogus error msg */
name|mci
operator|->
name|mci_errno
operator|=
literal|0
expr_stmt|;
comment|/* temp or permanent failure? */
name|rcode
operator|=
operator|(
operator|*
name|p
operator|==
literal|'4'
operator|)
condition|?
name|EX_TEMPFAIL
else|:
name|EX_UNAVAILABLE
expr_stmt|;
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|rcode
argument_list|,
name|enhsc
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* 				**  hack to get the error message into 				**  the envelope (done in giveresponse()) 				*/
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|SmtpError
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|SmtpError
argument_list|)
expr_stmt|;
block|}
name|QuickAbort
operator|=
name|saveQuickAbort
expr_stmt|;
name|SuprErrs
operator|=
name|saveSuprErrs
expr_stmt|;
if|if
condition|(
name|DONE_STARTTLS
argument_list|(
name|mci
operator|->
name|mci_flags
argument_list|)
operator|&&
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_CLOSED
condition|)
block|{
name|SET_HELO
argument_list|(
name|mci
operator|->
name|mci_flags
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_flags
operator|&=
operator|~
name|MCIF_EXTENS
expr_stmt|;
goto|goto
name|reconnect
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* STARTTLS */
if|#
directive|if
name|SASL
comment|/* if other server supports authentication let's authenticate */
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_CLOSED
operator|&&
name|mci
operator|->
name|mci_saslcap
operator|!=
name|NULL
operator|&&
operator|!
name|DONE_AUTH
argument_list|(
name|mci
operator|->
name|mci_flags
argument_list|)
operator|&&
operator|!
name|iscltflgset
argument_list|(
name|e
argument_list|,
name|D_NOAUTH
argument_list|)
condition|)
block|{
comment|/* Should we require some minimum authentication? */
if|if
condition|(
operator|(
name|ret
operator|=
name|smtpauth
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
operator|)
operator|==
name|EX_OK
condition|)
block|{
name|int
name|result
decl_stmt|;
name|sasl_ssf_t
modifier|*
name|ssf
init|=
name|NULL
decl_stmt|;
comment|/* Get security strength (features) */
name|result
operator|=
name|sasl_getprop
argument_list|(
name|mci
operator|->
name|mci_conn
argument_list|,
name|SASL_SSF
argument_list|,
if|#
directive|if
name|SASL
operator|>=
literal|20000
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|ssf
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SASL>= 20000 */
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ssf
block|)
empty_stmt|;
endif|#
directive|endif
comment|/* SASL>= 20000 */
comment|/* XXX authid? */
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"AUTH=client, relay=%.100s, mech=%.16s, bits=%d"
argument_list|,
name|mci
operator|->
name|mci_host
argument_list|,
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{auth_type}"
argument_list|)
argument_list|,
name|e
argument_list|)
argument_list|,
name|result
operator|==
name|SASL_OK
condition|?
operator|*
name|ssf
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* 				**  Only switch to encrypted connection 				**  if a security layer has been negotiated 				*/
if|if
condition|(
name|result
operator|==
name|SASL_OK
operator|&&
operator|*
name|ssf
operator|>
literal|0
condition|)
block|{
comment|/* 					**  Convert I/O layer to use SASL. 					**  If the call fails, the connection 					**  is aborted. 					*/
if|if
condition|(
name|sfdcsasl
argument_list|(
operator|&
name|mci
operator|->
name|mci_in
argument_list|,
operator|&
name|mci
operator|->
name|mci_out
argument_list|,
name|mci
operator|->
name|mci_conn
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mci
operator|->
name|mci_flags
operator|&=
operator|~
name|MCIF_EXTENS
expr_stmt|;
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_AUTHACT
operator||
name|MCIF_ONLY_EHLO
expr_stmt|;
goto|goto
name|reconnect
goto|;
block|}
name|syserr
argument_list|(
literal|"AUTH TLS switch failed in client"
argument_list|)
expr_stmt|;
block|}
comment|/* else? XXX */
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_AUTHACT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
name|EX_TEMPFAIL
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"AUTH=client, relay=%.100s, temporary failure, connection abort"
argument_list|,
name|mci
operator|->
name|mci_host
argument_list|)
expr_stmt|;
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* avoid bogus error msg */
name|mci
operator|->
name|mci_errno
operator|=
literal|0
expr_stmt|;
name|rcode
operator|=
name|EX_TEMPFAIL
expr_stmt|;
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|rcode
argument_list|,
literal|"4.3.0"
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* 				**  hack to get the error message into 				**  the envelope (done in giveresponse()) 				*/
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|SmtpError
argument_list|,
literal|"Temporary AUTH failure"
argument_list|,
sizeof|sizeof
name|SmtpError
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SASL */
block|}
name|do_transfer
label|:
comment|/* clear out per-message flags from connection structure */
name|mci
operator|->
name|mci_flags
operator|&=
operator|~
operator|(
name|MCIF_CVT7TO8
operator||
name|MCIF_CVT8TO7
operator|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|EF_HAS8BIT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_DONT_MIME
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
name|bitnset
argument_list|(
name|M_7BITS
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_CVT8TO7
expr_stmt|;
if|#
directive|if
name|MIME7TO8
if|if
condition|(
name|bitnset
argument_list|(
name|M_MAKE8BIT
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|MCIF_7BIT
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
operator|&&
operator|(
name|p
operator|=
name|hvalue
argument_list|(
literal|"Content-Transfer-Encoding"
argument_list|,
name|e
operator|->
name|e_header
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|sm_strcasecmp
argument_list|(
name|p
argument_list|,
literal|"quoted-printable"
argument_list|)
operator|==
literal|0
operator|||
name|sm_strcasecmp
argument_list|(
name|p
argument_list|,
literal|"base64"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|p
operator|=
name|hvalue
argument_list|(
literal|"Content-Type"
argument_list|,
name|e
operator|->
name|e_header
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* may want to convert 7 -> 8 */
comment|/* XXX should really parse it here -- and use a class XXX */
if|if
condition|(
name|sm_strncasecmp
argument_list|(
name|p
argument_list|,
literal|"text/plain"
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|p
index|[
literal|10
index|]
operator|==
literal|'\0'
operator|||
name|p
index|[
literal|10
index|]
operator|==
literal|' '
operator|||
name|p
index|[
literal|10
index|]
operator|==
literal|';'
operator|)
condition|)
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_CVT7TO8
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MIME7TO8 */
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"openmailer: "
argument_list|)
expr_stmt|;
name|mci_dump
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|mci
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|_FFR_CLIENT_SIZE
comment|/* 	**  See if we know the maximum size and 	**  abort if the message is too big. 	** 	**  NOTE: _FFR_CLIENT_SIZE is untested. 	*/
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_SIZE
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
operator|&&
name|mci
operator|->
name|mci_maxsize
operator|>
literal|0
operator|&&
name|e
operator|->
name|e_msgsize
operator|>
name|mci
operator|->
name|mci_maxsize
condition|)
block|{
name|e
operator|->
name|e_flags
operator||=
name|EF_NO_BODY_RETN
expr_stmt|;
if|if
condition|(
name|bitnset
argument_list|(
name|M_LOCALMAILER
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|e
operator|->
name|e_status
operator|=
literal|"5.2.3"
expr_stmt|;
else|else
name|e
operator|->
name|e_status
operator|=
literal|"5.3.4"
expr_stmt|;
name|usrerrenh
argument_list|(
name|e
operator|->
name|e_status
argument_list|,
literal|"552 Message is too large; %ld bytes max"
argument_list|,
name|mci
operator|->
name|mci_maxsize
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|EX_DATAERR
expr_stmt|;
comment|/* Need an e_message for error */
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|SmtpError
argument_list|,
sizeof|sizeof
name|SmtpError
argument_list|,
literal|"Message is too large; %ld bytes max"
argument_list|,
name|mci
operator|->
name|mci_maxsize
argument_list|)
expr_stmt|;
goto|goto
name|give_up
goto|;
block|}
endif|#
directive|endif
comment|/* _FFR_CLIENT_SIZE */
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_OPEN
condition|)
block|{
comment|/* couldn't open the mailer */
name|rcode
operator|=
name|mci
operator|->
name|mci_exitstat
expr_stmt|;
name|errno
operator|=
name|mci
operator|->
name|mci_errno
expr_stmt|;
name|SM_SET_H_ERRNO
argument_list|(
name|mci
operator|->
name|mci_herrno
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcode
operator|==
name|EX_OK
condition|)
block|{
comment|/* shouldn't happen */
name|syserr
argument_list|(
literal|"554 5.3.5 deliver: mci=%lx rcode=%d errno=%d state=%d sig=%s"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|mci
argument_list|,
name|rcode
argument_list|,
name|errno
argument_list|,
name|mci
operator|->
name|mci_state
argument_list|,
name|firstsig
argument_list|)
expr_stmt|;
name|mci_dump_all
argument_list|(
name|smioout
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|EX_SOFTWARE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nummxhosts
operator|>
name|hostnum
condition|)
block|{
comment|/* try next MX site */
goto|goto
name|tryhost
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|clever
condition|)
block|{
name|bool
name|ok
decl_stmt|;
comment|/* 		**  Format and send message. 		*/
name|rcode
operator|=
name|EX_OK
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ok
operator|=
name|putfromline
argument_list|(
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
name|ok
operator|=
call|(
modifier|*
name|e
operator|->
name|e_puthdr
call|)
argument_list|(
name|mci
argument_list|,
name|e
operator|->
name|e_header
argument_list|,
name|e
argument_list|,
name|M87F_OUTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
name|ok
operator|=
call|(
modifier|*
name|e
operator|->
name|e_putbody
call|)
argument_list|(
name|mci
argument_list|,
name|e
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		**  Ignore an I/O error that was caused by EPIPE. 		**  Some broken mailers don't read the entire body 		**  but just exit() thus causing an I/O error. 		*/
if|if
condition|(
operator|!
name|ok
operator|&&
operator|(
name|sm_io_error
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|)
operator|&&
name|errno
operator|==
name|EPIPE
operator|)
condition|)
name|ok
operator|=
name|true
expr_stmt|;
comment|/* (always) get the exit status */
name|rcode
operator|=
name|endmailer
argument_list|(
name|mci
argument_list|,
name|e
argument_list|,
name|pv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|rcode
operator|=
name|EX_TEMPFAIL
expr_stmt|;
if|if
condition|(
name|rcode
operator|==
name|EX_TEMPFAIL
operator|&&
name|SmtpError
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* 			**  Need an e_message for mailq display. 			**  We set SmtpError as 			*/
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|SmtpError
argument_list|,
sizeof|sizeof
name|SmtpError
argument_list|,
literal|"%s mailer (%s) exited with EX_TEMPFAIL"
argument_list|,
name|m
operator|->
name|m_name
argument_list|,
name|m
operator|->
name|m_mailer
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		**  Send the MAIL FROM: protocol 		*/
comment|/* XXX this isn't pipelined... */
name|rcode
operator|=
name|smtpmailfrom
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcode
operator|==
name|EX_OK
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|#
directive|if
name|PIPELINING
name|ADDRESS
modifier|*
specifier|volatile
name|pchain
decl_stmt|;
endif|#
directive|endif
comment|/* PIPELINING */
comment|/* send the recipient list */
name|tobuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mci
operator|->
name|mci_retryrcpt
operator|=
name|false
expr_stmt|;
name|mci
operator|->
name|mci_tolist
operator|=
name|tobuf
expr_stmt|;
if|#
directive|if
name|PIPELINING
name|pchain
operator|=
name|NULL
expr_stmt|;
name|mci
operator|->
name|mci_nextaddr
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* PIPELINING */
for|for
control|(
name|to
operator|=
name|tochain
init|;
name|to
operator|!=
name|NULL
condition|;
name|to
operator|=
name|to
operator|->
name|q_tchain
control|)
block|{
if|if
condition|(
operator|!
name|QS_IS_UNMARKED
argument_list|(
name|to
operator|->
name|q_state
argument_list|)
condition|)
continue|continue;
comment|/* mark recipient state as "ok so far" */
name|to
operator|->
name|q_state
operator|=
name|QS_OK
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|to
operator|->
name|q_paddr
expr_stmt|;
if|#
directive|if
name|STARTTLS
name|i
operator|=
name|rscheck
argument_list|(
literal|"tls_rcpt"
argument_list|,
name|to
operator|->
name|q_user
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
name|RSF_RMCOMM
operator||
name|RSF_COUNT
argument_list|,
literal|3
argument_list|,
name|mci
operator|->
name|mci_host
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|EX_OK
condition|)
block|{
name|markfailure
argument_list|(
name|e
argument_list|,
name|to
argument_list|,
name|mci
argument_list|,
name|i
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|giveresponse
argument_list|(
name|i
argument_list|,
name|to
operator|->
name|q_status
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|ctladdr
argument_list|,
name|xstart
argument_list|,
name|e
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|EX_TEMPFAIL
condition|)
block|{
name|mci
operator|->
name|mci_retryrcpt
operator|=
name|true
expr_stmt|;
name|to
operator|->
name|q_state
operator|=
name|QS_RETRY
expr_stmt|;
block|}
continue|continue;
block|}
endif|#
directive|endif
comment|/* STARTTLS */
name|i
operator|=
name|smtprcpt
argument_list|(
name|to
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|ctladdr
argument_list|,
name|xstart
argument_list|)
expr_stmt|;
if|#
directive|if
name|PIPELINING
if|if
condition|(
name|i
operator|==
name|EX_OK
operator|&&
name|bitset
argument_list|(
name|MCIF_PIPELINED
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
block|{
comment|/* 					**  Add new element to list of 					**  recipients for pipelining. 					*/
name|to
operator|->
name|q_pchain
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_nextaddr
operator|==
name|NULL
condition|)
name|mci
operator|->
name|mci_nextaddr
operator|=
name|to
expr_stmt|;
if|if
condition|(
name|pchain
operator|==
name|NULL
condition|)
name|pchain
operator|=
name|to
expr_stmt|;
else|else
block|{
name|pchain
operator|->
name|q_pchain
operator|=
name|to
expr_stmt|;
name|pchain
operator|=
name|pchain
operator|->
name|q_pchain
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* PIPELINING */
if|if
condition|(
name|i
operator|!=
name|EX_OK
condition|)
block|{
name|markfailure
argument_list|(
name|e
argument_list|,
name|to
argument_list|,
name|mci
argument_list|,
name|i
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|giveresponse
argument_list|(
name|i
argument_list|,
name|to
operator|->
name|q_status
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|ctladdr
argument_list|,
name|xstart
argument_list|,
name|e
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|EX_TEMPFAIL
condition|)
name|to
operator|->
name|q_state
operator|=
name|QS_RETRY
expr_stmt|;
block|}
block|}
comment|/* No recipients in list and no missing responses? */
if|if
condition|(
name|tobuf
index|[
literal|0
index|]
operator|==
literal|'\0'
if|#
directive|if
name|PIPELINING
operator|&&
name|mci
operator|->
name|mci_nextaddr
operator|==
name|NULL
endif|#
directive|endif
comment|/* PIPELINING */
condition|)
block|{
name|rcode
operator|=
name|EX_OK
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_CACHED
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
name|smtprset
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e
operator|->
name|e_to
operator|=
name|tobuf
operator|+
literal|1
expr_stmt|;
name|rcode
operator|=
name|smtpdata
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|ctladdr
argument_list|,
name|xstart
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rcode
operator|==
name|EX_TEMPFAIL
operator|&&
name|nummxhosts
operator|>
name|hostnum
condition|)
block|{
comment|/* try next MX site */
goto|goto
name|tryhost
goto|;
block|}
block|}
if|#
directive|if
name|NAMED_BIND
if|if
condition|(
name|ConfigLevel
operator|<
literal|2
condition|)
name|_res
operator|.
name|options
operator||=
name|RES_DEFNAMES
operator||
name|RES_DNSRCH
expr_stmt|;
comment|/* XXX */
endif|#
directive|endif
comment|/* NAMED_BIND */
if|if
condition|(
name|tTd
argument_list|(
literal|62
argument_list|,
literal|1
argument_list|)
condition|)
name|checkfds
argument_list|(
literal|"after delivery"
argument_list|)
expr_stmt|;
comment|/* 	**  Do final status disposal. 	**	We check for something in tobuf for the SMTP case. 	**	If we got a temporary failure, arrange to queue the 	**		addressees. 	*/
name|give_up
label|:
if|if
condition|(
name|bitnset
argument_list|(
name|M_LMTP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
name|lmtp_rcode
operator|=
name|rcode
expr_stmt|;
name|tobuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|anyok
operator|=
name|false
expr_stmt|;
name|strsize
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|anyok
operator|=
name|rcode
operator|==
name|EX_OK
expr_stmt|;
for|for
control|(
name|to
operator|=
name|tochain
init|;
name|to
operator|!=
name|NULL
condition|;
name|to
operator|=
name|to
operator|->
name|q_tchain
control|)
block|{
comment|/* see if address already marked */
if|if
condition|(
operator|!
name|QS_IS_OK
argument_list|(
name|to
operator|->
name|q_state
argument_list|)
condition|)
continue|continue;
comment|/* if running LMTP, get the status for each address */
if|if
condition|(
name|bitnset
argument_list|(
name|M_LMTP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|lmtp_rcode
operator|==
name|EX_OK
condition|)
name|rcode
operator|=
name|smtpgetstat
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcode
operator|==
name|EX_OK
condition|)
block|{
name|strsize
operator|+=
name|sm_strlcat2
argument_list|(
name|tobuf
operator|+
name|strsize
argument_list|,
literal|","
argument_list|,
name|to
operator|->
name|q_paddr
argument_list|,
name|tobufsize
operator|-
name|strsize
argument_list|)
expr_stmt|;
name|SM_ASSERT
argument_list|(
name|strsize
operator|<
name|tobufsize
argument_list|)
expr_stmt|;
name|anyok
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|e
operator|->
name|e_to
operator|=
name|to
operator|->
name|q_paddr
expr_stmt|;
name|markfailure
argument_list|(
name|e
argument_list|,
name|to
argument_list|,
name|mci
argument_list|,
name|rcode
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|giveresponse
argument_list|(
name|rcode
argument_list|,
name|to
operator|->
name|q_status
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|ctladdr
argument_list|,
name|xstart
argument_list|,
name|e
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|tobuf
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
comment|/* mark bad addresses */
if|if
condition|(
name|rcode
operator|!=
name|EX_OK
condition|)
block|{
if|if
condition|(
name|goodmxfound
operator|&&
name|rcode
operator|==
name|EX_NOHOST
condition|)
name|rcode
operator|=
name|EX_TEMPFAIL
expr_stmt|;
name|markfailure
argument_list|(
name|e
argument_list|,
name|to
argument_list|,
name|mci
argument_list|,
name|rcode
argument_list|,
name|true
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* successful delivery */
name|to
operator|->
name|q_state
operator|=
name|QS_SENT
expr_stmt|;
name|to
operator|->
name|q_statdate
operator|=
name|curtime
argument_list|()
expr_stmt|;
name|e
operator|->
name|e_nsent
operator|++
expr_stmt|;
comment|/* 		**  Checkpoint the send list every few addresses 		*/
if|if
condition|(
name|CheckpointInterval
operator|>
literal|0
operator|&&
name|e
operator|->
name|e_nsent
operator|>=
name|CheckpointInterval
condition|)
block|{
name|queueup
argument_list|(
name|e
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_nsent
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bitnset
argument_list|(
name|M_LOCALMAILER
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|&&
name|bitset
argument_list|(
name|QPINGONSUCCESS
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
condition|)
block|{
name|to
operator|->
name|q_flags
operator||=
name|QDELIVERED
expr_stmt|;
name|to
operator|->
name|q_status
operator|=
literal|"2.1.5"
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s... Successfully delivered\n"
argument_list|,
name|to
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|QPINGONSUCCESS
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
operator|&&
name|bitset
argument_list|(
name|QPRIMARY
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|MCIF_DSN
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
block|{
name|to
operator|->
name|q_flags
operator||=
name|QRELAYED
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s... relayed; expect no further notifications\n"
argument_list|,
name|to
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_DLVR_NOTIFY
argument_list|(
name|e
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|MCIF_DLVR_BY
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
operator|&&
name|bitset
argument_list|(
name|QPRIMARY
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
operator|&&
operator|(
operator|!
name|bitset
argument_list|(
name|QHASNOTIFY
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
operator|||
name|bitset
argument_list|(
name|QPINGONSUCCESS
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
operator|||
name|bitset
argument_list|(
name|QPINGONFAILURE
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
operator|||
name|bitset
argument_list|(
name|QPINGONDELAY
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
operator|)
condition|)
block|{
comment|/* RFC 2852, 4.1.4.2: no NOTIFY, or not NEVER */
name|to
operator|->
name|q_flags
operator||=
name|QBYNRELAY
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s... Deliver-by notify: relayed\n"
argument_list|,
name|to
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_DLVR_TRACE
argument_list|(
name|e
argument_list|)
operator|&&
operator|(
operator|!
name|bitset
argument_list|(
name|QHASNOTIFY
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
operator|||
name|bitset
argument_list|(
name|QPINGONSUCCESS
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
operator|||
name|bitset
argument_list|(
name|QPINGONFAILURE
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
operator|||
name|bitset
argument_list|(
name|QPINGONDELAY
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
operator|)
operator|&&
name|bitset
argument_list|(
name|QPRIMARY
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
condition|)
block|{
comment|/* RFC 2852, 4.1.4: no NOTIFY, or not NEVER */
name|to
operator|->
name|q_flags
operator||=
name|QBYTRACE
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s... Deliver-By trace: relayed\n"
argument_list|,
name|to
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bitnset
argument_list|(
name|M_LMTP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
comment|/* 		**  Global information applies to the last recipient only; 		**  clear it out to avoid bogus errors. 		*/
name|rcode
operator|=
name|EX_OK
expr_stmt|;
name|e
operator|->
name|e_statmsg
operator|=
name|NULL
expr_stmt|;
comment|/* reset the mci state for the next transaction */
if|if
condition|(
name|mci
operator|!=
name|NULL
operator|&&
operator|(
name|mci
operator|->
name|mci_state
operator|==
name|MCIS_MAIL
operator|||
name|mci
operator|->
name|mci_state
operator|==
name|MCIS_RCPT
operator|||
name|mci
operator|->
name|mci_state
operator|==
name|MCIS_DATA
operator|)
condition|)
block|{
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_OPEN
expr_stmt|;
name|SmtpPhase
operator|=
name|mci
operator|->
name|mci_phase
operator|=
literal|"idle"
expr_stmt|;
name|sm_setproctitle
argument_list|(
name|true
argument_list|,
name|e
argument_list|,
literal|"%s: %s"
argument_list|,
name|CurHostName
argument_list|,
name|mci
operator|->
name|mci_phase
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tobuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|giveresponse
argument_list|(
name|rcode
argument_list|,
name|NULL
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|ctladdr
argument_list|,
name|xstart
argument_list|,
name|e
argument_list|,
name|tochain
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 		**  This code is disabled for now because I am not 		**  sure that copying status from the first recipient 		**  to all non-status'ed recipients is a good idea. 		*/
block|if (tochain->q_message != NULL&& 		    !bitnset(M_LMTP, m->m_flags)&& rcode != EX_OK) 		{ 			for (to = tochain->q_tchain; to != NULL; 			     to = to->q_tchain) 			{
comment|/* see if address already marked */
block|if (QS_IS_QUEUEUP(to->q_state)&& 				    to->q_message == NULL) 					to->q_message = sm_rpool_strdup_x(e->e_rpool, 							tochain->q_message); 			} 		}
endif|#
directive|endif
comment|/* 0 */
block|}
if|if
condition|(
name|anyok
condition|)
name|markstats
argument_list|(
name|e
argument_list|,
name|tochain
argument_list|,
name|STATS_NORMAL
argument_list|)
expr_stmt|;
name|mci_store_persistent
argument_list|(
name|mci
argument_list|)
expr_stmt|;
comment|/* Some recipients were tempfailed, try them on the next host */
if|if
condition|(
name|mci
operator|!=
name|NULL
operator|&&
name|mci
operator|->
name|mci_retryrcpt
operator|&&
name|nummxhosts
operator|>
name|hostnum
condition|)
block|{
comment|/* try next MX site */
goto|goto
name|tryhost
goto|;
block|}
comment|/* now close the connection */
if|if
condition|(
name|clever
operator|&&
name|mci
operator|!=
name|NULL
operator|&&
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_CLOSED
operator|&&
operator|!
name|bitset
argument_list|(
name|MCIF_CACHED
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|cleanup
label|:
empty_stmt|;
block|}
end_function

begin_macro
name|SM_FINALLY
end_macro

begin_block
block|{
comment|/* 		**  Restore state and return. 		*/
if|#
directive|if
name|XDEBUG
name|char
name|wbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
comment|/* make absolutely certain 0, 1, and 2 are in use */
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|wbuf
argument_list|,
sizeof|sizeof
name|wbuf
argument_list|,
literal|"%s... end of deliver(%s)"
argument_list|,
name|e
operator|->
name|e_to
operator|==
name|NULL
condition|?
literal|"NO-TO-LIST"
else|:
name|shortenstring
argument_list|(
name|e
operator|->
name|e_to
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|,
name|m
operator|->
name|m_name
argument_list|)
expr_stmt|;
name|checkfd012
argument_list|(
name|wbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XDEBUG */
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* 		**  It was originally necessary to set macro 'g' to NULL 		**  because it previously pointed to an auto buffer. 		**  We don't do this any more, so this may be unnecessary. 		*/
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'g'
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_macro
name|SM_END_TRY
end_macro

begin_return
return|return
name|rcode
return|;
end_return

begin_comment
unit|}
comment|/* **  MARKFAILURE -- mark a failure on a specific address. ** **	Parameters: **		e -- the envelope we are sending. **		q -- the address to mark. **		mci -- mailer connection information. **		rcode -- the code signifying the particular failure. **		ovr -- override an existing code? ** **	Returns: **		none. ** **	Side Effects: **		marks the address (and possibly the envelope) with the **			failure so that an error will be returned or **			the message will be queued, as appropriate. */
end_comment

begin_expr_stmt
unit|void
name|markfailure
argument_list|(
name|e
argument_list|,
name|q
argument_list|,
name|mci
argument_list|,
name|rcode
argument_list|,
name|ovr
argument_list|)
specifier|register
name|ENVELOPE
operator|*
name|e
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|ovr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|char
modifier|*
name|status
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|rstatus
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|rcode
condition|)
block|{
case|case
name|EX_OK
case|:
break|break;
case|case
name|EX_TEMPFAIL
case|:
case|case
name|EX_IOERR
case|:
case|case
name|EX_OSERR
case|:
name|q
operator|->
name|q_state
operator|=
name|QS_QUEUEUP
expr_stmt|;
break|break;
default|default:
name|q
operator|->
name|q_state
operator|=
name|QS_BADADDR
expr_stmt|;
break|break;
block|}
comment|/* find most specific error code possible */
if|if
condition|(
name|mci
operator|!=
name|NULL
operator|&&
name|mci
operator|->
name|mci_status
operator|!=
name|NULL
condition|)
block|{
name|status
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|mci
operator|->
name|mci_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_rstatus
operator|!=
name|NULL
condition|)
name|rstatus
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|mci
operator|->
name|mci_rstatus
argument_list|)
expr_stmt|;
else|else
name|rstatus
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|e_status
operator|!=
name|NULL
condition|)
block|{
name|status
operator|=
name|e
operator|->
name|e_status
expr_stmt|;
name|rstatus
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|rcode
condition|)
block|{
case|case
name|EX_USAGE
case|:
name|status
operator|=
literal|"5.5.4"
expr_stmt|;
break|break;
case|case
name|EX_DATAERR
case|:
name|status
operator|=
literal|"5.5.2"
expr_stmt|;
break|break;
case|case
name|EX_NOUSER
case|:
name|status
operator|=
literal|"5.1.1"
expr_stmt|;
break|break;
case|case
name|EX_NOHOST
case|:
name|status
operator|=
literal|"5.1.2"
expr_stmt|;
break|break;
case|case
name|EX_NOINPUT
case|:
case|case
name|EX_CANTCREAT
case|:
case|case
name|EX_NOPERM
case|:
name|status
operator|=
literal|"5.3.0"
expr_stmt|;
break|break;
case|case
name|EX_UNAVAILABLE
case|:
case|case
name|EX_SOFTWARE
case|:
case|case
name|EX_OSFILE
case|:
case|case
name|EX_PROTOCOL
case|:
case|case
name|EX_CONFIG
case|:
name|status
operator|=
literal|"5.5.0"
expr_stmt|;
break|break;
case|case
name|EX_OSERR
case|:
case|case
name|EX_IOERR
case|:
name|status
operator|=
literal|"4.5.0"
expr_stmt|;
break|break;
case|case
name|EX_TEMPFAIL
case|:
name|status
operator|=
literal|"4.2.0"
expr_stmt|;
break|break;
block|}
block|}
comment|/* new status? */
if|if
condition|(
name|status
operator|!=
name|NULL
operator|&&
operator|*
name|status
operator|!=
literal|'\0'
operator|&&
operator|(
name|ovr
operator|||
name|q
operator|->
name|q_status
operator|==
name|NULL
operator|||
operator|*
name|q
operator|->
name|q_status
operator|==
literal|'\0'
operator|||
operator|*
name|q
operator|->
name|q_status
operator|<
operator|*
name|status
operator|)
condition|)
block|{
name|q
operator|->
name|q_status
operator|=
name|status
expr_stmt|;
name|q
operator|->
name|q_rstatus
operator|=
name|rstatus
expr_stmt|;
block|}
if|if
condition|(
name|rcode
operator|!=
name|EX_OK
operator|&&
name|q
operator|->
name|q_rstatus
operator|==
name|NULL
operator|&&
name|q
operator|->
name|q_mailer
operator|!=
name|NULL
operator|&&
name|q
operator|->
name|q_mailer
operator|->
name|m_diagtype
operator|!=
name|NULL
operator|&&
name|sm_strcasecmp
argument_list|(
name|q
operator|->
name|q_mailer
operator|->
name|m_diagtype
argument_list|,
literal|"X-UNIX"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|rcode
argument_list|)
expr_stmt|;
name|q
operator|->
name|q_rstatus
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|q
operator|->
name|q_statdate
operator|=
name|curtime
argument_list|()
expr_stmt|;
if|if
condition|(
name|CurHostName
operator|!=
name|NULL
operator|&&
name|CurHostName
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|mci
operator|!=
name|NULL
operator|&&
operator|!
name|bitset
argument_list|(
name|M_LOCALMAILER
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
name|q
operator|->
name|q_statmta
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|CurHostName
argument_list|)
expr_stmt|;
comment|/* restore errno */
name|errno
operator|=
name|save_errno
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **  ENDMAILER -- Wait for mailer to terminate. ** **	We should never get fatal errors (e.g., segmentation **	violation), so we report those specially.  For other **	errors, we choose a status message (into statmsg), **	and if it represents an error, we print it. ** **	Parameters: **		mci -- the mailer connection info. **		e -- the current envelope. **		pv -- the parameter vector that invoked the mailer **			(for error messages). ** **	Returns: **		exit code of mailer. ** **	Side Effects: **		none. */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|EndWaitTimeout
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|endwaittimeout
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
comment|/* 	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD 	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE 	**	DOING. 	*/
name|errno
operator|=
name|ETIMEDOUT
expr_stmt|;
name|longjmp
argument_list|(
name|EndWaitTimeout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|endmailer
parameter_list|(
name|mci
parameter_list|,
name|e
parameter_list|,
name|pv
parameter_list|)
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
modifier|*
name|pv
decl_stmt|;
block|{
name|int
name|st
decl_stmt|;
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|SM_EVENT
modifier|*
name|ev
init|=
name|NULL
decl_stmt|;
name|mci_unlock_host
argument_list|(
name|mci
argument_list|)
expr_stmt|;
comment|/* close output to mailer */
if|if
condition|(
name|mci
operator|->
name|mci_out
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_out
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* copy any remaining input to transcript */
if|if
condition|(
name|mci
operator|->
name|mci_in
operator|!=
name|NULL
operator|&&
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_ERROR
operator|&&
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|sfgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|mci
operator|->
name|mci_in
argument_list|,
name|TimeOuts
operator|.
name|to_quit
argument_list|,
literal|"Draining Input"
argument_list|)
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_fputs
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|SASL
comment|/* close SASL connection */
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_AUTHACT
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
block|{
name|sasl_dispose
argument_list|(
operator|&
name|mci
operator|->
name|mci_conn
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_flags
operator|&=
operator|~
name|MCIF_AUTHACT
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SASL */
if|#
directive|if
name|STARTTLS
comment|/* shutdown TLS */
operator|(
name|void
operator|)
name|endtlsclt
argument_list|(
name|mci
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* STARTTLS */
comment|/* now close the input */
if|if
condition|(
name|mci
operator|->
name|mci_in
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|mci
operator|->
name|mci_in
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_in
operator|=
name|NULL
expr_stmt|;
block|}
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_CLOSED
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
comment|/* in the IPC case there is nothing to wait for */
if|if
condition|(
name|mci
operator|->
name|mci_pid
operator|==
literal|0
condition|)
return|return
name|EX_OK
return|;
comment|/* put a timeout around the wait */
if|if
condition|(
name|mci
operator|->
name|mci_mailer
operator|->
name|m_wait
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|setjmp
argument_list|(
name|EndWaitTimeout
argument_list|)
operator|==
literal|0
condition|)
name|ev
operator|=
name|sm_setevent
argument_list|(
name|mci
operator|->
name|mci_mailer
operator|->
name|m_wait
argument_list|,
name|endwaittimeout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|syserr
argument_list|(
literal|"endmailer %s: wait timeout (%ld)"
argument_list|,
name|mci
operator|->
name|mci_mailer
operator|->
name|m_name
argument_list|,
operator|(
name|long
operator|)
name|mci
operator|->
name|mci_mailer
operator|->
name|m_wait
argument_list|)
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
block|}
comment|/* wait for the mailer process, collect status */
name|st
operator|=
name|waitfor
argument_list|(
name|mci
operator|->
name|mci_pid
argument_list|)
expr_stmt|;
name|save_errno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|ev
operator|!=
name|NULL
condition|)
name|sm_clrevent
argument_list|(
name|ev
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
if|if
condition|(
name|st
operator|==
operator|-
literal|1
condition|)
block|{
name|syserr
argument_list|(
literal|"endmailer %s: wait"
argument_list|,
name|mci
operator|->
name|mci_mailer
operator|->
name|m_name
argument_list|)
expr_stmt|;
return|return
name|EX_SOFTWARE
return|;
block|}
if|if
condition|(
name|WIFEXITED
argument_list|(
name|st
argument_list|)
condition|)
block|{
comment|/* normal death -- return status */
return|return
operator|(
name|WEXITSTATUS
argument_list|(
name|st
argument_list|)
operator|)
return|;
block|}
comment|/* it died a horrid death */
name|syserr
argument_list|(
literal|"451 4.3.0 mailer %s died with signal %d%s"
argument_list|,
name|mci
operator|->
name|mci_mailer
operator|->
name|m_name
argument_list|,
name|WTERMSIG
argument_list|(
name|st
argument_list|)
argument_list|,
name|WCOREDUMP
argument_list|(
name|st
argument_list|)
condition|?
literal|" (core dumped)"
else|:
operator|(
name|WIFSTOPPED
argument_list|(
name|st
argument_list|)
condition|?
literal|" (stopped)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
comment|/* log the arguments */
if|if
condition|(
name|pv
operator|!=
name|NULL
operator|&&
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Arguments:"
argument_list|)
expr_stmt|;
for|for
control|(
name|av
operator|=
name|pv
init|;
operator|*
name|av
operator|!=
name|NULL
condition|;
name|av
operator|++
control|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|" %s"
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|ExitStat
operator|=
name|EX_TEMPFAIL
expr_stmt|;
return|return
name|EX_TEMPFAIL
return|;
block|}
end_function

begin_comment
comment|/* **  GIVERESPONSE -- Interpret an error response from a mailer ** **	Parameters: **		status -- the status code from the mailer (high byte **			only; core dumps must have been taken care of **			already). **		dsn -- the DSN associated with the address, if any. **		m -- the mailer info for this mailer. **		mci -- the mailer connection info -- can be NULL if the **			response is given before the connection is made. **		ctladdr -- the controlling address for the recipient **			address(es). **		xstart -- the transaction start time, for computing **			transaction delays. **		e -- the current envelope. **		to -- the current recipient (NULL if none). ** **	Returns: **		none. ** **	Side Effects: **		Errors may be incremented. **		ExitStat may be set. */
end_comment

begin_function
name|void
name|giveresponse
parameter_list|(
name|status
parameter_list|,
name|dsn
parameter_list|,
name|m
parameter_list|,
name|mci
parameter_list|,
name|ctladdr
parameter_list|,
name|xstart
parameter_list|,
name|e
parameter_list|,
name|to
parameter_list|)
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|dsn
decl_stmt|;
specifier|register
name|MAILER
modifier|*
name|m
decl_stmt|;
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
name|ADDRESS
modifier|*
name|ctladdr
decl_stmt|;
name|time_t
name|xstart
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|ADDRESS
modifier|*
name|to
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|statmsg
decl_stmt|;
name|int
name|errnum
init|=
name|errno
decl_stmt|;
name|int
name|off
init|=
literal|4
decl_stmt|;
name|bool
name|usestat
init|=
name|false
decl_stmt|;
name|char
name|dsnbuf
index|[
name|ENHSCLEN
index|]
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|char
modifier|*
name|exmsg
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"giveresponse: null envelope"
argument_list|)
expr_stmt|;
comment|/* 	**  Compute status message from code. 	*/
name|exmsg
operator|=
name|sm_sysexmsg
argument_list|(
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|statmsg
operator|=
literal|"250 2.0.0 Sent"
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_statmsg
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"%s (%s)"
argument_list|,
name|statmsg
argument_list|,
name|shortenstring
argument_list|(
name|e
operator|->
name|e_statmsg
argument_list|,
literal|403
argument_list|)
argument_list|)
expr_stmt|;
name|statmsg
operator|=
name|buf
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|exmsg
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"554 5.3.0 unknown mailer error %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|status
operator|=
name|EX_UNAVAILABLE
expr_stmt|;
name|statmsg
operator|=
name|buf
expr_stmt|;
name|usestat
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|EX_TEMPFAIL
condition|)
block|{
name|char
modifier|*
name|bp
init|=
name|buf
decl_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|bp
argument_list|,
name|exmsg
operator|+
literal|1
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|#
directive|if
name|NAMED_BIND
if|if
condition|(
name|h_errno
operator|==
name|TRY_AGAIN
condition|)
name|statmsg
operator|=
name|sm_errstring
argument_list|(
name|h_errno
operator|+
name|E_DNSBASE
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* NAMED_BIND */
block|{
if|if
condition|(
name|errnum
operator|!=
literal|0
condition|)
name|statmsg
operator|=
name|sm_errstring
argument_list|(
name|errnum
argument_list|)
expr_stmt|;
else|else
name|statmsg
operator|=
name|SmtpError
expr_stmt|;
block|}
if|if
condition|(
name|statmsg
operator|!=
name|NULL
operator|&&
name|statmsg
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
switch|switch
condition|(
name|errnum
condition|)
block|{
ifdef|#
directive|ifdef
name|ENETDOWN
case|case
name|ENETDOWN
case|:
comment|/* Network is down */
endif|#
directive|endif
comment|/* ENETDOWN */
ifdef|#
directive|ifdef
name|ENETUNREACH
case|case
name|ENETUNREACH
case|:
comment|/* Network is unreachable */
endif|#
directive|endif
comment|/* ENETUNREACH */
ifdef|#
directive|ifdef
name|ENETRESET
case|case
name|ENETRESET
case|:
comment|/* Network dropped connection on reset */
endif|#
directive|endif
comment|/* ENETRESET */
ifdef|#
directive|ifdef
name|ECONNABORTED
case|case
name|ECONNABORTED
case|:
comment|/* Software caused connection abort */
endif|#
directive|endif
comment|/* ECONNABORTED */
ifdef|#
directive|ifdef
name|EHOSTDOWN
case|case
name|EHOSTDOWN
case|:
comment|/* Host is down */
endif|#
directive|endif
comment|/* EHOSTDOWN */
ifdef|#
directive|ifdef
name|EHOSTUNREACH
case|case
name|EHOSTUNREACH
case|:
comment|/* No route to host */
endif|#
directive|endif
comment|/* EHOSTUNREACH */
if|if
condition|(
name|mci
operator|!=
name|NULL
operator|&&
name|mci
operator|->
name|mci_host
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|bp
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|": "
argument_list|,
name|mci
operator|->
name|mci_host
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|bp
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|": "
argument_list|,
name|statmsg
argument_list|)
expr_stmt|;
name|usestat
operator|=
name|true
expr_stmt|;
block|}
name|statmsg
operator|=
name|buf
expr_stmt|;
block|}
if|#
directive|if
name|NAMED_BIND
elseif|else
if|if
condition|(
name|status
operator|==
name|EX_NOHOST
operator|&&
name|h_errno
operator|!=
literal|0
condition|)
block|{
name|statmsg
operator|=
name|sm_errstring
argument_list|(
name|h_errno
operator|+
name|E_DNSBASE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"%s (%s)"
argument_list|,
name|exmsg
operator|+
literal|1
argument_list|,
name|statmsg
argument_list|)
expr_stmt|;
name|statmsg
operator|=
name|buf
expr_stmt|;
name|usestat
operator|=
name|true
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NAMED_BIND */
else|else
block|{
name|statmsg
operator|=
name|exmsg
expr_stmt|;
if|if
condition|(
operator|*
name|statmsg
operator|++
operator|==
literal|':'
operator|&&
name|errnum
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"%s: %s"
argument_list|,
name|statmsg
argument_list|,
name|sm_errstring
argument_list|(
name|errnum
argument_list|)
argument_list|)
expr_stmt|;
name|statmsg
operator|=
name|buf
expr_stmt|;
name|usestat
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitnset
argument_list|(
name|M_LMTP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|&&
name|e
operator|->
name|e_statmsg
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"%s (%s)"
argument_list|,
name|statmsg
argument_list|,
name|shortenstring
argument_list|(
name|e
operator|->
name|e_statmsg
argument_list|,
literal|403
argument_list|)
argument_list|)
expr_stmt|;
name|statmsg
operator|=
name|buf
expr_stmt|;
name|usestat
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* 	**  Print the message as appropriate 	*/
if|if
condition|(
name|status
operator|==
name|EX_OK
operator|||
name|status
operator|==
name|EX_TEMPFAIL
condition|)
block|{
specifier|extern
name|char
name|MsgBuf
index|[]
decl_stmt|;
if|if
condition|(
operator|(
name|off
operator|=
name|isenhsc
argument_list|(
name|statmsg
operator|+
literal|4
argument_list|,
literal|' '
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|dsn
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|dsnbuf
argument_list|,
sizeof|sizeof
name|dsnbuf
argument_list|,
literal|"%.*s"
argument_list|,
name|off
argument_list|,
name|statmsg
operator|+
literal|4
argument_list|)
expr_stmt|;
name|dsn
operator|=
name|dsnbuf
expr_stmt|;
block|}
name|off
operator|+=
literal|5
expr_stmt|;
block|}
else|else
block|{
name|off
operator|=
literal|4
expr_stmt|;
block|}
name|message
argument_list|(
literal|"%s"
argument_list|,
name|statmsg
operator|+
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EX_TEMPFAIL
operator|&&
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%s\n"
argument_list|,
operator|&
name|MsgBuf
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|mbuf
index|[
name|ENHSCLEN
operator|+
literal|4
index|]
decl_stmt|;
name|Errors
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|off
operator|=
name|isenhsc
argument_list|(
name|statmsg
operator|+
literal|4
argument_list|,
literal|' '
argument_list|)
operator|)
operator|>
literal|0
operator|&&
name|off
operator|<
sizeof|sizeof
name|mbuf
operator|-
literal|4
condition|)
block|{
if|if
condition|(
name|dsn
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|dsnbuf
argument_list|,
sizeof|sizeof
name|dsnbuf
argument_list|,
literal|"%.*s"
argument_list|,
name|off
argument_list|,
name|statmsg
operator|+
literal|4
argument_list|)
expr_stmt|;
name|dsn
operator|=
name|dsnbuf
expr_stmt|;
block|}
name|off
operator|+=
literal|5
expr_stmt|;
comment|/* copy only part of statmsg to mbuf */
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|mbuf
argument_list|,
name|statmsg
argument_list|,
name|off
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|mbuf
argument_list|,
literal|" %s"
argument_list|,
sizeof|sizeof
name|mbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dsnbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|mbuf
argument_list|,
sizeof|sizeof
name|mbuf
argument_list|,
literal|"%.3s %%s"
argument_list|,
name|statmsg
argument_list|)
expr_stmt|;
name|off
operator|=
literal|4
expr_stmt|;
block|}
name|usrerr
argument_list|(
name|mbuf
argument_list|,
operator|&
name|statmsg
index|[
name|off
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Final cleanup. 	**	Log a record of the transaction.  Compute the new 	**	ExitStat -- if we already had an error, stick with 	**	that. 	*/
if|if
condition|(
name|OpMode
operator|!=
name|MD_VERIFY
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_VRFYONLY
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
name|LogLevel
operator|>
operator|(
operator|(
name|status
operator|==
name|EX_TEMPFAIL
operator|)
condition|?
literal|8
else|:
operator|(
name|status
operator|==
name|EX_OK
operator|)
condition|?
literal|7
else|:
literal|6
operator|)
condition|)
name|logdelivery
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|dsn
argument_list|,
name|statmsg
operator|+
name|off
argument_list|,
name|ctladdr
argument_list|,
name|xstart
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"giveresponse: status=%d, dsn=%s, e->e_message=%s, errnum=%d\n"
argument_list|,
name|status
argument_list|,
name|dsn
operator|==
name|NULL
condition|?
literal|"<NULL>"
else|:
name|dsn
argument_list|,
name|e
operator|->
name|e_message
operator|==
name|NULL
condition|?
literal|"<NULL>"
else|:
name|e
operator|->
name|e_message
argument_list|,
name|errnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|EX_TEMPFAIL
condition|)
name|setstat
argument_list|(
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|EX_OK
operator|&&
operator|(
name|status
operator|!=
name|EX_TEMPFAIL
operator|||
name|e
operator|->
name|e_message
operator|==
name|NULL
operator|)
condition|)
name|e
operator|->
name|e_message
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|statmsg
operator|+
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|EX_OK
operator|&&
name|to
operator|!=
name|NULL
operator|&&
name|to
operator|->
name|q_message
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|usestat
operator|&&
name|e
operator|->
name|e_message
operator|!=
name|NULL
condition|)
name|to
operator|->
name|q_message
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|e
operator|->
name|e_message
argument_list|)
expr_stmt|;
else|else
name|to
operator|->
name|q_message
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|statmsg
operator|+
name|off
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|SM_SET_H_ERRNO
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  LOGDELIVERY -- log the delivery in the system log ** **	Care is taken to avoid logging lines that are too long, because **	some versions of syslog have an unfortunate proclivity for core **	dumping.  This is a hack, to be sure, that is at best empirical. ** **	Parameters: **		m -- the mailer info.  Can be NULL for initial queue. **		mci -- the mailer connection info -- can be NULL if the **			log is occurring when no connection is active. **		dsn -- the DSN attached to the status. **		status -- the message to print for the status. **		ctladdr -- the controlling address for the to list. **		xstart -- the transaction start time, used for **			computing transaction delay. **		e -- the current envelope. ** **	Returns: **		none ** **	Side Effects: **		none */
end_comment

begin_function
name|void
name|logdelivery
parameter_list|(
name|m
parameter_list|,
name|mci
parameter_list|,
name|dsn
parameter_list|,
name|status
parameter_list|,
name|ctladdr
parameter_list|,
name|xstart
parameter_list|,
name|e
parameter_list|)
name|MAILER
modifier|*
name|m
decl_stmt|;
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
name|char
modifier|*
name|dsn
decl_stmt|;
specifier|const
name|char
modifier|*
name|status
decl_stmt|;
name|ADDRESS
modifier|*
name|ctladdr
decl_stmt|;
name|time_t
name|xstart
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|l
decl_stmt|;
name|time_t
name|now
init|=
name|curtime
argument_list|()
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
if|#
directive|if
operator|(
name|SYSLOG_BUFSIZE
operator|)
operator|>=
literal|256
comment|/* ctladdr: max 106 bytes */
name|bp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|ctladdr
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|bp
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|", ctladdr="
argument_list|,
name|shortenstring
argument_list|(
name|ctladdr
operator|->
name|q_paddr
argument_list|,
literal|83
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|QGOODUID
argument_list|,
name|ctladdr
operator|->
name|q_flags
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|bp
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|)
argument_list|,
literal|" (%d/%d)"
argument_list|,
operator|(
name|int
operator|)
name|ctladdr
operator|->
name|q_uid
argument_list|,
operator|(
name|int
operator|)
name|ctladdr
operator|->
name|q_gid
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* delay& xdelay: max 41 bytes */
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|bp
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|", delay="
argument_list|,
name|pintvl
argument_list|(
name|now
operator|-
name|e
operator|->
name|e_ctime
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|xstart
operator|!=
operator|(
name|time_t
operator|)
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|bp
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|", xdelay="
argument_list|,
name|pintvl
argument_list|(
name|now
operator|-
name|xstart
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* mailer: assume about 19 bytes (max 10 byte mailer name) */
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|bp
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|", mailer="
argument_list|,
name|m
operator|->
name|m_name
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* pri: changes with each delivery attempt */
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|bp
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|)
argument_list|,
literal|", pri=%ld"
argument_list|,
name|e
operator|->
name|e_msgpriority
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* relay: max 66 bytes for IPv4 addresses */
if|if
condition|(
name|mci
operator|!=
name|NULL
operator|&&
name|mci
operator|->
name|mci_host
operator|!=
name|NULL
condition|)
block|{
specifier|extern
name|SOCKADDR
name|CurHostAddr
decl_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|bp
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|", relay="
argument_list|,
name|shortenstring
argument_list|(
name|mci
operator|->
name|mci_host
argument_list|,
literal|40
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|CurHostAddr
operator|.
name|sa
operator|.
name|sa_family
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|bp
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|)
argument_list|,
literal|" [%s]"
argument_list|,
name|anynet_ntoa
argument_list|(
operator|&
name|CurHostAddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|status
argument_list|,
literal|"quarantined"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|e_quarmsg
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|bp
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|)
argument_list|,
literal|", quarantine=%s"
argument_list|,
name|shortenstring
argument_list|(
name|e
operator|->
name|e_quarmsg
argument_list|,
literal|40
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|status
argument_list|,
literal|"queued"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
name|macvalue
argument_list|(
literal|'h'
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|bp
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|)
argument_list|,
literal|", relay=%s"
argument_list|,
name|shortenstring
argument_list|(
name|p
argument_list|,
literal|40
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* dsn */
if|if
condition|(
name|dsn
operator|!=
name|NULL
operator|&&
operator|*
name|dsn
operator|!=
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|bp
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|", dsn="
argument_list|,
name|shortenstring
argument_list|(
name|dsn
argument_list|,
name|ENHSCLEN
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|_FFR_LOG_NTRIES
comment|/* ntries */
if|if
condition|(
name|e
operator|->
name|e_ntries
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|bp
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|)
argument_list|,
literal|", ntries=%d"
argument_list|,
name|e
operator|->
name|e_ntries
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* _FFR_LOG_NTRIES */
define|#
directive|define
name|STATLEN
value|(((SYSLOG_BUFSIZE) - 100) / 4)
if|#
directive|if
operator|(
name|STATLEN
operator|)
operator|<
literal|63
undef|#
directive|undef
name|STATLEN
define|#
directive|define
name|STATLEN
value|63
endif|#
directive|endif
comment|/* (STATLEN)< 63 */
if|#
directive|if
operator|(
name|STATLEN
operator|)
operator|>
literal|203
undef|#
directive|undef
name|STATLEN
define|#
directive|define
name|STATLEN
value|203
endif|#
directive|endif
comment|/* (STATLEN)> 203 */
comment|/* stat: max 210 bytes */
if|if
condition|(
operator|(
name|bp
operator|-
name|buf
operator|)
operator|>
operator|(
sizeof|sizeof
name|buf
operator|-
operator|(
operator|(
name|STATLEN
operator|)
operator|+
literal|20
operator|)
operator|)
condition|)
block|{
comment|/* desperation move -- truncate data */
name|bp
operator|=
name|buf
operator|+
sizeof|sizeof
name|buf
operator|-
operator|(
operator|(
name|STATLEN
operator|)
operator|+
literal|17
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|bp
argument_list|,
literal|"..."
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|+=
literal|3
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|bp
argument_list|,
literal|", stat="
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|bp
argument_list|,
name|shortenstring
argument_list|(
name|status
argument_list|,
name|STATLEN
argument_list|)
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* id, to: max 13 + TOBUFSIZE bytes */
name|l
operator|=
name|SYSLOG_BUFSIZE
operator|-
literal|100
operator|-
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|<
literal|0
condition|)
name|l
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|e
operator|->
name|e_to
operator|==
name|NULL
condition|?
literal|"NO-TO-LIST"
else|:
name|e
operator|->
name|e_to
expr_stmt|;
while|while
condition|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|>=
name|l
condition|)
block|{
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|p
operator|+
name|l
init|;
name|q
operator|>
name|p
condition|;
name|q
operator|--
control|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|','
condition|)
break|break;
block|}
if|if
condition|(
name|p
operator|==
name|q
condition|)
break|break;
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"to=%.*s [more]%s"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|++
name|q
operator|-
name|p
argument_list|)
argument_list|,
name|p
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"to=%.*s%s"
argument_list|,
name|l
argument_list|,
name|p
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* (SYSLOG_BUFSIZE)>= 256 */
name|l
operator|=
name|SYSLOG_BUFSIZE
operator|-
literal|85
expr_stmt|;
if|if
condition|(
name|l
operator|<
literal|0
condition|)
name|l
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|e
operator|->
name|e_to
operator|==
name|NULL
condition|?
literal|"NO-TO-LIST"
else|:
name|e
operator|->
name|e_to
expr_stmt|;
while|while
condition|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|>=
name|l
condition|)
block|{
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|p
operator|+
name|l
init|;
name|q
operator|>
name|p
condition|;
name|q
operator|--
control|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|','
condition|)
break|break;
block|}
if|if
condition|(
name|p
operator|==
name|q
condition|)
break|break;
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"to=%.*s [more]"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|++
name|q
operator|-
name|p
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"to=%.*s"
argument_list|,
name|l
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctladdr
operator|!=
name|NULL
condition|)
block|{
name|bp
operator|=
name|buf
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|bp
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|"ctladdr="
argument_list|,
name|shortenstring
argument_list|(
name|ctladdr
operator|->
name|q_paddr
argument_list|,
literal|83
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|QGOODUID
argument_list|,
name|ctladdr
operator|->
name|q_flags
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|bp
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|)
argument_list|,
literal|" (%d/%d)"
argument_list|,
name|ctladdr
operator|->
name|q_uid
argument_list|,
name|ctladdr
operator|->
name|q_gid
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|bp
operator|=
name|buf
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|bp
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|"delay="
argument_list|,
name|pintvl
argument_list|(
name|now
operator|-
name|e
operator|->
name|e_ctime
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|xstart
operator|!=
operator|(
name|time_t
operator|)
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|bp
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|", xdelay="
argument_list|,
name|pintvl
argument_list|(
name|now
operator|-
name|xstart
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|bp
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|", mailer="
argument_list|,
name|m
operator|->
name|m_name
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%.1000s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|mci
operator|!=
name|NULL
operator|&&
name|mci
operator|->
name|mci_host
operator|!=
name|NULL
condition|)
block|{
specifier|extern
name|SOCKADDR
name|CurHostAddr
decl_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|bp
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|)
argument_list|,
literal|"relay=%.100s"
argument_list|,
name|mci
operator|->
name|mci_host
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|CurHostAddr
operator|.
name|sa
operator|.
name|sa_family
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|bp
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|)
argument_list|,
literal|" [%.100s]"
argument_list|,
name|anynet_ntoa
argument_list|(
operator|&
name|CurHostAddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|status
argument_list|,
literal|"quarantined"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|e_quarmsg
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|bp
argument_list|,
name|SPACELEFT
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|)
argument_list|,
literal|", quarantine=%.100s"
argument_list|,
name|e
operator|->
name|e_quarmsg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|status
argument_list|,
literal|"queued"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
name|macvalue
argument_list|(
literal|'h'
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"relay=%.100s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%.1000s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"stat=%s"
argument_list|,
name|shortenstring
argument_list|(
name|status
argument_list|,
literal|63
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (SYSLOG_BUFSIZE)>= 256 */
block|}
end_function

begin_comment
comment|/* **  PUTFROMLINE -- output a UNIX-style from line (or whatever) ** **	This can be made an arbitrary message separator by changing $l ** **	One of the ugliest hacks seen by human eyes is contained herein: **	UUCP wants those stupid "remote from<host>" lines.  Why oh why **	does a well-meaning programmer such as myself have to deal with **	this kind of antique garbage???? ** **	Parameters: **		mci -- the connection information. **		e -- the envelope. ** **	Returns: **		true iff line was written successfully ** **	Side Effects: **		outputs some text to fp. */
end_comment

begin_function
name|bool
name|putfromline
parameter_list|(
name|mci
parameter_list|,
name|e
parameter_list|)
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|char
modifier|*
name|template
init|=
name|UnixFromLine
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|char
name|xbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
if|if
condition|(
name|bitnset
argument_list|(
name|M_NHDR
argument_list|,
name|mci
operator|->
name|mci_mailer
operator|->
name|m_flags
argument_list|)
condition|)
return|return
name|true
return|;
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_INHEADER
expr_stmt|;
if|if
condition|(
name|bitnset
argument_list|(
name|M_UGLYUUCP
argument_list|,
name|mci
operator|->
name|mci_mailer
operator|->
name|m_flags
argument_list|)
condition|)
block|{
name|char
modifier|*
name|bang
decl_stmt|;
name|expand
argument_list|(
literal|"\201g"
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|bang
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|bang
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|at
decl_stmt|;
name|char
name|hname
index|[
name|MAXNAME
index|]
decl_stmt|;
comment|/* 			**  If we can construct a UUCP path, do so 			*/
name|at
operator|=
name|strrchr
argument_list|(
name|buf
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
operator|==
name|NULL
condition|)
block|{
name|expand
argument_list|(
literal|"\201k"
argument_list|,
name|hname
argument_list|,
sizeof|sizeof
name|hname
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|at
operator|=
name|hname
expr_stmt|;
block|}
else|else
operator|*
name|at
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|xbuf
argument_list|,
sizeof|sizeof
name|xbuf
argument_list|,
literal|"From %.800s  \201d remote from %.100s\n"
argument_list|,
name|buf
argument_list|,
name|at
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|bang
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|xbuf
argument_list|,
sizeof|sizeof
name|xbuf
argument_list|,
literal|"From %.800s  \201d remote from %.100s\n"
argument_list|,
name|bang
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|template
operator|=
name|xbuf
expr_stmt|;
block|}
block|}
name|expand
argument_list|(
name|template
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|putxline
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|mci
argument_list|,
name|PXLF_HEADER
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  PUTBODY -- put the body of a message. ** **	Parameters: **		mci -- the connection information. **		e -- the envelope to put out. **		separator -- if non-NULL, a message separator that must **			not be permitted in the resulting message. ** **	Returns: **		true iff message was written successfully ** **	Side Effects: **		The message is written onto fp. */
end_comment

begin_comment
comment|/* values for output state variable */
end_comment

begin_define
define|#
directive|define
name|OSTATE_HEAD
value|0
end_define

begin_comment
comment|/* at beginning of line */
end_comment

begin_define
define|#
directive|define
name|OSTATE_CR
value|1
end_define

begin_comment
comment|/* read a carriage return */
end_comment

begin_define
define|#
directive|define
name|OSTATE_INLINE
value|2
end_define

begin_comment
comment|/* putting rest of line */
end_comment

begin_function
name|bool
name|putbody
parameter_list|(
name|mci
parameter_list|,
name|e
parameter_list|,
name|separator
parameter_list|)
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|separator
decl_stmt|;
block|{
name|bool
name|dead
init|=
name|false
decl_stmt|;
name|bool
name|ioerr
init|=
name|false
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
if|#
directive|if
name|MIME8TO7
name|char
modifier|*
name|boundaries
index|[
name|MAXMIMENESTING
operator|+
literal|1
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* MIME8TO7 */
comment|/* 	**  Output the body of the message 	*/
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|==
name|NULL
operator|&&
name|bitset
argument_list|(
name|EF_HAS_DF
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|char
modifier|*
name|df
init|=
name|queuename
argument_list|(
name|e
argument_list|,
name|DATAFL_LETTER
argument_list|)
decl_stmt|;
name|e
operator|->
name|e_dfp
operator|=
name|sm_io_open
argument_list|(
name|SmFtStdio
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|df
argument_list|,
name|SM_IO_RDONLY_B
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|msg
init|=
literal|"!putbody: Cannot open %s for %s from %s"
decl_stmt|;
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
name|msg
operator|++
expr_stmt|;
name|syserr
argument_list|(
name|msg
argument_list|,
name|df
argument_list|,
name|e
operator|->
name|e_to
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_INHEADER
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|putline
argument_list|(
literal|""
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
name|mci
operator|->
name|mci_flags
operator|&=
operator|~
name|MCIF_INHEADER
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|putline
argument_list|(
literal|"<<< No Message Collected>>>"
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
goto|goto
name|endofmessage
goto|;
block|}
if|if
condition|(
name|e
operator|->
name|e_dfino
operator|==
operator|(
name|ino_t
operator|)
literal|0
condition|)
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|sm_io_getinfo
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|<
literal|0
condition|)
name|e
operator|->
name|e_dfino
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|e
operator|->
name|e_dfdev
operator|=
name|stbuf
operator|.
name|st_dev
expr_stmt|;
name|e
operator|->
name|e_dfino
operator|=
name|stbuf
operator|.
name|st_ino
expr_stmt|;
block|}
block|}
comment|/* paranoia: the data file should always be in a rewound state */
operator|(
name|void
operator|)
name|bfrewind
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|)
expr_stmt|;
comment|/* simulate an I/O timeout when used as source */
if|if
condition|(
name|tTd
argument_list|(
literal|84
argument_list|,
literal|101
argument_list|)
condition|)
name|sleep
argument_list|(
literal|319
argument_list|)
expr_stmt|;
if|#
directive|if
name|MIME8TO7
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_CVT8TO7
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
block|{
comment|/* 		**  Do 8 to 7 bit MIME conversion. 		*/
comment|/* make sure it looks like a MIME message */
if|if
condition|(
name|hvalue
argument_list|(
literal|"MIME-Version"
argument_list|,
name|e
operator|->
name|e_header
argument_list|)
operator|==
name|NULL
operator|&&
operator|!
name|putline
argument_list|(
literal|"MIME-Version: 1.0"
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
if|if
condition|(
name|hvalue
argument_list|(
literal|"Content-Type"
argument_list|,
name|e
operator|->
name|e_header
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"Content-Type: text/plain; charset=%s"
argument_list|,
name|defcharset
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
comment|/* now do the hard work */
name|boundaries
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_INHEADER
expr_stmt|;
if|if
condition|(
name|mime8to7
argument_list|(
name|mci
argument_list|,
name|e
operator|->
name|e_header
argument_list|,
name|e
argument_list|,
name|boundaries
argument_list|,
name|M87F_OUTER
argument_list|)
operator|==
name|SM_IO_EOF
condition|)
goto|goto
name|writeerr
goto|;
block|}
if|#
directive|if
name|MIME7TO8
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_CVT7TO8
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|mime7to8
argument_list|(
name|mci
argument_list|,
name|e
operator|->
name|e_header
argument_list|,
name|e
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
endif|#
directive|endif
comment|/* MIME7TO8 */
elseif|else
if|if
condition|(
name|MaxMimeHeaderLength
operator|>
literal|0
operator|||
name|MaxMimeFieldLength
operator|>
literal|0
condition|)
block|{
name|bool
name|oldsuprerrs
init|=
name|SuprErrs
decl_stmt|;
comment|/* Use mime8to7 to check multipart for MIME header overflows */
name|boundaries
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_INHEADER
expr_stmt|;
comment|/* 		**  If EF_DONT_MIME is set, we have a broken MIME message 		**  and don't want to generate a new bounce message whose 		**  body propagates the broken MIME.  We can't just not call 		**  mime8to7() as is done above since we need the security 		**  checks.  The best we can do is suppress the errors. 		*/
if|if
condition|(
name|bitset
argument_list|(
name|EF_DONT_MIME
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|SuprErrs
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|mime8to7
argument_list|(
name|mci
argument_list|,
name|e
operator|->
name|e_header
argument_list|,
name|e
argument_list|,
name|boundaries
argument_list|,
name|M87F_OUTER
operator||
name|M87F_NO8TO7
argument_list|)
operator|==
name|SM_IO_EOF
condition|)
goto|goto
name|writeerr
goto|;
comment|/* restore SuprErrs */
name|SuprErrs
operator|=
name|oldsuprerrs
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* MIME8TO7 */
block|{
name|int
name|ostate
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
specifier|register
name|char
modifier|*
name|pbp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|xp
decl_stmt|;
name|int
name|padc
decl_stmt|;
name|char
modifier|*
name|buflim
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|char
name|peekbuf
index|[
literal|12
index|]
decl_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_INHEADER
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|putline
argument_list|(
literal|""
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
name|mci
operator|->
name|mci_flags
operator|&=
operator|~
name|MCIF_INHEADER
expr_stmt|;
block|}
comment|/* determine end of buffer; allow for short mailer lines */
name|buflim
operator|=
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_mailer
operator|->
name|m_linelimit
operator|>
literal|0
operator|&&
name|mci
operator|->
name|mci_mailer
operator|->
name|m_linelimit
operator|<
sizeof|sizeof
name|buf
operator|-
literal|1
condition|)
name|buflim
operator|=
operator|&
name|buf
index|[
name|mci
operator|->
name|mci_mailer
operator|->
name|m_linelimit
operator|-
literal|1
index|]
expr_stmt|;
comment|/* copy temp file to output with mapping */
name|ostate
operator|=
name|OSTATE_HEAD
expr_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
name|pbp
operator|=
name|peekbuf
expr_stmt|;
while|while
condition|(
operator|!
name|sm_io_error
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|)
operator|&&
operator|!
name|dead
condition|)
block|{
if|if
condition|(
name|pbp
operator|>
name|peekbuf
condition|)
name|c
operator|=
operator|*
operator|--
name|pbp
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|c
operator|=
name|sm_io_getc
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
operator|)
operator|==
name|SM_IO_EOF
condition|)
break|break;
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_7BIT
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
name|c
operator|&=
literal|0x7f
expr_stmt|;
switch|switch
condition|(
name|ostate
condition|)
block|{
case|case
name|OSTATE_HEAD
case|:
if|if
condition|(
name|c
operator|==
literal|'\0'
operator|&&
name|bitnset
argument_list|(
name|M_NONULLS
argument_list|,
name|mci
operator|->
name|mci_mailer
operator|->
name|m_flags
argument_list|)
condition|)
break|break;
if|if
condition|(
name|c
operator|!=
literal|'\r'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|bp
operator|<
name|buflim
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
comment|/* check beginning of line for special cases */
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
name|padc
operator|=
name|SM_IO_EOF
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'F'
operator|&&
name|bitnset
argument_list|(
name|M_ESCFROM
argument_list|,
name|mci
operator|->
name|mci_mailer
operator|->
name|m_flags
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"From "
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|padc
operator|=
literal|'>'
expr_stmt|;
block|}
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
literal|'-'
operator|&&
name|separator
operator|!=
name|NULL
condition|)
block|{
comment|/* possible separator */
name|int
name|sl
init|=
name|strlen
argument_list|(
name|separator
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
operator|&
name|buf
index|[
literal|2
index|]
argument_list|,
name|separator
argument_list|,
name|sl
argument_list|)
operator|==
literal|0
condition|)
name|padc
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|bitnset
argument_list|(
name|M_XDOT
argument_list|,
name|mci
operator|->
name|mci_mailer
operator|->
name|m_flags
argument_list|)
condition|)
block|{
name|padc
operator|=
literal|'.'
expr_stmt|;
block|}
comment|/* now copy out saved line */
if|if
condition|(
name|TrafficLogFile
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|TrafficLogFile
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"%05d>>> "
argument_list|,
operator|(
name|int
operator|)
name|CurrentPid
argument_list|)
expr_stmt|;
if|if
condition|(
name|padc
operator|!=
name|SM_IO_EOF
condition|)
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|TrafficLogFile
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|padc
argument_list|)
expr_stmt|;
for|for
control|(
name|xp
operator|=
name|buf
init|;
name|xp
operator|<
name|bp
condition|;
name|xp
operator|++
control|)
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|TrafficLogFile
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
operator|(
name|unsigned
name|char
operator|)
operator|*
name|xp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
operator|(
name|void
operator|)
name|sm_io_fputs
argument_list|(
name|TrafficLogFile
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|mci
operator|->
name|mci_mailer
operator|->
name|m_eol
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|padc
operator|!=
name|SM_IO_EOF
condition|)
block|{
if|if
condition|(
name|sm_io_putc
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|padc
argument_list|)
operator|==
name|SM_IO_EOF
condition|)
block|{
name|dead
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
name|pos
operator|++
expr_stmt|;
block|}
for|for
control|(
name|xp
operator|=
name|buf
init|;
name|xp
operator|<
name|bp
condition|;
name|xp
operator|++
control|)
block|{
if|if
condition|(
name|sm_io_putc
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
operator|(
name|unsigned
name|char
operator|)
operator|*
name|xp
argument_list|)
operator|==
name|SM_IO_EOF
condition|)
block|{
name|dead
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|dead
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|sm_io_fputs
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|mci
operator|->
name|mci_mailer
operator|->
name|m_eol
argument_list|)
operator|==
name|SM_IO_EOF
condition|)
break|break;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|+=
name|bp
operator|-
name|buf
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\r'
condition|)
block|{
name|SM_ASSERT
argument_list|(
name|pbp
operator|<
name|peekbuf
operator|+
sizeof|sizeof
argument_list|(
name|peekbuf
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pbp
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
name|bp
operator|=
name|buf
expr_stmt|;
comment|/* determine next state */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|ostate
operator|=
name|OSTATE_HEAD
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
name|ostate
operator|=
name|OSTATE_CR
expr_stmt|;
else|else
name|ostate
operator|=
name|OSTATE_INLINE
expr_stmt|;
continue|continue;
case|case
name|OSTATE_CR
case|:
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* got CRLF */
if|if
condition|(
name|sm_io_fputs
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|mci
operator|->
name|mci_mailer
operator|->
name|m_eol
argument_list|)
operator|==
name|SM_IO_EOF
condition|)
continue|continue;
if|if
condition|(
name|TrafficLogFile
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fputs
argument_list|(
name|TrafficLogFile
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|mci
operator|->
name|mci_mailer
operator|->
name|m_eol
argument_list|)
expr_stmt|;
block|}
name|ostate
operator|=
name|OSTATE_HEAD
expr_stmt|;
continue|continue;
block|}
comment|/* had a naked carriage return */
name|SM_ASSERT
argument_list|(
name|pbp
operator|<
name|peekbuf
operator|+
sizeof|sizeof
argument_list|(
name|peekbuf
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pbp
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
literal|'\r'
expr_stmt|;
name|ostate
operator|=
name|OSTATE_INLINE
expr_stmt|;
goto|goto
name|putch
goto|;
case|case
name|OSTATE_INLINE
case|:
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
block|{
name|ostate
operator|=
name|OSTATE_CR
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'\0'
operator|&&
name|bitnset
argument_list|(
name|M_NONULLS
argument_list|,
name|mci
operator|->
name|mci_mailer
operator|->
name|m_flags
argument_list|)
condition|)
break|break;
name|putch
label|:
if|if
condition|(
name|mci
operator|->
name|mci_mailer
operator|->
name|m_linelimit
operator|>
literal|0
operator|&&
name|pos
operator|>=
name|mci
operator|->
name|mci_mailer
operator|->
name|m_linelimit
operator|-
literal|1
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|int
name|d
decl_stmt|;
comment|/* check next character for EOL */
if|if
condition|(
name|pbp
operator|>
name|peekbuf
condition|)
name|d
operator|=
operator|*
operator|(
name|pbp
operator|-
literal|1
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|d
operator|=
name|sm_io_getc
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
operator|)
operator|!=
name|SM_IO_EOF
condition|)
block|{
name|SM_ASSERT
argument_list|(
name|pbp
operator|<
name|peekbuf
operator|+
sizeof|sizeof
argument_list|(
name|peekbuf
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pbp
operator|++
operator|=
name|d
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|==
literal|'\n'
operator|||
name|d
operator|==
name|SM_IO_EOF
condition|)
block|{
if|if
condition|(
name|TrafficLogFile
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|TrafficLogFile
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm_io_putc
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
operator|==
name|SM_IO_EOF
condition|)
block|{
name|dead
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
name|pos
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sm_io_putc
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|'!'
argument_list|)
operator|==
name|SM_IO_EOF
operator|||
name|sm_io_fputs
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|mci
operator|->
name|mci_mailer
operator|->
name|m_eol
argument_list|)
operator|==
name|SM_IO_EOF
condition|)
block|{
name|dead
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TrafficLogFile
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|TrafficLogFile
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"!%s"
argument_list|,
name|mci
operator|->
name|mci_mailer
operator|->
name|m_eol
argument_list|)
expr_stmt|;
block|}
name|ostate
operator|=
name|OSTATE_HEAD
expr_stmt|;
name|SM_ASSERT
argument_list|(
name|pbp
operator|<
name|peekbuf
operator|+
sizeof|sizeof
argument_list|(
name|peekbuf
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pbp
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|TrafficLogFile
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_fputs
argument_list|(
name|TrafficLogFile
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|mci
operator|->
name|mci_mailer
operator|->
name|m_eol
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm_io_fputs
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|mci
operator|->
name|mci_mailer
operator|->
name|m_eol
argument_list|)
operator|==
name|SM_IO_EOF
condition|)
continue|continue;
name|pos
operator|=
literal|0
expr_stmt|;
name|ostate
operator|=
name|OSTATE_HEAD
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TrafficLogFile
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|TrafficLogFile
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm_io_putc
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
operator|==
name|SM_IO_EOF
condition|)
block|{
name|dead
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
name|pos
operator|++
expr_stmt|;
name|ostate
operator|=
name|OSTATE_INLINE
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* make sure we are at the beginning of a line */
if|if
condition|(
name|bp
operator|>
name|buf
condition|)
block|{
if|if
condition|(
name|TrafficLogFile
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|xp
operator|=
name|buf
init|;
name|xp
operator|<
name|bp
condition|;
name|xp
operator|++
control|)
operator|(
name|void
operator|)
name|sm_io_putc
argument_list|(
name|TrafficLogFile
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
operator|(
name|unsigned
name|char
operator|)
operator|*
name|xp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|xp
operator|=
name|buf
init|;
name|xp
operator|<
name|bp
condition|;
name|xp
operator|++
control|)
block|{
if|if
condition|(
name|sm_io_putc
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
operator|(
name|unsigned
name|char
operator|)
operator|*
name|xp
argument_list|)
operator|==
name|SM_IO_EOF
condition|)
block|{
name|dead
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
name|pos
operator|+=
name|bp
operator|-
name|buf
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dead
operator|&&
name|pos
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|TrafficLogFile
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_fputs
argument_list|(
name|TrafficLogFile
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|mci
operator|->
name|mci_mailer
operator|->
name|m_eol
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm_io_fputs
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|mci
operator|->
name|mci_mailer
operator|->
name|m_eol
argument_list|)
operator|==
name|SM_IO_EOF
condition|)
goto|goto
name|writeerr
goto|;
block|}
block|}
if|if
condition|(
name|sm_io_error
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|)
condition|)
block|{
name|syserr
argument_list|(
literal|"putbody: %s/%cf%s: read error"
argument_list|,
name|qid_printqueue
argument_list|(
name|e
operator|->
name|e_dfqgrp
argument_list|,
name|e
operator|->
name|e_dfqdir
argument_list|)
argument_list|,
name|DATAFL_LETTER
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_IOERR
expr_stmt|;
name|ioerr
operator|=
name|true
expr_stmt|;
block|}
name|endofmessage
label|:
comment|/* 	**  Since mailfile() uses e_dfp in a child process, 	**  the file offset in the stdio library for the 	**  parent process will not agree with the in-kernel 	**  file offset since the file descriptor is shared 	**  between the processes.  Therefore, it is vital 	**  that the file always be rewound.  This forces the 	**  kernel offset (lseek) and stdio library (ftell) 	**  offset to match. 	*/
name|save_errno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|bfrewind
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|)
expr_stmt|;
comment|/* some mailers want extra blank line at end of message */
if|if
condition|(
operator|!
name|dead
operator|&&
name|bitnset
argument_list|(
name|M_BLANKEND
argument_list|,
name|mci
operator|->
name|mci_mailer
operator|->
name|m_flags
argument_list|)
operator|&&
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|!
name|putline
argument_list|(
literal|""
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
if|if
condition|(
operator|!
name|dead
operator|&&
operator|(
name|sm_io_flush
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
operator|==
name|SM_IO_EOF
operator|||
operator|(
name|sm_io_error
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|)
operator|&&
name|errno
operator|!=
name|EPIPE
operator|)
operator|)
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
name|syserr
argument_list|(
literal|"putbody: write error"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_IOERR
expr_stmt|;
name|ioerr
operator|=
name|true
expr_stmt|;
block|}
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
operator|!
name|dead
operator|&&
operator|!
name|ioerr
return|;
name|writeerr
label|:
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* **  MAILFILE -- Send a message to a file. ** **	If the file has the set-user-ID/set-group-ID bits set, but NO **	execute bits, sendmail will try to become the owner of that file **	rather than the real user.  Obviously, this only works if **	sendmail runs as root. ** **	This could be done as a subordinate mailer, except that it **	is used implicitly to save messages in ~/dead.letter.  We **	view this as being sufficiently important as to include it **	here.  For example, if the system is dying, we shouldn't have **	to create another process plus some pipes to save the message. ** **	Parameters: **		filename -- the name of the file to send to. **		mailer -- mailer definition for recipient -- if NULL, **			use FileMailer. **		ctladdr -- the controlling address header -- includes **			the userid/groupid to be when sending. **		sfflags -- flags for opening. **		e -- the current envelope. ** **	Returns: **		The exit code associated with the operation. ** **	Side Effects: **		none. */
end_comment

begin_define
define|#
directive|define
name|RETURN
parameter_list|(
name|st
parameter_list|)
value|exit(st);
end_define

begin_decl_stmt
specifier|static
name|jmp_buf
name|CtxMailfileTimeout
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|mailfile
parameter_list|(
name|filename
parameter_list|,
name|mailer
parameter_list|,
name|ctladdr
parameter_list|,
name|sfflags
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
specifier|volatile
name|filename
decl_stmt|;
name|MAILER
modifier|*
specifier|volatile
name|mailer
decl_stmt|;
name|ADDRESS
modifier|*
name|ctladdr
decl_stmt|;
specifier|volatile
name|long
name|sfflags
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|SM_FILE_T
modifier|*
name|f
decl_stmt|;
specifier|register
name|pid_t
name|pid
init|=
operator|-
literal|1
decl_stmt|;
specifier|volatile
name|int
name|mode
decl_stmt|;
name|int
name|len
decl_stmt|;
name|off_t
name|curoff
decl_stmt|;
name|bool
name|suidwarn
init|=
name|geteuid
argument_list|()
operator|==
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
specifier|volatile
name|realfile
decl_stmt|;
name|SM_EVENT
modifier|*
name|ev
decl_stmt|;
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|targetfile
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"mailfile %s\n  ctladdr="
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|ctladdr
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mailer
operator|==
name|NULL
condition|)
name|mailer
operator|=
name|FileMailer
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_flush
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
comment|/* 	**  Special case /dev/null.  This allows us to restrict file 	**  delivery to regular files only. 	*/
if|if
condition|(
name|sm_path_isdevnull
argument_list|(
name|filename
argument_list|)
condition|)
return|return
name|EX_OK
return|;
comment|/* check for 8-bit available */
if|if
condition|(
name|bitset
argument_list|(
name|EF_HAS8BIT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
name|bitnset
argument_list|(
name|M_7BITS
argument_list|,
name|mailer
operator|->
name|m_flags
argument_list|)
operator|&&
operator|(
name|bitset
argument_list|(
name|EF_DONT_MIME
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|||
operator|!
operator|(
name|bitset
argument_list|(
name|MM_MIME8BIT
argument_list|,
name|MimeMode
argument_list|)
operator|||
operator|(
name|bitset
argument_list|(
name|EF_IS_MIME
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
name|bitset
argument_list|(
name|MM_CVTMIME
argument_list|,
name|MimeMode
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|e
operator|->
name|e_status
operator|=
literal|"5.6.3"
expr_stmt|;
name|usrerrenh
argument_list|(
name|e
operator|->
name|e_status
argument_list|,
literal|"554 Cannot send 8-bit data to 7-bit destination"
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
return|return
name|EX_DATAERR
return|;
block|}
comment|/* Find the actual file */
if|if
condition|(
name|SafeFileEnv
operator|!=
name|NULL
operator|&&
name|SafeFileEnv
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|SafeFileEnv
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|SafeFileEnv
argument_list|,
name|filename
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
name|filename
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
operator|>=
sizeof|sizeof
name|targetfile
condition|)
block|{
name|syserr
argument_list|(
literal|"mailfile: filename too long (%s/%s)"
argument_list|,
name|SafeFileEnv
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
name|EX_CANTCREAT
return|;
block|}
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|targetfile
argument_list|,
name|SafeFileEnv
argument_list|,
sizeof|sizeof
name|targetfile
argument_list|)
expr_stmt|;
name|realfile
operator|=
name|targetfile
operator|+
name|len
expr_stmt|;
if|if
condition|(
operator|*
name|filename
operator|==
literal|'/'
condition|)
name|filename
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|filename
operator|!=
literal|'\0'
condition|)
block|{
comment|/* paranoia: trailing / should be removed in readcf */
if|if
condition|(
name|targetfile
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|targetfile
argument_list|,
literal|"/"
argument_list|,
sizeof|sizeof
name|targetfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|targetfile
argument_list|,
name|filename
argument_list|,
sizeof|sizeof
name|targetfile
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mailer
operator|->
name|m_rootdir
operator|!=
name|NULL
condition|)
block|{
name|expand
argument_list|(
name|mailer
operator|->
name|m_rootdir
argument_list|,
name|targetfile
argument_list|,
sizeof|sizeof
name|targetfile
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|targetfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|targetfile
argument_list|,
name|filename
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
name|filename
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
operator|>=
sizeof|sizeof
name|targetfile
condition|)
block|{
name|syserr
argument_list|(
literal|"mailfile: filename too long (%s/%s)"
argument_list|,
name|targetfile
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
name|EX_CANTCREAT
return|;
block|}
name|realfile
operator|=
name|targetfile
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|targetfile
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|targetfile
argument_list|,
literal|"/"
argument_list|,
sizeof|sizeof
name|targetfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|filename
operator|==
literal|'/'
condition|)
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|targetfile
argument_list|,
name|filename
operator|+
literal|1
argument_list|,
sizeof|sizeof
name|targetfile
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sm_strlcat
argument_list|(
name|targetfile
argument_list|,
name|filename
argument_list|,
sizeof|sizeof
name|targetfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sm_strlcpy
argument_list|(
name|targetfile
argument_list|,
name|filename
argument_list|,
sizeof|sizeof
name|targetfile
argument_list|)
operator|>=
sizeof|sizeof
name|targetfile
condition|)
block|{
name|syserr
argument_list|(
literal|"mailfile: filename too long (%s)"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
name|EX_CANTCREAT
return|;
block|}
name|realfile
operator|=
name|targetfile
expr_stmt|;
block|}
comment|/* 	**  Fork so we can change permissions here. 	**	Note that we MUST use fork, not vfork, because of 	**	the complications of calling subroutines, etc. 	*/
comment|/* 	**  Dispose of SIGCHLD signal catchers that may be laying 	**  around so that the waitfor() below will get it. 	*/
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|DOFORK
argument_list|(
name|fork
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
return|return
name|EX_OSERR
return|;
elseif|else
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* child -- actually write to file */
name|struct
name|stat
name|stb
decl_stmt|;
name|MCI
name|mcibuf
decl_stmt|;
name|int
name|err
decl_stmt|;
specifier|volatile
name|int
name|oflags
init|=
name|O_WRONLY
operator||
name|O_APPEND
decl_stmt|;
comment|/* Reset global flags */
name|RestartRequest
operator|=
name|NULL
expr_stmt|;
name|RestartWorkGroup
operator|=
name|false
expr_stmt|;
name|ShutdownRequest
operator|=
name|NULL
expr_stmt|;
name|PendingSignal
operator|=
literal|0
expr_stmt|;
name|CurrentPid
operator|=
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_lockfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|sm_io_getinfo
argument_list|(
name|e
operator|->
name|e_lockfp
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|OldUmask
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|filename
expr_stmt|;
name|ExitStat
operator|=
name|EX_OK
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|CtxMailfileTimeout
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|RETURN
argument_list|(
name|EX_TEMPFAIL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TimeOuts
operator|.
name|to_fileopen
operator|>
literal|0
condition|)
name|ev
operator|=
name|sm_setevent
argument_list|(
name|TimeOuts
operator|.
name|to_fileopen
argument_list|,
name|mailfiletimeout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ev
operator|=
name|NULL
expr_stmt|;
comment|/* check file mode to see if set-user-ID */
if|if
condition|(
name|stat
argument_list|(
name|targetfile
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
name|mode
operator|=
name|FileMode
expr_stmt|;
else|else
name|mode
operator|=
name|stb
operator|.
name|st_mode
expr_stmt|;
comment|/* limit the errors to those actually caused in the child */
name|errno
operator|=
literal|0
expr_stmt|;
name|ExitStat
operator|=
name|EX_OK
expr_stmt|;
comment|/* Allow alias expansions to use the S_IS{U,G}ID bits */
if|if
condition|(
operator|(
name|ctladdr
operator|!=
name|NULL
operator|&&
operator|!
name|bitset
argument_list|(
name|QALIAS
argument_list|,
name|ctladdr
operator|->
name|q_flags
argument_list|)
operator|)
operator|||
name|bitset
argument_list|(
name|SFF_RUNASREALUID
argument_list|,
name|sfflags
argument_list|)
condition|)
block|{
comment|/* ignore set-user-ID and set-group-ID bits */
name|mode
operator|&=
operator|~
operator|(
name|S_ISGID
operator||
name|S_ISUID
operator|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|20
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"mailfile: ignoring set-user-ID/set-group-ID bits\n"
argument_list|)
expr_stmt|;
block|}
comment|/* we have to open the data file BEFORE setuid() */
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|==
name|NULL
operator|&&
name|bitset
argument_list|(
name|EF_HAS_DF
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|char
modifier|*
name|df
init|=
name|queuename
argument_list|(
name|e
argument_list|,
name|DATAFL_LETTER
argument_list|)
decl_stmt|;
name|e
operator|->
name|e_dfp
operator|=
name|sm_io_open
argument_list|(
name|SmFtStdio
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|df
argument_list|,
name|SM_IO_RDONLY_B
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"mailfile: Cannot open %s for %s from %s"
argument_list|,
name|df
argument_list|,
name|e
operator|->
name|e_to
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* select a new user to run as */
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|SFF_RUNASREALUID
argument_list|,
name|sfflags
argument_list|)
condition|)
block|{
if|if
condition|(
name|bitnset
argument_list|(
name|M_SPECIFIC_UID
argument_list|,
name|mailer
operator|->
name|m_flags
argument_list|)
condition|)
block|{
name|RealUserName
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mailer
operator|->
name|m_uid
operator|==
name|NO_UID
condition|)
name|RealUid
operator|=
name|RunAsUid
expr_stmt|;
else|else
name|RealUid
operator|=
name|mailer
operator|->
name|m_uid
expr_stmt|;
if|if
condition|(
name|RunAsUid
operator|!=
literal|0
operator|&&
name|RealUid
operator|!=
name|RunAsUid
condition|)
block|{
comment|/* Only root can change the uid */
name|syserr
argument_list|(
literal|"mailfile: insufficient privileges to change uid, RunAsUid=%d, RealUid=%d"
argument_list|,
operator|(
name|int
operator|)
name|RunAsUid
argument_list|,
operator|(
name|int
operator|)
name|RealUid
argument_list|)
expr_stmt|;
name|RETURN
argument_list|(
name|EX_TEMPFAIL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|S_ISUID
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|RealUserName
operator|=
name|NULL
expr_stmt|;
name|RealUid
operator|=
name|stb
operator|.
name|st_uid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctladdr
operator|!=
name|NULL
operator|&&
name|ctladdr
operator|->
name|q_uid
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ctladdr
operator|->
name|q_ruser
operator|!=
name|NULL
condition|)
name|RealUserName
operator|=
name|ctladdr
operator|->
name|q_ruser
expr_stmt|;
else|else
name|RealUserName
operator|=
name|ctladdr
operator|->
name|q_user
expr_stmt|;
name|RealUid
operator|=
name|ctladdr
operator|->
name|q_uid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mailer
operator|!=
name|NULL
operator|&&
name|mailer
operator|->
name|m_uid
operator|!=
name|NO_UID
condition|)
block|{
name|RealUserName
operator|=
name|DefUser
expr_stmt|;
name|RealUid
operator|=
name|mailer
operator|->
name|m_uid
expr_stmt|;
block|}
else|else
block|{
name|RealUserName
operator|=
name|DefUser
expr_stmt|;
name|RealUid
operator|=
name|DefUid
expr_stmt|;
block|}
comment|/* select a new group to run as */
if|if
condition|(
name|bitnset
argument_list|(
name|M_SPECIFIC_UID
argument_list|,
name|mailer
operator|->
name|m_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|mailer
operator|->
name|m_gid
operator|==
name|NO_GID
condition|)
name|RealGid
operator|=
name|RunAsGid
expr_stmt|;
else|else
name|RealGid
operator|=
name|mailer
operator|->
name|m_gid
expr_stmt|;
if|if
condition|(
name|RunAsUid
operator|!=
literal|0
operator|&&
operator|(
name|RealGid
operator|!=
name|getgid
argument_list|()
operator|||
name|RealGid
operator|!=
name|getegid
argument_list|()
operator|)
condition|)
block|{
comment|/* Only root can change the gid */
name|syserr
argument_list|(
literal|"mailfile: insufficient privileges to change gid, RealGid=%d, RunAsUid=%d, gid=%d, egid=%d"
argument_list|,
operator|(
name|int
operator|)
name|RealGid
argument_list|,
operator|(
name|int
operator|)
name|RunAsUid
argument_list|,
operator|(
name|int
operator|)
name|getgid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getegid
argument_list|()
argument_list|)
expr_stmt|;
name|RETURN
argument_list|(
name|EX_TEMPFAIL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|S_ISGID
argument_list|,
name|mode
argument_list|)
condition|)
name|RealGid
operator|=
name|stb
operator|.
name|st_gid
expr_stmt|;
elseif|else
if|if
condition|(
name|ctladdr
operator|!=
name|NULL
operator|&&
name|ctladdr
operator|->
name|q_uid
operator|==
name|DefUid
operator|&&
name|ctladdr
operator|->
name|q_gid
operator|==
literal|0
condition|)
block|{
comment|/* 				**  Special case:  This means it is an 				**  alias and we should act as DefaultUser. 				**  See alias()'s comments. 				*/
name|RealGid
operator|=
name|DefGid
expr_stmt|;
name|RealUserName
operator|=
name|DefUser
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctladdr
operator|!=
name|NULL
operator|&&
name|ctladdr
operator|->
name|q_uid
operator|!=
literal|0
condition|)
name|RealGid
operator|=
name|ctladdr
operator|->
name|q_gid
expr_stmt|;
elseif|else
if|if
condition|(
name|mailer
operator|!=
name|NULL
operator|&&
name|mailer
operator|->
name|m_gid
operator|!=
name|NO_GID
condition|)
name|RealGid
operator|=
name|mailer
operator|->
name|m_gid
expr_stmt|;
else|else
name|RealGid
operator|=
name|DefGid
expr_stmt|;
block|}
comment|/* last ditch */
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|SFF_ROOTOK
argument_list|,
name|sfflags
argument_list|)
condition|)
block|{
if|if
condition|(
name|RealUid
operator|==
literal|0
condition|)
name|RealUid
operator|=
name|DefUid
expr_stmt|;
if|if
condition|(
name|RealGid
operator|==
literal|0
condition|)
name|RealGid
operator|=
name|DefGid
expr_stmt|;
block|}
comment|/* set group id list (needs /etc/group access) */
if|if
condition|(
name|RealUserName
operator|!=
name|NULL
operator|&&
operator|!
name|DontInitGroups
condition|)
block|{
if|if
condition|(
name|initgroups
argument_list|(
name|RealUserName
argument_list|,
name|RealGid
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|suidwarn
condition|)
block|{
name|syserr
argument_list|(
literal|"mailfile: initgroups(%s, %d) failed"
argument_list|,
name|RealUserName
argument_list|,
name|RealGid
argument_list|)
expr_stmt|;
name|RETURN
argument_list|(
name|EX_TEMPFAIL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|GIDSET_T
name|gidset
index|[
literal|1
index|]
decl_stmt|;
name|gidset
index|[
literal|0
index|]
operator|=
name|RealGid
expr_stmt|;
if|if
condition|(
name|setgroups
argument_list|(
literal|1
argument_list|,
name|gidset
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|suidwarn
condition|)
block|{
name|syserr
argument_list|(
literal|"mailfile: setgroups() failed"
argument_list|)
expr_stmt|;
name|RETURN
argument_list|(
name|EX_TEMPFAIL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		**  If you have a safe environment, go into it. 		*/
if|if
condition|(
name|realfile
operator|!=
name|targetfile
condition|)
block|{
name|char
name|save
decl_stmt|;
name|save
operator|=
operator|*
name|realfile
expr_stmt|;
operator|*
name|realfile
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|20
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"mailfile: chroot %s\n"
argument_list|,
name|targetfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|chroot
argument_list|(
name|targetfile
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"mailfile: Cannot chroot(%s)"
argument_list|,
name|targetfile
argument_list|)
expr_stmt|;
name|RETURN
argument_list|(
name|EX_CANTCREAT
argument_list|)
expr_stmt|;
block|}
operator|*
name|realfile
operator|=
name|save
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|40
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"mailfile: deliver to %s\n"
argument_list|,
name|realfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
literal|"/"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"mailfile: cannot chdir(/)"
argument_list|)
expr_stmt|;
name|RETURN
argument_list|(
name|EX_CANTCREAT
argument_list|)
expr_stmt|;
block|}
comment|/* now reset the group and user ids */
name|endpwent
argument_list|()
expr_stmt|;
name|sm_mbdb_terminate
argument_list|()
expr_stmt|;
if|if
condition|(
name|setgid
argument_list|(
name|RealGid
argument_list|)
operator|<
literal|0
operator|&&
name|suidwarn
condition|)
block|{
name|syserr
argument_list|(
literal|"mailfile: setgid(%ld) failed"
argument_list|,
operator|(
name|long
operator|)
name|RealGid
argument_list|)
expr_stmt|;
name|RETURN
argument_list|(
name|EX_TEMPFAIL
argument_list|)
expr_stmt|;
block|}
name|vendor_set_uid
argument_list|(
name|RealUid
argument_list|)
expr_stmt|;
if|if
condition|(
name|setuid
argument_list|(
name|RealUid
argument_list|)
operator|<
literal|0
operator|&&
name|suidwarn
condition|)
block|{
name|syserr
argument_list|(
literal|"mailfile: setuid(%ld) failed"
argument_list|,
operator|(
name|long
operator|)
name|RealUid
argument_list|)
expr_stmt|;
name|RETURN
argument_list|(
name|EX_TEMPFAIL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|2
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"mailfile: running as r/euid=%d/%d, r/egid=%d/%d\n"
argument_list|,
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getgid
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|getegid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* move into some "safe" directory */
if|if
condition|(
name|mailer
operator|->
name|m_execdir
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|p
operator|=
name|mailer
operator|->
name|m_execdir
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|q
control|)
block|{
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|expand
argument_list|(
name|p
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
operator|*
name|q
operator|++
operator|=
literal|':'
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|20
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"mailfile: trydir %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|chdir
argument_list|(
name|buf
argument_list|)
operator|>=
literal|0
condition|)
break|break;
block|}
block|}
comment|/* 		**  Recheck the file after we have assumed the ID of the 		**  delivery user to make sure we can deliver to it as 		**  that user.  This is necessary if sendmail is running 		**  as root and the file is on an NFS mount which treats 		**  root as nobody. 		*/
if|#
directive|if
name|HASLSTAT
if|if
condition|(
name|bitnset
argument_list|(
name|DBS_FILEDELIVERYTOSYMLINK
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
name|err
operator|=
name|stat
argument_list|(
name|realfile
argument_list|,
operator|&
name|stb
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|lstat
argument_list|(
name|realfile
argument_list|,
operator|&
name|stb
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* HASLSTAT */
name|err
operator|=
name|stat
argument_list|(
name|realfile
argument_list|,
operator|&
name|stb
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HASLSTAT */
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
name|stb
operator|.
name|st_mode
operator|=
name|ST_MODE_NOFILE
expr_stmt|;
name|mode
operator|=
name|FileMode
expr_stmt|;
name|oflags
operator||=
name|O_CREAT
operator||
name|O_EXCL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
operator|!
name|bitnset
argument_list|(
name|DBS_FILEDELIVERYTOHARDLINK
argument_list|,
name|DontBlameSendmail
argument_list|)
operator|&&
name|stb
operator|.
name|st_nlink
operator|!=
literal|1
operator|)
operator|||
operator|(
name|realfile
operator|!=
name|targetfile
operator|&&
operator|!
name|S_ISREG
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
name|exit
argument_list|(
name|EX_CANTCREAT
argument_list|)
expr_stmt|;
else|else
name|mode
operator|=
name|stb
operator|.
name|st_mode
expr_stmt|;
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|DBS_FILEDELIVERYTOSYMLINK
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
name|sfflags
operator||=
name|SFF_NOSLINK
expr_stmt|;
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|DBS_FILEDELIVERYTOHARDLINK
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
name|sfflags
operator||=
name|SFF_NOHLINK
expr_stmt|;
name|sfflags
operator|&=
operator|~
name|SFF_OPENASROOT
expr_stmt|;
name|f
operator|=
name|safefopen
argument_list|(
name|realfile
argument_list|,
name|oflags
argument_list|,
name|mode
argument_list|,
name|sfflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|transienterror
argument_list|(
name|errno
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"454 4.3.0 cannot open %s: %s"
argument_list|,
name|shortenstring
argument_list|(
name|realfile
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
argument_list|(
name|EX_TEMPFAIL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usrerr
argument_list|(
literal|"554 5.3.0 cannot open %s: %s"
argument_list|,
name|shortenstring
argument_list|(
name|realfile
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
argument_list|(
name|EX_CANTCREAT
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|filechanged
argument_list|(
name|realfile
argument_list|,
name|sm_io_getinfo
argument_list|(
name|f
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|&
name|stb
argument_list|)
condition|)
block|{
name|syserr
argument_list|(
literal|"554 5.3.0 file changed after open"
argument_list|)
expr_stmt|;
name|RETURN
argument_list|(
name|EX_CANTCREAT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|sm_io_getinfo
argument_list|(
name|f
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"554 5.3.0 cannot fstat %s"
argument_list|,
name|sm_errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN
argument_list|(
name|EX_CANTCREAT
argument_list|)
expr_stmt|;
block|}
name|curoff
operator|=
name|stb
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
name|ev
operator|!=
name|NULL
condition|)
name|sm_clrevent
argument_list|(
name|ev
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mcibuf
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|mcibuf
argument_list|)
expr_stmt|;
name|mcibuf
operator|.
name|mci_mailer
operator|=
name|mailer
expr_stmt|;
name|mcibuf
operator|.
name|mci_out
operator|=
name|f
expr_stmt|;
if|if
condition|(
name|bitnset
argument_list|(
name|M_7BITS
argument_list|,
name|mailer
operator|->
name|m_flags
argument_list|)
condition|)
name|mcibuf
operator|.
name|mci_flags
operator||=
name|MCIF_7BIT
expr_stmt|;
comment|/* clear out per-message flags from connection structure */
name|mcibuf
operator|.
name|mci_flags
operator|&=
operator|~
operator|(
name|MCIF_CVT7TO8
operator||
name|MCIF_CVT8TO7
operator|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|EF_HAS8BIT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_DONT_MIME
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
name|bitnset
argument_list|(
name|M_7BITS
argument_list|,
name|mailer
operator|->
name|m_flags
argument_list|)
condition|)
name|mcibuf
operator|.
name|mci_flags
operator||=
name|MCIF_CVT8TO7
expr_stmt|;
if|#
directive|if
name|MIME7TO8
if|if
condition|(
name|bitnset
argument_list|(
name|M_MAKE8BIT
argument_list|,
name|mailer
operator|->
name|m_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|MCIF_7BIT
argument_list|,
name|mcibuf
operator|.
name|mci_flags
argument_list|)
operator|&&
operator|(
name|p
operator|=
name|hvalue
argument_list|(
literal|"Content-Transfer-Encoding"
argument_list|,
name|e
operator|->
name|e_header
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|sm_strcasecmp
argument_list|(
name|p
argument_list|,
literal|"quoted-printable"
argument_list|)
operator|==
literal|0
operator|||
name|sm_strcasecmp
argument_list|(
name|p
argument_list|,
literal|"base64"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|p
operator|=
name|hvalue
argument_list|(
literal|"Content-Type"
argument_list|,
name|e
operator|->
name|e_header
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* may want to convert 7 -> 8 */
comment|/* XXX should really parse it here -- and use a class XXX */
if|if
condition|(
name|sm_strncasecmp
argument_list|(
name|p
argument_list|,
literal|"text/plain"
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|p
index|[
literal|10
index|]
operator|==
literal|'\0'
operator|||
name|p
index|[
literal|10
index|]
operator|==
literal|' '
operator|||
name|p
index|[
literal|10
index|]
operator|==
literal|';'
operator|)
condition|)
name|mcibuf
operator|.
name|mci_flags
operator||=
name|MCIF_CVT7TO8
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MIME7TO8 */
if|if
condition|(
operator|!
name|putfromline
argument_list|(
operator|&
name|mcibuf
argument_list|,
name|e
argument_list|)
operator|||
operator|!
call|(
modifier|*
name|e
operator|->
name|e_puthdr
call|)
argument_list|(
operator|&
name|mcibuf
argument_list|,
name|e
operator|->
name|e_header
argument_list|,
name|e
argument_list|,
name|M87F_OUTER
argument_list|)
operator|||
operator|!
call|(
modifier|*
name|e
operator|->
name|e_putbody
call|)
argument_list|(
operator|&
name|mcibuf
argument_list|,
name|e
argument_list|,
name|NULL
argument_list|)
operator|||
operator|!
name|putline
argument_list|(
literal|"\n"
argument_list|,
operator|&
name|mcibuf
argument_list|)
operator|||
operator|(
name|sm_io_flush
argument_list|(
name|f
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|SuperSafe
operator|!=
name|SAFE_NO
operator|&&
name|fsync
argument_list|(
name|sm_io_getinfo
argument_list|(
name|f
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
operator|||
name|sm_io_error
argument_list|(
name|f
argument_list|)
operator|)
condition|)
block|{
name|setstat
argument_list|(
name|EX_IOERR
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|NOFTRUNCATE
operator|(
name|void
operator|)
name|ftruncate
argument_list|(
name|sm_io_getinfo
argument_list|(
name|f
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|curoff
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !NOFTRUNCATE */
block|}
comment|/* reset ISUID& ISGID bits for paranoid systems */
if|#
directive|if
name|HASFCHMOD
operator|(
name|void
operator|)
name|fchmod
argument_list|(
name|sm_io_getinfo
argument_list|(
name|f
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|(
name|MODE_T
operator|)
name|mode
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* HASFCHMOD */
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|filename
argument_list|,
operator|(
name|MODE_T
operator|)
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HASFCHMOD */
if|if
condition|(
name|sm_io_close
argument_list|(
name|f
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
operator|<
literal|0
condition|)
name|setstat
argument_list|(
name|EX_IOERR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_flush
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|RealUid
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ExitStat
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
else|else
block|{
comment|/* parent -- wait for exit status */
name|int
name|st
decl_stmt|;
name|st
operator|=
name|waitfor
argument_list|(
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
operator|-
literal|1
condition|)
block|{
name|syserr
argument_list|(
literal|"mailfile: %s: wait"
argument_list|,
name|mailer
operator|->
name|m_name
argument_list|)
expr_stmt|;
return|return
name|EX_SOFTWARE
return|;
block|}
if|if
condition|(
name|WIFEXITED
argument_list|(
name|st
argument_list|)
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|WEXITSTATUS
argument_list|(
name|st
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|syserr
argument_list|(
literal|"mailfile: %s: child died on signal %d"
argument_list|,
name|mailer
operator|->
name|m_name
argument_list|,
name|st
argument_list|)
expr_stmt|;
return|return
name|EX_UNAVAILABLE
return|;
block|}
comment|/* NOTREACHED */
block|}
return|return
name|EX_UNAVAILABLE
return|;
comment|/* avoid compiler warning on IRIX */
block|}
end_function

begin_function
specifier|static
name|void
name|mailfiletimeout
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
comment|/* 	**  NOTE: THIS CAN BE CALLED FROM A SIGNAL HANDLER.  DO NOT ADD 	**	ANYTHING TO THIS ROUTINE UNLESS YOU KNOW WHAT YOU ARE 	**	DOING. 	*/
name|errno
operator|=
name|ETIMEDOUT
expr_stmt|;
name|longjmp
argument_list|(
name|CtxMailfileTimeout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  HOSTSIGNATURE -- return the "signature" for a host. ** **	The signature describes how we are going to send this -- it **	can be just the hostname (for non-Internet hosts) or can be **	an ordered list of MX hosts. ** **	Parameters: **		m -- the mailer describing this host. **		host -- the host name. ** **	Returns: **		The signature for this host. ** **	Side Effects: **		Can tweak the symbol table. */
end_comment

begin_define
define|#
directive|define
name|MAXHOSTSIGNATURE
value|8192
end_define

begin_comment
comment|/* max len of hostsignature */
end_comment

begin_function
name|char
modifier|*
name|hostsignature
parameter_list|(
name|m
parameter_list|,
name|host
parameter_list|)
specifier|register
name|MAILER
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|host
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|STAB
modifier|*
name|s
decl_stmt|;
name|time_t
name|now
decl_stmt|;
if|#
directive|if
name|NAMED_BIND
name|char
name|sep
init|=
literal|':'
decl_stmt|;
name|char
name|prevsep
init|=
literal|':'
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|nmx
decl_stmt|;
name|int
name|hl
decl_stmt|;
name|char
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|endp
decl_stmt|;
name|int
name|oldoptions
init|=
name|_res
operator|.
name|options
decl_stmt|;
name|char
modifier|*
name|mxhosts
index|[
name|MAXMXHOSTS
operator|+
literal|1
index|]
decl_stmt|;
name|unsigned
name|short
name|mxprefs
index|[
name|MAXMXHOSTS
operator|+
literal|1
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* NAMED_BIND */
if|if
condition|(
name|tTd
argument_list|(
literal|17
argument_list|,
literal|3
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"hostsignature(%s)\n"
argument_list|,
name|host
argument_list|)
expr_stmt|;
comment|/* 	**  If local delivery (and not remote), just return a constant. 	*/
if|if
condition|(
name|bitnset
argument_list|(
name|M_LOCALMAILER
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|m
operator|->
name|m_mailer
argument_list|,
literal|"[IPC]"
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|m
operator|->
name|m_argv
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|m
operator|->
name|m_argv
index|[
literal|0
index|]
argument_list|,
literal|"TCP"
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
literal|"localhost"
return|;
comment|/* an empty host does not have MX records */
if|if
condition|(
operator|*
name|host
operator|==
literal|'\0'
condition|)
return|return
literal|"_empty_"
return|;
comment|/* 	**  Check to see if this uses IPC -- if not, it can't have MX records. 	*/
if|if
condition|(
name|strcmp
argument_list|(
name|m
operator|->
name|m_mailer
argument_list|,
literal|"[IPC]"
argument_list|)
operator|!=
literal|0
operator|||
name|CurEnv
operator|->
name|e_sendmode
operator|==
name|SM_DEFER
condition|)
block|{
comment|/* just an ordinary mailer or deferred mode */
return|return
name|host
return|;
block|}
if|#
directive|if
name|NETUNIX
elseif|else
if|if
condition|(
name|m
operator|->
name|m_argv
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|m
operator|->
name|m_argv
index|[
literal|0
index|]
argument_list|,
literal|"FILE"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* rendezvous in the file system, no MX records */
return|return
name|host
return|;
block|}
endif|#
directive|endif
comment|/* NETUNIX */
comment|/* 	**  Look it up in the symbol table. 	*/
name|now
operator|=
name|curtime
argument_list|()
expr_stmt|;
name|s
operator|=
name|stab
argument_list|(
name|host
argument_list|,
name|ST_HOSTSIG
argument_list|,
name|ST_ENTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s_hostsig
operator|.
name|hs_sig
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|s_hostsig
operator|.
name|hs_exp
operator|>=
name|now
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|17
argument_list|,
literal|3
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"hostsignature(): stab(%s) found %s\n"
argument_list|,
name|host
argument_list|,
name|s
operator|->
name|s_hostsig
operator|.
name|hs_sig
argument_list|)
expr_stmt|;
return|return
name|s
operator|->
name|s_hostsig
operator|.
name|hs_sig
return|;
block|}
comment|/* signature is expired: clear it */
name|sm_free
argument_list|(
name|s
operator|->
name|s_hostsig
operator|.
name|hs_sig
argument_list|)
expr_stmt|;
name|s
operator|->
name|s_hostsig
operator|.
name|hs_sig
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* set default TTL */
name|s
operator|->
name|s_hostsig
operator|.
name|hs_exp
operator|=
name|now
operator|+
name|SM_DEFAULT_TTL
expr_stmt|;
comment|/* 	**  Not already there or expired -- create a signature. 	*/
if|#
directive|if
name|NAMED_BIND
if|if
condition|(
name|ConfigLevel
operator|<
literal|2
condition|)
name|_res
operator|.
name|options
operator|&=
operator|~
operator|(
name|RES_DEFNAMES
operator||
name|RES_DNSRCH
operator|)
expr_stmt|;
comment|/* XXX */
for|for
control|(
name|hp
operator|=
name|host
init|;
name|hp
operator|!=
name|NULL
condition|;
name|hp
operator|=
name|endp
control|)
block|{
if|#
directive|if
name|NETINET6
if|if
condition|(
operator|*
name|hp
operator|==
literal|'['
condition|)
block|{
name|endp
operator|=
name|strchr
argument_list|(
name|hp
operator|+
literal|1
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|!=
name|NULL
condition|)
name|endp
operator|=
name|strpbrk
argument_list|(
name|endp
operator|+
literal|1
argument_list|,
literal|":,"
argument_list|)
expr_stmt|;
block|}
else|else
name|endp
operator|=
name|strpbrk
argument_list|(
name|hp
argument_list|,
literal|":,"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* NETINET6 */
name|endp
operator|=
name|strpbrk
argument_list|(
name|hp
argument_list|,
literal|":,"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NETINET6 */
if|if
condition|(
name|endp
operator|!=
name|NULL
condition|)
block|{
name|sep
operator|=
operator|*
name|endp
expr_stmt|;
operator|*
name|endp
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|bitnset
argument_list|(
name|M_NOMX
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
comment|/* skip MX lookups */
name|nmx
operator|=
literal|1
expr_stmt|;
name|mxhosts
index|[
literal|0
index|]
operator|=
name|hp
expr_stmt|;
block|}
else|else
block|{
specifier|auto
name|int
name|rcode
decl_stmt|;
name|int
name|ttl
decl_stmt|;
name|nmx
operator|=
name|getmxrr
argument_list|(
name|hp
argument_list|,
name|mxhosts
argument_list|,
name|mxprefs
argument_list|,
name|true
argument_list|,
operator|&
name|rcode
argument_list|,
name|true
argument_list|,
operator|&
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmx
operator|<=
literal|0
condition|)
block|{
name|int
name|save_errno
decl_stmt|;
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
comment|/* update the connection info for this host */
name|save_errno
operator|=
name|errno
expr_stmt|;
name|mci
operator|=
name|mci_get
argument_list|(
name|hp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_errno
operator|=
name|save_errno
expr_stmt|;
name|mci
operator|->
name|mci_herrno
operator|=
name|h_errno
expr_stmt|;
name|mci
operator|->
name|mci_lastuse
operator|=
name|now
expr_stmt|;
if|if
condition|(
name|rcode
operator|==
name|EX_NOHOST
condition|)
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|rcode
argument_list|,
literal|"5.1.2"
argument_list|,
literal|"550 Host unknown"
argument_list|)
expr_stmt|;
else|else
name|mci_setstat
argument_list|(
name|mci
argument_list|,
name|rcode
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* use the original host name as signature */
name|nmx
operator|=
literal|1
expr_stmt|;
name|mxhosts
index|[
literal|0
index|]
operator|=
name|hp
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|17
argument_list|,
literal|3
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"hostsignature(): getmxrr() returned %d, mxhosts[0]=%s\n"
argument_list|,
name|nmx
argument_list|,
name|mxhosts
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* 			**  Set new TTL: we use only one! 			**	We could try to use the minimum instead. 			*/
name|s
operator|->
name|s_hostsig
operator|.
name|hs_exp
operator|=
name|now
operator|+
name|SM_MIN
argument_list|(
name|ttl
argument_list|,
name|SM_DEFAULT_TTL
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmx
condition|;
name|i
operator|++
control|)
name|len
operator|+=
name|strlen
argument_list|(
name|mxhosts
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s_hostsig
operator|.
name|hs_sig
operator|!=
name|NULL
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|s
operator|->
name|s_hostsig
operator|.
name|hs_sig
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>=
name|MAXHOSTSIGNATURE
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"hostsignature for host '%s' exceeds maxlen (%d): %d"
argument_list|,
name|host
argument_list|,
name|MAXHOSTSIGNATURE
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
name|MAXHOSTSIGNATURE
expr_stmt|;
block|}
name|p
operator|=
name|sm_pmalloc_x
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s_hostsig
operator|.
name|hs_sig
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|p
argument_list|,
name|s
operator|->
name|s_hostsig
operator|.
name|hs_sig
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sm_free
argument_list|(
name|s
operator|->
name|s_hostsig
operator|.
name|hs_sig
argument_list|)
expr_stmt|;
comment|/* XXX */
name|s
operator|->
name|s_hostsig
operator|.
name|hs_sig
operator|=
name|p
expr_stmt|;
name|hl
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|hl
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|prevsep
expr_stmt|;
name|len
operator|-=
name|hl
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|s
operator|->
name|s_hostsig
operator|.
name|hs_sig
operator|=
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmx
condition|;
name|i
operator|++
control|)
block|{
name|hl
operator|=
name|strlen
argument_list|(
name|mxhosts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|-
literal|1
operator|<
name|hl
operator|||
name|len
operator|<=
literal|1
condition|)
block|{
comment|/* force to drop out of outer loop */
name|len
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|mxprefs
index|[
name|i
index|]
operator|==
name|mxprefs
index|[
name|i
operator|-
literal|1
index|]
condition|)
operator|*
name|p
operator|++
operator|=
literal|','
expr_stmt|;
else|else
operator|*
name|p
operator|++
operator|=
literal|':'
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|p
argument_list|,
name|mxhosts
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|hl
expr_stmt|;
name|len
operator|-=
name|hl
expr_stmt|;
block|}
comment|/* 		**  break out of loop if len exceeded MAXHOSTSIGNATURE 		**  because we won't have more space for further hosts 		**  anyway (separated by : in the .cf file). 		*/
if|if
condition|(
name|len
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|endp
operator|!=
name|NULL
condition|)
operator|*
name|endp
operator|++
operator|=
name|sep
expr_stmt|;
name|prevsep
operator|=
name|sep
expr_stmt|;
block|}
name|makelower
argument_list|(
name|s
operator|->
name|s_hostsig
operator|.
name|hs_sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|ConfigLevel
operator|<
literal|2
condition|)
name|_res
operator|.
name|options
operator|=
name|oldoptions
expr_stmt|;
else|#
directive|else
comment|/* NAMED_BIND */
comment|/* not using BIND -- the signature is just the host name */
comment|/* 	**  'host' points to storage that will be freed after we are 	**  done processing the current envelope, so we copy it. 	*/
name|s
operator|->
name|s_hostsig
operator|.
name|hs_sig
operator|=
name|sm_pstrdup_x
argument_list|(
name|host
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NAMED_BIND */
if|if
condition|(
name|tTd
argument_list|(
literal|17
argument_list|,
literal|1
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"hostsignature(%s) = %s\n"
argument_list|,
name|host
argument_list|,
name|s
operator|->
name|s_hostsig
operator|.
name|hs_sig
argument_list|)
expr_stmt|;
return|return
name|s
operator|->
name|s_hostsig
operator|.
name|hs_sig
return|;
block|}
end_function

begin_comment
comment|/* **  PARSE_HOSTSIGNATURE -- parse the "signature" and return MX host array. ** **	The signature describes how we are going to send this -- it **	can be just the hostname (for non-Internet hosts) or can be **	an ordered list of MX hosts which must be randomized for equal **	MX preference values. ** **	Parameters: **		sig -- the host signature. **		mxhosts -- array to populate. **		mailer -- mailer. ** **	Returns: **		The number of hosts inserted into mxhosts array. ** **	Side Effects: **		Randomizes equal MX preference hosts in mxhosts. */
end_comment

begin_function
specifier|static
name|int
name|parse_hostsignature
parameter_list|(
name|sig
parameter_list|,
name|mxhosts
parameter_list|,
name|mailer
parameter_list|)
name|char
modifier|*
name|sig
decl_stmt|;
name|char
modifier|*
modifier|*
name|mxhosts
decl_stmt|;
name|MAILER
modifier|*
name|mailer
decl_stmt|;
block|{
name|unsigned
name|short
name|curpref
init|=
literal|0
decl_stmt|;
name|int
name|nmx
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* NOTE: i, j, and nmx must have same type */
name|char
modifier|*
name|hp
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|unsigned
name|short
name|prefer
index|[
name|MAXMXHOSTS
index|]
decl_stmt|;
name|long
name|rndm
index|[
name|MAXMXHOSTS
index|]
decl_stmt|;
for|for
control|(
name|hp
operator|=
name|sig
init|;
name|hp
operator|!=
name|NULL
condition|;
name|hp
operator|=
name|endp
control|)
block|{
name|char
name|sep
init|=
literal|':'
decl_stmt|;
if|#
directive|if
name|NETINET6
if|if
condition|(
operator|*
name|hp
operator|==
literal|'['
condition|)
block|{
name|endp
operator|=
name|strchr
argument_list|(
name|hp
operator|+
literal|1
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|!=
name|NULL
condition|)
name|endp
operator|=
name|strpbrk
argument_list|(
name|endp
operator|+
literal|1
argument_list|,
literal|":,"
argument_list|)
expr_stmt|;
block|}
else|else
name|endp
operator|=
name|strpbrk
argument_list|(
name|hp
argument_list|,
literal|":,"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* NETINET6 */
name|endp
operator|=
name|strpbrk
argument_list|(
name|hp
argument_list|,
literal|":,"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NETINET6 */
if|if
condition|(
name|endp
operator|!=
name|NULL
condition|)
block|{
name|sep
operator|=
operator|*
name|endp
expr_stmt|;
operator|*
name|endp
operator|=
literal|'\0'
expr_stmt|;
block|}
name|mxhosts
index|[
name|nmx
index|]
operator|=
name|hp
expr_stmt|;
name|prefer
index|[
name|nmx
index|]
operator|=
name|curpref
expr_stmt|;
if|if
condition|(
name|mci_match
argument_list|(
name|hp
argument_list|,
name|mailer
argument_list|)
condition|)
name|rndm
index|[
name|nmx
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|rndm
index|[
name|nmx
index|]
operator|=
name|get_random
argument_list|()
expr_stmt|;
if|if
condition|(
name|endp
operator|!=
name|NULL
condition|)
block|{
comment|/* 			**  Since we don't have the original MX prefs, 			**  make our own.  If the separator is a ':', that 			**  means the preference for the next host will be 			**  higher than this one, so simply increment curpref. 			*/
if|if
condition|(
name|sep
operator|==
literal|':'
condition|)
name|curpref
operator|++
expr_stmt|;
operator|*
name|endp
operator|++
operator|=
name|sep
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|nmx
operator|>=
name|MAXMXHOSTS
condition|)
break|break;
block|}
comment|/* sort the records using the random factor for equal preferences */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmx
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|nmx
condition|;
name|j
operator|++
control|)
block|{
comment|/* 			**  List is already sorted by MX preference, only 			**  need to look for equal preference MX records 			*/
if|if
condition|(
name|prefer
index|[
name|i
index|]
operator|<
name|prefer
index|[
name|j
index|]
condition|)
break|break;
if|if
condition|(
name|prefer
index|[
name|i
index|]
operator|>
name|prefer
index|[
name|j
index|]
operator|||
operator|(
name|prefer
index|[
name|i
index|]
operator|==
name|prefer
index|[
name|j
index|]
operator|&&
name|rndm
index|[
name|i
index|]
operator|>
name|rndm
index|[
name|j
index|]
operator|)
condition|)
block|{
specifier|register
name|unsigned
name|short
name|tempp
decl_stmt|;
specifier|register
name|long
name|tempr
decl_stmt|;
specifier|register
name|char
modifier|*
name|temp1
decl_stmt|;
name|tempp
operator|=
name|prefer
index|[
name|i
index|]
expr_stmt|;
name|prefer
index|[
name|i
index|]
operator|=
name|prefer
index|[
name|j
index|]
expr_stmt|;
name|prefer
index|[
name|j
index|]
operator|=
name|tempp
expr_stmt|;
name|temp1
operator|=
name|mxhosts
index|[
name|i
index|]
expr_stmt|;
name|mxhosts
index|[
name|i
index|]
operator|=
name|mxhosts
index|[
name|j
index|]
expr_stmt|;
name|mxhosts
index|[
name|j
index|]
operator|=
name|temp1
expr_stmt|;
name|tempr
operator|=
name|rndm
index|[
name|i
index|]
expr_stmt|;
name|rndm
index|[
name|i
index|]
operator|=
name|rndm
index|[
name|j
index|]
expr_stmt|;
name|rndm
index|[
name|j
index|]
operator|=
name|tempr
expr_stmt|;
block|}
block|}
block|}
return|return
name|nmx
return|;
block|}
end_function

begin_if
if|#
directive|if
name|STARTTLS
end_if

begin_decl_stmt
specifier|static
name|SSL_CTX
modifier|*
name|clt_ctx
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|tls_ok_clt
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  SETCLTTLS -- client side TLS: allow/disallow. ** **	Parameters: **		tls_ok -- should tls be done? ** **	Returns: **		none. ** **	Side Effects: **		sets tls_ok_clt (static variable in this module) */
end_comment

begin_function
name|void
name|setclttls
parameter_list|(
name|tls_ok
parameter_list|)
name|bool
name|tls_ok
decl_stmt|;
block|{
name|tls_ok_clt
operator|=
name|tls_ok
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* **  INITCLTTLS -- initialize client side TLS ** **	Parameters: **		tls_ok -- should tls initialization be done? ** **	Returns: **		succeeded? ** **	Side Effects: **		sets tls_ok_clt (static variable in this module) */
end_comment

begin_function
name|bool
name|initclttls
parameter_list|(
name|tls_ok
parameter_list|)
name|bool
name|tls_ok
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|tls_ok_clt
condition|)
return|return
name|false
return|;
name|tls_ok_clt
operator|=
name|tls_ok
expr_stmt|;
if|if
condition|(
operator|!
name|tls_ok_clt
condition|)
return|return
name|false
return|;
if|if
condition|(
name|clt_ctx
operator|!=
name|NULL
condition|)
return|return
name|true
return|;
comment|/* already done */
name|tls_ok_clt
operator|=
name|inittls
argument_list|(
operator|&
name|clt_ctx
argument_list|,
name|TLS_I_CLT
argument_list|,
name|false
argument_list|,
name|CltCertFile
argument_list|,
name|CltKeyFile
argument_list|,
name|CACertPath
argument_list|,
name|CACertFile
argument_list|,
name|DHParams
argument_list|)
expr_stmt|;
return|return
name|tls_ok_clt
return|;
block|}
end_function

begin_comment
comment|/* **  STARTTLS -- try to start secure connection (client side) ** **	Parameters: **		m -- the mailer. **		mci -- the mailer connection info. **		e -- the envelope. ** **	Returns: **		success? **		(maybe this should be some other code than EX_ **		that denotes which stage failed.) */
end_comment

begin_function
specifier|static
name|int
name|starttls
parameter_list|(
name|m
parameter_list|,
name|mci
parameter_list|,
name|e
parameter_list|)
name|MAILER
modifier|*
name|m
decl_stmt|;
name|MCI
modifier|*
name|mci
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|int
name|smtpresult
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|int
name|rfd
decl_stmt|,
name|wfd
decl_stmt|;
name|SSL
modifier|*
name|clt_ssl
init|=
name|NULL
decl_stmt|;
name|time_t
name|tlsstart
decl_stmt|;
if|if
condition|(
name|clt_ctx
operator|==
name|NULL
operator|&&
operator|!
name|initclttls
argument_list|(
name|true
argument_list|)
condition|)
return|return
name|EX_TEMPFAIL
return|;
name|smtpmessage
argument_list|(
literal|"STARTTLS"
argument_list|,
name|m
argument_list|,
name|mci
argument_list|)
expr_stmt|;
comment|/* get the reply */
name|smtpresult
operator|=
name|reply
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|,
name|TimeOuts
operator|.
name|to_starttls
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|XS_STARTTLS
argument_list|)
expr_stmt|;
comment|/* check return code from server */
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|smtpresult
argument_list|)
operator|==
literal|4
condition|)
return|return
name|EX_TEMPFAIL
return|;
if|if
condition|(
name|smtpresult
operator|==
literal|501
condition|)
return|return
name|EX_USAGE
return|;
if|if
condition|(
name|smtpresult
operator|==
operator|-
literal|1
condition|)
return|return
name|smtpresult
return|;
comment|/* not an expected reply but we have to deal with it */
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|smtpresult
argument_list|)
operator|==
literal|5
condition|)
return|return
name|EX_UNAVAILABLE
return|;
if|if
condition|(
name|smtpresult
operator|!=
literal|220
condition|)
return|return
name|EX_PROTOCOL
return|;
if|if
condition|(
name|LogLevel
operator|>
literal|13
condition|)
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=client, start=ok"
argument_list|)
expr_stmt|;
comment|/* start connection */
if|if
condition|(
operator|(
name|clt_ssl
operator|=
name|SSL_new
argument_list|(
name|clt_ctx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=client, error: SSL_new failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|tlslogerr
argument_list|(
literal|"client"
argument_list|)
expr_stmt|;
block|}
return|return
name|EX_SOFTWARE
return|;
block|}
name|rfd
operator|=
name|sm_io_getinfo
argument_list|(
name|mci
operator|->
name|mci_in
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|wfd
operator|=
name|sm_io_getinfo
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
name|SM_IO_WHAT_FD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* SSL_clear(clt_ssl); ? */
if|if
condition|(
name|rfd
operator|<
literal|0
operator|||
name|wfd
operator|<
literal|0
operator|||
operator|(
name|result
operator|=
name|SSL_set_rfd
argument_list|(
name|clt_ssl
argument_list|,
name|rfd
argument_list|)
operator|)
operator|!=
literal|1
operator|||
operator|(
name|result
operator|=
name|SSL_set_wfd
argument_list|(
name|clt_ssl
argument_list|,
name|wfd
argument_list|)
operator|)
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=client, error: SSL_set_xfd failed=%d"
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|9
condition|)
name|tlslogerr
argument_list|(
literal|"client"
argument_list|)
expr_stmt|;
block|}
return|return
name|EX_SOFTWARE
return|;
block|}
name|SSL_set_connect_state
argument_list|(
name|clt_ssl
argument_list|)
expr_stmt|;
name|tlsstart
operator|=
name|curtime
argument_list|()
expr_stmt|;
name|ssl_retry
label|:
if|if
condition|(
operator|(
name|result
operator|=
name|SSL_connect
argument_list|(
name|clt_ssl
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|,
name|ssl_err
decl_stmt|;
name|ssl_err
operator|=
name|SSL_get_error
argument_list|(
name|clt_ssl
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|i
operator|=
name|tls_retry
argument_list|(
name|clt_ssl
argument_list|,
name|rfd
argument_list|,
name|wfd
argument_list|,
name|tlsstart
argument_list|,
name|TimeOuts
operator|.
name|to_starttls
argument_list|,
name|ssl_err
argument_list|,
literal|"client"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
goto|goto
name|ssl_retry
goto|;
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
block|{
name|sm_syslog
argument_list|(
name|LOG_WARNING
argument_list|,
name|NOQID
argument_list|,
literal|"STARTTLS=client, error: connect failed=%d, SSL_error=%d, errno=%d, retry=%d"
argument_list|,
name|result
argument_list|,
name|ssl_err
argument_list|,
name|errno
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|tlslogerr
argument_list|(
literal|"client"
argument_list|)
expr_stmt|;
block|}
name|SSL_free
argument_list|(
name|clt_ssl
argument_list|)
expr_stmt|;
name|clt_ssl
operator|=
name|NULL
expr_stmt|;
return|return
name|EX_SOFTWARE
return|;
block|}
name|mci
operator|->
name|mci_ssl
operator|=
name|clt_ssl
expr_stmt|;
name|result
operator|=
name|tls_get_info
argument_list|(
name|mci
operator|->
name|mci_ssl
argument_list|,
name|false
argument_list|,
name|mci
operator|->
name|mci_host
argument_list|,
operator|&
name|mci
operator|->
name|mci_macro
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* switch to use TLS... */
if|if
condition|(
name|sfdctls
argument_list|(
operator|&
name|mci
operator|->
name|mci_in
argument_list|,
operator|&
name|mci
operator|->
name|mci_out
argument_list|,
name|mci
operator|->
name|mci_ssl
argument_list|)
operator|==
literal|0
condition|)
return|return
name|EX_OK
return|;
comment|/* failure */
name|SSL_free
argument_list|(
name|clt_ssl
argument_list|)
expr_stmt|;
name|clt_ssl
operator|=
name|NULL
expr_stmt|;
return|return
name|EX_SOFTWARE
return|;
block|}
end_function

begin_comment
comment|/* **  ENDTLSCLT -- shutdown secure connection (client side) ** **	Parameters: **		mci -- the mailer connection info. ** **	Returns: **		success? */
end_comment

begin_function
specifier|static
name|int
name|endtlsclt
parameter_list|(
name|mci
parameter_list|)
name|MCI
modifier|*
name|mci
decl_stmt|;
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|MCIF_TLSACT
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
return|return
name|EX_OK
return|;
name|r
operator|=
name|endtls
argument_list|(
name|mci
operator|->
name|mci_ssl
argument_list|,
literal|"client"
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_flags
operator|&=
operator|~
name|MCIF_TLSACT
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STARTTLS */
end_comment

begin_if
if|#
directive|if
name|STARTTLS
operator|||
name|SASL
end_if

begin_comment
comment|/* **  ISCLTFLGSET -- check whether client flag is set. ** **	Parameters: **		e -- envelope. **		flag -- flag to check in {client_flags} ** **	Returns: **		true iff flag is set. */
end_comment

begin_function
specifier|static
name|bool
name|iscltflgset
parameter_list|(
name|e
parameter_list|,
name|flag
parameter_list|)
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|macvalue
argument_list|(
name|macid
argument_list|(
literal|"{client_flags}"
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|false
return|;
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
comment|/* look for just this one flag */
if|if
condition|(
operator|*
name|p
operator|==
operator|(
name|char
operator|)
name|flag
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STARTTLS || SASL */
end_comment

end_unit

