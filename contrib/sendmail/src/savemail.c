begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998-2003, 2006 Sendmail, Inc. and its suppliers.  *	All rights reserved.  * Copyright (c) 1983, 1995-1997 Eric P. Allman.  All rights reserved.  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * By using this file, you agree to the terms and conditions set  * forth in the LICENSE file which can be found at the top level of  * the sendmail distribution.  *  *	$FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|<sendmail.h>
end_include

begin_macro
name|SM_RCSID
argument_list|(
literal|"@(#)$Id: savemail.c,v 8.313 2006/11/29 00:20:41 ca Exp $"
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|bool
name|errbody
name|__P
argument_list|(
operator|(
name|MCI
operator|*
operator|,
name|ENVELOPE
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|pruneroute
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  SAVEMAIL -- Save mail on error ** **	If mailing back errors, mail it back to the originator **	together with an error message; otherwise, just put it in **	dead.letter in the user's home directory (if he exists on **	this machine). ** **	Parameters: **		e -- the envelope containing the message in error. **		sendbody -- if true, also send back the body of the **			message; otherwise just send the header. ** **	Returns: **		true if savemail panic'ed, (i.e., the data file should **		be preserved by dropenvelope()) ** **	Side Effects: **		Saves the letter, by writing or mailing it back to the **		sender, or by putting it in dead.letter in her home **		directory. */
end_comment

begin_comment
comment|/* defines for state machine */
end_comment

begin_define
define|#
directive|define
name|ESM_REPORT
value|0
end_define

begin_comment
comment|/* report to sender's terminal */
end_comment

begin_define
define|#
directive|define
name|ESM_MAIL
value|1
end_define

begin_comment
comment|/* mail back to sender */
end_comment

begin_define
define|#
directive|define
name|ESM_QUIET
value|2
end_define

begin_comment
comment|/* mail has already been returned */
end_comment

begin_define
define|#
directive|define
name|ESM_DEADLETTER
value|3
end_define

begin_comment
comment|/* save in ~/dead.letter */
end_comment

begin_define
define|#
directive|define
name|ESM_POSTMASTER
value|4
end_define

begin_comment
comment|/* return to postmaster */
end_comment

begin_define
define|#
directive|define
name|ESM_DEADLETTERDROP
value|5
end_define

begin_comment
comment|/* save in DeadLetterDrop */
end_comment

begin_define
define|#
directive|define
name|ESM_PANIC
value|6
end_define

begin_comment
comment|/* call loseqfile() */
end_comment

begin_define
define|#
directive|define
name|ESM_DONE
value|7
end_define

begin_comment
comment|/* message is successfully delivered */
end_comment

begin_function
name|bool
name|savemail
parameter_list|(
name|e
parameter_list|,
name|sendbody
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|bool
name|sendbody
decl_stmt|;
block|{
specifier|register
name|SM_FILE_T
modifier|*
name|fp
decl_stmt|;
name|bool
name|panic
init|=
name|false
decl_stmt|;
name|int
name|state
decl_stmt|;
specifier|auto
name|ADDRESS
modifier|*
name|q
init|=
name|NULL
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|MCI
name|mcibuf
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|long
name|sff
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|dlbuf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|SM_MBDB_T
name|user
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|6
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"\nsavemail, errormode = %c, id = %s, ExitStat = %d\n  e_from="
argument_list|,
name|e
operator|->
name|e_errormode
argument_list|,
name|e
operator|->
name|e_id
operator|==
name|NULL
condition|?
literal|"NONE"
else|:
name|e
operator|->
name|e_id
argument_list|,
name|ExitStat
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
operator|&
name|e
operator|->
name|e_from
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|e_id
operator|==
name|NULL
condition|)
block|{
comment|/* can't return a message with no id */
return|return
name|panic
return|;
block|}
comment|/* 	**  In the unhappy event we don't know who to return the mail 	**  to, make someone up. 	*/
if|if
condition|(
name|e
operator|->
name|e_from
operator|.
name|q_paddr
operator|==
name|NULL
condition|)
block|{
name|e
operator|->
name|e_sender
operator|=
literal|"Postmaster"
expr_stmt|;
if|if
condition|(
name|parseaddr
argument_list|(
name|e
operator|->
name|e_sender
argument_list|,
operator|&
name|e
operator|->
name|e_from
argument_list|,
name|RF_COPYPARSE
operator||
name|RF_SENDERADDR
argument_list|,
literal|'\0'
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
name|false
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"553 5.3.5 Cannot parse Postmaster!"
argument_list|)
expr_stmt|;
name|finis
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
block|}
block|}
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
comment|/* 	**  Basic state machine. 	** 	**	This machine runs through the following states: 	** 	**	ESM_QUIET	Errors have already been printed iff the 	**			sender is local. 	**	ESM_REPORT	Report directly to the sender's terminal. 	**	ESM_MAIL	Mail response to the sender. 	**	ESM_DEADLETTER	Save response in ~/dead.letter. 	**	ESM_POSTMASTER	Mail response to the postmaster. 	**	ESM_DEADLETTERDROP 	**			If DeadLetterDrop set, save it there. 	**	ESM_PANIC	Save response anywhere possible. 	*/
comment|/* determine starting state */
switch|switch
condition|(
name|e
operator|->
name|e_errormode
condition|)
block|{
case|case
name|EM_WRITE
case|:
name|state
operator|=
name|ESM_REPORT
expr_stmt|;
break|break;
case|case
name|EM_BERKNET
case|:
case|case
name|EM_MAIL
case|:
name|state
operator|=
name|ESM_MAIL
expr_stmt|;
break|break;
case|case
name|EM_PRINT
case|:
case|case
literal|'\0'
case|:
name|state
operator|=
name|ESM_QUIET
expr_stmt|;
break|break;
case|case
name|EM_QUIET
case|:
comment|/* no need to return anything at all */
return|return
name|panic
return|;
default|default:
name|syserr
argument_list|(
literal|"554 5.3.0 savemail: bogus errormode x%x"
argument_list|,
name|e
operator|->
name|e_errormode
argument_list|)
expr_stmt|;
name|state
operator|=
name|ESM_MAIL
expr_stmt|;
break|break;
block|}
comment|/* if this is already an error response, send to postmaster */
if|if
condition|(
name|bitset
argument_list|(
name|EF_RESPONSE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|e_parent
operator|!=
name|NULL
operator|&&
name|bitset
argument_list|(
name|EF_RESPONSE
argument_list|,
name|e
operator|->
name|e_parent
operator|->
name|e_flags
argument_list|)
condition|)
block|{
comment|/* got an error sending a response -- can it */
return|return
name|panic
return|;
block|}
name|state
operator|=
name|ESM_POSTMASTER
expr_stmt|;
block|}
while|while
condition|(
name|state
operator|!=
name|ESM_DONE
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|6
argument_list|,
literal|5
argument_list|)
condition|)
name|sm_dprintf
argument_list|(
literal|"  state %d\n"
argument_list|,
name|state
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|ESM_QUIET
case|:
if|if
condition|(
name|bitnset
argument_list|(
name|M_LOCALMAILER
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|->
name|m_flags
argument_list|)
condition|)
name|state
operator|=
name|ESM_DEADLETTER
expr_stmt|;
else|else
name|state
operator|=
name|ESM_MAIL
expr_stmt|;
break|break;
case|case
name|ESM_REPORT
case|:
comment|/* 			**  If the user is still logged in on the same terminal, 			**  then write the error messages back to hir (sic). 			*/
if|#
directive|if
name|USE_TTYPATH
name|p
operator|=
name|ttypath
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* USE_TTYPATH */
name|p
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* USE_TTYPATH */
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|sm_io_reopen
argument_list|(
name|SmFtStdio
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|p
argument_list|,
name|SM_IO_WRONLY
argument_list|,
name|NULL
argument_list|,
name|smioout
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|state
operator|=
name|ESM_MAIL
expr_stmt|;
break|break;
block|}
name|expand
argument_list|(
literal|"\201n"
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"\r\nMessage from %s...\r\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Errors occurred while sending mail.\r\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|bfrewind
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Transcript follows:\r\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|sm_io_fgets
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|!=
name|NULL
operator|&&
operator|!
name|sm_io_error
argument_list|(
name|smioout
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sm_io_fputs
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syserr
argument_list|(
literal|"Cannot open %s"
argument_list|,
name|queuename
argument_list|(
name|e
argument_list|,
name|XSCRPT_LETTER
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Transcript of session is unavailable.\r\n"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_io_fprintf
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
literal|"Original message will be saved in dead.letter.\r\n"
argument_list|)
expr_stmt|;
name|state
operator|=
name|ESM_DEADLETTER
expr_stmt|;
break|break;
case|case
name|ESM_MAIL
case|:
comment|/* 			**  If mailing back, do it. 			**	Throw away all further output.  Don't alias, 			**	since this could cause loops, e.g., if joe 			**	mails to joe@x, and for some reason the network 			**	for @x is down, then the response gets sent to 			**	joe@x, which gives a response, etc.  Also force 			**	the mail to be delivered even if a version of 			**	it has already been sent to the sender. 			** 			**  If this is a configuration or local software 			**	error, send to the local postmaster as well, 			**	since the originator can't do anything 			**	about it anyway.  Note that this is a full 			**	copy of the message (intentionally) so that 			**	the Postmaster can forward things along. 			*/
if|if
condition|(
name|ExitStat
operator|==
name|EX_CONFIG
operator|||
name|ExitStat
operator|==
name|EX_SOFTWARE
condition|)
block|{
operator|(
name|void
operator|)
name|sendtolist
argument_list|(
literal|"postmaster"
argument_list|,
name|NULLADDR
argument_list|,
operator|&
name|e
operator|->
name|e_errorqueue
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|emptyaddr
argument_list|(
operator|&
name|e
operator|->
name|e_from
argument_list|)
condition|)
block|{
name|char
name|from
index|[
name|TOBUFSIZE
index|]
decl_stmt|;
if|if
condition|(
name|sm_strlcpy
argument_list|(
name|from
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|,
sizeof|sizeof
argument_list|(
name|from
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
condition|)
block|{
name|state
operator|=
name|ESM_POSTMASTER
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|DontPruneRoutes
condition|)
operator|(
name|void
operator|)
name|pruneroute
argument_list|(
name|from
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sendtolist
argument_list|(
name|from
argument_list|,
name|NULLADDR
argument_list|,
operator|&
name|e
operator|->
name|e_errorqueue
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|/* 			**  Deliver a non-delivery report to the 			**  Postmaster-designate (not necessarily 			**  Postmaster).  This does not include the 			**  body of the message, for privacy reasons. 			**  You really shouldn't need this. 			*/
name|e
operator|->
name|e_flags
operator||=
name|EF_PM_NOTIFY
expr_stmt|;
comment|/* check to see if there are any good addresses */
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_errorqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|QS_IS_SENDABLE
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
comment|/* this is an error-error */
name|state
operator|=
name|ESM_POSTMASTER
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|returntosender
argument_list|(
name|e
operator|->
name|e_message
argument_list|,
name|e
operator|->
name|e_errorqueue
argument_list|,
name|sendbody
condition|?
name|RTSF_SEND_BODY
else|:
name|RTSF_NO_BODY
argument_list|,
name|e
argument_list|)
operator|==
literal|0
condition|)
block|{
name|state
operator|=
name|ESM_DONE
expr_stmt|;
break|break;
block|}
comment|/* didn't work -- return to postmaster */
name|state
operator|=
name|ESM_POSTMASTER
expr_stmt|;
break|break;
case|case
name|ESM_POSTMASTER
case|:
comment|/* 			**  Similar to previous case, but to system postmaster. 			*/
name|q
operator|=
name|NULL
expr_stmt|;
name|expand
argument_list|(
name|DoubleBounceAddr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* 			**  Just drop it on the floor if DoubleBounceAddr 			**  expands to an empty string. 			*/
if|if
condition|(
operator|*
name|buf
operator|==
literal|'\0'
condition|)
block|{
name|state
operator|=
name|ESM_DONE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sendtolist
argument_list|(
name|buf
argument_list|,
name|NULLADDR
argument_list|,
operator|&
name|q
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"553 5.3.0 cannot parse %s!"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_SOFTWARE
expr_stmt|;
name|state
operator|=
name|ESM_DEADLETTERDROP
expr_stmt|;
break|break;
block|}
name|flags
operator|=
name|RTSF_PM_BOUNCE
expr_stmt|;
if|if
condition|(
name|sendbody
condition|)
name|flags
operator||=
name|RTSF_SEND_BODY
expr_stmt|;
if|if
condition|(
name|returntosender
argument_list|(
name|e
operator|->
name|e_message
argument_list|,
name|q
argument_list|,
name|flags
argument_list|,
name|e
argument_list|)
operator|==
literal|0
condition|)
block|{
name|state
operator|=
name|ESM_DONE
expr_stmt|;
break|break;
block|}
comment|/* didn't work -- last resort */
name|state
operator|=
name|ESM_DEADLETTERDROP
expr_stmt|;
break|break;
case|case
name|ESM_DEADLETTER
case|:
comment|/* 			**  Save the message in dead.letter. 			**	If we weren't mailing back, and the user is 			**	local, we should save the message in 			**	~/dead.letter so that the poor person doesn't 			**	have to type it over again -- and we all know 			**	what poor typists UNIX users are. 			*/
name|p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bitnset
argument_list|(
name|M_HASPWENT
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_mailer
operator|->
name|m_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|e_from
operator|.
name|q_home
operator|!=
name|NULL
condition|)
name|p
operator|=
name|e
operator|->
name|e_from
operator|.
name|q_home
expr_stmt|;
elseif|else
if|if
condition|(
name|sm_mbdb_lookup
argument_list|(
name|e
operator|->
name|e_from
operator|.
name|q_user
argument_list|,
operator|&
name|user
argument_list|)
operator|==
name|EX_OK
operator|&&
operator|*
name|user
operator|.
name|mbdb_homedir
operator|!=
literal|'\0'
condition|)
name|p
operator|=
name|user
operator|.
name|mbdb_homedir
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|e
operator|->
name|e_dfp
operator|==
name|NULL
condition|)
block|{
comment|/* no local directory or no data file */
name|state
operator|=
name|ESM_MAIL
expr_stmt|;
break|break;
block|}
comment|/* we have a home directory; write dead.letter */
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_TEMP
argument_list|,
literal|'z'
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* get the sender for the UnixFromLine */
name|p
operator|=
name|macvalue
argument_list|(
literal|'g'
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'g'
argument_list|,
name|e
operator|->
name|e_sender
argument_list|)
expr_stmt|;
name|expand
argument_list|(
literal|"\201z/dead.letter"
argument_list|,
name|dlbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dlbuf
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|sff
operator|=
name|SFF_CREAT
operator||
name|SFF_REGONLY
operator||
name|SFF_RUNASREALUID
expr_stmt|;
if|if
condition|(
name|RealUid
operator|==
literal|0
condition|)
name|sff
operator||=
name|SFF_ROOTOK
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|dlbuf
expr_stmt|;
if|if
condition|(
name|writable
argument_list|(
name|dlbuf
argument_list|,
name|NULL
argument_list|,
name|sff
argument_list|)
operator|&&
name|mailfile
argument_list|(
name|dlbuf
argument_list|,
name|FileMailer
argument_list|,
name|NULL
argument_list|,
name|sff
argument_list|,
name|e
argument_list|)
operator|==
name|EX_OK
condition|)
block|{
name|int
name|oldverb
init|=
name|Verbose
decl_stmt|;
if|if
condition|(
name|OpMode
operator|!=
name|MD_DAEMON
operator|&&
name|OpMode
operator|!=
name|MD_SMTP
condition|)
name|Verbose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|Verbose
operator|>
literal|0
condition|)
name|message
argument_list|(
literal|"Saved message in %s"
argument_list|,
name|dlbuf
argument_list|)
expr_stmt|;
name|Verbose
operator|=
name|oldverb
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'g'
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|state
operator|=
name|ESM_DONE
expr_stmt|;
break|break;
block|}
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'g'
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|state
operator|=
name|ESM_MAIL
expr_stmt|;
break|break;
case|case
name|ESM_DEADLETTERDROP
case|:
comment|/* 			**  Log the mail in DeadLetterDrop file. 			*/
if|if
condition|(
name|e
operator|->
name|e_class
operator|<
literal|0
condition|)
block|{
name|state
operator|=
name|ESM_DONE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|SafeFileEnv
operator|!=
name|NULL
operator|&&
name|SafeFileEnv
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
operator|||
name|DeadLetterDrop
operator|==
name|NULL
operator|||
name|DeadLetterDrop
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|state
operator|=
name|ESM_PANIC
expr_stmt|;
break|break;
block|}
name|sff
operator|=
name|SFF_CREAT
operator||
name|SFF_REGONLY
operator||
name|SFF_ROOTOK
operator||
name|SFF_OPENASROOT
operator||
name|SFF_MUSTOWN
expr_stmt|;
if|if
condition|(
operator|!
name|writable
argument_list|(
name|DeadLetterDrop
argument_list|,
name|NULL
argument_list|,
name|sff
argument_list|)
operator|||
operator|(
name|fp
operator|=
name|safefopen
argument_list|(
name|DeadLetterDrop
argument_list|,
name|O_WRONLY
operator||
name|O_APPEND
argument_list|,
name|FileMode
argument_list|,
name|sff
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|state
operator|=
name|ESM_PANIC
expr_stmt|;
break|break;
block|}
name|memset
argument_list|(
operator|&
name|mcibuf
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|mcibuf
argument_list|)
argument_list|)
expr_stmt|;
name|mcibuf
operator|.
name|mci_out
operator|=
name|fp
expr_stmt|;
name|mcibuf
operator|.
name|mci_mailer
operator|=
name|FileMailer
expr_stmt|;
if|if
condition|(
name|bitnset
argument_list|(
name|M_7BITS
argument_list|,
name|FileMailer
operator|->
name|m_flags
argument_list|)
condition|)
name|mcibuf
operator|.
name|mci_flags
operator||=
name|MCIF_7BIT
expr_stmt|;
comment|/* get the sender for the UnixFromLine */
name|p
operator|=
name|macvalue
argument_list|(
literal|'g'
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'g'
argument_list|,
name|e
operator|->
name|e_sender
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putfromline
argument_list|(
operator|&
name|mcibuf
argument_list|,
name|e
argument_list|)
operator|||
operator|!
call|(
modifier|*
name|e
operator|->
name|e_puthdr
call|)
argument_list|(
operator|&
name|mcibuf
argument_list|,
name|e
operator|->
name|e_header
argument_list|,
name|e
argument_list|,
name|M87F_OUTER
argument_list|)
operator|||
operator|!
call|(
modifier|*
name|e
operator|->
name|e_putbody
call|)
argument_list|(
operator|&
name|mcibuf
argument_list|,
name|e
argument_list|,
name|NULL
argument_list|)
operator|||
operator|!
name|putline
argument_list|(
literal|"\n"
argument_list|,
operator|&
name|mcibuf
argument_list|)
operator|||
name|sm_io_flush
argument_list|(
name|fp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
operator|==
name|SM_IO_EOF
operator|||
name|sm_io_error
argument_list|(
name|fp
argument_list|)
operator|||
name|sm_io_close
argument_list|(
name|fp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
operator|<
literal|0
condition|)
name|state
operator|=
name|ESM_PANIC
expr_stmt|;
else|else
block|{
name|int
name|oldverb
init|=
name|Verbose
decl_stmt|;
if|if
condition|(
name|OpMode
operator|!=
name|MD_DAEMON
operator|&&
name|OpMode
operator|!=
name|MD_SMTP
condition|)
name|Verbose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|Verbose
operator|>
literal|0
condition|)
name|message
argument_list|(
literal|"Saved message in %s"
argument_list|,
name|DeadLetterDrop
argument_list|)
expr_stmt|;
name|Verbose
operator|=
name|oldverb
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|3
condition|)
name|sm_syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"Saved message in %s"
argument_list|,
name|DeadLetterDrop
argument_list|)
expr_stmt|;
name|state
operator|=
name|ESM_DONE
expr_stmt|;
block|}
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'g'
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
literal|"554 5.3.5 savemail: unknown state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|ESM_PANIC
case|:
comment|/* leave the locked queue& transcript files around */
name|loseqfile
argument_list|(
name|e
argument_list|,
literal|"savemail panic"
argument_list|)
expr_stmt|;
name|panic
operator|=
name|true
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|syserr
argument_list|(
literal|"554 savemail: cannot save rejected email anywhere"
argument_list|)
expr_stmt|;
name|state
operator|=
name|ESM_DONE
expr_stmt|;
break|break;
block|}
block|}
return|return
name|panic
return|;
block|}
end_function

begin_comment
comment|/* **  RETURNTOSENDER -- return a message to the sender with an error. ** **	Parameters: **		msg -- the explanatory message. **		returnq -- the queue of people to send the message to. **		flags -- flags tweaking the operation: **			RTSF_SENDBODY -- include body of message (otherwise **				just send the header). **			RTSF_PMBOUNCE -- this is a postmaster bounce. **		e -- the current envelope. ** **	Returns: **		zero -- if everything went ok. **		else -- some error. ** **	Side Effects: **		Returns the current message to the sender via mail. */
end_comment

begin_define
define|#
directive|define
name|MAXRETURNS
value|6
end_define

begin_comment
comment|/* max depth of returning messages */
end_comment

begin_define
define|#
directive|define
name|ERRORFUDGE
value|1024
end_define

begin_comment
comment|/* nominal size of error message text */
end_comment

begin_function
name|int
name|returntosender
parameter_list|(
name|msg
parameter_list|,
name|returnq
parameter_list|,
name|flags
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
name|ADDRESS
modifier|*
name|returnq
decl_stmt|;
name|int
name|flags
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|ENVELOPE
modifier|*
name|ee
decl_stmt|;
name|ENVELOPE
modifier|*
name|oldcur
init|=
name|CurEnv
decl_stmt|;
name|ENVELOPE
name|errenvelope
decl_stmt|;
specifier|static
name|int
name|returndepth
init|=
literal|0
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
name|MAXNAME
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|returnq
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
name|msg
operator|=
literal|"Unable to deliver mail"
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|6
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"\n*** Return To Sender: msg=\"%s\", depth=%d, e=%p, returnq="
argument_list|,
name|msg
argument_list|,
name|returndepth
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|returnq
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|6
argument_list|,
literal|20
argument_list|)
condition|)
block|{
name|sm_dprintf
argument_list|(
literal|"Sendq="
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|sm_debug_file
argument_list|()
argument_list|,
name|e
operator|->
name|e_sendqueue
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|++
name|returndepth
operator|>=
name|MAXRETURNS
condition|)
block|{
if|if
condition|(
name|returndepth
operator|!=
name|MAXRETURNS
condition|)
name|syserr
argument_list|(
literal|"554 5.3.0 returntosender: infinite recursion on %s"
argument_list|,
name|returnq
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
comment|/* don't "unrecurse" and fake a clean exit */
comment|/* returndepth--; */
return|return
literal|0
return|;
block|}
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'g'
argument_list|,
name|e
operator|->
name|e_sender
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|e
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'u'
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* initialize error envelope */
name|ee
operator|=
name|newenvelope
argument_list|(
operator|&
name|errenvelope
argument_list|,
name|e
argument_list|,
name|sm_rpool_new_x
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|ee
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'a'
argument_list|,
literal|"\201b"
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|ee
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'r'
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|ee
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'s'
argument_list|,
literal|"localhost"
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|ee
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'_'
argument_list|,
literal|"localhost"
argument_list|)
expr_stmt|;
name|clrsessenvelope
argument_list|(
name|ee
argument_list|)
expr_stmt|;
name|ee
operator|->
name|e_puthdr
operator|=
name|putheader
expr_stmt|;
name|ee
operator|->
name|e_putbody
operator|=
name|errbody
expr_stmt|;
name|ee
operator|->
name|e_flags
operator||=
name|EF_RESPONSE
operator||
name|EF_METOO
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|EF_OLDSTYLE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|ee
operator|->
name|e_flags
operator|&=
operator|~
name|EF_OLDSTYLE
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|EF_DONT_MIME
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|ee
operator|->
name|e_flags
operator||=
name|EF_DONT_MIME
expr_stmt|;
comment|/* 		**  If we can't convert to MIME and we don't pass 		**  8-bit, we can't send the body. 		*/
if|if
condition|(
name|bitset
argument_list|(
name|EF_HAS8BIT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|MM_PASS8BIT
argument_list|,
name|MimeMode
argument_list|)
condition|)
name|flags
operator|&=
operator|~
name|RTSF_SEND_BODY
expr_stmt|;
block|}
name|ee
operator|->
name|e_sendqueue
operator|=
name|returnq
expr_stmt|;
name|ee
operator|->
name|e_msgsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RTSF_SEND_BODY
argument_list|,
name|flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|PRIV_NOBODYRETN
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
name|ee
operator|->
name|e_msgsize
operator|=
name|ERRORFUDGE
operator|+
name|e
operator|->
name|e_msgsize
expr_stmt|;
else|else
name|ee
operator|->
name|e_flags
operator||=
name|EF_NO_BODY_RETN
expr_stmt|;
if|if
condition|(
operator|!
name|setnewqueue
argument_list|(
name|ee
argument_list|)
condition|)
block|{
name|syserr
argument_list|(
literal|"554 5.3.0 returntosender: cannot select queue for %s"
argument_list|,
name|returnq
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_UNAVAILABLE
expr_stmt|;
name|returndepth
operator|--
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|initsys
argument_list|(
name|ee
argument_list|)
expr_stmt|;
if|#
directive|if
name|NAMED_BIND
name|_res
operator|.
name|retry
operator|=
name|TimeOuts
operator|.
name|res_retry
index|[
name|RES_TO_FIRST
index|]
expr_stmt|;
name|_res
operator|.
name|retrans
operator|=
name|TimeOuts
operator|.
name|res_retrans
index|[
name|RES_TO_FIRST
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* NAMED_BIND */
for|for
control|(
name|q
operator|=
name|returnq
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|QS_IS_BADADDR
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
condition|)
continue|continue;
name|q
operator|->
name|q_flags
operator|&=
operator|~
operator|(
name|QHASNOTIFY
operator||
name|Q_PINGFLAGS
operator|)
expr_stmt|;
name|q
operator|->
name|q_flags
operator||=
name|QPINGONFAILURE
expr_stmt|;
if|if
condition|(
operator|!
name|QS_IS_DEAD
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
condition|)
name|ee
operator|->
name|e_nrcpts
operator|++
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|q_alias
operator|==
name|NULL
condition|)
name|addheader
argument_list|(
literal|"To"
argument_list|,
name|q
operator|->
name|q_paddr
argument_list|,
literal|0
argument_list|,
name|ee
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|EF_RESPONSE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|p
operator|=
literal|"return to sender"
expr_stmt|;
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|EF_WARNING
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|p
operator|=
literal|"sender notify"
expr_stmt|;
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|RTSF_PM_BOUNCE
argument_list|,
name|flags
argument_list|)
condition|)
name|p
operator|=
literal|"postmaster notify"
expr_stmt|;
else|else
name|p
operator|=
literal|"DSN"
expr_stmt|;
name|sm_syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"%s: %s: %s"
argument_list|,
name|ee
operator|->
name|e_id
argument_list|,
name|p
argument_list|,
name|shortenstring
argument_list|(
name|msg
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SendMIMEErrors
condition|)
block|{
name|addheader
argument_list|(
literal|"MIME-Version"
argument_list|,
literal|"1.0"
argument_list|,
literal|0
argument_list|,
name|ee
argument_list|,
name|true
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s.%ld/%.100s"
argument_list|,
name|ee
operator|->
name|e_id
argument_list|,
operator|(
name|long
operator|)
name|curtime
argument_list|()
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
name|ee
operator|->
name|e_msgboundary
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|ee
operator|->
name|e_rpool
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
if|#
directive|if
name|DSN
literal|"multipart/report; report-type=delivery-status;\n\tboundary=\"%s\""
argument_list|,
else|#
directive|else
comment|/* DSN */
literal|"multipart/mixed; boundary=\"%s\""
argument_list|,
endif|#
directive|endif
comment|/* DSN */
name|ee
operator|->
name|e_msgboundary
argument_list|)
expr_stmt|;
name|addheader
argument_list|(
literal|"Content-Type"
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|ee
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|p
operator|=
name|hvalue
argument_list|(
literal|"Content-Transfer-Encoding"
argument_list|,
name|e
operator|->
name|e_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|sm_strcasecmp
argument_list|(
name|p
argument_list|,
literal|"binary"
argument_list|)
operator|!=
literal|0
condition|)
name|p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|&&
name|bitset
argument_list|(
name|EF_HAS8BIT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|p
operator|=
literal|"8bit"
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|addheader
argument_list|(
literal|"Content-Transfer-Encoding"
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
name|ee
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|msg
argument_list|,
literal|"Warning:"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|addheader
argument_list|(
literal|"Subject"
argument_list|,
name|msg
argument_list|,
literal|0
argument_list|,
name|ee
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|p
operator|=
literal|"warning-timeout"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|msg
argument_list|,
literal|"Postmaster warning:"
argument_list|,
literal|19
argument_list|)
operator|==
literal|0
condition|)
block|{
name|addheader
argument_list|(
literal|"Subject"
argument_list|,
name|msg
argument_list|,
literal|0
argument_list|,
name|ee
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|p
operator|=
literal|"postmaster-warning"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"Return receipt"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|addheader
argument_list|(
literal|"Subject"
argument_list|,
name|msg
argument_list|,
literal|0
argument_list|,
name|ee
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|p
operator|=
literal|"return-receipt"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|RTSF_PM_BOUNCE
argument_list|,
name|flags
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Postmaster notify: see transcript for details"
argument_list|)
expr_stmt|;
name|addheader
argument_list|(
literal|"Subject"
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|ee
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|p
operator|=
literal|"postmaster-notification"
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Returned mail: see transcript for details"
argument_list|)
expr_stmt|;
name|addheader
argument_list|(
literal|"Subject"
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|ee
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|p
operator|=
literal|"failure"
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"auto-generated (%s)"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|addheader
argument_list|(
literal|"Auto-Submitted"
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|ee
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* fake up an address header for the from person */
name|expand
argument_list|(
literal|"\201n"
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|parseaddr
argument_list|(
name|buf
argument_list|,
operator|&
name|ee
operator|->
name|e_from
argument_list|,
name|RF_COPYALL
operator||
name|RF_SENDERADDR
argument_list|,
literal|'\0'
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
name|false
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"553 5.3.5 Can't parse myself!"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_SOFTWARE
expr_stmt|;
name|returndepth
operator|--
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ee
operator|->
name|e_from
operator|.
name|q_flags
operator|&=
operator|~
operator|(
name|QHASNOTIFY
operator||
name|Q_PINGFLAGS
operator|)
expr_stmt|;
name|ee
operator|->
name|e_from
operator|.
name|q_flags
operator||=
name|QPINGONFAILURE
expr_stmt|;
name|ee
operator|->
name|e_sender
operator|=
name|ee
operator|->
name|e_from
operator|.
name|q_paddr
expr_stmt|;
comment|/* push state into submessage */
name|CurEnv
operator|=
name|ee
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|ee
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'f'
argument_list|,
literal|"\201n"
argument_list|)
expr_stmt|;
name|macdefine
argument_list|(
operator|&
name|ee
operator|->
name|e_macro
argument_list|,
name|A_PERM
argument_list|,
literal|'x'
argument_list|,
literal|"Mail Delivery Subsystem"
argument_list|)
expr_stmt|;
name|eatheader
argument_list|(
name|ee
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* mark statistics */
name|markstats
argument_list|(
name|ee
argument_list|,
name|NULLADDR
argument_list|,
name|STATS_NORMAL
argument_list|)
expr_stmt|;
comment|/* actually deliver the error message */
name|sendall
argument_list|(
name|ee
argument_list|,
name|SM_DELIVER
argument_list|)
expr_stmt|;
comment|/* restore state */
name|dropenvelope
argument_list|(
name|ee
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|sm_rpool_free
argument_list|(
name|ee
operator|->
name|e_rpool
argument_list|)
expr_stmt|;
name|CurEnv
operator|=
name|oldcur
expr_stmt|;
name|returndepth
operator|--
expr_stmt|;
comment|/* check for delivery errors */
if|if
condition|(
name|ee
operator|->
name|e_parent
operator|==
name|NULL
operator|||
operator|!
name|bitset
argument_list|(
name|EF_RESPONSE
argument_list|,
name|ee
operator|->
name|e_parent
operator|->
name|e_flags
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|q
operator|=
name|ee
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|QS_IS_ATTEMPTED
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* **  ERRBODY -- output the body of an error message. ** **	Typically this is a copy of the transcript plus a copy of the **	original offending message. ** **	Parameters: **		mci -- the mailer connection information. **		e -- the envelope we are working in. **		separator -- any possible MIME separator (unused). ** **	Returns: **		true iff body was written successfully ** **	Side Effects: **		Outputs the body of an error message. */
end_comment

begin_comment
comment|/* ARGSUSED2 */
end_comment

begin_function
specifier|static
name|bool
name|errbody
parameter_list|(
name|mci
parameter_list|,
name|e
parameter_list|,
name|separator
parameter_list|)
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|separator
decl_stmt|;
block|{
name|bool
name|printheader
decl_stmt|;
name|bool
name|sendbody
decl_stmt|;
name|bool
name|pm_notify
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
specifier|register
name|SM_FILE_T
modifier|*
name|xfile
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|q
init|=
name|NULL
decl_stmt|;
name|char
name|actual
index|[
name|MAXLINE
index|]
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_INHEADER
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|putline
argument_list|(
literal|""
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
name|mci
operator|->
name|mci_flags
operator|&=
operator|~
name|MCIF_INHEADER
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|e_parent
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"errbody: null parent"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
literal|"   ----- Original message lost -----\n"
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
return|return
name|true
return|;
block|}
comment|/* 	**  Output MIME header. 	*/
if|if
condition|(
name|e
operator|->
name|e_msgboundary
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|"--"
argument_list|,
name|e
operator|->
name|e_msgboundary
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
literal|"This is a MIME-encapsulated message"
argument_list|,
name|mci
argument_list|)
operator|||
operator|!
name|putline
argument_list|(
literal|""
argument_list|,
name|mci
argument_list|)
operator|||
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
operator|||
operator|!
name|putline
argument_list|(
literal|""
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
comment|/* 	**  Output introductory information. 	*/
name|pm_notify
operator|=
name|false
expr_stmt|;
name|p
operator|=
name|hvalue
argument_list|(
literal|"subject"
argument_list|,
name|e
operator|->
name|e_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"Postmaster "
argument_list|,
literal|11
argument_list|)
operator|==
literal|0
condition|)
name|pm_notify
operator|=
name|true
expr_stmt|;
else|else
block|{
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_parent
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|QS_IS_BADADDR
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|pm_notify
operator|&&
name|q
operator|==
name|NULL
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_FATALERRS
operator||
name|EF_SENDRECEIPT
argument_list|,
name|e
operator|->
name|e_parent
operator|->
name|e_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|putline
argument_list|(
literal|"    **********************************************"
argument_list|,
name|mci
argument_list|)
operator|||
operator|!
name|putline
argument_list|(
literal|"    **      THIS IS A WARNING MESSAGE ONLY      **"
argument_list|,
name|mci
argument_list|)
operator|||
operator|!
name|putline
argument_list|(
literal|"    **  YOU DO NOT NEED TO RESEND YOUR MESSAGE  **"
argument_list|,
name|mci
argument_list|)
operator|||
operator|!
name|putline
argument_list|(
literal|"    **********************************************"
argument_list|,
name|mci
argument_list|)
operator|||
operator|!
name|putline
argument_list|(
literal|""
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"The original message was received at %s"
argument_list|,
name|arpadate
argument_list|(
name|ctime
argument_list|(
operator|&
name|e
operator|->
name|e_parent
operator|->
name|e_ctime
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
name|expand
argument_list|(
literal|"from \201_"
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|e
operator|->
name|e_parent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
comment|/* include id in postmaster copies */
if|if
condition|(
name|pm_notify
operator|&&
name|e
operator|->
name|e_parent
operator|->
name|e_id
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|"with id "
argument_list|,
name|e
operator|->
name|e_parent
operator|->
name|e_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
if|if
condition|(
operator|!
name|putline
argument_list|(
literal|""
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
comment|/* 	**  Output error message header (if specified and available). 	*/
if|if
condition|(
name|ErrMsgFile
operator|!=
name|NULL
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_SENDRECEIPT
argument_list|,
name|e
operator|->
name|e_parent
operator|->
name|e_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|ErrMsgFile
operator|==
literal|'/'
condition|)
block|{
name|long
name|sff
init|=
name|SFF_ROOTOK
operator||
name|SFF_REGONLY
decl_stmt|;
if|if
condition|(
name|DontLockReadFiles
condition|)
name|sff
operator||=
name|SFF_NOLOCK
expr_stmt|;
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|DBS_ERRORHEADERINUNSAFEDIRPATH
argument_list|,
name|DontBlameSendmail
argument_list|)
condition|)
name|sff
operator||=
name|SFF_SAFEDIRPATH
expr_stmt|;
name|xfile
operator|=
name|safefopen
argument_list|(
name|ErrMsgFile
argument_list|,
name|O_RDONLY
argument_list|,
literal|0444
argument_list|,
name|sff
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfile
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|sm_io_fgets
argument_list|(
name|xfile
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|lbs
decl_stmt|;
name|bool
name|putok
decl_stmt|;
name|char
modifier|*
name|lbp
decl_stmt|;
name|lbs
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|lbp
operator|=
name|translate_dollars
argument_list|(
name|buf
argument_list|,
name|buf
argument_list|,
operator|&
name|lbs
argument_list|)
expr_stmt|;
name|expand
argument_list|(
name|lbp
argument_list|,
name|lbp
argument_list|,
name|lbs
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|putok
operator|=
name|putline
argument_list|(
name|lbp
argument_list|,
name|mci
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbp
operator|!=
name|buf
condition|)
name|sm_free
argument_list|(
name|lbp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putok
condition|)
goto|goto
name|writeerr
goto|;
block|}
operator|(
name|void
operator|)
name|sm_io_close
argument_list|(
name|xfile
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
literal|"\n"
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
block|}
else|else
block|{
name|expand
argument_list|(
name|ErrMsgFile
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
operator|||
operator|!
name|putline
argument_list|(
literal|""
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
block|}
comment|/* 	**  Output message introduction 	*/
comment|/* permanent fatal errors */
name|printheader
operator|=
name|true
expr_stmt|;
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_parent
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
operator|!
name|QS_IS_BADADDR
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
operator|||
operator|!
name|bitset
argument_list|(
name|QPINGONFAILURE
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|printheader
condition|)
block|{
if|if
condition|(
operator|!
name|putline
argument_list|(
literal|"   ----- The following addresses had permanent fatal errors -----"
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
name|printheader
operator|=
name|false
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|buf
argument_list|,
name|shortenstring
argument_list|(
name|q
operator|->
name|q_paddr
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
if|if
condition|(
name|q
operator|->
name|q_rstatus
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"    (reason: %s)"
argument_list|,
name|shortenstring
argument_list|(
name|exitstat
argument_list|(
name|q
operator|->
name|q_rstatus
argument_list|)
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
if|if
condition|(
name|q
operator|->
name|q_alias
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"    (expanded from: %s)"
argument_list|,
name|shortenstring
argument_list|(
name|q
operator|->
name|q_alias
operator|->
name|q_paddr
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|printheader
operator|&&
operator|!
name|putline
argument_list|(
literal|""
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
comment|/* transient non-fatal errors */
name|printheader
operator|=
name|true
expr_stmt|;
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_parent
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|QS_IS_BADADDR
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
operator|||
operator|!
name|bitset
argument_list|(
name|QPRIMARY
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
operator|||
operator|!
name|bitset
argument_list|(
name|QBYNDELAY
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
operator|||
operator|!
name|bitset
argument_list|(
name|QDELAYED
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|printheader
condition|)
block|{
if|if
condition|(
operator|!
name|putline
argument_list|(
literal|"   ----- The following addresses had transient non-fatal errors -----"
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
name|printheader
operator|=
name|false
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|buf
argument_list|,
name|shortenstring
argument_list|(
name|q
operator|->
name|q_paddr
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
if|if
condition|(
name|q
operator|->
name|q_alias
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"    (expanded from: %s)"
argument_list|,
name|shortenstring
argument_list|(
name|q
operator|->
name|q_alias
operator|->
name|q_paddr
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|printheader
operator|&&
operator|!
name|putline
argument_list|(
literal|""
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
comment|/* successful delivery notifications */
name|printheader
operator|=
name|true
expr_stmt|;
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_parent
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|QS_IS_BADADDR
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
operator|||
operator|!
name|bitset
argument_list|(
name|QPRIMARY
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
operator|||
name|bitset
argument_list|(
name|QBYNDELAY
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
operator|||
name|bitset
argument_list|(
name|QDELAYED
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|QBYNRELAY
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
name|p
operator|=
literal|"Deliver-By notify: relayed"
expr_stmt|;
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|QBYTRACE
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
name|p
operator|=
literal|"Deliver-By trace: relayed"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QPINGONSUCCESS
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|QRELAYED
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
name|p
operator|=
literal|"relayed to non-DSN-aware mailer"
expr_stmt|;
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|QDELIVERED
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|QEXPANDED
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
name|p
operator|=
literal|"successfully delivered to mailing list"
expr_stmt|;
else|else
name|p
operator|=
literal|"successfully delivered to mailbox"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|QEXPANDED
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
name|p
operator|=
literal|"expanded by alias"
expr_stmt|;
else|else
continue|continue;
if|if
condition|(
name|printheader
condition|)
block|{
if|if
condition|(
operator|!
name|putline
argument_list|(
literal|"   ----- The following addresses had successful delivery notifications -----"
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
name|printheader
operator|=
name|false
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s  (%s)"
argument_list|,
name|shortenstring
argument_list|(
name|q
operator|->
name|q_paddr
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
if|if
condition|(
name|q
operator|->
name|q_alias
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"    (expanded from: %s)"
argument_list|,
name|shortenstring
argument_list|(
name|q
operator|->
name|q_alias
operator|->
name|q_paddr
argument_list|,
name|MAXSHORTSTR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|printheader
operator|&&
operator|!
name|putline
argument_list|(
literal|""
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
comment|/* 	**  Output transcript of errors 	*/
operator|(
name|void
operator|)
name|sm_io_flush
argument_list|(
name|smioout
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_parent
operator|->
name|e_xfp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|putline
argument_list|(
literal|"   ----- Transcript of session is unavailable -----\n"
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
else|else
block|{
name|printheader
operator|=
name|true
expr_stmt|;
operator|(
name|void
operator|)
name|bfrewind
argument_list|(
name|e
operator|->
name|e_parent
operator|->
name|e_xfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sm_io_flush
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
expr_stmt|;
while|while
condition|(
name|sm_io_fgets
argument_list|(
name|e
operator|->
name|e_parent
operator|->
name|e_xfp
argument_list|,
name|SM_TIME_DEFAULT
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|printheader
operator|&&
operator|!
name|putline
argument_list|(
literal|"   ----- Transcript of session follows -----\n"
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
name|printheader
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
block|}
name|errno
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|DSN
comment|/* 	**  Output machine-readable version. 	*/
if|if
condition|(
name|e
operator|->
name|e_msgboundary
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|"--"
argument_list|,
name|e
operator|->
name|e_msgboundary
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
literal|""
argument_list|,
name|mci
argument_list|)
operator|||
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
operator|||
operator|!
name|putline
argument_list|(
literal|"Content-Type: message/delivery-status"
argument_list|,
name|mci
argument_list|)
operator|||
operator|!
name|putline
argument_list|(
literal|""
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
comment|/* 		**  Output per-message information. 		*/
comment|/* original envelope id from MAIL FROM: line */
if|if
condition|(
name|e
operator|->
name|e_parent
operator|->
name|e_envid
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Original-Envelope-Id: %.800s"
argument_list|,
name|xuntextify
argument_list|(
name|e
operator|->
name|e_parent
operator|->
name|e_envid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
comment|/* Reporting-MTA: is us (required) */
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Reporting-MTA: dns; %.800s"
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
comment|/* DSN-Gateway: not relevant since we are not translating */
comment|/* Received-From-MTA: shows where we got this message from */
if|if
condition|(
name|RealHostName
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX use $s for type? */
if|if
condition|(
name|e
operator|->
name|e_parent
operator|->
name|e_from
operator|.
name|q_mailer
operator|==
name|NULL
operator|||
operator|(
name|p
operator|=
name|e
operator|->
name|e_parent
operator|->
name|e_from
operator|.
name|q_mailer
operator|->
name|m_mtatype
operator|)
operator|==
name|NULL
condition|)
name|p
operator|=
literal|"dns"
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Received-From-MTA: %s; %.800s"
argument_list|,
name|p
argument_list|,
name|RealHostName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
comment|/* Arrival-Date: -- when it arrived here */
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|"Arrival-Date: "
argument_list|,
name|arpadate
argument_list|(
name|ctime
argument_list|(
operator|&
name|e
operator|->
name|e_parent
operator|->
name|e_ctime
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
comment|/* Deliver-By-Date: -- when it should have been delivered */
if|if
condition|(
name|IS_DLVR_BY
argument_list|(
name|e
operator|->
name|e_parent
argument_list|)
condition|)
block|{
name|time_t
name|dbyd
decl_stmt|;
name|dbyd
operator|=
name|e
operator|->
name|e_parent
operator|->
name|e_ctime
operator|+
name|e
operator|->
name|e_parent
operator|->
name|e_deliver_by
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|"Deliver-By-Date: "
argument_list|,
name|arpadate
argument_list|(
name|ctime
argument_list|(
operator|&
name|dbyd
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
comment|/* 		**  Output per-address information. 		*/
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_parent
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
name|char
modifier|*
name|action
decl_stmt|;
if|if
condition|(
name|QS_IS_BADADDR
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
condition|)
block|{
comment|/* RFC 1891, 6.2.6 (b) */
if|if
condition|(
name|bitset
argument_list|(
name|QHASNOTIFY
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|QPINGONFAILURE
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
continue|continue;
name|action
operator|=
literal|"failed"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QPRIMARY
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|QDELIVERED
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|QEXPANDED
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
name|action
operator|=
literal|"delivered (to mailing list)"
expr_stmt|;
else|else
name|action
operator|=
literal|"delivered (to mailbox)"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|QRELAYED
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
name|action
operator|=
literal|"relayed (to non-DSN-aware mailer)"
expr_stmt|;
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|QEXPANDED
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
name|action
operator|=
literal|"expanded (to multi-recipient alias)"
expr_stmt|;
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|QDELAYED
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
name|action
operator|=
literal|"delayed"
expr_stmt|;
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|QBYTRACE
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
name|action
operator|=
literal|"relayed (Deliver-By trace mode)"
expr_stmt|;
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|QBYNDELAY
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
name|action
operator|=
literal|"delayed (Deliver-By notify mode)"
expr_stmt|;
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|QBYNRELAY
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
name|action
operator|=
literal|"relayed (Deliver-By notify mode)"
expr_stmt|;
else|else
continue|continue;
if|if
condition|(
operator|!
name|putline
argument_list|(
literal|""
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
comment|/* Original-Recipient: -- passed from on high */
if|if
condition|(
name|q
operator|->
name|q_orcpt
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Original-Recipient: %.800s"
argument_list|,
name|q
operator|->
name|q_orcpt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
comment|/* Figure out actual recipient */
name|actual
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|q_user
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|q_mailer
operator|!=
name|NULL
operator|&&
name|q
operator|->
name|q_mailer
operator|->
name|m_addrtype
operator|!=
name|NULL
condition|)
name|p
operator|=
name|q
operator|->
name|q_mailer
operator|->
name|m_addrtype
expr_stmt|;
else|else
name|p
operator|=
literal|"rfc822"
expr_stmt|;
if|if
condition|(
name|sm_strcasecmp
argument_list|(
name|p
argument_list|,
literal|"rfc822"
argument_list|)
operator|==
literal|0
operator|&&
name|strchr
argument_list|(
name|q
operator|->
name|q_user
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|actual
argument_list|,
sizeof|sizeof
argument_list|(
name|actual
argument_list|)
argument_list|,
literal|"%s; %.700s@%.100s"
argument_list|,
name|p
argument_list|,
name|q
operator|->
name|q_user
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|actual
argument_list|,
sizeof|sizeof
argument_list|(
name|actual
argument_list|)
argument_list|,
literal|"%s; %.800s"
argument_list|,
name|p
argument_list|,
name|q
operator|->
name|q_user
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Final-Recipient: -- the name from the RCPT command */
if|if
condition|(
name|q
operator|->
name|q_finalrcpt
operator|==
name|NULL
condition|)
block|{
comment|/* should never happen */
name|sm_syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
literal|"returntosender: q_finalrcpt is NULL"
argument_list|)
expr_stmt|;
comment|/* try to fall back to the actual recipient */
if|if
condition|(
name|actual
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|q
operator|->
name|q_finalrcpt
operator|=
name|sm_rpool_strdup_x
argument_list|(
name|e
operator|->
name|e_rpool
argument_list|,
name|actual
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|->
name|q_finalrcpt
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Final-Recipient: %s"
argument_list|,
name|q
operator|->
name|q_finalrcpt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
comment|/* X-Actual-Recipient: -- the real problem address */
if|if
condition|(
name|actual
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|q
operator|->
name|q_finalrcpt
operator|!=
name|NULL
operator|&&
operator|!
name|bitset
argument_list|(
name|PRIV_NOACTUALRECIPIENT
argument_list|,
name|PrivacyFlags
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|actual
argument_list|,
name|q
operator|->
name|q_finalrcpt
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"X-Actual-Recipient: %s"
argument_list|,
name|actual
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
comment|/* Action: -- what happened? */
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|"Action: "
argument_list|,
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
comment|/* Status: -- what _really_ happened? */
if|if
condition|(
name|q
operator|->
name|q_status
operator|!=
name|NULL
condition|)
name|p
operator|=
name|q
operator|->
name|q_status
expr_stmt|;
elseif|else
if|if
condition|(
name|QS_IS_BADADDR
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
condition|)
name|p
operator|=
literal|"5.0.0"
expr_stmt|;
elseif|else
if|if
condition|(
name|QS_IS_QUEUEUP
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
condition|)
name|p
operator|=
literal|"4.0.0"
expr_stmt|;
else|else
name|p
operator|=
literal|"2.0.0"
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|"Status: "
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
comment|/* Remote-MTA: -- who was I talking to? */
if|if
condition|(
name|q
operator|->
name|q_statmta
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|q_mailer
operator|==
name|NULL
operator|||
operator|(
name|p
operator|=
name|q
operator|->
name|q_mailer
operator|->
name|m_mtatype
operator|)
operator|==
name|NULL
condition|)
name|p
operator|=
literal|"dns"
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Remote-MTA: %s; %.800s"
argument_list|,
name|p
argument_list|,
name|q
operator|->
name|q_statmta
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
comment|/* Diagnostic-Code: -- actual result from other end */
if|if
condition|(
name|q
operator|->
name|q_rstatus
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|q_mailer
operator|==
name|NULL
operator|||
operator|(
name|p
operator|=
name|q
operator|->
name|q_mailer
operator|->
name|m_diagtype
operator|)
operator|==
name|NULL
condition|)
name|p
operator|=
literal|"smtp"
expr_stmt|;
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Diagnostic-Code: %s; %.800s"
argument_list|,
name|p
argument_list|,
name|q
operator|->
name|q_rstatus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
comment|/* Last-Attempt-Date: -- fine granularity */
if|if
condition|(
name|q
operator|->
name|q_statdate
operator|==
operator|(
name|time_t
operator|)
literal|0L
condition|)
name|q
operator|->
name|q_statdate
operator|=
name|curtime
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|"Last-Attempt-Date: "
argument_list|,
name|arpadate
argument_list|(
name|ctime
argument_list|(
operator|&
name|q
operator|->
name|q_statdate
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
comment|/* Will-Retry-Until: -- for delayed messages only */
if|if
condition|(
name|QS_IS_QUEUEUP
argument_list|(
name|q
operator|->
name|q_state
argument_list|)
condition|)
block|{
name|time_t
name|xdate
decl_stmt|;
name|xdate
operator|=
name|e
operator|->
name|e_parent
operator|->
name|e_ctime
operator|+
name|TimeOuts
operator|.
name|to_q_return
index|[
name|e
operator|->
name|e_parent
operator|->
name|e_timeoutclass
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|"Will-Retry-Until: "
argument_list|,
name|arpadate
argument_list|(
name|ctime
argument_list|(
operator|&
name|xdate
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* DSN */
comment|/* 	**  Output text of original message 	*/
if|if
condition|(
operator|!
name|putline
argument_list|(
literal|""
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
if|if
condition|(
name|bitset
argument_list|(
name|EF_HAS_DF
argument_list|,
name|e
operator|->
name|e_parent
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|sendbody
operator|=
operator|!
name|bitset
argument_list|(
name|EF_NO_BODY_RETN
argument_list|,
name|e
operator|->
name|e_parent
operator|->
name|e_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_NO_BODY_RETN
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_msgboundary
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|putline
argument_list|(
name|sendbody
condition|?
literal|"   ----- Original message follows -----\n"
else|:
literal|"   ----- Message header follows -----\n"
argument_list|,
name|mci
argument_list|)
condition|)
block|{
goto|goto
name|writeerr
goto|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|"--"
argument_list|,
name|e
operator|->
name|e_msgboundary
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|"Content-Type: "
argument_list|,
name|sendbody
condition|?
literal|"message/rfc822"
else|:
literal|"text/rfc822-headers"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
name|p
operator|=
name|hvalue
argument_list|(
literal|"Content-Transfer-Encoding"
argument_list|,
name|e
operator|->
name|e_parent
operator|->
name|e_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|sm_strcasecmp
argument_list|(
name|p
argument_list|,
literal|"binary"
argument_list|)
operator|!=
literal|0
condition|)
name|p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|&&
name|bitset
argument_list|(
name|EF_HAS8BIT
argument_list|,
name|e
operator|->
name|e_parent
operator|->
name|e_flags
argument_list|)
condition|)
name|p
operator|=
literal|"8bit"
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Content-Transfer-Encoding: %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|putline
argument_list|(
literal|""
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
name|save_errno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
operator|!
name|putheader
argument_list|(
name|mci
argument_list|,
name|e
operator|->
name|e_parent
operator|->
name|e_header
argument_list|,
name|e
operator|->
name|e_parent
argument_list|,
name|M87F_OUTER
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
name|errno
operator|=
name|save_errno
expr_stmt|;
if|if
condition|(
name|sendbody
condition|)
block|{
if|if
condition|(
operator|!
name|putbody
argument_list|(
name|mci
argument_list|,
name|e
operator|->
name|e_parent
argument_list|,
name|e
operator|->
name|e_msgboundary
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|e_msgboundary
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|putline
argument_list|(
literal|""
argument_list|,
name|mci
argument_list|)
operator|||
operator|!
name|putline
argument_list|(
literal|"   ----- Message body suppressed -----"
argument_list|,
name|mci
argument_list|)
condition|)
block|{
goto|goto
name|writeerr
goto|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|e_msgboundary
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|putline
argument_list|(
literal|"  ----- No message was collected -----\n"
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
if|if
condition|(
name|e
operator|->
name|e_msgboundary
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sm_strlcpyn
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|3
argument_list|,
literal|"--"
argument_list|,
name|e
operator|->
name|e_msgboundary
argument_list|,
literal|"--"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putline
argument_list|(
literal|""
argument_list|,
name|mci
argument_list|)
operator|||
operator|!
name|putline
argument_list|(
name|buf
argument_list|,
name|mci
argument_list|)
condition|)
goto|goto
name|writeerr
goto|;
block|}
if|if
condition|(
operator|!
name|putline
argument_list|(
literal|""
argument_list|,
name|mci
argument_list|)
operator|||
name|sm_io_flush
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
name|SM_TIME_DEFAULT
argument_list|)
operator|==
name|SM_IO_EOF
condition|)
goto|goto
name|writeerr
goto|;
comment|/* 	**  Cleanup and exit 	*/
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|writeerr
label|:
name|syserr
argument_list|(
literal|"errbody: I/O error"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* **  SMTPTODSN -- convert SMTP to DSN status code ** **	Parameters: **		smtpstat -- the smtp status code (e.g., 550). ** **	Returns: **		The DSN version of the status code. ** **	Storage Management: **		smtptodsn() returns a pointer to a character string literal, **		which will remain valid forever, and thus does not need to **		be copied.  Current code relies on this property. */
end_comment

begin_function
name|char
modifier|*
name|smtptodsn
parameter_list|(
name|smtpstat
parameter_list|)
name|int
name|smtpstat
decl_stmt|;
block|{
if|if
condition|(
name|smtpstat
operator|<
literal|0
condition|)
return|return
literal|"4.4.2"
return|;
switch|switch
condition|(
name|smtpstat
condition|)
block|{
case|case
literal|450
case|:
comment|/* Req mail action not taken: mailbox unavailable */
return|return
literal|"4.2.0"
return|;
case|case
literal|451
case|:
comment|/* Req action aborted: local error in processing */
return|return
literal|"4.3.0"
return|;
case|case
literal|452
case|:
comment|/* Req action not taken: insufficient sys storage */
return|return
literal|"4.3.1"
return|;
case|case
literal|500
case|:
comment|/* Syntax error, command unrecognized */
return|return
literal|"5.5.2"
return|;
case|case
literal|501
case|:
comment|/* Syntax error in parameters or arguments */
return|return
literal|"5.5.4"
return|;
case|case
literal|502
case|:
comment|/* Command not implemented */
return|return
literal|"5.5.1"
return|;
case|case
literal|503
case|:
comment|/* Bad sequence of commands */
return|return
literal|"5.5.1"
return|;
case|case
literal|504
case|:
comment|/* Command parameter not implemented */
return|return
literal|"5.5.4"
return|;
case|case
literal|550
case|:
comment|/* Req mail action not taken: mailbox unavailable */
return|return
literal|"5.2.0"
return|;
case|case
literal|551
case|:
comment|/* User not local; please try<...> */
return|return
literal|"5.1.6"
return|;
case|case
literal|552
case|:
comment|/* Req mail action aborted: exceeded storage alloc */
return|return
literal|"5.2.2"
return|;
case|case
literal|553
case|:
comment|/* Req action not taken: mailbox name not allowed */
return|return
literal|"5.1.0"
return|;
case|case
literal|554
case|:
comment|/* Transaction failed */
return|return
literal|"5.0.0"
return|;
block|}
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|smtpstat
argument_list|)
operator|==
literal|2
condition|)
return|return
literal|"2.0.0"
return|;
if|if
condition|(
name|REPLYTYPE
argument_list|(
name|smtpstat
argument_list|)
operator|==
literal|4
condition|)
return|return
literal|"4.0.0"
return|;
return|return
literal|"5.0.0"
return|;
block|}
end_function

begin_comment
comment|/* **  XTEXTIFY -- take regular text and turn it into DSN-style xtext ** **	Parameters: **		t -- the text to convert. **		taboo -- additional characters that must be encoded. ** **	Returns: **		The xtext-ified version of the same string. */
end_comment

begin_function
name|char
modifier|*
name|xtextify
parameter_list|(
name|t
parameter_list|,
name|taboo
parameter_list|)
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|taboo
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|l
decl_stmt|;
name|int
name|nbogus
decl_stmt|;
specifier|static
name|char
modifier|*
name|bp
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|bplen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|taboo
operator|==
name|NULL
condition|)
name|taboo
operator|=
literal|""
expr_stmt|;
comment|/* figure out how long this xtext will have to be */
name|nbogus
operator|=
name|l
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|t
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
specifier|register
name|int
name|c
init|=
operator|(
operator|*
name|p
operator|&
literal|0xff
operator|)
decl_stmt|;
comment|/* ASCII dependence here -- this is the way the spec words it */
if|if
condition|(
name|c
operator|<
literal|'!'
operator|||
name|c
operator|>
literal|'~'
operator|||
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
literal|'('
operator|||
name|strchr
argument_list|(
name|taboo
argument_list|,
name|c
argument_list|)
operator|!=
name|NULL
condition|)
name|nbogus
operator|++
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nbogus
operator|<
literal|0
condition|)
block|{
comment|/* since nbogus is ssize_t and wrapped, 2 * size_t would wrap */
name|syserr
argument_list|(
literal|"!xtextify string too long"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nbogus
operator|==
literal|0
condition|)
return|return
name|t
return|;
name|l
operator|+=
name|nbogus
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
comment|/* now allocate space if necessary for the new string */
if|if
condition|(
name|l
operator|>
name|bplen
condition|)
block|{
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* XXX */
name|bp
operator|=
name|sm_pmalloc_x
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|bplen
operator|=
name|l
expr_stmt|;
block|}
comment|/* ok, copy the text with byte expansion */
for|for
control|(
name|p
operator|=
name|bp
init|;
operator|*
name|t
operator|!=
literal|'\0'
condition|;
control|)
block|{
specifier|register
name|int
name|c
init|=
operator|(
operator|*
name|t
operator|++
operator|&
literal|0xff
operator|)
decl_stmt|;
comment|/* ASCII dependence here -- this is the way the spec words it */
if|if
condition|(
name|c
operator|<
literal|'!'
operator|||
name|c
operator|>
literal|'~'
operator|||
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
literal|'('
operator|||
name|strchr
argument_list|(
name|taboo
argument_list|,
name|c
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'+'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|"0123456789ABCDEF"
index|[
name|c
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|"0123456789ABCDEF"
index|[
name|c
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
else|else
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|bp
return|;
block|}
end_function

begin_comment
comment|/* **  XUNTEXTIFY -- take xtext and turn it into plain text ** **	Parameters: **		t -- the xtextified text. ** **	Returns: **		The decoded text.  No attempt is made to deal with **		null strings in the resulting text. */
end_comment

begin_function
name|char
modifier|*
name|xuntextify
parameter_list|(
name|t
parameter_list|)
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|l
decl_stmt|;
specifier|static
name|char
modifier|*
name|bp
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|bplen
init|=
literal|0
decl_stmt|;
comment|/* heuristic -- if no plus sign, just return the input */
if|if
condition|(
name|strchr
argument_list|(
name|t
argument_list|,
literal|'+'
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|t
return|;
comment|/* xtext is always longer than decoded text */
name|l
operator|=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|bplen
condition|)
block|{
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|sm_free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* XXX */
name|bp
operator|=
name|xalloc
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|bplen
operator|=
name|l
expr_stmt|;
block|}
comment|/* ok, copy the text with byte compression */
for|for
control|(
name|p
operator|=
name|bp
init|;
operator|*
name|t
operator|!=
literal|'\0'
condition|;
name|t
operator|++
control|)
block|{
specifier|register
name|int
name|c
init|=
operator|*
name|t
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'+'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
name|c
operator|=
operator|*
operator|++
name|t
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|!
name|isascii
argument_list|(
name|c
argument_list|)
operator|||
operator|!
name|isxdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* error -- first digit is not hex */
name|usrerr
argument_list|(
literal|"bogus xtext: +%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|t
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|-=
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|-=
literal|'A'
operator|-
literal|10
expr_stmt|;
else|else
name|c
operator|-=
literal|'a'
operator|-
literal|10
expr_stmt|;
operator|*
name|p
operator|=
name|c
operator|<<
literal|4
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|t
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|!
name|isascii
argument_list|(
name|c
argument_list|)
operator|||
operator|!
name|isxdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* error -- second digit is not hex */
name|usrerr
argument_list|(
literal|"bogus xtext: +%x%c"
argument_list|,
operator|*
name|p
operator|>>
literal|4
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|t
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|-=
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|-=
literal|'A'
operator|-
literal|10
expr_stmt|;
else|else
name|c
operator|-=
literal|'a'
operator|-
literal|10
expr_stmt|;
operator|*
name|p
operator|++
operator||=
name|c
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|bp
return|;
block|}
end_function

begin_comment
comment|/* **  XTEXTOK -- check if a string is legal xtext ** **	Xtext is used in Delivery Status Notifications.  The spec was **	taken from RFC 1891, ``SMTP Service Extension for Delivery **	Status Notifications''. ** **	Parameters: **		s -- the string to check. ** **	Returns: **		true -- if 's' is legal xtext. **		false -- if it has any illegal characters in it. */
end_comment

begin_function
name|bool
name|xtextok
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'+'
condition|)
block|{
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isascii
argument_list|(
name|c
argument_list|)
operator|||
operator|!
name|isxdigit
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|false
return|;
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isascii
argument_list|(
name|c
argument_list|)
operator|||
operator|!
name|isxdigit
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|'!'
operator|||
name|c
operator|>
literal|'~'
operator|||
name|c
operator|==
literal|'='
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* **  PRUNEROUTE -- prune an RFC-822 source route ** **	Trims down a source route to the last internet-registered hop. **	This is encouraged by RFC 1123 section 5.3.3. ** **	Parameters: **		addr -- the address ** **	Returns: **		true -- address was modified **		false -- address could not be pruned ** **	Side Effects: **		modifies addr in-place */
end_comment

begin_function
specifier|static
name|bool
name|pruneroute
parameter_list|(
name|addr
parameter_list|)
name|char
modifier|*
name|addr
decl_stmt|;
block|{
if|#
directive|if
name|NAMED_BIND
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|at
decl_stmt|,
modifier|*
name|comma
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|braclev
decl_stmt|;
name|int
name|rcode
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|hostbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|mxhosts
index|[
name|MAXMXHOSTS
operator|+
literal|1
index|]
decl_stmt|;
comment|/* check to see if this is really a route-addr */
if|if
condition|(
operator|*
name|addr
operator|!=
literal|'<'
operator|||
name|addr
index|[
literal|1
index|]
operator|!=
literal|'@'
operator|||
name|addr
index|[
name|strlen
argument_list|(
name|addr
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'>'
condition|)
return|return
name|false
return|;
comment|/* 	**  Can't simply find the first ':' is the address might be in the 	**  form:  "<@[IPv6:::1]:user@host>" and the first ':' in inside 	**  the IPv6 address. 	*/
name|start
operator|=
name|addr
expr_stmt|;
name|braclev
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|start
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|start
operator|==
literal|':'
operator|&&
name|braclev
operator|<=
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
operator|*
name|start
operator|==
literal|'['
condition|)
name|braclev
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|start
operator|==
literal|']'
operator|&&
name|braclev
operator|>
literal|0
condition|)
name|braclev
operator|--
expr_stmt|;
name|start
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|braclev
operator|>
literal|0
operator|||
operator|*
name|start
operator|!=
literal|':'
condition|)
return|return
name|false
return|;
name|at
operator|=
name|strrchr
argument_list|(
name|addr
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
operator|==
name|NULL
operator|||
name|at
operator|<
name|start
condition|)
return|return
name|false
return|;
comment|/* slice off the angle brackets */
name|i
operator|=
name|strlen
argument_list|(
name|at
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
sizeof|sizeof
argument_list|(
name|hostbuf
argument_list|)
condition|)
return|return
name|false
return|;
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|hostbuf
argument_list|,
name|at
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|hostbuf
argument_list|)
argument_list|)
expr_stmt|;
name|hostbuf
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|start
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|getmxrr
argument_list|(
name|hostbuf
argument_list|,
name|mxhosts
argument_list|,
name|NULL
argument_list|,
name|false
argument_list|,
operator|&
name|rcode
argument_list|,
name|true
argument_list|,
name|NULL
argument_list|)
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|addr
operator|+
literal|1
argument_list|,
name|start
operator|+
literal|1
argument_list|,
name|strlen
argument_list|(
name|addr
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|c
operator|=
operator|*
name|start
expr_stmt|;
operator|*
name|start
operator|=
literal|'\0'
expr_stmt|;
name|comma
operator|=
name|strrchr
argument_list|(
name|addr
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|comma
operator|!=
name|NULL
operator|&&
name|comma
index|[
literal|1
index|]
operator|==
literal|'@'
operator|&&
name|strlen
argument_list|(
name|comma
operator|+
literal|2
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|hostbuf
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sm_strlcpy
argument_list|(
name|hostbuf
argument_list|,
name|comma
operator|+
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|hostbuf
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|comma
operator|=
name|NULL
expr_stmt|;
operator|*
name|start
operator|=
name|c
expr_stmt|;
name|start
operator|=
name|comma
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NAMED_BIND */
return|return
name|false
return|;
block|}
end_function

end_unit

