begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997-1999 Erez Zadok  * Copyright (c) 1989 Jan-Simon Pendry  * Copyright (c) 1989 Imperial College of Science, Technology& Medicine  * Copyright (c) 1989 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry at Imperial College, London.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgment:  *      This product includes software developed by the University of  *      California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      %W% (Berkeley) %G%  *  * $Id: rpc_fwd.c,v 1.2 1999/01/10 21:53:52 ezk Exp $  *  */
end_comment

begin_comment
comment|/*  * RPC packet forwarding  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<am_defs.h>
end_include

begin_include
include|#
directive|include
file|<amd.h>
end_include

begin_comment
comment|/*  * Note that the ID field in the external packet is only  * ever treated as a 32 bit opaque data object, so there  * is no need to convert to and from network byte ordering.  */
end_comment

begin_define
define|#
directive|define
name|XID_ALLOC
parameter_list|(
name|struct
define|)	(xid++)
end_define

begin_define
define|#
directive|define
name|MAX_PACKET_SIZE
value|8192
end_define

begin_comment
comment|/* Maximum UDP packet size */
end_comment

begin_comment
comment|/*  * Each pending reply has an rpc_forward structure  * associated with it.  These have a 15 second lifespan.  * If a new structure is required, then an expired  * one will be re-allocated if available, otherwise a fresh  * one is allocated.  Whenever a reply is received the  * structure is discarded.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|rpc_forward
name|rpc_forward
typedef|;
end_typedef

begin_struct
struct|struct
name|rpc_forward
block|{
name|qelem
name|rf_q
decl_stmt|;
comment|/* Linked list */
name|time_t
name|rf_ttl
decl_stmt|;
comment|/* Time to live */
name|u_int
name|rf_xid
decl_stmt|;
comment|/* Packet id */
name|u_int
name|rf_oldid
decl_stmt|;
comment|/* Original packet id */
name|fwd_fun
name|rf_fwd
decl_stmt|;
comment|/* Forwarding function */
name|voidp
name|rf_ptr
decl_stmt|;
name|struct
name|sockaddr_in
name|rf_sin
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Head of list of pending replies  */
end_comment

begin_decl_stmt
name|qelem
name|rpc_head
init|=
block|{
operator|&
name|rpc_head
block|,
operator|&
name|rpc_head
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fwd_sock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|xid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Allocate a rely structure  */
end_comment

begin_function
specifier|static
name|rpc_forward
modifier|*
name|fwd_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|time_t
name|now
init|=
name|clocktime
argument_list|()
decl_stmt|;
name|rpc_forward
modifier|*
name|p
init|=
literal|0
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
comment|/*    * First search for an existing expired one.    */
name|ITER
argument_list|(
argument|p2
argument_list|,
argument|rpc_forward
argument_list|,
argument|&rpc_head
argument_list|)
block|{
if|if
condition|(
name|p2
operator|->
name|rf_ttl
operator|<=
name|now
condition|)
block|{
name|p
operator|=
name|p2
expr_stmt|;
break|break;
block|}
block|}
comment|/*    * If one couldn't be found then allocate    * a new structure and link it at the    * head of the list.    */
if|if
condition|(
name|p
condition|)
block|{
comment|/*      * Call forwarding function to say that      * this message was junked.      */
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Re-using packet forwarding slot - id %#x"
argument_list|,
name|p
operator|->
name|rf_xid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|p
operator|->
name|rf_fwd
condition|)
call|(
modifier|*
name|p
operator|->
name|rf_fwd
call|)
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|p
operator|->
name|rf_sin
argument_list|,
name|p
operator|->
name|rf_ptr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|rem_que
argument_list|(
operator|&
name|p
operator|->
name|rf_q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|ALLOC
argument_list|(
expr|struct
name|rpc_forward
argument_list|)
expr_stmt|;
block|}
name|ins_que
argument_list|(
operator|&
name|p
operator|->
name|rf_q
argument_list|,
operator|&
name|rpc_head
argument_list|)
expr_stmt|;
comment|/*    * Set the time to live field    * Timeout in 43 seconds    */
name|p
operator|->
name|rf_ttl
operator|=
name|now
operator|+
literal|43
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * Free an allocated reply structure.  * First unlink it from the list, then  * discard it.  */
end_comment

begin_function
specifier|static
name|void
name|fwd_free
parameter_list|(
name|rpc_forward
modifier|*
name|p
parameter_list|)
block|{
name|rem_que
argument_list|(
operator|&
name|p
operator|->
name|rf_q
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the RPC forwarder  */
end_comment

begin_function
name|int
name|fwd_init
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|FIONBIO
name|int
name|on
init|=
literal|1
decl_stmt|;
endif|#
directive|endif
comment|/* FIONBIO */
ifdef|#
directive|ifdef
name|HAVE_TRANSPORT_TYPE_TLI
comment|/*    * Create ping TLI socket (/dev/tcp and /dev/ticlts did not work)    * (HPUX-11 does not like using O_NDELAY in flags)    */
name|fwd_sock
operator|=
name|t_open
argument_list|(
literal|"/dev/udp"
argument_list|,
name|O_RDWR
operator||
name|O_NONBLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwd_sock
operator|<
literal|0
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"unable to create RPC forwarding TLI socket: %s"
argument_list|,
name|t_errlist
index|[
name|t_errno
index|]
argument_list|)
expr_stmt|;
return|return
name|errno
return|;
block|}
else|#
directive|else
comment|/* not HAVE_TRANSPORT_TYPE_TLI */
comment|/*    * Create ping socket    */
name|fwd_sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwd_sock
operator|<
literal|0
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"unable to create RPC forwarding socket: %m"
argument_list|)
expr_stmt|;
return|return
name|errno
return|;
block|}
endif|#
directive|endif
comment|/* not HAVE_TRANSPORT_TYPE_TLI */
comment|/*    * Some things we talk to require a priv port - so make one here    */
if|if
condition|(
name|bind_resv_port
argument_list|(
name|fwd_sock
argument_list|,
operator|(
name|u_short
operator|*
operator|)
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"can't bind privileged port"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|fwd_sock
argument_list|,
name|F_SETFL
argument_list|,
name|FNDELAY
argument_list|)
operator|<
literal|0
ifdef|#
directive|ifdef
name|FIONBIO
operator|&&
name|ioctl
argument_list|(
name|fwd_sock
argument_list|,
name|FIONBIO
argument_list|,
operator|&
name|on
argument_list|)
operator|<
literal|0
endif|#
directive|endif
comment|/* FIONBIO */
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"Can't set non-block on forwarding socket: %m"
argument_list|)
expr_stmt|;
return|return
name|errno
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Locate a packet in the forwarding list  */
end_comment

begin_function
specifier|static
name|rpc_forward
modifier|*
name|fwd_locate
parameter_list|(
name|u_int
name|id
parameter_list|)
block|{
name|rpc_forward
modifier|*
name|p
decl_stmt|;
name|ITER
argument_list|(
argument|p
argument_list|,
argument|rpc_forward
argument_list|,
argument|&rpc_head
argument_list|)
block|{
if|if
condition|(
name|p
operator|->
name|rf_xid
operator|==
name|id
condition|)
return|return
name|p
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This is called to forward a packet to another  * RPC server.  The message id is changed and noted  * so that when a reply appears we can tie it up  * correctly.  Just matching the reply's source address  * would not work because it might come from a  * different address.  */
end_comment

begin_function
name|int
name|fwd_packet
parameter_list|(
name|int
name|type_id
parameter_list|,
name|voidp
name|pkt
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|fwdto
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|replyto
parameter_list|,
name|voidp
name|i
parameter_list|,
name|fwd_fun
name|cb
parameter_list|)
block|{
name|rpc_forward
modifier|*
name|p
decl_stmt|;
name|u_int
modifier|*
name|pkt_int
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TRANSPORT_TYPE_TLI
name|struct
name|t_unitdata
name|ud
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_TRANSPORT_TYPE_TLI */
if|if
condition|(
operator|(
name|int
operator|)
name|amd_state
operator|>=
operator|(
name|int
operator|)
name|Finishing
condition|)
return|return
name|ENOENT
return|;
comment|/*    * See if the type_id is fully specified.    * If so, then discard any old entries    * for this id.    * Otherwise make sure the type_id is    * fully qualified by allocating an id here.    */
ifdef|#
directive|ifdef
name|DEBUG
switch|switch
condition|(
name|type_id
operator|&
name|RPC_XID_MASK
condition|)
block|{
case|case
name|RPC_XID_PORTMAP
case|:
name|dlog
argument_list|(
literal|"Sending PORTMAP request"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RPC_XID_MOUNTD
case|:
name|dlog
argument_list|(
literal|"Sending MOUNTD request %#x"
argument_list|,
name|type_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|RPC_XID_NFSPING
case|:
name|dlog
argument_list|(
literal|"Sending NFS ping"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|dlog
argument_list|(
literal|"UNKNOWN RPC XID"
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|type_id
operator|&
operator|~
name|RPC_XID_MASK
condition|)
block|{
name|p
operator|=
name|fwd_locate
argument_list|(
name|type_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Discarding earlier rpc fwd handle"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|fwd_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Allocating a new xid..."
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|type_id
operator|=
name|MK_RPC_XID
argument_list|(
name|type_id
argument_list|,
name|XID_ALLOC
argument_list|(
expr|struct
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|fwd_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|ENOBUFS
return|;
name|error
operator|=
literal|0
expr_stmt|;
name|pkt_int
operator|=
operator|(
name|u_int
operator|*
operator|)
name|pkt
expr_stmt|;
comment|/*    * Get the original packet id    */
name|p
operator|->
name|rf_oldid
operator|=
operator|*
name|pkt_int
expr_stmt|;
comment|/*    * Replace with newly allocated id    */
name|p
operator|->
name|rf_xid
operator|=
operator|*
name|pkt_int
operator|=
name|type_id
expr_stmt|;
comment|/*    * The sendto may fail if, for example, the route    * to a remote host is lost because an intermediate    * gateway has gone down.  Important to fill in the    * rest of "p" otherwise nasty things happen later...    */
ifdef|#
directive|ifdef
name|DEBUG
block|{
name|char
name|dq
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|p
operator|&&
name|fwdto
condition|)
name|dlog
argument_list|(
literal|"Sending packet id %#x to %s.%d"
argument_list|,
name|p
operator|->
name|rf_xid
argument_list|,
name|inet_dquad
argument_list|(
name|dq
argument_list|,
name|fwdto
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|fwdto
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
comment|/* if NULL, remote server probably down */
if|if
condition|(
operator|!
name|fwdto
condition|)
block|{
name|error
operator|=
name|AM_ERRNO_HOST_DOWN
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|HAVE_TRANSPORT_TYPE_TLI
name|ud
operator|.
name|addr
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|fwdto
expr_stmt|;
if|if
condition|(
name|fwdto
condition|)
comment|/* if NULL, set sizes to zero */
name|ud
operator|.
name|addr
operator|.
name|maxlen
operator|=
name|ud
operator|.
name|addr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
else|else
name|ud
operator|.
name|addr
operator|.
name|maxlen
operator|=
name|ud
operator|.
name|addr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|opt
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|ud
operator|.
name|opt
operator|.
name|maxlen
operator|=
name|ud
operator|.
name|opt
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|udata
operator|.
name|buf
operator|=
name|pkt
expr_stmt|;
name|ud
operator|.
name|udata
operator|.
name|maxlen
operator|=
name|ud
operator|.
name|udata
operator|.
name|len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|t_sndudata
argument_list|(
name|fwd_sock
argument_list|,
operator|&
name|ud
argument_list|)
operator|<
literal|0
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"fwd_packet failed: t_errno=%d, errno=%d"
argument_list|,
name|t_errno
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
operator|=
name|errno
expr_stmt|;
block|}
else|#
directive|else
comment|/* not HAVE_TRANSPORT_TYPE_TLI */
if|if
condition|(
name|sendto
argument_list|(
name|fwd_sock
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pkt
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|fwdto
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fwdto
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|error
operator|=
name|errno
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_TRANSPORT_TYPE_TLI */
comment|/*    * Save callback function and return address    */
name|out
label|:
name|p
operator|->
name|rf_fwd
operator|=
name|cb
expr_stmt|;
if|if
condition|(
name|replyto
condition|)
name|p
operator|->
name|rf_sin
operator|=
operator|*
name|replyto
expr_stmt|;
else|else
name|memset
argument_list|(
operator|(
name|voidp
operator|)
operator|&
name|p
operator|->
name|rf_sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|rf_sin
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|rf_ptr
operator|=
name|i
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Called when some data arrives on the forwarding socket  */
end_comment

begin_function
name|void
name|fwd_reply
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|u_int
name|pkt
index|[
name|MAX_PACKET_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
name|u_int
modifier|*
name|pkt_int
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rpc_forward
modifier|*
name|p
decl_stmt|;
name|struct
name|sockaddr_in
name|src_addr
decl_stmt|;
name|RECVFROM_FROMLEN_TYPE
name|src_addr_len
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TRANSPORT_TYPE_TLI
name|struct
name|t_unitdata
name|ud
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_TRANSPORT_TYPE_TLI */
comment|/*    * Determine the length of the packet    */
name|len
operator|=
name|MAX_PACKET_SIZE
expr_stmt|;
comment|/*    * Read the packet and check for validity    */
name|again
label|:
name|src_addr_len
operator|=
sizeof|sizeof
argument_list|(
name|src_addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TRANSPORT_TYPE_TLI
name|ud
operator|.
name|addr
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|src_addr
expr_stmt|;
name|ud
operator|.
name|addr
operator|.
name|maxlen
operator|=
name|ud
operator|.
name|addr
operator|.
name|len
operator|=
name|src_addr_len
expr_stmt|;
name|ud
operator|.
name|opt
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|ud
operator|.
name|opt
operator|.
name|maxlen
operator|=
name|ud
operator|.
name|opt
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|udata
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|pkt
expr_stmt|;
name|ud
operator|.
name|udata
operator|.
name|maxlen
operator|=
name|ud
operator|.
name|udata
operator|.
name|len
operator|=
name|len
expr_stmt|;
comment|/* XXX: use flags accordingly such as if T_MORE set */
name|rc
operator|=
name|t_rcvudata
argument_list|(
name|fwd_sock
argument_list|,
operator|&
name|ud
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
comment|/* success, reset rc to length */
name|rc
operator|=
name|ud
operator|.
name|udata
operator|.
name|len
expr_stmt|;
else|else
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"fwd_reply failed: t_errno=%d, errno=%d, flags=%d"
argument_list|,
name|t_errno
argument_list|,
name|errno
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* not HAVE_TRANSPORT_TYPE_TLI */
name|rc
operator|=
name|recvfrom
argument_list|(
name|fwd_sock
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pkt
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|src_addr
argument_list|,
operator|&
name|src_addr_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_TRANSPORT_TYPE_TLI */
comment|/*    * XXX: in svr4, if the T_MORE bit of flags is set, what do    * we then do?  -Erez    */
if|if
condition|(
name|rc
operator|<
literal|0
operator|||
name|src_addr_len
operator|!=
sizeof|sizeof
argument_list|(
name|src_addr
argument_list|)
operator|||
name|src_addr
operator|.
name|sin_family
operator|!=
name|AF_INET
condition|)
block|{
if|if
condition|(
name|rc
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
goto|goto
name|again
goto|;
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"Error reading RPC reply: %m"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*    * Do no more work if finishing soon    */
if|if
condition|(
operator|(
name|int
operator|)
name|amd_state
operator|>=
operator|(
name|int
operator|)
name|Finishing
condition|)
goto|goto
name|out
goto|;
comment|/*    * Find packet reference    */
name|pkt_int
operator|=
operator|(
name|u_int
operator|*
operator|)
name|pkt
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
switch|switch
condition|(
operator|*
name|pkt_int
operator|&
name|RPC_XID_MASK
condition|)
block|{
case|case
name|RPC_XID_PORTMAP
case|:
name|dlog
argument_list|(
literal|"Receiving PORTMAP reply"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RPC_XID_MOUNTD
case|:
name|dlog
argument_list|(
literal|"Receiving MOUNTD reply %#x"
argument_list|,
operator|*
name|pkt_int
argument_list|)
expr_stmt|;
break|break;
case|case
name|RPC_XID_NFSPING
case|:
name|dlog
argument_list|(
literal|"Receiving NFS ping %#x"
argument_list|,
operator|*
name|pkt_int
argument_list|)
expr_stmt|;
break|break;
default|default:
name|dlog
argument_list|(
literal|"UNKNOWN RPC XID"
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* DEBUG */
name|p
operator|=
name|fwd_locate
argument_list|(
operator|*
name|pkt_int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Can't forward reply id %#x"
argument_list|,
operator|*
name|pkt_int
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|rf_fwd
condition|)
block|{
comment|/*      * Put the original message id back      * into the packet.      */
operator|*
name|pkt_int
operator|=
name|p
operator|->
name|rf_oldid
expr_stmt|;
comment|/*      * Call forwarding function      */
call|(
modifier|*
name|p
operator|->
name|rf_fwd
call|)
argument_list|(
operator|(
name|voidp
operator|)
name|pkt
argument_list|,
name|rc
argument_list|,
operator|&
name|src_addr
argument_list|,
operator|&
name|p
operator|->
name|rf_sin
argument_list|,
name|p
operator|->
name|rf_ptr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/*    * Free forwarding info    */
name|fwd_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|out
label|:
empty_stmt|;
block|}
end_function

end_unit

