begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997-2006 Erez Zadok  * Copyright (c) 1990 Jan-Simon Pendry  * Copyright (c) 1990 Imperial College of Science, Technology& Medicine  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry at Imperial College, London.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgment:  *      This product includes software developed by the University of  *      California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *  * File: am-utils/amd/amfs_generic.c  *  */
end_comment

begin_comment
comment|/*  * generic functions used by amfs filesystems, ripped out of amfs_auto.c.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<am_defs.h>
end_include

begin_include
include|#
directive|include
file|<amd.h>
end_include

begin_comment
comment|/****************************************************************************  *** MACROS                                                               ***  ****************************************************************************/
end_comment

begin_define
define|#
directive|define
name|IN_PROGRESS
parameter_list|(
name|cp
parameter_list|)
value|((cp)->mp->am_mnt->mf_flags& MFF_MOUNTING)
end_define

begin_comment
comment|/****************************************************************************  *** STRUCTURES                                                           ***  ****************************************************************************/
end_comment

begin_comment
comment|/*  * Mounting a file system may take a significant period of time.  The  * problem is that if this is done in the main process thread then the  * entire automounter could be blocked, possibly hanging lots of processes  * on the system.  Instead we use a continuation scheme to allow mounts to  * be attempted in a sub-process.  When the sub-process exits we pick up the  * exit status (by convention a UN*X error number) and continue in a  * notifier.  The notifier gets handed a data structure and can then  * determine whether the mount was successful or not.  If not, it updates  * the data structure and tries again until there are no more ways to try  * the mount, or some other permanent error occurs.  In the mean time no RPC  * reply is sent, even after the mount is successful.  We rely on the RPC  * retry mechanism to resend the lookup request which can then be handled.  */
end_comment

begin_struct
struct|struct
name|continuation
block|{
name|am_node
modifier|*
name|mp
decl_stmt|;
comment|/* Node we are trying to mount */
name|int
name|retry
decl_stmt|;
comment|/* Try again? */
name|time_t
name|start
decl_stmt|;
comment|/* Time we started this mount */
name|int
name|callout
decl_stmt|;
comment|/* Callout identifier */
name|mntfs
modifier|*
modifier|*
name|mf
decl_stmt|;
comment|/* Current mntfs */
block|}
struct|;
end_struct

begin_comment
comment|/****************************************************************************  *** FORWARD DEFINITIONS                                                  ***  ****************************************************************************/
end_comment

begin_function_decl
specifier|static
name|am_node
modifier|*
name|amfs_lookup_node
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|,
name|char
modifier|*
name|fname
parameter_list|,
name|int
modifier|*
name|error_return
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|mntfs
modifier|*
name|amfs_lookup_one_mntfs
parameter_list|(
name|am_node
modifier|*
name|new_mp
parameter_list|,
name|mntfs
modifier|*
name|mf
parameter_list|,
name|char
modifier|*
name|ivec
parameter_list|,
name|char
modifier|*
name|def_opts
parameter_list|,
name|char
modifier|*
name|pfname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|mntfs
modifier|*
modifier|*
name|amfs_lookup_mntfs
parameter_list|(
name|am_node
modifier|*
name|new_mp
parameter_list|,
name|int
modifier|*
name|error_return
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|amfs_cont
parameter_list|(
name|int
name|rc
parameter_list|,
name|int
name|term
parameter_list|,
name|opaque_t
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|amfs_retry
parameter_list|(
name|int
name|rc
parameter_list|,
name|int
name|term
parameter_list|,
name|opaque_t
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_continuation
parameter_list|(
name|struct
name|continuation
modifier|*
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|amfs_bgmount
parameter_list|(
name|struct
name|continuation
modifier|*
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|amfs_parse_defaults
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|,
name|mntfs
modifier|*
name|mf
parameter_list|,
name|char
modifier|*
name|def_opts
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/****************************************************************************  *** FUNCTIONS                                                             ***  ****************************************************************************/
end_comment

begin_function
specifier|static
name|am_node
modifier|*
name|amfs_lookup_node
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|,
name|char
modifier|*
name|fname
parameter_list|,
name|int
modifier|*
name|error_return
parameter_list|)
block|{
name|am_node
modifier|*
name|new_mp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Error so far */
name|int
name|in_progress
init|=
literal|0
decl_stmt|;
comment|/* # of (un)mount in progress */
name|mntfs
modifier|*
name|mf
decl_stmt|;
name|char
modifier|*
name|expanded_fname
init|=
literal|0
decl_stmt|;
name|dlog
argument_list|(
literal|"in amfs_lookup_node"
argument_list|)
expr_stmt|;
comment|/*    * If the server is shutting down    * then don't return information    * about the mount point.    */
if|if
condition|(
name|amd_state
operator|==
name|Finishing
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|am_mnt
operator|==
literal|0
operator|||
name|mp
operator|->
name|am_mnt
operator|->
name|mf_fsflags
operator|&
name|FS_DIRECT
condition|)
block|{
name|dlog
argument_list|(
literal|"%s mount ignored - going down"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dlog
argument_list|(
literal|"%s/%s mount ignored - going down"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
name|ereturn
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
block|}
comment|/*    * Handle special case of "." and ".."    */
if|if
condition|(
name|fname
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|fname
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
name|mp
return|;
comment|/* "." is the current node */
if|if
condition|(
name|fname
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|fname
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|am_parent
condition|)
block|{
name|dlog
argument_list|(
literal|".. in %s gives %s"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|mp
operator|->
name|am_parent
operator|->
name|am_path
argument_list|)
expr_stmt|;
return|return
name|mp
operator|->
name|am_parent
return|;
comment|/* ".." is the parent node */
block|}
name|ereturn
argument_list|(
name|ESTALE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Check for valid key name.    * If it is invalid then pretend it doesn't exist.    */
if|if
condition|(
operator|!
name|valid_key
argument_list|(
name|fname
argument_list|)
condition|)
block|{
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"Key \"%s\" contains a disallowed character"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
block|}
comment|/*    * Expand key name.    * expanded_fname is now a private copy.    */
name|expanded_fname
operator|=
name|expand_selectors
argument_list|(
name|fname
argument_list|)
expr_stmt|;
comment|/*    * Search children of this node    */
for|for
control|(
name|new_mp
operator|=
name|mp
operator|->
name|am_child
init|;
name|new_mp
condition|;
name|new_mp
operator|=
name|new_mp
operator|->
name|am_osib
control|)
block|{
if|if
condition|(
name|FSTREQ
argument_list|(
name|new_mp
operator|->
name|am_name
argument_list|,
name|expanded_fname
argument_list|)
condition|)
block|{
if|if
condition|(
name|new_mp
operator|->
name|am_error
condition|)
block|{
name|error
operator|=
name|new_mp
operator|->
name|am_error
expr_stmt|;
continue|continue;
block|}
comment|/*        * If the error code is undefined then it must be        * in progress.        */
name|mf
operator|=
name|new_mp
operator|->
name|am_mnt
expr_stmt|;
if|if
condition|(
name|mf
operator|->
name|mf_error
operator|<
literal|0
condition|)
goto|goto
name|in_progrss
goto|;
comment|/*        * If there was a previous error with this node        * then return that error code.        */
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_ERROR
condition|)
block|{
name|error
operator|=
name|mf
operator|->
name|mf_error
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_MOUNTED
operator|)
operator|||
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_UNMOUNTING
operator|)
condition|)
block|{
name|in_progrss
label|:
comment|/* 	 * If the fs is not mounted or it is unmounting then there 	 * is a background (un)mount in progress.  In this case 	 * we just drop the RPC request (return nil) and 	 * wait for a retry, by which time the (un)mount may 	 * have completed. 	 */
name|dlog
argument_list|(
literal|"ignoring mount of %s in %s -- %smounting in progress, flags %x"
argument_list|,
name|expanded_fname
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|,
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_UNMOUNTING
operator|)
condition|?
literal|"un"
else|:
literal|""
argument_list|,
name|mf
operator|->
name|mf_flags
argument_list|)
expr_stmt|;
name|in_progress
operator|++
expr_stmt|;
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_UNMOUNTING
condition|)
block|{
name|dlog
argument_list|(
literal|"will remount later"
argument_list|)
expr_stmt|;
name|new_mp
operator|->
name|am_flags
operator||=
name|AMF_REMOUNT
expr_stmt|;
block|}
continue|continue;
block|}
comment|/*        * Otherwise we have a hit: return the current mount point.        */
name|dlog
argument_list|(
literal|"matched %s in %s"
argument_list|,
name|expanded_fname
argument_list|,
name|new_mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|expanded_fname
argument_list|)
expr_stmt|;
return|return
name|new_mp
return|;
block|}
block|}
if|if
condition|(
name|in_progress
condition|)
block|{
name|dlog
argument_list|(
literal|"Waiting while %d mount(s) in progress"
argument_list|,
name|in_progress
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|expanded_fname
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*    * If an error occurred then return it.    */
if|if
condition|(
name|error
condition|)
block|{
name|dlog
argument_list|(
literal|"Returning error: %s"
argument_list|,
name|strerror
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|expanded_fname
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
comment|/*    * If the server is going down then just return,    * don't try to mount any more file systems    */
if|if
condition|(
operator|(
name|int
operator|)
name|amd_state
operator|>=
operator|(
name|int
operator|)
name|Finishing
condition|)
block|{
name|dlog
argument_list|(
literal|"not found - server going down anyway"
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
block|}
comment|/*    * Allocate a new map    */
name|new_mp
operator|=
name|get_ap_child
argument_list|(
name|mp
argument_list|,
name|expanded_fname
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|expanded_fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_mp
operator|==
literal|0
condition|)
name|ereturn
argument_list|(
name|ENOSPC
argument_list|)
expr_stmt|;
operator|*
name|error_return
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|new_mp
return|;
block|}
end_function

begin_function
specifier|static
name|mntfs
modifier|*
name|amfs_lookup_one_mntfs
parameter_list|(
name|am_node
modifier|*
name|new_mp
parameter_list|,
name|mntfs
modifier|*
name|mf
parameter_list|,
name|char
modifier|*
name|ivec
parameter_list|,
name|char
modifier|*
name|def_opts
parameter_list|,
name|char
modifier|*
name|pfname
parameter_list|)
block|{
name|am_ops
modifier|*
name|p
decl_stmt|;
name|am_opts
modifier|*
name|fs_opts
decl_stmt|;
name|mntfs
modifier|*
name|new_mf
decl_stmt|;
name|char
modifier|*
name|mp_dir
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FS_AUTOFS
name|int
name|on_autofs
init|=
literal|1
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_FS_AUTOFS */
comment|/* match the operators */
name|fs_opts
operator|=
name|CALLOC
argument_list|(
name|am_opts
argument_list|)
expr_stmt|;
name|p
operator|=
name|ops_match
argument_list|(
name|fs_opts
argument_list|,
name|ivec
argument_list|,
name|def_opts
argument_list|,
name|new_mp
operator|->
name|am_path
argument_list|,
name|pfname
argument_list|,
name|mf
operator|->
name|mf_info
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FS_AUTOFS
comment|/* XXX: this should be factored out into an autofs-specific function */
if|if
condition|(
name|new_mp
operator|->
name|am_flags
operator|&
name|AMF_AUTOFS
condition|)
block|{
comment|/* ignore user-provided fs if we're using autofs */
if|if
condition|(
name|fs_opts
operator|->
name|opt_sublink
condition|)
block|{
comment|/*        * For sublinks we need to use a hack with autofs:        * mount the filesystem on the original opt_fs (which is NOT an        * autofs mountpoint) and symlink (or lofs-mount) to it from        * the autofs mountpoint.        */
name|on_autofs
operator|=
literal|0
expr_stmt|;
name|mp_dir
operator|=
name|fs_opts
operator|->
name|opt_fs
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|->
name|autofs_fs_flags
operator|&
name|FS_ON_AUTOFS
condition|)
block|{
name|mp_dir
operator|=
name|new_mp
operator|->
name|am_path
expr_stmt|;
block|}
else|else
block|{
name|mp_dir
operator|=
name|fs_opts
operator|->
name|opt_fs
expr_stmt|;
name|on_autofs
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
endif|#
directive|endif
comment|/* HAVE_FS_AUTOFS */
name|mp_dir
operator|=
name|fs_opts
operator|->
name|opt_fs
expr_stmt|;
comment|/*    * Find or allocate a filesystem for this node.    */
name|new_mf
operator|=
name|find_mntfs
argument_list|(
name|p
argument_list|,
name|fs_opts
argument_list|,
name|mp_dir
argument_list|,
name|fs_opts
operator|->
name|fs_mtab
argument_list|,
name|def_opts
argument_list|,
name|fs_opts
operator|->
name|opt_opts
argument_list|,
name|fs_opts
operator|->
name|opt_remopts
argument_list|)
expr_stmt|;
comment|/*    * See whether this is a real filesystem    */
name|p
operator|=
name|new_mf
operator|->
name|mf_ops
expr_stmt|;
if|if
condition|(
name|p
operator|==
operator|&
name|amfs_error_ops
condition|)
block|{
name|plog
argument_list|(
name|XLOG_MAP
argument_list|,
literal|"Map entry %s for %s did not match"
argument_list|,
name|ivec
argument_list|,
name|new_mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
name|free_mntfs
argument_list|(
name|new_mf
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|dlog
argument_list|(
literal|"Got a hit with %s"
argument_list|,
name|p
operator|->
name|fs_type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FS_AUTOFS
if|if
condition|(
name|new_mp
operator|->
name|am_flags
operator|&
name|AMF_AUTOFS
operator|&&
name|on_autofs
condition|)
block|{
name|new_mf
operator|->
name|mf_flags
operator||=
name|MFF_ON_AUTOFS
expr_stmt|;
name|new_mf
operator|->
name|mf_fsflags
operator|=
name|new_mf
operator|->
name|mf_ops
operator|->
name|autofs_fs_flags
expr_stmt|;
block|}
comment|/*    * A new filesystem is an autofs filesystems if:    * 1. it claims it can be one (has the FS_AUTOFS flag)    * 2. autofs is enabled system-wide    * 3. either has an autofs parent,    *    or it is explicitly requested to be autofs.    */
if|if
condition|(
name|new_mf
operator|->
name|mf_ops
operator|->
name|autofs_fs_flags
operator|&
name|FS_AUTOFS
operator|&&
name|amd_use_autofs
operator|&&
operator|(
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_IS_AUTOFS
operator|)
operator|||
operator|(
name|new_mf
operator|->
name|mf_fo
operator|&&
name|new_mf
operator|->
name|mf_fo
operator|->
name|opt_mount_type
operator|&&
name|STREQ
argument_list|(
name|new_mf
operator|->
name|mf_fo
operator|->
name|opt_mount_type
argument_list|,
literal|"autofs"
argument_list|)
operator|)
operator|)
condition|)
name|new_mf
operator|->
name|mf_flags
operator||=
name|MFF_IS_AUTOFS
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_FS_AUTOFS */
return|return
name|new_mf
return|;
block|}
end_function

begin_function
specifier|static
name|mntfs
modifier|*
modifier|*
name|amfs_lookup_mntfs
parameter_list|(
name|am_node
modifier|*
name|new_mp
parameter_list|,
name|int
modifier|*
name|error_return
parameter_list|)
block|{
name|am_node
modifier|*
name|mp
decl_stmt|;
name|char
modifier|*
name|info
decl_stmt|;
comment|/* Mount info - where to get the file system */
name|char
modifier|*
modifier|*
name|ivecs
decl_stmt|,
modifier|*
modifier|*
name|cur_ivec
decl_stmt|;
comment|/* Split version of info */
name|int
name|num_ivecs
decl_stmt|;
name|char
modifier|*
name|orig_def_opts
decl_stmt|;
comment|/* Original Automount options */
name|char
modifier|*
name|def_opts
decl_stmt|;
comment|/* Automount options */
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Error so far */
name|char
name|path_name
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
comment|/* General path name buffer */
name|char
modifier|*
name|pfname
decl_stmt|;
comment|/* Path for database lookup */
name|mntfs
modifier|*
name|mf
decl_stmt|,
modifier|*
modifier|*
name|mf_array
decl_stmt|;
name|int
name|count
decl_stmt|;
name|dlog
argument_list|(
literal|"in amfs_lookup_mntfs"
argument_list|)
expr_stmt|;
name|mp
operator|=
name|new_mp
operator|->
name|am_parent
expr_stmt|;
comment|/*    * If we get here then this is a reference to an,    * as yet, unknown name so we need to search the mount    * map for it.    */
if|if
condition|(
name|mp
operator|->
name|am_pref
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|mp
operator|->
name|am_pref
argument_list|)
operator|+
name|strlen
argument_list|(
name|new_mp
operator|->
name|am_name
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|path_name
argument_list|)
condition|)
name|ereturn
argument_list|(
name|ENAMETOOLONG
argument_list|)
expr_stmt|;
name|xsnprintf
argument_list|(
name|path_name
argument_list|,
sizeof|sizeof
argument_list|(
name|path_name
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|mp
operator|->
name|am_pref
argument_list|,
name|new_mp
operator|->
name|am_name
argument_list|)
expr_stmt|;
name|pfname
operator|=
name|path_name
expr_stmt|;
block|}
else|else
block|{
name|pfname
operator|=
name|new_mp
operator|->
name|am_name
expr_stmt|;
block|}
name|mf
operator|=
name|mp
operator|->
name|am_mnt
expr_stmt|;
name|dlog
argument_list|(
literal|"will search map info in %s to find %s"
argument_list|,
name|mf
operator|->
name|mf_info
argument_list|,
name|pfname
argument_list|)
expr_stmt|;
comment|/*    * Consult the oracle for some mount information.    * info is malloc'ed and belongs to this routine.    * It ends up being free'd in free_continuation().    *    * Note that this may return -1 indicating that information    * is not yet available.    */
name|error
operator|=
name|mapc_search
argument_list|(
operator|(
name|mnt_map
operator|*
operator|)
name|mf
operator|->
name|mf_private
argument_list|,
name|pfname
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|>
literal|0
condition|)
name|plog
argument_list|(
name|XLOG_MAP
argument_list|,
literal|"No map entry for %s"
argument_list|,
name|pfname
argument_list|)
expr_stmt|;
else|else
name|plog
argument_list|(
name|XLOG_MAP
argument_list|,
literal|"Waiting on map entry for %s"
argument_list|,
name|pfname
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
name|dlog
argument_list|(
literal|"mount info is %s"
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/*    * Split info into an argument vector.    * The vector is malloc'ed and belongs to    * this routine.  It is free'd further down.    *    * Note: the vector pointers point into info, so don't free it!    */
name|ivecs
operator|=
name|strsplit
argument_list|(
name|info
argument_list|,
literal|' '
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
if|if
condition|(
name|mf
operator|->
name|mf_auto
condition|)
name|def_opts
operator|=
name|mf
operator|->
name|mf_auto
expr_stmt|;
else|else
name|def_opts
operator|=
literal|""
expr_stmt|;
name|orig_def_opts
operator|=
name|amfs_parse_defaults
argument_list|(
name|mp
argument_list|,
name|mf
argument_list|,
name|strdup
argument_list|(
name|def_opts
argument_list|)
argument_list|)
expr_stmt|;
name|def_opts
operator|=
name|strdup
argument_list|(
name|orig_def_opts
argument_list|)
expr_stmt|;
comment|/* first build our defaults */
name|num_ivecs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cur_ivec
operator|=
name|ivecs
init|;
operator|*
name|cur_ivec
condition|;
name|cur_ivec
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|*
name|cur_ivec
operator|==
literal|'-'
condition|)
block|{
comment|/*        * Pick up new defaults        */
name|char
modifier|*
name|new_def_opts
init|=
name|str3cat
argument_list|(
name|NULL
argument_list|,
name|def_opts
argument_list|,
literal|";"
argument_list|,
operator|*
name|cur_ivec
operator|+
literal|1
argument_list|)
decl_stmt|;
name|XFREE
argument_list|(
name|def_opts
argument_list|)
expr_stmt|;
name|def_opts
operator|=
name|new_def_opts
expr_stmt|;
name|dlog
argument_list|(
literal|"Setting def_opts to \"%s\""
argument_list|,
name|def_opts
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
name|num_ivecs
operator|++
expr_stmt|;
block|}
name|mf_array
operator|=
name|calloc
argument_list|(
name|num_ivecs
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|mntfs
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* construct the array of struct mntfs for this mount point */
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|cur_ivec
operator|=
name|ivecs
init|;
operator|*
name|cur_ivec
condition|;
name|cur_ivec
operator|++
control|)
block|{
name|mntfs
modifier|*
name|new_mf
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|cur_ivec
operator|==
literal|'-'
condition|)
block|{
name|XFREE
argument_list|(
name|def_opts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cur_ivec
operator|)
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* 	 * If we have a single dash '-' than we need to reset the 	 * default options. 	 */
name|def_opts
operator|=
name|strdup
argument_list|(
name|orig_def_opts
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
literal|"Resetting the default options, a single dash '-' was found."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* append options to /default options */
name|def_opts
operator|=
name|str3cat
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|orig_def_opts
argument_list|,
literal|";"
argument_list|,
operator|*
name|cur_ivec
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
literal|"Resetting def_opts to \"%s\""
argument_list|,
name|def_opts
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/*      * If a mntfs has already been found, and we find      * a cut then don't try any more locations.      *      * XXX: we do not know when the "/" was added as an equivalent for "||".      * It's undocumented, it might go away at any time. Caveat emptor.      */
if|if
condition|(
name|STREQ
argument_list|(
operator|*
name|cur_ivec
argument_list|,
literal|"/"
argument_list|)
operator|||
name|STREQ
argument_list|(
operator|*
name|cur_ivec
argument_list|,
literal|"||"
argument_list|)
condition|)
block|{
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|dlog
argument_list|(
literal|"Cut: not trying any more locations for %s"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
name|new_mf
operator|=
name|amfs_lookup_one_mntfs
argument_list|(
name|new_mp
argument_list|,
name|mf
argument_list|,
operator|*
name|cur_ivec
argument_list|,
name|def_opts
argument_list|,
name|pfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_mf
operator|==
name|NULL
condition|)
continue|continue;
name|mf_array
index|[
name|count
operator|++
index|]
operator|=
name|new_mf
expr_stmt|;
block|}
comment|/* We're done with ivecs */
name|XFREE
argument_list|(
name|ivecs
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|orig_def_opts
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|def_opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|/* no match */
name|XFREE
argument_list|(
name|mf_array
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
block|}
return|return
name|mf_array
return|;
block|}
end_function

begin_comment
comment|/*  * The continuation function.  This is called by  * the task notifier when a background mount attempt  * completes.  */
end_comment

begin_function
specifier|static
name|void
name|amfs_cont
parameter_list|(
name|int
name|rc
parameter_list|,
name|int
name|term
parameter_list|,
name|opaque_t
name|arg
parameter_list|)
block|{
name|struct
name|continuation
modifier|*
name|cp
init|=
operator|(
expr|struct
name|continuation
operator|*
operator|)
name|arg
decl_stmt|;
name|am_node
modifier|*
name|mp
init|=
name|cp
operator|->
name|mp
decl_stmt|;
name|mntfs
modifier|*
name|mf
init|=
name|mp
operator|->
name|am_mnt
decl_stmt|;
name|dlog
argument_list|(
literal|"amfs_cont: '%s'"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
comment|/*    * Definitely not trying to mount at the moment    */
name|mf
operator|->
name|mf_flags
operator|&=
operator|~
name|MFF_MOUNTING
expr_stmt|;
comment|/*    * While we are mounting - try to avoid race conditions    */
name|new_ttl
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/*    * Wakeup anything waiting for this mount    */
name|wakeup
argument_list|(
name|get_mntfs_wchan
argument_list|(
name|mf
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    * Check for termination signal or exit status...    */
if|if
condition|(
name|rc
operator|||
name|term
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_FS_AUTOFS
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_IS_AUTOFS
operator|&&
operator|!
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_MOUNTED
operator|)
condition|)
name|autofs_release_fh
argument_list|(
name|mp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_FS_AUTOFS */
if|if
condition|(
name|term
condition|)
block|{
comment|/*        * Not sure what to do for an error code.        */
name|mf
operator|->
name|mf_error
operator|=
name|EIO
expr_stmt|;
comment|/* XXX ? */
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_ERROR
expr_stmt|;
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"mount for %s got signal %d"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|term
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*        * Check for exit status...        */
ifdef|#
directive|ifdef
name|__linux__
comment|/*        * HACK ALERT!        *        * On Linux (and maybe not only) it's possible to run        * an amd which "knows" how to mount certain combinations        * of nfs_proto/nfs_version which the kernel doesn't grok.        * So if we got an EINVAL and we have a server that's not        * using NFSv2/UDP, try again with NFSv2/UDP.        *        * Too bad that there is no way to dynamically determine        * what combinations the _client_ supports, as opposed to        * what the _server_ supports...        */
if|if
condition|(
name|rc
operator|==
name|EINVAL
operator|&&
name|mf
operator|->
name|mf_server
operator|&&
operator|(
name|mf
operator|->
name|mf_server
operator|->
name|fs_version
operator|!=
literal|2
operator|||
operator|!
name|STREQ
argument_list|(
name|mf
operator|->
name|mf_server
operator|->
name|fs_proto
argument_list|,
literal|"udp"
argument_list|)
operator|)
condition|)
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_NFS_SCALEDOWN
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* __linux__ */
block|{
name|mf
operator|->
name|mf_error
operator|=
name|rc
expr_stmt|;
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_ERROR
expr_stmt|;
name|errno
operator|=
name|rc
expr_stmt|;
comment|/* XXX */
if|if
condition|(
operator|!
name|STREQ
argument_list|(
name|mp
operator|->
name|am_mnt
operator|->
name|mf_ops
operator|->
name|fs_type
argument_list|,
literal|"linkx"
argument_list|)
condition|)
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"%s: mount (amfs_cont): %m"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_NFS_SCALEDOWN
operator|)
condition|)
block|{
comment|/*        * If we get here then that attempt didn't work, so        * move the info vector pointer along by one and        * call the background mount routine again        */
name|amd_stats
operator|.
name|d_merr
operator|++
expr_stmt|;
name|cp
operator|->
name|mf
operator|++
expr_stmt|;
block|}
name|amfs_bgmount
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_error
operator|>
literal|0
condition|)
name|assign_error_mntfs
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*      * The mount worked.      */
name|dlog
argument_list|(
literal|"Mounting %s returned success"
argument_list|,
name|cp
operator|->
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
name|am_mounted
argument_list|(
name|cp
operator|->
name|mp
argument_list|)
expr_stmt|;
name|free_continuation
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|reschedule_timeout_mp
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Retry a mount  */
end_comment

begin_function
specifier|static
name|void
name|amfs_retry
parameter_list|(
name|int
name|rc
parameter_list|,
name|int
name|term
parameter_list|,
name|opaque_t
name|arg
parameter_list|)
block|{
name|struct
name|continuation
modifier|*
name|cp
init|=
operator|(
expr|struct
name|continuation
operator|*
operator|)
name|arg
decl_stmt|;
name|am_node
modifier|*
name|mp
init|=
name|cp
operator|->
name|mp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|dlog
argument_list|(
literal|"Commencing retry for mount of %s"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
name|new_ttl
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|->
name|start
operator|+
name|ALLOWED_MOUNT_TIME
operator|)
operator|<
name|clocktime
argument_list|(
name|NULL
argument_list|)
condition|)
block|{
comment|/*      * The entire mount has timed out.  Set the error code and skip past all      * the mntfs's so that amfs_bgmount will not have any more      * ways to try the mount, thus causing an error.      */
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"mount of \"%s\" has timed out"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|->
name|mf
condition|)
name|cp
operator|->
name|mf
operator|++
expr_stmt|;
comment|/* explicitly forbid further retries after timeout */
name|cp
operator|->
name|retry
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|||
operator|!
name|IN_PROGRESS
argument_list|(
name|cp
argument_list|)
condition|)
name|error
operator|=
name|amfs_bgmount
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|reschedule_timeout_mp
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Discard an old continuation  */
end_comment

begin_function
specifier|static
name|void
name|free_continuation
parameter_list|(
name|struct
name|continuation
modifier|*
name|cp
parameter_list|)
block|{
name|mntfs
modifier|*
modifier|*
name|mfp
decl_stmt|;
name|dlog
argument_list|(
literal|"free_continuation"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|callout
condition|)
name|untimeout
argument_list|(
name|cp
operator|->
name|callout
argument_list|)
expr_stmt|;
comment|/*    * we must free the mntfs's in the list.    * so free all of them if there was an error,    * or free all but the used one, if the mount succeeded.    */
for|for
control|(
name|mfp
operator|=
name|cp
operator|->
name|mp
operator|->
name|am_mfarray
init|;
operator|*
name|mfp
condition|;
name|mfp
operator|++
control|)
block|{
name|free_mntfs
argument_list|(
operator|*
name|mfp
argument_list|)
expr_stmt|;
block|}
name|XFREE
argument_list|(
name|cp
operator|->
name|mp
operator|->
name|am_mfarray
argument_list|)
expr_stmt|;
name|cp
operator|->
name|mp
operator|->
name|am_mfarray
operator|=
literal|0
expr_stmt|;
name|XFREE
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Pick a file system to try mounting and  * do that in the background if necessary  * For each location: 	discard previous mount location if required 	fetch next mount location 	if the filesystem failed to be mounted then 		this_error = error from filesystem 		goto failed 	if the filesystem is mounting or unmounting then 		goto retry; 	if the fileserver is down then 		this_error = EIO 		continue; 	if the filesystem is already mounted 		break 	fi  	this_error = initialize mount point  	if no error on this mount and mount is delayed then 		this_error = -1 	fi 	if this_error< 0 then 		retry = true 	fi 	if no error on this mount then 		if mount in background then 			run mount in background 			return -1 		else 			this_error = mount in foreground 		fi 	fi 	if an error occurred on this mount then 		update stats 		save error in mount point 	fi endfor  */
end_comment

begin_function
specifier|static
name|int
name|amfs_bgmount
parameter_list|(
name|struct
name|continuation
modifier|*
name|cp
parameter_list|)
block|{
name|am_node
modifier|*
name|mp
init|=
name|cp
operator|->
name|mp
decl_stmt|;
name|mntfs
modifier|*
name|mf
decl_stmt|;
comment|/* Current mntfs */
name|int
name|this_error
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Per-mount error */
name|int
name|hard_error
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Cumulative per-node error */
if|if
condition|(
name|mp
operator|->
name|am_mnt
condition|)
name|free_mntfs
argument_list|(
name|mp
operator|->
name|am_mnt
argument_list|)
expr_stmt|;
comment|/*    * Try to mount each location.    * At the end:    * hard_error == 0 indicates something was mounted.    * hard_error> 0 indicates everything failed with a hard error    * hard_error< 0 indicates nothing could be mounted now    */
for|for
control|(
name|mp
operator|->
name|am_mnt
operator|=
operator|*
name|cp
operator|->
name|mf
init|;
operator|*
name|cp
operator|->
name|mf
condition|;
name|cp
operator|->
name|mf
operator|++
operator|,
name|mp
operator|->
name|am_mnt
operator|=
operator|*
name|cp
operator|->
name|mf
control|)
block|{
name|am_ops
modifier|*
name|p
decl_stmt|;
name|mf
operator|=
name|dup_mntfs
argument_list|(
name|mp
operator|->
name|am_mnt
argument_list|)
expr_stmt|;
name|p
operator|=
name|mf
operator|->
name|mf_ops
expr_stmt|;
if|if
condition|(
name|hard_error
operator|<
literal|0
condition|)
name|hard_error
operator|=
name|this_error
expr_stmt|;
name|this_error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mf
operator|->
name|mf_error
operator|>
literal|0
condition|)
block|{
name|this_error
operator|=
name|mf
operator|->
name|mf_error
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
operator|(
name|MFF_MOUNTING
operator||
name|MFF_UNMOUNTING
operator|)
condition|)
block|{
comment|/*        * Still mounting - retry later        */
name|dlog
argument_list|(
literal|"mount of \"%s\" already pending"
argument_list|,
name|mf
operator|->
name|mf_info
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
if|if
condition|(
name|FSRV_ISDOWN
argument_list|(
name|mf
operator|->
name|mf_server
argument_list|)
condition|)
block|{
comment|/*        * Would just mount from the same place        * as a hung mount - so give up        */
name|dlog
argument_list|(
literal|"%s is already hung - giving up"
argument_list|,
name|mf
operator|->
name|mf_server
operator|->
name|fs_host
argument_list|)
expr_stmt|;
name|this_error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
if|if
condition|(
name|mp
operator|->
name|am_link
condition|)
block|{
name|XFREE
argument_list|(
name|mp
operator|->
name|am_link
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_link
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mf
operator|->
name|mf_fo
operator|&&
name|mf
operator|->
name|mf_fo
operator|->
name|opt_sublink
condition|)
name|mp
operator|->
name|am_link
operator|=
name|strdup
argument_list|(
name|mf
operator|->
name|mf_fo
operator|->
name|opt_sublink
argument_list|)
expr_stmt|;
comment|/*      * Will usually need to play around with the mount nodes      * file attribute structure.  This must be done here.      * Try and get things initialized, even if the fileserver      * is not known to be up.  In the common case this will      * progress things faster.      */
comment|/*      * Fill in attribute fields.      */
if|if
condition|(
name|mf
operator|->
name|mf_fsflags
operator|&
name|FS_DIRECTORY
condition|)
name|mk_fattr
argument_list|(
operator|&
name|mp
operator|->
name|am_fattr
argument_list|,
name|NFDIR
argument_list|)
expr_stmt|;
else|else
name|mk_fattr
argument_list|(
operator|&
name|mp
operator|->
name|am_fattr
argument_list|,
name|NFLNK
argument_list|)
expr_stmt|;
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_MOUNTED
condition|)
block|{
name|dlog
argument_list|(
literal|"duplicate mount of \"%s\" ..."
argument_list|,
name|mf
operator|->
name|mf_info
argument_list|)
expr_stmt|;
comment|/*        * Skip initial processing of the mountpoint if already mounted.        * This could happen if we have multiple sublinks into the same f/s,        * or if we are restarting an already-mounted filesystem.        */
goto|goto
name|already_mounted
goto|;
block|}
if|if
condition|(
name|mf
operator|->
name|mf_fo
operator|&&
name|mf
operator|->
name|mf_fo
operator|->
name|fs_mtab
condition|)
block|{
name|plog
argument_list|(
name|XLOG_MAP
argument_list|,
literal|"Trying mount of %s on %s fstype %s mount_type %s"
argument_list|,
name|mf
operator|->
name|mf_fo
operator|->
name|fs_mtab
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|,
name|p
operator|->
name|fs_type
argument_list|,
name|mp
operator|->
name|am_flags
operator|&
name|AMF_AUTOFS
condition|?
literal|"autofs"
else|:
literal|"non-autofs"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|fs_init
operator|&&
operator|!
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_RESTART
operator|)
condition|)
name|this_error
operator|=
name|p
operator|->
name|fs_init
argument_list|(
name|mf
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_error
operator|>
literal|0
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|this_error
operator|<
literal|0
condition|)
goto|goto
name|retry
goto|;
if|if
condition|(
name|mf
operator|->
name|mf_fo
operator|&&
name|mf
operator|->
name|mf_fo
operator|->
name|opt_delay
condition|)
block|{
comment|/*        * If there is a delay timer on the mount        * then don't try to mount if the timer        * has not expired.        */
name|int
name|i
init|=
name|atoi
argument_list|(
name|mf
operator|->
name|mf_fo
operator|->
name|opt_delay
argument_list|)
decl_stmt|;
name|time_t
name|now
init|=
name|clocktime
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|now
operator|<
operator|(
name|cp
operator|->
name|start
operator|+
name|i
operator|)
condition|)
block|{
name|dlog
argument_list|(
literal|"Mount of %s delayed by %lds"
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|,
call|(
name|long
call|)
argument_list|(
name|i
operator|-
name|now
operator|+
name|cp
operator|->
name|start
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
comment|/*      * If the directory is not yet made and it needs to be made, then make it!      */
if|if
condition|(
operator|!
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_MKMNT
operator|)
operator|&&
name|mf
operator|->
name|mf_fsflags
operator|&
name|FS_MKMNT
condition|)
block|{
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"creating mountpoint directory '%s'"
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
name|this_error
operator|=
name|mkdirs
argument_list|(
name|mf
operator|->
name|mf_mount
argument_list|,
literal|0555
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_error
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"mkdirs failed: %s"
argument_list|,
name|strerror
argument_list|(
name|this_error
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_MKMNT
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_FS_AUTOFS
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_IS_AUTOFS
condition|)
if|if
condition|(
operator|(
name|this_error
operator|=
name|autofs_get_fh
argument_list|(
name|mp
argument_list|)
operator|)
condition|)
goto|goto
name|failed
goto|;
endif|#
directive|endif
comment|/* HAVE_FS_AUTOFS */
name|already_mounted
label|:
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_MOUNTING
expr_stmt|;
if|if
condition|(
name|mf
operator|->
name|mf_fsflags
operator|&
name|FS_MBACKGROUND
condition|)
block|{
name|dlog
argument_list|(
literal|"backgrounding mount of \"%s\""
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|callout
condition|)
block|{
name|untimeout
argument_list|(
name|cp
operator|->
name|callout
argument_list|)
expr_stmt|;
name|cp
operator|->
name|callout
operator|=
literal|0
expr_stmt|;
block|}
comment|/* actually run the task, backgrounding as necessary */
name|run_task
argument_list|(
name|mount_node
argument_list|,
operator|(
name|opaque_t
operator|)
name|mp
argument_list|,
name|amfs_cont
argument_list|,
operator|(
name|opaque_t
operator|)
name|cp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|dlog
argument_list|(
literal|"foreground mount of \"%s\" ..."
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
name|this_error
operator|=
name|mount_node
argument_list|(
operator|(
name|opaque_t
operator|)
name|mp
argument_list|)
expr_stmt|;
block|}
name|mf
operator|->
name|mf_flags
operator|&=
operator|~
name|MFF_MOUNTING
expr_stmt|;
if|if
condition|(
name|this_error
operator|>
literal|0
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|this_error
operator|==
literal|0
condition|)
block|{
name|am_mounted
argument_list|(
name|mp
argument_list|)
expr_stmt|;
break|break;
comment|/* Success */
block|}
name|retry
label|:
if|if
condition|(
operator|!
name|cp
operator|->
name|retry
condition|)
continue|continue;
name|dlog
argument_list|(
literal|"will retry ...\n"
argument_list|)
expr_stmt|;
comment|/*      * Arrange that amfs_bgmount is called      * after anything else happens.      */
name|dlog
argument_list|(
literal|"Arranging to retry mount of %s"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
name|sched_task
argument_list|(
name|amfs_retry
argument_list|,
operator|(
name|opaque_t
operator|)
name|cp
argument_list|,
name|get_mntfs_wchan
argument_list|(
name|mf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|callout
condition|)
name|untimeout
argument_list|(
name|cp
operator|->
name|callout
argument_list|)
expr_stmt|;
name|cp
operator|->
name|callout
operator|=
name|timeout
argument_list|(
name|RETRY_INTERVAL
argument_list|,
name|wakeup
argument_list|,
operator|(
name|opaque_t
operator|)
name|get_mntfs_wchan
argument_list|(
name|mf
argument_list|)
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_ttl
operator|=
name|clocktime
argument_list|(
name|NULL
argument_list|)
operator|+
name|RETRY_INTERVAL
expr_stmt|;
comment|/*      * Not done yet - so don't return anything      */
return|return
operator|-
literal|1
return|;
name|failed
label|:
name|amd_stats
operator|.
name|d_merr
operator|++
expr_stmt|;
name|mf
operator|->
name|mf_error
operator|=
name|this_error
expr_stmt|;
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_ERROR
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FS_AUTOFS
if|if
condition|(
name|mp
operator|->
name|am_autofs_fh
condition|)
name|autofs_release_fh
argument_list|(
name|mp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_FS_AUTOFS */
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_MKMNT
condition|)
block|{
name|rmdirs
argument_list|(
name|mf
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
name|mf
operator|->
name|mf_flags
operator|&=
operator|~
name|MFF_MKMNT
expr_stmt|;
block|}
comment|/*      * Wakeup anything waiting for this mount      */
name|wakeup
argument_list|(
name|get_mntfs_wchan
argument_list|(
name|mf
argument_list|)
argument_list|)
expr_stmt|;
name|free_mntfs
argument_list|(
name|mf
argument_list|)
expr_stmt|;
comment|/* continue */
block|}
comment|/*    * If we get here, then either the mount succeeded or    * there is no more mount information available.    */
if|if
condition|(
name|this_error
condition|)
block|{
name|mp
operator|->
name|am_mnt
operator|=
name|mf
operator|=
name|new_mntfs
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FS_AUTOFS
if|if
condition|(
name|mp
operator|->
name|am_flags
operator|&
name|AMF_AUTOFS
condition|)
name|autofs_mount_failed
argument_list|(
name|mp
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* HAVE_FS_AUTOFS */
name|nfs_quick_reply
argument_list|(
name|mp
argument_list|,
name|this_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|hard_error
operator|<=
literal|0
condition|)
name|hard_error
operator|=
name|this_error
expr_stmt|;
if|if
condition|(
name|hard_error
operator|<
literal|0
condition|)
name|hard_error
operator|=
name|ETIMEDOUT
expr_stmt|;
comment|/*      * Set a small(ish) timeout on an error node if      * the error was not a time out.      */
switch|switch
condition|(
name|hard_error
condition|)
block|{
case|case
name|ETIMEDOUT
case|:
case|case
name|EWOULDBLOCK
case|:
case|case
name|EIO
case|:
name|mp
operator|->
name|am_timeo
operator|=
literal|17
expr_stmt|;
break|break;
default|default:
name|mp
operator|->
name|am_timeo
operator|=
literal|5
expr_stmt|;
break|break;
block|}
name|new_ttl
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mf
operator|=
name|mp
operator|->
name|am_mnt
expr_stmt|;
comment|/*      * Wakeup anything waiting for this mount      */
name|wakeup
argument_list|(
name|get_mntfs_wchan
argument_list|(
name|mf
argument_list|)
argument_list|)
expr_stmt|;
name|hard_error
operator|=
literal|0
expr_stmt|;
block|}
comment|/*    * Make sure that the error value in the mntfs has a    * reasonable value.    */
if|if
condition|(
name|mf
operator|->
name|mf_error
operator|<
literal|0
condition|)
block|{
name|mf
operator|->
name|mf_error
operator|=
name|hard_error
expr_stmt|;
if|if
condition|(
name|hard_error
condition|)
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_ERROR
expr_stmt|;
block|}
comment|/*    * In any case we don't need the continuation any more    */
name|free_continuation
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
name|hard_error
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|amfs_parse_defaults
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|,
name|mntfs
modifier|*
name|mf
parameter_list|,
name|char
modifier|*
name|def_opts
parameter_list|)
block|{
name|char
modifier|*
name|dflts
decl_stmt|;
name|char
modifier|*
name|dfl
decl_stmt|;
name|char
modifier|*
modifier|*
name|rvec
init|=
name|NULL
decl_stmt|;
name|struct
name|mnt_map
modifier|*
name|mm
init|=
operator|(
name|mnt_map
operator|*
operator|)
name|mf
operator|->
name|mf_private
decl_stmt|;
name|dlog
argument_list|(
literal|"determining /defaults entry value"
argument_list|)
expr_stmt|;
comment|/*    * Find out if amd.conf overrode any map-specific /defaults.    *    * HACK ALERT: there's no easy way to find out what the map mount point is    * at this point, so I am forced to initialize the mnt_map->cfm field here    * for the first time, upon the very first search for a /defaults entry in    * this map.  This initialization is much better done in mapc_create(),    * but it's impossible to do that there with the current code structure.    */
if|if
condition|(
name|mm
operator|->
name|cfm
operator|==
name|NULL
condition|)
block|{
comment|/* then initialize it for first time */
name|mm
operator|->
name|cfm
operator|=
name|find_cf_map
argument_list|(
name|mf
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mm
operator|->
name|cfm
operator|&&
name|mm
operator|->
name|cfm
operator|->
name|cfm_defaults
condition|)
block|{
name|dlog
argument_list|(
literal|"map %s map_defaults override: %s"
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|,
name|mm
operator|->
name|cfm
operator|->
name|cfm_defaults
argument_list|)
expr_stmt|;
name|dflts
operator|=
name|strdup
argument_list|(
name|mm
operator|->
name|cfm
operator|->
name|cfm_defaults
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mapc_search
argument_list|(
name|mm
argument_list|,
literal|"/defaults"
argument_list|,
operator|&
name|dflts
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dlog
argument_list|(
literal|"/defaults gave %s"
argument_list|,
name|dflts
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|def_opts
return|;
comment|/* if nothing found */
block|}
comment|/* trim leading '-' in case thee's one */
if|if
condition|(
operator|*
name|dflts
operator|==
literal|'-'
condition|)
name|dfl
operator|=
name|dflts
operator|+
literal|1
expr_stmt|;
else|else
name|dfl
operator|=
name|dflts
expr_stmt|;
comment|/*    * Chop the defaults up    */
name|rvec
operator|=
name|strsplit
argument_list|(
name|dfl
argument_list|,
literal|' '
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
if|if
condition|(
name|gopt
operator|.
name|flags
operator|&
name|CFM_SELECTORS_IN_DEFAULTS
condition|)
block|{
comment|/*      * Pick whichever first entry matched the list of selectors.      * Strip the selectors from the string, and assign to dfl the      * rest of the string.      */
if|if
condition|(
name|rvec
condition|)
block|{
name|am_opts
name|ap
decl_stmt|;
name|am_ops
modifier|*
name|pt
decl_stmt|;
name|char
modifier|*
modifier|*
name|sp
init|=
name|rvec
decl_stmt|;
while|while
condition|(
operator|*
name|sp
condition|)
block|{
comment|/* loop until you find something, if any */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|am_opts
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * This next routine cause many spurious "expansion of ... is" 	 * messages, which are ignored, b/c all we need out of this 	 * routine is to match selectors.  These spurious messages may 	 * be wrong, esp. if they try to expand ${key} b/c it will 	 * get expanded to "/defaults" 	 */
name|pt
operator|=
name|ops_match
argument_list|(
operator|&
name|ap
argument_list|,
operator|*
name|sp
argument_list|,
literal|""
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
literal|"/defaults"
argument_list|,
name|mp
operator|->
name|am_parent
operator|->
name|am_mnt
operator|->
name|mf_info
argument_list|)
expr_stmt|;
name|free_opts
argument_list|(
operator|&
name|ap
argument_list|)
expr_stmt|;
comment|/* don't leak */
if|if
condition|(
name|pt
operator|==
operator|&
name|amfs_error_ops
condition|)
block|{
name|plog
argument_list|(
name|XLOG_MAP
argument_list|,
literal|"did not match defaults for \"%s\""
argument_list|,
operator|*
name|sp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dfl
operator|=
name|strip_selectors
argument_list|(
operator|*
name|sp
argument_list|,
literal|"/defaults"
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_MAP
argument_list|,
literal|"matched default selectors \"%s\""
argument_list|,
name|dfl
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|sp
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* not selectors_in_defaults */
comment|/*      * Extract first value      */
name|dfl
operator|=
name|rvec
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/*    * If there were any values at all...    */
if|if
condition|(
name|dfl
condition|)
block|{
comment|/*      * Log error if there were other values      */
if|if
condition|(
operator|!
operator|(
name|gopt
operator|.
name|flags
operator|&
name|CFM_SELECTORS_IN_DEFAULTS
operator|)
operator|&&
name|rvec
index|[
literal|1
index|]
condition|)
block|{
name|dlog
argument_list|(
literal|"/defaults chopped into %s"
argument_list|,
name|dfl
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_USER
argument_list|,
literal|"More than a single value for /defaults in %s"
argument_list|,
name|mf
operator|->
name|mf_info
argument_list|)
expr_stmt|;
block|}
comment|/*      * Prepend to existing defaults if they exist,      * otherwise just use these defaults.      */
if|if
condition|(
operator|*
name|def_opts
operator|&&
operator|*
name|dfl
condition|)
block|{
name|size_t
name|l
init|=
name|strlen
argument_list|(
name|def_opts
argument_list|)
operator|+
name|strlen
argument_list|(
name|dfl
argument_list|)
operator|+
literal|2
decl_stmt|;
name|char
modifier|*
name|nopts
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|l
argument_list|)
decl_stmt|;
name|xsnprintf
argument_list|(
name|nopts
argument_list|,
name|l
argument_list|,
literal|"%s;%s"
argument_list|,
name|dfl
argument_list|,
name|def_opts
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|def_opts
argument_list|)
expr_stmt|;
name|def_opts
operator|=
name|nopts
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|dfl
condition|)
block|{
name|def_opts
operator|=
name|strealloc
argument_list|(
name|def_opts
argument_list|,
name|dfl
argument_list|)
expr_stmt|;
block|}
block|}
name|XFREE
argument_list|(
name|dflts
argument_list|)
expr_stmt|;
comment|/* don't need info vector any more */
if|if
condition|(
name|rvec
condition|)
name|XFREE
argument_list|(
name|rvec
argument_list|)
expr_stmt|;
return|return
name|def_opts
return|;
block|}
end_function

begin_function
name|am_node
modifier|*
name|amfs_generic_mount_child
parameter_list|(
name|am_node
modifier|*
name|new_mp
parameter_list|,
name|int
modifier|*
name|error_return
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|continuation
modifier|*
name|cp
decl_stmt|;
comment|/* Continuation structure if need to mount */
name|dlog
argument_list|(
literal|"in amfs_generic_mount_child"
argument_list|)
expr_stmt|;
operator|*
name|error_return
operator|=
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Error so far */
comment|/* we have an errorfs attached to the am_node, free it */
name|free_mntfs
argument_list|(
name|new_mp
operator|->
name|am_mnt
argument_list|)
expr_stmt|;
name|new_mp
operator|->
name|am_mnt
operator|=
literal|0
expr_stmt|;
comment|/*    * Construct a continuation    */
name|cp
operator|=
name|ALLOC
argument_list|(
expr|struct
name|continuation
argument_list|)
expr_stmt|;
name|cp
operator|->
name|callout
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|mp
operator|=
name|new_mp
expr_stmt|;
name|cp
operator|->
name|retry
operator|=
name|TRUE
expr_stmt|;
name|cp
operator|->
name|start
operator|=
name|clocktime
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|cp
operator|->
name|mf
operator|=
name|new_mp
operator|->
name|am_mfarray
expr_stmt|;
comment|/*    * Try and mount the file system.  If this succeeds immediately (possible    * for a ufs file system) then return the attributes, otherwise just    * return an error.    */
name|error
operator|=
name|amfs_bgmount
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|reschedule_timeout_mp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
return|return
name|new_mp
return|;
comment|/*    * Code for quick reply.  If current_transp is set, then it's the    * transp that's been passed down from nfs_program_2() or from    * autofs_program_[123]().    * If new_mp->am_transp is not already set, set it by copying in    * current_transp.  Once am_transp is set, nfs_quick_reply() and    * autofs_mount_succeeded() can use it to send a reply to the    * client that requested this mount.    */
if|if
condition|(
name|current_transp
operator|&&
operator|!
name|new_mp
operator|->
name|am_transp
condition|)
block|{
name|dlog
argument_list|(
literal|"Saving RPC transport for %s"
argument_list|,
name|new_mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
name|new_mp
operator|->
name|am_transp
operator|=
operator|(
name|SVCXPRT
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SVCXPRT
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|new_mp
operator|->
name|am_transp
operator|)
operator|=
operator|*
name|current_transp
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|&&
name|new_mp
operator|->
name|am_mnt
operator|&&
operator|(
name|new_mp
operator|->
name|am_mnt
operator|->
name|mf_ops
operator|==
operator|&
name|amfs_error_ops
operator|)
condition|)
name|new_mp
operator|->
name|am_error
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|new_mp
operator|->
name|am_error
operator|>
literal|0
condition|)
name|assign_error_mntfs
argument_list|(
name|new_mp
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Automount interface to RPC lookup routine  * Find the corresponding entry and return  * the file handle for it.  */
end_comment

begin_function
name|am_node
modifier|*
name|amfs_generic_lookup_child
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|,
name|char
modifier|*
name|fname
parameter_list|,
name|int
modifier|*
name|error_return
parameter_list|,
name|int
name|op
parameter_list|)
block|{
name|am_node
modifier|*
name|new_mp
decl_stmt|;
name|mntfs
modifier|*
modifier|*
name|mf_array
decl_stmt|;
name|int
name|mp_error
decl_stmt|;
name|dlog
argument_list|(
literal|"in amfs_generic_lookup_child"
argument_list|)
expr_stmt|;
operator|*
name|error_return
operator|=
literal|0
expr_stmt|;
name|new_mp
operator|=
name|amfs_lookup_node
argument_list|(
name|mp
argument_list|,
name|fname
argument_list|,
name|error_return
argument_list|)
expr_stmt|;
comment|/* return if we got an error */
if|if
condition|(
operator|!
name|new_mp
operator|||
operator|*
name|error_return
operator|>
literal|0
condition|)
return|return
name|new_mp
return|;
comment|/* also return if it's already mounted and known to be up */
if|if
condition|(
operator|*
name|error_return
operator|==
literal|0
operator|&&
name|FSRV_ISUP
argument_list|(
name|new_mp
operator|->
name|am_mnt
operator|->
name|mf_server
argument_list|)
condition|)
return|return
name|new_mp
return|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|VLOOK_DELETE
case|:
comment|/*      * If doing a delete then don't create again!      */
name|ereturn
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
case|case
name|VLOOK_LOOKUP
case|:
return|return
name|new_mp
return|;
block|}
comment|/* save error_return */
name|mp_error
operator|=
operator|*
name|error_return
expr_stmt|;
name|mf_array
operator|=
name|amfs_lookup_mntfs
argument_list|(
name|new_mp
argument_list|,
name|error_return
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mf_array
condition|)
block|{
name|new_mp
operator|->
name|am_error
operator|=
name|new_mp
operator|->
name|am_mnt
operator|->
name|mf_error
operator|=
operator|*
name|error_return
expr_stmt|;
name|free_map
argument_list|(
name|new_mp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*    * Already mounted but known to be down:    * check if we have any alternatives to mount    */
if|if
condition|(
name|mp_error
operator|==
literal|0
condition|)
block|{
name|mntfs
modifier|*
modifier|*
name|mfp
decl_stmt|;
for|for
control|(
name|mfp
operator|=
name|mf_array
init|;
operator|*
name|mfp
condition|;
name|mfp
operator|++
control|)
if|if
condition|(
operator|*
name|mfp
operator|!=
name|new_mp
operator|->
name|am_mnt
condition|)
break|break;
if|if
condition|(
operator|*
name|mfp
operator|!=
name|NULL
condition|)
block|{
comment|/*        * we found an alternative, so try mounting again.        */
operator|*
name|error_return
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|mfp
operator|=
name|mf_array
init|;
operator|*
name|mfp
condition|;
name|mfp
operator|++
control|)
name|free_mntfs
argument_list|(
operator|*
name|mfp
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|mf_array
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_mp
operator|->
name|am_flags
operator|&
name|AMF_SOFTLOOKUP
condition|)
block|{
name|ereturn
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|error_return
operator|=
literal|0
expr_stmt|;
return|return
name|new_mp
return|;
block|}
block|}
block|}
comment|/* store the array inside the am_node */
name|new_mp
operator|->
name|am_mfarray
operator|=
name|mf_array
expr_stmt|;
comment|/*    * Note: while it might seem like a good idea to prioritize    * the list of mntfs's we got here, it probably isn't.    * It would ignore the ordering of entries specified by the user,    * which is counterintuitive and confusing.    */
return|return
name|new_mp
return|;
block|}
end_function

begin_function
name|void
name|amfs_generic_mounted
parameter_list|(
name|mntfs
modifier|*
name|mf
parameter_list|)
block|{
name|amfs_mkcacheref
argument_list|(
name|mf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unmount an automount sub-node  */
end_comment

begin_function
name|int
name|amfs_generic_umount
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|,
name|mntfs
modifier|*
name|mf
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FS_AUTOFS
name|int
name|unmount_flags
init|=
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_ON_AUTOFS
operator|)
condition|?
name|AMU_UMOUNT_AUTOFS
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_IS_AUTOFS
condition|)
name|error
operator|=
name|UMOUNT_FS
argument_list|(
name|mp
operator|->
name|am_path
argument_list|,
name|mnttab_file_name
argument_list|,
name|unmount_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_FS_AUTOFS */
return|return
name|error
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|amfs_generic_match
parameter_list|(
name|am_opts
modifier|*
name|fo
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|fo
operator|->
name|opt_rfs
condition|)
block|{
name|plog
argument_list|(
name|XLOG_USER
argument_list|,
literal|"amfs_generic_match: no mount point named (rfs:=)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|fo
operator|->
name|opt_fs
condition|)
block|{
name|plog
argument_list|(
name|XLOG_USER
argument_list|,
literal|"amfs_generic_match: no map named (fs:=)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*    * Swap round fs:= and rfs:= options    * ... historical (jsp)    */
name|p
operator|=
name|fo
operator|->
name|opt_rfs
expr_stmt|;
name|fo
operator|->
name|opt_rfs
operator|=
name|fo
operator|->
name|opt_fs
expr_stmt|;
name|fo
operator|->
name|opt_fs
operator|=
name|p
expr_stmt|;
comment|/*    * mtab entry turns out to be the name of the mount map    */
return|return
name|strdup
argument_list|(
name|fo
operator|->
name|opt_rfs
condition|?
name|fo
operator|->
name|opt_rfs
else|:
literal|"."
argument_list|)
return|;
block|}
end_function

end_unit

