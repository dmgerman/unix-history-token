begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997-1999 Erez Zadok  * Copyright (c) 1989 Jan-Simon Pendry  * Copyright (c) 1989 Imperial College of Science, Technology& Medicine  * Copyright (c) 1989 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry at Imperial College, London.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgment:  *      This product includes software developed by the University of  *      California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      %W% (Berkeley) %G%  *  * $Id: am_ops.c,v 1.4 1999/03/13 17:03:26 ezk Exp $  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<am_defs.h>
end_include

begin_include
include|#
directive|include
file|<amd.h>
end_include

begin_comment
comment|/*  * The order of these entries matters, since lookups in this table are done  * on a first-match basis.  The entries below are a mixture of native  * filesystems supported by the OS (HAVE_FS_FOO), and some meta-filesystems  * supported by amd (HAVE_AM_FS_FOO).  The order is set here in expected  * match-hit such that more popular filesystems are listed first (nfs is the  * most popular, followed by a symlink F/S)  */
end_comment

begin_decl_stmt
specifier|static
name|am_ops
modifier|*
name|vops
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|HAVE_FS_NFS
operator|&
name|nfs_ops
block|,
comment|/* network F/S (version 2) */
endif|#
directive|endif
comment|/* HAVE_FS_NFS */
ifdef|#
directive|ifdef
name|HAVE_AM_FS_LINK
operator|&
name|amfs_link_ops
block|,
comment|/* symlink F/S */
endif|#
directive|endif
comment|/* HAVE_AM_FS_LINK */
comment|/*    * Other amd-supported meta-filesystems.    */
ifdef|#
directive|ifdef
name|HAVE_AM_FS_NFSX
operator|&
name|amfs_nfsx_ops
block|,
comment|/* multiple-nfs F/S */
endif|#
directive|endif
comment|/* HAVE_AM_FS_NFSX */
ifdef|#
directive|ifdef
name|HAVE_AM_FS_NFSL
operator|&
name|amfs_nfsl_ops
block|,
comment|/* NFS with local link existence check */
endif|#
directive|endif
comment|/* HAVE_AM_FS_NFSL */
ifdef|#
directive|ifdef
name|HAVE_AM_FS_HOST
operator|&
name|amfs_host_ops
block|,
comment|/* multiple exported nfs F/S */
endif|#
directive|endif
comment|/* HAVE_AM_FS_HOST */
ifdef|#
directive|ifdef
name|HAVE_AM_FS_LINKX
operator|&
name|amfs_linkx_ops
block|,
comment|/* symlink F/S with link target verify */
endif|#
directive|endif
comment|/* HAVE_AM_FS_LINKX */
ifdef|#
directive|ifdef
name|HAVE_AM_FS_PROGRAM
operator|&
name|amfs_program_ops
block|,
comment|/* program F/S */
endif|#
directive|endif
comment|/* HAVE_AM_FS_PROGRAM */
ifdef|#
directive|ifdef
name|HAVE_AM_FS_UNION
operator|&
name|amfs_union_ops
block|,
comment|/* union F/S */
endif|#
directive|endif
comment|/* HAVE_AM_FS_UNION */
ifdef|#
directive|ifdef
name|HAVE_AM_FS_INHERIT
operator|&
name|amfs_inherit_ops
block|,
comment|/* inheritance F/S */
endif|#
directive|endif
comment|/* HAVE_AM_FS_INHERIT */
comment|/*    * A few more native filesystems.    */
ifdef|#
directive|ifdef
name|HAVE_FS_UFS
operator|&
name|ufs_ops
block|,
comment|/* Unix F/S */
endif|#
directive|endif
comment|/* HAVE_FS_UFS */
ifdef|#
directive|ifdef
name|HAVE_FS_XFS
operator|&
name|xfs_ops
block|,
comment|/* Unix (irix) F/S */
endif|#
directive|endif
comment|/* HAVE_FS_XFS */
ifdef|#
directive|ifdef
name|HAVE_FS_EFS
operator|&
name|efs_ops
block|,
comment|/* Unix (irix) F/S */
endif|#
directive|endif
comment|/* HAVE_FS_EFS */
ifdef|#
directive|ifdef
name|HAVE_FS_LOFS
operator|&
name|lofs_ops
block|,
comment|/* loopback F/S */
endif|#
directive|endif
comment|/* HAVE_FS_LOFS */
ifdef|#
directive|ifdef
name|HAVE_FS_CDFS
operator|&
name|cdfs_ops
block|,
comment|/* CDROM/HSFS/ISO9960 F/S */
endif|#
directive|endif
comment|/* HAVE_FS_CDFS */
ifdef|#
directive|ifdef
name|HAVE_FS_PCFS
operator|&
name|pcfs_ops
block|,
comment|/* Floppy/MSDOS F/S */
endif|#
directive|endif
comment|/* HAVE_FS_PCFS */
ifdef|#
directive|ifdef
name|HAVE_FS_CACHEFS
operator|&
name|cachefs_ops
block|,
comment|/* caching F/S */
endif|#
directive|endif
comment|/* HAVE_FS_CACHEFS */
ifdef|#
directive|ifdef
name|HAVE_FS_NULLFS
comment|/* FILL IN */
comment|/* null (loopback) F/S */
endif|#
directive|endif
comment|/* HAVE_FS_NULLFS */
ifdef|#
directive|ifdef
name|HAVE_FS_UNIONFS
comment|/* FILL IN */
comment|/* union (bsd44) F/S */
endif|#
directive|endif
comment|/* HAVE_FS_UNIONFS */
ifdef|#
directive|ifdef
name|HAVE_FS_UMAPFS
comment|/* FILL IN */
comment|/* uid/gid mapping F/S */
endif|#
directive|endif
comment|/* HAVE_FS_UMAPFS */
comment|/*    * These 5 should be last, in the order:    *	(1) amfs_auto    *	(2) amfs_direct    *	(3) amfs_toplvl    *	(4) autofs    *	(5) amfs_error    */
ifdef|#
directive|ifdef
name|HAVE_AM_FS_AUTO
operator|&
name|amfs_auto_ops
block|,
comment|/* Automounter F/S */
endif|#
directive|endif
comment|/* HAVE_AM_FS_AUTO */
ifdef|#
directive|ifdef
name|HAVE_AM_FS_DIRECT
operator|&
name|amfs_direct_ops
block|,
comment|/* direct-mount F/S */
endif|#
directive|endif
comment|/* HAVE_AM_FS_DIRECT */
ifdef|#
directive|ifdef
name|HAVE_AM_FS_TOPLVL
operator|&
name|amfs_toplvl_ops
block|,
comment|/* top-level mount F/S */
endif|#
directive|endif
comment|/* HAVE_AM_FS_TOPLVL */
ifdef|#
directive|ifdef
name|HAVE_FS_AUTOFS
operator|&
name|autofs_ops
block|,
comment|/* autofs mount F/S */
endif|#
directive|endif
comment|/* HAVE_FS_AUTOFS */
ifdef|#
directive|ifdef
name|HAVE_AM_FS_ERROR
operator|&
name|amfs_error_ops
block|,
comment|/* error F/S */
endif|#
directive|endif
comment|/* HAVE_AM_FS_ERROR */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ops_showamfstypes
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|am_ops
modifier|*
modifier|*
name|ap
decl_stmt|;
name|int
name|l
init|=
literal|0
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|vops
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
operator|(
operator|*
name|ap
operator|)
operator|->
name|fs_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
index|[
literal|1
index|]
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|l
operator|+=
name|strlen
argument_list|(
operator|(
operator|*
name|ap
operator|)
operator|->
name|fs_type
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|l
operator|>
literal|62
condition|)
block|{
name|l
operator|=
literal|0
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"\n      "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ops_show1
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|lp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|lp
operator|>
literal|60
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"\t\n"
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ops_showfstypes
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|l
init|=
literal|0
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|MNTTAB_TYPE_AUTOFS
name|ops_show1
argument_list|(
name|buf
argument_list|,
operator|&
name|l
argument_list|,
name|MNTTAB_TYPE_AUTOFS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_TYPE_AUTOFS */
ifdef|#
directive|ifdef
name|MNTTAB_TYPE_CACHEFS
name|ops_show1
argument_list|(
name|buf
argument_list|,
operator|&
name|l
argument_list|,
name|MNTTAB_TYPE_CACHEFS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_TYPE_CACHEFS */
ifdef|#
directive|ifdef
name|MNTTAB_TYPE_CDFS
name|ops_show1
argument_list|(
name|buf
argument_list|,
operator|&
name|l
argument_list|,
name|MNTTAB_TYPE_CDFS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_TYPE_CDFS */
ifdef|#
directive|ifdef
name|MNTTAB_TYPE_CFS
name|ops_show1
argument_list|(
name|buf
argument_list|,
operator|&
name|l
argument_list|,
name|MNTTAB_TYPE_CFS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_TYPE_CFS */
ifdef|#
directive|ifdef
name|MNTTAB_TYPE_LOFS
name|ops_show1
argument_list|(
name|buf
argument_list|,
operator|&
name|l
argument_list|,
name|MNTTAB_TYPE_LOFS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_TYPE_LOFS */
ifdef|#
directive|ifdef
name|MNTTAB_TYPE_EFS
name|ops_show1
argument_list|(
name|buf
argument_list|,
operator|&
name|l
argument_list|,
name|MNTTAB_TYPE_EFS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_TYPE_EFS */
ifdef|#
directive|ifdef
name|MNTTAB_TYPE_MFS
name|ops_show1
argument_list|(
name|buf
argument_list|,
operator|&
name|l
argument_list|,
name|MNTTAB_TYPE_MFS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_TYPE_MFS */
ifdef|#
directive|ifdef
name|MNTTAB_TYPE_NFS
name|ops_show1
argument_list|(
name|buf
argument_list|,
operator|&
name|l
argument_list|,
name|MNTTAB_TYPE_NFS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_TYPE_NFS */
ifdef|#
directive|ifdef
name|MNTTAB_TYPE_NFS3
name|ops_show1
argument_list|(
name|buf
argument_list|,
operator|&
name|l
argument_list|,
literal|"nfs3"
argument_list|)
expr_stmt|;
comment|/* always hard-code as nfs3 */
endif|#
directive|endif
comment|/* MNTTAB_TYPE_NFS3 */
ifdef|#
directive|ifdef
name|MNTTAB_TYPE_NULLFS
name|ops_show1
argument_list|(
name|buf
argument_list|,
operator|&
name|l
argument_list|,
name|MNTTAB_TYPE_NULLFS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_TYPE_NULLFS */
ifdef|#
directive|ifdef
name|MNTTAB_TYPE_PCFS
name|ops_show1
argument_list|(
name|buf
argument_list|,
operator|&
name|l
argument_list|,
name|MNTTAB_TYPE_PCFS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_TYPE_PCFS */
ifdef|#
directive|ifdef
name|MNTTAB_TYPE_TFS
name|ops_show1
argument_list|(
name|buf
argument_list|,
operator|&
name|l
argument_list|,
name|MNTTAB_TYPE_TFS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_TYPE_TFS */
ifdef|#
directive|ifdef
name|MNTTAB_TYPE_TMPFS
name|ops_show1
argument_list|(
name|buf
argument_list|,
operator|&
name|l
argument_list|,
name|MNTTAB_TYPE_TMPFS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_TYPE_TMPFS */
ifdef|#
directive|ifdef
name|MNTTAB_TYPE_UFS
name|ops_show1
argument_list|(
name|buf
argument_list|,
operator|&
name|l
argument_list|,
name|MNTTAB_TYPE_UFS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_TYPE_UFS */
ifdef|#
directive|ifdef
name|MNTTAB_TYPE_UMAPFS
name|ops_show1
argument_list|(
name|buf
argument_list|,
operator|&
name|l
argument_list|,
name|MNTTAB_TYPE_UMAPFS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_TYPE_UMAPFS */
ifdef|#
directive|ifdef
name|MNTTAB_TYPE_UNIONFS
name|ops_show1
argument_list|(
name|buf
argument_list|,
operator|&
name|l
argument_list|,
name|MNTTAB_TYPE_UNIONFS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_TYPE_UNIONFS */
ifdef|#
directive|ifdef
name|MNTTAB_TYPE_XFS
name|ops_show1
argument_list|(
name|buf
argument_list|,
operator|&
name|l
argument_list|,
name|MNTTAB_TYPE_XFS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_TYPE_XFS */
comment|/* terminate with a period, newline, and NULL */
if|if
condition|(
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * return string option which is the reverse of opt.  * nosuid -> suid  * quota -> noquota  * ro -> rw  * etc.  * may return pointer to static buffer or subpointer within opt.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|reverse_option
parameter_list|(
specifier|const
name|char
modifier|*
name|opt
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
operator|!
name|opt
condition|)
return|return
name|NULL
return|;
comment|/* check special cases */
comment|/* XXX: if this gets too long, rewrite the code more flexibly */
if|if
condition|(
name|STREQ
argument_list|(
name|opt
argument_list|,
literal|"ro"
argument_list|)
condition|)
return|return
literal|"rw"
return|;
if|if
condition|(
name|STREQ
argument_list|(
name|opt
argument_list|,
literal|"rw"
argument_list|)
condition|)
return|return
literal|"ro"
return|;
if|if
condition|(
name|STREQ
argument_list|(
name|opt
argument_list|,
literal|"bg"
argument_list|)
condition|)
return|return
literal|"fg"
return|;
if|if
condition|(
name|STREQ
argument_list|(
name|opt
argument_list|,
literal|"fg"
argument_list|)
condition|)
return|return
literal|"bg"
return|;
if|if
condition|(
name|STREQ
argument_list|(
name|opt
argument_list|,
literal|"soft"
argument_list|)
condition|)
return|return
literal|"hard"
return|;
if|if
condition|(
name|STREQ
argument_list|(
name|opt
argument_list|,
literal|"hard"
argument_list|)
condition|)
return|return
literal|"soft"
return|;
comment|/* check if string starts with 'no' and chop it */
if|if
condition|(
name|NSTREQ
argument_list|(
name|opt
argument_list|,
literal|"no"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|opt
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* finally return a string prepended with 'no' */
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"no"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|opt
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/*  * start with an empty string. for each opts1 option that is not  * in opts2, add it to the string (make sure the reverse of it  * isn't in either). finally add opts2. return new string.  * Both opts1 and opts2 must not be null!  * Caller must eventually free the string being returned.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|merge_opts
parameter_list|(
specifier|const
name|char
modifier|*
name|opts1
parameter_list|,
specifier|const
name|char
modifier|*
name|opts2
parameter_list|)
block|{
name|mntent_t
name|mnt2
decl_stmt|;
comment|/* place holder for opts2 */
name|char
modifier|*
name|newstr
decl_stmt|;
comment|/* new string to return (malloc'ed) */
name|char
modifier|*
name|tmpstr
decl_stmt|;
comment|/* temp */
name|char
modifier|*
name|eq
decl_stmt|;
comment|/* pointer to '=' within temp */
name|char
name|oneopt
index|[
literal|80
index|]
decl_stmt|;
comment|/* one option w/o value if any */
name|char
modifier|*
name|revoneopt
decl_stmt|;
comment|/* reverse of oneopt */
name|int
name|len
init|=
name|strlen
argument_list|(
name|opts1
argument_list|)
operator|+
name|strlen
argument_list|(
name|opts2
argument_list|)
operator|+
literal|2
decl_stmt|;
comment|/* space for "," and NULL */
name|char
modifier|*
name|s1
init|=
name|strdup
argument_list|(
name|opts1
argument_list|)
decl_stmt|;
comment|/* copy of opts1 to munge */
comment|/* initialization */
name|mnt2
operator|.
name|mnt_opts
operator|=
operator|(
name|char
operator|*
operator|)
name|opts2
expr_stmt|;
name|newstr
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|newstr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|tmpstr
operator|=
name|strtok
argument_list|(
name|s1
argument_list|,
literal|","
argument_list|)
init|;
name|tmpstr
condition|;
name|tmpstr
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
control|)
block|{
comment|/* copy option to temp buffer */
name|strncpy
argument_list|(
name|oneopt
argument_list|,
name|tmpstr
argument_list|,
literal|80
argument_list|)
expr_stmt|;
name|oneopt
index|[
literal|79
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* if option has a value such as rsize=1024, chop the value part */
if|if
condition|(
operator|(
name|eq
operator|=
name|strchr
argument_list|(
name|oneopt
argument_list|,
literal|'='
argument_list|)
operator|)
condition|)
name|eq
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* find reverse option of oneopt */
name|revoneopt
operator|=
name|reverse_option
argument_list|(
name|oneopt
argument_list|)
expr_stmt|;
comment|/* if option orits reverse exist in opts2, ignore it */
if|if
condition|(
name|hasmntopt
argument_list|(
operator|&
name|mnt2
argument_list|,
name|oneopt
argument_list|)
operator|||
name|hasmntopt
argument_list|(
operator|&
name|mnt2
argument_list|,
name|revoneopt
argument_list|)
condition|)
continue|continue;
comment|/* add option to returned string */
if|if
condition|(
name|newstr
operator|&&
name|newstr
index|[
literal|0
index|]
condition|)
block|{
name|strcat
argument_list|(
name|newstr
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|newstr
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|newstr
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* finally, append opts2 itself */
if|if
condition|(
name|newstr
operator|&&
name|newstr
index|[
literal|0
index|]
condition|)
block|{
name|strcat
argument_list|(
name|newstr
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|newstr
argument_list|,
name|opts2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|newstr
argument_list|,
name|opts2
argument_list|)
expr_stmt|;
block|}
name|XFREE
argument_list|(
name|s1
argument_list|)
expr_stmt|;
return|return
name|newstr
return|;
block|}
end_function

begin_function
name|am_ops
modifier|*
name|ops_match
parameter_list|(
name|am_opts
modifier|*
name|fo
parameter_list|,
name|char
modifier|*
name|key
parameter_list|,
name|char
modifier|*
name|g_key
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|keym
parameter_list|,
name|char
modifier|*
name|map
parameter_list|)
block|{
name|am_ops
modifier|*
modifier|*
name|vp
decl_stmt|;
name|am_ops
modifier|*
name|rop
init|=
literal|0
decl_stmt|;
comment|/*    * First crack the global opts and the local opts    */
if|if
condition|(
operator|!
name|eval_fs_opts
argument_list|(
name|fo
argument_list|,
name|key
argument_list|,
name|g_key
argument_list|,
name|path
argument_list|,
name|keym
argument_list|,
name|map
argument_list|)
condition|)
block|{
name|rop
operator|=
operator|&
name|amfs_error_ops
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fo
operator|->
name|opt_type
operator|==
literal|0
condition|)
block|{
name|plog
argument_list|(
name|XLOG_USER
argument_list|,
literal|"No fs type specified (key = \"%s\", map = \"%s\")"
argument_list|,
name|keym
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|rop
operator|=
operator|&
name|amfs_error_ops
expr_stmt|;
block|}
else|else
block|{
comment|/*      * Next find the correct filesystem type      */
for|for
control|(
name|vp
operator|=
name|vops
init|;
operator|(
name|rop
operator|=
operator|*
name|vp
operator|)
condition|;
name|vp
operator|++
control|)
if|if
condition|(
name|STREQ
argument_list|(
name|rop
operator|->
name|fs_type
argument_list|,
name|fo
operator|->
name|opt_type
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|rop
condition|)
block|{
name|plog
argument_list|(
name|XLOG_USER
argument_list|,
literal|"fs type \"%s\" not recognized"
argument_list|,
name|fo
operator|->
name|opt_type
argument_list|)
expr_stmt|;
name|rop
operator|=
operator|&
name|amfs_error_ops
expr_stmt|;
block|}
block|}
comment|/*    * Make sure we have a default mount option.    * Otherwise skip past any leading '-'.    */
if|if
condition|(
name|fo
operator|->
name|opt_opts
operator|==
literal|0
condition|)
name|fo
operator|->
name|opt_opts
operator|=
name|strdup
argument_list|(
literal|"rw,defaults"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|fo
operator|->
name|opt_opts
operator|==
literal|'-'
condition|)
block|{
comment|/*      * We cannot simply do fo->opt_opts++ here since the opts      * module will try to free the pointer fo->opt_opts later.      * So just reallocate the thing -- stolcke 11/11/94      */
name|char
modifier|*
name|old
init|=
name|fo
operator|->
name|opt_opts
decl_stmt|;
name|fo
operator|->
name|opt_opts
operator|=
name|strdup
argument_list|(
name|old
operator|+
literal|1
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
comment|/*    * If addopts option was used, then append it to the    * current options and remote mount options.    */
if|if
condition|(
name|fo
operator|->
name|opt_addopts
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|fo
operator|->
name|opt_opts
argument_list|,
name|fo
operator|->
name|opt_remopts
argument_list|)
condition|)
block|{
comment|/* optimize things for the common case where opts==remopts */
name|char
modifier|*
name|mergedstr
decl_stmt|;
name|mergedstr
operator|=
name|merge_opts
argument_list|(
name|fo
operator|->
name|opt_opts
argument_list|,
name|fo
operator|->
name|opt_addopts
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_USER
argument_list|,
literal|"merge rem/opts \"%s\" add \"%s\" => \"%s\""
argument_list|,
name|fo
operator|->
name|opt_opts
argument_list|,
name|fo
operator|->
name|opt_addopts
argument_list|,
name|mergedstr
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|fo
operator|->
name|opt_opts
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|fo
operator|->
name|opt_remopts
argument_list|)
expr_stmt|;
name|fo
operator|->
name|opt_opts
operator|=
name|mergedstr
expr_stmt|;
name|fo
operator|->
name|opt_remopts
operator|=
name|strdup
argument_list|(
name|mergedstr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|mergedstr
decl_stmt|,
modifier|*
name|remmergedstr
decl_stmt|;
name|mergedstr
operator|=
name|merge_opts
argument_list|(
name|fo
operator|->
name|opt_opts
argument_list|,
name|fo
operator|->
name|opt_addopts
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_USER
argument_list|,
literal|"merge opts \"%s\" add \"%s\" => \"%s\""
argument_list|,
name|fo
operator|->
name|opt_opts
argument_list|,
name|fo
operator|->
name|opt_addopts
argument_list|,
name|mergedstr
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|fo
operator|->
name|opt_opts
argument_list|)
expr_stmt|;
name|fo
operator|->
name|opt_opts
operator|=
name|mergedstr
expr_stmt|;
name|remmergedstr
operator|=
name|merge_opts
argument_list|(
name|fo
operator|->
name|opt_remopts
argument_list|,
name|fo
operator|->
name|opt_addopts
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_USER
argument_list|,
literal|"merge remopts \"%s\" add \"%s\" => \"%s\""
argument_list|,
name|fo
operator|->
name|opt_remopts
argument_list|,
name|fo
operator|->
name|opt_addopts
argument_list|,
name|remmergedstr
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|fo
operator|->
name|opt_remopts
argument_list|)
expr_stmt|;
name|fo
operator|->
name|opt_remopts
operator|=
name|remmergedstr
expr_stmt|;
block|}
block|}
comment|/*    * Check the filesystem is happy    */
if|if
condition|(
name|fo
operator|->
name|fs_mtab
condition|)
name|XFREE
argument_list|(
name|fo
operator|->
name|fs_mtab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fo
operator|->
name|fs_mtab
operator|=
call|(
modifier|*
name|rop
operator|->
name|fs_match
call|)
argument_list|(
name|fo
argument_list|)
operator|)
condition|)
return|return
name|rop
return|;
comment|/*    * Return error file system    */
name|fo
operator|->
name|fs_mtab
operator|=
call|(
modifier|*
name|amfs_error_ops
operator|.
name|fs_match
call|)
argument_list|(
name|fo
argument_list|)
expr_stmt|;
return|return
operator|&
name|amfs_error_ops
return|;
block|}
end_function

end_unit

