begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997-1999 Erez Zadok  * Copyright (c) 1990 Jan-Simon Pendry  * Copyright (c) 1990 Imperial College of Science, Technology& Medicine  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry at Imperial College, London.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgment:  *      This product includes software developed by the University of  *      California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      %W% (Berkeley) %G%  *  * $Id: amfs_auto.c,v 1.5 1999/09/30 21:01:29 ezk Exp $  *  */
end_comment

begin_comment
comment|/*  * Automount file system  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<am_defs.h>
end_include

begin_include
include|#
directive|include
file|<amd.h>
end_include

begin_comment
comment|/****************************************************************************  *** MACROS                                                               ***  ****************************************************************************/
end_comment

begin_define
define|#
directive|define
name|IN_PROGRESS
parameter_list|(
name|cp
parameter_list|)
value|((cp)->mp->am_mnt->mf_flags& MFF_MOUNTING)
end_define

begin_comment
comment|/* DEVELOPERS: turn this on for special debugging of readdir code */
end_comment

begin_undef
undef|#
directive|undef
name|DEBUG_READDIR
end_undef

begin_define
define|#
directive|define
name|DOT_DOT_COOKIE
value|(u_int) 1
end_define

begin_comment
comment|/****************************************************************************  *** STRUCTURES                                                           ***  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *** FORWARD DEFINITIONS                                                  ***  ****************************************************************************/
end_comment

begin_function_decl
specifier|static
name|int
name|amfs_auto_bgmount
parameter_list|(
name|struct
name|continuation
modifier|*
name|cp
parameter_list|,
name|int
name|mpe
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|amfs_auto_mount
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|amfs_auto_readdir_browsable
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|,
name|nfscookie
name|cookie
parameter_list|,
name|nfsdirlist
modifier|*
name|dp
parameter_list|,
name|nfsentry
modifier|*
name|ep
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|fully_browsable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|amfs_auto_umounted
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/****************************************************************************  *** OPS STRUCTURES                                                       ***  ****************************************************************************/
end_comment

begin_decl_stmt
name|am_ops
name|amfs_auto_ops
init|=
block|{
literal|"auto"
block|,
name|amfs_auto_match
block|,
literal|0
block|,
comment|/* amfs_auto_init */
name|amfs_auto_mount
block|,
literal|0
block|,
name|amfs_auto_umount
block|,
literal|0
block|,
name|amfs_auto_lookuppn
block|,
name|amfs_auto_readdir
block|,
literal|0
block|,
comment|/* amfs_auto_readlink */
literal|0
block|,
comment|/* amfs_auto_mounted */
name|amfs_auto_umounted
block|,
name|find_amfs_auto_srvr
block|,
name|FS_AMQINFO
operator||
name|FS_DIRECTORY
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/****************************************************************************  *** FUNCTIONS                                                             ***  ****************************************************************************/
end_comment

begin_comment
comment|/*  * AMFS_AUTO needs nothing in particular.  */
end_comment

begin_function
name|char
modifier|*
name|amfs_auto_match
parameter_list|(
name|am_opts
modifier|*
name|fo
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|fo
operator|->
name|opt_rfs
decl_stmt|;
if|if
condition|(
operator|!
name|fo
operator|->
name|opt_rfs
condition|)
block|{
name|plog
argument_list|(
name|XLOG_USER
argument_list|,
literal|"auto: no mount point named (rfs:=)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|fo
operator|->
name|opt_fs
condition|)
block|{
name|plog
argument_list|(
name|XLOG_USER
argument_list|,
literal|"auto: no map named (fs:=)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*    * Swap round fs:= and rfs:= options    * ... historical (jsp)    */
name|fo
operator|->
name|opt_rfs
operator|=
name|fo
operator|->
name|opt_fs
expr_stmt|;
name|fo
operator|->
name|opt_fs
operator|=
name|p
expr_stmt|;
comment|/*    * mtab entry turns out to be the name of the mount map    */
return|return
name|strdup
argument_list|(
name|fo
operator|->
name|opt_rfs
condition|?
name|fo
operator|->
name|opt_rfs
else|:
literal|"."
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Build a new map cache for this node, or re-use  * an existing cache for the same map.  */
end_comment

begin_function
name|void
name|amfs_auto_mkcacheref
parameter_list|(
name|mntfs
modifier|*
name|mf
parameter_list|)
block|{
name|char
modifier|*
name|cache
decl_stmt|;
if|if
condition|(
name|mf
operator|->
name|mf_fo
operator|&&
name|mf
operator|->
name|mf_fo
operator|->
name|opt_cache
condition|)
name|cache
operator|=
name|mf
operator|->
name|mf_fo
operator|->
name|opt_cache
expr_stmt|;
else|else
name|cache
operator|=
literal|"none"
expr_stmt|;
name|mf
operator|->
name|mf_private
operator|=
operator|(
name|voidp
operator|)
name|mapc_find
argument_list|(
name|mf
operator|->
name|mf_info
argument_list|,
name|cache
argument_list|,
name|mf
operator|->
name|mf_fo
operator|->
name|opt_maptype
argument_list|)
expr_stmt|;
name|mf
operator|->
name|mf_prfree
operator|=
name|mapc_free
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mount a sub-mount  */
end_comment

begin_function
specifier|static
name|int
name|amfs_auto_mount
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
name|mntfs
modifier|*
name|mf
init|=
name|mp
operator|->
name|am_mnt
decl_stmt|;
comment|/*    * Pseudo-directories are used to provide some structure    * to the automounted directories instead    * of putting them all in the top-level automount directory.    *    * Here, just increment the parent's link count.    */
name|mp
operator|->
name|am_parent
operator|->
name|am_fattr
operator|.
name|na_nlink
operator|++
expr_stmt|;
comment|/*    * Info field of . means use parent's info field.    * Historical - not documented.    */
if|if
condition|(
name|mf
operator|->
name|mf_info
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|mf
operator|->
name|mf_info
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|mf
operator|->
name|mf_info
operator|=
name|strealloc
argument_list|(
name|mf
operator|->
name|mf_info
argument_list|,
name|mp
operator|->
name|am_parent
operator|->
name|am_mnt
operator|->
name|mf_info
argument_list|)
expr_stmt|;
comment|/*    * Compute prefix:    *    * If there is an option prefix then use that else    * If the parent had a prefix then use that with name    *      of this node appended else    * Use the name of this node.    *    * That means if you want no prefix you must say so    * in the map.    */
if|if
condition|(
name|mf
operator|->
name|mf_fo
operator|->
name|opt_pref
condition|)
block|{
comment|/* allow pref:=null to set a real null prefix */
if|if
condition|(
name|STREQ
argument_list|(
name|mf
operator|->
name|mf_fo
operator|->
name|opt_pref
argument_list|,
literal|"null"
argument_list|)
condition|)
block|{
name|mp
operator|->
name|am_pref
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
comment|/*        * the prefix specified as an option        */
name|mp
operator|->
name|am_pref
operator|=
name|strdup
argument_list|(
name|mf
operator|->
name|mf_fo
operator|->
name|opt_pref
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*      * else the parent's prefix      * followed by the name      * followed by /      */
name|char
modifier|*
name|ppref
init|=
name|mp
operator|->
name|am_parent
operator|->
name|am_pref
decl_stmt|;
if|if
condition|(
name|ppref
operator|==
literal|0
condition|)
name|ppref
operator|=
literal|""
expr_stmt|;
name|mp
operator|->
name|am_pref
operator|=
name|str3cat
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|ppref
argument_list|,
name|mp
operator|->
name|am_name
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
comment|/*    * Attach a map cache    */
name|amfs_auto_mkcacheref
argument_list|(
name|mf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Unmount an automount sub-node  */
end_comment

begin_function
name|int
name|amfs_auto_umount
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Unmount an automount node  */
end_comment

begin_function
specifier|static
name|void
name|amfs_auto_umounted
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
comment|/*    * If this is a pseudo-directory then just adjust the link count    * in the parent, otherwise call the generic unmount routine    */
if|if
condition|(
name|mp
operator|->
name|am_parent
operator|&&
name|mp
operator|->
name|am_parent
operator|->
name|am_parent
condition|)
operator|--
name|mp
operator|->
name|am_parent
operator|->
name|am_fattr
operator|.
name|na_nlink
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Discard an old continuation  */
end_comment

begin_function
name|void
name|free_continuation
parameter_list|(
name|struct
name|continuation
modifier|*
name|cp
parameter_list|)
block|{
if|if
condition|(
name|cp
operator|->
name|callout
condition|)
name|untimeout
argument_list|(
name|cp
operator|->
name|callout
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|cp
operator|->
name|key
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|cp
operator|->
name|xivec
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|cp
operator|->
name|info
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|cp
operator|->
name|auto_opts
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|cp
operator|->
name|def_opts
argument_list|)
expr_stmt|;
name|free_opts
argument_list|(
operator|&
name|cp
operator|->
name|fs_opts
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Discard the underlying mount point and replace  * with a reference to an error filesystem.  */
end_comment

begin_function
name|void
name|assign_error_mntfs
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
if|if
condition|(
name|mp
operator|->
name|am_error
operator|>
literal|0
condition|)
block|{
comment|/*      * Save the old error code      */
name|int
name|error
init|=
name|mp
operator|->
name|am_error
decl_stmt|;
if|if
condition|(
name|error
operator|<=
literal|0
condition|)
name|error
operator|=
name|mp
operator|->
name|am_mnt
operator|->
name|mf_error
expr_stmt|;
comment|/*      * Discard the old filesystem      */
name|free_mntfs
argument_list|(
name|mp
operator|->
name|am_mnt
argument_list|)
expr_stmt|;
comment|/*      * Allocate a new error reference      */
name|mp
operator|->
name|am_mnt
operator|=
name|new_mntfs
argument_list|()
expr_stmt|;
comment|/*      * Put back the error code      */
name|mp
operator|->
name|am_mnt
operator|->
name|mf_error
operator|=
name|error
expr_stmt|;
name|mp
operator|->
name|am_mnt
operator|->
name|mf_flags
operator||=
name|MFF_ERROR
expr_stmt|;
comment|/*      * Zero the error in the mount point      */
name|mp
operator|->
name|am_error
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * The continuation function.  This is called by  * the task notifier when a background mount attempt  * completes.  */
end_comment

begin_function
name|void
name|amfs_auto_cont
parameter_list|(
name|int
name|rc
parameter_list|,
name|int
name|term
parameter_list|,
name|voidp
name|closure
parameter_list|)
block|{
name|struct
name|continuation
modifier|*
name|cp
init|=
operator|(
expr|struct
name|continuation
operator|*
operator|)
name|closure
decl_stmt|;
name|mntfs
modifier|*
name|mf
init|=
name|cp
operator|->
name|mp
operator|->
name|am_mnt
decl_stmt|;
comment|/*    * Definitely not trying to mount at the moment    */
name|mf
operator|->
name|mf_flags
operator|&=
operator|~
name|MFF_MOUNTING
expr_stmt|;
comment|/*    * While we are mounting - try to avoid race conditions    */
name|new_ttl
argument_list|(
name|cp
operator|->
name|mp
argument_list|)
expr_stmt|;
comment|/*    * Wakeup anything waiting for this mount    */
name|wakeup
argument_list|(
operator|(
name|voidp
operator|)
name|mf
argument_list|)
expr_stmt|;
comment|/*    * Check for termination signal or exit status...    */
if|if
condition|(
name|rc
operator|||
name|term
condition|)
block|{
name|am_node
modifier|*
name|xmp
decl_stmt|;
if|if
condition|(
name|term
condition|)
block|{
comment|/*        * Not sure what to do for an error code.        */
name|mf
operator|->
name|mf_error
operator|=
name|EIO
expr_stmt|;
comment|/* XXX ? */
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_ERROR
expr_stmt|;
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"mount for %s got signal %d"
argument_list|,
name|cp
operator|->
name|mp
operator|->
name|am_path
argument_list|,
name|term
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*        * Check for exit status...        */
name|mf
operator|->
name|mf_error
operator|=
name|rc
expr_stmt|;
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_ERROR
expr_stmt|;
name|errno
operator|=
name|rc
expr_stmt|;
comment|/* XXX */
if|if
condition|(
operator|!
name|STREQ
argument_list|(
name|cp
operator|->
name|mp
operator|->
name|am_mnt
operator|->
name|mf_ops
operator|->
name|fs_type
argument_list|,
literal|"linkx"
argument_list|)
condition|)
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"%s: mount (amfs_auto_cont): %m"
argument_list|,
name|cp
operator|->
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
block|}
comment|/*      * If we get here then that attempt didn't work, so      * move the info vector pointer along by one and      * call the background mount routine again      */
name|amd_stats
operator|.
name|d_merr
operator|++
expr_stmt|;
name|cp
operator|->
name|ivec
operator|++
expr_stmt|;
name|xmp
operator|=
name|cp
operator|->
name|mp
expr_stmt|;
operator|(
name|void
operator|)
name|amfs_auto_bgmount
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assign_error_mntfs
argument_list|(
name|xmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*      * The mount worked.      */
name|am_mounted
argument_list|(
name|cp
operator|->
name|mp
argument_list|)
expr_stmt|;
name|free_continuation
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|reschedule_timeout_mp
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Retry a mount  */
end_comment

begin_function
name|void
name|amfs_auto_retry
parameter_list|(
name|int
name|rc
parameter_list|,
name|int
name|term
parameter_list|,
name|voidp
name|closure
parameter_list|)
block|{
name|struct
name|continuation
modifier|*
name|cp
init|=
operator|(
expr|struct
name|continuation
operator|*
operator|)
name|closure
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Commencing retry for mount of %s"
argument_list|,
name|cp
operator|->
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|new_ttl
argument_list|(
name|cp
operator|->
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|->
name|start
operator|+
name|ALLOWED_MOUNT_TIME
operator|)
operator|<
name|clocktime
argument_list|()
condition|)
block|{
comment|/*      * The entire mount has timed out.  Set the error code and skip past all      * the info vectors so that amfs_auto_bgmount will not have any more      * ways to try the mount, so causing an error.      */
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"mount of \"%s\" has timed out"
argument_list|,
name|cp
operator|->
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|->
name|ivec
condition|)
name|cp
operator|->
name|ivec
operator|++
expr_stmt|;
comment|/* explicitly forbid further retries after timeout */
name|cp
operator|->
name|retry
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|||
operator|!
name|IN_PROGRESS
argument_list|(
name|cp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|amfs_auto_bgmount
argument_list|(
name|cp
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|reschedule_timeout_mp
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Try to mount a file system.  Can be called  * directly or in a sub-process by run_task.  */
end_comment

begin_function
name|int
name|try_mount
parameter_list|(
name|voidp
name|mvp
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|am_node
modifier|*
name|mp
init|=
operator|(
name|am_node
operator|*
operator|)
name|mvp
decl_stmt|;
name|mntfs
modifier|*
name|mf
init|=
name|mp
operator|->
name|am_mnt
decl_stmt|;
comment|/*    * If the directory is not yet made and it needs to be made, then make it!    * This may be run in a background process in which case the flag setting    * won't be noticed later - but it is set anyway just after run_task is    * called.  It should probably go away totally...    */
if|if
condition|(
operator|!
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_MKMNT
operator|)
operator|&&
name|mf
operator|->
name|mf_ops
operator|->
name|fs_flags
operator|&
name|FS_MKMNT
condition|)
block|{
name|error
operator|=
name|mkdirs
argument_list|(
name|mf
operator|->
name|mf_mount
argument_list|,
literal|0555
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_MKMNT
expr_stmt|;
block|}
comment|/*    * Mount it!    */
name|error
operator|=
name|mount_node
argument_list|(
name|mp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|error
operator|>
literal|0
condition|)
block|{
name|errno
operator|=
name|error
expr_stmt|;
name|dlog
argument_list|(
literal|"amfs_auto call to mount_node failed: %m"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Pick a file system to try mounting and  * do that in the background if necessary  * For each location: 	if it is new -defaults then 		extract and process 		continue; 	fi 	if it is a cut then 		if a location has been tried then 			break; 		fi 		continue; 	fi 	parse mount location 	discard previous mount location if required 	find matching mounted filesystem 	if not applicable then 		this_error = No such file or directory 		continue 	fi 	if the filesystem failed to be mounted then 		this_error = error from filesystem 	elif the filesystem is mounting or unmounting then 		this_error = -1 	elif the fileserver is down then 		this_error = -1 	elif the filesystem is already mounted 		this_error = 0 		break 	fi 	if no error on this mount then 		this_error = initialize mount point 	fi 	if no error on this mount and mount is delayed then 		this_error = -1 	fi 	if this_error< 0 then 		retry = true 	fi 	if no error on this mount then 		make mount point if required 	fi 	if no error on this mount then 		if mount in background then 			run mount in background 			return -1 		else 			this_error = mount in foreground 		fi 	fi 	if an error occurred on this mount then 		update stats 		save error in mount point 	fi endfor  */
end_comment

begin_function
specifier|static
name|int
name|amfs_auto_bgmount
parameter_list|(
name|struct
name|continuation
modifier|*
name|cp
parameter_list|,
name|int
name|mpe
parameter_list|)
block|{
name|mntfs
modifier|*
name|mf
init|=
name|cp
operator|->
name|mp
operator|->
name|am_mnt
decl_stmt|;
comment|/* Current mntfs */
name|mntfs
modifier|*
name|mf_retry
init|=
literal|0
decl_stmt|;
comment|/* First mntfs which needed retrying */
name|int
name|this_error
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Per-mount error */
name|int
name|hard_error
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|mp_error
init|=
name|mpe
decl_stmt|;
comment|/*    * Try to mount each location.    * At the end:    * hard_error == 0 indicates something was mounted.    * hard_error> 0 indicates everything failed with a hard error    * hard_error< 0 indicates nothing could be mounted now    */
for|for
control|(
init|;
name|this_error
operator|&&
operator|*
name|cp
operator|->
name|ivec
condition|;
name|cp
operator|->
name|ivec
operator|++
control|)
block|{
name|am_ops
modifier|*
name|p
decl_stmt|;
name|am_node
modifier|*
name|mp
init|=
name|cp
operator|->
name|mp
decl_stmt|;
name|char
modifier|*
name|link_dir
decl_stmt|;
name|int
name|dont_retry
decl_stmt|;
if|if
condition|(
name|hard_error
operator|<
literal|0
condition|)
name|hard_error
operator|=
name|this_error
expr_stmt|;
name|this_error
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|cp
operator|->
name|ivec
operator|==
literal|'-'
condition|)
block|{
comment|/*        * Pick up new defaults        */
if|if
condition|(
name|cp
operator|->
name|auto_opts
operator|&&
operator|*
name|cp
operator|->
name|auto_opts
condition|)
name|cp
operator|->
name|def_opts
operator|=
name|str3cat
argument_list|(
name|cp
operator|->
name|def_opts
argument_list|,
name|cp
operator|->
name|auto_opts
argument_list|,
literal|";"
argument_list|,
operator|*
name|cp
operator|->
name|ivec
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|cp
operator|->
name|def_opts
operator|=
name|strealloc
argument_list|(
name|cp
operator|->
name|def_opts
argument_list|,
operator|*
name|cp
operator|->
name|ivec
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Setting def_opts to \"%s\""
argument_list|,
name|cp
operator|->
name|def_opts
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
continue|continue;
block|}
comment|/*      * If a mount has been attempted, and we find      * a cut then don't try any more locations.      */
if|if
condition|(
name|STREQ
argument_list|(
operator|*
name|cp
operator|->
name|ivec
argument_list|,
literal|"/"
argument_list|)
operator|||
name|STREQ
argument_list|(
operator|*
name|cp
operator|->
name|ivec
argument_list|,
literal|"||"
argument_list|)
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|tried
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Cut: not trying any more locations for %s"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
break|break;
block|}
continue|continue;
block|}
comment|/* match the operators */
name|p
operator|=
name|ops_match
argument_list|(
operator|&
name|cp
operator|->
name|fs_opts
argument_list|,
operator|*
name|cp
operator|->
name|ivec
argument_list|,
name|cp
operator|->
name|def_opts
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|cp
operator|->
name|key
argument_list|,
name|mp
operator|->
name|am_parent
operator|->
name|am_mnt
operator|->
name|mf_info
argument_list|)
expr_stmt|;
comment|/*      * Find a mounted filesystem for this node.      */
name|mp
operator|->
name|am_mnt
operator|=
name|mf
operator|=
name|realloc_mntfs
argument_list|(
name|mf
argument_list|,
name|p
argument_list|,
operator|&
name|cp
operator|->
name|fs_opts
argument_list|,
name|cp
operator|->
name|fs_opts
operator|.
name|opt_fs
argument_list|,
name|cp
operator|->
name|fs_opts
operator|.
name|fs_mtab
argument_list|,
name|cp
operator|->
name|auto_opts
argument_list|,
name|cp
operator|->
name|fs_opts
operator|.
name|opt_opts
argument_list|,
name|cp
operator|->
name|fs_opts
operator|.
name|opt_remopts
argument_list|)
expr_stmt|;
name|p
operator|=
name|mf
operator|->
name|mf_ops
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Got a hit with %s"
argument_list|,
name|p
operator|->
name|fs_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/*      * Note whether this is a real mount attempt      */
if|if
condition|(
name|p
operator|==
operator|&
name|amfs_error_ops
condition|)
block|{
name|plog
argument_list|(
name|XLOG_MAP
argument_list|,
literal|"Map entry %s for %s failed to match"
argument_list|,
operator|*
name|cp
operator|->
name|ivec
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_error
operator|<=
literal|0
condition|)
name|this_error
operator|=
name|ENOENT
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|cp
operator|->
name|fs_opts
operator|.
name|fs_mtab
condition|)
block|{
name|plog
argument_list|(
name|XLOG_MAP
argument_list|,
literal|"Trying mount of %s on %s fstype %s"
argument_list|,
name|cp
operator|->
name|fs_opts
operator|.
name|fs_mtab
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|p
operator|->
name|fs_type
argument_list|)
expr_stmt|;
block|}
name|cp
operator|->
name|tried
operator|=
name|TRUE
expr_stmt|;
block|}
name|this_error
operator|=
literal|0
expr_stmt|;
name|dont_retry
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_link
condition|)
block|{
name|XFREE
argument_list|(
name|mp
operator|->
name|am_link
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_link
operator|=
literal|0
expr_stmt|;
block|}
name|link_dir
operator|=
name|mf
operator|->
name|mf_fo
operator|->
name|opt_sublink
expr_stmt|;
if|if
condition|(
name|link_dir
operator|&&
operator|*
name|link_dir
condition|)
block|{
if|if
condition|(
operator|*
name|link_dir
operator|==
literal|'/'
condition|)
block|{
name|mp
operator|->
name|am_link
operator|=
name|strdup
argument_list|(
name|link_dir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * try getting fs option from continuation, not mountpoint! 	 * Don't try logging the string from mf, since it may be bad! 	 */
if|if
condition|(
name|cp
operator|->
name|fs_opts
operator|.
name|opt_fs
operator|!=
name|mf
operator|->
name|mf_fo
operator|->
name|opt_fs
condition|)
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"use %s instead of 0x%lx"
argument_list|,
name|cp
operator|->
name|fs_opts
operator|.
name|opt_fs
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|mf
operator|->
name|mf_fo
operator|->
name|opt_fs
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_link
operator|=
name|str3cat
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|cp
operator|->
name|fs_opts
operator|.
name|opt_fs
argument_list|,
literal|"/"
argument_list|,
name|link_dir
argument_list|)
expr_stmt|;
name|normalize_slash
argument_list|(
name|mp
operator|->
name|am_link
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mf
operator|->
name|mf_error
operator|>
literal|0
condition|)
block|{
name|this_error
operator|=
name|mf
operator|->
name|mf_error
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
operator|(
name|MFF_MOUNTING
operator||
name|MFF_UNMOUNTING
operator|)
condition|)
block|{
comment|/*        * Still mounting - retry later        */
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Duplicate pending mount fstype %s"
argument_list|,
name|p
operator|->
name|fs_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|this_error
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FSRV_ISDOWN
argument_list|(
name|mf
operator|->
name|mf_server
argument_list|)
condition|)
block|{
comment|/*        * Would just mount from the same place        * as a hung mount - so give up        */
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"%s is already hung - giving up"
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|mp_error
operator|=
name|EWOULDBLOCK
expr_stmt|;
name|dont_retry
operator|=
name|TRUE
expr_stmt|;
name|this_error
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_MOUNTED
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"duplicate mount of \"%s\" ..."
argument_list|,
name|mf
operator|->
name|mf_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/*        * Just call mounted()        */
name|am_mounted
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|this_error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/*      * Will usually need to play around with the mount nodes      * file attribute structure.  This must be done here.      * Try and get things initialized, even if the fileserver      * is not known to be up.  In the common case this will      * progress things faster.      */
if|if
condition|(
operator|!
name|this_error
condition|)
block|{
comment|/*        * Fill in attribute fields.        */
if|if
condition|(
name|mf
operator|->
name|mf_ops
operator|->
name|fs_flags
operator|&
name|FS_DIRECTORY
condition|)
name|mk_fattr
argument_list|(
name|mp
argument_list|,
name|NFDIR
argument_list|)
expr_stmt|;
else|else
name|mk_fattr
argument_list|(
name|mp
argument_list|,
name|NFLNK
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|.
name|na_fileid
operator|=
name|mp
operator|->
name|am_gen
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|fs_init
condition|)
name|this_error
operator|=
call|(
modifier|*
name|p
operator|->
name|fs_init
call|)
argument_list|(
name|mf
argument_list|)
expr_stmt|;
block|}
comment|/*      * Make sure the fileserver is UP before doing any more work      */
if|if
condition|(
operator|!
name|FSRV_ISUP
argument_list|(
name|mf
operator|->
name|mf_server
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"waiting for server %s to become available"
argument_list|,
name|mf
operator|->
name|mf_server
operator|->
name|fs_host
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|this_error
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|this_error
operator|&&
name|mf
operator|->
name|mf_fo
operator|->
name|opt_delay
condition|)
block|{
comment|/*        * If there is a delay timer on the mount        * then don't try to mount if the timer        * has not expired.        */
name|int
name|i
init|=
name|atoi
argument_list|(
name|mf
operator|->
name|mf_fo
operator|->
name|opt_delay
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|clocktime
argument_list|()
operator|<
operator|(
name|cp
operator|->
name|start
operator|+
name|i
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Mount of %s delayed by %lds"
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|,
call|(
name|long
call|)
argument_list|(
name|i
operator|-
name|clocktime
argument_list|()
operator|+
name|cp
operator|->
name|start
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|this_error
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|this_error
operator|<
literal|0
operator|&&
operator|!
name|dont_retry
condition|)
block|{
if|if
condition|(
operator|!
name|mf_retry
condition|)
name|mf_retry
operator|=
name|dup_mntfs
argument_list|(
name|mf
argument_list|)
expr_stmt|;
name|cp
operator|->
name|retry
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"will retry ...\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
break|break;
block|}
if|if
condition|(
operator|!
name|this_error
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|fs_flags
operator|&
name|FS_MBACKGROUND
condition|)
block|{
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_MOUNTING
expr_stmt|;
comment|/* XXX */
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"backgrounding mount of \"%s\""
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|cp
operator|->
name|callout
condition|)
block|{
name|untimeout
argument_list|(
name|cp
operator|->
name|callout
argument_list|)
expr_stmt|;
name|cp
operator|->
name|callout
operator|=
literal|0
expr_stmt|;
block|}
name|run_task
argument_list|(
name|try_mount
argument_list|,
operator|(
name|voidp
operator|)
name|mp
argument_list|,
name|amfs_auto_cont
argument_list|,
operator|(
name|voidp
operator|)
name|cp
argument_list|)
expr_stmt|;
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_MKMNT
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|mf_retry
condition|)
name|free_mntfs
argument_list|(
name|mf_retry
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"foreground mount of \"%s\" ..."
argument_list|,
name|mf
operator|->
name|mf_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|this_error
operator|=
name|try_mount
argument_list|(
operator|(
name|voidp
operator|)
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_error
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|mf_retry
condition|)
name|mf_retry
operator|=
name|dup_mntfs
argument_list|(
name|mf
argument_list|)
expr_stmt|;
name|cp
operator|->
name|retry
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|this_error
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|this_error
operator|>
literal|0
condition|)
block|{
name|amd_stats
operator|.
name|d_merr
operator|++
expr_stmt|;
if|if
condition|(
name|mf
operator|!=
name|mf_retry
condition|)
block|{
name|mf
operator|->
name|mf_error
operator|=
name|this_error
expr_stmt|;
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_ERROR
expr_stmt|;
block|}
block|}
comment|/*        * Wakeup anything waiting for this mount        */
name|wakeup
argument_list|(
operator|(
name|voidp
operator|)
name|mf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|this_error
operator|&&
name|cp
operator|->
name|retry
condition|)
block|{
name|free_mntfs
argument_list|(
name|mf
argument_list|)
expr_stmt|;
name|mf
operator|=
name|cp
operator|->
name|mp
operator|->
name|am_mnt
operator|=
name|mf_retry
expr_stmt|;
comment|/*      * Not retrying again (so far)      */
name|cp
operator|->
name|retry
operator|=
name|FALSE
expr_stmt|;
name|cp
operator|->
name|tried
operator|=
name|FALSE
expr_stmt|;
comment|/*      * Start at the beginning.      * Rewind the location vector and      * reset the default options.      */
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"(skipping rewind)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/*      * Arrange that amfs_auto_bgmount is called      * after anything else happens.      */
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Arranging to retry mount of %s"
argument_list|,
name|cp
operator|->
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|sched_task
argument_list|(
name|amfs_auto_retry
argument_list|,
operator|(
name|voidp
operator|)
name|cp
argument_list|,
operator|(
name|voidp
operator|)
name|mf
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|callout
condition|)
name|untimeout
argument_list|(
name|cp
operator|->
name|callout
argument_list|)
expr_stmt|;
name|cp
operator|->
name|callout
operator|=
name|timeout
argument_list|(
name|RETRY_INTERVAL
argument_list|,
name|wakeup
argument_list|,
operator|(
name|voidp
operator|)
name|mf
argument_list|)
expr_stmt|;
name|cp
operator|->
name|mp
operator|->
name|am_ttl
operator|=
name|clocktime
argument_list|()
operator|+
name|RETRY_INTERVAL
expr_stmt|;
comment|/*      * Not done yet - so don't return anything      */
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|hard_error
operator|<
literal|0
operator|||
name|this_error
operator|==
literal|0
condition|)
name|hard_error
operator|=
name|this_error
expr_stmt|;
comment|/*    * Discard handle on duff filesystem.    * This should never happen since it    * should be caught by the case above.    */
if|if
condition|(
name|mf_retry
condition|)
block|{
if|if
condition|(
name|hard_error
condition|)
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"discarding a retry mntfs for %s"
argument_list|,
name|mf_retry
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
name|free_mntfs
argument_list|(
name|mf_retry
argument_list|)
expr_stmt|;
block|}
comment|/*    * If we get here, then either the mount succeeded or    * there is no more mount information available.    */
if|if
condition|(
name|hard_error
operator|<
literal|0
operator|&&
name|mp_error
condition|)
name|hard_error
operator|=
name|cp
operator|->
name|mp
operator|->
name|am_error
operator|=
name|mp_error
expr_stmt|;
if|if
condition|(
name|hard_error
operator|>
literal|0
condition|)
block|{
comment|/*      * Set a small(ish) timeout on an error node if      * the error was not a time out.      */
switch|switch
condition|(
name|hard_error
condition|)
block|{
case|case
name|ETIMEDOUT
case|:
case|case
name|EWOULDBLOCK
case|:
name|cp
operator|->
name|mp
operator|->
name|am_timeo
operator|=
literal|17
expr_stmt|;
break|break;
default|default:
name|cp
operator|->
name|mp
operator|->
name|am_timeo
operator|=
literal|5
expr_stmt|;
break|break;
block|}
name|new_ttl
argument_list|(
name|cp
operator|->
name|mp
argument_list|)
expr_stmt|;
block|}
comment|/*    * Make sure that the error value in the mntfs has a    * reasonable value.    */
if|if
condition|(
name|mf
operator|->
name|mf_error
operator|<
literal|0
condition|)
block|{
name|mf
operator|->
name|mf_error
operator|=
name|hard_error
expr_stmt|;
if|if
condition|(
name|hard_error
condition|)
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_ERROR
expr_stmt|;
block|}
comment|/*    * In any case we don't need the continuation any more    */
name|free_continuation
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
name|hard_error
return|;
block|}
end_function

begin_comment
comment|/*  * Automount interface to RPC lookup routine  * Find the corresponding entry and return  * the file handle for it.  */
end_comment

begin_function
name|am_node
modifier|*
name|amfs_auto_lookuppn
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|,
name|char
modifier|*
name|fname
parameter_list|,
name|int
modifier|*
name|error_return
parameter_list|,
name|int
name|op
parameter_list|)
block|{
name|am_node
modifier|*
name|ap
decl_stmt|,
modifier|*
name|new_mp
decl_stmt|,
modifier|*
name|ap_hung
decl_stmt|;
name|char
modifier|*
name|info
decl_stmt|;
comment|/* Mount info - where to get the file system */
name|char
modifier|*
modifier|*
name|ivec
decl_stmt|,
modifier|*
modifier|*
name|xivec
decl_stmt|;
comment|/* Split version of info */
name|char
modifier|*
name|auto_opts
decl_stmt|;
comment|/* Automount options */
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Error so far */
name|char
name|path_name
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
comment|/* General path name buffer */
name|char
modifier|*
name|pfname
decl_stmt|;
comment|/* Path for database lookup */
name|struct
name|continuation
modifier|*
name|cp
decl_stmt|;
comment|/* Continuation structure if need to mount */
name|int
name|in_progress
init|=
literal|0
decl_stmt|;
comment|/* # of (un)mount in progress */
name|char
modifier|*
name|dflts
decl_stmt|;
name|mntfs
modifier|*
name|mf
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"in amfs_auto_lookuppn"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/*    * If the server is shutting down    * then don't return information    * about the mount point.    */
if|if
condition|(
name|amd_state
operator|==
name|Finishing
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|mf
operator|=
name|mp
operator|->
name|am_mnt
operator|)
operator|==
literal|0
operator|||
name|mf
operator|->
name|mf_ops
operator|==
operator|&
name|amfs_direct_ops
condition|)
block|{
name|dlog
argument_list|(
literal|"%s mount ignored - going down"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dlog
argument_list|(
literal|"%s/%s mount ignored - going down"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
name|ereturn
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
block|}
comment|/*    * Handle special case of "." and ".."    */
if|if
condition|(
name|fname
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|fname
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
name|mp
return|;
comment|/* "." is the current node */
if|if
condition|(
name|fname
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|fname
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|am_parent
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|".. in %s gives %s"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|mp
operator|->
name|am_parent
operator|->
name|am_path
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
name|mp
operator|->
name|am_parent
return|;
comment|/* ".." is the parent node */
block|}
name|ereturn
argument_list|(
name|ESTALE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Check for valid key name.    * If it is invalid then pretend it doesn't exist.    */
if|if
condition|(
operator|!
name|valid_key
argument_list|(
name|fname
argument_list|)
condition|)
block|{
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"Key \"%s\" contains a disallowed character"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
block|}
comment|/*    * Expand key name.    * fname is now a private copy.    */
name|fname
operator|=
name|expand_key
argument_list|(
name|fname
argument_list|)
expr_stmt|;
for|for
control|(
name|ap_hung
operator|=
literal|0
operator|,
name|ap
operator|=
name|mp
operator|->
name|am_child
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|am_osib
control|)
block|{
comment|/*      * Otherwise search children of this node      */
if|if
condition|(
name|FSTREQ
argument_list|(
name|ap
operator|->
name|am_name
argument_list|,
name|fname
argument_list|)
condition|)
block|{
name|mf
operator|=
name|ap
operator|->
name|am_mnt
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|am_error
condition|)
block|{
name|error
operator|=
name|ap
operator|->
name|am_error
expr_stmt|;
continue|continue;
block|}
comment|/*        * If the error code is undefined then it must be        * in progress.        */
if|if
condition|(
name|mf
operator|->
name|mf_error
operator|<
literal|0
condition|)
goto|goto
name|in_progrss
goto|;
comment|/*        * Check for a hung node        */
if|if
condition|(
name|FSRV_ISDOWN
argument_list|(
name|mf
operator|->
name|mf_server
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"server hung"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|error
operator|=
name|ap
operator|->
name|am_error
expr_stmt|;
name|ap_hung
operator|=
name|ap
expr_stmt|;
continue|continue;
block|}
comment|/*        * If there was a previous error with this node        * then return that error code.        */
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_ERROR
condition|)
block|{
name|error
operator|=
name|mf
operator|->
name|mf_error
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_MOUNTED
operator|)
operator|||
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_UNMOUNTING
operator|)
condition|)
block|{
name|in_progrss
label|:
comment|/* 	 * If the fs is not mounted or it is unmounting then there 	 * is a background (un)mount in progress.  In this case 	 * we just drop the RPC request (return nil) and 	 * wait for a retry, by which time the (un)mount may 	 * have completed. 	 */
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"ignoring mount of %s in %s -- flags (%x) in progress"
argument_list|,
name|fname
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|,
name|mf
operator|->
name|mf_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|in_progress
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/*        * Otherwise we have a hit: return the current mount point.        */
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"matched %s in %s"
argument_list|,
name|fname
argument_list|,
name|ap
operator|->
name|am_path
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|XFREE
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
name|ap
return|;
block|}
block|}
if|if
condition|(
name|in_progress
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Waiting while %d mount(s) in progress"
argument_list|,
name|in_progress
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|XFREE
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*    * If an error occurred then return it.    */
if|if
condition|(
name|error
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|errno
operator|=
name|error
expr_stmt|;
comment|/* XXX */
name|dlog
argument_list|(
literal|"Returning error: %m"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|XFREE
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
comment|/*    * If doing a delete then don't create again!    */
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|VLOOK_DELETE
case|:
name|ereturn
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
case|case
name|VLOOK_CREATE
case|:
break|break;
default|default:
name|plog
argument_list|(
name|XLOG_FATAL
argument_list|,
literal|"Unknown op to amfs_auto_lookuppn: 0x%x"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
comment|/*    * If the server is going down then just return,    * don't try to mount any more file systems    */
if|if
condition|(
operator|(
name|int
operator|)
name|amd_state
operator|>=
operator|(
name|int
operator|)
name|Finishing
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"not found - server going down anyway"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|XFREE
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
block|}
comment|/*    * If we get there then this is a reference to an,    * as yet, unknown name so we need to search the mount    * map for it.    */
if|if
condition|(
name|mp
operator|->
name|am_pref
condition|)
block|{
name|sprintf
argument_list|(
name|path_name
argument_list|,
literal|"%s%s"
argument_list|,
name|mp
operator|->
name|am_pref
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|pfname
operator|=
name|path_name
expr_stmt|;
block|}
else|else
block|{
name|pfname
operator|=
name|fname
expr_stmt|;
block|}
name|mf
operator|=
name|mp
operator|->
name|am_mnt
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"will search map info in %s to find %s"
argument_list|,
name|mf
operator|->
name|mf_info
argument_list|,
name|pfname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/*    * Consult the oracle for some mount information.    * info is malloc'ed and belongs to this routine.    * It ends up being free'd in free_continuation().    *    * Note that this may return -1 indicating that information    * is not yet available.    */
name|error
operator|=
name|mapc_search
argument_list|(
operator|(
name|mnt_map
operator|*
operator|)
name|mf
operator|->
name|mf_private
argument_list|,
name|pfname
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|>
literal|0
condition|)
name|plog
argument_list|(
name|XLOG_MAP
argument_list|,
literal|"No map entry for %s"
argument_list|,
name|pfname
argument_list|)
expr_stmt|;
else|else
name|plog
argument_list|(
name|XLOG_MAP
argument_list|,
literal|"Waiting on map entry for %s"
argument_list|,
name|pfname
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"mount info is %s"
argument_list|,
name|info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/*    * Split info into an argument vector.    * The vector is malloc'ed and belongs to    * this routine.  It is free'd in free_continuation()    */
name|xivec
operator|=
name|ivec
operator|=
name|strsplit
argument_list|(
name|info
argument_list|,
literal|' '
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
comment|/*    * Default error code...    */
if|if
condition|(
name|ap_hung
condition|)
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
else|else
name|error
operator|=
name|ENOENT
expr_stmt|;
comment|/*    * Allocate a new map    */
name|new_mp
operator|=
name|exported_ap_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_mp
operator|==
literal|0
condition|)
block|{
name|XFREE
argument_list|(
name|xivec
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
name|ENOSPC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mf
operator|->
name|mf_auto
condition|)
name|auto_opts
operator|=
name|mf
operator|->
name|mf_auto
expr_stmt|;
else|else
name|auto_opts
operator|=
literal|""
expr_stmt|;
name|auto_opts
operator|=
name|strdup
argument_list|(
name|auto_opts
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"searching for /defaults entry"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|mapc_search
argument_list|(
operator|(
name|mnt_map
operator|*
operator|)
name|mf
operator|->
name|mf_private
argument_list|,
literal|"/defaults"
argument_list|,
operator|&
name|dflts
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|dfl
decl_stmt|;
name|char
modifier|*
modifier|*
name|rvec
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"/defaults gave %s"
argument_list|,
name|dflts
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
operator|*
name|dflts
operator|==
literal|'-'
condition|)
name|dfl
operator|=
name|dflts
operator|+
literal|1
expr_stmt|;
else|else
name|dfl
operator|=
name|dflts
expr_stmt|;
comment|/*      * Chop the defaults up      */
name|rvec
operator|=
name|strsplit
argument_list|(
name|dfl
argument_list|,
literal|' '
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
if|if
condition|(
name|gopt
operator|.
name|flags
operator|&
name|CFM_ENABLE_DEFAULT_SELECTORS
condition|)
block|{
comment|/*        * Pick whichever first entry matched the list of selectors.        * Strip the selectors from the string, and assign to dfl the        * rest of the string.        */
if|if
condition|(
name|rvec
condition|)
block|{
name|am_opts
name|ap
decl_stmt|;
name|am_ops
modifier|*
name|pt
decl_stmt|;
name|char
modifier|*
modifier|*
name|sp
init|=
name|rvec
decl_stmt|;
while|while
condition|(
operator|*
name|sp
condition|)
block|{
comment|/* loop until you find something, if any */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|am_opts
argument_list|)
argument_list|)
expr_stmt|;
name|pt
operator|=
name|ops_match
argument_list|(
operator|&
name|ap
argument_list|,
operator|*
name|sp
argument_list|,
literal|""
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
literal|"/defaults"
argument_list|,
name|mp
operator|->
name|am_parent
operator|->
name|am_mnt
operator|->
name|mf_info
argument_list|)
expr_stmt|;
name|free_opts
argument_list|(
operator|&
name|ap
argument_list|)
expr_stmt|;
comment|/* don't leak */
if|if
condition|(
name|pt
operator|==
operator|&
name|amfs_error_ops
condition|)
block|{
name|plog
argument_list|(
name|XLOG_MAP
argument_list|,
literal|"failed to match defaults for \"%s\""
argument_list|,
operator|*
name|sp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dfl
operator|=
name|strip_selectors
argument_list|(
operator|*
name|sp
argument_list|,
literal|"/defaults"
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_MAP
argument_list|,
literal|"matched default selectors \"%s\""
argument_list|,
name|dfl
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|sp
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* not enable_default_selectors */
comment|/*        * Extract first value        */
name|dfl
operator|=
name|rvec
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/*      * If there were any values at all...      */
if|if
condition|(
name|dfl
condition|)
block|{
comment|/*        * Log error if there were other values        */
if|if
condition|(
operator|!
operator|(
name|gopt
operator|.
name|flags
operator|&
name|CFM_ENABLE_DEFAULT_SELECTORS
operator|)
operator|&&
name|rvec
index|[
literal|1
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"/defaults chopped into %s"
argument_list|,
name|dfl
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|plog
argument_list|(
name|XLOG_USER
argument_list|,
literal|"More than a single value for /defaults in %s"
argument_list|,
name|mf
operator|->
name|mf_info
argument_list|)
expr_stmt|;
block|}
comment|/*        * Prepend to existing defaults if they exist,        * otherwise just use these defaults.        */
if|if
condition|(
operator|*
name|auto_opts
operator|&&
operator|*
name|dfl
condition|)
block|{
name|char
modifier|*
name|nopts
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|auto_opts
argument_list|)
operator|+
name|strlen
argument_list|(
name|dfl
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|nopts
argument_list|,
literal|"%s;%s"
argument_list|,
name|dfl
argument_list|,
name|auto_opts
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|auto_opts
argument_list|)
expr_stmt|;
name|auto_opts
operator|=
name|nopts
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|dfl
condition|)
block|{
name|auto_opts
operator|=
name|strealloc
argument_list|(
name|auto_opts
argument_list|,
name|dfl
argument_list|)
expr_stmt|;
block|}
block|}
name|XFREE
argument_list|(
name|dflts
argument_list|)
expr_stmt|;
comment|/*      * Don't need info vector any more      */
name|XFREE
argument_list|(
name|rvec
argument_list|)
expr_stmt|;
block|}
comment|/*    * Fill it in    */
name|init_map
argument_list|(
name|new_mp
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/*    * Put it in the table    */
name|insert_am
argument_list|(
name|new_mp
argument_list|,
name|mp
argument_list|)
expr_stmt|;
comment|/*    * Fill in some other fields,    * path and mount point.    *    * bugfix: do not prepend old am_path if direct map    *<wls@astro.umd.edu> William Sebok    */
name|new_mp
operator|->
name|am_path
operator|=
name|str3cat
argument_list|(
name|new_mp
operator|->
name|am_path
argument_list|,
name|mf
operator|->
name|mf_ops
operator|==
operator|&
name|amfs_direct_ops
condition|?
literal|""
else|:
name|mp
operator|->
name|am_path
argument_list|,
operator|*
name|fname
operator|==
literal|'/'
condition|?
literal|""
else|:
literal|"/"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"setting path to %s"
argument_list|,
name|new_mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/*    * Take private copy of pfname    */
name|pfname
operator|=
name|strdup
argument_list|(
name|pfname
argument_list|)
expr_stmt|;
comment|/*    * Construct a continuation    */
name|cp
operator|=
name|ALLOC
argument_list|(
expr|struct
name|continuation
argument_list|)
expr_stmt|;
name|cp
operator|->
name|callout
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|mp
operator|=
name|new_mp
expr_stmt|;
name|cp
operator|->
name|xivec
operator|=
name|xivec
expr_stmt|;
name|cp
operator|->
name|ivec
operator|=
name|ivec
expr_stmt|;
name|cp
operator|->
name|info
operator|=
name|info
expr_stmt|;
name|cp
operator|->
name|key
operator|=
name|pfname
expr_stmt|;
name|cp
operator|->
name|auto_opts
operator|=
name|auto_opts
expr_stmt|;
name|cp
operator|->
name|retry
operator|=
name|FALSE
expr_stmt|;
name|cp
operator|->
name|tried
operator|=
name|FALSE
expr_stmt|;
name|cp
operator|->
name|start
operator|=
name|clocktime
argument_list|()
expr_stmt|;
name|cp
operator|->
name|def_opts
operator|=
name|strdup
argument_list|(
name|auto_opts
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|voidp
operator|)
operator|&
name|cp
operator|->
name|fs_opts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cp
operator|->
name|fs_opts
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    * Try and mount the file system.  If this succeeds immediately (possible    * for a ufs file system) then return the attributes, otherwise just    * return an error.    */
name|error
operator|=
name|amfs_auto_bgmount
argument_list|(
name|cp
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|reschedule_timeout_mp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|XFREE
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
name|new_mp
return|;
block|}
comment|/*    * Code for quick reply.  If nfs_program_2_transp is set, then    * its the transp that's been passed down from nfs_program_2().    * If new_mp->am_transp is not already set, set it by copying in    * nfs_program_2_transp.  Once am_transp is set, quick_reply() can    * use it to send a reply to the client that requested this mount.    */
if|if
condition|(
name|nfs_program_2_transp
operator|&&
operator|!
name|new_mp
operator|->
name|am_transp
condition|)
block|{
name|new_mp
operator|->
name|am_transp
operator|=
operator|(
name|SVCXPRT
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SVCXPRT
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|new_mp
operator|->
name|am_transp
operator|)
operator|=
operator|*
name|nfs_program_2_transp
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|&&
operator|(
name|new_mp
operator|->
name|am_mnt
operator|->
name|mf_ops
operator|==
operator|&
name|amfs_error_ops
operator|)
condition|)
name|new_mp
operator|->
name|am_error
operator|=
name|error
expr_stmt|;
name|assign_error_mntfs
argument_list|(
name|new_mp
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Locate next node in sibling list which is mounted  * and is not an error node.  */
end_comment

begin_function
name|am_node
modifier|*
name|next_nonerror_node
parameter_list|(
name|am_node
modifier|*
name|xp
parameter_list|)
block|{
name|mntfs
modifier|*
name|mf
decl_stmt|;
comment|/*    * Bug report (7/12/89) from Rein Tollevik<rein@ifi.uio.no>    * Fixes a race condition when mounting direct automounts.    * Also fixes a problem when doing a readdir on a directory    * containing hung automounts.    */
while|while
condition|(
name|xp
operator|&&
operator|(
operator|!
operator|(
name|mf
operator|=
name|xp
operator|->
name|am_mnt
operator|)
operator|||
comment|/* No mounted filesystem */
name|mf
operator|->
name|mf_error
operator|!=
literal|0
operator|||
comment|/* There was a mntfs error */
name|xp
operator|->
name|am_error
operator|!=
literal|0
operator|||
comment|/* There was a mount error */
operator|!
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_MOUNTED
operator|)
operator|||
comment|/* The fs is not mounted */
operator|(
name|mf
operator|->
name|mf_server
operator|->
name|fs_flags
operator|&
name|FSF_DOWN
operator|)
operator|)
comment|/* The fs may be down */
condition|)
name|xp
operator|=
name|xp
operator|->
name|am_osib
expr_stmt|;
return|return
name|xp
return|;
block|}
end_function

begin_comment
comment|/*  * This readdir function which call a special version of it that allows  * browsing if browsable_dirs=yes was set on the map.  */
end_comment

begin_function
name|int
name|amfs_auto_readdir
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|,
name|nfscookie
name|cookie
parameter_list|,
name|nfsdirlist
modifier|*
name|dp
parameter_list|,
name|nfsentry
modifier|*
name|ep
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|u_int
name|gen
init|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|cookie
decl_stmt|;
name|am_node
modifier|*
name|xp
decl_stmt|;
name|mntent_t
name|mnt
decl_stmt|;
name|dp
operator|->
name|dl_eof
operator|=
name|FALSE
expr_stmt|;
comment|/* assume readdir not done */
comment|/* check if map is browsable */
if|if
condition|(
name|mp
operator|->
name|am_mnt
operator|&&
name|mp
operator|->
name|am_mnt
operator|->
name|mf_mopts
condition|)
block|{
name|mnt
operator|.
name|mnt_opts
operator|=
name|mp
operator|->
name|am_mnt
operator|->
name|mf_mopts
expr_stmt|;
if|if
condition|(
name|hasmntopt
argument_list|(
operator|&
name|mnt
argument_list|,
literal|"fullybrowsable"
argument_list|)
condition|)
return|return
name|amfs_auto_readdir_browsable
argument_list|(
name|mp
argument_list|,
name|cookie
argument_list|,
name|dp
argument_list|,
name|ep
argument_list|,
name|count
argument_list|,
name|TRUE
argument_list|)
return|;
if|if
condition|(
name|hasmntopt
argument_list|(
operator|&
name|mnt
argument_list|,
literal|"browsable"
argument_list|)
condition|)
return|return
name|amfs_auto_readdir_browsable
argument_list|(
name|mp
argument_list|,
name|cookie
argument_list|,
name|dp
argument_list|,
name|ep
argument_list|,
name|count
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
if|if
condition|(
name|gen
operator|==
literal|0
condition|)
block|{
comment|/*      * In the default instance (which is used to start a search) we return      * "." and "..".      *      * This assumes that the count is big enough to allow both "." and ".."      * to be returned in a single packet.  If it isn't (which would be      * fairly unbelievable) then tough.      */
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"amfs_auto_readdir: default search"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/*      * Check for enough room.  This is extremely approximate but is more      * than enough space.  Really need 2 times:      *      4byte fileid      *      4byte cookie      *      4byte name length      *      4byte name      * plus the dirlist structure */
if|if
condition|(
name|count
operator|<
operator|(
literal|2
operator|*
operator|(
literal|2
operator|*
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|".."
argument_list|)
operator|+
literal|4
operator|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|dp
argument_list|)
operator|)
operator|)
condition|)
return|return
name|EINVAL
return|;
name|xp
operator|=
name|next_nonerror_node
argument_list|(
name|mp
operator|->
name|am_child
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dl_entries
operator|=
name|ep
expr_stmt|;
comment|/* construct "." */
name|ep
index|[
literal|0
index|]
operator|.
name|ne_fileid
operator|=
name|mp
operator|->
name|am_gen
expr_stmt|;
name|ep
index|[
literal|0
index|]
operator|.
name|ne_name
operator|=
literal|"."
expr_stmt|;
name|ep
index|[
literal|0
index|]
operator|.
name|ne_nextentry
operator|=
operator|&
name|ep
index|[
literal|1
index|]
expr_stmt|;
operator|*
operator|(
name|u_int
operator|*
operator|)
name|ep
index|[
literal|0
index|]
operator|.
name|ne_cookie
operator|=
literal|0
expr_stmt|;
comment|/* construct ".." */
if|if
condition|(
name|mp
operator|->
name|am_parent
condition|)
name|ep
index|[
literal|1
index|]
operator|.
name|ne_fileid
operator|=
name|mp
operator|->
name|am_parent
operator|->
name|am_gen
expr_stmt|;
else|else
name|ep
index|[
literal|1
index|]
operator|.
name|ne_fileid
operator|=
name|mp
operator|->
name|am_gen
expr_stmt|;
name|ep
index|[
literal|1
index|]
operator|.
name|ne_name
operator|=
literal|".."
expr_stmt|;
name|ep
index|[
literal|1
index|]
operator|.
name|ne_nextentry
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|u_int
operator|*
operator|)
name|ep
index|[
literal|1
index|]
operator|.
name|ne_cookie
operator|=
operator|(
name|xp
condition|?
name|xp
operator|->
name|am_gen
else|:
name|DOT_DOT_COOKIE
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|xp
condition|)
name|dp
operator|->
name|dl_eof
operator|=
name|TRUE
expr_stmt|;
comment|/* by default assume readdir done */
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"amfs_auto_readdir: real child"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|gen
operator|==
name|DOT_DOT_COOKIE
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"amfs_auto_readdir: End of readdir in %s"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|dp
operator|->
name|dl_eof
operator|=
name|TRUE
expr_stmt|;
name|dp
operator|->
name|dl_entries
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* non-browsable directories code */
name|xp
operator|=
name|mp
operator|->
name|am_child
expr_stmt|;
while|while
condition|(
name|xp
operator|&&
name|xp
operator|->
name|am_gen
operator|!=
name|gen
condition|)
name|xp
operator|=
name|xp
operator|->
name|am_osib
expr_stmt|;
if|if
condition|(
name|xp
condition|)
block|{
name|int
name|nbytes
init|=
name|count
operator|/
literal|2
decl_stmt|;
comment|/* conservative */
name|int
name|todo
init|=
name|MAX_READDIR_ENTRIES
decl_stmt|;
name|dp
operator|->
name|dl_entries
operator|=
name|ep
expr_stmt|;
do|do
block|{
name|am_node
modifier|*
name|xp_next
init|=
name|next_nonerror_node
argument_list|(
name|xp
operator|->
name|am_osib
argument_list|)
decl_stmt|;
if|if
condition|(
name|xp_next
condition|)
block|{
operator|*
operator|(
name|u_int
operator|*
operator|)
name|ep
operator|->
name|ne_cookie
operator|=
name|xp_next
operator|->
name|am_gen
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
name|u_int
operator|*
operator|)
name|ep
operator|->
name|ne_cookie
operator|=
name|DOT_DOT_COOKIE
expr_stmt|;
name|dp
operator|->
name|dl_eof
operator|=
name|TRUE
expr_stmt|;
block|}
name|ep
operator|->
name|ne_fileid
operator|=
name|xp
operator|->
name|am_gen
expr_stmt|;
name|ep
operator|->
name|ne_name
operator|=
name|xp
operator|->
name|am_name
expr_stmt|;
name|nbytes
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|am_name
condition|)
name|nbytes
operator|-=
name|strlen
argument_list|(
name|xp
operator|->
name|am_name
argument_list|)
expr_stmt|;
name|xp
operator|=
name|xp_next
expr_stmt|;
if|if
condition|(
name|nbytes
operator|>
literal|0
operator|&&
operator|!
name|dp
operator|->
name|dl_eof
operator|&&
name|todo
operator|>
literal|1
condition|)
block|{
name|ep
operator|->
name|ne_nextentry
operator|=
name|ep
operator|+
literal|1
expr_stmt|;
name|ep
operator|++
expr_stmt|;
operator|--
name|todo
expr_stmt|;
block|}
else|else
block|{
name|todo
operator|=
literal|0
expr_stmt|;
block|}
block|}
do|while
condition|(
name|todo
operator|>
literal|0
condition|)
do|;
name|ep
operator|->
name|ne_nextentry
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ESTALE
return|;
block|}
end_function

begin_comment
comment|/* This one is called only if map is browsable */
end_comment

begin_function
specifier|static
name|int
name|amfs_auto_readdir_browsable
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|,
name|nfscookie
name|cookie
parameter_list|,
name|nfsdirlist
modifier|*
name|dp
parameter_list|,
name|nfsentry
modifier|*
name|ep
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|fully_browsable
parameter_list|)
block|{
name|u_int
name|gen
init|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|cookie
decl_stmt|;
name|int
name|chain_length
decl_stmt|,
name|i
decl_stmt|;
specifier|static
name|nfsentry
modifier|*
name|te
decl_stmt|,
modifier|*
name|te_next
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_READDIR
name|nfsentry
modifier|*
name|ne
decl_stmt|;
specifier|static
name|int
name|j
decl_stmt|;
endif|#
directive|endif
comment|/* DEBUG_READDIR */
name|dp
operator|->
name|dl_eof
operator|=
name|FALSE
expr_stmt|;
comment|/* assume readdir not done */
ifdef|#
directive|ifdef
name|DEBUG_READDIR
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"amfs_auto_readdir_browsable gen=%u, count=%d"
argument_list|,
name|gen
argument_list|,
name|count
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_READDIR */
if|if
condition|(
name|gen
operator|==
literal|0
condition|)
block|{
comment|/*      * In the default instance (which is used to start a search) we return      * "." and "..".      *      * This assumes that the count is big enough to allow both "." and ".."      * to be returned in a single packet.  If it isn't (which would be      * fairly unbelievable) then tough.      */
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"amfs_auto_readdir_browsable: default search"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/*      * Check for enough room.  This is extremely approximate but is more      * than enough space.  Really need 2 times:      *      4byte fileid      *      4byte cookie      *      4byte name length      *      4byte name      * plus the dirlist structure */
if|if
condition|(
name|count
operator|<
operator|(
literal|2
operator|*
operator|(
literal|2
operator|*
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|".."
argument_list|)
operator|+
literal|4
operator|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|dp
argument_list|)
operator|)
operator|)
condition|)
return|return
name|EINVAL
return|;
comment|/*      * compute # of entries to send in this chain.      * heuristics: 128 bytes per entry.      * This is too much probably, but it seems to work better because      * of the re-entrant nature of nfs_readdir, and esp. on systems      * like OpenBSD 2.2.      */
name|chain_length
operator|=
name|count
operator|/
literal|128
expr_stmt|;
comment|/* reset static state counters */
name|te
operator|=
name|te_next
operator|=
name|NULL
expr_stmt|;
name|dp
operator|->
name|dl_entries
operator|=
name|ep
expr_stmt|;
comment|/* construct "." */
name|ep
index|[
literal|0
index|]
operator|.
name|ne_fileid
operator|=
name|mp
operator|->
name|am_gen
expr_stmt|;
name|ep
index|[
literal|0
index|]
operator|.
name|ne_name
operator|=
literal|"."
expr_stmt|;
name|ep
index|[
literal|0
index|]
operator|.
name|ne_nextentry
operator|=
operator|&
name|ep
index|[
literal|1
index|]
expr_stmt|;
operator|*
operator|(
name|u_int
operator|*
operator|)
name|ep
index|[
literal|0
index|]
operator|.
name|ne_cookie
operator|=
literal|0
expr_stmt|;
comment|/* construct ".." */
if|if
condition|(
name|mp
operator|->
name|am_parent
condition|)
name|ep
index|[
literal|1
index|]
operator|.
name|ne_fileid
operator|=
name|mp
operator|->
name|am_parent
operator|->
name|am_gen
expr_stmt|;
else|else
name|ep
index|[
literal|1
index|]
operator|.
name|ne_fileid
operator|=
name|mp
operator|->
name|am_gen
expr_stmt|;
name|ep
index|[
literal|1
index|]
operator|.
name|ne_name
operator|=
literal|".."
expr_stmt|;
name|ep
index|[
literal|1
index|]
operator|.
name|ne_nextentry
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|u_int
operator|*
operator|)
name|ep
index|[
literal|1
index|]
operator|.
name|ne_cookie
operator|=
name|DOT_DOT_COOKIE
expr_stmt|;
comment|/*      * If map is browsable, call a function make_entry_chain() to construct      * a linked list of unmounted keys, and return it.  Then link the chain      * to the regular list.  Get the chain only once, but return      * chunks of it each time.      */
name|te
operator|=
name|make_entry_chain
argument_list|(
name|mp
argument_list|,
name|dp
operator|->
name|dl_entries
argument_list|,
name|fully_browsable
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|te
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|DEBUG_READDIR
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|ne
operator|=
name|te
init|;
name|ne
condition|;
name|ne
operator|=
name|ne
operator|->
name|ne_nextentry
control|)
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"gen1 key %4d \"%s\""
argument_list|,
name|j
operator|++
argument_list|,
name|ne
operator|->
name|ne_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_READDIR */
comment|/* return only "chain_length" entries */
name|te_next
operator|=
name|te
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|chain_length
condition|;
operator|++
name|i
control|)
block|{
name|te_next
operator|=
name|te_next
operator|->
name|ne_nextentry
expr_stmt|;
if|if
condition|(
operator|!
name|te_next
condition|)
break|break;
block|}
if|if
condition|(
name|te_next
condition|)
block|{
name|nfsentry
modifier|*
name|te_saved
init|=
name|te_next
operator|->
name|ne_nextentry
decl_stmt|;
name|te_next
operator|->
name|ne_nextentry
operator|=
name|NULL
expr_stmt|;
comment|/* terminate "te" chain */
name|te_next
operator|=
name|te_saved
expr_stmt|;
comment|/* save rest of "te" for next iteration */
name|dp
operator|->
name|dl_eof
operator|=
name|FALSE
expr_stmt|;
comment|/* tell readdir there's more */
block|}
else|else
block|{
name|dp
operator|->
name|dl_eof
operator|=
name|TRUE
expr_stmt|;
comment|/* tell readdir that's it */
block|}
name|ep
index|[
literal|1
index|]
operator|.
name|ne_nextentry
operator|=
name|te
expr_stmt|;
comment|/* append this chunk of "te" chain */
ifdef|#
directive|ifdef
name|DEBUG_READDIR
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|ne
operator|=
name|te
init|;
name|ne
condition|;
name|ne
operator|=
name|ne
operator|->
name|ne_nextentry
control|)
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"gen2 key %4d \"%s\""
argument_list|,
name|j
operator|++
argument_list|,
name|ne
operator|->
name|ne_name
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|ne
operator|=
name|ep
init|;
name|ne
condition|;
name|ne
operator|=
name|ne
operator|->
name|ne_nextentry
control|)
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"gen2+ key %4d \"%s\" fi=%d ck=%d"
argument_list|,
name|j
operator|++
argument_list|,
name|ne
operator|->
name|ne_name
argument_list|,
name|ne
operator|->
name|ne_fileid
argument_list|,
operator|*
operator|(
name|u_int
operator|*
operator|)
name|ne
operator|->
name|ne_cookie
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"EOF is %d"
argument_list|,
name|dp
operator|->
name|dl_eof
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_READDIR */
return|return
literal|0
return|;
block|}
comment|/* end of "if (gen == 0)" statement */
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"amfs_auto_readdir_browsable: real child"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|gen
operator|==
name|DOT_DOT_COOKIE
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"amfs_auto_readdir_browsable: End of readdir in %s"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|dp
operator|->
name|dl_eof
operator|=
name|TRUE
expr_stmt|;
name|dp
operator|->
name|dl_entries
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*    * If browsable directories, then continue serving readdir() with another    * chunk of entries, starting from where we left off (when gen was equal    * to 0).  Once again, assume last chunk served to readdir.    */
name|dp
operator|->
name|dl_eof
operator|=
name|TRUE
expr_stmt|;
name|dp
operator|->
name|dl_entries
operator|=
name|ep
expr_stmt|;
name|te
operator|=
name|te_next
expr_stmt|;
comment|/* reset 'te' from last saved te_next */
if|if
condition|(
operator|!
name|te
condition|)
block|{
comment|/* another indicator of end of readdir */
name|dp
operator|->
name|dl_entries
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*    * compute # of entries to send in this chain.    * heuristics: 128 bytes per entry.    */
name|chain_length
operator|=
name|count
operator|/
literal|128
expr_stmt|;
comment|/* return only "chain_length" entries */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|chain_length
condition|;
operator|++
name|i
control|)
block|{
name|te_next
operator|=
name|te_next
operator|->
name|ne_nextentry
expr_stmt|;
if|if
condition|(
operator|!
name|te_next
condition|)
break|break;
block|}
if|if
condition|(
name|te_next
condition|)
block|{
name|nfsentry
modifier|*
name|te_saved
init|=
name|te_next
operator|->
name|ne_nextentry
decl_stmt|;
name|te_next
operator|->
name|ne_nextentry
operator|=
name|NULL
expr_stmt|;
comment|/* terminate "te" chain */
name|te_next
operator|=
name|te_saved
expr_stmt|;
comment|/* save rest of "te" for next iteration */
name|dp
operator|->
name|dl_eof
operator|=
name|FALSE
expr_stmt|;
comment|/* tell readdir there's more */
block|}
name|ep
operator|=
name|te
expr_stmt|;
comment|/* send next chunk of "te" chain */
name|dp
operator|->
name|dl_entries
operator|=
name|ep
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_READDIR
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"dl_entries=0x%x, te_next=0x%x, dl_eof=%d"
argument_list|,
operator|(
name|int
operator|)
name|dp
operator|->
name|dl_entries
argument_list|,
operator|(
name|int
operator|)
name|te_next
argument_list|,
name|dp
operator|->
name|dl_eof
argument_list|)
expr_stmt|;
for|for
control|(
name|ne
operator|=
name|te
init|;
name|ne
condition|;
name|ne
operator|=
name|ne
operator|->
name|ne_nextentry
control|)
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"gen3 key %4d \"%s\""
argument_list|,
name|j
operator|++
argument_list|,
name|ne
operator|->
name|ne_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_READDIR */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|amfs_auto_fmount
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
name|mntfs
modifier|*
name|mf
init|=
name|mp
operator|->
name|am_mnt
decl_stmt|;
return|return
call|(
modifier|*
name|mf
operator|->
name|mf_ops
operator|->
name|fmount_fs
call|)
argument_list|(
name|mf
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|amfs_auto_fumount
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
name|mntfs
modifier|*
name|mf
init|=
name|mp
operator|->
name|am_mnt
decl_stmt|;
return|return
call|(
modifier|*
name|mf
operator|->
name|mf_ops
operator|->
name|fumount_fs
call|)
argument_list|(
name|mf
argument_list|)
return|;
block|}
end_function

end_unit

