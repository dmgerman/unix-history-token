begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997-1998 Erez Zadok  * Copyright (c) 1990 Jan-Simon Pendry  * Copyright (c) 1990 Imperial College of Science, Technology& Medicine  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry at Imperial College, London.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgment:  *      This product includes software developed by the University of  *      California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      %W% (Berkeley) %G%  *  * $Id: ops_autofs.c,v 1.2 1998/12/27 06:24:47 ezk Exp $  *  */
end_comment

begin_comment
comment|/*  * Automounter filesystem  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<am_defs.h>
end_include

begin_include
include|#
directive|include
file|<amd.h>
end_include

begin_comment
comment|/*  * KLUDGE: wrap whole file in HAVE_FS_AUTOFS, because  * not all systems with an automounter file system are supported  * by am-utils yet...  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FS_AUTOFS
end_ifdef

begin_comment
comment|/*  * MACROS:  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|AUTOFS_NULL
end_ifndef

begin_define
define|#
directive|define
name|AUTOFS_NULL
value|((u_long)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not AUTOFS_NULL */
end_comment

begin_comment
comment|/*  * VARIABLES:  */
end_comment

begin_comment
comment|/* forward declarations */
end_comment

begin_function_decl
specifier|static
name|int
name|mount_autofs
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|,
name|char
modifier|*
name|opts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|autofs_mount_1_svc
parameter_list|(
name|struct
name|mntrequest
modifier|*
name|mr
parameter_list|,
name|struct
name|mntres
modifier|*
name|result
parameter_list|,
name|struct
name|authunix_parms
modifier|*
name|cred
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|autofs_unmount_1_svc
parameter_list|(
name|struct
name|umntrequest
modifier|*
name|ur
parameter_list|,
name|struct
name|umntres
modifier|*
name|result
parameter_list|,
name|struct
name|authunix_parms
modifier|*
name|cred
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* external declarations */
end_comment

begin_function_decl
specifier|extern
name|bool_t
name|xdr_mntrequest
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|mntrequest
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|bool_t
name|xdr_mntres
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|mntres
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|bool_t
name|xdr_umntrequest
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|umntrequest
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|bool_t
name|xdr_umntres
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|umntres
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * STRUCTURES:  */
end_comment

begin_comment
comment|/* Sun's kernel-based automounter-supporting file system */
end_comment

begin_decl_stmt
name|am_ops
name|autofs_ops
init|=
block|{
literal|"autofs"
block|,
name|amfs_auto_match
block|,
literal|0
block|,
comment|/* amfs_auto_init */
name|autofs_mount
block|,
literal|0
block|,
name|autofs_umount
block|,
literal|0
block|,
name|amfs_auto_lookuppn
block|,
name|amfs_auto_readdir
block|,
comment|/* browsable version of readdir() */
literal|0
block|,
comment|/* autofs_readlink */
name|autofs_mounted
block|,
literal|0
block|,
comment|/* autofs_umounted */
name|find_amfs_auto_srvr
block|,
name|FS_MKMNT
operator||
name|FS_NOTIMEOUT
operator||
name|FS_BACKGROUND
operator||
name|FS_AMQINFO
operator||
name|FS_DIRECTORY
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/****************************************************************************  *** FUNCTIONS                                                            ***  ****************************************************************************/
end_comment

begin_comment
comment|/*  * Mount the top-level using autofs  */
end_comment

begin_function
name|int
name|autofs_mount
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
name|mntfs
modifier|*
name|mf
init|=
name|mp
operator|->
name|am_mnt
decl_stmt|;
name|struct
name|stat
name|stb
decl_stmt|;
name|char
name|opts
index|[
literal|256
index|]
decl_stmt|,
name|preopts
index|[
literal|256
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
modifier|*
name|mnttype
decl_stmt|;
comment|/*    * Mounting the automounter.    * Make sure the mount directory exists, construct    * the mount options and call the mount_autofs routine.    */
if|if
condition|(
name|stat
argument_list|(
name|mp
operator|->
name|am_path
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|errno
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|stb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFDIR
condition|)
block|{
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"%s is not a directory"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
return|return
name|ENOTDIR
return|;
block|}
if|if
condition|(
name|mf
operator|->
name|mf_ops
operator|==
operator|&
name|autofs_ops
condition|)
name|mnttype
operator|=
literal|"indirect"
expr_stmt|;
elseif|else
if|if
condition|(
name|mf
operator|->
name|mf_ops
operator|==
operator|&
name|amfs_direct_ops
condition|)
name|mnttype
operator|=
literal|"direct"
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_AM_FS_UNION
elseif|else
if|if
condition|(
name|mf
operator|->
name|mf_ops
operator|==
operator|&
name|amfs_union_ops
condition|)
name|mnttype
operator|=
literal|"union"
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_AM_FS_UNION */
else|else
name|mnttype
operator|=
literal|"auto"
expr_stmt|;
comment|/*    * Construct some mount options:    *    * Tack on magic map=<mapname> option in mtab to emulate    * SunOS automounter behavior.    */
name|preopts
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|MNTTAB_OPT_INTR
name|strcat
argument_list|(
name|preopts
argument_list|,
name|MNTTAB_OPT_INTR
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|preopts
argument_list|,
literal|","
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_OPT_INTR */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_IGNORE
name|strcat
argument_list|(
name|preopts
argument_list|,
name|MNTTAB_OPT_IGNORE
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|preopts
argument_list|,
literal|","
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_OPT_IGNORE */
name|sprintf
argument_list|(
name|opts
argument_list|,
literal|"%s%s,%s=%d,%s=%d,%s=%d,%s,map=%s"
argument_list|,
name|preopts
argument_list|,
name|MNTTAB_OPT_RW
argument_list|,
name|MNTTAB_OPT_PORT
argument_list|,
name|nfs_port
argument_list|,
name|MNTTAB_OPT_TIMEO
argument_list|,
name|gopt
operator|.
name|amfs_auto_timeo
argument_list|,
name|MNTTAB_OPT_RETRANS
argument_list|,
name|gopt
operator|.
name|amfs_auto_retrans
argument_list|,
name|mnttype
argument_list|,
name|mf
operator|->
name|mf_info
argument_list|)
expr_stmt|;
comment|/* now do the mount */
name|error
operator|=
name|mount_autofs
argument_list|(
name|mf
operator|->
name|mf_mount
argument_list|,
name|opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|errno
operator|=
name|error
expr_stmt|;
name|plog
argument_list|(
name|XLOG_FATAL
argument_list|,
literal|"mount_autofs: %m"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|autofs_mounted
parameter_list|(
name|mntfs
modifier|*
name|mf
parameter_list|)
block|{
name|amfs_auto_mkcacheref
argument_list|(
name|mf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unmount a top-level automount node  */
end_comment

begin_function
name|int
name|autofs_umount
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|stat
name|stb
decl_stmt|;
comment|/*    * The lstat is needed if this mount is type=direct.  When that happens,    * the kernel cache gets confused between the underlying type (dir) and    * the mounted type (link) and so needs to be re-synced before the    * unmount.  This is all because the unmount system call follows links and    * so can't actually unmount a link (stupid!).  It was noted that doing an    * ls -ld of the mount point to see why things were not working actually    * fixed the problem - so simulate an ls -ld here.    */
if|if
condition|(
name|lstat
argument_list|(
name|mp
operator|->
name|am_path
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"lstat(%s): %m"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
name|error
operator|=
name|UMOUNT_FS
argument_list|(
name|mp
operator|->
name|am_path
argument_list|,
name|mnttab_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EBUSY
operator|&&
name|mp
operator|->
name|am_flags
operator|&
name|AMF_AUTOFS
condition|)
block|{
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"autofs_unmount of %s busy (autofs). exit"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* fake unmount was ok */
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Mount an automounter directory.  * The automounter is connected into the system  * as a user-level NFS server.  mount_autofs constructs  * the necessary NFS parameters to be given to the  * kernel so that it will talk back to us.  */
end_comment

begin_function
specifier|static
name|int
name|mount_autofs
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|,
name|char
modifier|*
name|opts
parameter_list|)
block|{
name|char
name|fs_hostname
index|[
name|MAXHOSTNAMELEN
operator|+
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|map_opt
decl_stmt|,
name|buf
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
name|int
name|retry
decl_stmt|,
name|error
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|utsname
name|utsname
decl_stmt|;
name|mntent_t
name|mnt
decl_stmt|;
name|autofs_args_t
name|autofs_args
decl_stmt|;
name|MTYPE_TYPE
name|type
init|=
name|MOUNT_TYPE_AUTOFS
decl_stmt|;
name|memset
argument_list|(
operator|(
name|voidp
operator|)
operator|&
name|autofs_args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|autofs_args
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Paranoid */
name|memset
argument_list|(
operator|(
name|voidp
operator|)
operator|&
name|mnt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mnt
argument_list|)
argument_list|)
expr_stmt|;
name|mnt
operator|.
name|mnt_dir
operator|=
name|dir
expr_stmt|;
name|mnt
operator|.
name|mnt_fsname
operator|=
name|pid_fsname
expr_stmt|;
name|mnt
operator|.
name|mnt_opts
operator|=
name|opts
expr_stmt|;
name|mnt
operator|.
name|mnt_type
operator|=
name|type
expr_stmt|;
name|retry
operator|=
name|hasmntval
argument_list|(
operator|&
name|mnt
argument_list|,
literal|"retry"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry
operator|<=
literal|0
condition|)
name|retry
operator|=
literal|2
expr_stmt|;
comment|/* XXX */
comment|/*    * SET MOUNT ARGS    */
if|if
condition|(
name|uname
argument_list|(
operator|&
name|utsname
argument_list|)
operator|<
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"localhost.autofs"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
name|utsname
operator|.
name|nodename
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|".autofs"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_FIELD_AUTOFS_ARGS_T_ADDR
name|autofs_args
operator|.
name|addr
operator|.
name|buf
operator|=
name|buf
expr_stmt|;
name|autofs_args
operator|.
name|addr
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|autofs_args
operator|.
name|addr
operator|.
name|buf
argument_list|)
expr_stmt|;
name|autofs_args
operator|.
name|addr
operator|.
name|maxlen
operator|=
name|autofs_args
operator|.
name|addr
operator|.
name|len
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_FIELD_AUTOFS_ARGS_T_ADDR */
name|autofs_args
operator|.
name|path
operator|=
name|dir
expr_stmt|;
name|autofs_args
operator|.
name|opts
operator|=
name|opts
expr_stmt|;
name|map_opt
operator|=
name|hasmntopt
argument_list|(
operator|&
name|mnt
argument_list|,
literal|"map"
argument_list|)
expr_stmt|;
if|if
condition|(
name|map_opt
condition|)
block|{
name|map_opt
operator|+=
sizeof|sizeof
argument_list|(
literal|"map="
argument_list|)
expr_stmt|;
comment|/* skip the "map=" */
if|if
condition|(
name|map_opt
operator|==
name|NULL
condition|)
block|{
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"map= has a null map name. reset to amd.unknown"
argument_list|)
expr_stmt|;
name|map_opt
operator|=
literal|"amd.unknown"
expr_stmt|;
block|}
block|}
name|autofs_args
operator|.
name|map
operator|=
name|map_opt
expr_stmt|;
comment|/* XXX: these I set arbitrarily... */
name|autofs_args
operator|.
name|mount_to
operator|=
literal|300
expr_stmt|;
name|autofs_args
operator|.
name|rpc_to
operator|=
literal|60
expr_stmt|;
name|autofs_args
operator|.
name|direct
operator|=
literal|0
expr_stmt|;
comment|/*    * Make a ``hostname'' string for the kernel    */
name|sprintf
argument_list|(
name|fs_hostname
argument_list|,
literal|"pid%ld@%s:%s"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|foreground
condition|?
name|am_mypid
else|:
name|getppid
argument_list|()
argument_list|)
argument_list|,
name|am_get_hostname
argument_list|()
argument_list|,
name|dir
argument_list|)
expr_stmt|;
comment|/*    * Most kernels have a name length restriction.    */
if|if
condition|(
name|strlen
argument_list|(
name|fs_hostname
argument_list|)
operator|>=
name|MAXHOSTNAMELEN
condition|)
name|strcpy
argument_list|(
name|fs_hostname
operator|+
name|MAXHOSTNAMELEN
operator|-
literal|3
argument_list|,
literal|".."
argument_list|)
expr_stmt|;
comment|/*    * Finally we can compute the mount flags set above.    */
name|flags
operator|=
name|compute_mount_flags
argument_list|(
operator|&
name|mnt
argument_list|)
expr_stmt|;
comment|/*    * This is it!  Here we try to mount amd on its mount points.    */
name|error
operator|=
name|mount_fs
argument_list|(
operator|&
name|mnt
argument_list|,
name|flags
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|autofs_args
argument_list|,
name|retry
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|mnttab_file_name
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/* autofs program dispatcher */
end_comment

begin_function
name|void
name|autofs_program_1
parameter_list|(
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|,
name|SVCXPRT
modifier|*
name|transp
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
union|union
block|{
name|mntrequest
name|autofs_mount_1_arg
decl_stmt|;
name|umntrequest
name|autofs_umount_1_arg
decl_stmt|;
block|}
name|argument
union|;
union|union
block|{
name|mntres
name|mount_res
decl_stmt|;
name|umntres
name|umount_res
decl_stmt|;
block|}
name|result
union|;
name|bool_t
argument_list|(
operator|*
name|xdr_argument
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|xdr_result
argument_list|)
argument_list|()
decl_stmt|;
name|int
function_decl|(
modifier|*
name|local
function_decl|)
parameter_list|()
function_decl|;
switch|switch
condition|(
name|rqstp
operator|->
name|rq_proc
condition|)
block|{
case|case
name|AUTOFS_NULL
case|:
name|svc_sendreply
argument_list|(
name|transp
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_void
argument_list|,
operator|(
name|SVC_IN_ARG_TYPE
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return;
case|case
name|AUTOFS_MOUNT
case|:
name|xdr_argument
operator|=
name|xdr_mntrequest
expr_stmt|;
name|xdr_result
operator|=
name|xdr_mntres
expr_stmt|;
name|local
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|autofs_mount_1_svc
expr_stmt|;
break|break;
case|case
name|AUTOFS_UNMOUNT
case|:
name|xdr_argument
operator|=
name|xdr_umntrequest
expr_stmt|;
name|xdr_result
operator|=
name|xdr_umntres
expr_stmt|;
name|local
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|autofs_unmount_1_svc
expr_stmt|;
break|break;
default|default:
name|svcerr_noproc
argument_list|(
name|transp
argument_list|)
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|argument
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|argument
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svc_getargs
argument_list|(
name|transp
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_argument
argument_list|,
operator|(
name|SVC_IN_ARG_TYPE
operator|)
operator|&
name|argument
argument_list|)
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"AUTOFS xdr decode failed for %d %d %d"
argument_list|,
name|rqstp
operator|->
name|rq_prog
argument_list|,
name|rqstp
operator|->
name|rq_vers
argument_list|,
name|rqstp
operator|->
name|rq_proc
argument_list|)
expr_stmt|;
name|svcerr_decode
argument_list|(
name|transp
argument_list|)
expr_stmt|;
return|return;
block|}
name|ret
operator|=
call|(
modifier|*
name|local
call|)
argument_list|(
operator|&
name|argument
argument_list|,
operator|&
name|result
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svc_sendreply
argument_list|(
name|transp
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_result
argument_list|,
operator|(
name|SVC_IN_ARG_TYPE
operator|)
operator|&
name|result
argument_list|)
condition|)
block|{
name|svcerr_systemerr
argument_list|(
name|transp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|svc_freeargs
argument_list|(
name|transp
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_argument
argument_list|,
operator|(
name|SVC_IN_ARG_TYPE
operator|)
operator|&
name|argument
argument_list|)
condition|)
block|{
name|plog
argument_list|(
name|XLOG_FATAL
argument_list|,
literal|"unable to free rpc arguments in autofs_program_1"
argument_list|)
expr_stmt|;
name|going_down
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|autofs_mount_1_svc
parameter_list|(
name|struct
name|mntrequest
modifier|*
name|mr
parameter_list|,
name|struct
name|mntres
modifier|*
name|result
parameter_list|,
name|struct
name|authunix_parms
modifier|*
name|cred
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|am_node
modifier|*
name|anp
decl_stmt|,
modifier|*
name|anp2
decl_stmt|;
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"XXX: autofs_mount_1_svc: %s:%s:%s:%s"
argument_list|,
name|mr
operator|->
name|map
argument_list|,
name|mr
operator|->
name|name
argument_list|,
name|mr
operator|->
name|opts
argument_list|,
name|mr
operator|->
name|path
argument_list|)
expr_stmt|;
comment|/* look for map (eg. "/home") */
name|anp
operator|=
name|find_ap
argument_list|(
name|mr
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|anp
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"map %s not found"
argument_list|,
name|mr
operator|->
name|path
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* turn on autofs in map flags */
if|if
condition|(
operator|!
operator|(
name|anp
operator|->
name|am_flags
operator|&
name|AMF_AUTOFS
operator|)
condition|)
block|{
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"turning on AMF_AUTOFS for node %s"
argument_list|,
name|mr
operator|->
name|path
argument_list|)
expr_stmt|;
name|anp
operator|->
name|am_flags
operator||=
name|AMF_AUTOFS
expr_stmt|;
block|}
comment|/*    * Look for (and create if needed) the new node.    *    * If an error occurred, return it.  If a -1 was returned, that indicates    * that a mount is in progress, so sleep a while (while the backgrounded    * mount is happening), and then signal the autofs to retry the mount.    *    * There's something I don't understand.  I was thinking that this code    * here is the one which will succeed eventually and will send an RPC    * reply to the kernel, but apparently that happens somewhere else, not    * here.  It works though, just that I don't know how.  Arg. -Erez.    * */
name|err
operator|=
literal|0
expr_stmt|;
name|anp2
operator|=
name|autofs_lookuppn
argument_list|(
name|anp
argument_list|,
name|mr
operator|->
name|name
argument_list|,
operator|&
name|err
argument_list|,
name|VLOOK_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|anp2
condition|)
block|{
if|if
condition|(
name|err
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* then tell autofs to retry */
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|err
operator|=
name|EAGAIN
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
name|out
label|:
name|result
operator|->
name|status
operator|=
name|err
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|autofs_unmount_1_svc
parameter_list|(
name|struct
name|umntrequest
modifier|*
name|ur
parameter_list|,
name|struct
name|umntres
modifier|*
name|result
parameter_list|,
name|struct
name|authunix_parms
modifier|*
name|cred
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FIELD_UMNTREQUEST_RDEVID
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"XXX: autofs_unmount_1_svc: %d:%u:%lu:0x%x"
argument_list|,
name|ur
operator|->
name|isdirect
argument_list|,
name|ur
operator|->
name|devid
argument_list|,
name|ur
operator|->
name|rdevid
argument_list|,
name|ur
operator|->
name|next
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* HAVE_FIELD_UMNTREQUEST_RDEVID */
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"XXX: autofs_unmount_1_svc: %d:%u:0x%x"
argument_list|,
name|ur
operator|->
name|isdirect
argument_list|,
name|ur
operator|->
name|devid
argument_list|,
name|ur
operator|->
name|next
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_FIELD_UMNTREQUEST_RDEVID */
name|err
operator|=
name|EINVAL
expr_stmt|;
comment|/* XXX: not implemented yet */
goto|goto
name|out
goto|;
name|out
label|:
name|result
operator|->
name|status
operator|=
name|err
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*  * Pick a file system to try mounting and  * do that in the background if necessary  *  For each location:  if it is new -defaults then  extract and process  continue;  fi  if it is a cut then  if a location has been tried then  break;  fi  continue;  fi  parse mount location  discard previous mount location if required  find matching mounted filesystem  if not applicable then  this_error = No such file or directory  continue  fi  if the filesystem failed to be mounted then  this_error = error from filesystem  elif the filesystem is mounting or unmounting then  this_error = -1  elif the fileserver is down then  this_error = -1  elif the filesystem is already mounted  this_error = 0  break  fi  if no error on this mount then  this_error = initialize mount point  fi  if no error on this mount and mount is delayed then  this_error = -1  fi  if this_error< 0 then  retry = true  fi  if no error on this mount then  make mount point if required  fi  if no error on this mount then  if mount in background then  run mount in background  return -1  else  this_error = mount in foreground  fi  fi  if an error occurred on this mount then  update stats  save error in mount point  fi  endfor  */
end_comment

begin_function
specifier|static
name|int
name|autofs_bgmount
parameter_list|(
name|struct
name|continuation
modifier|*
name|cp
parameter_list|,
name|int
name|mpe
parameter_list|)
block|{
name|mntfs
modifier|*
name|mf
init|=
name|cp
operator|->
name|mp
operator|->
name|am_mnt
decl_stmt|;
comment|/* Current mntfs */
name|mntfs
modifier|*
name|mf_retry
init|=
literal|0
decl_stmt|;
comment|/* First mntfs which needed retrying */
name|int
name|this_error
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Per-mount error */
name|int
name|hard_error
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|mp_error
init|=
name|mpe
decl_stmt|;
comment|/*    * Try to mount each location.    * At the end:    * hard_error == 0 indicates something was mounted.    * hard_error> 0 indicates everything failed with a hard error    * hard_error< 0 indicates nothing could be mounted now    */
for|for
control|(
init|;
name|this_error
operator|&&
operator|*
name|cp
operator|->
name|ivec
condition|;
name|cp
operator|->
name|ivec
operator|++
control|)
block|{
name|am_ops
modifier|*
name|p
decl_stmt|;
name|am_node
modifier|*
name|mp
init|=
name|cp
operator|->
name|mp
decl_stmt|;
name|char
modifier|*
name|link_dir
decl_stmt|;
name|int
name|dont_retry
decl_stmt|;
if|if
condition|(
name|hard_error
operator|<
literal|0
condition|)
name|hard_error
operator|=
name|this_error
expr_stmt|;
name|this_error
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|cp
operator|->
name|ivec
operator|==
literal|'-'
condition|)
block|{
comment|/*        * Pick up new defaults        */
if|if
condition|(
name|cp
operator|->
name|auto_opts
operator|&&
operator|*
name|cp
operator|->
name|auto_opts
condition|)
name|cp
operator|->
name|def_opts
operator|=
name|str3cat
argument_list|(
name|cp
operator|->
name|def_opts
argument_list|,
name|cp
operator|->
name|auto_opts
argument_list|,
literal|";"
argument_list|,
operator|*
name|cp
operator|->
name|ivec
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|cp
operator|->
name|def_opts
operator|=
name|strealloc
argument_list|(
name|cp
operator|->
name|def_opts
argument_list|,
operator|*
name|cp
operator|->
name|ivec
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Setting def_opts to \"%s\""
argument_list|,
name|cp
operator|->
name|def_opts
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
continue|continue;
block|}
comment|/*      * If a mount has been attempted, and we find      * a cut then don't try any more locations.      */
if|if
condition|(
name|STREQ
argument_list|(
operator|*
name|cp
operator|->
name|ivec
argument_list|,
literal|"/"
argument_list|)
operator|||
name|STREQ
argument_list|(
operator|*
name|cp
operator|->
name|ivec
argument_list|,
literal|"||"
argument_list|)
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|tried
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Cut: not trying any more locations for %s"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
break|break;
block|}
continue|continue;
block|}
comment|/* match the operators */
name|p
operator|=
name|ops_match
argument_list|(
operator|&
name|cp
operator|->
name|fs_opts
argument_list|,
operator|*
name|cp
operator|->
name|ivec
argument_list|,
name|cp
operator|->
name|def_opts
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|cp
operator|->
name|key
argument_list|,
name|mp
operator|->
name|am_parent
operator|->
name|am_mnt
operator|->
name|mf_info
argument_list|)
expr_stmt|;
comment|/*      * Find a mounted filesystem for this node.      */
name|mp
operator|->
name|am_mnt
operator|=
name|mf
operator|=
name|realloc_mntfs
argument_list|(
name|mf
argument_list|,
name|p
argument_list|,
operator|&
name|cp
operator|->
name|fs_opts
argument_list|,
name|cp
operator|->
name|fs_opts
operator|.
name|opt_fs
argument_list|,
name|cp
operator|->
name|fs_opts
operator|.
name|fs_mtab
argument_list|,
name|cp
operator|->
name|auto_opts
argument_list|,
name|cp
operator|->
name|fs_opts
operator|.
name|opt_opts
argument_list|,
name|cp
operator|->
name|fs_opts
operator|.
name|opt_remopts
argument_list|)
expr_stmt|;
name|p
operator|=
name|mf
operator|->
name|mf_ops
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Got a hit with %s"
argument_list|,
name|p
operator|->
name|fs_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/*      * Note whether this is a real mount attempt      */
if|if
condition|(
name|p
operator|==
operator|&
name|amfs_error_ops
condition|)
block|{
name|plog
argument_list|(
name|XLOG_MAP
argument_list|,
literal|"Map entry %s for %s failed to match"
argument_list|,
operator|*
name|cp
operator|->
name|ivec
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_error
operator|<=
literal|0
condition|)
name|this_error
operator|=
name|ENOENT
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|cp
operator|->
name|fs_opts
operator|.
name|fs_mtab
condition|)
block|{
name|plog
argument_list|(
name|XLOG_MAP
argument_list|,
literal|"Trying mount of %s on \"%s\" fstype %s"
argument_list|,
name|cp
operator|->
name|fs_opts
operator|.
name|fs_mtab
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|p
operator|->
name|fs_type
argument_list|)
expr_stmt|;
block|}
name|cp
operator|->
name|tried
operator|=
name|TRUE
expr_stmt|;
block|}
name|this_error
operator|=
literal|0
expr_stmt|;
name|dont_retry
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_link
condition|)
block|{
name|XFREE
argument_list|(
name|mp
operator|->
name|am_link
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_link
operator|=
literal|0
expr_stmt|;
block|}
name|link_dir
operator|=
name|mf
operator|->
name|mf_fo
operator|->
name|opt_sublink
expr_stmt|;
if|if
condition|(
name|link_dir
operator|&&
operator|*
name|link_dir
condition|)
block|{
if|if
condition|(
operator|*
name|link_dir
operator|==
literal|'/'
condition|)
block|{
name|mp
operator|->
name|am_link
operator|=
name|strdup
argument_list|(
name|link_dir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * try getting fs option from continuation, not mountpoint! 	 * Don't try logging the string from mf, since it may be bad! 	 */
if|if
condition|(
name|cp
operator|->
name|fs_opts
operator|.
name|opt_fs
operator|!=
name|mf
operator|->
name|mf_fo
operator|->
name|opt_fs
condition|)
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"use %s instead of 0x%x"
argument_list|,
name|cp
operator|->
name|fs_opts
operator|.
name|opt_fs
argument_list|,
name|mf
operator|->
name|mf_fo
operator|->
name|opt_fs
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_link
operator|=
name|str3cat
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|cp
operator|->
name|fs_opts
operator|.
name|opt_fs
argument_list|,
literal|"/"
argument_list|,
name|link_dir
argument_list|)
expr_stmt|;
name|normalize_slash
argument_list|(
name|mp
operator|->
name|am_link
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mf
operator|->
name|mf_error
operator|>
literal|0
condition|)
block|{
name|this_error
operator|=
name|mf
operator|->
name|mf_error
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
operator|(
name|MFF_MOUNTING
operator||
name|MFF_UNMOUNTING
operator|)
condition|)
block|{
comment|/*        * Still mounting - retry later        */
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Duplicate pending mount fstype %s"
argument_list|,
name|p
operator|->
name|fs_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|this_error
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FSRV_ISDOWN
argument_list|(
name|mf
operator|->
name|mf_server
argument_list|)
condition|)
block|{
comment|/*        * Would just mount from the same place        * as a hung mount - so give up        */
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"%s is already hung - giving up"
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|mp_error
operator|=
name|EWOULDBLOCK
expr_stmt|;
name|dont_retry
operator|=
name|TRUE
expr_stmt|;
name|this_error
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_MOUNTED
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"duplicate mount of \"%s\" ..."
argument_list|,
name|mf
operator|->
name|mf_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/*        * Just call mounted()        */
name|am_mounted
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|this_error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/*      * Will usually need to play around with the mount nodes      * file attribute structure.  This must be done here.      * Try and get things initialized, even if the fileserver      * is not known to be up.  In the common case this will      * progress things faster.      */
if|if
condition|(
operator|!
name|this_error
condition|)
block|{
comment|/*        * Fill in attribute fields.        */
if|if
condition|(
name|mf
operator|->
name|mf_ops
operator|->
name|fs_flags
operator|&
name|FS_DIRECTORY
condition|)
name|mk_fattr
argument_list|(
name|mp
argument_list|,
name|NFDIR
argument_list|)
expr_stmt|;
else|else
name|mk_fattr
argument_list|(
name|mp
argument_list|,
name|NFLNK
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|.
name|na_fileid
operator|=
name|mp
operator|->
name|am_gen
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|fs_init
condition|)
name|this_error
operator|=
call|(
modifier|*
name|p
operator|->
name|fs_init
call|)
argument_list|(
name|mf
argument_list|)
expr_stmt|;
block|}
comment|/*      * Make sure the fileserver is UP before doing any more work      */
if|if
condition|(
operator|!
name|FSRV_ISUP
argument_list|(
name|mf
operator|->
name|mf_server
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"waiting for server %s to become available"
argument_list|,
name|mf
operator|->
name|mf_server
operator|->
name|fs_host
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|this_error
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|this_error
operator|&&
name|mf
operator|->
name|mf_fo
operator|->
name|opt_delay
condition|)
block|{
comment|/*        * If there is a delay timer on the mount        * then don't try to mount if the timer        * has not expired.        */
name|int
name|i
init|=
name|atoi
argument_list|(
name|mf
operator|->
name|mf_fo
operator|->
name|opt_delay
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|clocktime
argument_list|()
operator|<
operator|(
name|cp
operator|->
name|start
operator|+
name|i
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Mount of %s delayed by %ds"
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|,
name|i
operator|-
name|clocktime
argument_list|()
operator|+
name|cp
operator|->
name|start
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|this_error
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|this_error
operator|<
literal|0
operator|&&
operator|!
name|dont_retry
condition|)
block|{
if|if
condition|(
operator|!
name|mf_retry
condition|)
name|mf_retry
operator|=
name|dup_mntfs
argument_list|(
name|mf
argument_list|)
expr_stmt|;
name|cp
operator|->
name|retry
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|this_error
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|fs_flags
operator|&
name|FS_MBACKGROUND
condition|)
block|{
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_MOUNTING
expr_stmt|;
comment|/* XXX */
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"backgrounding mount of \"%s\""
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|cp
operator|->
name|callout
condition|)
block|{
name|untimeout
argument_list|(
name|cp
operator|->
name|callout
argument_list|)
expr_stmt|;
name|cp
operator|->
name|callout
operator|=
literal|0
expr_stmt|;
block|}
name|run_task
argument_list|(
name|try_mount
argument_list|,
operator|(
name|voidp
operator|)
name|mp
argument_list|,
name|amfs_auto_cont
argument_list|,
operator|(
name|voidp
operator|)
name|cp
argument_list|)
expr_stmt|;
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_MKMNT
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|mf_retry
condition|)
name|free_mntfs
argument_list|(
name|mf_retry
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"foreground mount of \"%s\" ..."
argument_list|,
name|mf
operator|->
name|mf_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|this_error
operator|=
name|try_mount
argument_list|(
operator|(
name|voidp
operator|)
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_error
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|mf_retry
condition|)
name|mf_retry
operator|=
name|dup_mntfs
argument_list|(
name|mf
argument_list|)
expr_stmt|;
name|cp
operator|->
name|retry
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|this_error
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|this_error
operator|>
literal|0
condition|)
block|{
name|amd_stats
operator|.
name|d_merr
operator|++
expr_stmt|;
if|if
condition|(
name|mf
operator|!=
name|mf_retry
condition|)
block|{
name|mf
operator|->
name|mf_error
operator|=
name|this_error
expr_stmt|;
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_ERROR
expr_stmt|;
block|}
block|}
comment|/*        * Wakeup anything waiting for this mount        */
name|wakeup
argument_list|(
operator|(
name|voidp
operator|)
name|mf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|this_error
operator|&&
name|cp
operator|->
name|retry
condition|)
block|{
name|free_mntfs
argument_list|(
name|mf
argument_list|)
expr_stmt|;
name|mf
operator|=
name|cp
operator|->
name|mp
operator|->
name|am_mnt
operator|=
name|mf_retry
expr_stmt|;
comment|/*      * Not retrying again (so far)      */
name|cp
operator|->
name|retry
operator|=
name|FALSE
expr_stmt|;
name|cp
operator|->
name|tried
operator|=
name|FALSE
expr_stmt|;
comment|/*      * Start at the beginning.      * Rewind the location vector and      * reset the default options.      */
name|cp
operator|->
name|ivec
operator|=
name|cp
operator|->
name|xivec
expr_stmt|;
name|cp
operator|->
name|def_opts
operator|=
name|strealloc
argument_list|(
name|cp
operator|->
name|def_opts
argument_list|,
name|cp
operator|->
name|auto_opts
argument_list|)
expr_stmt|;
comment|/*      * Arrange that autofs_bgmount is called      * after anything else happens.      */
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Arranging to retry mount of %s"
argument_list|,
name|cp
operator|->
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|sched_task
argument_list|(
name|amfs_auto_retry
argument_list|,
operator|(
name|voidp
operator|)
name|cp
argument_list|,
operator|(
name|voidp
operator|)
name|mf
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|callout
condition|)
name|untimeout
argument_list|(
name|cp
operator|->
name|callout
argument_list|)
expr_stmt|;
name|cp
operator|->
name|callout
operator|=
name|timeout
argument_list|(
name|RETRY_INTERVAL
argument_list|,
name|wakeup
argument_list|,
operator|(
name|voidp
operator|)
name|mf
argument_list|)
expr_stmt|;
name|cp
operator|->
name|mp
operator|->
name|am_ttl
operator|=
name|clocktime
argument_list|()
operator|+
name|RETRY_INTERVAL
expr_stmt|;
comment|/*      * Not done yet - so don't return anything      */
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|hard_error
operator|<
literal|0
operator|||
name|this_error
operator|==
literal|0
condition|)
name|hard_error
operator|=
name|this_error
expr_stmt|;
comment|/*    * Discard handle on duff filesystem.    * This should never happen since it    * should be caught by the case above.    */
if|if
condition|(
name|mf_retry
condition|)
block|{
if|if
condition|(
name|hard_error
condition|)
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"discarding a retry mntfs for %s"
argument_list|,
name|mf_retry
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
name|free_mntfs
argument_list|(
name|mf_retry
argument_list|)
expr_stmt|;
block|}
comment|/*    * If we get here, then either the mount succeeded or    * there is no more mount information available.    */
if|if
condition|(
name|hard_error
operator|<
literal|0
operator|&&
name|mp_error
condition|)
name|hard_error
operator|=
name|cp
operator|->
name|mp
operator|->
name|am_error
operator|=
name|mp_error
expr_stmt|;
if|if
condition|(
name|hard_error
operator|>
literal|0
condition|)
block|{
comment|/*      * Set a small(ish) timeout on an error node if      * the error was not a time out.      */
switch|switch
condition|(
name|hard_error
condition|)
block|{
case|case
name|ETIMEDOUT
case|:
case|case
name|EWOULDBLOCK
case|:
name|cp
operator|->
name|mp
operator|->
name|am_timeo
operator|=
literal|17
expr_stmt|;
break|break;
default|default:
name|cp
operator|->
name|mp
operator|->
name|am_timeo
operator|=
literal|5
expr_stmt|;
break|break;
block|}
name|new_ttl
argument_list|(
name|cp
operator|->
name|mp
argument_list|)
expr_stmt|;
block|}
comment|/*    * Make sure that the error value in the mntfs has a    * reasonable value.    */
if|if
condition|(
name|mf
operator|->
name|mf_error
operator|<
literal|0
condition|)
block|{
name|mf
operator|->
name|mf_error
operator|=
name|hard_error
expr_stmt|;
if|if
condition|(
name|hard_error
condition|)
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_ERROR
expr_stmt|;
block|}
comment|/*    * In any case we don't need the continuation any more    */
name|free_continuation
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
name|hard_error
return|;
block|}
end_function

begin_comment
comment|/*  * Automount interface to RPC lookup routine  * Find the corresponding entry and return  * the file handle for it.  */
end_comment

begin_function
name|am_node
modifier|*
name|autofs_lookuppn
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|,
name|char
modifier|*
name|fname
parameter_list|,
name|int
modifier|*
name|error_return
parameter_list|,
name|int
name|op
parameter_list|)
block|{
name|am_node
modifier|*
name|ap
decl_stmt|,
modifier|*
name|new_mp
decl_stmt|,
modifier|*
name|ap_hung
decl_stmt|;
name|char
modifier|*
name|info
decl_stmt|;
comment|/* Mount info - where to get the file system */
name|char
modifier|*
modifier|*
name|ivec
decl_stmt|,
modifier|*
modifier|*
name|xivec
decl_stmt|;
comment|/* Split version of info */
name|char
modifier|*
name|auto_opts
decl_stmt|;
comment|/* Automount options */
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Error so far */
name|char
name|path_name
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
comment|/* General path name buffer */
name|char
name|apath
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
comment|/* autofs path (added space) */
name|char
modifier|*
name|pfname
decl_stmt|;
comment|/* Path for database lookup */
name|struct
name|continuation
modifier|*
name|cp
decl_stmt|;
comment|/* Continuation structure if need to mount */
name|int
name|in_progress
init|=
literal|0
decl_stmt|;
comment|/* # of (un)mount in progress */
name|char
modifier|*
name|dflts
decl_stmt|;
name|mntfs
modifier|*
name|mf
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"in autofs_lookuppn"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/*    * If the server is shutting down    * then don't return information    * about the mount point.    */
if|if
condition|(
name|amd_state
operator|==
name|Finishing
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|mf
operator|=
name|mp
operator|->
name|am_mnt
operator|)
operator|==
literal|0
operator|||
name|mf
operator|->
name|mf_ops
operator|==
operator|&
name|amfs_direct_ops
condition|)
block|{
name|dlog
argument_list|(
literal|"%s mount ignored - going down"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dlog
argument_list|(
literal|"%s/%s mount ignored - going down"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
name|ereturn
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
block|}
comment|/*    * Handle special case of "." and ".."    */
if|if
condition|(
name|fname
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|fname
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
name|mp
return|;
comment|/* "." is the current node */
if|if
condition|(
name|fname
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|fname
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|am_parent
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|".. in %s gives %s"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|mp
operator|->
name|am_parent
operator|->
name|am_path
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
name|mp
operator|->
name|am_parent
return|;
comment|/* ".." is the parent node */
block|}
name|ereturn
argument_list|(
name|ESTALE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Check for valid key name.    * If it is invalid then pretend it doesn't exist.    */
if|if
condition|(
operator|!
name|valid_key
argument_list|(
name|fname
argument_list|)
condition|)
block|{
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"Key \"%s\" contains a disallowed character"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
block|}
comment|/*    * Expand key name.    * fname is now a private copy.    */
name|fname
operator|=
name|expand_key
argument_list|(
name|fname
argument_list|)
expr_stmt|;
for|for
control|(
name|ap_hung
operator|=
literal|0
operator|,
name|ap
operator|=
name|mp
operator|->
name|am_child
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|am_osib
control|)
block|{
comment|/*      * Otherwise search children of this node      */
if|if
condition|(
name|FSTREQ
argument_list|(
name|ap
operator|->
name|am_name
argument_list|,
name|fname
argument_list|)
condition|)
block|{
name|mf
operator|=
name|ap
operator|->
name|am_mnt
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|am_error
condition|)
block|{
name|error
operator|=
name|ap
operator|->
name|am_error
expr_stmt|;
continue|continue;
block|}
comment|/*        * If the error code is undefined then it must be        * in progress.        */
if|if
condition|(
name|mf
operator|->
name|mf_error
operator|<
literal|0
condition|)
goto|goto
name|in_progrss
goto|;
comment|/*        * Check for a hung node        */
if|if
condition|(
name|FSRV_ISDOWN
argument_list|(
name|mf
operator|->
name|mf_server
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"server hung"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|error
operator|=
name|ap
operator|->
name|am_error
expr_stmt|;
name|ap_hung
operator|=
name|ap
expr_stmt|;
continue|continue;
block|}
comment|/*        * If there was a previous error with this node        * then return that error code.        */
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_ERROR
condition|)
block|{
name|error
operator|=
name|mf
operator|->
name|mf_error
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_MOUNTED
operator|)
operator|||
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_UNMOUNTING
operator|)
condition|)
block|{
name|in_progrss
label|:
comment|/* 	 * If the fs is not mounted or it is unmounting then there 	 * is a background (un)mount in progress.  In this case 	 * we just drop the RPC request (return nil) and 	 * wait for a retry, by which time the (un)mount may 	 * have completed. 	 */
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"ignoring mount of %s in %s -- flags (%x) in progress"
argument_list|,
name|fname
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|,
name|mf
operator|->
name|mf_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|in_progress
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/*        * Otherwise we have a hit: return the current mount point.        */
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"matched %s in %s"
argument_list|,
name|fname
argument_list|,
name|ap
operator|->
name|am_path
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|XFREE
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
name|ap
return|;
block|}
block|}
if|if
condition|(
name|in_progress
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Waiting while %d mount(s) in progress"
argument_list|,
name|in_progress
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|XFREE
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*    * If an error occurred then return it.    */
if|if
condition|(
name|error
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|errno
operator|=
name|error
expr_stmt|;
comment|/* XXX */
name|dlog
argument_list|(
literal|"Returning error: %m"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|XFREE
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
comment|/*    * If doing a delete then don't create again!    */
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|VLOOK_DELETE
case|:
name|ereturn
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
case|case
name|VLOOK_CREATE
case|:
break|break;
default|default:
name|plog
argument_list|(
name|XLOG_FATAL
argument_list|,
literal|"Unknown op to autofs_lookuppn: 0x%x"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
comment|/*    * If the server is going down then just return,    * don't try to mount any more file systems    */
if|if
condition|(
operator|(
name|int
operator|)
name|amd_state
operator|>=
operator|(
name|int
operator|)
name|Finishing
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"not found - server going down anyway"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|XFREE
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
block|}
comment|/*    * If we get there then this is a reference to an,    * as yet, unknown name so we need to search the mount    * map for it.    */
if|if
condition|(
name|mp
operator|->
name|am_pref
condition|)
block|{
name|sprintf
argument_list|(
name|path_name
argument_list|,
literal|"%s%s"
argument_list|,
name|mp
operator|->
name|am_pref
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|pfname
operator|=
name|path_name
expr_stmt|;
block|}
else|else
block|{
name|pfname
operator|=
name|fname
expr_stmt|;
block|}
name|mf
operator|=
name|mp
operator|->
name|am_mnt
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"will search map info in %s to find %s"
argument_list|,
name|mf
operator|->
name|mf_info
argument_list|,
name|pfname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/*    * Consult the oracle for some mount information.    * info is malloc'ed and belongs to this routine.    * It ends up being free'd in free_continuation().    *    * Note that this may return -1 indicating that information    * is not yet available.    */
name|error
operator|=
name|mapc_search
argument_list|(
operator|(
name|mnt_map
operator|*
operator|)
name|mf
operator|->
name|mf_private
argument_list|,
name|pfname
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|>
literal|0
condition|)
name|plog
argument_list|(
name|XLOG_MAP
argument_list|,
literal|"No map entry for %s"
argument_list|,
name|pfname
argument_list|)
expr_stmt|;
else|else
name|plog
argument_list|(
name|XLOG_MAP
argument_list|,
literal|"Waiting on map entry for %s"
argument_list|,
name|pfname
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"mount info is %s"
argument_list|,
name|info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/*    * Split info into an argument vector.    * The vector is malloc'ed and belongs to    * this routine.  It is free'd in free_continuation()    */
name|xivec
operator|=
name|ivec
operator|=
name|strsplit
argument_list|(
name|info
argument_list|,
literal|' '
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
comment|/*    * Default error code...    */
if|if
condition|(
name|ap_hung
condition|)
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
else|else
name|error
operator|=
name|ENOENT
expr_stmt|;
comment|/*    * Allocate a new map    */
name|new_mp
operator|=
name|exported_ap_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_mp
operator|==
literal|0
condition|)
block|{
name|XFREE
argument_list|(
name|xivec
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
name|ENOSPC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mf
operator|->
name|mf_auto
condition|)
name|auto_opts
operator|=
name|mf
operator|->
name|mf_auto
expr_stmt|;
else|else
name|auto_opts
operator|=
literal|""
expr_stmt|;
name|auto_opts
operator|=
name|strdup
argument_list|(
name|auto_opts
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"searching for /defaults entry"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|mapc_search
argument_list|(
operator|(
name|mnt_map
operator|*
operator|)
name|mf
operator|->
name|mf_private
argument_list|,
literal|"/defaults"
argument_list|,
operator|&
name|dflts
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|dfl
decl_stmt|;
name|char
modifier|*
modifier|*
name|rvec
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"/defaults gave %s"
argument_list|,
name|dflts
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
operator|*
name|dflts
operator|==
literal|'-'
condition|)
name|dfl
operator|=
name|dflts
operator|+
literal|1
expr_stmt|;
else|else
name|dfl
operator|=
name|dflts
expr_stmt|;
comment|/*      * Chop the defaults up      */
name|rvec
operator|=
name|strsplit
argument_list|(
name|dfl
argument_list|,
literal|' '
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
if|if
condition|(
name|gopt
operator|.
name|flags
operator|&
name|CFM_ENABLE_DEFAULT_SELECTORS
condition|)
block|{
comment|/*        * Pick whichever first entry matched the list of selectors.        * Strip the selectors from the string, and assign to dfl the        * rest of the string.        */
if|if
condition|(
name|rvec
condition|)
block|{
name|am_opts
name|ap
decl_stmt|;
name|am_ops
modifier|*
name|pt
decl_stmt|;
name|char
modifier|*
modifier|*
name|sp
init|=
name|rvec
decl_stmt|;
while|while
condition|(
operator|*
name|sp
condition|)
block|{
comment|/* loop until you find something, if any */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|am_opts
argument_list|)
argument_list|)
expr_stmt|;
name|pt
operator|=
name|ops_match
argument_list|(
operator|&
name|ap
argument_list|,
operator|*
name|sp
argument_list|,
literal|""
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
literal|"/defaults"
argument_list|,
name|mp
operator|->
name|am_parent
operator|->
name|am_mnt
operator|->
name|mf_info
argument_list|)
expr_stmt|;
name|free_opts
argument_list|(
operator|&
name|ap
argument_list|)
expr_stmt|;
comment|/* don't leak */
if|if
condition|(
name|pt
operator|==
operator|&
name|amfs_error_ops
condition|)
block|{
name|plog
argument_list|(
name|XLOG_MAP
argument_list|,
literal|"failed to match defaults for \"%s\""
argument_list|,
operator|*
name|sp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dfl
operator|=
name|strip_selectors
argument_list|(
operator|*
name|sp
argument_list|,
literal|"/defaults"
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_MAP
argument_list|,
literal|"matched default selectors \"%s\""
argument_list|,
name|dfl
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|sp
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* not enable_default_selectors */
comment|/*        * Extract first value        */
name|dfl
operator|=
name|rvec
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/*      * If there were any values at all...      */
if|if
condition|(
name|dfl
condition|)
block|{
comment|/*        * Log error if there were other values        */
if|if
condition|(
operator|!
operator|(
name|gopt
operator|.
name|flags
operator|&
name|CFM_ENABLE_DEFAULT_SELECTORS
operator|)
operator|&&
name|rvec
index|[
literal|1
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"/defaults chopped into %s"
argument_list|,
name|dfl
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|plog
argument_list|(
name|XLOG_USER
argument_list|,
literal|"More than a single value for /defaults in %s"
argument_list|,
name|mf
operator|->
name|mf_info
argument_list|)
expr_stmt|;
block|}
comment|/*        * Prepend to existing defaults if they exist,        * otherwise just use these defaults.        */
if|if
condition|(
operator|*
name|auto_opts
operator|&&
operator|*
name|dfl
condition|)
block|{
name|char
modifier|*
name|nopts
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|auto_opts
argument_list|)
operator|+
name|strlen
argument_list|(
name|dfl
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|nopts
argument_list|,
literal|"%s;%s"
argument_list|,
name|dfl
argument_list|,
name|auto_opts
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|auto_opts
argument_list|)
expr_stmt|;
name|auto_opts
operator|=
name|nopts
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|dfl
condition|)
block|{
name|auto_opts
operator|=
name|strealloc
argument_list|(
name|auto_opts
argument_list|,
name|dfl
argument_list|)
expr_stmt|;
block|}
block|}
name|XFREE
argument_list|(
name|dflts
argument_list|)
expr_stmt|;
comment|/*      * Don't need info vector any more      */
name|XFREE
argument_list|(
name|rvec
argument_list|)
expr_stmt|;
block|}
comment|/*    * Fill it in    */
name|init_map
argument_list|(
name|new_mp
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/*    * Turn on autofs flag if needed.    */
if|if
condition|(
name|mp
operator|->
name|am_flags
operator|&
name|AMF_AUTOFS
condition|)
block|{
name|new_mp
operator|->
name|am_flags
operator||=
name|AMF_AUTOFS
expr_stmt|;
block|}
comment|/*    * Put it in the table    */
name|insert_am
argument_list|(
name|new_mp
argument_list|,
name|mp
argument_list|)
expr_stmt|;
comment|/*    * Fill in some other fields,    * path and mount point.    *    * bugfix: do not prepend old am_path if direct map    *<wls@astro.umd.edu> William Sebok    */
name|strcpy
argument_list|(
name|apath
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|apath
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|new_mp
operator|->
name|am_path
operator|=
name|str3cat
argument_list|(
name|new_mp
operator|->
name|am_path
argument_list|,
name|mf
operator|->
name|mf_ops
operator|==
operator|&
name|amfs_direct_ops
condition|?
literal|""
else|:
name|mp
operator|->
name|am_path
argument_list|,
operator|*
name|fname
operator|==
literal|'/'
condition|?
literal|""
else|:
literal|"/"
argument_list|,
name|apath
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"setting path to \"%s\""
argument_list|,
name|new_mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/*    * Take private copy of pfname    */
name|pfname
operator|=
name|strdup
argument_list|(
name|pfname
argument_list|)
expr_stmt|;
comment|/*    * Construct a continuation    */
name|cp
operator|=
name|ALLOC
argument_list|(
expr|struct
name|continuation
argument_list|)
expr_stmt|;
name|cp
operator|->
name|callout
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|mp
operator|=
name|new_mp
expr_stmt|;
name|cp
operator|->
name|xivec
operator|=
name|xivec
expr_stmt|;
name|cp
operator|->
name|ivec
operator|=
name|ivec
expr_stmt|;
name|cp
operator|->
name|info
operator|=
name|info
expr_stmt|;
name|cp
operator|->
name|key
operator|=
name|pfname
expr_stmt|;
name|cp
operator|->
name|auto_opts
operator|=
name|auto_opts
expr_stmt|;
name|cp
operator|->
name|retry
operator|=
name|FALSE
expr_stmt|;
name|cp
operator|->
name|tried
operator|=
name|FALSE
expr_stmt|;
name|cp
operator|->
name|start
operator|=
name|clocktime
argument_list|()
expr_stmt|;
name|cp
operator|->
name|def_opts
operator|=
name|strdup
argument_list|(
name|auto_opts
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|voidp
operator|)
operator|&
name|cp
operator|->
name|fs_opts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cp
operator|->
name|fs_opts
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    * Try and mount the file system.  If this succeeds immediately (possible    * for a ufs file system) then return the attributes, otherwise just    * return an error.    */
name|error
operator|=
name|autofs_bgmount
argument_list|(
name|cp
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|reschedule_timeout_mp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|XFREE
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
name|new_mp
return|;
block|}
comment|/*    * Code for quick reply.  If nfs_program_2_transp is set, then    * its the transp that's been passed down from nfs_program_2().    * If new_mp->am_transp is not already set, set it by copying in    * nfs_program_2_transp.  Once am_transp is set, quick_reply() can    * use it to send a reply to the client that requested this mount.    */
if|if
condition|(
name|nfs_program_2_transp
operator|&&
operator|!
name|new_mp
operator|->
name|am_transp
condition|)
block|{
name|new_mp
operator|->
name|am_transp
operator|=
operator|(
name|SVCXPRT
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SVCXPRT
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|new_mp
operator|->
name|am_transp
operator|)
operator|=
operator|*
name|nfs_program_2_transp
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|&&
operator|(
name|new_mp
operator|->
name|am_mnt
operator|->
name|mf_ops
operator|==
operator|&
name|amfs_error_ops
operator|)
condition|)
name|new_mp
operator|->
name|am_error
operator|=
name|error
expr_stmt|;
name|assign_error_mntfs
argument_list|(
name|new_mp
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|ereturn
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_FS_AUTOFS */
end_comment

end_unit

