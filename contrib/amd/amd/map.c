begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997-1999 Erez Zadok  * Copyright (c) 1990 Jan-Simon Pendry  * Copyright (c) 1990 Imperial College of Science, Technology& Medicine  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry at Imperial College, London.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgment:  *      This product includes software developed by the University of  *      California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      %W% (Berkeley) %G%  *  * $Id: map.c,v 1.5 1999/08/22 05:12:51 ezk Exp $  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<am_defs.h>
end_include

begin_include
include|#
directive|include
file|<amd.h>
end_include

begin_define
define|#
directive|define
name|smallest_t
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
value|(t1 != NEVER ? (t2 != NEVER ? (t1< t2 ? t1 : t2) : t1) : t2)
end_define

begin_define
define|#
directive|define
name|IGNORE_FLAGS
value|(MFF_MOUNTING|MFF_UNMOUNTING|MFF_RESTART)
end_define

begin_define
define|#
directive|define
name|NEVER
value|(time_t) 0
end_define

begin_define
define|#
directive|define
name|new_gen
parameter_list|()
value|(am_gen++)
end_define

begin_comment
comment|/*  * Generation Numbers.  *  * Generation numbers are allocated to every node created  * by amd.  When a filehandle is computed and sent to the  * kernel, the generation number makes sure that it is safe  * to reallocate a node slot even when the kernel has a cached  * reference to its old incarnation.  * No garbage collection is done, since it is assumed that  * there is no way that 2^32 generation numbers could ever  * be allocated by a single run of amd - there is simply  * not enough cpu time available.  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|am_gen
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initial generation number */
end_comment

begin_decl_stmt
specifier|static
name|int
name|timeout_mp_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Id from last call to timeout */
end_comment

begin_decl_stmt
name|am_node
modifier|*
name|root_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The root of the mount tree */
end_comment

begin_decl_stmt
name|am_node
modifier|*
modifier|*
name|exported_ap
init|=
operator|(
name|am_node
operator|*
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|exported_ap_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|first_free_map
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First available free slot */
end_comment

begin_decl_stmt
name|int
name|last_used_map
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last unavailable used slot */
end_comment

begin_comment
comment|/*  * This is the default attributes field which  * is copied into every new node to be created.  * The individual filesystem fs_init() routines  * patch the copy to represent the particular  * details for the relevant filesystem type  */
end_comment

begin_decl_stmt
specifier|static
name|nfsfattr
name|gen_fattr
init|=
block|{
name|NFLNK
block|,
comment|/* type */
name|NFSMODE_LNK
operator||
literal|0777
block|,
comment|/* mode */
literal|1
block|,
comment|/* nlink */
literal|0
block|,
comment|/* uid */
literal|0
block|,
comment|/* gid */
literal|0
block|,
comment|/* size */
literal|4096
block|,
comment|/* blocksize */
literal|0
block|,
comment|/* rdev */
literal|1
block|,
comment|/* blocks */
literal|0
block|,
comment|/* fsid */
literal|0
block|,
comment|/* fileid */
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* atime */
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* mtime */
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* ctime */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* forward declarations */
end_comment

begin_function_decl
specifier|static
name|int
name|unmount_node
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|exported_ap_free
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_am
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Resize exported_ap map  */
end_comment

begin_function
specifier|static
name|int
name|exported_ap_realloc_map
parameter_list|(
name|int
name|nsize
parameter_list|)
block|{
comment|/*    * this shouldn't happen, but...    */
if|if
condition|(
name|nsize
operator|<
literal|0
operator|||
name|nsize
operator|==
name|exported_ap_size
condition|)
return|return
literal|0
return|;
name|exported_ap
operator|=
operator|(
name|am_node
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|voidp
operator|)
name|exported_ap
argument_list|,
name|nsize
operator|*
sizeof|sizeof
argument_list|(
name|am_node
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsize
operator|>
name|exported_ap_size
condition|)
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|exported_ap
operator|+
name|exported_ap_size
operator|)
argument_list|,
literal|0
argument_list|,
operator|(
name|nsize
operator|-
name|exported_ap_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|am_node
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|exported_ap_size
operator|=
name|nsize
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new mount slot and create  * a new node.  * Fills in the map number of the node,  * but leaves everything else uninitialized.  */
end_comment

begin_function
name|am_node
modifier|*
name|exported_ap_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|am_node
modifier|*
name|mp
decl_stmt|,
modifier|*
modifier|*
name|mpp
decl_stmt|;
comment|/*    * First check if there are any slots left, realloc if needed    */
if|if
condition|(
name|first_free_map
operator|>=
name|exported_ap_size
condition|)
if|if
condition|(
operator|!
name|exported_ap_realloc_map
argument_list|(
name|exported_ap_size
operator|+
name|NEXP_AP
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/*    * Grab the next free slot    */
name|mpp
operator|=
name|exported_ap
operator|+
name|first_free_map
expr_stmt|;
name|mp
operator|=
operator|*
name|mpp
operator|=
name|ALLOC
argument_list|(
expr|struct
name|am_node
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_mapno
operator|=
name|first_free_map
operator|++
expr_stmt|;
comment|/*    * Update free pointer    */
while|while
condition|(
name|first_free_map
operator|<
name|exported_ap_size
operator|&&
name|exported_ap
index|[
name|first_free_map
index|]
condition|)
name|first_free_map
operator|++
expr_stmt|;
if|if
condition|(
name|first_free_map
operator|>
name|last_used_map
condition|)
name|last_used_map
operator|=
name|first_free_map
operator|-
literal|1
expr_stmt|;
return|return
name|mp
return|;
block|}
end_function

begin_comment
comment|/*  * Free a mount slot  */
end_comment

begin_function
specifier|static
name|void
name|exported_ap_free
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
comment|/*    * Sanity check    */
if|if
condition|(
operator|!
name|mp
condition|)
return|return;
comment|/*    * Zero the slot pointer to avoid double free's    */
name|exported_ap
index|[
name|mp
operator|->
name|am_mapno
index|]
operator|=
literal|0
expr_stmt|;
comment|/*    * Update the free and last_used indices    */
if|if
condition|(
name|mp
operator|->
name|am_mapno
operator|==
name|last_used_map
condition|)
while|while
condition|(
name|last_used_map
operator|>=
literal|0
operator|&&
name|exported_ap
index|[
name|last_used_map
index|]
operator|==
literal|0
condition|)
operator|--
name|last_used_map
expr_stmt|;
if|if
condition|(
name|first_free_map
operator|>
name|mp
operator|->
name|am_mapno
condition|)
name|first_free_map
operator|=
name|mp
operator|->
name|am_mapno
expr_stmt|;
comment|/*    * Free the mount node    */
name|XFREE
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Insert mp into the correct place,  * where p_mp is its parent node.  * A new node gets placed as the youngest sibling  * of any other children, and the parent's child  * pointer is adjusted to point to the new child node.  */
end_comment

begin_function
name|void
name|insert_am
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|,
name|am_node
modifier|*
name|p_mp
parameter_list|)
block|{
comment|/*    * If this is going in at the root then flag it    * so that it cannot be unmounted by amq.    */
if|if
condition|(
name|p_mp
operator|==
name|root_node
condition|)
name|mp
operator|->
name|am_flags
operator||=
name|AMF_ROOT
expr_stmt|;
comment|/*    * Fill in n-way links    */
name|mp
operator|->
name|am_parent
operator|=
name|p_mp
expr_stmt|;
name|mp
operator|->
name|am_osib
operator|=
name|p_mp
operator|->
name|am_child
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_osib
condition|)
name|mp
operator|->
name|am_osib
operator|->
name|am_ysib
operator|=
name|mp
expr_stmt|;
name|p_mp
operator|->
name|am_child
operator|=
name|mp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove am from its place in the mount tree  */
end_comment

begin_function
specifier|static
name|void
name|remove_am
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
comment|/*    * 1.  Consistency check    */
if|if
condition|(
name|mp
operator|->
name|am_child
operator|&&
name|mp
operator|->
name|am_parent
condition|)
block|{
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"children of \"%s\" still exist - deleting anyway"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
block|}
comment|/*    * 2.  Update parent's child pointer    */
if|if
condition|(
name|mp
operator|->
name|am_parent
operator|&&
name|mp
operator|->
name|am_parent
operator|->
name|am_child
operator|==
name|mp
condition|)
name|mp
operator|->
name|am_parent
operator|->
name|am_child
operator|=
name|mp
operator|->
name|am_osib
expr_stmt|;
comment|/*    * 3.  Unlink from sibling chain    */
if|if
condition|(
name|mp
operator|->
name|am_ysib
condition|)
name|mp
operator|->
name|am_ysib
operator|->
name|am_osib
operator|=
name|mp
operator|->
name|am_osib
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_osib
condition|)
name|mp
operator|->
name|am_osib
operator|->
name|am_ysib
operator|=
name|mp
operator|->
name|am_ysib
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compute a new time to live value for a node.  */
end_comment

begin_function
name|void
name|new_ttl
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
name|mp
operator|->
name|am_timeo_w
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|am_ttl
operator|=
name|clocktime
argument_list|()
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|.
name|na_atime
operator|.
name|nt_seconds
operator|=
name|mp
operator|->
name|am_ttl
expr_stmt|;
name|mp
operator|->
name|am_ttl
operator|+=
name|mp
operator|->
name|am_timeo
expr_stmt|;
comment|/* sun's -tl option */
block|}
end_function

begin_function
name|void
name|mk_fattr
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|,
name|nfsftype
name|vntype
parameter_list|)
block|{
switch|switch
condition|(
name|vntype
condition|)
block|{
case|case
name|NFDIR
case|:
name|mp
operator|->
name|am_fattr
operator|.
name|na_type
operator|=
name|NFDIR
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|.
name|na_mode
operator|=
name|NFSMODE_DIR
operator||
literal|0555
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|.
name|na_nlink
operator|=
literal|2
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|.
name|na_size
operator|=
literal|512
expr_stmt|;
break|break;
case|case
name|NFLNK
case|:
name|mp
operator|->
name|am_fattr
operator|.
name|na_type
operator|=
name|NFLNK
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|.
name|na_mode
operator|=
name|NFSMODE_LNK
operator||
literal|0777
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|.
name|na_nlink
operator|=
literal|1
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|.
name|na_size
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|plog
argument_list|(
name|XLOG_FATAL
argument_list|,
literal|"Unknown fattr type %d - ignored"
argument_list|,
name|vntype
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize an allocated mount node.  * It is assumed that the mount node was b-zero'd  * before getting here so anything that would  * be set to zero isn't done here.  */
end_comment

begin_function
name|void
name|init_map
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|,
name|char
modifier|*
name|dir
parameter_list|)
block|{
comment|/*    * mp->am_mapno is initialized by exported_ap_alloc    * other fields don't need to be set to zero.    */
name|mp
operator|->
name|am_mnt
operator|=
name|new_mntfs
argument_list|()
expr_stmt|;
name|mp
operator|->
name|am_name
operator|=
name|strdup
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_path
operator|=
name|strdup
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_gen
operator|=
name|new_gen
argument_list|()
expr_stmt|;
name|mp
operator|->
name|am_timeo
operator|=
name|gopt
operator|.
name|am_timeo
expr_stmt|;
name|mp
operator|->
name|am_attr
operator|.
name|ns_status
operator|=
name|NFS_OK
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|=
name|gen_fattr
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|.
name|na_fsid
operator|=
literal|42
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|.
name|na_fileid
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|.
name|na_atime
operator|.
name|nt_seconds
operator|=
name|clocktime
argument_list|()
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|.
name|na_atime
operator|.
name|nt_useconds
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|.
name|na_mtime
operator|=
name|mp
operator|->
name|am_fattr
operator|.
name|na_ctime
operator|=
name|mp
operator|->
name|am_fattr
operator|.
name|na_atime
expr_stmt|;
name|new_ttl
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_stats
operator|.
name|s_mtime
operator|=
name|mp
operator|->
name|am_fattr
operator|.
name|na_atime
operator|.
name|nt_seconds
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free a mount node.  * The node must be already unmounted.  */
end_comment

begin_function
name|void
name|free_map
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
name|remove_am
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_link
condition|)
name|XFREE
argument_list|(
name|mp
operator|->
name|am_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_name
condition|)
name|XFREE
argument_list|(
name|mp
operator|->
name|am_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_path
condition|)
name|XFREE
argument_list|(
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_pref
condition|)
name|XFREE
argument_list|(
name|mp
operator|->
name|am_pref
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_transp
condition|)
name|XFREE
argument_list|(
name|mp
operator|->
name|am_transp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_mnt
condition|)
name|free_mntfs
argument_list|(
name|mp
operator|->
name|am_mnt
argument_list|)
expr_stmt|;
name|exported_ap_free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Convert from file handle to automount node.  */
end_comment

begin_function
name|am_node
modifier|*
name|fh_to_mp3
parameter_list|(
name|am_nfs_fh
modifier|*
name|fhp
parameter_list|,
name|int
modifier|*
name|rp
parameter_list|,
name|int
name|c_or_d
parameter_list|)
block|{
name|struct
name|am_fh
modifier|*
name|fp
init|=
operator|(
expr|struct
name|am_fh
operator|*
operator|)
name|fhp
decl_stmt|;
name|am_node
modifier|*
name|ap
init|=
literal|0
decl_stmt|;
comment|/*    * Check process id matches    * If it doesn't then it is probably    * from an old kernel cached filehandle    * which is now out of date.    */
if|if
condition|(
name|fp
operator|->
name|fhh_pid
operator|!=
name|am_mypid
condition|)
goto|goto
name|drop
goto|;
comment|/*    * Make sure the index is valid before    * exported_ap is referenced.    */
if|if
condition|(
name|fp
operator|->
name|fhh_id
operator|<
literal|0
operator|||
name|fp
operator|->
name|fhh_id
operator|>=
name|exported_ap_size
condition|)
goto|goto
name|drop
goto|;
comment|/*    * Get hold of the supposed mount node    */
name|ap
operator|=
name|exported_ap
index|[
name|fp
operator|->
name|fhh_id
index|]
expr_stmt|;
comment|/*    * If it exists then maybe...    */
if|if
condition|(
name|ap
condition|)
block|{
comment|/*      * Check the generation number in the node      * matches the one from the kernel.  If not      * then the old node has been timed out and      * a new one allocated.      */
if|if
condition|(
name|ap
operator|->
name|am_gen
operator|!=
name|fp
operator|->
name|fhh_gen
condition|)
block|{
name|ap
operator|=
literal|0
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
comment|/*      * If the node is hung then locate a new node      * for it.  This implements the replicated filesystem      * retries.      */
if|if
condition|(
name|ap
operator|->
name|am_mnt
operator|&&
name|FSRV_ISDOWN
argument_list|(
name|ap
operator|->
name|am_mnt
operator|->
name|mf_server
argument_list|)
operator|&&
name|ap
operator|->
name|am_parent
condition|)
block|{
name|int
name|error
decl_stmt|;
name|am_node
modifier|*
name|orig_ap
init|=
name|ap
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"fh_to_mp3: %s (%s) is hung:- call lookup"
argument_list|,
name|orig_ap
operator|->
name|am_path
argument_list|,
name|orig_ap
operator|->
name|am_mnt
operator|->
name|mf_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/*        * Update modify time of parent node.        * With any luck the kernel will re-stat        * the child node and get new information.        */
name|orig_ap
operator|->
name|am_fattr
operator|.
name|na_mtime
operator|.
name|nt_seconds
operator|=
name|clocktime
argument_list|()
expr_stmt|;
comment|/*        * Call the parent's lookup routine for an object        * with the same name.  This may return -1 in error        * if a mount is in progress.  In any case, if no        * mount node is returned the error code is propagated        * to the caller.        */
if|if
condition|(
name|c_or_d
operator|==
name|VLOOK_CREATE
condition|)
block|{
name|ap
operator|=
call|(
modifier|*
name|orig_ap
operator|->
name|am_parent
operator|->
name|am_mnt
operator|->
name|mf_ops
operator|->
name|lookuppn
call|)
argument_list|(
name|orig_ap
operator|->
name|am_parent
argument_list|,
name|orig_ap
operator|->
name|am_name
argument_list|,
operator|&
name|error
argument_list|,
name|c_or_d
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ap
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|ESTALE
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|<
literal|0
operator|&&
name|amd_state
operator|==
name|Finishing
condition|)
name|error
operator|=
name|ENOENT
expr_stmt|;
operator|*
name|rp
operator|=
name|error
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*        * Update last access to original node.  This        * avoids timing it out and so sending ESTALE        * back to the kernel.        * XXX - Not sure we need this anymore (jsp, 90/10/6).        */
name|new_ttl
argument_list|(
name|orig_ap
argument_list|)
expr_stmt|;
block|}
comment|/*      * Disallow references to objects being unmounted, unless      * they are automount points.      */
if|if
condition|(
name|ap
operator|->
name|am_mnt
operator|&&
operator|(
name|ap
operator|->
name|am_mnt
operator|->
name|mf_flags
operator|&
name|MFF_UNMOUNTING
operator|)
operator|&&
operator|!
operator|(
name|ap
operator|->
name|am_flags
operator|&
name|AMF_ROOT
operator|)
condition|)
block|{
if|if
condition|(
name|amd_state
operator|==
name|Finishing
condition|)
operator|*
name|rp
operator|=
name|ENOENT
expr_stmt|;
else|else
operator|*
name|rp
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|new_ttl
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
name|drop
label|:
if|if
condition|(
operator|!
name|ap
operator|||
operator|!
name|ap
operator|->
name|am_mnt
condition|)
block|{
comment|/*      * If we are shutting down then it is likely      * that this node has disappeared because of      * a fast timeout.  To avoid things thrashing      * just pretend it doesn't exist at all.  If      * ESTALE is returned, some NFS clients just      * keep retrying (stupid or what - if it's      * stale now, what's it going to be in 5 minutes?)      */
if|if
condition|(
name|amd_state
operator|==
name|Finishing
condition|)
operator|*
name|rp
operator|=
name|ENOENT
expr_stmt|;
else|else
operator|*
name|rp
operator|=
name|ESTALE
expr_stmt|;
name|amd_stats
operator|.
name|d_stale
operator|++
expr_stmt|;
block|}
return|return
name|ap
return|;
block|}
end_function

begin_function
name|am_node
modifier|*
name|fh_to_mp
parameter_list|(
name|am_nfs_fh
modifier|*
name|fhp
parameter_list|)
block|{
name|int
name|dummy
decl_stmt|;
return|return
name|fh_to_mp2
argument_list|(
name|fhp
argument_list|,
operator|&
name|dummy
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert from automount node to file handle.  */
end_comment

begin_function
name|void
name|mp_to_fh
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|,
name|am_nfs_fh
modifier|*
name|fhp
parameter_list|)
block|{
name|struct
name|am_fh
modifier|*
name|fp
init|=
operator|(
expr|struct
name|am_fh
operator|*
operator|)
name|fhp
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fhp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|am_nfs_fh
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    * Take the process id    */
name|fp
operator|->
name|fhh_pid
operator|=
name|am_mypid
expr_stmt|;
comment|/*    * ... the map number    */
name|fp
operator|->
name|fhh_id
operator|=
name|mp
operator|->
name|am_mapno
expr_stmt|;
comment|/*    * ... and the generation number    */
name|fp
operator|->
name|fhh_gen
operator|=
name|mp
operator|->
name|am_gen
expr_stmt|;
comment|/*    * ... to make a "unique" triple that will never    * be reallocated except across reboots (which doesn't matter)    * or if we are unlucky enough to be given the same    * pid as a previous amd (very unlikely).    */
block|}
end_function

begin_function
name|am_node
modifier|*
name|find_ap2
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|,
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
if|if
condition|(
name|mp
condition|)
block|{
name|am_node
modifier|*
name|mp2
decl_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|mp
operator|->
name|am_path
argument_list|,
name|dir
argument_list|)
condition|)
return|return
name|mp
return|;
if|if
condition|(
operator|(
name|mp
operator|->
name|am_mnt
operator|->
name|mf_flags
operator|&
name|MFF_MOUNTED
operator|)
operator|&&
name|STREQ
argument_list|(
name|mp
operator|->
name|am_mnt
operator|->
name|mf_mount
argument_list|,
name|dir
argument_list|)
condition|)
return|return
name|mp
return|;
name|mp2
operator|=
name|find_ap2
argument_list|(
name|dir
argument_list|,
name|mp
operator|->
name|am_osib
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp2
condition|)
return|return
name|mp2
return|;
return|return
name|find_ap2
argument_list|(
name|dir
argument_list|,
name|mp
operator|->
name|am_child
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Find the mount node corresponding to dir.  dir can match either the  * automount path or, if the node is mounted, the mount location.  */
end_comment

begin_function
name|am_node
modifier|*
name|find_ap
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|last_used_map
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|am_node
modifier|*
name|mp
init|=
name|exported_ap
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|mp
operator|&&
operator|(
name|mp
operator|->
name|am_flags
operator|&
name|AMF_ROOT
operator|)
condition|)
block|{
name|mp
operator|=
name|find_ap2
argument_list|(
name|dir
argument_list|,
name|exported_ap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
condition|)
block|{
return|return
name|mp
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Find the mount node corresponding  * to the mntfs structure.  */
end_comment

begin_function
name|am_node
modifier|*
name|find_mf
parameter_list|(
name|mntfs
modifier|*
name|mf
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|last_used_map
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|am_node
modifier|*
name|mp
init|=
name|exported_ap
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|mp
operator|&&
name|mp
operator|->
name|am_mnt
operator|==
name|mf
condition|)
return|return
name|mp
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Get the filehandle for a particular named directory.  * This is used during the bootstrap to tell the kernel  * the filehandles of the initial automount points.  */
end_comment

begin_function
name|am_nfs_fh
modifier|*
name|root_fh
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|)
block|{
specifier|static
name|am_nfs_fh
name|nfh
decl_stmt|;
name|am_node
modifier|*
name|mp
init|=
name|root_ap
argument_list|(
name|dir
argument_list|,
name|TRUE
argument_list|)
decl_stmt|;
if|if
condition|(
name|mp
condition|)
block|{
name|mp_to_fh
argument_list|(
name|mp
argument_list|,
operator|&
name|nfh
argument_list|)
expr_stmt|;
comment|/*      * Patch up PID to match main server...      */
if|if
condition|(
operator|!
name|foreground
condition|)
block|{
name|long
name|pid
init|=
name|getppid
argument_list|()
decl_stmt|;
operator|(
operator|(
expr|struct
name|am_fh
operator|*
operator|)
operator|&
name|nfh
operator|)
operator|->
name|fhh_pid
operator|=
name|pid
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"root_fh substitutes pid %ld"
argument_list|,
operator|(
name|long
operator|)
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
return|return
operator|&
name|nfh
return|;
block|}
comment|/*    * Should never get here...    */
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"Can't find root filehandle for %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|am_node
modifier|*
name|root_ap
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|,
name|int
name|path
parameter_list|)
block|{
name|am_node
modifier|*
name|mp
init|=
name|find_ap
argument_list|(
name|dir
argument_list|)
decl_stmt|;
if|if
condition|(
name|mp
operator|&&
name|mp
operator|->
name|am_parent
operator|==
name|root_node
condition|)
return|return
name|mp
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Timeout all nodes waiting on  * a given Fserver.  */
end_comment

begin_function
name|void
name|map_flush_srvr
parameter_list|(
name|fserver
modifier|*
name|fs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|last_used_map
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|am_node
modifier|*
name|mp
init|=
name|exported_ap
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|mp
operator|&&
name|mp
operator|->
name|am_mnt
operator|&&
name|mp
operator|->
name|am_mnt
operator|->
name|mf_server
operator|==
name|fs
condition|)
block|{
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"Flushed %s; dependent on %s"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_ttl
operator|=
name|clocktime
argument_list|()
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|done
condition|)
name|reschedule_timeout_mp
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mount a top level automount node  * by calling lookup in the parent  * (root) node which will cause the  * automount node to be automounted.  */
end_comment

begin_function
name|int
name|mount_auto_node
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|,
name|voidp
name|arg
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|amfs_auto_ops
operator|.
name|lookuppn
argument_list|(
operator|(
name|am_node
operator|*
operator|)
name|arg
argument_list|,
name|dir
argument_list|,
operator|&
name|error
argument_list|,
name|VLOOK_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>
literal|0
condition|)
block|{
name|errno
operator|=
name|error
expr_stmt|;
comment|/* XXX */
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"Could not mount %s: %m"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Cause all the top-level mount nodes  * to be automounted  */
end_comment

begin_function
name|int
name|mount_exported
parameter_list|(
name|void
parameter_list|)
block|{
comment|/*    * Iterate over all the nodes to be started    */
return|return
name|root_keyiter
argument_list|(
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|voidp
operator|)
argument_list|)
operator|)
name|mount_auto_node
argument_list|,
name|root_node
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Construct top-level node  */
end_comment

begin_function
name|void
name|make_root_node
parameter_list|(
name|void
parameter_list|)
block|{
name|mntfs
modifier|*
name|root_mnt
decl_stmt|;
name|char
modifier|*
name|rootmap
init|=
name|ROOT_MAP
decl_stmt|;
name|root_node
operator|=
name|exported_ap_alloc
argument_list|()
expr_stmt|;
comment|/*    * Allocate a new map    */
name|init_map
argument_list|(
name|root_node
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/*    * Allocate a new mounted filesystem    */
name|root_mnt
operator|=
name|find_mntfs
argument_list|(
operator|&
name|amfs_root_ops
argument_list|,
operator|(
name|am_opts
operator|*
operator|)
literal|0
argument_list|,
literal|""
argument_list|,
name|rootmap
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/*    * Replace the initial null reference    */
name|free_mntfs
argument_list|(
name|root_node
operator|->
name|am_mnt
argument_list|)
expr_stmt|;
name|root_node
operator|->
name|am_mnt
operator|=
name|root_mnt
expr_stmt|;
comment|/*    * Initialize the root    */
if|if
condition|(
name|root_mnt
operator|->
name|mf_ops
operator|->
name|fs_init
condition|)
call|(
modifier|*
name|root_mnt
operator|->
name|mf_ops
operator|->
name|fs_init
call|)
argument_list|(
name|root_mnt
argument_list|)
expr_stmt|;
comment|/*    * Mount the root    */
name|root_mnt
operator|->
name|mf_error
operator|=
call|(
modifier|*
name|root_mnt
operator|->
name|mf_ops
operator|->
name|mount_fs
call|)
argument_list|(
name|root_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Cause all the nodes to be unmounted by timing  * them out.  */
end_comment

begin_function
name|void
name|umount_exported
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|last_used_map
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|am_node
modifier|*
name|mp
init|=
name|exported_ap
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|mp
condition|)
block|{
name|mntfs
modifier|*
name|mf
init|=
name|mp
operator|->
name|am_mnt
decl_stmt|;
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_UNMOUNTING
condition|)
block|{
comment|/* 	 * If this node is being unmounted then just ignore it.  However, 	 * this could prevent amd from finishing if the unmount gets blocked 	 * since the am_node will never be free'd.  am_unmounted needs 	 * telling about this possibility. - XXX 	 */
continue|continue;
block|}
if|if
condition|(
name|mf
operator|&&
operator|!
operator|(
name|mf
operator|->
name|mf_ops
operator|->
name|fs_flags
operator|&
name|FS_DIRECTORY
operator|)
condition|)
block|{
comment|/* 	 * When shutting down this had better 	 * look like a directory, otherwise it 	 * can't be unmounted! 	 */
name|mk_fattr
argument_list|(
name|mp
argument_list|,
name|NFDIR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|--
name|immediate_abort
operator|<
literal|0
operator|&&
operator|!
operator|(
name|mp
operator|->
name|am_flags
operator|&
name|AMF_ROOT
operator|)
operator|&&
name|mp
operator|->
name|am_parent
operator|)
operator|||
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_RESTART
operator|)
condition|)
block|{
comment|/* 	 * Just throw this node away without bothering to unmount it.  If 	 * the server is not known to be up then don't discard the mounted 	 * on directory or Amd might hang... 	 */
if|if
condition|(
name|mf
operator|->
name|mf_server
operator|&&
operator|(
name|mf
operator|->
name|mf_server
operator|->
name|fs_flags
operator|&
operator|(
name|FSF_DOWN
operator||
name|FSF_VALID
operator|)
operator|)
operator|!=
name|FSF_VALID
condition|)
name|mf
operator|->
name|mf_flags
operator|&=
operator|~
name|MFF_MKMNT
expr_stmt|;
if|if
condition|(
name|gopt
operator|.
name|flags
operator|&
name|CFM_UNMOUNT_ON_EXIT
condition|)
block|{
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"on-exit attempt to unmount %s"
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
name|unmount_node
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
name|am_unmounted
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * Any other node gets forcibly timed out. 	 */
name|mp
operator|->
name|am_flags
operator|&=
operator|~
name|AMF_NOTIMEOUT
expr_stmt|;
name|mp
operator|->
name|am_mnt
operator|->
name|mf_flags
operator|&=
operator|~
name|MFF_RSTKEEP
expr_stmt|;
name|mp
operator|->
name|am_ttl
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|am_timeo
operator|=
literal|1
expr_stmt|;
name|mp
operator|->
name|am_timeo_w
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|unmount_node
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
name|mntfs
modifier|*
name|mf
init|=
name|mp
operator|->
name|am_mnt
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_ERROR
operator|)
operator|||
name|mf
operator|->
name|mf_refc
operator|>
literal|1
condition|)
block|{
comment|/*      * Just unlink      */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_ERROR
condition|)
name|dlog
argument_list|(
literal|"No-op unmount of error node %s"
argument_list|,
name|mf
operator|->
name|mf_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Unmounting %s (%s)"
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|,
name|mf
operator|->
name|mf_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|error
operator|=
call|(
modifier|*
name|mf
operator|->
name|mf_ops
operator|->
name|umount_fs
call|)
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|errno
operator|=
name|error
expr_stmt|;
comment|/* XXX */
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"%s: unmount: %m"
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unmount_node_wrap
parameter_list|(
name|voidp
name|vp
parameter_list|)
block|{
return|return
name|unmount_node
argument_list|(
operator|(
name|am_node
operator|*
operator|)
name|vp
argument_list|)
return|;
comment|/*    * Below is the comment left from the old code    * that was dependent on the macro FLUSH_KERNEL_NAME_CACHE    */
comment|/*    * This code should just say:    * return unmount_node((am_node *) vp);    *    * However...    * The kernel keeps a cached copy of filehandles,    * and doesn't ever uncache them (apparently).  So    * when Amd times out a node the kernel will have a    * stale filehandle.  When the kernel next uses the    * filehandle it gets ESTALE.    *    * The workaround:    * Arrange that when a node is removed an unlink or    * rmdir is done on that path so that the kernel    * cache is done.  Yes - yuck.    *    * This can all be removed (and the background    * unmount flag in amfs_link_ops) if/when the kernel does    * something smarter.    *    * If the unlink or rmdir failed then just log a warning,    * don't fail the unmount.  This can occur if the kernel    * client code decides that the object is still referenced    * and should be renamed rather than discarded.    *    * There is still a race condition here...    * if another process is trying to access the same    * filesystem at the time we get here, then    * it will block, since the MF_UNMOUNTING flag will    * be set.  That may, or may not, cause the entire    * system to deadlock.  Hmmm...    */
block|}
end_function

begin_function
specifier|static
name|void
name|free_map_if_success
parameter_list|(
name|int
name|rc
parameter_list|,
name|int
name|term
parameter_list|,
name|voidp
name|closure
parameter_list|)
block|{
name|am_node
modifier|*
name|mp
init|=
operator|(
name|am_node
operator|*
operator|)
name|closure
decl_stmt|;
name|mntfs
modifier|*
name|mf
init|=
name|mp
operator|->
name|am_mnt
decl_stmt|;
comment|/*    * Not unmounting any more    */
name|mf
operator|->
name|mf_flags
operator|&=
operator|~
name|MFF_UNMOUNTING
expr_stmt|;
comment|/*    * If a timeout was deferred because the underlying filesystem    * was busy then arrange for a timeout as soon as possible.    */
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_WANTTIMO
condition|)
block|{
name|mf
operator|->
name|mf_flags
operator|&=
operator|~
name|MFF_WANTTIMO
expr_stmt|;
name|reschedule_timeout_mp
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|term
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"unmount for %s got signal %d"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|term
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGTRAP
argument_list|)
comment|/*      * dbx likes to put a trap on exit().      * Pretend it succeeded for now...      */
if|if
condition|(
name|term
operator|==
name|SIGTRAP
condition|)
block|{
name|am_unmounted
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
name|amd_stats
operator|.
name|d_uerr
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
condition|)
block|{
if|if
condition|(
name|mf
operator|->
name|mf_ops
operator|==
operator|&
name|amfs_program_ops
operator|||
name|rc
operator|==
name|EBUSY
condition|)
block|{
name|plog
argument_list|(
name|XLOG_STATS
argument_list|,
literal|"\"%s\" on %s still active"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errno
operator|=
name|rc
expr_stmt|;
comment|/* XXX */
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"%s: unmount: %m"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
block|}
name|amd_stats
operator|.
name|d_uerr
operator|++
expr_stmt|;
block|}
else|else
block|{
name|am_unmounted
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
comment|/*    * Wakeup anything waiting for this mount    */
name|wakeup
argument_list|(
operator|(
name|voidp
operator|)
name|mf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|unmount_mp
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
name|int
name|was_backgrounded
init|=
literal|0
decl_stmt|;
name|mntfs
modifier|*
name|mf
init|=
name|mp
operator|->
name|am_mnt
decl_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"\"%s\" on %s timed out"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|mp
operator|->
name|am_mnt
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* notdef */
if|if
condition|(
operator|(
name|mf
operator|->
name|mf_ops
operator|->
name|fs_flags
operator|&
name|FS_UBACKGROUND
operator|)
operator|&&
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_MOUNTED
operator|)
condition|)
block|{
if|if
condition|(
name|mf
operator|->
name|mf_refc
operator|==
literal|1
operator|&&
operator|!
name|FSRV_ISUP
argument_list|(
name|mf
operator|->
name|mf_server
argument_list|)
condition|)
block|{
comment|/*        * Don't try to unmount from a server that is known to be down        */
if|if
condition|(
operator|!
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_LOGDOWN
operator|)
condition|)
block|{
comment|/* Only log this once, otherwise gets a bit boring */
name|plog
argument_list|(
name|XLOG_STATS
argument_list|,
literal|"file server %s is down - timeout of \"%s\" ignored"
argument_list|,
name|mf
operator|->
name|mf_server
operator|->
name|fs_host
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_LOGDOWN
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Clear logdown flag - since the server must be up */
name|mf
operator|->
name|mf_flags
operator|&=
operator|~
name|MFF_LOGDOWN
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"\"%s\" on %s timed out"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|mp
operator|->
name|am_mnt
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
comment|/* dlog("Will background the unmount attempt"); */
endif|#
directive|endif
comment|/* DEBUG */
comment|/*        * Note that we are unmounting this node        */
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_UNMOUNTING
expr_stmt|;
name|run_task
argument_list|(
name|unmount_node_wrap
argument_list|,
operator|(
name|voidp
operator|)
name|mp
argument_list|,
name|free_map_if_success
argument_list|,
operator|(
name|voidp
operator|)
name|mp
argument_list|)
expr_stmt|;
name|was_backgrounded
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"unmount attempt backgrounded"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"\"%s\" on %s timed out"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|mp
operator|->
name|am_mnt
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
literal|"Trying unmount in foreground"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_UNMOUNTING
expr_stmt|;
name|free_map_if_success
argument_list|(
name|unmount_node
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|voidp
operator|)
name|mp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"unmount attempt done"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
return|return
name|was_backgrounded
return|;
block|}
end_function

begin_function
name|void
name|timeout_mp
parameter_list|(
name|voidp
name|v
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|time_t
name|t
init|=
name|NEVER
decl_stmt|;
name|time_t
name|now
init|=
name|clocktime
argument_list|()
decl_stmt|;
name|int
name|backoff
init|=
name|NumChild
operator|/
literal|4
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Timing out automount points..."
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
for|for
control|(
name|i
operator|=
name|last_used_map
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|am_node
modifier|*
name|mp
init|=
name|exported_ap
index|[
name|i
index|]
decl_stmt|;
name|mntfs
modifier|*
name|mf
decl_stmt|;
comment|/*      * Just continue if nothing mounted, or can't be timed out.      */
if|if
condition|(
operator|!
name|mp
operator|||
operator|(
name|mp
operator|->
name|am_flags
operator|&
name|AMF_NOTIMEOUT
operator|)
condition|)
continue|continue;
comment|/*      * Pick up mounted filesystem      */
name|mf
operator|=
name|mp
operator|->
name|am_mnt
expr_stmt|;
if|if
condition|(
operator|!
name|mf
condition|)
continue|continue;
comment|/*      * Don't delete last reference to a restarted filesystem.      */
if|if
condition|(
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_RSTKEEP
operator|)
operator|&&
name|mf
operator|->
name|mf_refc
operator|==
literal|1
condition|)
continue|continue;
comment|/*      * If there is action on this filesystem then ignore it      */
if|if
condition|(
operator|!
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|IGNORE_FLAGS
operator|)
condition|)
block|{
name|int
name|expired
init|=
literal|0
decl_stmt|;
name|mf
operator|->
name|mf_flags
operator|&=
operator|~
name|MFF_WANTTIMO
expr_stmt|;
if|if
condition|(
name|now
operator|>=
name|mp
operator|->
name|am_ttl
condition|)
block|{
if|if
condition|(
operator|!
name|backoff
condition|)
block|{
name|expired
operator|=
literal|1
expr_stmt|;
comment|/* 	   * Move the ttl forward to avoid thrashing effects 	   * on the next call to timeout! 	   */
comment|/* sun's -tw option */
if|if
condition|(
name|mp
operator|->
name|am_timeo_w
operator|<
literal|4
operator|*
name|gopt
operator|.
name|am_timeo_w
condition|)
name|mp
operator|->
name|am_timeo_w
operator|+=
name|gopt
operator|.
name|am_timeo_w
expr_stmt|;
name|mp
operator|->
name|am_ttl
operator|=
name|now
operator|+
name|mp
operator|->
name|am_timeo_w
expr_stmt|;
block|}
else|else
block|{
comment|/* 	   * Just backoff this unmount for 	   * a couple of seconds to avoid 	   * many multiple unmounts being 	   * started in parallel. 	   */
name|mp
operator|->
name|am_ttl
operator|=
name|now
operator|+
name|backoff
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/*        * If the next ttl is smallest, use that        */
name|t
operator|=
name|smallest_t
argument_list|(
name|t
argument_list|,
name|mp
operator|->
name|am_ttl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mp
operator|->
name|am_child
operator|&&
name|mf
operator|->
name|mf_error
operator|>=
literal|0
operator|&&
name|expired
condition|)
block|{
comment|/* 	 * If the unmount was backgrounded then 	 * bump the backoff counter. 	 */
if|if
condition|(
name|unmount_mp
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|backoff
operator|=
literal|2
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_UNMOUNTING
condition|)
block|{
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_WANTTIMO
expr_stmt|;
block|}
block|}
if|if
condition|(
name|t
operator|==
name|NEVER
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"No further timeouts"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|t
operator|=
name|now
operator|+
name|ONE_HOUR
expr_stmt|;
block|}
comment|/*    * Sanity check to avoid runaways.    * Absolutely should never get this but    * if you do without this trap amd will thrash.    */
if|if
condition|(
name|t
operator|<=
name|now
condition|)
block|{
name|t
operator|=
name|now
operator|+
literal|6
expr_stmt|;
comment|/* XXX */
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"Got a zero interval in timeout_mp()!"
argument_list|)
expr_stmt|;
block|}
comment|/*    * XXX - when shutting down, make things happen faster    */
if|if
condition|(
operator|(
name|int
operator|)
name|amd_state
operator|>=
operator|(
name|int
operator|)
name|Finishing
condition|)
name|t
operator|=
name|now
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Next mount timeout in %lds"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|t
operator|-
name|now
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|timeout_mp_id
operator|=
name|timeout
argument_list|(
name|t
operator|-
name|now
argument_list|,
name|timeout_mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Cause timeout_mp to be called soonest  */
end_comment

begin_function
name|void
name|reschedule_timeout_mp
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|timeout_mp_id
condition|)
name|untimeout
argument_list|(
name|timeout_mp_id
argument_list|)
expr_stmt|;
name|timeout_mp_id
operator|=
name|timeout
argument_list|(
literal|0
argument_list|,
name|timeout_mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

