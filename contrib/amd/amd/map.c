begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997-2006 Erez Zadok  * Copyright (c) 1990 Jan-Simon Pendry  * Copyright (c) 1990 Imperial College of Science, Technology& Medicine  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry at Imperial College, London.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgment:  *      This product includes software developed by the University of  *      California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *  * File: am-utils/amd/map.c  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<am_defs.h>
end_include

begin_include
include|#
directive|include
file|<amd.h>
end_include

begin_define
define|#
directive|define
name|smallest_t
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
value|(t1 != NEVER ? (t2 != NEVER ? (t1< t2 ? t1 : t2) : t1) : t2)
end_define

begin_define
define|#
directive|define
name|IGNORE_FLAGS
value|(MFF_MOUNTING|MFF_UNMOUNTING|MFF_RESTART)
end_define

begin_define
define|#
directive|define
name|new_gen
parameter_list|()
value|(am_gen++)
end_define

begin_comment
comment|/*  * Generation Numbers.  *  * Generation numbers are allocated to every node created  * by amd.  When a filehandle is computed and sent to the  * kernel, the generation number makes sure that it is safe  * to reallocate a node slot even when the kernel has a cached  * reference to its old incarnation.  * No garbage collection is done, since it is assumed that  * there is no way that 2^32 generation numbers could ever  * be allocated by a single run of amd - there is simply  * not enough cpu time available.  * Famous last words... -Ion  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|am_gen
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initial generation number */
end_comment

begin_decl_stmt
specifier|static
name|int
name|timeout_mp_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Id from last call to timeout */
end_comment

begin_decl_stmt
specifier|static
name|am_node
modifier|*
name|root_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The root of the mount tree */
end_comment

begin_decl_stmt
specifier|static
name|am_node
modifier|*
modifier|*
name|exported_ap
init|=
operator|(
name|am_node
operator|*
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|exported_ap_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|first_free_map
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First available free slot */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_used_map
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last unavailable used slot */
end_comment

begin_comment
comment|/*  * This is the default attributes field which  * is copied into every new node to be created.  * The individual filesystem fs_init() routines  * patch the copy to represent the particular  * details for the relevant filesystem type  */
end_comment

begin_decl_stmt
specifier|static
name|nfsfattr
name|gen_fattr
init|=
block|{
name|NFLNK
block|,
comment|/* type */
name|NFSMODE_LNK
operator||
literal|0777
block|,
comment|/* mode */
literal|1
block|,
comment|/* nlink */
literal|0
block|,
comment|/* uid */
literal|0
block|,
comment|/* gid */
literal|0
block|,
comment|/* size */
literal|4096
block|,
comment|/* blocksize */
literal|0
block|,
comment|/* rdev */
literal|1
block|,
comment|/* blocks */
literal|0
block|,
comment|/* fsid */
literal|0
block|,
comment|/* fileid */
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* atime */
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* mtime */
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* ctime */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* forward declarations */
end_comment

begin_function_decl
specifier|static
name|int
name|unmount_node
parameter_list|(
name|opaque_t
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|exported_ap_free
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_am
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|am_node
modifier|*
name|get_root_ap
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Iterator functions for exported_ap[]  */
end_comment

begin_function
name|am_node
modifier|*
name|get_first_exported_ap
parameter_list|(
name|int
modifier|*
name|index
parameter_list|)
block|{
operator|*
name|index
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|get_next_exported_ap
argument_list|(
name|index
argument_list|)
return|;
block|}
end_function

begin_function
name|am_node
modifier|*
name|get_next_exported_ap
parameter_list|(
name|int
modifier|*
name|index
parameter_list|)
block|{
operator|(
operator|*
name|index
operator|)
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|index
operator|<
name|exported_ap_size
condition|)
block|{
if|if
condition|(
name|exported_ap
index|[
operator|*
name|index
index|]
operator|!=
name|NULL
condition|)
return|return
name|exported_ap
index|[
operator|*
name|index
index|]
return|;
operator|(
operator|*
name|index
operator|)
operator|++
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Get exported_ap by index  */
end_comment

begin_function
name|am_node
modifier|*
name|get_exported_ap
parameter_list|(
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|exported_ap_size
condition|)
return|return
literal|0
return|;
return|return
name|exported_ap
index|[
name|index
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Get exported_ap by path  */
end_comment

begin_function
name|am_node
modifier|*
name|path_to_exported_ap
parameter_list|(
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|am_node
modifier|*
name|mp
decl_stmt|;
name|mp
operator|=
name|get_first_exported_ap
argument_list|(
operator|&
name|index
argument_list|)
expr_stmt|;
while|while
condition|(
name|mp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|mp
operator|->
name|am_path
argument_list|,
name|path
argument_list|)
condition|)
break|break;
name|mp
operator|=
name|get_next_exported_ap
argument_list|(
operator|&
name|index
argument_list|)
expr_stmt|;
block|}
return|return
name|mp
return|;
block|}
end_function

begin_comment
comment|/*  * Resize exported_ap map  */
end_comment

begin_function
specifier|static
name|int
name|exported_ap_realloc_map
parameter_list|(
name|int
name|nsize
parameter_list|)
block|{
comment|/*    * this shouldn't happen, but...    */
if|if
condition|(
name|nsize
operator|<
literal|0
operator|||
name|nsize
operator|==
name|exported_ap_size
condition|)
return|return
literal|0
return|;
name|exported_ap
operator|=
operator|(
name|am_node
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|voidp
operator|)
name|exported_ap
argument_list|,
name|nsize
operator|*
sizeof|sizeof
argument_list|(
name|am_node
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsize
operator|>
name|exported_ap_size
condition|)
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|exported_ap
operator|+
name|exported_ap_size
operator|)
argument_list|,
literal|0
argument_list|,
operator|(
name|nsize
operator|-
name|exported_ap_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|am_node
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|exported_ap_size
operator|=
name|nsize
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|am_node
modifier|*
name|get_ap_child
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|,
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|am_node
modifier|*
name|new_mp
decl_stmt|;
name|mntfs
modifier|*
name|mf
init|=
name|mp
operator|->
name|am_mnt
decl_stmt|;
comment|/*    * Allocate a new map    */
name|new_mp
operator|=
name|exported_ap_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_mp
condition|)
block|{
comment|/*      * Fill it in      */
name|init_map
argument_list|(
name|new_mp
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/*      * Put it in the table      */
name|insert_am
argument_list|(
name|new_mp
argument_list|,
name|mp
argument_list|)
expr_stmt|;
comment|/*      * Fill in some other fields,      * path and mount point.      *      * bugfix: do not prepend old am_path if direct map      *<wls@astro.umd.edu> William Sebok      */
name|new_mp
operator|->
name|am_path
operator|=
name|str3cat
argument_list|(
name|new_mp
operator|->
name|am_path
argument_list|,
operator|(
name|mf
operator|->
name|mf_fsflags
operator|&
name|FS_DIRECT
operator|)
condition|?
literal|""
else|:
name|mp
operator|->
name|am_path
argument_list|,
operator|*
name|fname
operator|==
literal|'/'
condition|?
literal|""
else|:
literal|"/"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
literal|"setting path to %s"
argument_list|,
name|new_mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
block|}
return|return
name|new_mp
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new mount slot and create  * a new node.  * Fills in the map number of the node,  * but leaves everything else uninitialized.  */
end_comment

begin_function
name|am_node
modifier|*
name|exported_ap_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|am_node
modifier|*
name|mp
decl_stmt|,
modifier|*
modifier|*
name|mpp
decl_stmt|;
comment|/*    * First check if there are any slots left, realloc if needed    */
if|if
condition|(
name|first_free_map
operator|>=
name|exported_ap_size
condition|)
if|if
condition|(
operator|!
name|exported_ap_realloc_map
argument_list|(
name|exported_ap_size
operator|+
name|NEXP_AP
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/*    * Grab the next free slot    */
name|mpp
operator|=
name|exported_ap
operator|+
name|first_free_map
expr_stmt|;
name|mp
operator|=
operator|*
name|mpp
operator|=
name|ALLOC
argument_list|(
expr|struct
name|am_node
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|am_node
argument_list|)
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_mapno
operator|=
name|first_free_map
operator|++
expr_stmt|;
comment|/*    * Update free pointer    */
while|while
condition|(
name|first_free_map
operator|<
name|exported_ap_size
operator|&&
name|exported_ap
index|[
name|first_free_map
index|]
condition|)
name|first_free_map
operator|++
expr_stmt|;
if|if
condition|(
name|first_free_map
operator|>
name|last_used_map
condition|)
name|last_used_map
operator|=
name|first_free_map
operator|-
literal|1
expr_stmt|;
return|return
name|mp
return|;
block|}
end_function

begin_comment
comment|/*  * Free a mount slot  */
end_comment

begin_function
specifier|static
name|void
name|exported_ap_free
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
comment|/*    * Sanity check    */
if|if
condition|(
operator|!
name|mp
condition|)
return|return;
comment|/*    * Zero the slot pointer to avoid double free's    */
name|exported_ap
index|[
name|mp
operator|->
name|am_mapno
index|]
operator|=
literal|0
expr_stmt|;
comment|/*    * Update the free and last_used indices    */
if|if
condition|(
name|mp
operator|->
name|am_mapno
operator|==
name|last_used_map
condition|)
while|while
condition|(
name|last_used_map
operator|>=
literal|0
operator|&&
name|exported_ap
index|[
name|last_used_map
index|]
operator|==
literal|0
condition|)
operator|--
name|last_used_map
expr_stmt|;
if|if
condition|(
name|first_free_map
operator|>
name|mp
operator|->
name|am_mapno
condition|)
name|first_free_map
operator|=
name|mp
operator|->
name|am_mapno
expr_stmt|;
comment|/*    * Free the mount node, and zero out it's internal struct data.    */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|am_node
argument_list|)
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Insert mp into the correct place,  * where p_mp is its parent node.  * A new node gets placed as the youngest sibling  * of any other children, and the parent's child  * pointer is adjusted to point to the new child node.  */
end_comment

begin_function
name|void
name|insert_am
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|,
name|am_node
modifier|*
name|p_mp
parameter_list|)
block|{
comment|/*    * If this is going in at the root then flag it    * so that it cannot be unmounted by amq.    */
if|if
condition|(
name|p_mp
operator|==
name|root_node
condition|)
name|mp
operator|->
name|am_flags
operator||=
name|AMF_ROOT
expr_stmt|;
comment|/*    * Fill in n-way links    */
name|mp
operator|->
name|am_parent
operator|=
name|p_mp
expr_stmt|;
name|mp
operator|->
name|am_osib
operator|=
name|p_mp
operator|->
name|am_child
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_osib
condition|)
name|mp
operator|->
name|am_osib
operator|->
name|am_ysib
operator|=
name|mp
expr_stmt|;
name|p_mp
operator|->
name|am_child
operator|=
name|mp
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FS_AUTOFS
if|if
condition|(
name|p_mp
operator|->
name|am_mnt
operator|->
name|mf_flags
operator|&
name|MFF_IS_AUTOFS
condition|)
name|mp
operator|->
name|am_flags
operator||=
name|AMF_AUTOFS
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_FS_AUTOFS */
block|}
end_function

begin_comment
comment|/*  * Remove am from its place in the mount tree  */
end_comment

begin_function
specifier|static
name|void
name|remove_am
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
comment|/*    * 1.  Consistency check    */
if|if
condition|(
name|mp
operator|->
name|am_child
operator|&&
name|mp
operator|->
name|am_parent
condition|)
block|{
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"children of \"%s\" still exist - deleting anyway"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
block|}
comment|/*    * 2.  Update parent's child pointer    */
if|if
condition|(
name|mp
operator|->
name|am_parent
operator|&&
name|mp
operator|->
name|am_parent
operator|->
name|am_child
operator|==
name|mp
condition|)
name|mp
operator|->
name|am_parent
operator|->
name|am_child
operator|=
name|mp
operator|->
name|am_osib
expr_stmt|;
comment|/*    * 3.  Unlink from sibling chain    */
if|if
condition|(
name|mp
operator|->
name|am_ysib
condition|)
name|mp
operator|->
name|am_ysib
operator|->
name|am_osib
operator|=
name|mp
operator|->
name|am_osib
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_osib
condition|)
name|mp
operator|->
name|am_osib
operator|->
name|am_ysib
operator|=
name|mp
operator|->
name|am_ysib
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compute a new time to live value for a node.  */
end_comment

begin_function
name|void
name|new_ttl
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
name|mp
operator|->
name|am_timeo_w
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|am_ttl
operator|=
name|clocktime
argument_list|(
operator|&
name|mp
operator|->
name|am_fattr
operator|.
name|na_atime
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_ttl
operator|+=
name|mp
operator|->
name|am_timeo
expr_stmt|;
comment|/* sun's -tl option */
block|}
end_function

begin_function
name|void
name|mk_fattr
parameter_list|(
name|nfsfattr
modifier|*
name|fattr
parameter_list|,
name|nfsftype
name|vntype
parameter_list|)
block|{
switch|switch
condition|(
name|vntype
condition|)
block|{
case|case
name|NFDIR
case|:
name|fattr
operator|->
name|na_type
operator|=
name|NFDIR
expr_stmt|;
name|fattr
operator|->
name|na_mode
operator|=
name|NFSMODE_DIR
operator||
literal|0555
expr_stmt|;
name|fattr
operator|->
name|na_nlink
operator|=
literal|2
expr_stmt|;
name|fattr
operator|->
name|na_size
operator|=
literal|512
expr_stmt|;
break|break;
case|case
name|NFLNK
case|:
name|fattr
operator|->
name|na_type
operator|=
name|NFLNK
expr_stmt|;
name|fattr
operator|->
name|na_mode
operator|=
name|NFSMODE_LNK
operator||
literal|0777
expr_stmt|;
name|fattr
operator|->
name|na_nlink
operator|=
literal|1
expr_stmt|;
name|fattr
operator|->
name|na_size
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|plog
argument_list|(
name|XLOG_FATAL
argument_list|,
literal|"Unknown fattr type %d - ignored"
argument_list|,
name|vntype
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize an allocated mount node.  * It is assumed that the mount node was b-zero'd  * before getting here so anything that would  * be set to zero isn't done here.  */
end_comment

begin_function
name|void
name|init_map
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|,
name|char
modifier|*
name|dir
parameter_list|)
block|{
comment|/*    * mp->am_mapno is initialized by exported_ap_alloc    * other fields don't need to be set to zero.    */
name|mp
operator|->
name|am_mnt
operator|=
name|new_mntfs
argument_list|()
expr_stmt|;
name|mp
operator|->
name|am_mfarray
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|am_name
operator|=
name|strdup
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_path
operator|=
name|strdup
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_gen
operator|=
name|new_gen
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FS_AUTOFS
name|mp
operator|->
name|am_autofs_fh
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_FS_AUTOFS */
name|mp
operator|->
name|am_timeo
operator|=
name|gopt
operator|.
name|am_timeo
expr_stmt|;
name|mp
operator|->
name|am_attr
operator|.
name|ns_status
operator|=
name|NFS_OK
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|=
name|gen_fattr
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|.
name|na_fsid
operator|=
literal|42
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|.
name|na_fileid
operator|=
name|mp
operator|->
name|am_gen
expr_stmt|;
name|clocktime
argument_list|(
operator|&
name|mp
operator|->
name|am_fattr
operator|.
name|na_atime
argument_list|)
expr_stmt|;
comment|/* next line copies a "struct nfstime" among several fields */
name|mp
operator|->
name|am_fattr
operator|.
name|na_mtime
operator|=
name|mp
operator|->
name|am_fattr
operator|.
name|na_ctime
operator|=
name|mp
operator|->
name|am_fattr
operator|.
name|na_atime
expr_stmt|;
name|new_ttl
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_stats
operator|.
name|s_mtime
operator|=
name|mp
operator|->
name|am_fattr
operator|.
name|na_atime
operator|.
name|nt_seconds
expr_stmt|;
name|mp
operator|->
name|am_dev
operator|=
operator|-
literal|1
expr_stmt|;
name|mp
operator|->
name|am_rdev
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free a mount node.  * The node must be already unmounted.  */
end_comment

begin_function
name|void
name|free_map
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
name|remove_am
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_link
condition|)
name|XFREE
argument_list|(
name|mp
operator|->
name|am_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_name
condition|)
name|XFREE
argument_list|(
name|mp
operator|->
name|am_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_path
condition|)
name|XFREE
argument_list|(
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_pref
condition|)
name|XFREE
argument_list|(
name|mp
operator|->
name|am_pref
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_transp
condition|)
name|XFREE
argument_list|(
name|mp
operator|->
name|am_transp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_mnt
condition|)
name|free_mntfs
argument_list|(
name|mp
operator|->
name|am_mnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_mfarray
condition|)
block|{
name|mntfs
modifier|*
modifier|*
name|temp_mf
decl_stmt|;
for|for
control|(
name|temp_mf
operator|=
name|mp
operator|->
name|am_mfarray
init|;
operator|*
name|temp_mf
condition|;
name|temp_mf
operator|++
control|)
name|free_mntfs
argument_list|(
operator|*
name|temp_mf
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|mp
operator|->
name|am_mfarray
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_FS_AUTOFS
if|if
condition|(
name|mp
operator|->
name|am_autofs_fh
condition|)
name|autofs_release_fh
argument_list|(
name|mp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_FS_AUTOFS */
name|exported_ap_free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|am_node
modifier|*
name|find_ap_recursive
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|,
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
if|if
condition|(
name|mp
condition|)
block|{
name|am_node
modifier|*
name|mp2
decl_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|mp
operator|->
name|am_path
argument_list|,
name|dir
argument_list|)
condition|)
return|return
name|mp
return|;
if|if
condition|(
operator|(
name|mp
operator|->
name|am_mnt
operator|->
name|mf_flags
operator|&
name|MFF_MOUNTED
operator|)
operator|&&
name|STREQ
argument_list|(
name|mp
operator|->
name|am_mnt
operator|->
name|mf_mount
argument_list|,
name|dir
argument_list|)
condition|)
return|return
name|mp
return|;
name|mp2
operator|=
name|find_ap_recursive
argument_list|(
name|dir
argument_list|,
name|mp
operator|->
name|am_osib
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp2
condition|)
return|return
name|mp2
return|;
return|return
name|find_ap_recursive
argument_list|(
name|dir
argument_list|,
name|mp
operator|->
name|am_child
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Find the mount node corresponding to dir.  dir can match either the  * automount path or, if the node is mounted, the mount location.  */
end_comment

begin_function
name|am_node
modifier|*
name|find_ap
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|last_used_map
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|am_node
modifier|*
name|mp
init|=
name|exported_ap
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|mp
operator|&&
operator|(
name|mp
operator|->
name|am_flags
operator|&
name|AMF_ROOT
operator|)
condition|)
block|{
name|mp
operator|=
name|find_ap_recursive
argument_list|(
name|dir
argument_list|,
name|exported_ap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
condition|)
block|{
return|return
name|mp
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Find the mount node corresponding  * to the mntfs structure.  */
end_comment

begin_function
name|am_node
modifier|*
name|find_mf
parameter_list|(
name|mntfs
modifier|*
name|mf
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|last_used_map
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|am_node
modifier|*
name|mp
init|=
name|exported_ap
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|mp
operator|&&
name|mp
operator|->
name|am_mnt
operator|==
name|mf
condition|)
return|return
name|mp
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Get the filehandle for a particular named directory.  * This is used during the bootstrap to tell the kernel  * the filehandles of the initial automount points.  */
end_comment

begin_function
name|am_nfs_fh
modifier|*
name|get_root_nfs_fh
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|)
block|{
specifier|static
name|am_nfs_fh
name|nfh
decl_stmt|;
name|am_node
modifier|*
name|mp
init|=
name|get_root_ap
argument_list|(
name|dir
argument_list|)
decl_stmt|;
if|if
condition|(
name|mp
condition|)
block|{
name|mp_to_fh
argument_list|(
name|mp
argument_list|,
operator|&
name|nfh
argument_list|)
expr_stmt|;
return|return
operator|&
name|nfh
return|;
block|}
comment|/*    * Should never get here...    */
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"Can't find root filehandle for %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|am_node
modifier|*
name|get_root_ap
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|)
block|{
name|am_node
modifier|*
name|mp
init|=
name|find_ap
argument_list|(
name|dir
argument_list|)
decl_stmt|;
if|if
condition|(
name|mp
operator|&&
name|mp
operator|->
name|am_parent
operator|==
name|root_node
condition|)
return|return
name|mp
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Timeout all nodes waiting on  * a given Fserver.  */
end_comment

begin_function
name|void
name|map_flush_srvr
parameter_list|(
name|fserver
modifier|*
name|fs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|last_used_map
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|am_node
modifier|*
name|mp
init|=
name|exported_ap
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|mp
operator|&&
name|mp
operator|->
name|am_mnt
operator|&&
name|mp
operator|->
name|am_mnt
operator|->
name|mf_server
operator|==
name|fs
condition|)
block|{
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"Flushed %s; dependent on %s"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_ttl
operator|=
name|clocktime
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|done
condition|)
name|reschedule_timeout_mp
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mount a top level automount node  * by calling lookup in the parent  * (root) node which will cause the  * automount node to be automounted.  */
end_comment

begin_function
name|int
name|mount_auto_node
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|,
name|opaque_t
name|arg
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|am_node
modifier|*
name|mp
init|=
operator|(
name|am_node
operator|*
operator|)
name|arg
decl_stmt|;
name|am_node
modifier|*
name|new_mp
decl_stmt|;
name|new_mp
operator|=
name|mp
operator|->
name|am_mnt
operator|->
name|mf_ops
operator|->
name|lookup_child
argument_list|(
name|mp
argument_list|,
name|dir
argument_list|,
operator|&
name|error
argument_list|,
name|VLOOK_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_mp
operator|&&
name|error
operator|<
literal|0
condition|)
block|{
comment|/*      * We can't allow the fileid of the root node to change.      * Should be ok to force it to 1, always.      */
name|new_mp
operator|->
name|am_gen
operator|=
name|new_mp
operator|->
name|am_fattr
operator|.
name|na_fileid
operator|=
literal|1
expr_stmt|;
name|new_mp
operator|=
name|mp
operator|->
name|am_mnt
operator|->
name|mf_ops
operator|->
name|mount_child
argument_list|(
name|new_mp
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|>
literal|0
condition|)
block|{
name|errno
operator|=
name|error
expr_stmt|;
comment|/* XXX */
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"Could not mount %s: %m"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Cause all the top-level mount nodes  * to be automounted  */
end_comment

begin_function
name|int
name|mount_exported
parameter_list|(
name|void
parameter_list|)
block|{
comment|/*    * Iterate over all the nodes to be started    */
return|return
name|root_keyiter
argument_list|(
name|mount_auto_node
argument_list|,
name|root_node
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Construct top-level node  */
end_comment

begin_function
name|void
name|make_root_node
parameter_list|(
name|void
parameter_list|)
block|{
name|mntfs
modifier|*
name|root_mnt
decl_stmt|;
name|char
modifier|*
name|rootmap
init|=
name|ROOT_MAP
decl_stmt|;
name|root_node
operator|=
name|exported_ap_alloc
argument_list|()
expr_stmt|;
comment|/*    * Allocate a new map    */
name|init_map
argument_list|(
name|root_node
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/*    * Allocate a new mounted filesystem    */
name|root_mnt
operator|=
name|find_mntfs
argument_list|(
operator|&
name|amfs_root_ops
argument_list|,
operator|(
name|am_opts
operator|*
operator|)
literal|0
argument_list|,
literal|""
argument_list|,
name|rootmap
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/*    * Replace the initial null reference    */
name|free_mntfs
argument_list|(
name|root_node
operator|->
name|am_mnt
argument_list|)
expr_stmt|;
name|root_node
operator|->
name|am_mnt
operator|=
name|root_mnt
expr_stmt|;
comment|/*    * Initialize the root    */
if|if
condition|(
name|root_mnt
operator|->
name|mf_ops
operator|->
name|fs_init
condition|)
call|(
modifier|*
name|root_mnt
operator|->
name|mf_ops
operator|->
name|fs_init
call|)
argument_list|(
name|root_mnt
argument_list|)
expr_stmt|;
comment|/*    * Mount the root    */
name|root_mnt
operator|->
name|mf_error
operator|=
name|root_mnt
operator|->
name|mf_ops
operator|->
name|mount_fs
argument_list|(
name|root_node
argument_list|,
name|root_mnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Cause all the nodes to be unmounted by timing  * them out.  */
end_comment

begin_function
name|void
name|umount_exported
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|last_used_map
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|am_node
modifier|*
name|mp
init|=
name|exported_ap
index|[
name|i
index|]
decl_stmt|;
name|mntfs
modifier|*
name|mf
decl_stmt|;
if|if
condition|(
operator|!
name|mp
condition|)
continue|continue;
name|mf
operator|=
name|mp
operator|->
name|am_mnt
expr_stmt|;
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_UNMOUNTING
condition|)
block|{
comment|/*        * If this node is being unmounted then just ignore it.  However,        * this could prevent amd from finishing if the unmount gets blocked        * since the am_node will never be free'd.  am_unmounted needs        * telling about this possibility. - XXX        */
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|mf
operator|->
name|mf_fsflags
operator|&
name|FS_DIRECTORY
operator|)
condition|)
comment|/*        * When shutting down this had better        * look like a directory, otherwise it        * can't be unmounted!        */
name|mk_fattr
argument_list|(
operator|&
name|mp
operator|->
name|am_fattr
argument_list|,
name|NFDIR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|--
name|immediate_abort
operator|<
literal|0
operator|&&
operator|!
operator|(
name|mp
operator|->
name|am_flags
operator|&
name|AMF_ROOT
operator|)
operator|&&
name|mp
operator|->
name|am_parent
operator|)
operator|||
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_RESTART
operator|)
condition|)
block|{
comment|/*        * Just throw this node away without bothering to unmount it.  If        * the server is not known to be up then don't discard the mounted        * on directory or Amd might hang...        */
if|if
condition|(
name|mf
operator|->
name|mf_server
operator|&&
operator|(
name|mf
operator|->
name|mf_server
operator|->
name|fs_flags
operator|&
operator|(
name|FSF_DOWN
operator||
name|FSF_VALID
operator|)
operator|)
operator|!=
name|FSF_VALID
condition|)
name|mf
operator|->
name|mf_flags
operator|&=
operator|~
name|MFF_MKMNT
expr_stmt|;
if|if
condition|(
name|gopt
operator|.
name|flags
operator|&
name|CFM_UNMOUNT_ON_EXIT
operator|||
name|mp
operator|->
name|am_flags
operator|&
name|AMF_AUTOFS
condition|)
block|{
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"on-exit attempt to unmount %s"
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
comment|/* 	 * use unmount_mp, not unmount_node, so that unmounts be 	 * backgrounded as needed. 	 */
name|unmount_mp
argument_list|(
operator|(
name|opaque_t
operator|)
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|am_unmounted
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
name|exported_ap
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/*        * Any other node gets forcibly timed out.        */
name|mp
operator|->
name|am_flags
operator|&=
operator|~
name|AMF_NOTIMEOUT
expr_stmt|;
name|mp
operator|->
name|am_mnt
operator|->
name|mf_flags
operator|&=
operator|~
name|MFF_RSTKEEP
expr_stmt|;
name|mp
operator|->
name|am_ttl
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|am_timeo
operator|=
literal|1
expr_stmt|;
name|mp
operator|->
name|am_timeo_w
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Try to mount a file system.  Can be called directly or in a sub-process by run_task.  *  * Warning: this function might be running in a child process context.  * Don't expect any changes made here to survive in the parent amd process.  */
end_comment

begin_function
name|int
name|mount_node
parameter_list|(
name|opaque_t
name|arg
parameter_list|)
block|{
name|am_node
modifier|*
name|mp
init|=
operator|(
name|am_node
operator|*
operator|)
name|arg
decl_stmt|;
name|mntfs
modifier|*
name|mf
init|=
name|mp
operator|->
name|am_mnt
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FS_AUTOFS
if|if
condition|(
name|mp
operator|->
name|am_flags
operator|&
name|AMF_AUTOFS
condition|)
name|error
operator|=
name|autofs_mount_fs
argument_list|(
name|mp
argument_list|,
name|mf
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
comment|/* HAVE_FS_AUTOFS */
if|if
condition|(
operator|!
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_MOUNTED
operator|)
condition|)
name|error
operator|=
name|mf
operator|->
name|mf_ops
operator|->
name|mount_fs
argument_list|(
name|mp
argument_list|,
name|mf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>
literal|0
condition|)
name|dlog
argument_list|(
literal|"mount_node: call to mf_ops->mount_fs(%s) failed: %s"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|strerror
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unmount_node
parameter_list|(
name|opaque_t
name|arg
parameter_list|)
block|{
name|am_node
modifier|*
name|mp
init|=
operator|(
name|am_node
operator|*
operator|)
name|arg
decl_stmt|;
name|mntfs
modifier|*
name|mf
init|=
name|mp
operator|->
name|am_mnt
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_ERROR
condition|)
block|{
comment|/*      * Just unlink      */
name|dlog
argument_list|(
literal|"No-op unmount of error node %s"
argument_list|,
name|mf
operator|->
name|mf_info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dlog
argument_list|(
literal|"Unmounting<%s><%s> (%s) flags %x"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|,
name|mf
operator|->
name|mf_info
argument_list|,
name|mf
operator|->
name|mf_flags
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FS_AUTOFS
if|if
condition|(
name|mp
operator|->
name|am_flags
operator|&
name|AMF_AUTOFS
condition|)
name|error
operator|=
name|autofs_umount_fs
argument_list|(
name|mp
argument_list|,
name|mf
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
comment|/* HAVE_FS_AUTOFS */
if|if
condition|(
name|mf
operator|->
name|mf_refc
operator|==
literal|1
condition|)
name|error
operator|=
name|mf
operator|->
name|mf_ops
operator|->
name|umount_fs
argument_list|(
name|mp
argument_list|,
name|mf
argument_list|)
expr_stmt|;
block|}
comment|/* do this again, it might have changed */
name|mf
operator|=
name|mp
operator|->
name|am_mnt
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|errno
operator|=
name|error
expr_stmt|;
comment|/* XXX */
name|dlog
argument_list|(
literal|"%s: unmount: %m"
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_map_if_success
parameter_list|(
name|int
name|rc
parameter_list|,
name|int
name|term
parameter_list|,
name|opaque_t
name|arg
parameter_list|)
block|{
name|am_node
modifier|*
name|mp
init|=
operator|(
name|am_node
operator|*
operator|)
name|arg
decl_stmt|;
name|mntfs
modifier|*
name|mf
init|=
name|mp
operator|->
name|am_mnt
decl_stmt|;
name|wchan_t
name|wchan
init|=
name|get_mntfs_wchan
argument_list|(
name|mf
argument_list|)
decl_stmt|;
comment|/*    * Not unmounting any more    */
name|mf
operator|->
name|mf_flags
operator|&=
operator|~
name|MFF_UNMOUNTING
expr_stmt|;
comment|/*    * If a timeout was deferred because the underlying filesystem    * was busy then arrange for a timeout as soon as possible.    */
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_WANTTIMO
condition|)
block|{
name|mf
operator|->
name|mf_flags
operator|&=
operator|~
name|MFF_WANTTIMO
expr_stmt|;
name|reschedule_timeout_mp
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|term
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"unmount for %s got signal %d"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|term
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGTRAP
argument_list|)
comment|/*      * dbx likes to put a trap on exit().      * Pretend it succeeded for now...      */
if|if
condition|(
name|term
operator|==
name|SIGTRAP
condition|)
block|{
name|am_unmounted
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
ifdef|#
directive|ifdef
name|HAVE_FS_AUTOFS
if|if
condition|(
name|mp
operator|->
name|am_flags
operator|&
name|AMF_AUTOFS
condition|)
name|autofs_umount_failed
argument_list|(
name|mp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_FS_AUTOFS */
name|amd_stats
operator|.
name|d_uerr
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
condition|)
block|{
if|if
condition|(
name|mf
operator|->
name|mf_ops
operator|==
operator|&
name|amfs_program_ops
operator|||
name|rc
operator|==
name|EBUSY
condition|)
name|plog
argument_list|(
name|XLOG_STATS
argument_list|,
literal|"\"%s\" on %s still active"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
else|else
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"%s: unmount: %s"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|strerror
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FS_AUTOFS
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_IS_AUTOFS
condition|)
name|autofs_get_mp
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_flags
operator|&
name|AMF_AUTOFS
condition|)
name|autofs_umount_failed
argument_list|(
name|mp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_FS_AUTOFS */
name|amd_stats
operator|.
name|d_uerr
operator|++
expr_stmt|;
block|}
else|else
block|{
name|am_unmounted
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
comment|/*    * Wakeup anything waiting for this unmount    */
name|wakeup
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|unmount_mp
parameter_list|(
name|am_node
modifier|*
name|mp
parameter_list|)
block|{
name|int
name|was_backgrounded
init|=
literal|0
decl_stmt|;
name|mntfs
modifier|*
name|mf
init|=
name|mp
operator|->
name|am_mnt
decl_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"\"%s\" on %s timed out (flags 0x%x)"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|mp
operator|->
name|am_mnt
operator|->
name|mf_mount
argument_list|,
operator|(
name|int
operator|)
name|mf
operator|->
name|mf_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* notdef */
ifndef|#
directive|ifndef
name|MNT2_NFS_OPT_SYMTTL
comment|/*      * This code is needed to defeat Solaris 2.4's (and newer) symlink      * values cache.  It forces the last-modified time of the symlink to be      * current.  It is not needed if the O/S has an nfs flag to turn off the      * symlink-cache at mount time (such as Irix 5.x and 6.x). -Erez.      *      * Additionally, Linux currently ignores the nt_useconds field,      * so we must update the nt_seconds field every time if clocktime(NULL)      * didn't return a new number of seconds.      */
if|if
condition|(
name|mp
operator|->
name|am_parent
condition|)
block|{
name|time_t
name|last
init|=
name|mp
operator|->
name|am_parent
operator|->
name|am_attr
operator|.
name|ns_u
operator|.
name|ns_attr_u
operator|.
name|na_mtime
operator|.
name|nt_seconds
decl_stmt|;
name|clocktime
argument_list|(
operator|&
name|mp
operator|->
name|am_parent
operator|->
name|am_attr
operator|.
name|ns_u
operator|.
name|ns_attr_u
operator|.
name|na_mtime
argument_list|)
expr_stmt|;
comment|/* defensive programming... can't we assert the above condition? */
if|if
condition|(
name|last
operator|==
operator|(
name|time_t
operator|)
name|mp
operator|->
name|am_parent
operator|->
name|am_attr
operator|.
name|ns_u
operator|.
name|ns_attr_u
operator|.
name|na_mtime
operator|.
name|nt_seconds
condition|)
name|mp
operator|->
name|am_parent
operator|->
name|am_attr
operator|.
name|ns_u
operator|.
name|ns_attr_u
operator|.
name|na_mtime
operator|.
name|nt_seconds
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not MNT2_NFS_OPT_SYMTTL */
if|if
condition|(
name|mf
operator|->
name|mf_refc
operator|==
literal|1
operator|&&
operator|!
name|FSRV_ISUP
argument_list|(
name|mf
operator|->
name|mf_server
argument_list|)
condition|)
block|{
comment|/*      * Don't try to unmount from a server that is known to be down      */
if|if
condition|(
operator|!
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_LOGDOWN
operator|)
condition|)
block|{
comment|/* Only log this once, otherwise gets a bit boring */
name|plog
argument_list|(
name|XLOG_STATS
argument_list|,
literal|"file server %s is down - timeout of \"%s\" ignored"
argument_list|,
name|mf
operator|->
name|mf_server
operator|->
name|fs_host
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_LOGDOWN
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|dlog
argument_list|(
literal|"\"%s\" on %s timed out"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|mp
operator|->
name|am_mnt
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_UNMOUNTING
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FS_AUTOFS
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_IS_AUTOFS
condition|)
name|autofs_release_mp
argument_list|(
name|mp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_FS_AUTOFS */
if|if
condition|(
operator|(
name|mf
operator|->
name|mf_fsflags
operator|&
name|FS_UBACKGROUND
operator|)
operator|&&
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_MOUNTED
operator|)
condition|)
block|{
name|dlog
argument_list|(
literal|"Trying unmount in background"
argument_list|)
expr_stmt|;
name|run_task
argument_list|(
name|unmount_node
argument_list|,
operator|(
name|opaque_t
operator|)
name|mp
argument_list|,
name|free_map_if_success
argument_list|,
operator|(
name|opaque_t
operator|)
name|mp
argument_list|)
expr_stmt|;
name|was_backgrounded
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dlog
argument_list|(
literal|"Trying unmount in foreground"
argument_list|)
expr_stmt|;
name|free_map_if_success
argument_list|(
name|unmount_node
argument_list|(
operator|(
name|opaque_t
operator|)
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|opaque_t
operator|)
name|mp
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
literal|"unmount attempt done"
argument_list|)
expr_stmt|;
block|}
return|return
name|was_backgrounded
return|;
block|}
end_function

begin_function
name|void
name|timeout_mp
parameter_list|(
name|opaque_t
name|v
parameter_list|)
comment|/* argument not used?! */
block|{
name|int
name|i
decl_stmt|;
name|time_t
name|t
init|=
name|NEVER
decl_stmt|;
name|time_t
name|now
init|=
name|clocktime
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|int
name|backoff
init|=
name|NumChildren
operator|/
literal|4
decl_stmt|;
name|dlog
argument_list|(
literal|"Timing out automount points..."
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|last_used_map
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|am_node
modifier|*
name|mp
init|=
name|exported_ap
index|[
name|i
index|]
decl_stmt|;
name|mntfs
modifier|*
name|mf
decl_stmt|;
comment|/*      * Just continue if nothing mounted      */
if|if
condition|(
operator|!
name|mp
condition|)
continue|continue;
comment|/*      * Pick up mounted filesystem      */
name|mf
operator|=
name|mp
operator|->
name|am_mnt
expr_stmt|;
if|if
condition|(
operator|!
name|mf
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|HAVE_FS_AUTOFS
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_IS_AUTOFS
operator|&&
name|mp
operator|->
name|am_autofs_ttl
operator|!=
name|NEVER
condition|)
block|{
if|if
condition|(
name|now
operator|>=
name|mp
operator|->
name|am_autofs_ttl
condition|)
name|autofs_timeout_mp
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|t
operator|=
name|smallest_t
argument_list|(
name|t
argument_list|,
name|mp
operator|->
name|am_autofs_ttl
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_FS_AUTOFS */
if|if
condition|(
name|mp
operator|->
name|am_flags
operator|&
name|AMF_NOTIMEOUT
condition|)
continue|continue;
comment|/*      * Don't delete last reference to a restarted filesystem.      */
if|if
condition|(
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_RSTKEEP
operator|)
operator|&&
name|mf
operator|->
name|mf_refc
operator|==
literal|1
condition|)
continue|continue;
comment|/*      * If there is action on this filesystem then ignore it      */
if|if
condition|(
operator|!
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|IGNORE_FLAGS
operator|)
condition|)
block|{
name|int
name|expired
init|=
literal|0
decl_stmt|;
name|mf
operator|->
name|mf_flags
operator|&=
operator|~
name|MFF_WANTTIMO
expr_stmt|;
if|if
condition|(
name|now
operator|>=
name|mp
operator|->
name|am_ttl
condition|)
block|{
if|if
condition|(
operator|!
name|backoff
condition|)
block|{
name|expired
operator|=
literal|1
expr_stmt|;
comment|/* 	   * Move the ttl forward to avoid thrashing effects 	   * on the next call to timeout! 	   */
comment|/* sun's -tw option */
if|if
condition|(
name|mp
operator|->
name|am_timeo_w
operator|<
literal|4
operator|*
name|gopt
operator|.
name|am_timeo_w
condition|)
name|mp
operator|->
name|am_timeo_w
operator|+=
name|gopt
operator|.
name|am_timeo_w
expr_stmt|;
name|mp
operator|->
name|am_ttl
operator|=
name|now
operator|+
name|mp
operator|->
name|am_timeo_w
expr_stmt|;
block|}
else|else
block|{
comment|/* 	   * Just backoff this unmount for 	   * a couple of seconds to avoid 	   * many multiple unmounts being 	   * started in parallel. 	   */
name|mp
operator|->
name|am_ttl
operator|=
name|now
operator|+
name|backoff
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/*        * If the next ttl is smallest, use that        */
name|t
operator|=
name|smallest_t
argument_list|(
name|t
argument_list|,
name|mp
operator|->
name|am_ttl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mp
operator|->
name|am_child
operator|&&
name|mf
operator|->
name|mf_error
operator|>=
literal|0
operator|&&
name|expired
condition|)
block|{
comment|/* 	 * If the unmount was backgrounded then 	 * bump the backoff counter. 	 */
if|if
condition|(
name|unmount_mp
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|backoff
operator|=
literal|2
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_UNMOUNTING
condition|)
block|{
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_WANTTIMO
expr_stmt|;
block|}
block|}
if|if
condition|(
name|t
operator|==
name|NEVER
condition|)
block|{
name|dlog
argument_list|(
literal|"No further timeouts"
argument_list|)
expr_stmt|;
name|t
operator|=
name|now
operator|+
name|ONE_HOUR
expr_stmt|;
block|}
comment|/*    * Sanity check to avoid runaways.    * Absolutely should never get this but    * if you do without this trap amd will thrash.    */
if|if
condition|(
name|t
operator|<=
name|now
condition|)
block|{
name|t
operator|=
name|now
operator|+
literal|6
expr_stmt|;
comment|/* XXX */
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"Got a zero interval in timeout_mp()!"
argument_list|)
expr_stmt|;
block|}
comment|/*    * XXX - when shutting down, make things happen faster    */
if|if
condition|(
operator|(
name|int
operator|)
name|amd_state
operator|>=
operator|(
name|int
operator|)
name|Finishing
condition|)
name|t
operator|=
name|now
operator|+
literal|1
expr_stmt|;
name|dlog
argument_list|(
literal|"Next mount timeout in %lds"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|t
operator|-
name|now
argument_list|)
argument_list|)
expr_stmt|;
name|timeout_mp_id
operator|=
name|timeout
argument_list|(
name|t
operator|-
name|now
argument_list|,
name|timeout_mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Cause timeout_mp to be called soonest  */
end_comment

begin_function
name|void
name|reschedule_timeout_mp
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|timeout_mp_id
condition|)
name|untimeout
argument_list|(
name|timeout_mp_id
argument_list|)
expr_stmt|;
name|timeout_mp_id
operator|=
name|timeout
argument_list|(
literal|0
argument_list|,
name|timeout_mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

