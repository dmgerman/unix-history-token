begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997-2006 Erez Zadok  * Copyright (c) 1990 Jan-Simon Pendry  * Copyright (c) 1990 Imperial College of Science, Technology& Medicine  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry at Imperial College, London.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgment:  *      This product includes software developed by the University of  *      California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *  * File: am-utils/amd/srvr_nfs.c  *  */
end_comment

begin_comment
comment|/*  * NFS server modeling  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<am_defs.h>
end_include

begin_include
include|#
directive|include
file|<amd.h>
end_include

begin_comment
comment|/*  * Number of pings allowed to fail before host is declared down  * - three-fifths of the allowed mount time...  */
end_comment

begin_define
define|#
directive|define
name|MAX_ALLOWED_PINGS
value|(3 +
comment|/* for luck ... */
value|1)
end_define

begin_comment
comment|/*  * How often to ping when starting a new server  */
end_comment

begin_define
define|#
directive|define
name|FAST_NFS_PING
value|3
end_define

begin_if
if|#
directive|if
operator|(
name|FAST_NFS_PING
operator|*
name|MAX_ALLOWED_PINGS
operator|)
operator|>=
name|ALLOWED_MOUNT_TIME
end_if

begin_error
error|#
directive|error
error|: sanity check failed in srvr_nfs.c
end_error

begin_comment
comment|/*  * you cannot do things this way...  * sufficient fast pings must be given the chance to fail  * within the allowed mount time  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (FAST_NFS_PING * MAX_ALLOWED_PINGS)>= ALLOWED_MOUNT_TIME */
end_comment

begin_comment
comment|/* structures and typedefs */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|nfs_private
block|{
name|u_short
name|np_mountd
decl_stmt|;
comment|/* Mount daemon port number */
name|char
name|np_mountd_inval
decl_stmt|;
comment|/* Port *may* be invalid */
name|int
name|np_ping
decl_stmt|;
comment|/* Number of failed ping attempts */
name|time_t
name|np_ttl
decl_stmt|;
comment|/* Time when server is thought dead */
name|int
name|np_xid
decl_stmt|;
comment|/* RPC transaction id for pings */
name|int
name|np_error
decl_stmt|;
comment|/* Error during portmap request */
block|}
name|nfs_private
typedef|;
end_typedef

begin_comment
comment|/* globals */
end_comment

begin_decl_stmt
name|qelem
name|nfs_srvr_list
init|=
block|{
operator|&
name|nfs_srvr_list
block|,
operator|&
name|nfs_srvr_list
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* statics */
end_comment

begin_decl_stmt
specifier|static
name|int
name|global_xid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For NFS pings */
end_comment

begin_define
define|#
directive|define
name|XID_ALLOC
parameter_list|()
value|(++global_xid)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FS_NFS3
end_ifdef

begin_define
define|#
directive|define
name|NUM_NFS_VERS
value|2
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not HAVE_FS_NFS3 */
end_comment

begin_define
define|#
directive|define
name|NUM_NFS_VERS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_FS_NFS3 */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ping_len
index|[
name|NUM_NFS_VERS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ping_buf
index|[
name|NUM_NFS_VERS
index|]
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|rpc_msg
argument_list|)
operator|+
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MNTTAB_OPT_PROTO
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_FS_NFS3
argument_list|)
end_if

begin_comment
comment|/*  * Protocols we know about, in order of preference.  *  * Note that Solaris 8 and newer NetBSD systems are switching to UDP first,  * so this order may have to be adjusted for Amd in the future once more  * vendors make that change. -Erez 11/24/2000  *  * Or we might simply make this is a platform-specific order. -Ion 09/13/2003  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|protocols
index|[]
init|=
block|{
literal|"tcp"
block|,
literal|"udp"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(MNTTAB_OPT_PROTO) || defined(HAVE_FS_NFS3) */
end_comment

begin_comment
comment|/* forward definitions */
end_comment

begin_function_decl
specifier|static
name|void
name|nfs_keepalive
parameter_list|(
name|voidp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Flush cached data for an fserver (or for all, if fs==NULL)  */
end_comment

begin_function
name|void
name|flush_srvr_nfs_cache
parameter_list|(
name|fserver
modifier|*
name|fs
parameter_list|)
block|{
name|fserver
modifier|*
name|fs2
init|=
name|NULL
decl_stmt|;
name|ITER
argument_list|(
argument|fs2
argument_list|,
argument|fserver
argument_list|,
argument|&nfs_srvr_list
argument_list|)
block|{
if|if
condition|(
name|fs
operator|==
name|NULL
operator|||
name|fs
operator|==
name|fs2
condition|)
block|{
name|nfs_private
modifier|*
name|np
init|=
operator|(
name|nfs_private
operator|*
operator|)
name|fs2
operator|->
name|fs_private
decl_stmt|;
if|if
condition|(
name|np
condition|)
block|{
name|np
operator|->
name|np_mountd_inval
operator|=
name|TRUE
expr_stmt|;
name|np
operator|->
name|np_error
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Startup the NFS ping for a particular version.  */
end_comment

begin_function
specifier|static
name|void
name|create_ping_payload
parameter_list|(
name|u_long
name|nfs_version
parameter_list|)
block|{
name|XDR
name|ping_xdr
decl_stmt|;
name|struct
name|rpc_msg
name|ping_msg
decl_stmt|;
comment|/*    * Non nfs mounts like /afs/glue.umd.edu have ended up here.    */
if|if
condition|(
name|nfs_version
operator|==
literal|0
condition|)
block|{
name|nfs_version
operator|=
name|NFS_VERSION
expr_stmt|;
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"create_ping_payload: nfs_version = 0, changed to 2"
argument_list|)
expr_stmt|;
block|}
else|else
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"create_ping_payload: nfs_version: %d"
argument_list|,
operator|(
name|int
operator|)
name|nfs_version
argument_list|)
expr_stmt|;
name|rpc_msg_init
argument_list|(
operator|&
name|ping_msg
argument_list|,
name|NFS_PROGRAM
argument_list|,
name|nfs_version
argument_list|,
name|NFSPROC_NULL
argument_list|)
expr_stmt|;
comment|/*    * Create an XDR endpoint    */
name|xdrmem_create
argument_list|(
operator|&
name|ping_xdr
argument_list|,
name|ping_buf
index|[
name|nfs_version
operator|-
name|NFS_VERSION
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|ping_buf
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|XDR_ENCODE
argument_list|)
expr_stmt|;
comment|/*    * Create the NFS ping message    */
if|if
condition|(
operator|!
name|xdr_callmsg
argument_list|(
operator|&
name|ping_xdr
argument_list|,
operator|&
name|ping_msg
argument_list|)
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"Couldn't create ping RPC message"
argument_list|)
expr_stmt|;
name|going_down
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/*    * Find out how long it is    */
name|ping_len
index|[
name|nfs_version
operator|-
name|NFS_VERSION
index|]
operator|=
name|xdr_getpos
argument_list|(
operator|&
name|ping_xdr
argument_list|)
expr_stmt|;
comment|/*    * Destroy the XDR endpoint - we don't need it anymore    */
name|xdr_destroy
argument_list|(
operator|&
name|ping_xdr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called when a portmap reply arrives  */
end_comment

begin_function
specifier|static
name|void
name|got_portmap
parameter_list|(
name|voidp
name|pkt
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|sa
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|ia
parameter_list|,
name|voidp
name|idv
parameter_list|,
name|int
name|done
parameter_list|)
block|{
name|fserver
modifier|*
name|fs2
init|=
operator|(
name|fserver
operator|*
operator|)
name|idv
decl_stmt|;
name|fserver
modifier|*
name|fs
init|=
literal|0
decl_stmt|;
comment|/*    * Find which fileserver we are talking about    */
name|ITER
argument_list|(
argument|fs
argument_list|,
argument|fserver
argument_list|,
argument|&nfs_srvr_list
argument_list|)
if|if
condition|(
name|fs
operator|==
name|fs2
condition|)
break|break;
if|if
condition|(
name|fs
operator|==
name|fs2
condition|)
block|{
name|u_long
name|port
init|=
literal|0
decl_stmt|;
comment|/* XXX - should be short but protocol is naff */
name|int
name|error
init|=
name|done
condition|?
name|pickup_rpc_reply
argument_list|(
name|pkt
argument_list|,
name|len
argument_list|,
operator|(
name|voidp
operator|)
operator|&
name|port
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_u_long
argument_list|)
else|:
operator|-
literal|1
decl_stmt|;
name|nfs_private
modifier|*
name|np
init|=
operator|(
name|nfs_private
operator|*
operator|)
name|fs
operator|->
name|fs_private
decl_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|port
condition|)
block|{
name|dlog
argument_list|(
literal|"got port (%d) for mountd on %s"
argument_list|,
operator|(
name|int
operator|)
name|port
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|)
expr_stmt|;
comment|/*        * Grab the port number.  Portmap sends back        * an u_long in native ordering, so it        * needs converting to a u_short in        * network ordering.        */
name|np
operator|->
name|np_mountd
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|port
argument_list|)
expr_stmt|;
name|np
operator|->
name|np_mountd_inval
operator|=
name|FALSE
expr_stmt|;
name|np
operator|->
name|np_error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|dlog
argument_list|(
literal|"Error fetching port for mountd on %s"
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
literal|"\t error=%d, port=%d"
argument_list|,
name|error
argument_list|,
operator|(
name|int
operator|)
name|port
argument_list|)
expr_stmt|;
comment|/*        * Almost certainly no mountd running on remote host        */
name|np
operator|->
name|np_error
operator|=
name|error
condition|?
name|error
else|:
name|ETIMEDOUT
expr_stmt|;
block|}
if|if
condition|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_WANT
condition|)
name|wakeup_srvr
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|done
condition|)
block|{
name|dlog
argument_list|(
literal|"Got portmap for old port request"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dlog
argument_list|(
literal|"portmap request timed out"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Obtain portmap information  */
end_comment

begin_function
specifier|static
name|int
name|call_portmap
parameter_list|(
name|fserver
modifier|*
name|fs
parameter_list|,
name|AUTH
modifier|*
name|auth
parameter_list|,
name|u_long
name|prog
parameter_list|,
name|u_long
name|vers
parameter_list|,
name|u_long
name|prot
parameter_list|)
block|{
name|struct
name|rpc_msg
name|pmap_msg
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
name|iobuf
index|[
name|UDPMSGSIZE
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|pmap
name|pmap
decl_stmt|;
name|rpc_msg_init
argument_list|(
operator|&
name|pmap_msg
argument_list|,
name|PMAPPROG
argument_list|,
name|PMAPVERS
argument_list|,
name|PMAPPROC_NULL
argument_list|)
expr_stmt|;
name|pmap
operator|.
name|pm_prog
operator|=
name|prog
expr_stmt|;
name|pmap
operator|.
name|pm_vers
operator|=
name|vers
expr_stmt|;
name|pmap
operator|.
name|pm_prot
operator|=
name|prot
expr_stmt|;
name|pmap
operator|.
name|pm_port
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|make_rpc_packet
argument_list|(
name|iobuf
argument_list|,
sizeof|sizeof
argument_list|(
name|iobuf
argument_list|)
argument_list|,
name|PMAPPROC_GETPORT
argument_list|,
operator|&
name|pmap_msg
argument_list|,
operator|(
name|voidp
operator|)
operator|&
name|pmap
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_pmap
argument_list|,
name|auth
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|memset
argument_list|(
operator|(
name|voidp
operator|)
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|=
operator|*
name|fs
operator|->
name|fs_ip
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|PMAPPORT
argument_list|)
expr_stmt|;
name|error
operator|=
name|fwd_packet
argument_list|(
name|RPC_XID_PORTMAP
argument_list|,
name|iobuf
argument_list|,
name|len
argument_list|,
operator|&
name|sin
argument_list|,
operator|&
name|sin
argument_list|,
operator|(
name|voidp
operator|)
name|fs
argument_list|,
name|got_portmap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
operator|-
name|len
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|recompute_portmap
parameter_list|(
name|fserver
modifier|*
name|fs
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|u_long
name|mnt_version
decl_stmt|;
comment|/*    * No portmap calls for pure WebNFS servers.    */
if|if
condition|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_WEBNFS
condition|)
return|return;
if|if
condition|(
name|nfs_auth
condition|)
name|error
operator|=
literal|0
expr_stmt|;
else|else
name|error
operator|=
name|make_nfs_auth
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nfs_private
modifier|*
name|np
init|=
operator|(
name|nfs_private
operator|*
operator|)
name|fs
operator|->
name|fs_private
decl_stmt|;
name|np
operator|->
name|np_error
operator|=
name|error
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fs
operator|->
name|fs_version
operator|==
literal|0
condition|)
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"recompute_portmap: nfs_version = 0 fixed"
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"recompute_portmap: NFS version %d on %s"
argument_list|,
operator|(
name|int
operator|)
name|fs
operator|->
name|fs_version
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FS_NFS3
if|if
condition|(
name|fs
operator|->
name|fs_version
operator|==
name|NFS_VERSION3
condition|)
name|mnt_version
operator|=
name|AM_MOUNTVERS3
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* HAVE_FS_NFS3 */
name|mnt_version
operator|=
name|MOUNTVERS
expr_stmt|;
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"Using MOUNT version: %d"
argument_list|,
operator|(
name|int
operator|)
name|mnt_version
argument_list|)
expr_stmt|;
name|call_portmap
argument_list|(
name|fs
argument_list|,
name|nfs_auth
argument_list|,
name|MOUNTPROG
argument_list|,
name|mnt_version
argument_list|,
operator|(
name|u_long
operator|)
name|IPPROTO_UDP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|get_mountd_port
parameter_list|(
name|fserver
modifier|*
name|fs
parameter_list|,
name|u_short
modifier|*
name|port
parameter_list|,
name|wchan_t
name|wchan
parameter_list|)
block|{
name|int
name|error
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|FSRV_ISDOWN
argument_list|(
name|fs
argument_list|)
condition|)
return|return
name|EWOULDBLOCK
return|;
if|if
condition|(
name|FSRV_ISUP
argument_list|(
name|fs
argument_list|)
condition|)
block|{
name|nfs_private
modifier|*
name|np
init|=
operator|(
name|nfs_private
operator|*
operator|)
name|fs
operator|->
name|fs_private
decl_stmt|;
if|if
condition|(
name|np
operator|->
name|np_error
operator|==
literal|0
condition|)
block|{
operator|*
name|port
operator|=
name|np
operator|->
name|np_mountd
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|np
operator|->
name|np_error
expr_stmt|;
block|}
comment|/*      * Now go get the port mapping again in case it changed.      * Note that it is used even if (np_mountd_inval)      * is True.  The flag is used simply as an      * indication that the mountd may be invalid, not      * that it is known to be invalid.      */
if|if
condition|(
name|np
operator|->
name|np_mountd_inval
condition|)
name|recompute_portmap
argument_list|(
name|fs
argument_list|)
expr_stmt|;
else|else
name|np
operator|->
name|np_mountd_inval
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|<
literal|0
operator|&&
name|wchan
operator|&&
operator|!
operator|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_WANT
operator|)
condition|)
block|{
comment|/*      * If a wait channel is supplied, and no      * error has yet occurred, then arrange      * that a wakeup is done on the wait channel,      * whenever a wakeup is done on this fs node.      * Wakeup's are done on the fs node whenever      * it changes state - thus causing control to      * come back here and new, better things to happen.      */
name|fs
operator|->
name|fs_flags
operator||=
name|FSF_WANT
expr_stmt|;
name|sched_task
argument_list|(
name|wakeup_task
argument_list|,
name|wchan
argument_list|,
operator|(
name|wchan_t
operator|)
name|fs
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * This is called when we get a reply to an RPC ping.  * The value of id was taken from the nfs_private  * structure when the ping was transmitted.  */
end_comment

begin_function
specifier|static
name|void
name|nfs_keepalive_callback
parameter_list|(
name|voidp
name|pkt
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|sp
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|tsp
parameter_list|,
name|voidp
name|idv
parameter_list|,
name|int
name|done
parameter_list|)
block|{
name|int
name|xid
init|=
operator|(
name|long
operator|)
name|idv
decl_stmt|;
comment|/* cast needed for 64-bit archs */
name|fserver
modifier|*
name|fs
decl_stmt|;
name|int
name|found_map
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|done
condition|)
return|return;
comment|/*    * For each node...    */
name|ITER
argument_list|(
argument|fs
argument_list|,
argument|fserver
argument_list|,
argument|&nfs_srvr_list
argument_list|)
block|{
name|nfs_private
modifier|*
name|np
init|=
operator|(
name|nfs_private
operator|*
operator|)
name|fs
operator|->
name|fs_private
decl_stmt|;
if|if
condition|(
name|np
operator|->
name|np_xid
operator|==
name|xid
operator|&&
operator|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_PINGING
operator|)
condition|)
block|{
comment|/*        * Reset the ping counter.        * Update the keepalive timer.        * Log what happened.        */
if|if
condition|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_DOWN
condition|)
block|{
name|fs
operator|->
name|fs_flags
operator|&=
operator|~
name|FSF_DOWN
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_VALID
condition|)
block|{
name|srvrlog
argument_list|(
name|fs
argument_list|,
literal|"is up"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|np
operator|->
name|np_ping
operator|>
literal|1
condition|)
name|srvrlog
argument_list|(
name|fs
argument_list|,
literal|"ok"
argument_list|)
expr_stmt|;
else|else
name|srvrlog
argument_list|(
name|fs
argument_list|,
literal|"starts up"
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_flags
operator||=
name|FSF_VALID
expr_stmt|;
block|}
name|map_flush_srvr
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_VALID
condition|)
block|{
name|dlog
argument_list|(
literal|"file server %s type nfs is still up"
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|np
operator|->
name|np_ping
operator|>
literal|1
condition|)
name|srvrlog
argument_list|(
name|fs
argument_list|,
literal|"ok"
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_flags
operator||=
name|FSF_VALID
expr_stmt|;
block|}
block|}
comment|/*        * Adjust ping interval        */
name|untimeout
argument_list|(
name|fs
operator|->
name|fs_cid
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_cid
operator|=
name|timeout
argument_list|(
name|fs
operator|->
name|fs_pinger
argument_list|,
name|nfs_keepalive
argument_list|,
operator|(
name|voidp
operator|)
name|fs
argument_list|)
expr_stmt|;
comment|/*        * Update ttl for this server        */
name|np
operator|->
name|np_ttl
operator|=
name|clocktime
argument_list|(
name|NULL
argument_list|)
operator|+
operator|(
name|MAX_ALLOWED_PINGS
operator|-
literal|1
operator|)
operator|*
name|FAST_NFS_PING
operator|+
name|fs
operator|->
name|fs_pinger
operator|-
literal|1
expr_stmt|;
comment|/*        * New RPC xid...        */
name|np
operator|->
name|np_xid
operator|=
name|XID_ALLOC
argument_list|()
expr_stmt|;
comment|/*        * Failed pings is zero...        */
name|np
operator|->
name|np_ping
operator|=
literal|0
expr_stmt|;
comment|/*        * Recompute portmap information if not known        */
if|if
condition|(
name|np
operator|->
name|np_mountd_inval
condition|)
name|recompute_portmap
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|found_map
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found_map
operator|==
literal|0
condition|)
name|dlog
argument_list|(
literal|"Spurious ping packet"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_fs_addr_change
parameter_list|(
name|fserver
modifier|*
name|fs
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|hp
init|=
name|NULL
decl_stmt|;
name|struct
name|in_addr
name|ia
decl_stmt|;
name|char
modifier|*
name|old_ipaddr
decl_stmt|,
modifier|*
name|new_ipaddr
decl_stmt|;
name|hp
operator|=
name|gethostbyname
argument_list|(
name|fs
operator|->
name|fs_host
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hp
operator|||
name|hp
operator|->
name|h_addrtype
operator|!=
name|AF_INET
operator|||
operator|!
name|STREQ
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hp
operator|->
name|h_name
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|)
operator|||
name|memcmp
argument_list|(
operator|(
name|voidp
operator|)
operator|&
name|fs
operator|->
name|fs_ip
operator|->
name|sin_addr
argument_list|,
operator|(
name|voidp
operator|)
name|hp
operator|->
name|h_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|fs
operator|->
name|fs_ip
operator|->
name|sin_addr
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* if got here: downed server changed IP address */
name|old_ipaddr
operator|=
name|strdup
argument_list|(
name|inet_ntoa
argument_list|(
name|fs
operator|->
name|fs_ip
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|(
name|voidp
operator|)
operator|&
name|ia
argument_list|,
operator|(
name|voidp
operator|)
name|hp
operator|->
name|h_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|new_ipaddr
operator|=
name|inet_ntoa
argument_list|(
name|ia
argument_list|)
expr_stmt|;
comment|/* ntoa uses static buf */
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"EZK: down fileserver %s changed ip: %s -> %s"
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|,
name|old_ipaddr
argument_list|,
name|new_ipaddr
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|old_ipaddr
argument_list|)
expr_stmt|;
comment|/* copy new IP addr */
name|memmove
argument_list|(
operator|(
name|voidp
operator|)
operator|&
name|fs
operator|->
name|fs_ip
operator|->
name|sin_addr
argument_list|,
operator|(
name|voidp
operator|)
name|hp
operator|->
name|h_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|fs
operator|->
name|fs_ip
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX: do we need to un/set these flags? */
name|fs
operator|->
name|fs_flags
operator|&=
operator|~
name|FSF_DOWN
expr_stmt|;
name|fs
operator|->
name|fs_flags
operator||=
name|FSF_VALID
operator||
name|FSF_WANT
expr_stmt|;
name|map_flush_srvr
argument_list|(
name|fs
argument_list|)
expr_stmt|;
comment|/* XXX: a race with flush_srvr_nfs_cache? */
name|flush_srvr_nfs_cache
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_flags
operator||=
name|FSF_FORCE_UNMOUNT
expr_stmt|;
if|#
directive|if
literal|0
block|flush_nfs_fhandle_cache(fs);
comment|/* done in caller: nfs_keepalive_timeout */
comment|/* XXX: need to purge nfs_private so that somehow it will get re-initialized? */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Called when no ping-reply received  */
end_comment

begin_function
specifier|static
name|void
name|nfs_keepalive_timeout
parameter_list|(
name|voidp
name|v
parameter_list|)
block|{
name|fserver
modifier|*
name|fs
init|=
name|v
decl_stmt|;
name|nfs_private
modifier|*
name|np
init|=
operator|(
name|nfs_private
operator|*
operator|)
name|fs
operator|->
name|fs_private
decl_stmt|;
comment|/*    * Another ping has failed    */
name|np
operator|->
name|np_ping
operator|++
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|np_ping
operator|>
literal|1
condition|)
name|srvrlog
argument_list|(
name|fs
argument_list|,
literal|"not responding"
argument_list|)
expr_stmt|;
comment|/*    * Not known to be up any longer    */
if|if
condition|(
name|FSRV_ISUP
argument_list|(
name|fs
argument_list|)
condition|)
name|fs
operator|->
name|fs_flags
operator|&=
operator|~
name|FSF_VALID
expr_stmt|;
comment|/*    * If ttl has expired then guess that it is dead    */
if|if
condition|(
name|np
operator|->
name|np_ttl
operator|<
name|clocktime
argument_list|(
name|NULL
argument_list|)
condition|)
block|{
name|int
name|oflags
init|=
name|fs
operator|->
name|fs_flags
decl_stmt|;
name|dlog
argument_list|(
literal|"ttl has expired"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_DOWN
operator|)
operator|==
literal|0
condition|)
block|{
comment|/*        * Server was up, but is now down.        */
name|srvrlog
argument_list|(
name|fs
argument_list|,
literal|"is down"
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_flags
operator||=
name|FSF_DOWN
operator||
name|FSF_VALID
expr_stmt|;
comment|/*        * Since the server is down, the portmap        * information may now be wrong, so it        * must be flushed from the local cache        */
name|flush_nfs_fhandle_cache
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|np
operator|->
name|np_error
operator|=
operator|-
literal|1
expr_stmt|;
name|check_fs_addr_change
argument_list|(
name|fs
argument_list|)
expr_stmt|;
comment|/* check if IP addr of fserver changed */
block|}
else|else
block|{
comment|/*        * Known to be down        */
if|if
condition|(
operator|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_VALID
operator|)
operator|==
literal|0
condition|)
name|srvrlog
argument_list|(
name|fs
argument_list|,
literal|"starts down"
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_flags
operator||=
name|FSF_VALID
expr_stmt|;
block|}
if|if
condition|(
name|oflags
operator|!=
name|fs
operator|->
name|fs_flags
operator|&&
operator|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_WANT
operator|)
condition|)
name|wakeup_srvr
argument_list|(
name|fs
argument_list|)
expr_stmt|;
comment|/*      * Reset failed ping count      */
name|np
operator|->
name|np_ping
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|np
operator|->
name|np_ping
operator|>
literal|1
condition|)
name|dlog
argument_list|(
literal|"%d pings to %s failed - at most %d allowed"
argument_list|,
name|np
operator|->
name|np_ping
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|,
name|MAX_ALLOWED_PINGS
argument_list|)
expr_stmt|;
block|}
comment|/*    * New RPC xid, so any late responses to the previous ping    * get ignored...    */
name|np
operator|->
name|np_xid
operator|=
name|XID_ALLOC
argument_list|()
expr_stmt|;
comment|/*    * Run keepalive again    */
name|nfs_keepalive
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Keep track of whether a server is alive  */
end_comment

begin_function
specifier|static
name|void
name|nfs_keepalive
parameter_list|(
name|voidp
name|v
parameter_list|)
block|{
name|fserver
modifier|*
name|fs
init|=
name|v
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nfs_private
modifier|*
name|np
init|=
operator|(
name|nfs_private
operator|*
operator|)
name|fs
operator|->
name|fs_private
decl_stmt|;
name|int
name|fstimeo
init|=
operator|-
literal|1
decl_stmt|;
comment|/*    * Send an NFS ping to this node    */
if|if
condition|(
name|ping_len
index|[
name|fs
operator|->
name|fs_version
operator|-
name|NFS_VERSION
index|]
operator|==
literal|0
condition|)
name|create_ping_payload
argument_list|(
name|fs
operator|->
name|fs_version
argument_list|)
expr_stmt|;
comment|/*    * Queue the packet...    */
name|error
operator|=
name|fwd_packet
argument_list|(
name|MK_RPC_XID
argument_list|(
name|RPC_XID_NFSPING
argument_list|,
name|np
operator|->
name|np_xid
argument_list|)
argument_list|,
name|ping_buf
index|[
name|fs
operator|->
name|fs_version
operator|-
name|NFS_VERSION
index|]
argument_list|,
name|ping_len
index|[
name|fs
operator|->
name|fs_version
operator|-
name|NFS_VERSION
index|]
argument_list|,
name|fs
operator|->
name|fs_ip
argument_list|,
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
literal|0
argument_list|,
call|(
name|voidp
call|)
argument_list|(
operator|(
name|long
operator|)
name|np
operator|->
name|np_xid
argument_list|)
argument_list|,
comment|/* cast needed for 64-bit archs */
name|nfs_keepalive_callback
argument_list|)
expr_stmt|;
comment|/*    * See if a hard error occurred    */
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|ENETDOWN
case|:
case|case
name|ENETUNREACH
case|:
case|case
name|EHOSTDOWN
case|:
case|case
name|EHOSTUNREACH
case|:
name|np
operator|->
name|np_ping
operator|=
name|MAX_ALLOWED_PINGS
expr_stmt|;
comment|/* immediately down */
name|np
operator|->
name|np_ttl
operator|=
operator|(
name|time_t
operator|)
literal|0
expr_stmt|;
comment|/*      * This causes an immediate call to nfs_keepalive_timeout      * whenever the server was thought to be up.      * See +++ below.      */
name|fstimeo
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|dlog
argument_list|(
literal|"Sent NFS ping to %s"
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*    * Back off the ping interval if we are not getting replies and    * the remote system is known to be down.    */
switch|switch
condition|(
name|fs
operator|->
name|fs_flags
operator|&
operator|(
name|FSF_DOWN
operator||
name|FSF_VALID
operator|)
condition|)
block|{
case|case
name|FSF_VALID
case|:
comment|/* Up */
if|if
condition|(
name|fstimeo
operator|<
literal|0
condition|)
comment|/* +++ see above */
name|fstimeo
operator|=
name|FAST_NFS_PING
expr_stmt|;
break|break;
case|case
name|FSF_VALID
operator||
name|FSF_DOWN
case|:
comment|/* Down */
name|fstimeo
operator|=
name|fs
operator|->
name|fs_pinger
expr_stmt|;
break|break;
default|default:
comment|/* Unknown */
name|fstimeo
operator|=
name|FAST_NFS_PING
expr_stmt|;
break|break;
block|}
name|dlog
argument_list|(
literal|"NFS timeout in %d seconds"
argument_list|,
name|fstimeo
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_cid
operator|=
name|timeout
argument_list|(
name|fstimeo
argument_list|,
name|nfs_keepalive_timeout
argument_list|,
operator|(
name|voidp
operator|)
name|fs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|start_nfs_pings
parameter_list|(
name|fserver
modifier|*
name|fs
parameter_list|,
name|int
name|pingval
parameter_list|)
block|{
if|if
condition|(
name|pingval
operator|==
literal|0
condition|)
comment|/* could be because ping mnt option not found */
name|pingval
operator|=
name|AM_PINGER
expr_stmt|;
comment|/* if pings haven't been initalized, then init them for first time */
if|if
condition|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_PING_UNINIT
condition|)
block|{
name|fs
operator|->
name|fs_flags
operator|&=
operator|~
name|FSF_PING_UNINIT
expr_stmt|;
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"initializing %s's pinger to %d sec"
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|,
name|pingval
argument_list|)
expr_stmt|;
goto|goto
name|do_pings
goto|;
block|}
if|if
condition|(
operator|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_PINGING
operator|)
operator|&&
name|fs
operator|->
name|fs_pinger
operator|==
name|pingval
condition|)
block|{
name|dlog
argument_list|(
literal|"already running pings to %s"
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* if got here, then we need to update the ping value */
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"changing %s's ping value from %d%s to %d%s"
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|,
name|fs
operator|->
name|fs_pinger
argument_list|,
operator|(
name|fs
operator|->
name|fs_pinger
operator|<
literal|0
condition|?
literal|" (off)"
else|:
literal|""
operator|)
argument_list|,
name|pingval
argument_list|,
operator|(
name|pingval
operator|<
literal|0
condition|?
literal|" (off)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|do_pings
label|:
name|fs
operator|->
name|fs_pinger
operator|=
name|pingval
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_cid
condition|)
name|untimeout
argument_list|(
name|fs
operator|->
name|fs_cid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pingval
operator|<
literal|0
condition|)
block|{
name|srvrlog
argument_list|(
name|fs
argument_list|,
literal|"wired up (pings disabled)"
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_flags
operator||=
name|FSF_VALID
expr_stmt|;
name|fs
operator|->
name|fs_flags
operator|&=
operator|~
name|FSF_DOWN
expr_stmt|;
block|}
else|else
block|{
name|fs
operator|->
name|fs_flags
operator||=
name|FSF_PINGING
expr_stmt|;
name|nfs_keepalive
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Find an nfs server for a host.  */
end_comment

begin_function
name|fserver
modifier|*
name|find_nfs_srvr
parameter_list|(
name|mntfs
modifier|*
name|mf
parameter_list|)
block|{
name|char
modifier|*
name|host
init|=
name|mf
operator|->
name|mf_fo
operator|->
name|opt_rhost
decl_stmt|;
name|fserver
modifier|*
name|fs
decl_stmt|;
name|int
name|pingval
decl_stmt|;
name|mntent_t
name|mnt
decl_stmt|;
name|nfs_private
modifier|*
name|np
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
init|=
name|NULL
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
name|u_long
name|nfs_version
init|=
literal|0
decl_stmt|;
comment|/* default is no version specified */
name|u_long
name|best_nfs_version
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|nfs_proto
init|=
name|NULL
decl_stmt|;
comment|/* no IP protocol either */
name|int
name|nfs_port
init|=
literal|0
decl_stmt|;
name|int
name|nfs_port_opt
init|=
literal|0
decl_stmt|;
name|int
name|fserver_is_down
init|=
literal|0
decl_stmt|;
comment|/*    * Get ping interval from mount options.    * Current only used to decide whether pings    * are required or not.< 0 = no pings.    */
name|mnt
operator|.
name|mnt_opts
operator|=
name|mf
operator|->
name|mf_mopts
expr_stmt|;
name|pingval
operator|=
name|hasmntval
argument_list|(
operator|&
name|mnt
argument_list|,
literal|"ping"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_NFS_SCALEDOWN
condition|)
block|{
comment|/*      * the server granted us a filehandle, but we were unable to mount it.      * therefore, scale down to NFSv2/UDP and try again.      */
name|nfs_version
operator|=
name|NFS_VERSION
expr_stmt|;
name|nfs_proto
operator|=
literal|"udp"
expr_stmt|;
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"find_nfs_srvr: NFS mount failed, trying again with NFSv2/UDP"
argument_list|)
expr_stmt|;
name|mf
operator|->
name|mf_flags
operator|&=
operator|~
name|MFF_NFS_SCALEDOWN
expr_stmt|;
block|}
else|else
block|{
comment|/*      * Get the NFS version from the mount options. This is used      * to decide the highest NFS version to try.      */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_VERS
name|nfs_version
operator|=
name|hasmntval
argument_list|(
operator|&
name|mnt
argument_list|,
name|MNTTAB_OPT_VERS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_OPT_VERS */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_PROTO
block|{
name|char
modifier|*
name|proto_opt
init|=
name|hasmnteq
argument_list|(
operator|&
name|mnt
argument_list|,
name|MNTTAB_OPT_PROTO
argument_list|)
decl_stmt|;
if|if
condition|(
name|proto_opt
condition|)
block|{
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|protocols
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|NSTREQ
argument_list|(
name|proto_opt
argument_list|,
operator|*
name|p
argument_list|,
name|strlen
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|nfs_proto
operator|=
operator|*
name|p
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|p
operator|==
name|NULL
condition|)
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"ignoring unknown protocol option for %s:%s"
argument_list|,
name|host
argument_list|,
name|mf
operator|->
name|mf_fo
operator|->
name|opt_rfs
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* MNTTAB_OPT_PROTO */
ifdef|#
directive|ifdef
name|HAVE_NFS_NFSV2_H
comment|/* allow overriding if nfsv2 option is specified in mount options */
if|if
condition|(
name|amu_hasmntopt
argument_list|(
operator|&
name|mnt
argument_list|,
literal|"nfsv2"
argument_list|)
condition|)
block|{
name|nfs_version
operator|=
name|NFS_VERSION
expr_stmt|;
comment|/* nullify any ``vers=X'' statements */
name|nfs_proto
operator|=
literal|"udp"
expr_stmt|;
comment|/* nullify any ``proto=tcp'' statements */
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"found compatibility option \"nfsv2\": set options vers=2,proto=udp for host %s"
argument_list|,
name|host
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_NFS_NFSV2_H */
comment|/* check if we've globally overridden the NFS version/protocol */
if|if
condition|(
name|gopt
operator|.
name|nfs_vers
condition|)
block|{
name|nfs_version
operator|=
name|gopt
operator|.
name|nfs_vers
expr_stmt|;
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"find_nfs_srvr: force NFS version to %d"
argument_list|,
operator|(
name|int
operator|)
name|nfs_version
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gopt
operator|.
name|nfs_proto
condition|)
block|{
name|nfs_proto
operator|=
name|gopt
operator|.
name|nfs_proto
expr_stmt|;
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"find_nfs_srvr: force NFS protocol transport to %s"
argument_list|,
name|nfs_proto
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * lookup host address and canonical name    */
name|hp
operator|=
name|gethostbyname
argument_list|(
name|host
argument_list|)
expr_stmt|;
comment|/*    * New code from Bob Harris<harris@basil-rathbone.mit.edu>    * Use canonical name to keep track of file server    * information.  This way aliases do not generate    * multiple NFS pingers.  (Except when we're normalizing    * hosts.)    */
if|if
condition|(
name|hp
operator|&&
operator|!
operator|(
name|gopt
operator|.
name|flags
operator|&
name|CFM_NORMALIZE_HOSTNAMES
operator|)
condition|)
name|host
operator|=
operator|(
name|char
operator|*
operator|)
name|hp
operator|->
name|h_name
expr_stmt|;
if|if
condition|(
name|hp
condition|)
block|{
switch|switch
condition|(
name|hp
operator|->
name|h_addrtype
condition|)
block|{
case|case
name|AF_INET
case|:
name|ip
operator|=
name|ALLOC
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|voidp
operator|)
name|ip
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|)
expr_stmt|;
comment|/* as per POSIX, sin_len need not be set (used internally by kernel) */
name|ip
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|memmove
argument_list|(
operator|(
name|voidp
operator|)
operator|&
name|ip
operator|->
name|sin_addr
argument_list|,
operator|(
name|voidp
operator|)
name|hp
operator|->
name|h_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|plog
argument_list|(
name|XLOG_USER
argument_list|,
literal|"No IP address for host %s"
argument_list|,
name|host
argument_list|)
expr_stmt|;
goto|goto
name|no_dns
goto|;
block|}
block|}
else|else
block|{
name|plog
argument_list|(
name|XLOG_USER
argument_list|,
literal|"Unknown host: %s"
argument_list|,
name|host
argument_list|)
expr_stmt|;
goto|goto
name|no_dns
goto|;
block|}
comment|/*    * This may not be the best way to do things, but it really doesn't make    * sense to query a file server which is marked as 'down' for any    * version/proto combination.    */
name|ITER
argument_list|(
argument|fs
argument_list|,
argument|fserver
argument_list|,
argument|&nfs_srvr_list
argument_list|)
block|{
if|if
condition|(
name|FSRV_ISDOWN
argument_list|(
name|fs
argument_list|)
operator|&&
name|STREQ
argument_list|(
name|host
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|)
condition|)
block|{
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"fileserver %s is already hung - not running NFS proto/version discovery"
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_refc
operator|++
expr_stmt|;
if|if
condition|(
name|ip
condition|)
name|XFREE
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
name|fs
return|;
block|}
block|}
comment|/*    * Get the NFS Version, and verify server is up.    * If the client only supports NFSv2, hardcode it but still try to    * contact the remote portmapper to see if the service is running.    */
ifndef|#
directive|ifndef
name|HAVE_FS_NFS3
name|nfs_version
operator|=
name|NFS_VERSION
expr_stmt|;
name|nfs_proto
operator|=
literal|"udp"
expr_stmt|;
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"The client supports only NFS(2,udp)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_FS_NFS3 */
if|if
condition|(
name|amu_hasmntopt
argument_list|(
operator|&
name|mnt
argument_list|,
name|MNTTAB_OPT_PUBLIC
argument_list|)
condition|)
block|{
comment|/*      * Use WebNFS to obtain file handles.      */
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_WEBNFS
expr_stmt|;
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"%s option used, NOT contacting the portmapper on %s"
argument_list|,
name|MNTTAB_OPT_PUBLIC
argument_list|,
name|host
argument_list|)
expr_stmt|;
comment|/*      * Prefer NFSv3/tcp if the client supports it (cf. RFC 2054, 7).      */
if|if
condition|(
operator|!
name|nfs_version
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_FS_NFS3
name|nfs_version
operator|=
name|NFS_VERSION3
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_FS_NFS3 */
name|nfs_version
operator|=
name|NFS_VERSION
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_FS_NFS3 */
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"No NFS version specified, will use NFSv%d"
argument_list|,
operator|(
name|int
operator|)
name|nfs_version
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nfs_proto
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|MNTTAB_OPT_PROTO
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_FS_NFS3
argument_list|)
name|nfs_proto
operator|=
literal|"tcp"
expr_stmt|;
else|#
directive|else
comment|/* not defined(MNTTAB_OPT_PROTO) || defined(HAVE_FS_NFS3) */
name|nfs_proto
operator|=
literal|"udp"
expr_stmt|;
endif|#
directive|endif
comment|/* not defined(MNTTAB_OPT_PROTO) || defined(HAVE_FS_NFS3) */
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"No NFS protocol transport specified, will use %s"
argument_list|,
name|nfs_proto
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*      * Find the best combination of NFS version and protocol.      * When given a choice, use the highest available version,      * and use TCP over UDP if available.      */
if|if
condition|(
name|check_pmap_up
argument_list|(
name|host
argument_list|,
name|ip
argument_list|)
condition|)
block|{
if|if
condition|(
name|nfs_proto
condition|)
block|{
name|best_nfs_version
operator|=
name|get_nfs_version
argument_list|(
name|host
argument_list|,
name|ip
argument_list|,
name|nfs_version
argument_list|,
name|nfs_proto
argument_list|)
expr_stmt|;
name|nfs_port
operator|=
name|ip
operator|->
name|sin_port
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MNTTAB_OPT_PROTO
else|else
block|{
name|u_int
name|proto_nfs_version
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|protocols
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|proto_nfs_version
operator|=
name|get_nfs_version
argument_list|(
name|host
argument_list|,
name|ip
argument_list|,
name|nfs_version
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto_nfs_version
operator|>
name|best_nfs_version
condition|)
block|{
name|best_nfs_version
operator|=
name|proto_nfs_version
expr_stmt|;
name|nfs_proto
operator|=
operator|*
name|p
expr_stmt|;
name|nfs_port
operator|=
name|ip
operator|->
name|sin_port
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* MNTTAB_OPT_PROTO */
block|}
else|else
block|{
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"portmapper service not running on %s"
argument_list|,
name|host
argument_list|)
expr_stmt|;
block|}
comment|/* use the portmapper results only nfs_version is not set yet */
if|if
condition|(
operator|!
name|best_nfs_version
condition|)
block|{
comment|/*        * If the NFS server is down or does not support the portmapper call        * (such as certain Novell NFS servers) we mark it as version 2 and we        * let the nfs code deal with the case when it is down.  If/when the        * server comes back up and it can support NFSv3 and/or TCP, it will        * use those.        */
if|if
condition|(
name|nfs_version
operator|==
literal|0
condition|)
block|{
name|nfs_version
operator|=
name|NFS_VERSION
expr_stmt|;
name|nfs_proto
operator|=
literal|"udp"
expr_stmt|;
block|}
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"NFS service not running on %s"
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|fserver_is_down
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nfs_version
operator|==
literal|0
condition|)
name|nfs_version
operator|=
name|best_nfs_version
expr_stmt|;
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"Using NFS version %d, protocol %s on host %s"
argument_list|,
operator|(
name|int
operator|)
name|nfs_version
argument_list|,
name|nfs_proto
argument_list|,
name|host
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Determine the NFS port.    *    * A valid "port" mount option overrides anything else.    * If the port has been determined from the portmapper, use that.    * Default to NFS_PORT otherwise (cf. RFC 2054, 3).    */
name|nfs_port_opt
operator|=
name|hasmntval
argument_list|(
operator|&
name|mnt
argument_list|,
name|MNTTAB_OPT_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfs_port_opt
operator|>
literal|0
condition|)
name|nfs_port
operator|=
name|htons
argument_list|(
name|nfs_port_opt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nfs_port
condition|)
name|nfs_port
operator|=
name|htons
argument_list|(
name|NFS_PORT
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
literal|"find_nfs_srvr: using port %d for nfs on %s"
argument_list|,
operator|(
name|int
operator|)
name|ntohs
argument_list|(
name|nfs_port
argument_list|)
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|ip
operator|->
name|sin_port
operator|=
name|nfs_port
expr_stmt|;
name|no_dns
label|:
comment|/*    * Try to find an existing fs server structure for this host.    * Note that differing versions or protocols have their own structures.    * XXX: Need to fix the ping mechanism to actually use the NFS protocol    * chosen here (right now it always uses datagram sockets).    */
name|ITER
argument_list|(
argument|fs
argument_list|,
argument|fserver
argument_list|,
argument|&nfs_srvr_list
argument_list|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|host
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|)
operator|&&
name|nfs_version
operator|==
name|fs
operator|->
name|fs_version
operator|&&
name|STREQ
argument_list|(
name|nfs_proto
argument_list|,
name|fs
operator|->
name|fs_proto
argument_list|)
condition|)
block|{
comment|/*        * fill in the IP address -- this is only needed        * if there is a chance an IP address will change        * between mounts.        * Mike Mitchell, mcm@unx.sas.com, 09/08/93        */
if|if
condition|(
name|hp
operator|&&
name|fs
operator|->
name|fs_ip
operator|&&
name|memcmp
argument_list|(
operator|(
name|voidp
operator|)
operator|&
name|fs
operator|->
name|fs_ip
operator|->
name|sin_addr
argument_list|,
operator|(
name|voidp
operator|)
name|hp
operator|->
name|h_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|fs
operator|->
name|fs_ip
operator|->
name|sin_addr
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|in_addr
name|ia
decl_stmt|;
name|char
modifier|*
name|old_ipaddr
decl_stmt|,
modifier|*
name|new_ipaddr
decl_stmt|;
name|old_ipaddr
operator|=
name|strdup
argument_list|(
name|inet_ntoa
argument_list|(
name|fs
operator|->
name|fs_ip
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|(
name|voidp
operator|)
operator|&
name|ia
argument_list|,
operator|(
name|voidp
operator|)
name|hp
operator|->
name|h_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|new_ipaddr
operator|=
name|inet_ntoa
argument_list|(
name|ia
argument_list|)
expr_stmt|;
comment|/* ntoa uses static buf */
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"fileserver %s changed ip: %s -> %s"
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|,
name|old_ipaddr
argument_list|,
name|new_ipaddr
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|old_ipaddr
argument_list|)
expr_stmt|;
name|flush_nfs_fhandle_cache
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|(
name|voidp
operator|)
operator|&
name|fs
operator|->
name|fs_ip
operator|->
name|sin_addr
argument_list|,
operator|(
name|voidp
operator|)
name|hp
operator|->
name|h_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|fs
operator|->
name|fs_ip
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*        * If the new file systems doesn't use WebNFS, the nfs pings may        * try to contact the portmapper.        */
if|if
condition|(
operator|!
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_WEBNFS
operator|)
condition|)
name|fs
operator|->
name|fs_flags
operator|&=
operator|~
name|FSF_WEBNFS
expr_stmt|;
comment|/* check if pingval needs to be updated/set/reset */
name|start_nfs_pings
argument_list|(
name|fs
argument_list|,
name|pingval
argument_list|)
expr_stmt|;
comment|/*        * Following if statement from Mike Mitchell<mcm@unx.sas.com>        * Initialize the ping data if we aren't pinging now.  The np_ttl and        * np_ping fields are especially important.        */
if|if
condition|(
operator|!
operator|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_PINGING
operator|)
condition|)
block|{
name|np
operator|=
operator|(
name|nfs_private
operator|*
operator|)
name|fs
operator|->
name|fs_private
expr_stmt|;
name|np
operator|->
name|np_mountd_inval
operator|=
name|TRUE
expr_stmt|;
name|np
operator|->
name|np_xid
operator|=
name|XID_ALLOC
argument_list|()
expr_stmt|;
name|np
operator|->
name|np_error
operator|=
operator|-
literal|1
expr_stmt|;
name|np
operator|->
name|np_ping
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Initially the server will be deemed dead 	 * after MAX_ALLOWED_PINGS of the fast variety 	 * have failed. 	 */
name|np
operator|->
name|np_ttl
operator|=
name|MAX_ALLOWED_PINGS
operator|*
name|FAST_NFS_PING
operator|+
name|clocktime
argument_list|(
name|NULL
argument_list|)
operator|-
literal|1
expr_stmt|;
name|start_nfs_pings
argument_list|(
name|fs
argument_list|,
name|pingval
argument_list|)
expr_stmt|;
if|if
condition|(
name|fserver_is_down
condition|)
name|fs
operator|->
name|fs_flags
operator||=
name|FSF_VALID
operator||
name|FSF_DOWN
expr_stmt|;
block|}
name|fs
operator|->
name|fs_refc
operator|++
expr_stmt|;
if|if
condition|(
name|ip
condition|)
name|XFREE
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
name|fs
return|;
block|}
block|}
comment|/*    * Get here if we can't find an entry    */
comment|/*    * Allocate a new server    */
name|fs
operator|=
name|ALLOC
argument_list|(
expr|struct
name|fserver
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_refc
operator|=
literal|1
expr_stmt|;
name|fs
operator|->
name|fs_host
operator|=
name|strdup
argument_list|(
name|hp
condition|?
name|hp
operator|->
name|h_name
else|:
literal|"unknown_hostname"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gopt
operator|.
name|flags
operator|&
name|CFM_NORMALIZE_HOSTNAMES
condition|)
name|host_normalize
argument_list|(
operator|&
name|fs
operator|->
name|fs_host
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_ip
operator|=
name|ip
expr_stmt|;
name|fs
operator|->
name|fs_cid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ip
condition|)
block|{
name|fs
operator|->
name|fs_flags
operator|=
name|FSF_DOWN
expr_stmt|;
comment|/* Starts off down */
block|}
else|else
block|{
name|fs
operator|->
name|fs_flags
operator|=
name|FSF_ERROR
operator||
name|FSF_VALID
expr_stmt|;
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_ERROR
expr_stmt|;
name|mf
operator|->
name|mf_error
operator|=
name|ENOENT
expr_stmt|;
block|}
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_WEBNFS
condition|)
name|fs
operator|->
name|fs_flags
operator||=
name|FSF_WEBNFS
expr_stmt|;
name|fs
operator|->
name|fs_version
operator|=
name|nfs_version
expr_stmt|;
name|fs
operator|->
name|fs_proto
operator|=
name|nfs_proto
expr_stmt|;
name|fs
operator|->
name|fs_type
operator|=
name|MNTTAB_TYPE_NFS
expr_stmt|;
name|fs
operator|->
name|fs_pinger
operator|=
name|AM_PINGER
expr_stmt|;
name|fs
operator|->
name|fs_flags
operator||=
name|FSF_PING_UNINIT
expr_stmt|;
comment|/* pinger hasn't been initialized */
name|np
operator|=
name|ALLOC
argument_list|(
expr|struct
name|nfs_private
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|voidp
operator|)
name|np
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|np_mountd_inval
operator|=
name|TRUE
expr_stmt|;
name|np
operator|->
name|np_xid
operator|=
name|XID_ALLOC
argument_list|()
expr_stmt|;
name|np
operator|->
name|np_error
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*    * Initially the server will be deemed dead after    * MAX_ALLOWED_PINGS of the fast variety have failed.    */
name|np
operator|->
name|np_ttl
operator|=
name|clocktime
argument_list|(
name|NULL
argument_list|)
operator|+
name|MAX_ALLOWED_PINGS
operator|*
name|FAST_NFS_PING
operator|-
literal|1
expr_stmt|;
name|fs
operator|->
name|fs_private
operator|=
operator|(
name|voidp
operator|)
name|np
expr_stmt|;
name|fs
operator|->
name|fs_prfree
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|voidp
argument_list|)
operator|)
name|free
expr_stmt|;
if|if
condition|(
operator|!
name|FSRV_ERROR
argument_list|(
name|fs
argument_list|)
condition|)
block|{
comment|/* start of keepalive timer, first updating pingval */
name|start_nfs_pings
argument_list|(
name|fs
argument_list|,
name|pingval
argument_list|)
expr_stmt|;
if|if
condition|(
name|fserver_is_down
condition|)
name|fs
operator|->
name|fs_flags
operator||=
name|FSF_VALID
operator||
name|FSF_DOWN
expr_stmt|;
block|}
comment|/*    * Add to list of servers    */
name|ins_que
argument_list|(
operator|&
name|fs
operator|->
name|fs_q
argument_list|,
operator|&
name|nfs_srvr_list
argument_list|)
expr_stmt|;
return|return
name|fs
return|;
block|}
end_function

end_unit

