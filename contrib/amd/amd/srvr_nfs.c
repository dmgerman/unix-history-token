begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997-1998 Erez Zadok  * Copyright (c) 1990 Jan-Simon Pendry  * Copyright (c) 1990 Imperial College of Science, Technology& Medicine  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry at Imperial College, London.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgment:  *      This product includes software developed by the University of  *      California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      %W% (Berkeley) %G%  *  * $Id: srvr_nfs.c,v 1.2 1998/12/27 06:24:48 ezk Exp $  *  */
end_comment

begin_comment
comment|/*  * NFS server modeling  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<am_defs.h>
end_include

begin_include
include|#
directive|include
file|<amd.h>
end_include

begin_comment
comment|/*  * Number of pings allowed to fail before host is declared down  * - three-fifths of the allowed mount time...  */
end_comment

begin_define
define|#
directive|define
name|MAX_ALLOWED_PINGS
value|(3 +
comment|/* for luck ... */
value|1)
end_define

begin_comment
comment|/*  * How often to ping when starting a new server  */
end_comment

begin_define
define|#
directive|define
name|FAST_NFS_PING
value|3
end_define

begin_if
if|#
directive|if
operator|(
name|FAST_NFS_PING
operator|*
name|MAX_ALLOWED_PINGS
operator|)
operator|>=
name|ALLOWED_MOUNT_TIME
end_if

begin_error
error|#
directive|error
error|: sanity check failed in srvr_nfs.c
end_error

begin_comment
comment|/*  * you cannot do things this way...  * sufficient fast pings must be given the chance to fail  * within the allowed mount time  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (FAST_NFS_PING * MAX_ALLOWED_PINGS)>= ALLOWED_MOUNT_TIME */
end_comment

begin_define
define|#
directive|define
name|NPXID_ALLOC
parameter_list|(
name|struct
define|)	(++np_xid)
end_define

begin_comment
comment|/* structures and typedefs */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|nfs_private
block|{
name|u_short
name|np_mountd
decl_stmt|;
comment|/* Mount daemon port number */
name|char
name|np_mountd_inval
decl_stmt|;
comment|/* Port *may* be invalid */
name|int
name|np_ping
decl_stmt|;
comment|/* Number of failed ping attempts */
name|time_t
name|np_ttl
decl_stmt|;
comment|/* Time when server is thought dead */
name|int
name|np_xid
decl_stmt|;
comment|/* RPC transaction id for pings */
name|int
name|np_error
decl_stmt|;
comment|/* Error during portmap request */
block|}
name|nfs_private
typedef|;
end_typedef

begin_comment
comment|/* globals */
end_comment

begin_decl_stmt
name|qelem
name|nfs_srvr_list
init|=
block|{
operator|&
name|nfs_srvr_list
block|,
operator|&
name|nfs_srvr_list
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* statics */
end_comment

begin_decl_stmt
specifier|static
name|int
name|np_xid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For NFS pings */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ping_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ping_buf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|rpc_msg
argument_list|)
operator|+
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MNTTAB_OPT_PROTO
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_FS_NFS3
argument_list|)
end_if

begin_comment
comment|/* protocols we know about, in order of preference */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|protocols
index|[]
init|=
block|{
literal|"tcp"
block|,
literal|"udp"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(MNTTAB_OPT_PROTO) || defined(HAVE_FS_NFS3) */
end_comment

begin_comment
comment|/* forward definitions */
end_comment

begin_function_decl
specifier|static
name|void
name|nfs_keepalive
parameter_list|(
name|voidp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Flush any cached data  */
end_comment

begin_function
name|void
name|flush_srvr_nfs_cache
parameter_list|(
name|void
parameter_list|)
block|{
name|fserver
modifier|*
name|fs
init|=
literal|0
decl_stmt|;
name|ITER
argument_list|(
argument|fs
argument_list|,
argument|fserver
argument_list|,
argument|&nfs_srvr_list
argument_list|)
block|{
name|nfs_private
modifier|*
name|np
init|=
operator|(
name|nfs_private
operator|*
operator|)
name|fs
operator|->
name|fs_private
decl_stmt|;
if|if
condition|(
name|np
condition|)
block|{
name|np
operator|->
name|np_mountd_inval
operator|=
name|TRUE
expr_stmt|;
name|np
operator|->
name|np_error
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Startup the NFS ping for a particular version.  */
end_comment

begin_function
specifier|static
name|void
name|start_ping
parameter_list|(
name|u_long
name|nfs_version
parameter_list|)
block|{
name|XDR
name|ping_xdr
decl_stmt|;
name|struct
name|rpc_msg
name|ping_msg
decl_stmt|;
comment|/*    * Non nfs mounts like /afs/glue.umd.edu have ended up here.    */
if|if
condition|(
name|nfs_version
operator|==
literal|0
condition|)
block|{
name|nfs_version
operator|=
name|NFS_VERSION
expr_stmt|;
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"start_ping: nfs_version = 0 fixed"
argument_list|)
expr_stmt|;
block|}
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"start_ping: nfs_version: %d"
argument_list|,
name|nfs_version
argument_list|)
expr_stmt|;
name|rpc_msg_init
argument_list|(
operator|&
name|ping_msg
argument_list|,
name|NFS_PROGRAM
argument_list|,
name|nfs_version
argument_list|,
name|NFSPROC_NULL
argument_list|)
expr_stmt|;
comment|/*    * Create an XDR endpoint    */
name|xdrmem_create
argument_list|(
operator|&
name|ping_xdr
argument_list|,
name|ping_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|ping_buf
argument_list|)
argument_list|,
name|XDR_ENCODE
argument_list|)
expr_stmt|;
comment|/*    * Create the NFS ping message    */
if|if
condition|(
operator|!
name|xdr_callmsg
argument_list|(
operator|&
name|ping_xdr
argument_list|,
operator|&
name|ping_msg
argument_list|)
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"Couldn't create ping RPC message"
argument_list|)
expr_stmt|;
name|going_down
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/*    * Find out how long it is    */
name|ping_len
operator|=
name|xdr_getpos
argument_list|(
operator|&
name|ping_xdr
argument_list|)
expr_stmt|;
comment|/*    * Destroy the XDR endpoint - we don't need it anymore    */
name|xdr_destroy
argument_list|(
operator|&
name|ping_xdr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called when a portmap reply arrives  */
end_comment

begin_function
specifier|static
name|void
name|got_portmap
parameter_list|(
name|voidp
name|pkt
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|sa
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|ia
parameter_list|,
name|voidp
name|idv
parameter_list|,
name|int
name|done
parameter_list|)
block|{
name|fserver
modifier|*
name|fs2
init|=
operator|(
name|fserver
operator|*
operator|)
name|idv
decl_stmt|;
name|fserver
modifier|*
name|fs
init|=
literal|0
decl_stmt|;
comment|/*    * Find which fileserver we are talking about    */
name|ITER
argument_list|(
argument|fs
argument_list|,
argument|fserver
argument_list|,
argument|&nfs_srvr_list
argument_list|)
if|if
condition|(
name|fs
operator|==
name|fs2
condition|)
break|break;
if|if
condition|(
name|fs
operator|==
name|fs2
condition|)
block|{
name|u_long
name|port
init|=
literal|0
decl_stmt|;
comment|/* XXX - should be short but protocol is naff */
name|int
name|error
init|=
name|done
condition|?
name|pickup_rpc_reply
argument_list|(
name|pkt
argument_list|,
name|len
argument_list|,
operator|(
name|voidp
operator|)
operator|&
name|port
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_u_long
argument_list|)
else|:
operator|-
literal|1
decl_stmt|;
name|nfs_private
modifier|*
name|np
init|=
operator|(
name|nfs_private
operator|*
operator|)
name|fs
operator|->
name|fs_private
decl_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|port
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"got port (%d) for mountd on %s"
argument_list|,
name|port
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/*        * Grab the port number.  Portmap sends back        * an u_long in native ordering, so it        * needs converting to a u_short in        * network ordering.        */
name|np
operator|->
name|np_mountd
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|port
argument_list|)
expr_stmt|;
name|np
operator|->
name|np_mountd_inval
operator|=
name|FALSE
expr_stmt|;
name|np
operator|->
name|np_error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Error fetching port for mountd on %s"
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
literal|"\t error=%d, port=%d"
argument_list|,
name|error
argument_list|,
name|port
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/*        * Almost certainly no mountd running on remote host        */
name|np
operator|->
name|np_error
operator|=
name|error
condition|?
name|error
else|:
name|ETIMEDOUT
expr_stmt|;
block|}
if|if
condition|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_WANT
condition|)
name|wakeup_srvr
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|done
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Got portmap for old port request"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"portmap request timed out"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
block|}
end_function

begin_comment
comment|/*  * Obtain portmap information  */
end_comment

begin_function
specifier|static
name|int
name|call_portmap
parameter_list|(
name|fserver
modifier|*
name|fs
parameter_list|,
name|AUTH
modifier|*
name|auth
parameter_list|,
name|u_long
name|prog
parameter_list|,
name|u_long
name|vers
parameter_list|,
name|u_long
name|prot
parameter_list|)
block|{
name|struct
name|rpc_msg
name|pmap_msg
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
name|iobuf
index|[
name|UDPMSGSIZE
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|pmap
name|pmap
decl_stmt|;
name|rpc_msg_init
argument_list|(
operator|&
name|pmap_msg
argument_list|,
name|PMAPPROG
argument_list|,
name|PMAPVERS
argument_list|,
name|PMAPPROC_NULL
argument_list|)
expr_stmt|;
name|pmap
operator|.
name|pm_prog
operator|=
name|prog
expr_stmt|;
name|pmap
operator|.
name|pm_vers
operator|=
name|vers
expr_stmt|;
name|pmap
operator|.
name|pm_prot
operator|=
name|prot
expr_stmt|;
name|pmap
operator|.
name|pm_port
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|make_rpc_packet
argument_list|(
name|iobuf
argument_list|,
sizeof|sizeof
argument_list|(
name|iobuf
argument_list|)
argument_list|,
name|PMAPPROC_GETPORT
argument_list|,
operator|&
name|pmap_msg
argument_list|,
operator|(
name|voidp
operator|)
operator|&
name|pmap
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_pmap
argument_list|,
name|auth
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|memset
argument_list|(
operator|(
name|voidp
operator|)
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|=
operator|*
name|fs
operator|->
name|fs_ip
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|PMAPPORT
argument_list|)
expr_stmt|;
name|error
operator|=
name|fwd_packet
argument_list|(
name|RPC_XID_PORTMAP
argument_list|,
operator|(
name|voidp
operator|)
name|iobuf
argument_list|,
name|len
argument_list|,
operator|&
name|sin
argument_list|,
operator|&
name|sin
argument_list|,
operator|(
name|voidp
operator|)
name|fs
argument_list|,
name|got_portmap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
operator|-
name|len
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|recompute_portmap
parameter_list|(
name|fserver
modifier|*
name|fs
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|u_long
name|mnt_version
decl_stmt|;
if|if
condition|(
name|nfs_auth
condition|)
name|error
operator|=
literal|0
expr_stmt|;
else|else
name|error
operator|=
name|make_nfs_auth
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nfs_private
modifier|*
name|np
init|=
operator|(
name|nfs_private
operator|*
operator|)
name|fs
operator|->
name|fs_private
decl_stmt|;
name|np
operator|->
name|np_error
operator|=
name|error
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fs
operator|->
name|fs_version
operator|==
literal|0
condition|)
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"recompute_portmap: nfs_version = 0 fixed"
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"recompute_portmap: NFS version %d"
argument_list|,
name|fs
operator|->
name|fs_version
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FS_NFS3
if|if
condition|(
name|fs
operator|->
name|fs_version
operator|==
name|NFS_VERSION3
condition|)
name|mnt_version
operator|=
name|MOUNTVERS3
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* HAVE_FS_NFS3 */
name|mnt_version
operator|=
name|MOUNTVERS
expr_stmt|;
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"Using MOUNT version: %d"
argument_list|,
name|mnt_version
argument_list|)
expr_stmt|;
name|call_portmap
argument_list|(
name|fs
argument_list|,
name|nfs_auth
argument_list|,
name|MOUNTPROG
argument_list|,
name|mnt_version
argument_list|,
operator|(
name|u_long
operator|)
name|IPPROTO_UDP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called when we get a reply to an RPC ping.  * The value of id was taken from the nfs_private  * structure when the ping was transmitted.  */
end_comment

begin_function
specifier|static
name|void
name|nfs_pinged
parameter_list|(
name|voidp
name|pkt
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|sp
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|tsp
parameter_list|,
name|voidp
name|idv
parameter_list|,
name|int
name|done
parameter_list|)
block|{
name|int
name|xid
init|=
operator|(
name|long
operator|)
name|idv
decl_stmt|;
comment|/* for 64-bit archs */
name|fserver
modifier|*
name|fs
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|found_map
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
operator|!
name|done
condition|)
return|return;
comment|/*    * For each node...    */
name|ITER
argument_list|(
argument|fs
argument_list|,
argument|fserver
argument_list|,
argument|&nfs_srvr_list
argument_list|)
block|{
name|nfs_private
modifier|*
name|np
init|=
operator|(
name|nfs_private
operator|*
operator|)
name|fs
operator|->
name|fs_private
decl_stmt|;
if|if
condition|(
name|np
operator|->
name|np_xid
operator|==
name|xid
operator|&&
operator|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_PINGING
operator|)
condition|)
block|{
comment|/*        * Reset the ping counter.        * Update the keepalive timer.        * Log what happened.        */
if|if
condition|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_DOWN
condition|)
block|{
name|fs
operator|->
name|fs_flags
operator|&=
operator|~
name|FSF_DOWN
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_VALID
condition|)
block|{
name|srvrlog
argument_list|(
name|fs
argument_list|,
literal|"is up"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|np
operator|->
name|np_ping
operator|>
literal|1
condition|)
name|srvrlog
argument_list|(
name|fs
argument_list|,
literal|"ok"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
else|else
name|srvrlog
argument_list|(
name|fs
argument_list|,
literal|"starts up"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|fs
operator|->
name|fs_flags
operator||=
name|FSF_VALID
expr_stmt|;
block|}
name|map_flush_srvr
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_VALID
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"file server %s type nfs is still up"
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
else|else
block|{
if|if
condition|(
name|np
operator|->
name|np_ping
operator|>
literal|1
condition|)
name|srvrlog
argument_list|(
name|fs
argument_list|,
literal|"ok"
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_flags
operator||=
name|FSF_VALID
expr_stmt|;
block|}
block|}
comment|/*        * Adjust ping interval        */
name|untimeout
argument_list|(
name|fs
operator|->
name|fs_cid
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_cid
operator|=
name|timeout
argument_list|(
name|fs
operator|->
name|fs_pinger
argument_list|,
name|nfs_keepalive
argument_list|,
operator|(
name|voidp
operator|)
name|fs
argument_list|)
expr_stmt|;
comment|/*        * Update ttl for this server        */
name|np
operator|->
name|np_ttl
operator|=
name|clocktime
argument_list|()
operator|+
operator|(
name|MAX_ALLOWED_PINGS
operator|-
literal|1
operator|)
operator|*
name|FAST_NFS_PING
operator|+
name|fs
operator|->
name|fs_pinger
operator|-
literal|1
expr_stmt|;
comment|/*        * New RPC xid...        */
name|np
operator|->
name|np_xid
operator|=
name|NPXID_ALLOC
argument_list|(
expr|struct
argument_list|)
expr_stmt|;
comment|/*        * Failed pings is zero...        */
name|np
operator|->
name|np_ping
operator|=
literal|0
expr_stmt|;
comment|/*        * Recompute portmap information if not known        */
if|if
condition|(
name|np
operator|->
name|np_mountd_inval
condition|)
name|recompute_portmap
argument_list|(
name|fs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|found_map
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|found_map
operator|==
literal|0
condition|)
name|dlog
argument_list|(
literal|"Spurious ping packet"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
end_function

begin_comment
comment|/*  * Called when no ping-reply received  */
end_comment

begin_function
specifier|static
name|void
name|nfs_timed_out
parameter_list|(
name|voidp
name|v
parameter_list|)
block|{
name|fserver
modifier|*
name|fs
init|=
name|v
decl_stmt|;
name|nfs_private
modifier|*
name|np
init|=
operator|(
name|nfs_private
operator|*
operator|)
name|fs
operator|->
name|fs_private
decl_stmt|;
comment|/*    * Another ping has failed    */
name|np
operator|->
name|np_ping
operator|++
expr_stmt|;
comment|/*    * Not known to be up any longer    */
if|if
condition|(
name|FSRV_ISUP
argument_list|(
name|fs
argument_list|)
condition|)
block|{
name|fs
operator|->
name|fs_flags
operator|&=
operator|~
name|FSF_VALID
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|np_ping
operator|>
literal|1
condition|)
name|srvrlog
argument_list|(
name|fs
argument_list|,
literal|"not responding"
argument_list|)
expr_stmt|;
block|}
comment|/*    * If ttl has expired then guess that it is dead    */
if|if
condition|(
name|np
operator|->
name|np_ttl
operator|<
name|clocktime
argument_list|()
condition|)
block|{
name|int
name|oflags
init|=
name|fs
operator|->
name|fs_flags
decl_stmt|;
if|if
condition|(
operator|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_DOWN
operator|)
operator|==
literal|0
condition|)
block|{
comment|/*        * Server was up, but is now down.        */
name|srvrlog
argument_list|(
name|fs
argument_list|,
literal|"is down"
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_flags
operator||=
name|FSF_DOWN
operator||
name|FSF_VALID
expr_stmt|;
comment|/*        * Since the server is down, the portmap        * information may now be wrong, so it        * must be flushed from the local cache        */
name|flush_nfs_fhandle_cache
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|np
operator|->
name|np_error
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/*        * Known to be down        */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_VALID
operator|)
operator|==
literal|0
condition|)
name|srvrlog
argument_list|(
name|fs
argument_list|,
literal|"starts down"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|fs
operator|->
name|fs_flags
operator||=
name|FSF_VALID
expr_stmt|;
block|}
if|if
condition|(
name|oflags
operator|!=
name|fs
operator|->
name|fs_flags
operator|&&
operator|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_WANT
operator|)
condition|)
name|wakeup_srvr
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|np
operator|->
name|np_ping
operator|>
literal|1
condition|)
name|dlog
argument_list|(
literal|"%d pings to %s failed - at most %d allowed"
argument_list|,
name|np
operator|->
name|np_ping
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|,
name|MAX_ALLOWED_PINGS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
comment|/*    * Run keepalive again    */
name|nfs_keepalive
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Keep track of whether a server is alive  */
end_comment

begin_function
specifier|static
name|void
name|nfs_keepalive
parameter_list|(
name|voidp
name|v
parameter_list|)
block|{
name|fserver
modifier|*
name|fs
init|=
name|v
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nfs_private
modifier|*
name|np
init|=
operator|(
name|nfs_private
operator|*
operator|)
name|fs
operator|->
name|fs_private
decl_stmt|;
name|int
name|fstimeo
init|=
operator|-
literal|1
decl_stmt|;
comment|/*    * Send an NFS ping to this node    */
if|if
condition|(
name|ping_len
operator|==
literal|0
condition|)
name|start_ping
argument_list|(
name|fs
operator|->
name|fs_version
argument_list|)
expr_stmt|;
comment|/*    * Queue the packet...    */
name|error
operator|=
name|fwd_packet
argument_list|(
name|MK_RPC_XID
argument_list|(
name|RPC_XID_NFSPING
argument_list|,
name|np
operator|->
name|np_xid
argument_list|)
argument_list|,
operator|(
name|voidp
operator|)
name|ping_buf
argument_list|,
name|ping_len
argument_list|,
name|fs
operator|->
name|fs_ip
argument_list|,
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
literal|0
argument_list|,
call|(
name|voidp
call|)
argument_list|(
operator|(
name|long
operator|)
name|np
operator|->
name|np_xid
argument_list|)
argument_list|,
comment|/* for 64-bit archs */
name|nfs_pinged
argument_list|)
expr_stmt|;
comment|/*    * See if a hard error occurred    */
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|ENETDOWN
case|:
case|case
name|ENETUNREACH
case|:
case|case
name|EHOSTDOWN
case|:
case|case
name|EHOSTUNREACH
case|:
name|np
operator|->
name|np_ping
operator|=
name|MAX_ALLOWED_PINGS
expr_stmt|;
comment|/* immediately down */
name|np
operator|->
name|np_ttl
operator|=
operator|(
name|time_t
operator|)
literal|0
expr_stmt|;
comment|/*      * This causes an immediate call to nfs_timed_out      * whenever the server was thought to be up.      * See +++ below.      */
name|fstimeo
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Sent NFS ping to %s"
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
break|break;
block|}
comment|/*    * Back off the ping interval if we are not getting replies and    * the remote system is know to be down.    */
switch|switch
condition|(
name|fs
operator|->
name|fs_flags
operator|&
operator|(
name|FSF_DOWN
operator||
name|FSF_VALID
operator|)
condition|)
block|{
case|case
name|FSF_VALID
case|:
comment|/* Up */
if|if
condition|(
name|fstimeo
operator|<
literal|0
condition|)
comment|/* +++ see above */
name|fstimeo
operator|=
name|FAST_NFS_PING
expr_stmt|;
break|break;
case|case
name|FSF_VALID
operator||
name|FSF_DOWN
case|:
comment|/* Down */
name|fstimeo
operator|=
name|fs
operator|->
name|fs_pinger
expr_stmt|;
break|break;
default|default:
comment|/* Unknown */
name|fstimeo
operator|=
name|FAST_NFS_PING
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"NFS timeout in %d seconds"
argument_list|,
name|fstimeo
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|fs
operator|->
name|fs_cid
operator|=
name|timeout
argument_list|(
name|fstimeo
argument_list|,
name|nfs_timed_out
argument_list|,
operator|(
name|voidp
operator|)
name|fs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|nfs_srvr_port
parameter_list|(
name|fserver
modifier|*
name|fs
parameter_list|,
name|u_short
modifier|*
name|port
parameter_list|,
name|voidp
name|wchan
parameter_list|)
block|{
name|int
name|error
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_VALID
operator|)
operator|==
name|FSF_VALID
condition|)
block|{
if|if
condition|(
operator|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_DOWN
operator|)
operator|==
literal|0
condition|)
block|{
name|nfs_private
modifier|*
name|np
init|=
operator|(
name|nfs_private
operator|*
operator|)
name|fs
operator|->
name|fs_private
decl_stmt|;
if|if
condition|(
name|np
operator|->
name|np_error
operator|==
literal|0
condition|)
block|{
operator|*
name|port
operator|=
name|np
operator|->
name|np_mountd
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|np
operator|->
name|np_error
expr_stmt|;
block|}
comment|/*        * Now go get the port mapping again in case it changed.        * Note that it is used even if (np_mountd_inval)        * is True.  The flag is used simply as an        * indication that the mountd may be invalid, not        * that it is known to be invalid.        */
if|if
condition|(
name|np
operator|->
name|np_mountd_inval
condition|)
name|recompute_portmap
argument_list|(
name|fs
argument_list|)
expr_stmt|;
else|else
name|np
operator|->
name|np_mountd_inval
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|<
literal|0
operator|&&
name|wchan
operator|&&
operator|!
operator|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_WANT
operator|)
condition|)
block|{
comment|/*      * If a wait channel is supplied, and no      * error has yet occurred, then arrange      * that a wakeup is done on the wait channel,      * whenever a wakeup is done on this fs node.      * Wakeup's are done on the fs node whenever      * it changes state - thus causing control to      * come back here and new, better things to happen.      */
name|fs
operator|->
name|fs_flags
operator||=
name|FSF_WANT
expr_stmt|;
name|sched_task
argument_list|(
name|wakeup_task
argument_list|,
name|wchan
argument_list|,
operator|(
name|voidp
operator|)
name|fs
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|start_nfs_pings
parameter_list|(
name|fserver
modifier|*
name|fs
parameter_list|,
name|int
name|pingval
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_PINGING
operator|)
condition|)
block|{
name|fs
operator|->
name|fs_flags
operator||=
name|FSF_PINGING
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_cid
condition|)
name|untimeout
argument_list|(
name|fs
operator|->
name|fs_cid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pingval
operator|<
literal|0
condition|)
block|{
name|srvrlog
argument_list|(
name|fs
argument_list|,
literal|"wired up"
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_flags
operator||=
name|FSF_VALID
expr_stmt|;
name|fs
operator|->
name|fs_flags
operator|&=
operator|~
name|FSF_DOWN
expr_stmt|;
block|}
else|else
block|{
name|nfs_keepalive
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Already running pings to %s"
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
block|}
end_function

begin_comment
comment|/*  * Find an nfs server for a host.  */
end_comment

begin_function
name|fserver
modifier|*
name|find_nfs_srvr
parameter_list|(
name|mntfs
modifier|*
name|mf
parameter_list|)
block|{
name|char
modifier|*
name|host
init|=
name|mf
operator|->
name|mf_fo
operator|->
name|opt_rhost
decl_stmt|;
name|char
modifier|*
name|nfs_proto
init|=
name|NULL
decl_stmt|;
name|fserver
modifier|*
name|fs
decl_stmt|;
name|int
name|pingval
decl_stmt|;
name|mntent_t
name|mnt
decl_stmt|;
name|nfs_private
modifier|*
name|np
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
init|=
literal|0
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|ip
decl_stmt|;
name|u_long
name|nfs_version
init|=
literal|0
decl_stmt|;
comment|/* default is no version specified */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_PROTO
name|char
modifier|*
name|rfsname
init|=
name|mf
operator|->
name|mf_fo
operator|->
name|opt_rfs
decl_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_OPT_PROTO */
comment|/*    * Get ping interval from mount options.    * Current only used to decide whether pings    * are required or not.< 0 = no pings.    */
name|mnt
operator|.
name|mnt_opts
operator|=
name|mf
operator|->
name|mf_mopts
expr_stmt|;
name|pingval
operator|=
name|hasmntval
argument_list|(
operator|&
name|mnt
argument_list|,
literal|"ping"
argument_list|)
expr_stmt|;
comment|/*    * Get the NFS version from the mount options. This is used    * to decide the highest NFS version to try.    */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_VERS
name|nfs_version
operator|=
name|hasmntval
argument_list|(
operator|&
name|mnt
argument_list|,
name|MNTTAB_OPT_VERS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_OPT_VERS */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_PROTO
block|{
name|char
modifier|*
name|proto_opt
init|=
name|hasmntopt
argument_list|(
operator|&
name|mnt
argument_list|,
name|MNTTAB_OPT_PROTO
argument_list|)
decl_stmt|;
if|if
condition|(
name|proto_opt
condition|)
block|{
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|proto_opt
operator|+=
sizeof|sizeof
argument_list|(
name|MNTTAB_OPT_PROTO
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* skip the "proto" */
for|for
control|(
name|p
operator|=
name|protocols
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|proto_opt
index|[
literal|0
index|]
operator|==
literal|'='
operator|&&
name|NSTREQ
argument_list|(
operator|&
name|proto_opt
index|[
literal|1
index|]
argument_list|,
operator|*
name|p
argument_list|,
name|strlen
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|nfs_proto
operator|=
operator|*
name|p
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|p
operator|==
name|NULL
condition|)
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"ignoring unknown protocol option for %s:%s"
argument_list|,
name|host
argument_list|,
name|rfsname
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* MNTTAB_OPT_PROTO */
ifdef|#
directive|ifdef
name|HAVE_NFS_NFSV2_H
comment|/* allow overriding if nfsv2 option is specified in mount options */
if|if
condition|(
name|hasmntopt
argument_list|(
operator|&
name|mnt
argument_list|,
literal|"nfsv2"
argument_list|)
condition|)
block|{
name|nfs_version
operator|=
operator|(
name|u_long
operator|)
literal|2
expr_stmt|;
comment|/* nullify any ``vers=X'' statements */
name|nfs_proto
operator|=
literal|"udp"
expr_stmt|;
comment|/* nullify any ``proto=tcp'' stmts */
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"found compatiblity option \"nfsv2\": set options vers=2, proto=udp for host %s"
argument_list|,
name|host
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_NFS_NFSV2_H */
comment|/*    * lookup host address and canonical name    */
name|hp
operator|=
name|gethostbyname
argument_list|(
name|host
argument_list|)
expr_stmt|;
comment|/*    * New code from Bob Harris<harris@basil-rathbone.mit.edu>    * Use canonical name to keep track of file server    * information.  This way aliases do not generate    * multiple NFS pingers.  (Except when we're normalizing    * hosts.)    */
if|if
condition|(
name|hp
operator|&&
operator|!
operator|(
name|gopt
operator|.
name|flags
operator|&
name|CFM_NORMALIZE_HOSTNAMES
operator|)
condition|)
name|host
operator|=
operator|(
name|char
operator|*
operator|)
name|hp
operator|->
name|h_name
expr_stmt|;
if|if
condition|(
name|hp
condition|)
block|{
switch|switch
condition|(
name|hp
operator|->
name|h_addrtype
condition|)
block|{
case|case
name|AF_INET
case|:
name|ip
operator|=
name|ALLOC
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|voidp
operator|)
name|ip
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|ip
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|memmove
argument_list|(
operator|(
name|voidp
operator|)
operator|&
name|ip
operator|->
name|sin_addr
argument_list|,
operator|(
name|voidp
operator|)
name|hp
operator|->
name|h_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ip
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
name|NFS_PORT
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ip
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|plog
argument_list|(
name|XLOG_USER
argument_list|,
literal|"Unknown host: %s"
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|ip
operator|=
literal|0
expr_stmt|;
block|}
comment|/*    * Get the NFS Version, and verify server is up. Probably no    * longer need to start server down below.    */
if|if
condition|(
name|ip
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_FS_NFS3
comment|/*      * Find the best combination of NFS version and protocol.      * When given a choice, use the highest available version,      * and use TCP over UDP if available.      */
if|if
condition|(
name|nfs_proto
condition|)
name|nfs_version
operator|=
name|get_nfs_version
argument_list|(
name|host
argument_list|,
name|ip
argument_list|,
name|nfs_version
argument_list|,
name|nfs_proto
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|best_nfs_version
init|=
literal|0
decl_stmt|;
name|int
name|proto_nfs_version
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|protocols
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|proto_nfs_version
operator|=
name|get_nfs_version
argument_list|(
name|host
argument_list|,
name|ip
argument_list|,
name|nfs_version
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto_nfs_version
operator|>
name|best_nfs_version
condition|)
block|{
name|best_nfs_version
operator|=
name|proto_nfs_version
expr_stmt|;
name|nfs_proto
operator|=
operator|*
name|p
expr_stmt|;
block|}
block|}
name|nfs_version
operator|=
name|best_nfs_version
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nfs_version
condition|)
block|{
comment|/*        * If the NFS server is down or does not support the portmapper call        * (such as certain Novell NFS servers) we mark it as version 2 and we        * let the nfs code deal with the case that is down.  If when the        * server comes back up, it can support NFS V.3 and/or TCP, it will        * use those.        */
name|nfs_version
operator|=
name|NFS_VERSION
expr_stmt|;
name|nfs_proto
operator|=
literal|"udp"
expr_stmt|;
block|}
else|#
directive|else
comment|/* not HAVE_FS_NFS3 */
name|nfs_version
operator|=
name|NFS_VERSION
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_FS_NFS3 */
block|}
if|if
condition|(
operator|!
name|nfs_proto
condition|)
name|nfs_proto
operator|=
literal|"udp"
expr_stmt|;
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"Using NFS version %d, protocol %s on host %s"
argument_list|,
name|nfs_version
argument_list|,
name|nfs_proto
argument_list|,
name|host
argument_list|)
expr_stmt|;
comment|/*    * Try to find an existing fs server structure for this host.    * Note that differing versions or protocols have their own structures.    * XXX: Need to fix the ping mechanism to actually use the NFS protocol    * chosen here (right now it always uses datagram sockets).    */
name|ITER
argument_list|(
argument|fs
argument_list|,
argument|fserver
argument_list|,
argument|&nfs_srvr_list
argument_list|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|host
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|)
operator|&&
name|nfs_version
operator|==
name|fs
operator|->
name|fs_version
operator|&&
name|STREQ
argument_list|(
name|nfs_proto
argument_list|,
name|fs
operator|->
name|fs_proto
argument_list|)
condition|)
block|{
comment|/*        * following if statement from Mike Mitchell        *<mcm@unx.sas.com>        * Initialize the ping data if we aren't pinging        * now.  The np_ttl and np_ping fields are        * especially important.        */
if|if
condition|(
operator|!
operator|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_PINGING
operator|)
condition|)
block|{
name|np
operator|=
operator|(
name|nfs_private
operator|*
operator|)
name|fs
operator|->
name|fs_private
expr_stmt|;
name|np
operator|->
name|np_mountd_inval
operator|=
name|TRUE
expr_stmt|;
name|np
operator|->
name|np_xid
operator|=
name|NPXID_ALLOC
argument_list|(
expr|struct
argument_list|)
expr_stmt|;
name|np
operator|->
name|np_error
operator|=
operator|-
literal|1
expr_stmt|;
name|np
operator|->
name|np_ping
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Initially the server will be deemed dead 	 * after MAX_ALLOWED_PINGS of the fast variety 	 * have failed. 	 */
name|np
operator|->
name|np_ttl
operator|=
name|MAX_ALLOWED_PINGS
operator|*
name|FAST_NFS_PING
operator|+
name|clocktime
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
comment|/*        * fill in the IP address -- this is only needed        * if there is a chance an IP address will change        * between mounts.        * Mike Mitchell, mcm@unx.sas.com, 09/08/93        */
if|if
condition|(
name|hp
operator|&&
name|fs
operator|->
name|fs_ip
condition|)
name|memmove
argument_list|(
operator|(
name|voidp
operator|)
operator|&
name|fs
operator|->
name|fs_ip
operator|->
name|sin_addr
argument_list|,
operator|(
name|voidp
operator|)
name|hp
operator|->
name|h_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|fs
operator|->
name|fs_ip
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|start_nfs_pings
argument_list|(
name|fs
argument_list|,
name|pingval
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_refc
operator|++
expr_stmt|;
if|if
condition|(
name|ip
condition|)
name|XFREE
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
name|fs
return|;
block|}
block|}
comment|/*    * Get here if we can't find an entry    */
comment|/*    * Allocate a new server    */
name|fs
operator|=
name|ALLOC
argument_list|(
expr|struct
name|fserver
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_refc
operator|=
literal|1
expr_stmt|;
name|fs
operator|->
name|fs_host
operator|=
name|strdup
argument_list|(
name|hp
condition|?
name|hp
operator|->
name|h_name
else|:
literal|"unknown_hostname"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gopt
operator|.
name|flags
operator|&
name|CFM_NORMALIZE_HOSTNAMES
condition|)
name|host_normalize
argument_list|(
operator|&
name|fs
operator|->
name|fs_host
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_ip
operator|=
name|ip
expr_stmt|;
name|fs
operator|->
name|fs_cid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ip
condition|)
block|{
name|fs
operator|->
name|fs_flags
operator|=
name|FSF_DOWN
expr_stmt|;
comment|/* Starts off down */
block|}
else|else
block|{
name|fs
operator|->
name|fs_flags
operator|=
name|FSF_ERROR
operator||
name|FSF_VALID
expr_stmt|;
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_ERROR
expr_stmt|;
name|mf
operator|->
name|mf_error
operator|=
name|ENOENT
expr_stmt|;
block|}
name|fs
operator|->
name|fs_version
operator|=
name|nfs_version
expr_stmt|;
name|fs
operator|->
name|fs_proto
operator|=
name|nfs_proto
expr_stmt|;
name|fs
operator|->
name|fs_type
operator|=
name|MNTTAB_TYPE_NFS
expr_stmt|;
name|fs
operator|->
name|fs_pinger
operator|=
name|AM_PINGER
expr_stmt|;
name|np
operator|=
name|ALLOC
argument_list|(
expr|struct
name|nfs_private
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|voidp
operator|)
name|np
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|np_mountd_inval
operator|=
name|TRUE
expr_stmt|;
name|np
operator|->
name|np_xid
operator|=
name|NPXID_ALLOC
argument_list|(
expr|struct
argument_list|)
expr_stmt|;
name|np
operator|->
name|np_error
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*    * Initially the server will be deemed dead after    * MAX_ALLOWED_PINGS of the fast variety have failed.    */
name|np
operator|->
name|np_ttl
operator|=
name|clocktime
argument_list|()
operator|+
name|MAX_ALLOWED_PINGS
operator|*
name|FAST_NFS_PING
operator|-
literal|1
expr_stmt|;
name|fs
operator|->
name|fs_private
operator|=
operator|(
name|voidp
operator|)
name|np
expr_stmt|;
name|fs
operator|->
name|fs_prfree
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|voidp
argument_list|)
operator|)
name|free
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fs
operator|->
name|fs_flags
operator|&
name|FSF_ERROR
operator|)
condition|)
block|{
comment|/*      * Start of keepalive timer      */
name|start_nfs_pings
argument_list|(
name|fs
argument_list|,
name|pingval
argument_list|)
expr_stmt|;
block|}
comment|/*    * Add to list of servers    */
name|ins_que
argument_list|(
operator|&
name|fs
operator|->
name|fs_q
argument_list|,
operator|&
name|nfs_srvr_list
argument_list|)
expr_stmt|;
return|return
name|fs
return|;
block|}
end_function

end_unit

