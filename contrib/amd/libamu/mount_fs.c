begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997-2014 Erez Zadok  * Copyright (c) 1990 Jan-Simon Pendry  * Copyright (c) 1990 Imperial College of Science, Technology& Medicine  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry at Imperial College, London.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *  * File: am-utils/libamu/mount_fs.c  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<am_defs.h>
end_include

begin_include
include|#
directive|include
file|<amu.h>
end_include

begin_include
include|#
directive|include
file|<nfs_common.h>
end_include

begin_comment
comment|/* ensure that mount table options are delimited by a comma */
end_comment

begin_define
define|#
directive|define
name|append_opts
parameter_list|(
name|old
parameter_list|,
name|l
parameter_list|,
name|new
parameter_list|)
value|{ \ 	if (*(old) != '\0') \ 	  xstrlcat(old, ",", l); \ 	xstrlcat(old, new, l); }
end_define

begin_comment
comment|/*  * Standard mount flags  */
end_comment

begin_decl_stmt
name|struct
name|opt_tab
name|mnt_flags
index|[]
init|=
block|{
if|#
directive|if
name|defined
argument_list|(
name|MNT2_GEN_OPT_RDONLY
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_RO
argument_list|)
block|{
name|MNTTAB_OPT_RO
block|,
name|MNT2_GEN_OPT_RDONLY
block|}
block|,
endif|#
directive|endif
comment|/* defined(MNT2_GEN_OPT_RDONLY)&& defined(MNTTAB_OPT_RO) */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_GEN_OPT_NOCACHE
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_NOCACHE
argument_list|)
block|{
name|MNTTAB_OPT_NOCACHE
block|,
name|MNT2_GEN_OPT_NOCACHE
block|}
block|,
endif|#
directive|endif
comment|/* defined(MNT2_GEN_OPT_NOCACHE)&& defined(MNTTAB_OPT_NOCACHE) */
comment|/* the "grpid" mount option can be offered as generic of NFS */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_GRPID
ifdef|#
directive|ifdef
name|MNT2_GEN_OPT_GRPID
block|{
name|MNTTAB_OPT_GRPID
block|,
name|MNT2_GEN_OPT_GRPID
block|}
block|,
endif|#
directive|endif
comment|/* MNT2_GEN_OPT_GRPID */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_GRPID
block|{
name|MNTTAB_OPT_GRPID
block|,
name|MNT2_NFS_OPT_GRPID
block|}
block|,
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_GRPID */
endif|#
directive|endif
comment|/* MNTTAB_OPT_GRPID */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_GEN_OPT_MULTI
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_MULTI
argument_list|)
block|{
name|MNTTAB_OPT_MULTI
block|,
name|MNT2_GEN_OPT_MULTI
block|}
block|,
endif|#
directive|endif
comment|/* defined(MNT2_GEN_OPT_MULTI)&& defined(MNTTAB_OPT_MULTI) */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_GEN_OPT_NODEV
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_NODEV
argument_list|)
block|{
name|MNTTAB_OPT_NODEV
block|,
name|MNT2_GEN_OPT_NODEV
block|}
block|,
endif|#
directive|endif
comment|/* defined(MNT2_GEN_OPT_NODEV)&& defined(MNTTAB_OPT_NODEV) */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_GEN_OPT_NOEXEC
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_NOEXEC
argument_list|)
block|{
name|MNTTAB_OPT_NOEXEC
block|,
name|MNT2_GEN_OPT_NOEXEC
block|}
block|,
endif|#
directive|endif
comment|/* defined(MNT2_GEN_OPT_NOEXEC)&& defined(MNTTAB_OPT_NOEXEC) */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_GEN_OPT_NOSUB
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_NOSUB
argument_list|)
block|{
name|MNTTAB_OPT_NOSUB
block|,
name|MNT2_GEN_OPT_NOSUB
block|}
block|,
endif|#
directive|endif
comment|/* defined(MNT2_GEN_OPT_NOSUB)&& defined(MNTTAB_OPT_NOSUB) */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_GEN_OPT_NOSUID
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_NOSUID
argument_list|)
block|{
name|MNTTAB_OPT_NOSUID
block|,
name|MNT2_GEN_OPT_NOSUID
block|}
block|,
endif|#
directive|endif
comment|/* defined(MNT2_GEN_OPT_NOSUID)&& defined(MNTTAB_OPT_NOSUID) */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_GEN_OPT_SYNC
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_SYNC
argument_list|)
block|{
name|MNTTAB_OPT_SYNC
block|,
name|MNT2_GEN_OPT_SYNC
block|}
block|,
endif|#
directive|endif
comment|/* defined(MNT2_GEN_OPT_SYNC)&& defined(MNTTAB_OPT_SYNC) */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_GEN_OPT_OVERLAY
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_OVERLAY
argument_list|)
block|{
name|MNTTAB_OPT_OVERLAY
block|,
name|MNT2_GEN_OPT_OVERLAY
block|}
block|,
endif|#
directive|endif
comment|/* defined(MNT2_GEN_OPT_OVERLAY)&& defined(MNTTAB_OPT_OVERLAY) */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_GEN_OPT_LOG
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_LOG
argument_list|)
block|{
name|MNTTAB_OPT_LOG
block|,
name|MNT2_GEN_OPT_LOG
block|}
block|,
endif|#
directive|endif
comment|/* defined(MNT2_GEN_OPT_LOG)&& defined(MNTTAB_OPT_LOG) */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_GEN_OPT_NOATIME
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_NOATIME
argument_list|)
block|{
name|MNTTAB_OPT_NOATIME
block|,
name|MNT2_GEN_OPT_NOATIME
block|}
block|,
endif|#
directive|endif
comment|/* defined(MNT2_GEN_OPT_NOATIME)&& defined(MNTTAB_OPT_NOATIME) */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_GEN_OPT_NODEVMTIME
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_NODEVMTIME
argument_list|)
block|{
name|MNTTAB_OPT_NODEVMTIME
block|,
name|MNT2_GEN_OPT_NODEVMTIME
block|}
block|,
endif|#
directive|endif
comment|/* defined(MNT2_GEN_OPT_NODEVMTIME)&& defined(MNTTAB_OPT_NODEVMTIME) */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_GEN_OPT_SOFTDEP
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_SOFTDEP
argument_list|)
block|{
name|MNTTAB_OPT_SOFTDEP
block|,
name|MNT2_GEN_OPT_SOFTDEP
block|}
block|,
endif|#
directive|endif
comment|/* defined(MNT2_GEN_OPT_SOFTDEP)&& defined(MNTTAB_OPT_SOFTDEP) */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_GEN_OPT_SYMPERM
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_SYMPERM
argument_list|)
block|{
name|MNTTAB_OPT_SYMPERM
block|,
name|MNT2_GEN_OPT_SYMPERM
block|}
block|,
endif|#
directive|endif
comment|/* defined(MNT2_GEN_OPT_SYMPERM)&& defined(MNTTAB_OPT_SYMPERM) */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_GEN_OPT_UNION
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_UNION
argument_list|)
block|{
name|MNTTAB_OPT_UNION
block|,
name|MNT2_GEN_OPT_UNION
block|}
block|,
endif|#
directive|endif
comment|/* defined(MNT2_GEN_OPT_UNION)&& defined(MNTTAB_OPT_UNION) */
comment|/*    * Do not define MNT2_NFS_OPT_* entries here!  This is for generic    * mount(2) options only, not for NFS mount options.  If you need to put    * something here, it's probably not the right place: see    * include/am_compat.h.    */
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* compute generic mount flags */
end_comment

begin_function
name|int
name|compute_mount_flags
parameter_list|(
name|mntent_t
modifier|*
name|mntp
parameter_list|)
block|{
name|struct
name|opt_tab
modifier|*
name|opt
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|MNT2_GEN_OPT_NEWTYPE
name|flags
operator||=
name|MNT2_GEN_OPT_NEWTYPE
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_GEN_OPT_NEWTYPE */
ifdef|#
directive|ifdef
name|MNT2_GEN_OPT_AUTOMOUNTED
name|flags
operator||=
name|MNT2_GEN_OPT_AUTOMOUNTED
expr_stmt|;
endif|#
directive|endif
comment|/* not MNT2_GEN_OPT_AUTOMOUNTED */
comment|/*    * Crack basic mount options    */
for|for
control|(
name|opt
operator|=
name|mnt_flags
init|;
name|opt
operator|->
name|opt
condition|;
name|opt
operator|++
control|)
block|{
name|flags
operator||=
name|amu_hasmntopt
argument_list|(
name|mntp
argument_list|,
name|opt
operator|->
name|opt
argument_list|)
condition|?
name|opt
operator|->
name|flag
else|:
literal|0
expr_stmt|;
block|}
return|return
name|flags
return|;
block|}
end_function

begin_comment
comment|/* compute generic mount flags for automounter mounts */
end_comment

begin_function
name|int
name|compute_automounter_mount_flags
parameter_list|(
name|mntent_t
modifier|*
name|mntp
parameter_list|)
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|MNT2_GEN_OPT_IGNORE
name|flags
operator||=
name|MNT2_GEN_OPT_IGNORE
expr_stmt|;
endif|#
directive|endif
comment|/* not MNT2_GEN_OPT_IGNORE */
ifdef|#
directive|ifdef
name|MNT2_GEN_OPT_AUTOMNTFS
name|flags
operator||=
name|MNT2_GEN_OPT_AUTOMNTFS
expr_stmt|;
endif|#
directive|endif
comment|/* not MNT2_GEN_OPT_AUTOMNTFS */
return|return
name|flags
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MOUNT_TABLE_ON_FILE
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_VERS
argument_list|)
end_if

begin_comment
comment|/*  * add the extra vers={2,3} field to the mount table,  * unless already specified by user  */
end_comment

begin_function
specifier|static
name|void
name|addvers
parameter_list|(
name|char
modifier|*
name|zopts
parameter_list|,
name|size_t
name|l
parameter_list|,
name|mntent_t
modifier|*
name|mnt
parameter_list|,
name|u_long
name|have_vers
parameter_list|,
name|u_long
name|want_vers
parameter_list|)
block|{
if|if
condition|(
name|have_vers
operator|==
name|want_vers
operator|&&
name|hasmntval
argument_list|(
name|mnt
argument_list|,
name|MNTTAB_OPT_VERS
argument_list|)
operator|!=
name|want_vers
condition|)
block|{
name|char
name|optsbuf
index|[
literal|48
index|]
decl_stmt|;
name|xsnprintf
argument_list|(
name|optsbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|optsbuf
argument_list|)
argument_list|,
literal|"%s=%d"
argument_list|,
name|MNTTAB_OPT_VERS
argument_list|,
name|want_vers
argument_list|)
expr_stmt|;
name|append_opts
argument_list|(
name|zopts
argument_list|,
name|l
argument_list|,
name|optsbuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MOUNT_TABLE_ON_FILE&& MNTTAB_OPT_VERS */
end_comment

begin_function
name|int
name|mount_fs
parameter_list|(
name|mntent_t
modifier|*
name|mnt
parameter_list|,
name|int
name|flags
parameter_list|,
name|caddr_t
name|mnt_data
parameter_list|,
name|int
name|retry
parameter_list|,
name|MTYPE_TYPE
name|type
parameter_list|,
name|u_long
name|nfs_version
parameter_list|,
specifier|const
name|char
modifier|*
name|nfs_proto
parameter_list|,
specifier|const
name|char
modifier|*
name|mnttabname
parameter_list|,
name|int
name|on_autofs
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|MOUNT_TABLE_ON_FILE
name|char
modifier|*
name|zopts
init|=
name|NULL
decl_stmt|,
modifier|*
name|xopts
init|=
name|NULL
decl_stmt|;
name|size_t
name|l
decl_stmt|;
endif|#
directive|endif
comment|/* MOUNT_TABLE_ON_FILE */
name|char
modifier|*
name|mnt_dir
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|NEED_AUTOFS_SPACE_HACK
name|char
modifier|*
name|old_mnt_dir
init|=
name|NULL
decl_stmt|;
comment|/* perform space hack */
if|if
condition|(
name|on_autofs
condition|)
block|{
name|old_mnt_dir
operator|=
name|mnt
operator|->
name|mnt_dir
expr_stmt|;
name|mnt
operator|->
name|mnt_dir
operator|=
name|mnt_dir
operator|=
name|autofs_strdup_space_hack
argument_list|(
name|old_mnt_dir
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* NEED_AUTOFS_SPACE_HACK */
name|mnt_dir
operator|=
name|xstrdup
argument_list|(
name|mnt
operator|->
name|mnt_dir
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
literal|"'%s' fstype "
name|MTYPE_PRINTF_TYPE
literal|" (%s) flags %#x (%s)"
argument_list|,
name|mnt_dir
argument_list|,
name|type
argument_list|,
name|mnt
operator|->
name|mnt_type
argument_list|,
name|flags
argument_list|,
name|mnt
operator|->
name|mnt_opts
argument_list|)
expr_stmt|;
name|again
label|:
name|error
operator|=
name|MOUNT_TRAP
argument_list|(
name|type
argument_list|,
name|mnt
argument_list|,
name|flags
argument_list|,
name|mnt_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|<
literal|0
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"'%s': mount: %m"
argument_list|,
name|mnt_dir
argument_list|)
expr_stmt|;
comment|/*      * The following code handles conditions which shouldn't      * occur.  They are possible either because amd screws up      * in preparing for the mount, or because some human      * messed with the mount point.  Both have been known to      * happen. -- stolcke 2/22/95      */
if|if
condition|(
name|errno
operator|==
name|EBUSY
condition|)
block|{
comment|/*        * Also, sometimes unmount isn't called, e.g., because        * our mountlist is garbled.  This leaves old mount        * points around which need to be removed before we        * can mount something new in their place.        */
name|errno
operator|=
name|umount_fs
argument_list|(
name|mnt_dir
argument_list|,
name|mnttabname
argument_list|,
name|on_autofs
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"'%s': umount: %m"
argument_list|,
name|mnt_dir
argument_list|)
expr_stmt|;
else|else
block|{
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"extra umount required for '%s'"
argument_list|,
name|mnt_dir
argument_list|)
expr_stmt|;
name|error
operator|=
name|MOUNT_TRAP
argument_list|(
name|type
argument_list|,
name|mnt
argument_list|,
name|flags
argument_list|,
name|mnt_data
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|error
operator|<
literal|0
operator|&&
operator|--
name|retry
operator|>
literal|0
condition|)
block|{
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
ifdef|#
directive|ifdef
name|NEED_AUTOFS_SPACE_HACK
comment|/* Undo space hack */
if|if
condition|(
name|on_autofs
condition|)
name|mnt
operator|->
name|mnt_dir
operator|=
name|old_mnt_dir
expr_stmt|;
endif|#
directive|endif
comment|/* NEED_AUTOFS_SPACE_HACK */
if|if
condition|(
name|error
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|MOUNT_TABLE_ON_FILE
comment|/*    * Allocate memory for options:    *        dev=..., vers={2,3}, proto={tcp,udp}    */
name|l
operator|=
name|strlen
argument_list|(
name|mnt
operator|->
name|mnt_opts
argument_list|)
operator|+
literal|48
expr_stmt|;
name|zopts
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|/* copy standard options */
name|xopts
operator|=
name|mnt
operator|->
name|mnt_opts
expr_stmt|;
name|xstrlcpy
argument_list|(
name|zopts
argument_list|,
name|xopts
argument_list|,
name|l
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MNTTAB_OPT_DEV
block|{
comment|/* add the extra dev= field to the mount table */
name|struct
name|stat
name|stb
decl_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|mnt_dir
argument_list|,
operator|&
name|stb
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|optsbuf
index|[
literal|48
index|]
decl_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|stb
operator|.
name|st_dev
argument_list|)
operator|==
literal|2
condition|)
comment|/* e.g. SunOS 4.1 */
name|xsnprintf
argument_list|(
name|optsbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|optsbuf
argument_list|)
argument_list|,
literal|"%s=%04lx"
argument_list|,
name|MNTTAB_OPT_DEV
argument_list|,
operator|(
name|u_long
operator|)
name|stb
operator|.
name|st_dev
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
else|else
comment|/* e.g. System Vr4 */
name|xsnprintf
argument_list|(
name|optsbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|optsbuf
argument_list|)
argument_list|,
literal|"%s=%08lx"
argument_list|,
name|MNTTAB_OPT_DEV
argument_list|,
operator|(
name|u_long
operator|)
name|stb
operator|.
name|st_dev
argument_list|)
expr_stmt|;
name|append_opts
argument_list|(
name|zopts
argument_list|,
name|l
argument_list|,
name|optsbuf
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* MNTTAB_OPT_DEV */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_FS_NFS4
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_VERS
argument_list|)
name|addvers
argument_list|(
name|zopts
argument_list|,
name|l
argument_list|,
name|mnt
argument_list|,
name|nfs_version
argument_list|,
name|NFS_VERSION4
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(HAVE_FS_NFS4)&& defined(MNTTAB_OPT_VERS) */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_FS_NFS3
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_VERS
argument_list|)
name|addvers
argument_list|(
name|zopts
argument_list|,
name|l
argument_list|,
name|mnt
argument_list|,
name|nfs_version
argument_list|,
name|NFS_VERSION3
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(HAVE_FS_NFS3)&& defined(MNTTAB_OPT_VERS) */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_VERS
name|addvers
argument_list|(
name|zopts
argument_list|,
name|l
argument_list|,
name|mnt
argument_list|,
name|nfs_version
argument_list|,
name|NFS_VERSION2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_OPT_VERS */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_PROTO
comment|/*    * add the extra proto={tcp,udp} field to the mount table,    * unless already specified by user.    */
if|if
condition|(
name|nfs_proto
operator|&&
operator|!
name|amu_hasmntopt
argument_list|(
name|mnt
argument_list|,
name|MNTTAB_OPT_PROTO
argument_list|)
condition|)
block|{
name|char
name|optsbuf
index|[
literal|48
index|]
decl_stmt|;
name|xsnprintf
argument_list|(
name|optsbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|optsbuf
argument_list|)
argument_list|,
literal|"%s=%s"
argument_list|,
name|MNTTAB_OPT_PROTO
argument_list|,
name|nfs_proto
argument_list|)
expr_stmt|;
name|append_opts
argument_list|(
name|zopts
argument_list|,
name|l
argument_list|,
name|optsbuf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MNTTAB_OPT_PROTO */
comment|/* finally, store the options into the mount table structure */
name|mnt
operator|->
name|mnt_opts
operator|=
name|zopts
expr_stmt|;
comment|/*    * Additional fields in mntent_t    * are fixed up here    */
ifdef|#
directive|ifdef
name|HAVE_MNTENT_T_MNT_CNODE
name|mnt
operator|->
name|mnt_cnode
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_MNTENT_T_MNT_CNODE */
ifdef|#
directive|ifdef
name|HAVE_MNTENT_T_MNT_RO
name|mnt
operator|->
name|mnt_ro
operator|=
operator|(
name|amu_hasmntopt
argument_list|(
name|mnt
argument_list|,
name|MNTTAB_OPT_RO
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_MNTENT_T_MNT_RO */
ifdef|#
directive|ifdef
name|HAVE_MNTENT_T_MNT_TIME
ifdef|#
directive|ifdef
name|HAVE_MNTENT_T_MNT_TIME_STRING
block|{
comment|/* allocate enough space for a long */
name|size_t
name|l
init|=
literal|13
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
decl_stmt|;
name|char
modifier|*
name|str
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|l
argument_list|)
decl_stmt|;
name|xsnprintf
argument_list|(
name|str
argument_list|,
name|l
argument_list|,
literal|"%ld"
argument_list|,
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|mnt
operator|->
name|mnt_time
operator|=
name|str
expr_stmt|;
block|}
else|#
directive|else
comment|/* not HAVE_MNTENT_T_MNT_TIME_STRING */
name|mnt
operator|->
name|mnt_time
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_MNTENT_T_MNT_TIME_STRING */
endif|#
directive|endif
comment|/* HAVE_MNTENT_T_MNT_TIME */
name|write_mntent
argument_list|(
name|mnt
argument_list|,
name|mnttabname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MNTTAB_OPT_DEV
if|if
condition|(
name|xopts
condition|)
block|{
name|XFREE
argument_list|(
name|mnt
operator|->
name|mnt_opts
argument_list|)
expr_stmt|;
name|mnt
operator|->
name|mnt_opts
operator|=
name|xopts
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MNTTAB_OPT_DEV */
endif|#
directive|endif
comment|/* MOUNT_TABLE_ON_FILE */
name|out
label|:
name|XFREE
argument_list|(
name|mnt_dir
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Compute all NFS attribute cache related flags separately.  Note that this  * function now computes attribute-cache flags for both Amd's automount  * points (NFS) as well as any normal NFS mount that Amd performs.  Edit  * with caution.  */
end_comment

begin_function
specifier|static
name|void
name|compute_nfs_attrcache_flags
parameter_list|(
name|struct
name|nfs_common_args
modifier|*
name|nap
parameter_list|,
name|mntent_t
modifier|*
name|mntp
parameter_list|)
block|{
name|int
name|acval
init|=
literal|0
decl_stmt|;
name|int
name|err_acval
init|=
literal|1
decl_stmt|;
comment|/* 1 means we found no 'actimeo' value */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_NFS_ARGS_T_ACREGMIN
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_NFS_ARGS_T_ACREGMAX
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_NFS_ARGS_T_ACDIRMIN
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_NFS_ARGS_T_ACDIRMAX
argument_list|)
name|int
name|err_acrdmm
decl_stmt|;
comment|/* for ac{reg,dir}{min,max} */
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_AC{REG,DIR}{MIN,MAX} */
comment|/************************************************************************/
comment|/***	ATTRIBUTE CACHES						***/
comment|/************************************************************************/
comment|/*    * acval is set to 0 at the top of the function.  If actimeo mount option    * exists and defined in mntopts, then its acval is set to it.    * If the value is non-zero, then we set all attribute cache fields to it.    * If acval is zero, it means it was never defined in mntopts or the    * actimeo mount option does not exist, in which case we check for    * individual mount options per attribute cache.    * Regardless of the value of acval, mount flags are set based directly    * on the values of the attribute caches.    */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_ACTIMEO
name|err_acval
operator|=
name|hasmntvalerr
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_ACTIMEO
argument_list|,
operator|&
name|acval
argument_list|)
expr_stmt|;
comment|/* attr cache timeout (sec) */
endif|#
directive|endif
comment|/* MNTTAB_OPT_ACTIMEO */
comment|/*** acregmin ***/
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_ACREGMIN
name|err_acrdmm
operator|=
literal|1
expr_stmt|;
comment|/* 1 means we found no acregmin value */
if|if
condition|(
operator|!
name|err_acval
condition|)
block|{
name|nap
operator|->
name|acregmin
operator|=
name|acval
expr_stmt|;
comment|/* min ac timeout for reg files (sec) */
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MNTTAB_OPT_ACREGMIN
name|int
name|tmp
decl_stmt|;
name|err_acrdmm
operator|=
name|hasmntvalerr
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_ACREGMIN
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|nap
operator|->
name|acregmin
operator|=
name|tmp
expr_stmt|;
else|#
directive|else
comment|/* not MNTTAB_OPT_ACREGMIN */
name|nap
operator|->
name|acregmin
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* not MNTTAB_OPT_ACREGMIN */
block|}
comment|/* set this flag iff we changed acregmin (possibly to zero) */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_ACREGMIN
if|if
condition|(
operator|!
name|err_acval
operator|||
operator|!
name|err_acrdmm
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_ACREGMIN
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_ACREGMIN */
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_ACREGMIN */
comment|/*** acregmax ***/
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_ACREGMAX
name|err_acrdmm
operator|=
literal|1
expr_stmt|;
comment|/* 1 means we found no acregmax value */
if|if
condition|(
operator|!
name|err_acval
condition|)
block|{
name|nap
operator|->
name|acregmax
operator|=
name|acval
expr_stmt|;
comment|/* max ac timeout for reg files (sec) */
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MNTTAB_OPT_ACREGMAX
name|int
name|tmp
decl_stmt|;
name|err_acrdmm
operator|=
name|hasmntvalerr
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_ACREGMAX
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|nap
operator|->
name|acregmax
operator|=
name|tmp
expr_stmt|;
else|#
directive|else
comment|/* not MNTTAB_OPT_ACREGMAX */
name|nap
operator|->
name|acregmax
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* not MNTTAB_OPT_ACREGMAX */
block|}
comment|/* set this flag iff we changed acregmax (possibly to zero) */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_ACREGMAX
if|if
condition|(
operator|!
name|err_acval
operator|||
operator|!
name|err_acrdmm
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_ACREGMAX
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_ACREGMAX */
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_ACREGMAX */
comment|/*** acdirmin ***/
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_ACDIRMIN
name|err_acrdmm
operator|=
literal|1
expr_stmt|;
comment|/* 1 means we found no acdirmin value */
if|if
condition|(
operator|!
name|err_acval
condition|)
block|{
name|nap
operator|->
name|acdirmin
operator|=
name|acval
expr_stmt|;
comment|/* min ac timeout for dirs (sec) */
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MNTTAB_OPT_ACDIRMIN
name|int
name|tmp
decl_stmt|;
name|err_acrdmm
operator|=
name|hasmntvalerr
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_ACDIRMIN
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|nap
operator|->
name|acdirmin
operator|=
name|tmp
expr_stmt|;
else|#
directive|else
comment|/* not MNTTAB_OPT_ACDIRMIN */
name|nap
operator|->
name|acdirmin
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* not MNTTAB_OPT_ACDIRMIN */
block|}
comment|/* set this flag iff we changed acdirmin (possibly to zero) */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_ACDIRMIN
if|if
condition|(
operator|!
name|err_acval
operator|||
operator|!
name|err_acrdmm
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_ACDIRMIN
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_ACDIRMIN */
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_ACDIRMIN */
comment|/*** acdirmax ***/
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_ACDIRMAX
name|err_acrdmm
operator|=
literal|1
expr_stmt|;
comment|/* 1 means we found no acdirmax value */
if|if
condition|(
operator|!
name|err_acval
condition|)
block|{
name|nap
operator|->
name|acdirmax
operator|=
name|acval
expr_stmt|;
comment|/* max ac timeout for dirs (sec) */
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MNTTAB_OPT_ACDIRMAX
name|int
name|tmp
decl_stmt|;
name|err_acrdmm
operator|=
name|hasmntvalerr
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_ACDIRMAX
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|nap
operator|->
name|acdirmax
operator|=
name|tmp
expr_stmt|;
else|#
directive|else
comment|/* not MNTTAB_OPT_ACDIRMAX */
name|nap
operator|->
name|acdirmax
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* not MNTTAB_OPT_ACDIRMAX */
block|}
comment|/* set this flag iff we changed acdirmax (possibly to zero) */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_ACDIRMAX
if|if
condition|(
operator|!
name|err_acval
operator|||
operator|!
name|err_acrdmm
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_ACDIRMAX
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_ACDIRMAX */
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_ACDIRMAX */
comment|/* don't cache attributes */
if|#
directive|if
name|defined
argument_list|(
name|MNTTAB_OPT_NOAC
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNT2_NFS_OPT_NOAC
argument_list|)
if|if
condition|(
name|amu_hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_NOAC
argument_list|)
operator|!=
name|NULL
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_NOAC
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MNTTAB_OPT_NOAC)&& defined(MNT2_NFS_OPT_NOAC) */
block|}
end_function

begin_function
specifier|static
name|void
name|compute_nfs_common_args
parameter_list|(
name|struct
name|nfs_common_args
modifier|*
name|nap
parameter_list|,
name|mntent_t
modifier|*
name|mntp
parameter_list|,
specifier|const
name|char
modifier|*
name|nfs_proto
parameter_list|,
name|u_long
name|nfs_version
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_TCP
if|if
condition|(
name|nfs_proto
operator|&&
name|STREQ
argument_list|(
name|nfs_proto
argument_list|,
literal|"tcp"
argument_list|)
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_TCP
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_TCP */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_NOCONN
comment|/* check if user specified to use unconnected or connected sockets */
if|if
condition|(
name|amu_hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_NOCONN
argument_list|)
operator|!=
name|NULL
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_NOCONN
expr_stmt|;
elseif|else
if|if
condition|(
name|amu_hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_CONN
argument_list|)
operator|!=
name|NULL
condition|)
name|nap
operator|->
name|flags
operator|&=
operator|~
name|MNT2_NFS_OPT_NOCONN
expr_stmt|;
else|else
block|{
comment|/*      * Some OSs want you to set noconn always.  Some want you to always turn      * it off.  Others want you to turn it on/off only if NFS V.3 is used.      * And all of that changes from revision to another.  This is      * particularly true of OpenBSD, NetBSD, and FreeBSD.  So, rather than      * attempt to auto-detect this, I'm forced to "fix" it in the individual      * conf/nfs_prot/nfs_prot_*.h files.      */
ifdef|#
directive|ifdef
name|USE_UNCONNECTED_NFS_SOCKETS
if|if
condition|(
operator|!
operator|(
name|nap
operator|->
name|flags
operator|&
name|MNT2_NFS_OPT_NOCONN
operator|)
condition|)
block|{
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_NOCONN
expr_stmt|;
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"noconn option not specified, and was just turned ON (OS override)! (May cause NFS hangs on some systems...)"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_UNCONNECTED_NFS_SOCKETS */
ifdef|#
directive|ifdef
name|USE_CONNECTED_NFS_SOCKETS
if|if
condition|(
name|nap
operator|->
name|flags
operator|&
name|MNT2_NFS_OPT_NOCONN
condition|)
block|{
name|nap
operator|->
name|flags
operator|&=
operator|~
name|MNT2_NFS_OPT_NOCONN
expr_stmt|;
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"noconn option specified, and was just turned OFF (OS override)! (May cause NFS hangs on some systems...)"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_CONNECTED_NFS_SOCKETS */
block|}
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_NOCONN */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_RESVPORT
ifdef|#
directive|ifdef
name|MNTTAB_OPT_RESVPORT
if|if
condition|(
name|amu_hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_RESVPORT
argument_list|)
operator|!=
name|NULL
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_RESVPORT
expr_stmt|;
else|#
directive|else
comment|/* not MNTTAB_OPT_RESVPORT */
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_RESVPORT
expr_stmt|;
endif|#
directive|endif
comment|/* not MNTTAB_OPT_RESVPORT */
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_RESVPORT */
name|nap
operator|->
name|rsize
operator|=
name|hasmntval
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_RSIZE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_RSIZE
if|if
condition|(
name|nap
operator|->
name|rsize
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_RSIZE
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_RSIZE */
if|if
condition|(
name|nfs_version
operator|==
name|NFS_VERSION
operator|&&
name|nap
operator|->
name|rsize
operator|>
literal|8192
condition|)
name|nap
operator|->
name|rsize
operator|=
literal|8192
expr_stmt|;
name|nap
operator|->
name|wsize
operator|=
name|hasmntval
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_WSIZE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_WSIZE
if|if
condition|(
name|nap
operator|->
name|wsize
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_WSIZE
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_WSIZE */
if|if
condition|(
name|nfs_version
operator|==
name|NFS_VERSION
operator|&&
name|nap
operator|->
name|wsize
operator|>
literal|8192
condition|)
name|nap
operator|->
name|wsize
operator|=
literal|8192
expr_stmt|;
name|nap
operator|->
name|timeo
operator|=
name|hasmntval
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_TIMEO
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_TIMEO
if|if
condition|(
name|nap
operator|->
name|timeo
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_TIMEO
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_TIMEO */
name|nap
operator|->
name|retrans
operator|=
name|hasmntval
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_RETRANS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_RETRANS
if|if
condition|(
name|nap
operator|->
name|retrans
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_RETRANS
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_RETRANS */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_SOFT
if|if
condition|(
name|amu_hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_SOFT
argument_list|)
operator|!=
name|NULL
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_SOFT
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_SOFT */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_SPONGY
if|if
condition|(
name|amu_hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_SPONGY
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_SPONGY
expr_stmt|;
if|if
condition|(
operator|*
name|flags
operator|&
name|MNT2_NFS_OPT_SOFT
condition|)
block|{
name|plog
argument_list|(
name|XLOG_USER
argument_list|,
literal|"Mount opts soft and spongy are incompatible - soft ignored"
argument_list|)
expr_stmt|;
name|nap
operator|->
name|flags
operator|&=
operator|~
name|MNT2_NFS_OPT_SOFT
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_SPONGY */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_GEN_OPT_RONLY
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNT2_NFS_OPT_RONLY
argument_list|)
comment|/* Ultrix has separate generic and NFS ro flags */
if|if
condition|(
name|genflags
operator|&
name|MNT2_GEN_OPT_RONLY
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_RONLY
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MNT2_GEN_OPT_RONLY)&& defined(MNT2_NFS_OPT_RONLY) */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_INTR
if|if
condition|(
name|amu_hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_INTR
argument_list|)
operator|!=
name|NULL
condition|)
comment|/*      * Either turn on the "allow interrupts" option, or      * turn off the "disallow interrupts" option"      */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_INTR
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_INTR
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_INTR */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_NOINTR
name|nap
operator|->
name|flags
operator|&=
operator|~
name|MNT2_NFS_OPT_NOINTR
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_NOINTR */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_INT
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_INT
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_INT */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_NOINT
name|nap
operator|->
name|flags
operator|&=
operator|~
name|MNT2_NFS_OPT_NOINT
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_NOINT */
endif|#
directive|endif
comment|/* MNTTAB_OPT_INTR */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_NOACL
if|if
condition|(
name|amu_hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_NOACL
argument_list|)
operator|!=
name|NULL
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_NOACL
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_NOACL */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_NODEVS
if|if
condition|(
name|amu_hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_NODEVS
argument_list|)
operator|!=
name|NULL
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_NODEVS
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_OPT_NODEVS */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_COMPRESS
if|if
condition|(
name|amu_hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_COMPRESS
argument_list|)
operator|!=
name|NULL
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_COMPRESS
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_OPT_COMPRESS */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_PRIVATE
comment|/* mount private, single-client tree */
if|if
condition|(
name|amu_hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_PRIVATE
argument_list|)
operator|!=
name|NULL
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_PRIVATE
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_OPT_PRIVATE */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_NFS_OPT_NOCTO
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_NOCTO
argument_list|)
if|if
condition|(
name|amu_hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_NOCTO
argument_list|)
operator|!=
name|NULL
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_NOCTO
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MNT2_NFS_OPT_NOCTO)&& defined(MNTTAB_OPT_NOCTO) */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_NFS_OPT_PROPLIST
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_PROPLIST
argument_list|)
if|if
condition|(
name|amu_hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_PROPLIST
argument_list|)
operator|!=
name|NULL
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_PROPLIST
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MNT2_NFS_OPT_PROPLIST)&& defined(MNTTAB_OPT_PROPLIST) */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_NFS_OPT_NONLM
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_NOLOCK
argument_list|)
if|if
condition|(
name|amu_hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_NOLOCK
argument_list|)
operator|!=
name|NULL
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_NONLM
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MNT2_NFS_OPT_NONLM)&& defined(MNTTAB_OPT_NOLOCK) */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_NFS_OPT_XLATECOOKIE
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_XLATECOOKIE
argument_list|)
if|if
condition|(
name|amu_hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_XLATECOOKIE
argument_list|)
operator|!=
name|NULL
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_XLATECOOKIE
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MNT2_NFS_OPT_XLATECOOKIE)&& defined(MNTTAB_OPT_XLATECOOKIE) */
block|}
end_function

begin_function
specifier|static
name|void
name|print_nfs_common_args
parameter_list|(
specifier|const
name|struct
name|nfs_common_args
modifier|*
name|a
parameter_list|)
block|{
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->flags = 0x%lx"
argument_list|,
name|a
operator|->
name|flags
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->rsize = %lu"
argument_list|,
name|a
operator|->
name|rsize
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->wsize = %lu"
argument_list|,
name|a
operator|->
name|wsize
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->timeo = %lu"
argument_list|,
name|a
operator|->
name|timeo
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->retrans = %lu"
argument_list|,
name|a
operator|->
name|retrans
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_ACREGMIN
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->acregmin = %lu"
argument_list|,
name|a
operator|->
name|acregmin
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->acregmax = %lu"
argument_list|,
name|a
operator|->
name|acregmax
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->acdirmin = %lu"
argument_list|,
name|a
operator|->
name|acdirmin
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->acdirmax = %lu"
argument_list|,
name|a
operator|->
name|acdirmax
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_ACREGMIN */
block|}
end_function

begin_function
specifier|static
name|void
name|discard_nfs23_args
parameter_list|(
name|nfs_args_t
modifier|*
name|nap
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TRANSPORT_TYPE_TLI
name|free_knetconfig
argument_list|(
name|nap
operator|->
name|knconf
argument_list|)
expr_stmt|;
if|if
condition|(
name|nap
operator|->
name|addr
condition|)
name|XFREE
argument_list|(
name|nap
operator|->
name|addr
argument_list|)
expr_stmt|;
comment|/* allocated in compute_nfs_args() */
endif|#
directive|endif
comment|/* HAVE_TRANSPORT_TYPE_TLI */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/* get string version (in hex) of identifier */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_hex_string
parameter_list|(
name|u_int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|fhdata
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
specifier|static
name|u_int
name|xlen
decl_stmt|;
specifier|static
name|char
modifier|*
name|buf
decl_stmt|;
specifier|static
name|u_short
modifier|*
name|arr
decl_stmt|;
name|char
name|str
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|fhdata
operator|||
name|len
operator|==
literal|0
operator|||
name|len
operator|>
literal|10240
condition|)
return|return
name|NULL
return|;
name|i
operator|=
name|len
operator|*
literal|4
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|xlen
operator|<
name|i
condition|)
block|{
name|buf
operator|=
name|xrealloc
argument_list|(
name|buf
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|arr
operator|=
name|xrealloc
argument_list|(
name|arr
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|arr
argument_list|)
argument_list|)
expr_stmt|;
name|xlen
operator|=
name|i
expr_stmt|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|memset
argument_list|(
name|arr
argument_list|,
literal|0
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|arr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|arr
argument_list|,
name|fhdata
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|/=
sizeof|sizeof
argument_list|(
operator|*
name|arr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|xsnprintf
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|"%04x"
argument_list|,
name|ntohs
argument_list|(
name|arr
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|xstrlcat
argument_list|(
name|buf
argument_list|,
name|str
argument_list|,
name|xlen
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_nfs_sockaddr_in
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
specifier|const
name|struct
name|sockaddr_in
modifier|*
name|sap
parameter_list|)
block|{
name|char
name|name
index|[
literal|64
index|]
decl_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->%s.sin_family = %d"
argument_list|,
name|tag
argument_list|,
name|sap
operator|->
name|sin_family
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->%s.sin_port = %d"
argument_list|,
name|tag
argument_list|,
name|ntohs
argument_list|(
name|sap
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inet_ntop
argument_list|(
name|AF_INET
argument_list|,
operator|&
name|sap
operator|->
name|sin_addr
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
return|return;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->%s.sin_addr = \"%s\""
argument_list|,
name|tag
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * print a subset of fields from "struct nfs_args" that are otherwise  * not being provided anywhere else.  */
end_comment

begin_function
specifier|static
name|void
name|print_nfs23_args
parameter_list|(
specifier|const
name|nfs_args_t
modifier|*
name|nap
parameter_list|,
name|u_long
name|nfs_version
parameter_list|)
block|{
name|int
name|fhlen
init|=
literal|32
decl_stmt|;
comment|/* default: NFS V.2 file handle length is 32 */
ifdef|#
directive|ifdef
name|HAVE_TRANSPORT_TYPE_TLI
name|struct
name|netbuf
modifier|*
name|nbp
decl_stmt|;
name|struct
name|knetconfig
modifier|*
name|kncp
decl_stmt|;
else|#
directive|else
comment|/* not HAVE_TRANSPORT_TYPE_TLI */
name|struct
name|sockaddr_in
modifier|*
name|sap
decl_stmt|;
endif|#
directive|endif
comment|/* not HAVE_TRANSPORT_TYPE_TLI */
name|struct
name|nfs_common_args
name|a
decl_stmt|;
if|if
condition|(
operator|!
name|nap
condition|)
block|{
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NULL nfs_args!"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* override default file handle size */
ifdef|#
directive|ifdef
name|FHSIZE
name|fhlen
operator|=
name|FHSIZE
expr_stmt|;
endif|#
directive|endif
comment|/* FHSIZE */
ifdef|#
directive|ifdef
name|NFS_FHSIZE
name|fhlen
operator|=
name|NFS_FHSIZE
expr_stmt|;
endif|#
directive|endif
comment|/* NFS_FHSIZE */
ifdef|#
directive|ifdef
name|HAVE_TRANSPORT_TYPE_TLI
name|nbp
operator|=
name|nap
operator|->
name|addr
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->addr {netbuf} (maxlen=%d, len=%d) = \"%s\""
argument_list|,
name|nbp
operator|->
name|maxlen
argument_list|,
name|nbp
operator|->
name|len
argument_list|,
name|get_hex_string
argument_list|(
name|nbp
operator|->
name|len
argument_list|,
name|nbp
operator|->
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|nbp
operator|=
name|nap
operator|->
name|syncaddr
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->syncaddr {netbuf} %p"
argument_list|,
name|nbp
argument_list|)
expr_stmt|;
name|kncp
operator|=
name|nap
operator|->
name|knconf
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->knconf->semantics %lu"
argument_list|,
operator|(
name|u_long
operator|)
name|kncp
operator|->
name|knc_semantics
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->knconf->protofmly \"%s\""
argument_list|,
name|kncp
operator|->
name|knc_protofmly
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->knconf->proto \"%s\""
argument_list|,
name|kncp
operator|->
name|knc_proto
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->knconf->rdev %lu"
argument_list|,
operator|(
name|u_long
operator|)
name|kncp
operator|->
name|knc_rdev
argument_list|)
expr_stmt|;
comment|/* don't print knconf->unused field */
else|#
directive|else
comment|/* not HAVE_TRANSPORT_TYPE_TLI */
ifdef|#
directive|ifdef
name|NFS_ARGS_T_ADDR_IS_POINTER
name|sap
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|nap
operator|->
name|addr
expr_stmt|;
else|#
directive|else
comment|/* not NFS_ARGS_T_ADDR_IS_POINTER */
name|sap
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|nap
operator|->
name|addr
expr_stmt|;
endif|#
directive|endif
comment|/* not NFS_ARGS_T_ADDR_IS_POINTER */
ifdef|#
directive|ifdef
name|HAVE_STRUCT_SOCKADDR_SA_LEN
comment|/* as per POSIX, sin_len need not be set (used internally by kernel) */
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->addr.sin_len = %d"
argument_list|,
name|sap
operator|->
name|sin_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_STRUCT_SOCKADDR_SA_LEN */
name|print_nfs_sockaddr_in
argument_list|(
literal|"addr"
argument_list|,
name|sap
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_TRANSPORT_TYPE_TLI */
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_ADDRLEN
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->addrlen = %d"
argument_list|,
name|nap
operator|->
name|addrlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ifdef HAVE_NFS_ARGS_T_ADDRLEN */
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->hostname = \"%s\""
argument_list|,
name|nap
operator|->
name|hostname
condition|?
name|nap
operator|->
name|hostname
else|:
literal|"null"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_NAMLEN
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->namlen = %d"
argument_list|,
name|nap
operator|->
name|namlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_NAMLEN */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_FSNAME
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->fsname = \"%s\""
argument_list|,
name|nap
operator|->
name|fsname
condition|?
name|nap
operator|->
name|fsname
else|:
literal|"null"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_FSNAME */
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_FHSIZE
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->fhsize = %d"
argument_list|,
name|nap
operator|->
name|fhsize
argument_list|)
expr_stmt|;
name|fhlen
operator|=
name|nap
operator|->
name|fhsize
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_FHSIZE */
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_FH_LEN
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->fh_len = %d"
argument_list|,
name|nap
operator|->
name|fh_len
argument_list|)
expr_stmt|;
name|fhlen
operator|=
name|nap
operator|->
name|fh_len
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_FH_LEN */
comment|/*    * XXX: need to figure out how to correctly print file handles,    * since some times they are pointers, and sometimes the real structure    * is stored in nfs_args.  Even if it is a pointer, it can be the actual    * char[] array, or a structure containing multiple fields.    */
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->filehandle = \"%s\""
argument_list|,
name|get_hex_string
argument_list|(
name|fhlen
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|nap
operator|->
name|NFS_FH_FIELD
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_SOTYPE
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->sotype = %d"
argument_list|,
name|nap
operator|->
name|sotype
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_SOTYPE */
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_PROTO
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->proto = %d"
argument_list|,
operator|(
name|int
operator|)
name|nap
operator|->
name|proto
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_PROTO */
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_VERSION
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->version = %d"
argument_list|,
name|nap
operator|->
name|version
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_VERSION */
name|put_nfs_common_args
argument_list|(
name|nap
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|print_nfs_common_args
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_BSIZE
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->bsize = %d"
argument_list|,
name|nap
operator|->
name|bsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_BSIZE */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_SYMTTL
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->symttl = %d"
argument_list|,
name|nap
operator|->
name|symttl
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_OPT_SYMTTL */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_PG_THRESH
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->pg_thresh = %d"
argument_list|,
name|nap
operator|->
name|pg_thresh
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_OPT_PG_THRESH */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_BIODS
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->biods = %d"
argument_list|,
name|nap
operator|->
name|biods
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_BIODS */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*  * Fill in the many possible fields and flags of struct nfs_args.  *  * nap:		pre-allocated structure to fill in.  * mntp:	mount entry structure (includes options)  * genflags:	generic mount flags already determined  * nfsncp:	(TLI only) netconfig entry for this NFS mount  * ip_addr:	IP address of file server  * nfs_version:	2, 3, or 0 if unknown  * nfs_proto:	"udp", "tcp", or NULL.  * fhp:		file handle structure pointer  * host_name:	name of remote NFS host  * fs_name:	remote file system name to mount  */
end_comment

begin_function
specifier|static
name|void
name|compute_nfs23_args
parameter_list|(
name|nfs_args_t
modifier|*
name|nap
parameter_list|,
name|mntent_t
modifier|*
name|mntp
parameter_list|,
name|int
name|genflags
parameter_list|,
name|struct
name|netconfig
modifier|*
name|nfsncp
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|ip_addr
parameter_list|,
name|u_long
name|nfs_version
parameter_list|,
name|char
modifier|*
name|nfs_proto
parameter_list|,
name|am_nfs_handle_t
modifier|*
name|fhp
parameter_list|,
name|char
modifier|*
name|host_name
parameter_list|,
name|char
modifier|*
name|fs_name
parameter_list|)
block|{
name|struct
name|nfs_common_args
name|a
decl_stmt|;
comment|/* initialize just in case */
name|memset
argument_list|(
operator|(
name|voidp
operator|)
name|nap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|nfs_args_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* compute all of the NFS attribute-cache flags */
name|memset
argument_list|(
operator|&
name|a
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|compute_nfs_attrcache_flags
argument_list|(
operator|&
name|a
argument_list|,
name|mntp
argument_list|)
expr_stmt|;
name|compute_nfs_common_args
argument_list|(
operator|&
name|a
argument_list|,
name|mntp
argument_list|,
name|nfs_proto
argument_list|,
name|nfs_version
argument_list|)
expr_stmt|;
name|get_nfs_common_args
argument_list|(
name|nap
argument_list|,
name|a
argument_list|)
expr_stmt|;
comment|/************************************************************************/
comment|/***	FILEHANDLE DATA AND LENGTH					***/
comment|/************************************************************************/
ifdef|#
directive|ifdef
name|HAVE_FS_NFS3
if|if
condition|(
name|nfs_version
operator|==
name|NFS_VERSION3
condition|)
block|{
if|if
condition|(
name|fhp
operator|==
name|NULL
condition|)
block|{
name|plog
argument_list|(
name|XLOG_FATAL
argument_list|,
literal|"cannot pass NULL fh for NFSv%lu"
argument_list|,
name|nfs_version
argument_list|)
expr_stmt|;
name|going_down
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_NFS_ARGS_T_FHSIZE
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_NFS_ARGS_T_FH_LEN
argument_list|)
comment|/*      * Some systems (Irix/bsdi3) have a separate field in nfs_args for      * the length of the file handle for NFS V3.  They insist that      * the file handle set in nfs_args be plain bytes, and not      * include the length field.      */
name|NFS_FH_DREF
argument_list|(
name|nap
operator|->
name|NFS_FH_FIELD
argument_list|,
operator|&
name|fhp
operator|->
name|v3
operator|.
name|am_fh3_data
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not defined(HAVE_NFS_ARGS_T_FHSIZE) || defined(HAVE_NFS_ARGS_T_FH_LEN) */
name|NFS_FH_DREF
argument_list|(
name|nap
operator|->
name|NFS_FH_FIELD
argument_list|,
operator|&
name|fhp
operator|->
name|v3
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not defined(HAVE_NFS_ARGS_T_FHSIZE) || defined(HAVE_NFS_ARGS_T_FH_LEN) */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_NFSV3
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_NFSV3
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_NFSV3 */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_VER3
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_VER3
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_VER3 */
block|}
else|else
endif|#
directive|endif
comment|/* HAVE_FS_NFS3 */
block|{
if|if
condition|(
name|fhp
operator|==
name|NULL
condition|)
block|{
name|plog
argument_list|(
name|XLOG_FATAL
argument_list|,
literal|"cannot pass NULL fh for NFSv%lu"
argument_list|,
name|nfs_version
argument_list|)
expr_stmt|;
name|going_down
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|NFS_FH_DREF
argument_list|(
name|nap
operator|->
name|NFS_FH_FIELD
argument_list|,
operator|&
name|fhp
operator|->
name|v2
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_FHSIZE
ifdef|#
directive|ifdef
name|HAVE_FS_NFS3
if|if
condition|(
name|nfs_version
operator|==
name|NFS_VERSION3
condition|)
name|nap
operator|->
name|fhsize
operator|=
name|fhp
operator|->
name|v3
operator|.
name|am_fh3_length
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* HAVE_FS_NFS3 */
name|nap
operator|->
name|fhsize
operator|=
name|FHSIZE
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_FHSIZE */
comment|/* this is the version of the nfs_args structure, not of NFS! */
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_FH_LEN
ifdef|#
directive|ifdef
name|HAVE_FS_NFS3
if|if
condition|(
name|nfs_version
operator|==
name|NFS_VERSION3
condition|)
name|nap
operator|->
name|fh_len
operator|=
name|fhp
operator|->
name|v3
operator|.
name|am_fh3_length
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* HAVE_FS_NFS3 */
name|nap
operator|->
name|fh_len
operator|=
name|FHSIZE
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_FH_LEN */
comment|/************************************************************************/
comment|/***	HOST NAME							***/
comment|/************************************************************************/
comment|/*    * XXX: warning, using xstrlcpy in NFS_HN_DREF, which may corrupt a    * struct nfs_args, or truncate our concocted "hostname:/path"    * string prematurely.    */
name|NFS_HN_DREF
argument_list|(
name|nap
operator|->
name|hostname
argument_list|,
name|host_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_HOSTNAME
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_HOSTNAME
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_HOSTNAME */
comment|/************************************************************************/
comment|/***	IP ADDRESS OF REMOTE HOST					***/
comment|/************************************************************************/
if|if
condition|(
name|ip_addr
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TRANSPORT_TYPE_TLI
name|nap
operator|->
name|addr
operator|=
name|ALLOC
argument_list|(
expr|struct
name|netbuf
argument_list|)
expr_stmt|;
comment|/* free()'ed at end of mount_nfs_fh() */
endif|#
directive|endif
comment|/* HAVE_TRANSPORT_TYPE_TLI */
name|NFS_SA_DREF
argument_list|(
name|nap
argument_list|,
name|ip_addr
argument_list|)
expr_stmt|;
block|}
comment|/************************************************************************/
comment|/***	NFS PROTOCOL (UDP, TCP) AND VERSION				***/
comment|/************************************************************************/
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_SOTYPE
comment|/* bsdi3 uses this */
if|if
condition|(
name|nfs_proto
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|nfs_proto
argument_list|,
literal|"tcp"
argument_list|)
condition|)
name|nap
operator|->
name|sotype
operator|=
name|SOCK_STREAM
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|nfs_proto
argument_list|,
literal|"udp"
argument_list|)
condition|)
name|nap
operator|->
name|sotype
operator|=
name|SOCK_DGRAM
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_SOTYPE */
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_PROTO
name|nap
operator|->
name|proto
operator|=
literal|0
expr_stmt|;
comment|/* bsdi3 sets this field to zero  */
ifdef|#
directive|ifdef
name|IPPROTO_TCP
if|if
condition|(
name|nfs_proto
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|nfs_proto
argument_list|,
literal|"tcp"
argument_list|)
condition|)
comment|/* AIX 4.2.x needs this */
name|nap
operator|->
name|proto
operator|=
name|IPPROTO_TCP
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|nfs_proto
argument_list|,
literal|"udp"
argument_list|)
condition|)
name|nap
operator|->
name|proto
operator|=
name|IPPROTO_UDP
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IPPROTO_TCP */
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_SOTYPE */
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_VERSION
ifdef|#
directive|ifdef
name|NFS_ARGSVERSION
name|nap
operator|->
name|version
operator|=
name|NFS_ARGSVERSION
expr_stmt|;
comment|/* BSDI 3.0 and OpenBSD 2.2 */
endif|#
directive|endif
comment|/* NFS_ARGSVERSION */
ifdef|#
directive|ifdef
name|DG_MOUNT_NFS_VERSION
name|nap
operator|->
name|version
operator|=
name|DG_MOUNT_NFS_VERSION
expr_stmt|;
comment|/* dg-ux */
endif|#
directive|endif
comment|/* DG_MOUNT_NFS_VERSION */
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_VERSION */
comment|/************************************************************************/
comment|/***	OTHER NFS SOCKET RELATED OPTIONS AND FLAGS			***/
comment|/************************************************************************/
comment|/************************************************************************/
comment|/***	OTHER FLAGS AND OPTIONS						***/
comment|/************************************************************************/
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_BIODS
if|if
condition|(
operator|(
name|nap
operator|->
name|biods
operator|=
name|hasmntval
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_BIODS
argument_list|)
operator|)
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_BIODS
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_BIODS */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_SYMTTL
comment|/* symlink cache time-to-live */
if|if
condition|(
operator|(
name|nap
operator|->
name|symttl
operator|=
name|hasmntval
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_SYMTTL
argument_list|)
operator|)
condition|)
name|nap
operator|->
name|args
operator|.
name|flags
operator||=
name|MNT2_NFS_OPT_SYMTTL
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_OPT_SYMTTL */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_PGTHRESH
comment|/* paging threshold */
if|if
condition|(
operator|(
name|nap
operator|->
name|pg_thresh
operator|=
name|hasmntval
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_PGTHRESH
argument_list|)
operator|)
condition|)
name|nap
operator|->
name|args
operator|.
name|flags
operator||=
name|MNT2_NFS_OPT_PGTHRESH
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_PGTHRESH */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_NFS_OPT_POSIX
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_POSIX
argument_list|)
if|if
condition|(
name|amu_hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_POSIX
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_POSIX
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_PATHCONF
name|nap
operator|->
name|pathconf
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_PATHCONF */
block|}
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_POSIX&& MNTTAB_OPT_POSIX */
ifdef|#
directive|ifdef
name|HAVE_TRANSPORT_TYPE_TLI
comment|/* set up syncaddr field */
name|nap
operator|->
name|syncaddr
operator|=
operator|(
expr|struct
name|netbuf
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* set up knconf field */
if|if
condition|(
name|get_knetconfig
argument_list|(
operator|&
name|nap
operator|->
name|knconf
argument_list|,
name|nfsncp
argument_list|,
name|nfs_proto
argument_list|)
operator|<
literal|0
condition|)
block|{
name|plog
argument_list|(
name|XLOG_FATAL
argument_list|,
literal|"cannot fill knetconfig structure for nfs_args"
argument_list|)
expr_stmt|;
name|going_down
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* update the flags field for knconf */
name|nap
operator|->
name|args
operator|.
name|flags
operator||=
name|MNT2_NFS_OPT_KNCONF
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_TRANSPORT_TYPE_TLI */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_FSNAME
name|nap
operator|->
name|fsname
operator|=
name|fs_name
expr_stmt|;
name|nap
operator|->
name|args
operator|.
name|flags
operator||=
name|MNT2_NFS_OPT_FSNAME
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_FSNAME */
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_OPTSTR
name|nap
operator|->
name|optstr
operator|=
name|mntp
operator|->
name|mnt_opts
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_OPTSTR */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_NFS_OPT_MAXGRPS
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_MAXGROUPS
argument_list|)
name|nap
operator|->
name|maxgrouplist
operator|=
name|hasmntval
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_MAXGROUPS
argument_list|)
expr_stmt|;
if|if
condition|(
name|nap
operator|->
name|maxgrouplist
operator|!=
literal|0
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_MAXGRPS
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MNT2_NFS_OPT_MAXGRPS)&& defined(MNTTAB_OPT_MAXGROUPS) */
comment|/************************************************************************/
comment|/***	FINAL ACTIONS							***/
comment|/************************************************************************/
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_GFS_FLAGS
comment|/* Ultrix stores generic flags in nfs_args.gfs_flags. */
name|nap
operator|->
name|gfs_flags
operator|=
name|genflags
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_FLAGS */
return|return;
comment|/* end of compute_nfs_args() function */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FS_NFS4
end_ifdef

begin_define
define|#
directive|define
name|RPC_AUTH_GSS_KRB5
value|390003
end_define

begin_define
define|#
directive|define
name|RPC_AUTH_GSS_KRB5I
value|390004
end_define

begin_define
define|#
directive|define
name|RPC_AUTH_GSS_KRB5P
value|390005
end_define

begin_define
define|#
directive|define
name|RPC_AUTH_GSS_LKEY
value|390006
end_define

begin_define
define|#
directive|define
name|RPC_AUTH_GSS_LKEYI
value|390007
end_define

begin_define
define|#
directive|define
name|RPC_AUTH_GSS_LKEYP
value|390008
end_define

begin_define
define|#
directive|define
name|RPC_AUTH_GSS_SPKM
value|390009
end_define

begin_define
define|#
directive|define
name|RPC_AUTH_GSS_SPKMI
value|390010
end_define

begin_define
define|#
directive|define
name|RPC_AUTH_GSS_SPKMP
value|390011
end_define

begin_struct
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|num
decl_stmt|;
block|}
name|flavours
index|[]
init|=
block|{
block|{
literal|"unix"
block|,
name|AUTH_UNIX
block|}
block|,
block|{
literal|"krb5"
block|,
name|RPC_AUTH_GSS_KRB5
block|}
block|,
block|{
literal|"krb5i"
block|,
name|RPC_AUTH_GSS_KRB5I
block|}
block|,
block|{
literal|"krb5p"
block|,
name|RPC_AUTH_GSS_KRB5P
block|}
block|,
block|{
literal|"lkey"
block|,
name|RPC_AUTH_GSS_LKEY
block|}
block|,
block|{
literal|"lkeyi"
block|,
name|RPC_AUTH_GSS_LKEYI
block|}
block|,
block|{
literal|"lkeyp"
block|,
name|RPC_AUTH_GSS_LKEYP
block|}
block|,
block|{
literal|"spkm"
block|,
name|RPC_AUTH_GSS_SPKM
block|}
block|,
block|{
literal|"spkmi"
block|,
name|RPC_AUTH_GSS_SPKMI
block|}
block|,
block|{
literal|"spkmp"
block|,
name|RPC_AUTH_GSS_SPKMP
block|}
block|, }
struct|;
end_struct

begin_function
specifier|static
name|char
modifier|*
name|set_nfs4_security
parameter_list|(
name|nfs4_args_t
modifier|*
name|nap
parameter_list|,
name|mntent_t
modifier|*
name|mntp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|o
init|=
name|hasmnteq
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_SEC
argument_list|)
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|ss
decl_stmt|;
name|size_t
name|l
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|o
operator|==
name|NULL
condition|)
name|o
operator|=
literal|"unix"
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|1
operator|,
name|q
operator|=
name|strchr
argument_list|(
name|o
argument_list|,
literal|','
argument_list|)
init|;
name|q
condition|;
name|q
operator|=
name|strchr
argument_list|(
name|q
operator|+
literal|1
argument_list|,
literal|','
argument_list|)
control|)
name|l
operator|++
expr_stmt|;
name|nap
operator|->
name|auth_flavours
operator|=
name|xmalloc
argument_list|(
name|l
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|nap
operator|->
name|auth_flavours
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|ss
operator|=
name|xstrdup
argument_list|(
name|o
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|q
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|flavours
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|flavours
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|flavours
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nap
operator|->
name|auth_flavours
index|[
name|l
operator|++
index|]
operator|=
name|flavours
index|[
name|i
index|]
operator|.
name|num
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
sizeof|sizeof
argument_list|(
name|flavours
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|flavours
index|[
literal|0
index|]
argument_list|)
condition|)
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"Unknown NFSv4 security mechanism %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
break|break;
operator|*
name|q
operator|=
literal|':'
expr_stmt|;
name|s
operator|=
operator|++
name|q
expr_stmt|;
block|}
name|nap
operator|->
name|auth_flavourlen
operator|=
name|l
expr_stmt|;
return|return
name|ss
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_my_ipv4addr
parameter_list|(
name|struct
name|nfs_string
modifier|*
name|ns
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|char
name|myname
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
if|if
condition|(
name|gethostname
argument_list|(
name|myname
argument_list|,
sizeof|sizeof
argument_list|(
name|myname
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|myname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|inet_ntop
argument_list|(
name|AF_INET
argument_list|,
name|hp
operator|->
name|h_addr
argument_list|,
name|myname
argument_list|,
sizeof|sizeof
argument_list|(
name|myname
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|ns
operator|->
name|len
operator|=
name|strlen
argument_list|(
name|myname
argument_list|)
expr_stmt|;
name|ns
operator|->
name|data
operator|=
name|xmalloc
argument_list|(
name|ns
operator|->
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ns
operator|->
name|data
argument_list|,
name|myname
argument_list|,
name|ns
operator|->
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_nfs4_mntopts
parameter_list|(
specifier|const
name|nfs4_args_t
modifier|*
name|nap
parameter_list|,
name|mntent_t
modifier|*
name|mntp
parameter_list|,
name|char
modifier|*
name|sec
parameter_list|)
block|{
name|char
modifier|*
name|opts
init|=
name|mntp
operator|->
name|mnt_opts
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|,
name|addr
index|[
literal|128
index|]
decl_stmt|;
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|mntp
operator|->
name|mnt_opts
argument_list|)
decl_stmt|;
if|if
condition|(
name|inet_ntop
argument_list|(
name|AF_INET
argument_list|,
operator|&
operator|(
operator|(
specifier|const
expr|struct
name|sockaddr_in
operator|*
operator|)
name|nap
operator|->
name|host_addr
operator|)
operator|->
name|sin_addr
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
return|return;
name|xsnprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|",clientaddr=%s,addr=%s"
argument_list|,
name|nap
operator|->
name|client_addr
operator|.
name|data
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|sec
operator|&&
name|strcmp
argument_list|(
name|sec
argument_list|,
literal|"unix"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|len
operator|+=
name|strlen
argument_list|(
name|sec
argument_list|)
operator|+
name|strlen
argument_list|(
name|MNTTAB_OPT_SEC
argument_list|)
operator|+
literal|2
expr_stmt|;
comment|/* 2 = ",=" */
block|}
else|else
name|sec
operator|=
name|NULL
expr_stmt|;
name|opts
operator|=
name|xrealloc
argument_list|(
name|mntp
operator|->
name|mnt_opts
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|xstrlcat
argument_list|(
name|opts
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
condition|)
block|{
name|xstrlcat
argument_list|(
name|opts
argument_list|,
literal|","
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|xstrlcat
argument_list|(
name|opts
argument_list|,
name|MNTTAB_OPT_SEC
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|xstrlcat
argument_list|(
name|opts
argument_list|,
literal|"="
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|xstrlcat
argument_list|(
name|opts
argument_list|,
name|sec
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|mntp
operator|->
name|mnt_opts
operator|=
name|opts
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_nfs4_security
parameter_list|(
specifier|const
name|nfs4_args_t
modifier|*
name|nap
parameter_list|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|num
index|[
literal|64
index|]
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nap
operator|->
name|auth_flavourlen
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|flavours
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|flavours
index|[
literal|0
index|]
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|flavours
index|[
name|j
index|]
operator|.
name|num
operator|==
name|nap
operator|->
name|auth_flavours
index|[
name|i
index|]
condition|)
block|{
name|xstrlcpy
argument_list|(
name|num
argument_list|,
name|flavours
index|[
name|j
index|]
operator|.
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|num
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|j
operator|==
sizeof|sizeof
argument_list|(
name|flavours
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|flavours
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"Unknown NFSv4 security mechanism %d\n"
argument_list|,
name|nap
operator|->
name|auth_flavours
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xsnprintf
argument_list|(
name|num
argument_list|,
sizeof|sizeof
argument_list|(
name|num
argument_list|)
argument_list|,
literal|"*%d*"
argument_list|,
name|nap
operator|->
name|auth_flavours
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buf
index|[
literal|0
index|]
condition|)
name|xstrlcat
argument_list|(
name|buf
argument_list|,
literal|":"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|xstrlcat
argument_list|(
name|buf
argument_list|,
name|num
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->auth_flavours \"%s\"\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|discard_nfs4_args
parameter_list|(
name|nfs4_args_t
modifier|*
name|nap
parameter_list|)
block|{
if|if
condition|(
name|nap
operator|->
name|client_addr
operator|.
name|data
condition|)
name|free
argument_list|(
name|nap
operator|->
name|client_addr
operator|.
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|nap
operator|->
name|hostname
operator|.
name|data
condition|)
name|free
argument_list|(
name|nap
operator|->
name|hostname
operator|.
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|nap
operator|->
name|mnt_path
operator|.
name|data
condition|)
name|free
argument_list|(
name|nap
operator|->
name|mnt_path
operator|.
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|nap
operator|->
name|host_addr
condition|)
name|free
argument_list|(
name|nap
operator|->
name|host_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|nap
operator|->
name|auth_flavours
condition|)
name|free
argument_list|(
name|nap
operator|->
name|auth_flavours
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fill in the many possible fields and flags of struct nfs4_args.  *  * nap:		pre-allocated structure to fill in.  * mntp:	mount entry structure (includes options)  * genflags:	generic mount flags already determined  * nfsncp:	(TLI only) netconfig entry for this NFS mount  * ip_addr:	IP address of file server  * nfs_version:	4, or 0 if unknown  * nfs_proto:	"udp", "tcp", or NULL.  * fhp:		file handle structure pointer  * host_name:	name of remote NFS host  * fs_name:	remote file system name to mount  */
end_comment

begin_function
specifier|static
name|void
name|compute_nfs4_args
parameter_list|(
name|nfs4_args_t
modifier|*
name|nap
parameter_list|,
name|mntent_t
modifier|*
name|mntp
parameter_list|,
name|int
name|genflags
parameter_list|,
name|struct
name|netconfig
modifier|*
name|nfsncp
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|ip_addr
parameter_list|,
name|u_long
name|nfs_version
parameter_list|,
name|char
modifier|*
name|nfs_proto
parameter_list|,
name|am_nfs_handle_t
modifier|*
name|fhp
parameter_list|,
name|char
modifier|*
name|host_name
parameter_list|,
name|char
modifier|*
name|fs_name
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|nfs_common_args
name|a
decl_stmt|;
name|uint16_t
name|nfs_port
decl_stmt|;
comment|/* initialize just in case */
name|memset
argument_list|(
operator|(
name|voidp
operator|)
name|nap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|nfs4_args_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* compute all of the NFS attribute-cache flags */
name|memset
argument_list|(
operator|&
name|a
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|compute_nfs_attrcache_flags
argument_list|(
operator|&
name|a
argument_list|,
name|mntp
argument_list|)
expr_stmt|;
name|compute_nfs_common_args
argument_list|(
operator|&
name|a
argument_list|,
name|mntp
argument_list|,
name|nfs_proto
argument_list|,
name|nfs_version
argument_list|)
expr_stmt|;
name|get_nfs_common_args
argument_list|(
name|nap
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|get_my_ipv4addr
argument_list|(
operator|&
name|nap
operator|->
name|client_addr
argument_list|)
expr_stmt|;
comment|/************************************************************************/
comment|/***	HOST NAME							***/
comment|/************************************************************************/
name|nap
operator|->
name|hostname
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|host_name
argument_list|)
expr_stmt|;
name|nap
operator|->
name|hostname
operator|.
name|data
operator|=
name|xmalloc
argument_list|(
name|nap
operator|->
name|hostname
operator|.
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|nap
operator|->
name|hostname
operator|.
name|data
argument_list|,
name|host_name
argument_list|,
name|nap
operator|->
name|hostname
operator|.
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|strchr
argument_list|(
name|fs_name
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|s
operator|++
expr_stmt|;
else|else
name|s
operator|=
name|fs_name
expr_stmt|;
name|nap
operator|->
name|mnt_path
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|nap
operator|->
name|mnt_path
operator|.
name|data
operator|=
name|xmalloc
argument_list|(
name|nap
operator|->
name|mnt_path
operator|.
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|nap
operator|->
name|mnt_path
operator|.
name|data
argument_list|,
name|s
argument_list|,
name|nap
operator|->
name|mnt_path
operator|.
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"dir name %s\n"
argument_list|,
name|nap
operator|->
name|mnt_path
operator|.
name|data
argument_list|)
expr_stmt|;
comment|/************************************************************************/
comment|/***  IP ADDRESS OF REMOTE HOST                                       ***/
comment|/************************************************************************/
name|nap
operator|->
name|host_addrlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ip_addr
argument_list|)
expr_stmt|;
name|nap
operator|->
name|host_addr
operator|=
name|xmalloc
argument_list|(
name|nap
operator|->
name|host_addrlen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|nap
operator|->
name|host_addr
argument_list|,
name|ip_addr
argument_list|,
name|nap
operator|->
name|host_addrlen
argument_list|)
expr_stmt|;
name|nfs_port
operator|=
name|hasmntval
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfs_port
operator|==
literal|0
condition|)
name|nfs_port
operator|=
name|htons
argument_list|(
name|NFS_PORT
argument_list|)
expr_stmt|;
else|else
name|nfs_port
operator|=
name|htons
argument_list|(
name|nfs_port
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|nap
operator|->
name|host_addr
operator|)
operator|->
name|sin_port
operator|=
name|nfs_port
expr_stmt|;
name|nap
operator|->
name|proto
operator|=
literal|0
expr_stmt|;
comment|/* bsdi3 sets this field to zero  */
if|if
condition|(
name|nfs_proto
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|nfs_proto
argument_list|,
literal|"tcp"
argument_list|)
condition|)
comment|/* AIX 4.2.x needs this */
name|nap
operator|->
name|proto
operator|=
name|IPPROTO_TCP
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|nfs_proto
argument_list|,
literal|"udp"
argument_list|)
condition|)
name|nap
operator|->
name|proto
operator|=
name|IPPROTO_UDP
expr_stmt|;
block|}
name|nap
operator|->
name|version
operator|=
name|NFS4_MOUNT_VERSION
expr_stmt|;
comment|/* BSDI 3.0 and OpenBSD 2.2 */
comment|/************************************************************************/
comment|/***  OTHER NFS SOCKET RELATED OPTIONS AND FLAGS                      ***/
comment|/************************************************************************/
comment|/************************************************************************/
comment|/***  OTHER FLAGS AND OPTIONS                                         ***/
comment|/************************************************************************/
if|#
directive|if
name|defined
argument_list|(
name|MNT2_NFS_OPT_POSIX
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_POSIX
argument_list|)
if|if
condition|(
name|amu_hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_POSIX
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|nap
operator|->
name|args
operator|.
name|flags
operator||=
name|MNT2_NFS_OPT_POSIX
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_PATHCONF
name|nap
operator|->
name|pathconf
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_PATHCONF */
block|}
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_POSIX&& MNTTAB_OPT_POSIX */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_NFS_OPT_MAXGRPS
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_MAXGROUPS
argument_list|)
name|nap
operator|->
name|maxgrouplist
operator|=
name|hasmntval
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_MAXGROUPS
argument_list|)
expr_stmt|;
if|if
condition|(
name|nap
operator|->
name|maxgrouplist
operator|!=
literal|0
condition|)
name|nap
operator|->
name|args
operator|.
name|flags
operator||=
name|MNT2_NFS_OPT_MAXGRPS
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MNT2_NFS_OPT_MAXGRPS)&& defined(MNTTAB_OPT_MAXGROUPS) */
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_OPTSTR
name|nap
operator|->
name|optstr
operator|=
name|mntp
operator|->
name|mnt_opts
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_OPTSTR */
comment|/************************************************************************/
comment|/***  FINAL ACTIONS                                                   ***/
comment|/************************************************************************/
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_GFS_FLAGS
comment|/* Ultrix stores generic flags in nfs_args.gfs_flags. */
name|nap
operator|->
name|gfs_flags
operator|=
name|genflags
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_FLAGS */
name|s
operator|=
name|set_nfs4_security
argument_list|(
name|nap
argument_list|,
name|mntp
argument_list|)
expr_stmt|;
comment|/* Add addresses to the mount options */
name|add_nfs4_mntopts
argument_list|(
name|nap
argument_list|,
name|mntp
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return;
comment|/* end of compute_nfs4_args() function */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|print_nfs4_args
parameter_list|(
specifier|const
name|nfs4_args_t
modifier|*
name|nap
parameter_list|,
name|u_long
name|nfs_version
parameter_list|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sap
decl_stmt|;
name|struct
name|nfs_common_args
name|a
decl_stmt|;
if|if
condition|(
operator|!
name|nap
condition|)
block|{
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NULL nfs_args!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->client_addr \"%s\"\n"
argument_list|,
name|nap
operator|->
name|client_addr
operator|.
name|data
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->mnt_path = \"%s\""
argument_list|,
name|nap
operator|->
name|mnt_path
operator|.
name|data
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->hostname = \"%s\""
argument_list|,
name|nap
operator|->
name|hostname
operator|.
name|data
argument_list|)
expr_stmt|;
name|sap
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|nap
operator|->
name|host_addr
expr_stmt|;
name|print_nfs_sockaddr_in
argument_list|(
literal|"host_addr"
argument_list|,
name|sap
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->proto = %d"
argument_list|,
operator|(
name|int
operator|)
name|nap
operator|->
name|proto
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_VERSION
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->version = %d"
argument_list|,
name|nap
operator|->
name|version
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_VERSION */
name|print_nfs4_security
argument_list|(
name|nap
argument_list|)
expr_stmt|;
name|put_nfs_common_args
argument_list|(
name|nap
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|print_nfs_common_args
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_FS_NFS4 */
end_comment

begin_function
name|void
name|compute_nfs_args
parameter_list|(
name|void
modifier|*
name|nap
parameter_list|,
name|mntent_t
modifier|*
name|mntp
parameter_list|,
name|int
name|genflags
parameter_list|,
name|struct
name|netconfig
modifier|*
name|nfsncp
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|ip_addr
parameter_list|,
name|u_long
name|nfs_version
parameter_list|,
name|char
modifier|*
name|nfs_proto
parameter_list|,
name|am_nfs_handle_t
modifier|*
name|fhp
parameter_list|,
name|char
modifier|*
name|host_name
parameter_list|,
name|char
modifier|*
name|fs_name
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_FS_NFS4
if|if
condition|(
name|nfs_version
operator|==
name|NFS_VERSION4
condition|)
name|compute_nfs4_args
argument_list|(
name|nap
argument_list|,
name|mntp
argument_list|,
name|genflags
argument_list|,
name|nfsncp
argument_list|,
name|ip_addr
argument_list|,
name|nfs_version
argument_list|,
name|nfs_proto
argument_list|,
name|fhp
argument_list|,
name|host_name
argument_list|,
name|fs_name
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* HAVE_FS_NFS4 */
name|compute_nfs23_args
argument_list|(
name|nap
argument_list|,
name|mntp
argument_list|,
name|genflags
argument_list|,
name|nfsncp
argument_list|,
name|ip_addr
argument_list|,
name|nfs_version
argument_list|,
name|nfs_proto
argument_list|,
name|fhp
argument_list|,
name|host_name
argument_list|,
name|fs_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|discard_nfs_args
parameter_list|(
name|void
modifier|*
name|nap
parameter_list|,
name|u_long
name|nfs_version
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_FS_NFS4
if|if
condition|(
name|nfs_version
operator|==
name|NFS_VERSION4
condition|)
name|discard_nfs4_args
argument_list|(
name|nap
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* HAVE_FS_NFS4 */
name|discard_nfs23_args
argument_list|(
name|nap
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
name|void
name|print_nfs_args
parameter_list|(
specifier|const
name|void
modifier|*
name|nap
parameter_list|,
name|u_long
name|nfs_version
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_FS_NFS4
if|if
condition|(
name|nfs_version
operator|==
name|NFS_VERSION4
condition|)
name|print_nfs4_args
argument_list|(
name|nap
argument_list|,
name|nfs_version
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* HAVE_FS_NFS4 */
name|print_nfs23_args
argument_list|(
name|nap
argument_list|,
name|nfs_version
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Fill in special values for flags and fields of nfs_args, for an  * automounter NFS mount.  */
end_comment

begin_function
name|void
name|compute_automounter_nfs_args
parameter_list|(
name|nfs_args_t
modifier|*
name|nap
parameter_list|,
name|mntent_t
modifier|*
name|mntp
parameter_list|)
block|{
name|struct
name|nfs_common_args
name|a
decl_stmt|;
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_SYMTTL
comment|/*    * Don't let the kernel cache symbolic links we generate, or else lookups    * will bypass amd and fail to remount stuff as needed.    */
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"turning on NFS option symttl and setting value to 0"
argument_list|)
expr_stmt|;
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_SYMTTL
expr_stmt|;
name|nap
operator|->
name|symttl
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_SYMTTL */
comment|/*    * This completes the flags for the HIDE_MOUNT_TYPE  code in the    * mount_amfs_toplvl() function in amd/amfs_toplvl.c.    * Some systems don't have a mount type, but a mount flag.    */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_AUTO
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_AUTO
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_AUTO */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_IGNORE
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_IGNORE
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_IGNORE */
ifdef|#
directive|ifdef
name|MNT2_GEN_OPT_AUTOMNTFS
name|nap
operator|->
name|flags
operator||=
name|MNT2_GEN_OPT_AUTOMNTFS
expr_stmt|;
endif|#
directive|endif
comment|/* not MNT2_GEN_OPT_AUTOMNTFS */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_DUMBTIMR
comment|/*    * Don't let the kernel start computing throughput of Amd.  The numbers    * will be meaningless because of the way Amd does mount retries.    */
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"%s: disabling nfs congestion window"
argument_list|,
name|mntp
operator|->
name|mnt_dir
argument_list|)
expr_stmt|;
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_DUMBTIMR
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_DUMBTIMR */
comment|/* compute all of the NFS attribute-cache flags */
name|memset
argument_list|(
operator|&
name|a
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|.
name|flags
operator|=
name|nap
operator|->
name|flags
expr_stmt|;
name|compute_nfs_attrcache_flags
argument_list|(
operator|&
name|a
argument_list|,
name|mntp
argument_list|)
expr_stmt|;
name|get_nfs_common_args
argument_list|(
name|nap
argument_list|,
name|a
argument_list|)
expr_stmt|;
comment|/*    * Provide a slight bit more security by requiring the kernel to use    * reserved ports.    */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_RESVPORT
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_RESVPORT
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_RESVPORT */
block|}
end_function

begin_function
name|int
name|nfs_valid_version
parameter_list|(
name|u_long
name|v
parameter_list|)
block|{
return|return
name|v
operator|>=
name|NFS_VERS_MIN
operator|&&
name|v
operator|<=
name|NFS_VERS_MAX
return|;
block|}
end_function

end_unit

