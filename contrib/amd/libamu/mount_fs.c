begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997-2003 Erez Zadok  * Copyright (c) 1990 Jan-Simon Pendry  * Copyright (c) 1990 Imperial College of Science, Technology& Medicine  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry at Imperial College, London.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgment:  *      This product includes software developed by the University of  *      California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      %W% (Berkeley) %G%  *  * $Id: mount_fs.c,v 1.11.2.11 2003/05/08 17:57:53 ib42 Exp $  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<am_defs.h>
end_include

begin_include
include|#
directive|include
file|<amu.h>
end_include

begin_comment
comment|/* ensure that mount table options are delimited by a comma */
end_comment

begin_define
define|#
directive|define
name|append_opts
parameter_list|(
name|old
parameter_list|,
name|new
parameter_list|)
value|{ \ 	if (*(old) != '\0') strcat(old, ","); \ 	strcat(old, new); }
end_define

begin_comment
comment|/*  * Standard mount flags  */
end_comment

begin_decl_stmt
name|struct
name|opt_tab
name|mnt_flags
index|[]
init|=
block|{
if|#
directive|if
name|defined
argument_list|(
name|MNT2_GEN_OPT_RDONLY
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_RO
argument_list|)
block|{
name|MNTTAB_OPT_RO
block|,
name|MNT2_GEN_OPT_RDONLY
block|}
block|,
endif|#
directive|endif
comment|/* defined(MNT2_GEN_OPT_RDONLY)&& defined(MNTTAB_OPT_RO) */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_GEN_OPT_NOCACHE
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_NOCACHE
argument_list|)
block|{
name|MNTTAB_OPT_NOCACHE
block|,
name|MNT2_GEN_OPT_NOCACHE
block|}
block|,
endif|#
directive|endif
comment|/* defined(MNT2_GEN_OPT_NOCACHE)&& defined(MNTTAB_OPT_NOCACHE) */
comment|/* the "grpid" mount option can be offered as generic of NFS */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_GRPID
ifdef|#
directive|ifdef
name|MNT2_GEN_OPT_GRPID
block|{
name|MNTTAB_OPT_GRPID
block|,
name|MNT2_GEN_OPT_GRPID
block|}
block|,
endif|#
directive|endif
comment|/* MNT2_GEN_OPT_GRPID */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_GRPID
block|{
name|MNTTAB_OPT_GRPID
block|,
name|MNT2_NFS_OPT_GRPID
block|}
block|,
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_GRPID */
endif|#
directive|endif
comment|/* MNTTAB_OPT_GRPID */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_GEN_OPT_MULTI
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_MULTI
argument_list|)
block|{
name|MNTTAB_OPT_MULTI
block|,
name|MNT2_GEN_OPT_MULTI
block|}
block|,
endif|#
directive|endif
comment|/* defined(MNT2_GEN_OPT_MULTI)&& defined(MNTTAB_OPT_MULTI) */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_GEN_OPT_NODEV
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_NODEV
argument_list|)
block|{
name|MNTTAB_OPT_NODEV
block|,
name|MNT2_GEN_OPT_NODEV
block|}
block|,
endif|#
directive|endif
comment|/* defined(MNT2_GEN_OPT_NODEV)&& defined(MNTTAB_OPT_NODEV) */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_GEN_OPT_NOEXEC
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_NOEXEC
argument_list|)
block|{
name|MNTTAB_OPT_NOEXEC
block|,
name|MNT2_GEN_OPT_NOEXEC
block|}
block|,
endif|#
directive|endif
comment|/* defined(MNT2_GEN_OPT_NOEXEC)&& defined(MNTTAB_OPT_NOEXEC) */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_GEN_OPT_NOSUB
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_NOSUB
argument_list|)
block|{
name|MNTTAB_OPT_NOSUB
block|,
name|MNT2_GEN_OPT_NOSUB
block|}
block|,
endif|#
directive|endif
comment|/* defined(MNT2_GEN_OPT_NOSUB)&& defined(MNTTAB_OPT_NOSUB) */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_GEN_OPT_NOSUID
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_NOSUID
argument_list|)
block|{
name|MNTTAB_OPT_NOSUID
block|,
name|MNT2_GEN_OPT_NOSUID
block|}
block|,
endif|#
directive|endif
comment|/* defined(MNT2_GEN_OPT_NOSUID)&& defined(MNTTAB_OPT_NOSUID) */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_GEN_OPT_SYNC
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_SYNC
argument_list|)
block|{
name|MNTTAB_OPT_SYNC
block|,
name|MNT2_GEN_OPT_SYNC
block|}
block|,
endif|#
directive|endif
comment|/* defined(MNT2_GEN_OPT_SYNC)&& defined(MNTTAB_OPT_SYNC) */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_GEN_OPT_OVERLAY
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_OVERLAY
argument_list|)
block|{
name|MNTTAB_OPT_OVERLAY
block|,
name|MNT2_GEN_OPT_OVERLAY
block|}
block|,
endif|#
directive|endif
comment|/* defined(MNT2_GEN_OPT_OVERLAY)&& defined(MNTTAB_OPT_OVERLAY) */
comment|/*    * Do not define MNT2_NFS_OPT_* entries here!  This is for generic    * mount(2) options only, not for NFS mount options.    */
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* compute generic mount flags */
end_comment

begin_function
name|int
name|compute_mount_flags
parameter_list|(
name|mntent_t
modifier|*
name|mntp
parameter_list|)
block|{
name|struct
name|opt_tab
modifier|*
name|opt
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|MNT2_GEN_OPT_NEWTYPE
name|flags
operator|=
name|MNT2_GEN_OPT_NEWTYPE
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_GEN_OPT_NEWTYPE */
ifdef|#
directive|ifdef
name|MNT2_GEN_OPT_AUTOMOUNTED
name|flags
operator||=
name|MNT2_GEN_OPT_AUTOMOUNTED
expr_stmt|;
endif|#
directive|endif
comment|/* not MNT2_GEN_OPT_AUTOMOUNTED */
comment|/*    * Crack basic mount options    */
for|for
control|(
name|opt
operator|=
name|mnt_flags
init|;
name|opt
operator|->
name|opt
condition|;
name|opt
operator|++
control|)
block|{
name|flags
operator||=
name|hasmntopt
argument_list|(
name|mntp
argument_list|,
name|opt
operator|->
name|opt
argument_list|)
condition|?
name|opt
operator|->
name|flag
else|:
literal|0
expr_stmt|;
block|}
return|return
name|flags
return|;
block|}
end_function

begin_comment
comment|/* compute generic mount flags for automounter mounts */
end_comment

begin_function
name|int
name|compute_automounter_mount_flags
parameter_list|(
name|mntent_t
modifier|*
name|mntp
parameter_list|)
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|MNT2_GEN_OPT_IGNORE
name|flags
operator||=
name|MNT2_GEN_OPT_IGNORE
expr_stmt|;
endif|#
directive|endif
comment|/* not MNT2_GEN_OPT_IGNORE */
ifdef|#
directive|ifdef
name|MNT2_GEN_OPT_AUTOMNTFS
name|flags
operator||=
name|MNT2_GEN_OPT_AUTOMNTFS
expr_stmt|;
endif|#
directive|endif
comment|/* not MNT2_GEN_OPT_AUTOMNTFS */
return|return
name|flags
return|;
block|}
end_function

begin_function
name|int
name|mount_fs
parameter_list|(
name|mntent_t
modifier|*
name|mnt
parameter_list|,
name|int
name|flags
parameter_list|,
name|caddr_t
name|mnt_data
parameter_list|,
name|int
name|retry
parameter_list|,
name|MTYPE_TYPE
name|type
parameter_list|,
name|u_long
name|nfs_version
parameter_list|,
specifier|const
name|char
modifier|*
name|nfs_proto
parameter_list|,
specifier|const
name|char
modifier|*
name|mnttabname
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|MOUNT_TABLE_ON_FILE
ifdef|#
directive|ifdef
name|MNTTAB_OPT_DEV
name|struct
name|stat
name|stb
decl_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_OPT_DEV */
name|char
modifier|*
name|zopts
init|=
name|NULL
decl_stmt|,
modifier|*
name|xopts
init|=
name|NULL
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MNTTAB_OPT_DEV
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|HAVE_FS_NFS3
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_VERS
argument_list|)
operator|)
operator|||
name|defined
argument_list|(
name|MNTTAB_OPT_PROTO
argument_list|)
name|char
name|optsbuf
index|[
literal|48
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* defined(MNTTAB_OPT_DEV) || (defined(HAVE_FS_NFS3)&& defined(MNTTAB_OPT_VERS)) || defined(MNTTAB_OPT_PROTO) */
endif|#
directive|endif
comment|/* MOUNT_TABLE_ON_FILE */
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"%s fstype "
name|MTYPE_PRINTF_TYPE
literal|" (%s) flags %#x (%s)"
argument_list|,
name|mnt
operator|->
name|mnt_dir
argument_list|,
name|type
argument_list|,
name|mnt
operator|->
name|mnt_type
argument_list|,
name|flags
argument_list|,
name|mnt
operator|->
name|mnt_opts
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|again
label|:
name|clock_valid
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|MOUNT_TRAP
argument_list|(
name|type
argument_list|,
name|mnt
argument_list|,
name|flags
argument_list|,
name|mnt_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|<
literal|0
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"%s: mount: %m"
argument_list|,
name|mnt
operator|->
name|mnt_dir
argument_list|)
expr_stmt|;
comment|/*      * The following code handles conditions which shouldn't      * occur.  They are possible either because amd screws up      * in preparing for the mount, or because some human      * messed with the mount point.  Both have been known to      * happen. -- stolcke 2/22/95      */
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
comment|/*        * Occasionally the mount point vanishes, probably        * due to some race condition.  Just recreate it        * as necessary.        */
name|errno
operator|=
name|mkdirs
argument_list|(
name|mnt
operator|->
name|mnt_dir
argument_list|,
literal|0555
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
operator|&&
name|errno
operator|!=
name|EEXIST
condition|)
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"%s: mkdirs: %m"
argument_list|,
name|mnt
operator|->
name|mnt_dir
argument_list|)
expr_stmt|;
else|else
block|{
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"extra mkdirs required for %s"
argument_list|,
name|mnt
operator|->
name|mnt_dir
argument_list|)
expr_stmt|;
name|error
operator|=
name|MOUNT_TRAP
argument_list|(
name|type
argument_list|,
name|mnt
argument_list|,
name|flags
argument_list|,
name|mnt_data
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|EBUSY
condition|)
block|{
comment|/*        * Also, sometimes unmount isn't called, e.g., because        * our mountlist is garbled.  This leaves old mount        * points around which need to be removed before we        * can mount something new in their place.        */
name|errno
operator|=
name|umount_fs
argument_list|(
name|mnt
operator|->
name|mnt_dir
argument_list|,
name|mnttabname
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"%s: umount: %m"
argument_list|,
name|mnt
operator|->
name|mnt_dir
argument_list|)
expr_stmt|;
else|else
block|{
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"extra umount required for %s"
argument_list|,
name|mnt
operator|->
name|mnt_dir
argument_list|)
expr_stmt|;
name|error
operator|=
name|MOUNT_TRAP
argument_list|(
name|type
argument_list|,
name|mnt
argument_list|,
name|flags
argument_list|,
name|mnt_data
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|error
operator|<
literal|0
operator|&&
operator|--
name|retry
operator|>
literal|0
condition|)
block|{
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|error
operator|<
literal|0
condition|)
block|{
return|return
name|errno
return|;
block|}
ifdef|#
directive|ifdef
name|MOUNT_TABLE_ON_FILE
comment|/*    * Allocate memory for options:    *        dev=..., vers={2,3}, proto={tcp,udp}    */
name|zopts
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|mnt
operator|->
name|mnt_opts
argument_list|)
operator|+
literal|48
argument_list|)
expr_stmt|;
comment|/* copy standard options */
name|xopts
operator|=
name|mnt
operator|->
name|mnt_opts
expr_stmt|;
name|strcpy
argument_list|(
name|zopts
argument_list|,
name|xopts
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MNTTAB_OPT_DEV
comment|/* add the extra dev= field to the mount table */
if|if
condition|(
name|lstat
argument_list|(
name|mnt
operator|->
name|mnt_dir
argument_list|,
operator|&
name|stb
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
name|stb
operator|.
name|st_dev
argument_list|)
operator|==
literal|2
condition|)
comment|/* e.g. SunOS 4.1 */
name|sprintf
argument_list|(
name|optsbuf
argument_list|,
literal|"%s=%04lx"
argument_list|,
name|MNTTAB_OPT_DEV
argument_list|,
operator|(
name|u_long
operator|)
name|stb
operator|.
name|st_dev
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
else|else
comment|/* e.g. System Vr4 */
name|sprintf
argument_list|(
name|optsbuf
argument_list|,
literal|"%s=%08lx"
argument_list|,
name|MNTTAB_OPT_DEV
argument_list|,
operator|(
name|u_long
operator|)
name|stb
operator|.
name|st_dev
argument_list|)
expr_stmt|;
name|append_opts
argument_list|(
name|zopts
argument_list|,
name|optsbuf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MNTTAB_OPT_DEV */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_FS_NFS3
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_VERS
argument_list|)
comment|/*    * add the extra vers={2,3} field to the mount table,    * unless already specified by user    */
if|if
condition|(
name|nfs_version
operator|==
name|NFS_VERSION3
operator|&&
name|hasmntval
argument_list|(
name|mnt
argument_list|,
name|MNTTAB_OPT_VERS
argument_list|)
operator|!=
name|NFS_VERSION3
condition|)
block|{
name|sprintf
argument_list|(
name|optsbuf
argument_list|,
literal|"%s=%d"
argument_list|,
name|MNTTAB_OPT_VERS
argument_list|,
name|NFS_VERSION3
argument_list|)
expr_stmt|;
name|append_opts
argument_list|(
name|zopts
argument_list|,
name|optsbuf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(HAVE_FS_NFS3)&& defined(MNTTAB_OPT_VERS) */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_PROTO
comment|/*    * add the extra proto={tcp,udp} field to the mount table,    * unless already specified by user.    */
if|if
condition|(
name|nfs_proto
operator|&&
operator|!
name|hasmntopt
argument_list|(
name|mnt
argument_list|,
name|MNTTAB_OPT_PROTO
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|optsbuf
argument_list|,
literal|"%s=%s"
argument_list|,
name|MNTTAB_OPT_PROTO
argument_list|,
name|nfs_proto
argument_list|)
expr_stmt|;
name|append_opts
argument_list|(
name|zopts
argument_list|,
name|optsbuf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MNTTAB_OPT_PROTO */
comment|/* finally, store the options into the mount table structure */
name|mnt
operator|->
name|mnt_opts
operator|=
name|zopts
expr_stmt|;
comment|/*    * Additional fields in mntent_t    * are fixed up here    */
ifdef|#
directive|ifdef
name|HAVE_MNTENT_T_MNT_CNODE
name|mnt
operator|->
name|mnt_cnode
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_MNTENT_T_MNT_CNODE */
ifdef|#
directive|ifdef
name|HAVE_MNTENT_T_MNT_RO
name|mnt
operator|->
name|mnt_ro
operator|=
operator|(
name|hasmntopt
argument_list|(
name|mnt
argument_list|,
name|MNTTAB_OPT_RO
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_MNTENT_T_MNT_RO */
ifdef|#
directive|ifdef
name|HAVE_MNTENT_T_MNT_TIME
ifdef|#
directive|ifdef
name|HAVE_MNTENT_T_MNT_TIME_STRING
block|{
comment|/* allocate enough space for a long */
name|char
modifier|*
name|str
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|13
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%ld"
argument_list|,
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|mnt
operator|->
name|mnt_time
operator|=
name|str
expr_stmt|;
block|}
else|#
directive|else
comment|/* not HAVE_MNTENT_T_MNT_TIME_STRING */
name|mnt
operator|->
name|mnt_time
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_MNTENT_T_MNT_TIME_STRING */
endif|#
directive|endif
comment|/* HAVE_MNTENT_T_MNT_TIME */
name|write_mntent
argument_list|(
name|mnt
argument_list|,
name|mnttabname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MNTTAB_OPT_DEV
if|if
condition|(
name|xopts
condition|)
block|{
name|XFREE
argument_list|(
name|mnt
operator|->
name|mnt_opts
argument_list|)
expr_stmt|;
name|mnt
operator|->
name|mnt_opts
operator|=
name|xopts
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MNTTAB_OPT_DEV */
endif|#
directive|endif
comment|/* MOUNT_TABLE_ON_FILE */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Fill in the many possible fields and flags of struct nfs_args.  *  * nap:		pre-allocated structure to fill in.  * mntp:	mount entry structure (includes options)  * genflags:	generic mount flags already determined  * nfsncp:	(TLI only) netconfig entry for this NFS mount  * ip_addr:	IP address of file server  * nfs_version:	2, 3, (4 in the future), or 0 if unknown  * nfs_proto:	"udp", "tcp", or NULL.  * fhp:		file handle structure pointer  * host_name:	name of remote NFS host  * fs_name:	remote file system name to mount  */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|HAVE_TRANSPORT_TYPE_TLI
name|compute_nfs_args
parameter_list|(
name|nfs_args_t
modifier|*
name|nap
parameter_list|,
name|mntent_t
modifier|*
name|mntp
parameter_list|,
name|int
name|genflags
parameter_list|,
name|struct
name|netconfig
modifier|*
name|nfsncp
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|ip_addr
parameter_list|,
name|u_long
name|nfs_version
parameter_list|,
name|char
modifier|*
name|nfs_proto
parameter_list|,
name|am_nfs_handle_t
modifier|*
name|fhp
parameter_list|,
name|char
modifier|*
name|host_name
parameter_list|,
name|char
modifier|*
name|fs_name
parameter_list|)
else|#
directive|else
comment|/* not HAVE_TRANSPORT_TYPE_TLI */
function|compute_nfs_args
parameter_list|(
name|nfs_args_t
modifier|*
name|nap
parameter_list|,
name|mntent_t
modifier|*
name|mntp
parameter_list|,
name|int
name|genflags
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|ip_addr
parameter_list|,
name|u_long
name|nfs_version
parameter_list|,
name|char
modifier|*
name|nfs_proto
parameter_list|,
name|am_nfs_handle_t
modifier|*
name|fhp
parameter_list|,
name|char
modifier|*
name|host_name
parameter_list|,
name|char
modifier|*
name|fs_name
parameter_list|)
endif|#
directive|endif
comment|/* not HAVE_TRANSPORT_TYPE_TLI */
block|{
name|int
name|acval
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FS_NFS3
specifier|static
name|am_nfs_fh3
name|fh3
decl_stmt|;
comment|/* static, b/c gcc on aix corrupts stack */
endif|#
directive|endif
comment|/* HAVE_FS_NFS3 */
comment|/* initialize just in case */
name|memset
argument_list|(
operator|(
name|voidp
operator|)
name|nap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|nfs_args_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/************************************************************************/
comment|/***	FILEHANDLE DATA AND LENGTH					***/
comment|/************************************************************************/
ifdef|#
directive|ifdef
name|HAVE_FS_NFS3
if|if
condition|(
name|nfs_version
operator|==
name|NFS_VERSION3
condition|)
block|{
name|memset
argument_list|(
operator|(
name|voidp
operator|)
operator|&
name|fh3
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|am_nfs_fh3
argument_list|)
argument_list|)
expr_stmt|;
name|fh3
operator|.
name|fh3_length
operator|=
name|fhp
operator|->
name|v3
operator|.
name|mountres3_u
operator|.
name|mountinfo
operator|.
name|fhandle
operator|.
name|fhandle3_len
expr_stmt|;
name|memmove
argument_list|(
name|fh3
operator|.
name|fh3_u
operator|.
name|data
argument_list|,
name|fhp
operator|->
name|v3
operator|.
name|mountres3_u
operator|.
name|mountinfo
operator|.
name|fhandle
operator|.
name|fhandle3_val
argument_list|,
name|fh3
operator|.
name|fh3_length
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_NFS_ARGS_T_FHSIZE
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_NFS_ARGS_T_FH_LEN
argument_list|)
comment|/*      * Some systems (Irix/bsdi3) have a separate field in nfs_args for      * the length of the file handle for NFS V3.  They insist that      * the file handle set in nfs_args be plain bytes, and not      * include the length field.      */
name|NFS_FH_DREF
argument_list|(
name|nap
operator|->
name|NFS_FH_FIELD
argument_list|,
operator|&
operator|(
name|fh3
operator|.
name|fh3_u
operator|.
name|data
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not defined(HAVE_NFS_ARGS_T_FHSIZE) || defined(HAVE_NFS_ARGS_T_FH_LEN) */
name|NFS_FH_DREF
argument_list|(
name|nap
operator|->
name|NFS_FH_FIELD
argument_list|,
operator|&
name|fh3
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not defined(HAVE_NFS_ARGS_T_FHSIZE) || defined(HAVE_NFS_ARGS_T_FH_LEN) */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_NFSV3
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_NFSV3
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_NFSV3 */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_VER3
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_VER3
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_VER3 */
block|}
else|else
endif|#
directive|endif
comment|/* HAVE_FS_NFS3 */
name|NFS_FH_DREF
argument_list|(
name|nap
operator|->
name|NFS_FH_FIELD
argument_list|,
operator|&
operator|(
name|fhp
operator|->
name|v2
operator|.
name|fhs_fh
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_FHSIZE
ifdef|#
directive|ifdef
name|HAVE_FS_NFS3
if|if
condition|(
name|nfs_version
operator|==
name|NFS_VERSION3
condition|)
name|nap
operator|->
name|fhsize
operator|=
name|fh3
operator|.
name|fh3_length
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* HAVE_FS_NFS3 */
name|nap
operator|->
name|fhsize
operator|=
name|FHSIZE
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_FHSIZE */
comment|/* this is the version of the nfs_args structure, not of NFS! */
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_FH_LEN
ifdef|#
directive|ifdef
name|HAVE_FS_NFS3
if|if
condition|(
name|nfs_version
operator|==
name|NFS_VERSION3
condition|)
name|nap
operator|->
name|fh_len
operator|=
name|fh3
operator|.
name|fh3_length
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* HAVE_FS_NFS3 */
name|nap
operator|->
name|fh_len
operator|=
name|FHSIZE
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_FH_LEN */
comment|/************************************************************************/
comment|/***	HOST NAME							***/
comment|/************************************************************************/
name|NFS_HN_DREF
argument_list|(
name|nap
operator|->
name|hostname
argument_list|,
name|host_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_HOSTNAME
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_HOSTNAME
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_HOSTNAME */
comment|/************************************************************************/
comment|/***	ATTRIBUTE CACHES						***/
comment|/************************************************************************/
comment|/*    * acval is set to 0 at the top of the function.  If actimeo mount option    * exists and defined in mntopts, then it acval is set to it.    * If the value is non-zero, then we set all attribute cache fields to it.    * If acval is zero, it means it was never defined in mntopts or the    * actimeo mount option does not exist, in which case we check for    * individual mount options per attribute cache.    * Regardless of the value of acval, mount flags are set based directly    * on the values of the attribute caches.    */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_ACTIMEO
name|acval
operator|=
name|hasmntval
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_ACTIMEO
argument_list|)
expr_stmt|;
comment|/* attr cache timeout (sec) */
endif|#
directive|endif
comment|/* MNTTAB_OPT_ACTIMEO */
if|if
condition|(
name|acval
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_ACREGMIN
name|nap
operator|->
name|acregmin
operator|=
name|acval
expr_stmt|;
comment|/* min ac timeout for reg files (sec) */
name|nap
operator|->
name|acregmax
operator|=
name|acval
expr_stmt|;
comment|/* max ac timeout for reg files (sec) */
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_ACREGMIN */
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_ACDIRMIN
name|nap
operator|->
name|acdirmin
operator|=
name|acval
expr_stmt|;
comment|/* min ac timeout for dirs (sec) */
name|nap
operator|->
name|acdirmax
operator|=
name|acval
expr_stmt|;
comment|/* max ac timeout for dirs (sec) */
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_ACDIRMIN */
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MNTTAB_OPT_ACREGMIN
name|nap
operator|->
name|acregmin
operator|=
name|hasmntval
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_ACREGMIN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_OPT_ACREGMIN */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_ACREGMAX
name|nap
operator|->
name|acregmax
operator|=
name|hasmntval
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_ACREGMAX
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_OPT_ACREGMAX */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_ACDIRMIN
name|nap
operator|->
name|acdirmin
operator|=
name|hasmntval
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_ACDIRMIN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_OPT_ACDIRMIN */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_ACDIRMAX
name|nap
operator|->
name|acdirmax
operator|=
name|hasmntval
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_ACDIRMAX
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_OPT_ACDIRMAX */
block|}
comment|/* end of "if (acval)" statement */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_ACREGMIN
if|if
condition|(
name|nap
operator|->
name|acregmin
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_ACREGMIN
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_ACREGMIN */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_ACREGMAX
if|if
condition|(
name|nap
operator|->
name|acregmax
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_ACREGMAX
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_ACREGMAX */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_ACDIRMIN
if|if
condition|(
name|nap
operator|->
name|acdirmin
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_ACDIRMIN
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_ACDIRMIN */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_ACDIRMAX
if|if
condition|(
name|nap
operator|->
name|acdirmax
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_ACDIRMAX
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_ACDIRMAX */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_NOAC
comment|/* don't cache attributes */
if|if
condition|(
name|hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_NOAC
argument_list|)
operator|!=
name|NULL
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_NOAC
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_OPT_NOAC */
comment|/************************************************************************/
comment|/***	IP ADDRESS OF REMOTE HOST					***/
comment|/************************************************************************/
if|if
condition|(
name|ip_addr
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TRANSPORT_TYPE_TLI
name|nap
operator|->
name|addr
operator|=
name|ALLOC
argument_list|(
expr|struct
name|netbuf
argument_list|)
expr_stmt|;
comment|/* free()'ed at end of mount_nfs_fh() */
endif|#
directive|endif
comment|/* HAVE_TRANSPORT_TYPE_TLI */
name|NFS_SA_DREF
argument_list|(
name|nap
argument_list|,
name|ip_addr
argument_list|)
expr_stmt|;
block|}
comment|/************************************************************************/
comment|/***	NFS PROTOCOL (UDP, TCP) AND VERSION				***/
comment|/************************************************************************/
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_TCP
if|if
condition|(
name|nfs_proto
operator|&&
name|STREQ
argument_list|(
name|nfs_proto
argument_list|,
literal|"tcp"
argument_list|)
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_TCP
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_TCP */
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_SOTYPE
comment|/* bsdi3 uses this */
if|if
condition|(
name|nfs_proto
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|nfs_proto
argument_list|,
literal|"tcp"
argument_list|)
condition|)
name|nap
operator|->
name|sotype
operator|=
name|SOCK_STREAM
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|nfs_proto
argument_list|,
literal|"udp"
argument_list|)
condition|)
name|nap
operator|->
name|sotype
operator|=
name|SOCK_DGRAM
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_SOTYPE */
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_PROTO
name|nap
operator|->
name|proto
operator|=
literal|0
expr_stmt|;
comment|/* bsdi3 sets this field to zero  */
ifdef|#
directive|ifdef
name|IPPROTO_TCP
if|if
condition|(
name|nfs_proto
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|nfs_proto
argument_list|,
literal|"tcp"
argument_list|)
condition|)
comment|/* AIX 4.2.x needs this */
name|nap
operator|->
name|proto
operator|=
name|IPPROTO_TCP
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|nfs_proto
argument_list|,
literal|"udp"
argument_list|)
condition|)
name|nap
operator|->
name|proto
operator|=
name|IPPROTO_UDP
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IPPROTO_TCP */
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_SOTYPE */
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_VERSION
ifdef|#
directive|ifdef
name|NFS_ARGSVERSION
name|nap
operator|->
name|version
operator|=
name|NFS_ARGSVERSION
expr_stmt|;
comment|/* BSDI 3.0 and OpenBSD 2.2 */
endif|#
directive|endif
comment|/* NFS_ARGSVERSION */
ifdef|#
directive|ifdef
name|DG_MOUNT_NFS_VERSION
name|nap
operator|->
name|version
operator|=
name|DG_MOUNT_NFS_VERSION
expr_stmt|;
comment|/* dg-ux */
endif|#
directive|endif
comment|/* DG_MOUNT_NFS_VERSION */
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_VERSION */
comment|/************************************************************************/
comment|/***	OTHER NFS SOCKET RELATED OPTIONS AND FLAGS			***/
comment|/************************************************************************/
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_NOCONN
comment|/* check if user specified to use unconnected or connected sockets */
if|if
condition|(
name|hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_NOCONN
argument_list|)
operator|!=
name|NULL
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_NOCONN
expr_stmt|;
elseif|else
if|if
condition|(
name|hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_CONN
argument_list|)
operator|!=
name|NULL
condition|)
name|nap
operator|->
name|flags
operator|&=
operator|~
name|MNT2_NFS_OPT_NOCONN
expr_stmt|;
else|else
block|{
comment|/*      * Some OSs want you to set noconn always.  Some want you to always turn      * it off.  Others want you to turn it on/off only if NFS V.3 is used.      * And all of that changes from revision to another.  This is      * particularly true of OpenBSD, NetBSD, and FreeBSD.  So, rather than      * attempt to auto-detect this, I'm forced to "fix" it in the individual      * conf/nfs_prot/nfs_prot_*.h files.      */
ifdef|#
directive|ifdef
name|USE_UNCONNECTED_NFS_SOCKETS
if|if
condition|(
operator|!
operator|(
name|nap
operator|->
name|flags
operator|&
name|MNT2_NFS_OPT_NOCONN
operator|)
condition|)
block|{
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_NOCONN
expr_stmt|;
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"noconn option not specified, and was just turned ON (OS override)! (May cause NFS hangs on some systems...)"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_UNCONNECTED_NFS_SOCKETS */
ifdef|#
directive|ifdef
name|USE_CONNECTED_NFS_SOCKETS
if|if
condition|(
name|nap
operator|->
name|flags
operator|&
name|MNT2_NFS_OPT_NOCONN
condition|)
block|{
name|nap
operator|->
name|flags
operator|&=
operator|~
name|MNT2_NFS_OPT_NOCONN
expr_stmt|;
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"noconn option specified, and was just turned OFF (OS override)! (May cause NFS hangs on some systems...)"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_CONNECTED_NFS_SOCKETS */
block|}
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_NOCONN */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_RESVPORT
ifdef|#
directive|ifdef
name|MNTTAB_OPT_RESVPORT
if|if
condition|(
name|hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_RESVPORT
argument_list|)
operator|!=
name|NULL
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_RESVPORT
expr_stmt|;
else|#
directive|else
comment|/* not MNTTAB_OPT_RESVPORT */
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_RESVPORT
expr_stmt|;
endif|#
directive|endif
comment|/* not MNTTAB_OPT_RESVPORT */
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_RESVPORT */
comment|/************************************************************************/
comment|/***	OTHER FLAGS AND OPTIONS						***/
comment|/************************************************************************/
ifdef|#
directive|ifdef
name|HAVE_TRANSPORT_TYPE_TLI
comment|/* set up syncaddr field */
name|nap
operator|->
name|syncaddr
operator|=
operator|(
expr|struct
name|netbuf
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* set up knconf field */
if|if
condition|(
name|get_knetconfig
argument_list|(
operator|&
name|nap
operator|->
name|knconf
argument_list|,
name|nfsncp
argument_list|,
name|nfs_proto
argument_list|)
operator|<
literal|0
condition|)
block|{
name|plog
argument_list|(
name|XLOG_FATAL
argument_list|,
literal|"cannot fill knetconfig structure for nfs_args"
argument_list|)
expr_stmt|;
name|going_down
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* update the flags field for knconf */
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_KNCONF
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_TRANSPORT_TYPE_TLI */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_FSNAME
name|nap
operator|->
name|fsname
operator|=
name|fs_name
expr_stmt|;
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_FSNAME
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_FSNAME */
name|nap
operator|->
name|rsize
operator|=
name|hasmntval
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_RSIZE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_RSIZE
if|if
condition|(
name|nap
operator|->
name|rsize
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_RSIZE
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_RSIZE */
name|nap
operator|->
name|wsize
operator|=
name|hasmntval
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_WSIZE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_WSIZE
if|if
condition|(
name|nap
operator|->
name|wsize
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_WSIZE
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_WSIZE */
name|nap
operator|->
name|timeo
operator|=
name|hasmntval
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_TIMEO
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_TIMEO
if|if
condition|(
name|nap
operator|->
name|timeo
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_TIMEO
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_TIMEO */
name|nap
operator|->
name|retrans
operator|=
name|hasmntval
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_RETRANS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_RETRANS
if|if
condition|(
name|nap
operator|->
name|retrans
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_RETRANS
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_RETRANS */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_BIODS
if|if
condition|(
operator|(
name|nap
operator|->
name|biods
operator|=
name|hasmntval
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_BIODS
argument_list|)
operator|)
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_BIODS
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_BIODS */
if|if
condition|(
name|hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_SOFT
argument_list|)
operator|!=
name|NULL
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_SOFT
expr_stmt|;
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_SPONGY
if|if
condition|(
name|hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_SPONGY
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_SPONGY
expr_stmt|;
if|if
condition|(
name|nap
operator|->
name|flags
operator|&
name|MNT2_NFS_OPT_SOFT
condition|)
block|{
name|plog
argument_list|(
name|XLOG_USER
argument_list|,
literal|"Mount opts soft and spongy are incompatible - soft ignored"
argument_list|)
expr_stmt|;
name|nap
operator|->
name|flags
operator|&=
operator|~
name|MNT2_NFS_OPT_SOFT
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_SPONGY */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_GEN_OPT_RONLY
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNT2_NFS_OPT_RONLY
argument_list|)
comment|/* Ultrix has separate generic and NFS ro flags */
if|if
condition|(
name|genflags
operator|&
name|MNT2_GEN_OPT_RONLY
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_RONLY
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MNT2_GEN_OPT_RONLY)&& defined(MNT2_NFS_OPT_RONLY) */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_INTR
if|if
condition|(
name|hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_INTR
argument_list|)
operator|!=
name|NULL
condition|)
comment|/*      * Either turn on the "allow interrupts" option, or      * turn off the "disallow interrupts" option"      */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_INTR
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_INTR
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_INTR */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_NOINTR
name|nap
operator|->
name|flags
operator|&=
operator|~
name|MNT2_NFS_OPT_NOINTR
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_NOINTR */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_INT
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_INT
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_INT */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_NOINT
name|nap
operator|->
name|flags
operator|&=
operator|~
name|MNT2_NFS_OPT_NOINT
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_NOINT */
endif|#
directive|endif
comment|/* MNTTAB_OPT_INTR */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_NODEVS
if|if
condition|(
name|hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_NODEVS
argument_list|)
operator|!=
name|NULL
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_NODEVS
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_OPT_NODEVS */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_COMPRESS
if|if
condition|(
name|hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_COMPRESS
argument_list|)
operator|!=
name|NULL
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_COMPRESS
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_OPT_COMPRESS */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_PRIVATE
comment|/* mount private, single-client tree */
if|if
condition|(
name|hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_PRIVATE
argument_list|)
operator|!=
name|NULL
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_PRIVATE
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_OPT_PRIVATE */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_SYMTTL
comment|/* symlink cache time-to-live */
if|if
condition|(
operator|(
name|nap
operator|->
name|symttl
operator|=
name|hasmntval
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_SYMTTL
argument_list|)
operator|)
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_SYMTTL
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_OPT_SYMTTL */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_PGTHRESH
comment|/* paging threshold */
if|if
condition|(
operator|(
name|nap
operator|->
name|pg_thresh
operator|=
name|hasmntval
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_PGTHRESH
argument_list|)
operator|)
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_PGTHRESH
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_PGTHRESH */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_NFS_OPT_NOCTO
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_NOCTO
argument_list|)
if|if
condition|(
name|hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_NOCTO
argument_list|)
operator|!=
name|NULL
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_NOCTO
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MNT2_NFS_OPT_NOCTO)&& defined(MNTTAB_OPT_NOCTO) */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_NFS_OPT_POSIX
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_POSIX
argument_list|)
if|if
condition|(
name|hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_POSIX
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_POSIX
expr_stmt|;
name|nap
operator|->
name|pathconf
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_POSIX&& MNTTAB_OPT_POSIX */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_NFS_OPT_PROPLIST
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_PROPLIST
argument_list|)
if|if
condition|(
name|hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_PROPLIST
argument_list|)
operator|!=
name|NULL
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_PROPLIST
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MNT2_NFS_OPT_PROPLIST)&& defined(MNTTAB_OPT_PROPLIST) */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_NFS_OPT_MAXGRPS
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_MAXGROUPS
argument_list|)
name|nap
operator|->
name|maxgrouplist
operator|=
name|hasmntval
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_MAXGROUPS
argument_list|)
expr_stmt|;
if|if
condition|(
name|nap
operator|->
name|maxgrouplist
operator|!=
name|NULL
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_MAXGRPS
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MNT2_NFS_OPT_MAXGRPS)&& defined(MNTTAB_OPT_MAXGROUPS) */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_NFS_OPT_NONLM
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNTTAB_OPT_NOLOCK
argument_list|)
if|if
condition|(
name|hasmntopt
argument_list|(
name|mntp
argument_list|,
name|MNTTAB_OPT_NOLOCK
argument_list|)
operator|!=
name|NULL
condition|)
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_NONLM
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MNT2_NFS_OPT_NONLM)&& defined(MNTTAB_OPT_NOLOCK) */
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_OPTSTR
name|nap
operator|->
name|optstr
operator|=
name|mntp
operator|->
name|mnt_opts
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_OPTSTR */
comment|/************************************************************************/
comment|/***	FINAL ACTIONS							***/
comment|/************************************************************************/
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_GFS_FLAGS
comment|/* Ultrix stores generic flags in nfs_args.gfs_flags. */
name|nap
operator|->
name|gfs_flags
operator|=
name|genflags
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_FLAGS */
return|return;
comment|/* end of compute_nfs_args() function */
block|}
end_function

begin_comment
comment|/*  * Fill in special values for flags and fields of nfs_args, for an  * automounter NFS mount.  */
end_comment

begin_function
name|void
name|compute_automounter_nfs_args
parameter_list|(
name|nfs_args_t
modifier|*
name|nap
parameter_list|,
name|mntent_t
modifier|*
name|mntp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_SYMTTL
comment|/*    * Don't let the kernel cache symbolic links we generate, or else lookups    * will bypass amd and fail to remount stuff as needed.    */
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"turning on NFS option symttl and setting value to 0"
argument_list|)
expr_stmt|;
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_SYMTTL
expr_stmt|;
name|nap
operator|->
name|symttl
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_SYMTTL */
comment|/*    * This completes the flags for the HIDE_MOUNT_TYPE  code in the    * mount_amfs_toplvl() function in amd/amfs_toplvl.c.    * Some systems don't have a mount type, but a mount flag.    */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_AUTO
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_AUTO
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_AUTO */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_IGNORE
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_IGNORE
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_IGNORE */
ifdef|#
directive|ifdef
name|MNT2_GEN_OPT_AUTOMNTFS
name|nap
operator|->
name|flags
operator||=
name|MNT2_GEN_OPT_AUTOMNTFS
expr_stmt|;
endif|#
directive|endif
comment|/* not MNT2_GEN_OPT_AUTOMNTFS */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_DUMBTIMR
comment|/*    * Don't let the kernel start computing throughput of Amd.  The numbers    * will be meaningless because of the way Amd does mount retries.    */
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"%s: disabling nfs congestion window"
argument_list|,
name|mntp
operator|->
name|mnt_dir
argument_list|)
expr_stmt|;
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_DUMBTIMR
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_DUMBTIMR */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_NOAC
comment|/*    * Don't cache attributes - they are changing under the kernel's feet.    * For example, IRIX5.2 will dispense with nfs lookup calls and hand stale    * filehandles to getattr unless we disable attribute caching on the    * automount points.    */
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_NOAC
expr_stmt|;
else|#
directive|else
comment|/* not MNT2_NFS_OPT_NOAC */
comment|/*    * Setting these to 0 results in an error on some systems, which is why    * it's better to use "noac" if possible.    */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_NFS_OPT_ACREGMIN
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNT2_NFS_OPT_ACREGMAX
argument_list|)
name|nap
operator|->
name|acregmin
operator|=
name|nap
operator|->
name|acregmax
operator|=
literal|0
expr_stmt|;
comment|/* XXX: was 1, but why? */
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_ACREGMIN
operator||
name|MNT2_NFS_OPT_ACREGMAX
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MNT2_NFS_OPT_ACREGMIN)&& defined(MNT2_NFS_OPT_ACREGMAX) */
if|#
directive|if
name|defined
argument_list|(
name|MNT2_NFS_OPT_ACDIRMIN
argument_list|)
operator|&&
name|defined
argument_list|(
name|MNT2_NFS_OPT_ACDIRMAX
argument_list|)
name|nap
operator|->
name|acdirmin
operator|=
name|nap
operator|->
name|acdirmax
operator|=
literal|0
expr_stmt|;
comment|/* XXX: was 1, but why? */
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_ACDIRMIN
operator||
name|MNT2_NFS_OPT_ACDIRMAX
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MNT2_NFS_OPT_ACDIRMIN)&& defined(MNT2_NFS_OPT_ACDIRMAX) */
endif|#
directive|endif
comment|/* not MNT2_NFS_OPT_NOAC */
comment|/*    * Provide a slight bit more security by requiring the kernel to use    * reserved ports.    */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_RESVPORT
name|nap
operator|->
name|flags
operator||=
name|MNT2_NFS_OPT_RESVPORT
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_RESVPORT */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/* get string version (in hex) of identifier */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_hex_string
parameter_list|(
name|u_int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|fhdata
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
comment|/* better not go over it! */
name|char
name|str
index|[
literal|16
index|]
decl_stmt|;
name|short
name|int
name|arr
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|fhdata
condition|)
return|return
name|NULL
return|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|memset
argument_list|(
operator|&
name|arr
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
operator|(
literal|64
operator|*
expr|sizeof
operator|(
name|short
name|int
operator|)
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|arr
index|[
literal|0
index|]
argument_list|,
operator|&
name|fhdata
index|[
literal|0
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|/
expr|sizeof
operator|(
name|short
name|int
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%04x"
argument_list|,
name|ntohs
argument_list|(
name|arr
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/*  * print a subset of fields from "struct nfs_args" that are otherwise  * not being provided anywhere else.  */
end_comment

begin_function
name|void
name|print_nfs_args
parameter_list|(
specifier|const
name|nfs_args_t
modifier|*
name|nap
parameter_list|,
name|u_long
name|nfs_version
parameter_list|)
block|{
name|int
name|fhlen
init|=
literal|32
decl_stmt|;
comment|/* default: NFS V.2 file handle length is 32 */
ifdef|#
directive|ifdef
name|HAVE_TRANSPORT_TYPE_TLI
name|struct
name|netbuf
modifier|*
name|nbp
decl_stmt|;
name|struct
name|knetconfig
modifier|*
name|kncp
decl_stmt|;
else|#
directive|else
comment|/* not HAVE_TRANSPORT_TYPE_TLI */
name|struct
name|sockaddr_in
modifier|*
name|sap
decl_stmt|;
endif|#
directive|endif
comment|/* not HAVE_TRANSPORT_TYPE_TLI */
if|if
condition|(
operator|!
name|nap
condition|)
block|{
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NULL nfs_args!"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* override default file handle size */
ifdef|#
directive|ifdef
name|FHSIZE
name|fhlen
operator|=
name|FHSIZE
expr_stmt|;
endif|#
directive|endif
comment|/* FHSIZE */
ifdef|#
directive|ifdef
name|NFS_FHSIZE
name|fhlen
operator|=
name|NFS_FHSIZE
expr_stmt|;
endif|#
directive|endif
comment|/* NFS_FHSIZE */
ifdef|#
directive|ifdef
name|HAVE_TRANSPORT_TYPE_TLI
name|nbp
operator|=
name|nap
operator|->
name|addr
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->addr {netbuf} (maxlen=%d, len=%d) = \"%s\""
argument_list|,
name|nbp
operator|->
name|maxlen
argument_list|,
name|nbp
operator|->
name|len
argument_list|,
name|get_hex_string
argument_list|(
name|nbp
operator|->
name|len
argument_list|,
name|nbp
operator|->
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|nbp
operator|=
name|nap
operator|->
name|syncaddr
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->syncaddr {netbuf} 0x%x"
argument_list|,
operator|(
name|int
operator|)
name|nbp
argument_list|)
expr_stmt|;
name|kncp
operator|=
name|nap
operator|->
name|knconf
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->knconf->semantics %lu"
argument_list|,
operator|(
name|u_long
operator|)
name|kncp
operator|->
name|knc_semantics
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->knconf->protofmly \"%s\""
argument_list|,
name|kncp
operator|->
name|knc_protofmly
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->knconf->proto \"%s\""
argument_list|,
name|kncp
operator|->
name|knc_proto
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->knconf->rdev %lu"
argument_list|,
operator|(
name|u_long
operator|)
name|kncp
operator|->
name|knc_rdev
argument_list|)
expr_stmt|;
comment|/* don't print knconf->unused field */
else|#
directive|else
comment|/* not HAVE_TRANSPORT_TYPE_TLI */
name|sap
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|nap
operator|->
name|addr
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->addr {sockaddr_in} (len=%d) = \"%s\""
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|,
name|get_hex_string
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|sap
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRUCT_SOCKADDR_SA_LEN
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->addr.sin_len = \"%d\""
argument_list|,
name|sap
operator|->
name|sin_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_STRUCT_SOCKADDR_SA_LEN */
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->addr.sin_family = \"%d\""
argument_list|,
name|sap
operator|->
name|sin_family
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->addr.sin_port = \"%d\""
argument_list|,
name|sap
operator|->
name|sin_port
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->addr.sin_addr = \"%s\""
argument_list|,
name|get_hex_string
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|sap
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_TRANSPORT_TYPE_TLI */
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->hostname = \"%s\""
argument_list|,
name|nap
operator|->
name|hostname
condition|?
name|nap
operator|->
name|hostname
else|:
literal|"null"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_NAMLEN
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->namlen = %d"
argument_list|,
name|nap
operator|->
name|namlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_NAMLEN */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_FSNAME
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->fsname = \"%s\""
argument_list|,
name|nap
operator|->
name|fsname
condition|?
name|nap
operator|->
name|fsname
else|:
literal|"null"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_FSNAME */
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_FHSIZE
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->fhsize = %d"
argument_list|,
name|nap
operator|->
name|fhsize
argument_list|)
expr_stmt|;
name|fhlen
operator|=
name|nap
operator|->
name|fhsize
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_FHSIZE */
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_FH_LEN
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->fh_len = %d"
argument_list|,
name|nap
operator|->
name|fh_len
argument_list|)
expr_stmt|;
name|fhlen
operator|=
name|nap
operator|->
name|fh_len
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_FH_LEN */
comment|/*    * XXX: need to figure out how to correctly print file handles,    * since some times they are pointers, and sometimes the real structure    * is stored in nfs_args.  Even if it is a pointer, it can be the actual    * char[] array, or a structure containing multiple fields.    */
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->filehandle = \"%s\""
argument_list|,
name|get_hex_string
argument_list|(
name|fhlen
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|nap
operator|->
name|NFS_FH_FIELD
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_SOTYPE
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->sotype = %d"
argument_list|,
name|nap
operator|->
name|sotype
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_SOTYPE */
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_PROTO
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->proto = %d"
argument_list|,
operator|(
name|int
operator|)
name|nap
operator|->
name|proto
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_PROTO */
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_VERSION
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->version = %d"
argument_list|,
name|nap
operator|->
name|version
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_VERSION */
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->flags = 0x%x"
argument_list|,
operator|(
name|int
operator|)
name|nap
operator|->
name|flags
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->rsize = %d"
argument_list|,
operator|(
name|int
operator|)
name|nap
operator|->
name|rsize
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->wsize = %d"
argument_list|,
operator|(
name|int
operator|)
name|nap
operator|->
name|wsize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_BSIZE
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->bsize = %d"
argument_list|,
name|nap
operator|->
name|bsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_BSIZE */
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->timeo = %d"
argument_list|,
operator|(
name|int
operator|)
name|nap
operator|->
name|timeo
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->retrans = %d"
argument_list|,
operator|(
name|int
operator|)
name|nap
operator|->
name|retrans
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_NFS_ARGS_T_ACREGMIN
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->acregmin = %d"
argument_list|,
operator|(
name|int
operator|)
name|nap
operator|->
name|acregmin
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->acregmax = %d"
argument_list|,
operator|(
name|int
operator|)
name|nap
operator|->
name|acregmax
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->acdirmin = %d"
argument_list|,
operator|(
name|int
operator|)
name|nap
operator|->
name|acdirmin
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->acdirmax = %d"
argument_list|,
operator|(
name|int
operator|)
name|nap
operator|->
name|acdirmax
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_NFS_ARGS_T_ACREGMIN */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_SYMTTL
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->symttl = %d"
argument_list|,
name|nap
operator|->
name|symttl
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_OPT_SYMTTL */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_PG_THRESH
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->pg_thresh = %d"
argument_list|,
name|nap
operator|->
name|pg_thresh
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_OPT_PG_THRESH */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_BIODS
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"NA->biods = %d"
argument_list|,
name|nap
operator|->
name|biods
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_BIODS */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

end_unit

