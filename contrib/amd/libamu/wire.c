begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997-1999 Erez Zadok  * Copyright (c) 1990 Jan-Simon Pendry  * Copyright (c) 1990 Imperial College of Science, Technology& Medicine  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry at Imperial College, London.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgment:  *      This product includes software developed by the University of  *      California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      %W% (Berkeley) %G%  *  * $Id: wire.c,v 1.5 1999/09/08 23:36:52 ezk Exp $  *  */
end_comment

begin_comment
comment|/*  * This function returns the subnet (address&netmask) for the primary network  * interface.  If the resulting address has an entry in the hosts file, the  * corresponding name is returned, otherwise the address is returned in  * standard internet format.  * As a side-effect, a list of local IP/net address is recorded for use  * by the islocalnet() function.  *  * Derived from original by Paul Anderson (23/4/90)  * Updates from Dirk Grunwald (11/11/91)  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<am_defs.h>
end_include

begin_include
include|#
directive|include
file|<amu.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_IFADDRS_H
end_ifdef

begin_include
include|#
directive|include
file|<ifaddrs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_IFADDRS_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_IRS_H
end_ifdef

begin_include
include|#
directive|include
file|<irs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_IRS_H */
end_comment

begin_comment
comment|/*  * List of locally connected networks  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|addrlist
name|addrlist
typedef|;
end_typedef

begin_struct
struct|struct
name|addrlist
block|{
name|addrlist
modifier|*
name|ip_next
decl_stmt|;
name|u_long
name|ip_addr
decl_stmt|;
comment|/* address of network */
name|u_long
name|ip_mask
decl_stmt|;
name|char
modifier|*
name|ip_net_num
decl_stmt|;
comment|/* number of network */
name|char
modifier|*
name|ip_net_name
decl_stmt|;
comment|/* name of network */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|addrlist
modifier|*
name|localnets
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|IFF_LOCAL_LOOPBACK
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|IFF_LOOPBACK
argument_list|)
end_if

begin_define
define|#
directive|define
name|IFF_LOOPBACK
value|IFF_LOCAL_LOOPBACK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(IFF_LOCAL_LOOPBACK)&& !defined(IFF_LOOPBACK) */
end_comment

begin_define
define|#
directive|define
name|C
parameter_list|(
name|x
parameter_list|)
value|((x)& 0xff)
end_define

begin_define
define|#
directive|define
name|GFBUFLEN
value|1024
end_define

begin_define
define|#
directive|define
name|S2IN
parameter_list|(
name|s
parameter_list|)
value|(((struct sockaddr_in *)(s))->sin_addr.s_addr)
end_define

begin_comment
comment|/* return malloc'ed buffer.  caller must free it */
end_comment

begin_function
name|char
modifier|*
name|print_wires
parameter_list|(
name|void
parameter_list|)
block|{
name|addrlist
modifier|*
name|al
decl_stmt|;
name|char
name|s
index|[
literal|256
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|bufcount
init|=
literal|0
decl_stmt|;
name|int
name|buf_size
init|=
literal|1024
decl_stmt|;
name|buf
operator|=
name|SALLOC
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|localnets
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"No networks.\n"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
comment|/* check if there's more than one network */
if|if
condition|(
operator|!
name|localnets
operator|->
name|ip_next
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Network: wire=\"%s\" (netnumber=%s).\n"
argument_list|,
name|localnets
operator|->
name|ip_net_name
argument_list|,
name|localnets
operator|->
name|ip_net_num
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* null out buffer before appending */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|al
operator|=
name|localnets
init|;
name|al
condition|;
name|al
operator|=
name|al
operator|->
name|ip_next
operator|,
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"Network %d: wire=\"%s\" (netnumber=%s).\n"
argument_list|,
name|i
argument_list|,
name|al
operator|->
name|ip_net_name
argument_list|,
name|al
operator|->
name|ip_net_num
argument_list|)
expr_stmt|;
name|bufcount
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufcount
operator|>
name|buf_size
condition|)
block|{
name|buf_size
operator|*=
literal|2
expr_stmt|;
name|buf
operator|=
name|xrealloc
argument_list|(
name|buf
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|buf
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|addrlist
modifier|*
name|getwire_lookup
parameter_list|(
name|u_long
name|address
parameter_list|,
name|u_long
name|netmask
parameter_list|,
name|int
name|ishost
parameter_list|)
block|{
name|struct
name|addrlist
modifier|*
name|al
decl_stmt|;
name|u_long
name|subnet
decl_stmt|;
name|char
name|netNumberBuf
index|[
literal|64
index|]
decl_stmt|;
name|char
name|buf
index|[
name|GFBUFLEN
index|]
decl_stmt|,
modifier|*
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_IRS_H
name|struct
name|nwent
modifier|*
name|np
decl_stmt|;
else|#
directive|else
comment|/* not HAVE_IRS_H */
name|struct
name|netent
modifier|*
name|np
decl_stmt|;
endif|#
directive|endif
comment|/* not HAVE_IRS_H */
comment|/*    * Add interface to local network singly linked list    */
name|al
operator|=
name|ALLOC
argument_list|(
expr|struct
name|addrlist
argument_list|)
expr_stmt|;
name|al
operator|->
name|ip_addr
operator|=
name|address
expr_stmt|;
name|al
operator|->
name|ip_mask
operator|=
name|netmask
expr_stmt|;
name|al
operator|->
name|ip_net_name
operator|=
name|NO_SUBNET
expr_stmt|;
comment|/* fill in a bit later */
name|al
operator|->
name|ip_net_num
operator|=
literal|"0.0.0.0"
expr_stmt|;
comment|/* fill in a bit later */
name|al
operator|->
name|ip_next
operator|=
name|NULL
expr_stmt|;
name|subnet
operator|=
name|ntohl
argument_list|(
name|address
argument_list|)
operator|&
name|ntohl
argument_list|(
name|netmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|ishost
condition|)
name|np
operator|=
name|NULL
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_IRS_H
name|u_long
name|mask
init|=
name|ntohl
argument_list|(
name|netmask
argument_list|)
decl_stmt|;
specifier|static
name|struct
name|irs_acc
modifier|*
name|irs_gen
decl_stmt|;
specifier|static
name|struct
name|irs_nw
modifier|*
name|irs_nw
decl_stmt|;
name|u_long
name|net
decl_stmt|;
name|int
name|maskbits
decl_stmt|;
name|u_char
name|addr
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|irs_gen
operator|==
name|NULL
condition|)
name|irs_gen
operator|=
name|irs_gen_acc
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|irs_gen
operator|&&
name|irs_nw
operator|==
name|NULL
condition|)
name|irs_nw
operator|=
call|(
modifier|*
name|irs_gen
operator|->
name|nw_map
call|)
argument_list|(
name|irs_gen
argument_list|)
expr_stmt|;
name|net
operator|=
name|ntohl
argument_list|(
name|address
argument_list|)
operator|&
operator|(
name|mask
operator|=
name|ntohl
argument_list|(
name|netmask
argument_list|)
operator|)
expr_stmt|;
name|addr
index|[
literal|0
index|]
operator|=
operator|(
literal|0xFF000000
operator|&
name|net
operator|)
operator|>>
literal|24
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
operator|(
literal|0x00FF0000
operator|&
name|net
operator|)
operator|>>
literal|16
expr_stmt|;
name|addr
index|[
literal|2
index|]
operator|=
operator|(
literal|0x0000FF00
operator|&
name|net
operator|)
operator|>>
literal|8
expr_stmt|;
name|addr
index|[
literal|3
index|]
operator|=
operator|(
literal|0x000000FF
operator|&
name|net
operator|)
expr_stmt|;
for|for
control|(
name|maskbits
operator|=
literal|32
init|;
operator|!
operator|(
name|mask
operator|&
literal|1
operator|)
condition|;
name|mask
operator|>>=
literal|1
control|)
name|maskbits
operator|--
expr_stmt|;
name|np
operator|=
call|(
modifier|*
name|irs_nw
operator|->
name|byaddr
call|)
argument_list|(
name|irs_nw
argument_list|,
name|addr
argument_list|,
name|maskbits
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_IRS_H */
name|np
operator|=
name|getnetbyaddr
argument_list|(
name|subnet
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
comment|/*      * Some systems (IRIX 6.4) cannot getnetbyaddr on networks such as      * "128.59.16.0".  Instead, they need to look for the short form of      * the network, "128.59.16".  So if the first getnetbyaddr failed, we      * shift the subnet way from zeros and try again.      */
if|if
condition|(
operator|!
name|np
condition|)
block|{
name|u_long
name|short_subnet
init|=
name|subnet
decl_stmt|;
while|while
condition|(
name|short_subnet
operator|&&
operator|(
name|short_subnet
operator|&
literal|0x000000ff
operator|)
operator|==
literal|0
condition|)
name|short_subnet
operator|>>=
literal|8
expr_stmt|;
name|np
operator|=
name|getnetbyaddr
argument_list|(
name|short_subnet
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
condition|)
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"getnetbyaddr failed on 0x%x, succeeded on 0x%x"
argument_list|,
operator|(
name|u_int
operator|)
name|subnet
argument_list|,
operator|(
name|u_int
operator|)
name|short_subnet
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not HAVE_IRS_H */
block|}
if|if
condition|(
operator|(
name|subnet
operator|&
literal|0xffffff
operator|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|netNumberBuf
argument_list|,
literal|"%lu"
argument_list|,
name|C
argument_list|(
name|subnet
operator|>>
literal|24
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|subnet
operator|&
literal|0xffff
operator|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|netNumberBuf
argument_list|,
literal|"%lu.%lu"
argument_list|,
name|C
argument_list|(
name|subnet
operator|>>
literal|24
argument_list|)
argument_list|,
name|C
argument_list|(
name|subnet
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|subnet
operator|&
literal|0xff
operator|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|netNumberBuf
argument_list|,
literal|"%lu.%lu.%lu"
argument_list|,
name|C
argument_list|(
name|subnet
operator|>>
literal|24
argument_list|)
argument_list|,
name|C
argument_list|(
name|subnet
operator|>>
literal|16
argument_list|)
argument_list|,
name|C
argument_list|(
name|subnet
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|netNumberBuf
argument_list|,
literal|"%lu.%lu.%lu.%lu"
argument_list|,
name|C
argument_list|(
name|subnet
operator|>>
literal|24
argument_list|)
argument_list|,
name|C
argument_list|(
name|subnet
operator|>>
literal|16
argument_list|)
argument_list|,
name|C
argument_list|(
name|subnet
operator|>>
literal|8
argument_list|)
argument_list|,
name|C
argument_list|(
name|subnet
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* fill in network number (string) */
name|al
operator|->
name|ip_net_num
operator|=
name|strdup
argument_list|(
name|netNumberBuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|!=
name|NULL
condition|)
name|s
operator|=
name|np
operator|->
name|n_name
expr_stmt|;
else|else
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|subnet
operator|=
name|address
operator|&
name|netmask
expr_stmt|;
name|hp
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|subnet
argument_list|,
literal|4
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|hp
operator|->
name|h_name
expr_stmt|;
else|else
name|s
operator|=
name|inet_dquad
argument_list|(
name|buf
argument_list|,
name|subnet
argument_list|)
expr_stmt|;
block|}
comment|/* fill in network name (string) */
name|al
operator|->
name|ip_net_name
operator|=
name|strdup
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|al
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make a dotted quad from a 32bit IP address  * addr is in network byte order.  * sizeof(buf) needs to be at least 16.  */
end_comment

begin_function
name|char
modifier|*
name|inet_dquad
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|u_long
name|addr
parameter_list|)
block|{
name|addr
operator|=
name|ntohl
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld.%ld.%ld.%ld"
argument_list|,
operator|(
operator|(
name|addr
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
argument_list|,
operator|(
operator|(
name|addr
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
argument_list|,
operator|(
operator|(
name|addr
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
argument_list|,
operator|(
operator|(
name|addr
operator|>>
literal|0
operator|)
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/*  * Determine whether a network is on a local network  * (addr) is in network byte order.  */
end_comment

begin_function
name|int
name|islocalnet
parameter_list|(
name|u_long
name|addr
parameter_list|)
block|{
name|addrlist
modifier|*
name|al
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
for|for
control|(
name|al
operator|=
name|localnets
init|;
name|al
condition|;
name|al
operator|=
name|al
operator|->
name|ip_next
control|)
if|if
condition|(
operator|(
operator|(
name|addr
operator|^
name|al
operator|->
name|ip_addr
operator|)
operator|&
name|al
operator|->
name|ip_mask
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"%s is on a remote network"
argument_list|,
name|inet_dquad
argument_list|(
name|buf
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * Determine whether a network name is one of the local networks  * of a host.  */
end_comment

begin_function
name|int
name|is_network_member
parameter_list|(
specifier|const
name|char
modifier|*
name|net
parameter_list|)
block|{
name|addrlist
modifier|*
name|al
decl_stmt|;
for|for
control|(
name|al
operator|=
name|localnets
init|;
name|al
condition|;
name|al
operator|=
name|al
operator|->
name|ip_next
control|)
if|if
condition|(
name|STREQ
argument_list|(
name|net
argument_list|,
name|al
operator|->
name|ip_net_name
argument_list|)
operator|||
name|STREQ
argument_list|(
name|net
argument_list|,
name|al
operator|->
name|ip_net_num
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETIFADDRS
end_ifdef

begin_function
name|void
name|getwire
parameter_list|(
name|char
modifier|*
modifier|*
name|name1
parameter_list|,
name|char
modifier|*
modifier|*
name|number1
parameter_list|)
block|{
name|addrlist
modifier|*
name|al
init|=
name|NULL
decl_stmt|,
modifier|*
name|tail
init|=
name|NULL
decl_stmt|;
name|struct
name|ifaddrs
modifier|*
name|ifaddrs
decl_stmt|,
modifier|*
name|ifap
decl_stmt|;
ifndef|#
directive|ifndef
name|HAVE_FIELD_STRUCT_IFADDRS_IFA_NEXT
name|int
name|count
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
endif|#
directive|endif
comment|/* not HAVE_FIELD_STRUCT_IFADDRS_IFA_NEXT */
name|ifaddrs
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FIELD_STRUCT_IFADDRS_IFA_NEXT
if|if
condition|(
name|getifaddrs
argument_list|(
operator|&
name|ifaddrs
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|ifap
operator|=
name|ifaddrs
init|;
name|ifap
operator|!=
name|NULL
condition|;
name|ifap
operator|=
name|ifap
operator|->
name|ifa_next
control|)
block|{
else|#
directive|else
comment|/* not HAVE_FIELD_STRUCT_IFADDRS_IFA_NEXT */
if|if
condition|(
name|getifaddrs
argument_list|(
operator|&
name|ifaddrs
argument_list|,
operator|&
name|count
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ifap
operator|=
name|ifaddrs
init|;
name|i
operator|<
name|count
condition|;
name|ifap
operator|++
operator|,
name|i
operator|++
control|)
block|{
endif|#
directive|endif
comment|/* HAVE_FIELD_STRUCT_IFADDRS_IFA_NEXT */
if|if
condition|(
operator|!
name|ifap
operator|||
operator|!
name|ifap
operator|->
name|ifa_addr
operator|||
name|ifap
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
continue|continue;
comment|/*      * If the interface is a loopback, or its not running      * then ignore it.      */
if|if
condition|(
operator|(
name|ifap
operator|->
name|ifa_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ifap
operator|->
name|ifa_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ifap
operator|->
name|ifa_flags
operator|&
name|IFF_POINTOPOINT
operator|)
operator|==
literal|0
condition|)
name|al
operator|=
name|getwire_lookup
argument_list|(
name|S2IN
argument_list|(
name|ifap
operator|->
name|ifa_addr
argument_list|)
argument_list|,
name|S2IN
argument_list|(
name|ifap
operator|->
name|ifa_netmask
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|al
operator|=
name|getwire_lookup
argument_list|(
name|S2IN
argument_list|(
name|ifap
operator|->
name|ifa_dstaddr
argument_list|)
argument_list|,
literal|0xffffffff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* append to the end of the list */
if|if
condition|(
operator|!
name|localnets
condition|)
block|{
name|localnets
operator|=
name|tail
operator|=
name|al
expr_stmt|;
name|tail
operator|->
name|ip_next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|tail
operator|->
name|ip_next
operator|=
name|al
expr_stmt|;
name|tail
operator|=
name|al
expr_stmt|;
block|}
block|}
name|out
label|:
if|if
condition|(
name|ifaddrs
condition|)
name|XFREE
argument_list|(
name|ifaddrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|localnets
condition|)
block|{
operator|*
name|name1
operator|=
name|localnets
operator|->
name|ip_net_name
expr_stmt|;
operator|*
name|number1
operator|=
name|localnets
operator|->
name|ip_net_num
expr_stmt|;
block|}
else|else
block|{
operator|*
name|name1
operator|=
name|NO_SUBNET
expr_stmt|;
operator|*
name|number1
operator|=
literal|"0.0.0.0"
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* not HAVE_GETIFADDRS */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_FIELD_STRUCT_IFREQ_IFR_ADDR
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_FIELD_STRUCT_SOCKADDR_SA_LEN
argument_list|)
define|#
directive|define
name|SIZE
parameter_list|(
name|ifr
parameter_list|)
value|(MAX((ifr)->ifr_addr.sa_len, sizeof((ifr)->ifr_addr)) + sizeof(ifr->ifr_name))
else|#
directive|else
comment|/* not defined(HAVE_FIELD_STRUCT_IFREQ_IFR_ADDR)&& defined(HAVE_FIELD_STRUCT_SOCKADDR_SA_LEN) */
define|#
directive|define
name|SIZE
parameter_list|(
name|ifr
parameter_list|)
value|sizeof(struct ifreq)
endif|#
directive|endif
comment|/* not defined(HAVE_FIELD_STRUCT_IFREQ_IFR_ADDR)&& defined(HAVE_FIELD_STRUCT_SOCKADDR_SA_LEN) */
define|#
directive|define
name|clist
value|(ifc.ifc_ifcu.ifcu_req)
define|#
directive|define
name|count
value|(ifc.ifc_len/sizeof(struct ifreq))
name|void
name|getwire
parameter_list|(
name|char
modifier|*
modifier|*
name|name1
parameter_list|,
name|char
modifier|*
modifier|*
name|number1
parameter_list|)
block|{
name|struct
name|ifconf
name|ifc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|caddr_t
name|cp
decl_stmt|,
name|cplim
decl_stmt|;
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
name|u_long
name|address
decl_stmt|;
name|addrlist
modifier|*
name|al
init|=
name|NULL
decl_stmt|,
modifier|*
name|tail
init|=
name|NULL
decl_stmt|;
name|char
name|buf
index|[
name|GFBUFLEN
index|]
decl_stmt|;
if|#
directive|if
literal|0
block|u_long net;   u_long mask;   u_long subnetshift;   char buf[GFBUFLEN], *s;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SIOCGIFFLAGS
comment|/* if cannot get interface flags, return nothing */
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"getwire unable to get interface flags"
argument_list|)
expr_stmt|;
name|localnets
operator|=
name|NULL
expr_stmt|;
return|return;
endif|#
directive|endif
comment|/* not SIOCGIFFLAGS */
comment|/*    * Get suitable socket    */
if|if
condition|(
operator|(
name|fd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/*    * Fill in ifconf details    */
name|memset
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|GFBUFLEN
argument_list|)
expr_stmt|;
name|ifc
operator|.
name|ifc_len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ifc
operator|.
name|ifc_buf
operator|=
name|buf
expr_stmt|;
comment|/*    * Get network interface configurations    */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGIFCONF
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifc
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/*    * Upper bound on array    */
name|cplim
operator|=
name|buf
operator|+
name|ifc
operator|.
name|ifc_len
expr_stmt|;
comment|/*    * This is some magic to cope with both "traditional" and the    * new 4.4BSD-style struct sockaddrs.  The new structure has    * variable length and a size field to support longer addresses.    * AF_LINK is a new definition for 4.4BSD.    */
comment|/*    * Scan the list looking for a suitable interface    */
for|for
control|(
name|cp
operator|=
name|buf
init|;
name|cp
operator|<
name|cplim
condition|;
name|cp
operator|+=
name|SIZE
argument_list|(
name|ifr
argument_list|)
control|)
block|{
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|cp
expr_stmt|;
if|if
condition|(
name|ifr
operator|->
name|ifr_addr
operator|.
name|sa_family
operator|!=
name|AF_INET
condition|)
continue|continue;
name|address
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifr
operator|->
name|ifr_addr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
comment|/*      * Get interface flags      */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|(
name|caddr_t
operator|)
name|ifr
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
comment|/*      * If the interface is a loopback, or its not running      * then ignore it.      */
ifdef|#
directive|ifdef
name|IFF_LOOPBACK
if|if
condition|(
operator|(
name|ifr
operator|->
name|ifr_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|!=
literal|0
condition|)
continue|continue;
endif|#
directive|endif
comment|/* IFF_LOOPBACK */
comment|/*      * Fix for 0.0.0.0 loopback on SunOS 3.X which defines IFF_ROUTE      * instead of IFF_LOOPBACK.      */
ifdef|#
directive|ifdef
name|IFF_ROUTE
if|if
condition|(
name|ifr
operator|->
name|ifr_flags
operator|==
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
condition|)
continue|continue;
endif|#
directive|endif
comment|/* IFF_ROUTE */
comment|/* if the interface is not UP or not RUNNING, skip it */
if|if
condition|(
operator|(
name|ifr
operator|->
name|ifr_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
operator|||
operator|(
name|ifr
operator|->
name|ifr_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ifr
operator|->
name|ifr_flags
operator|&
name|IFF_POINTOPOINT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/*        * Get the netmask of this interface        */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGIFNETMASK
argument_list|,
operator|(
name|caddr_t
operator|)
name|ifr
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
name|al
operator|=
name|getwire_lookup
argument_list|(
name|address
argument_list|,
name|S2IN
argument_list|(
operator|&
name|ifr
operator|->
name|ifr_addr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|al
operator|=
name|getwire_lookup
argument_list|(
name|address
argument_list|,
literal|0xffffffff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* append to the end of the list */
if|if
condition|(
operator|!
name|localnets
condition|)
block|{
name|localnets
operator|=
name|tail
operator|=
name|al
expr_stmt|;
name|tail
operator|->
name|ip_next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|tail
operator|->
name|ip_next
operator|=
name|al
expr_stmt|;
name|tail
operator|=
name|al
expr_stmt|;
block|}
block|}
name|out
label|:
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|localnets
condition|)
block|{
operator|*
name|name1
operator|=
name|localnets
operator|->
name|ip_net_name
expr_stmt|;
operator|*
name|number1
operator|=
name|localnets
operator|->
name|ip_net_num
expr_stmt|;
block|}
else|else
block|{
operator|*
name|name1
operator|=
name|NO_SUBNET
expr_stmt|;
operator|*
name|number1
operator|=
literal|"0.0.0.0"
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_GETIFADDRS */
end_comment

end_unit

