begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997-2004 Erez Zadok  * Copyright (c) 1989 Jan-Simon Pendry  * Copyright (c) 1989 Imperial College of Science, Technology& Medicine  * Copyright (c) 1989 The Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgment:  *      This product includes software developed by the University of  *      California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      %W% (Berkeley) %G%  *  * $Id: fsi_util.c,v 1.3.2.6 2004/01/06 03:15:23 ezk Exp $  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<am_defs.h>
end_include

begin_include
include|#
directive|include
file|<fsi_data.h>
end_include

begin_include
include|#
directive|include
file|<fsinfo.h>
end_include

begin_comment
comment|/* static variables */
end_comment

begin_decl_stmt
specifier|static
name|int
name|show_range
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|col
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_shown
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_mmm
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|col_output
parameter_list|(
name|int
name|len
parameter_list|)
block|{
name|int
name|wrapped
init|=
literal|0
decl_stmt|;
name|col
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|col
operator|>
literal|77
condition|)
block|{
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|col
operator|=
name|len
expr_stmt|;
name|wrapped
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|wrapped
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_total
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|total_mmm
operator|!=
operator|-
name|show_range
operator|+
literal|1
condition|)
block|{
name|char
name|n
index|[
literal|8
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|total_mmm
operator|<
literal|0
condition|)
name|fputc
argument_list|(
literal|'*'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|n
argument_list|,
literal|"%d"
argument_list|,
name|total_shown
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|col_output
argument_list|(
name|len
argument_list|)
condition|)
name|fputc
argument_list|(
literal|' '
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|n
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|total_mmm
operator|=
operator|-
name|show_range
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|col_cleanup
parameter_list|(
name|int
name|eoj
parameter_list|)
block|{
if|if
condition|(
name|verbose
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|eoj
condition|)
block|{
name|show_total
argument_list|()
expr_stmt|;
name|fputs
argument_list|(
literal|")]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|col
condition|)
block|{
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Lots of ways of reporting errors...  */
end_comment

begin_function
name|void
name|error
parameter_list|(
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|col_cleanup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Error, "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lerror
parameter_list|(
name|ioloc
modifier|*
name|l
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|col_cleanup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|l
operator|->
name|i_file
argument_list|,
name|l
operator|->
name|i_line
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lwarning
parameter_list|(
name|ioloc
modifier|*
name|l
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|col_cleanup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|l
operator|->
name|i_file
argument_list|,
name|l
operator|->
name|i_line
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fatal
parameter_list|(
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|col_cleanup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Fatal, "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Debug log  */
end_comment

begin_function
name|void
name|fsi_log
parameter_list|(
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|0
condition|)
block|{
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'#'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stdout
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|info_hdr
parameter_list|(
name|FILE
modifier|*
name|ef
parameter_list|,
name|char
modifier|*
name|info
parameter_list|)
block|{
name|fprintf
argument_list|(
name|ef
argument_list|,
literal|"# *** NOTE: This file contains %s info\n"
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gen_hdr
parameter_list|(
name|FILE
modifier|*
name|ef
parameter_list|,
name|char
modifier|*
name|hn
parameter_list|)
block|{
name|fprintf
argument_list|(
name|ef
argument_list|,
literal|"# *** NOTE: Only for use on %s\n"
argument_list|,
name|hn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|make_banner
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|time_t
name|t
init|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|ctime
argument_list|(
operator|&
name|t
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\ # *** This file was automatically generated -- DO NOT EDIT HERE ***\n\ # \"%s\" run by %s@%s on %s\ #\n\ "
argument_list|,
name|progname
argument_list|,
name|username
argument_list|,
name|hostname
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|show_new
parameter_list|(
name|char
modifier|*
name|msg
parameter_list|)
block|{
if|if
condition|(
name|verbose
operator|<
literal|0
condition|)
return|return;
name|total_shown
operator|++
expr_stmt|;
if|if
condition|(
name|total_mmm
operator|>
name|show_range
condition|)
block|{
name|show_total
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|total_mmm
operator|==
literal|0
condition|)
block|{
name|fputc
argument_list|(
literal|'*'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|1
expr_stmt|;
block|}
name|total_mmm
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|show_area_being_processed
parameter_list|(
name|char
modifier|*
name|area
parameter_list|,
name|int
name|n
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|last_area
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|verbose
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|last_area
condition|)
block|{
if|if
condition|(
name|total_shown
condition|)
name|show_total
argument_list|()
expr_stmt|;
name|fputs
argument_list|(
literal|")"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|last_area
operator|||
operator|!
name|STREQ
argument_list|(
name|area
argument_list|,
name|last_area
argument_list|)
condition|)
block|{
if|if
condition|(
name|last_area
condition|)
block|{
name|col_cleanup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|total_shown
operator|=
literal|0
expr_stmt|;
name|total_mmm
operator|=
name|show_range
operator|+
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|col_output
argument_list|(
name|strlen
argument_list|(
name|area
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"[%s"
argument_list|,
name|area
argument_list|)
expr_stmt|;
name|last_area
operator|=
name|area
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|" ("
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|2
expr_stmt|;
name|show_range
operator|=
name|n
expr_stmt|;
name|total_mmm
operator|=
name|n
operator|+
literal|1
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Open a file with the given prefix and name  */
end_comment

begin_function
name|FILE
modifier|*
name|pref_open
parameter_list|(
name|char
modifier|*
name|pref
parameter_list|,
name|char
modifier|*
name|hn
parameter_list|,
name|void
function_decl|(
modifier|*
name|hdr
function_decl|)
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|char
name|p
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|FILE
modifier|*
name|ef
decl_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s%s"
argument_list|,
name|pref
argument_list|,
name|hn
argument_list|)
expr_stmt|;
name|fsi_log
argument_list|(
literal|"Writing %s info for %s to %s"
argument_list|,
name|pref
argument_list|,
name|hn
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ef
operator|=
name|fopen
argument_list|(
name|p
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
condition|)
block|{
call|(
modifier|*
name|hdr
call|)
argument_list|(
name|ef
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|make_banner
argument_list|(
name|ef
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"can't open %s for writing"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|ef
return|;
block|}
end_function

begin_function
name|int
name|pref_close
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
return|return
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Determine where Amd would automount the host/volname pair  */
end_comment

begin_function
name|void
name|compute_automount_point
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|host
modifier|*
name|hp
parameter_list|,
name|char
modifier|*
name|vn
parameter_list|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|autodir
argument_list|,
name|hp
operator|->
name|h_lochost
argument_list|,
name|vn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|xcalloc
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|s
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
name|i
argument_list|,
operator|(
name|unsigned
operator|)
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|fatal
argument_list|(
literal|"Out of memory"
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * Data constructors..  */
end_comment

begin_function
name|automount
modifier|*
name|new_automount
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|automount
modifier|*
name|ap
init|=
name|CALLOC
argument_list|(
expr|struct
name|automount
argument_list|)
decl_stmt|;
name|ap
operator|->
name|a_ioloc
operator|=
name|current_location
argument_list|()
expr_stmt|;
name|ap
operator|->
name|a_name
operator|=
name|name
expr_stmt|;
name|ap
operator|->
name|a_volname
operator|=
literal|0
expr_stmt|;
name|ap
operator|->
name|a_mount
operator|=
literal|0
expr_stmt|;
name|ap
operator|->
name|a_opts
operator|=
literal|0
expr_stmt|;
name|show_new
argument_list|(
literal|"automount"
argument_list|)
expr_stmt|;
return|return
name|ap
return|;
block|}
end_function

begin_function
name|auto_tree
modifier|*
name|new_auto_tree
parameter_list|(
name|char
modifier|*
name|def
parameter_list|,
name|qelem
modifier|*
name|ap
parameter_list|)
block|{
name|auto_tree
modifier|*
name|tp
init|=
name|CALLOC
argument_list|(
expr|struct
name|auto_tree
argument_list|)
decl_stmt|;
name|tp
operator|->
name|t_ioloc
operator|=
name|current_location
argument_list|()
expr_stmt|;
name|tp
operator|->
name|t_defaults
operator|=
name|def
expr_stmt|;
name|tp
operator|->
name|t_mount
operator|=
name|ap
expr_stmt|;
name|show_new
argument_list|(
literal|"auto_tree"
argument_list|)
expr_stmt|;
return|return
name|tp
return|;
block|}
end_function

begin_function
name|host
modifier|*
name|new_host
parameter_list|(
name|void
parameter_list|)
block|{
name|host
modifier|*
name|hp
init|=
name|CALLOC
argument_list|(
expr|struct
name|host
argument_list|)
decl_stmt|;
name|hp
operator|->
name|h_ioloc
operator|=
name|current_location
argument_list|()
expr_stmt|;
name|hp
operator|->
name|h_mask
operator|=
literal|0
expr_stmt|;
name|show_new
argument_list|(
literal|"host"
argument_list|)
expr_stmt|;
return|return
name|hp
return|;
block|}
end_function

begin_function
name|void
name|set_host
parameter_list|(
name|host
modifier|*
name|hp
parameter_list|,
name|int
name|k
parameter_list|,
name|char
modifier|*
name|v
parameter_list|)
block|{
name|int
name|m
init|=
literal|1
operator|<<
name|k
decl_stmt|;
if|if
condition|(
name|hp
operator|->
name|h_mask
operator|&
name|m
condition|)
block|{
name|yyerror
argument_list|(
literal|"host field \"%s\" already set"
argument_list|,
name|host_strings
index|[
name|k
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|hp
operator|->
name|h_mask
operator||=
name|m
expr_stmt|;
switch|switch
condition|(
name|k
condition|)
block|{
case|case
name|HF_HOST
case|:
block|{
name|char
modifier|*
name|p
init|=
name|strdup
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|dict_ent
modifier|*
name|de
init|=
name|dict_locate
argument_list|(
name|dict_of_hosts
argument_list|,
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
name|de
condition|)
name|yyerror
argument_list|(
literal|"duplicate host %s!"
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
name|dict_add
argument_list|(
name|dict_of_hosts
argument_list|,
name|v
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hp
argument_list|)
expr_stmt|;
name|hp
operator|->
name|h_hostname
operator|=
name|v
expr_stmt|;
name|domain_strip
argument_list|(
name|p
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|p
argument_list|,
literal|'.'
argument_list|)
operator|!=
literal|0
condition|)
name|XFREE
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|hp
operator|->
name|h_lochost
operator|=
name|p
expr_stmt|;
block|}
break|break;
case|case
name|HF_CONFIG
case|:
block|{
name|qelem
modifier|*
name|q
decl_stmt|;
name|qelem
modifier|*
name|vq
init|=
operator|(
name|qelem
operator|*
operator|)
name|v
decl_stmt|;
name|hp
operator|->
name|h_mask
operator|&=
operator|~
name|m
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|h_config
condition|)
name|q
operator|=
name|hp
operator|->
name|h_config
expr_stmt|;
else|else
name|q
operator|=
name|hp
operator|->
name|h_config
operator|=
name|new_que
argument_list|()
expr_stmt|;
name|ins_que
argument_list|(
name|vq
argument_list|,
name|q
operator|->
name|q_back
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HF_ETHER
case|:
block|{
name|qelem
modifier|*
name|q
decl_stmt|;
name|qelem
modifier|*
name|vq
init|=
operator|(
name|qelem
operator|*
operator|)
name|v
decl_stmt|;
name|hp
operator|->
name|h_mask
operator|&=
operator|~
name|m
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|h_ether
condition|)
name|q
operator|=
name|hp
operator|->
name|h_ether
expr_stmt|;
else|else
name|q
operator|=
name|hp
operator|->
name|h_ether
operator|=
name|new_que
argument_list|()
expr_stmt|;
name|ins_que
argument_list|(
name|vq
argument_list|,
name|q
operator|->
name|q_back
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HF_ARCH
case|:
name|hp
operator|->
name|h_arch
operator|=
name|v
expr_stmt|;
break|break;
case|case
name|HF_OS
case|:
name|hp
operator|->
name|h_os
operator|=
name|v
expr_stmt|;
break|break;
case|case
name|HF_CLUSTER
case|:
name|hp
operator|->
name|h_cluster
operator|=
name|v
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|ether_if
modifier|*
name|new_ether_if
parameter_list|(
name|void
parameter_list|)
block|{
name|ether_if
modifier|*
name|ep
init|=
name|CALLOC
argument_list|(
expr|struct
name|ether_if
argument_list|)
decl_stmt|;
name|ep
operator|->
name|e_mask
operator|=
literal|0
expr_stmt|;
name|ep
operator|->
name|e_ioloc
operator|=
name|current_location
argument_list|()
expr_stmt|;
name|show_new
argument_list|(
literal|"ether_if"
argument_list|)
expr_stmt|;
return|return
name|ep
return|;
block|}
end_function

begin_function
name|void
name|set_ether_if
parameter_list|(
name|ether_if
modifier|*
name|ep
parameter_list|,
name|int
name|k
parameter_list|,
name|char
modifier|*
name|v
parameter_list|)
block|{
name|int
name|m
init|=
literal|1
operator|<<
name|k
decl_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_mask
operator|&
name|m
condition|)
block|{
name|yyerror
argument_list|(
literal|"netif field \"%s\" already set"
argument_list|,
name|ether_if_strings
index|[
name|k
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|ep
operator|->
name|e_mask
operator||=
name|m
expr_stmt|;
switch|switch
condition|(
name|k
condition|)
block|{
case|case
name|EF_INADDR
case|:
block|{
name|ep
operator|->
name|e_inaddr
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_inaddr
operator|.
name|s_addr
operator|==
operator|(
name|u_long
operator|)
operator|-
literal|1
condition|)
name|yyerror
argument_list|(
literal|"malformed IP dotted quad: %s"
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EF_NETMASK
case|:
block|{
name|u_long
name|nm
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|sscanf
argument_list|(
name|v
argument_list|,
literal|"0x%lx"
argument_list|,
operator|&
name|nm
argument_list|)
operator|==
literal|1
operator|||
name|sscanf
argument_list|(
name|v
argument_list|,
literal|"%lx"
argument_list|,
operator|&
name|nm
argument_list|)
operator|==
literal|1
operator|)
operator|&&
name|nm
operator|!=
literal|0
condition|)
name|ep
operator|->
name|e_netmask
operator|=
name|htonl
argument_list|(
name|nm
argument_list|)
expr_stmt|;
else|else
name|yyerror
argument_list|(
literal|"malformed netmask: %s"
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EF_HWADDR
case|:
name|ep
operator|->
name|e_hwaddr
operator|=
name|v
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|set_disk_fs
parameter_list|(
name|disk_fs
modifier|*
name|dp
parameter_list|,
name|int
name|k
parameter_list|,
name|char
modifier|*
name|v
parameter_list|)
block|{
name|int
name|m
init|=
literal|1
operator|<<
name|k
decl_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_mask
operator|&
name|m
condition|)
block|{
name|yyerror
argument_list|(
literal|"fs field \"%s\" already set"
argument_list|,
name|disk_fs_strings
index|[
name|k
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|dp
operator|->
name|d_mask
operator||=
name|m
expr_stmt|;
switch|switch
condition|(
name|k
condition|)
block|{
case|case
name|DF_FSTYPE
case|:
name|dp
operator|->
name|d_fstype
operator|=
name|v
expr_stmt|;
break|break;
case|case
name|DF_OPTS
case|:
name|dp
operator|->
name|d_opts
operator|=
name|v
expr_stmt|;
break|break;
case|case
name|DF_DUMPSET
case|:
name|dp
operator|->
name|d_dumpset
operator|=
name|v
expr_stmt|;
break|break;
case|case
name|DF_LOG
case|:
name|dp
operator|->
name|d_log
operator|=
name|v
expr_stmt|;
break|break;
case|case
name|DF_PASSNO
case|:
name|dp
operator|->
name|d_passno
operator|=
name|atoi
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|DF_FREQ
case|:
name|dp
operator|->
name|d_freq
operator|=
name|atoi
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|XFREE
argument_list|(
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|DF_MOUNT
case|:
name|dp
operator|->
name|d_mount
operator|=
operator|&
operator|(
operator|(
name|fsi_mount
operator|*
operator|)
name|v
operator|)
operator|->
name|m_q
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|disk_fs
modifier|*
name|new_disk_fs
parameter_list|(
name|void
parameter_list|)
block|{
name|disk_fs
modifier|*
name|dp
init|=
name|CALLOC
argument_list|(
expr|struct
name|disk_fs
argument_list|)
decl_stmt|;
name|dp
operator|->
name|d_ioloc
operator|=
name|current_location
argument_list|()
expr_stmt|;
name|show_new
argument_list|(
literal|"disk_fs"
argument_list|)
expr_stmt|;
return|return
name|dp
return|;
block|}
end_function

begin_function
name|void
name|set_mount
parameter_list|(
name|fsi_mount
modifier|*
name|mp
parameter_list|,
name|int
name|k
parameter_list|,
name|char
modifier|*
name|v
parameter_list|)
block|{
name|int
name|m
init|=
literal|1
operator|<<
name|k
decl_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_mask
operator|&
name|m
condition|)
block|{
name|yyerror
argument_list|(
literal|"mount tree field \"%s\" already set"
argument_list|,
name|mount_strings
index|[
name|k
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|mp
operator|->
name|m_mask
operator||=
name|m
expr_stmt|;
switch|switch
condition|(
name|k
condition|)
block|{
case|case
name|DM_VOLNAME
case|:
name|dict_add
argument_list|(
name|dict_of_volnames
argument_list|,
name|v
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_volname
operator|=
name|v
expr_stmt|;
break|break;
case|case
name|DM_EXPORTFS
case|:
name|mp
operator|->
name|m_exportfs
operator|=
name|v
expr_stmt|;
break|break;
case|case
name|DM_SEL
case|:
name|mp
operator|->
name|m_sel
operator|=
name|v
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|fsi_mount
modifier|*
name|new_mount
parameter_list|(
name|void
parameter_list|)
block|{
name|fsi_mount
modifier|*
name|fp
init|=
name|CALLOC
argument_list|(
expr|struct
name|fsi_mount
argument_list|)
decl_stmt|;
name|fp
operator|->
name|m_ioloc
operator|=
name|current_location
argument_list|()
expr_stmt|;
name|show_new
argument_list|(
literal|"mount"
argument_list|)
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_function
name|void
name|set_fsmount
parameter_list|(
name|fsmount
modifier|*
name|fp
parameter_list|,
name|int
name|k
parameter_list|,
name|char
modifier|*
name|v
parameter_list|)
block|{
name|int
name|m
init|=
literal|1
operator|<<
name|k
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_mask
operator|&
name|m
condition|)
block|{
name|yyerror
argument_list|(
literal|"mount field \"%s\" already set"
argument_list|,
name|fsmount_strings
index|[
name|k
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|fp
operator|->
name|f_mask
operator||=
name|m
expr_stmt|;
switch|switch
condition|(
name|k
condition|)
block|{
case|case
name|FM_LOCALNAME
case|:
name|fp
operator|->
name|f_localname
operator|=
name|v
expr_stmt|;
break|break;
case|case
name|FM_VOLNAME
case|:
name|fp
operator|->
name|f_volname
operator|=
name|v
expr_stmt|;
break|break;
case|case
name|FM_FSTYPE
case|:
name|fp
operator|->
name|f_fstype
operator|=
name|v
expr_stmt|;
break|break;
case|case
name|FM_OPTS
case|:
name|fp
operator|->
name|f_opts
operator|=
name|v
expr_stmt|;
break|break;
case|case
name|FM_FROM
case|:
name|fp
operator|->
name|f_from
operator|=
name|v
expr_stmt|;
break|break;
case|case
name|FM_DIRECT
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|fsmount
modifier|*
name|new_fsmount
parameter_list|(
name|void
parameter_list|)
block|{
name|fsmount
modifier|*
name|fp
init|=
name|CALLOC
argument_list|(
expr|struct
name|fsmount
argument_list|)
decl_stmt|;
name|fp
operator|->
name|f_ioloc
operator|=
name|current_location
argument_list|()
expr_stmt|;
name|show_new
argument_list|(
literal|"fsmount"
argument_list|)
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_function
name|void
name|init_que
parameter_list|(
name|qelem
modifier|*
name|q
parameter_list|)
block|{
name|q
operator|->
name|q_forw
operator|=
name|q
operator|->
name|q_back
operator|=
name|q
expr_stmt|;
block|}
end_function

begin_function
name|qelem
modifier|*
name|new_que
parameter_list|(
name|void
parameter_list|)
block|{
name|qelem
modifier|*
name|q
init|=
name|CALLOC
argument_list|(
name|qelem
argument_list|)
decl_stmt|;
name|init_que
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|q
return|;
block|}
end_function

begin_function
name|void
name|ins_que
parameter_list|(
name|qelem
modifier|*
name|elem
parameter_list|,
name|qelem
modifier|*
name|pred
parameter_list|)
block|{
name|qelem
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|pred
operator|->
name|q_forw
expr_stmt|;
name|elem
operator|->
name|q_back
operator|=
name|pred
expr_stmt|;
name|elem
operator|->
name|q_forw
operator|=
name|p
expr_stmt|;
name|pred
operator|->
name|q_forw
operator|=
name|elem
expr_stmt|;
name|p
operator|->
name|q_back
operator|=
name|elem
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rem_que
parameter_list|(
name|qelem
modifier|*
name|elem
parameter_list|)
block|{
name|qelem
modifier|*
name|p
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|p
operator|=
name|elem
operator|->
name|q_forw
expr_stmt|;
name|p2
operator|=
name|elem
operator|->
name|q_back
expr_stmt|;
name|p2
operator|->
name|q_forw
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|q_back
operator|=
name|p2
expr_stmt|;
block|}
end_function

end_unit

