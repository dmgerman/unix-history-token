begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997-2014 Erez Zadok  * Copyright (c) 1989 Jan-Simon Pendry  * Copyright (c) 1989 Imperial College of Science, Technology& Medicine  * Copyright (c) 1989 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry at Imperial College, London.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *  * File: am-utils/hlfsd/stubs.c  *  * HLFSD was written at Columbia University Computer Science Department, by  * Erez Zadok<ezk@cs.columbia.edu> and Alexander Dupuy<dupuy@cs.columbia.edu>  * It is being distributed under the same terms and conditions as amd does.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<am_defs.h>
end_include

begin_include
include|#
directive|include
file|<hlfsd.h>
end_include

begin_comment
comment|/*  * STATIC VARIABLES:  */
end_comment

begin_decl_stmt
specifier|static
name|nfsfattr
name|rootfattr
init|=
block|{
name|NFDIR
block|,
literal|0040555
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|512
block|,
literal|512
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
name|ROOTID
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|nfsfattr
name|slinkfattr
init|=
block|{
name|NFLNK
block|,
literal|0120777
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|NFS_MAXPATHLEN
block|,
literal|512
block|,
literal|0
block|,
operator|(
name|NFS_MAXPATHLEN
operator|+
literal|1
operator|)
operator|/
literal|512
block|,
literal|0
block|,
name|SLINKID
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user name file attributes */
end_comment

begin_decl_stmt
specifier|static
name|nfsfattr
name|un_fattr
init|=
block|{
name|NFLNK
block|,
literal|0120777
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|NFS_MAXPATHLEN
block|,
literal|512
block|,
literal|0
block|,
operator|(
name|NFS_MAXPATHLEN
operator|+
literal|1
operator|)
operator|/
literal|512
block|,
literal|0
block|,
name|INVALIDID
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|started
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|am_nfs_fh
name|slink
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|am_nfs_fh
name|un_fhandle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * GLOBALS:  */
end_comment

begin_decl_stmt
name|am_nfs_fh
name|root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|am_nfs_fh
modifier|*
name|root_fhp
init|=
operator|&
name|root
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initialize NFS file handles for hlfsd */
end_comment

begin_function
name|void
name|hlfsd_init_filehandles
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|ui
decl_stmt|;
name|ui
operator|=
name|ROOTID
expr_stmt|;
name|memcpy
argument_list|(
name|root
operator|.
name|fh_data
argument_list|,
operator|&
name|ui
argument_list|,
sizeof|sizeof
argument_list|(
name|ui
argument_list|)
argument_list|)
expr_stmt|;
name|ui
operator|=
name|SLINKID
expr_stmt|;
name|memcpy
argument_list|(
name|slink
operator|.
name|fh_data
argument_list|,
operator|&
name|ui
argument_list|,
sizeof|sizeof
argument_list|(
name|ui
argument_list|)
argument_list|)
expr_stmt|;
name|ui
operator|=
name|INVALIDID
expr_stmt|;
name|memcpy
argument_list|(
name|un_fhandle
operator|.
name|fh_data
argument_list|,
operator|&
name|ui
argument_list|,
sizeof|sizeof
argument_list|(
name|ui
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|voidp
name|nfsproc_null_2_svc
parameter_list|(
name|voidp
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|char
name|res
decl_stmt|;
return|return
operator|(
name|voidp
operator|)
operator|&
name|res
return|;
block|}
end_function

begin_comment
comment|/* compare if two filehandles are equal */
end_comment

begin_function
specifier|static
name|int
name|eq_fh
parameter_list|(
specifier|const
name|am_nfs_fh
modifier|*
name|fh1
parameter_list|,
specifier|const
name|am_nfs_fh
modifier|*
name|fh2
parameter_list|)
block|{
return|return
operator|(
operator|!
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fh1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fh2
argument_list|,
sizeof|sizeof
argument_list|(
name|am_nfs_fh
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|nfsattrstat
modifier|*
name|nfsproc_getattr_2_svc
parameter_list|(
name|am_nfs_fh
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|nfsattrstat
name|res
decl_stmt|;
name|uid_t
name|uid
init|=
operator|(
name|uid_t
operator|)
name|INVALIDID
decl_stmt|;
name|gid_t
name|gid
init|=
operator|(
name|gid_t
operator|)
name|INVALIDID
decl_stmt|;
if|if
condition|(
operator|!
name|started
condition|)
block|{
name|started
operator|++
expr_stmt|;
name|rootfattr
operator|.
name|na_ctime
operator|=
name|startup
expr_stmt|;
name|rootfattr
operator|.
name|na_mtime
operator|=
name|startup
expr_stmt|;
name|slinkfattr
operator|.
name|na_ctime
operator|=
name|startup
expr_stmt|;
name|slinkfattr
operator|.
name|na_mtime
operator|=
name|startup
expr_stmt|;
name|un_fattr
operator|.
name|na_ctime
operator|=
name|startup
expr_stmt|;
name|un_fattr
operator|.
name|na_mtime
operator|=
name|startup
expr_stmt|;
block|}
if|if
condition|(
name|getcreds
argument_list|(
name|rqstp
argument_list|,
operator|&
name|uid
argument_list|,
operator|&
name|gid
argument_list|,
name|nfsxprt
argument_list|)
operator|<
literal|0
condition|)
block|{
name|res
operator|.
name|ns_status
operator|=
name|NFSERR_STALE
expr_stmt|;
return|return
operator|&
name|res
return|;
block|}
if|if
condition|(
name|eq_fh
argument_list|(
name|argp
argument_list|,
operator|&
name|root
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
comment|/*      * XXX: increment mtime of parent directory, causes NFS clients to      * invalidate their cache for that directory.      * Some NFS clients may need this code.      */
block|if (uid != rootfattr.na_uid) {       clocktime(&rootfattr.na_mtime);       rootfattr.na_uid = uid;     }
endif|#
directive|endif
comment|/* 0 */
name|res
operator|.
name|ns_status
operator|=
name|NFS_OK
expr_stmt|;
name|res
operator|.
name|ns_u
operator|.
name|ns_attr_u
operator|=
name|rootfattr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eq_fh
argument_list|(
name|argp
argument_list|,
operator|&
name|slink
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|MNT2_NFS_OPT_SYMTTL
comment|/*      * This code is needed to defeat Solaris 2.4's (and newer) symlink      * values cache.  It forces the last-modified time of the symlink to be      * current.  It is not needed if the O/S has an nfs flag to turn off the      * symlink-cache at mount time (such as Irix 5.x and 6.x). -Erez.      *      * Additionally, Linux currently ignores the nt_useconds field,      * so we must update the nt_seconds field every time.      */
if|if
condition|(
name|uid
operator|!=
name|slinkfattr
operator|.
name|na_uid
condition|)
block|{
name|clocktime
argument_list|(
operator|&
name|slinkfattr
operator|.
name|na_mtime
argument_list|)
expr_stmt|;
name|slinkfattr
operator|.
name|na_uid
operator|=
name|uid
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not MNT2_NFS_OPT_SYMTTL */
name|res
operator|.
name|ns_status
operator|=
name|NFS_OK
expr_stmt|;
name|res
operator|.
name|ns_u
operator|.
name|ns_attr_u
operator|=
name|slinkfattr
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|gid
operator|!=
name|hlfs_gid
condition|)
block|{
name|res
operator|.
name|ns_status
operator|=
name|NFSERR_STALE
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|uid
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|uid
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|argp
operator|->
name|fh_data
expr_stmt|;
if|if
condition|(
name|plt_search
argument_list|(
name|uid
argument_list|)
operator|!=
operator|(
name|uid2home_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|res
operator|.
name|ns_status
operator|=
name|NFS_OK
expr_stmt|;
name|un_fattr
operator|.
name|na_fileid
operator|=
name|uid
expr_stmt|;
name|res
operator|.
name|ns_u
operator|.
name|ns_attr_u
operator|=
name|un_fattr
expr_stmt|;
name|dlog
argument_list|(
literal|"nfs_getattr: successful search for uid=%ld, gid=%ld"
argument_list|,
operator|(
name|long
operator|)
name|uid
argument_list|,
operator|(
name|long
operator|)
name|gid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* not found */
name|res
operator|.
name|ns_status
operator|=
name|NFSERR_STALE
expr_stmt|;
block|}
block|}
block|}
return|return
operator|&
name|res
return|;
block|}
end_function

begin_function
name|nfsattrstat
modifier|*
name|nfsproc_setattr_2_svc
parameter_list|(
name|nfssattrargs
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|nfsattrstat
name|res
init|=
block|{
name|NFSERR_ROFS
block|}
decl_stmt|;
return|return
operator|&
name|res
return|;
block|}
end_function

begin_function
name|voidp
name|nfsproc_root_2_svc
parameter_list|(
name|voidp
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|char
name|res
decl_stmt|;
return|return
operator|(
name|voidp
operator|)
operator|&
name|res
return|;
block|}
end_function

begin_function
name|nfsdiropres
modifier|*
name|nfsproc_lookup_2_svc
parameter_list|(
name|nfsdiropargs
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|nfsdiropres
name|res
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|uid_t
name|uid
init|=
operator|(
name|uid_t
operator|)
name|INVALIDID
decl_stmt|;
name|gid_t
name|gid
init|=
operator|(
name|gid_t
operator|)
name|INVALIDID
decl_stmt|;
if|if
condition|(
operator|!
name|started
condition|)
block|{
name|started
operator|++
expr_stmt|;
name|rootfattr
operator|.
name|na_ctime
operator|=
name|startup
expr_stmt|;
name|rootfattr
operator|.
name|na_mtime
operator|=
name|startup
expr_stmt|;
name|slinkfattr
operator|.
name|na_ctime
operator|=
name|startup
expr_stmt|;
name|slinkfattr
operator|.
name|na_mtime
operator|=
name|startup
expr_stmt|;
name|un_fattr
operator|.
name|na_ctime
operator|=
name|startup
expr_stmt|;
name|un_fattr
operator|.
name|na_mtime
operator|=
name|startup
expr_stmt|;
block|}
if|if
condition|(
name|eq_fh
argument_list|(
operator|&
name|argp
operator|->
name|da_fhandle
argument_list|,
operator|&
name|slink
argument_list|)
condition|)
block|{
name|res
operator|.
name|dr_status
operator|=
name|NFSERR_NOTDIR
expr_stmt|;
return|return
operator|&
name|res
return|;
block|}
if|if
condition|(
name|getcreds
argument_list|(
name|rqstp
argument_list|,
operator|&
name|uid
argument_list|,
operator|&
name|gid
argument_list|,
name|nfsxprt
argument_list|)
operator|<
literal|0
condition|)
block|{
name|res
operator|.
name|dr_status
operator|=
name|NFSERR_NOENT
expr_stmt|;
return|return
operator|&
name|res
return|;
block|}
if|if
condition|(
name|eq_fh
argument_list|(
operator|&
name|argp
operator|->
name|da_fhandle
argument_list|,
operator|&
name|root
argument_list|)
condition|)
block|{
if|if
condition|(
name|argp
operator|->
name|da_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|argp
operator|->
name|da_name
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|argp
operator|->
name|da_name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|argp
operator|->
name|da_name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|)
condition|)
block|{
if|#
directive|if
literal|0
comment|/*      * XXX: increment mtime of parent directory, causes NFS clients to      * invalidate their cache for that directory.      * Some NFS clients may need this code.      */
block|if (uid != rootfattr.na_uid) { 	clocktime(&rootfattr.na_mtime); 	rootfattr.na_uid = uid;       }
endif|#
directive|endif
comment|/* 0 */
name|res
operator|.
name|dr_u
operator|.
name|dr_drok_u
operator|.
name|drok_fhandle
operator|=
name|root
expr_stmt|;
name|res
operator|.
name|dr_u
operator|.
name|dr_drok_u
operator|.
name|drok_attributes
operator|=
name|rootfattr
expr_stmt|;
name|res
operator|.
name|dr_status
operator|=
name|NFS_OK
expr_stmt|;
return|return
operator|&
name|res
return|;
block|}
if|if
condition|(
name|STREQ
argument_list|(
name|argp
operator|->
name|da_name
argument_list|,
name|slinkname
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|MNT2_NFS_OPT_SYMTTL
comment|/*        * This code is needed to defeat Solaris 2.4's (and newer) symlink        * values cache.  It forces the last-modified time of the symlink to be        * current.  It is not needed if the O/S has an nfs flag to turn off the        * symlink-cache at mount time (such as Irix 5.x and 6.x). -Erez.        *        * Additionally, Linux currently ignores the nt_useconds field,        * so we must update the nt_seconds field every time.        */
if|if
condition|(
name|uid
operator|!=
name|slinkfattr
operator|.
name|na_uid
condition|)
block|{
name|clocktime
argument_list|(
operator|&
name|slinkfattr
operator|.
name|na_mtime
argument_list|)
expr_stmt|;
name|slinkfattr
operator|.
name|na_uid
operator|=
name|uid
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not MNT2_NFS_OPT_SYMTTL */
name|res
operator|.
name|dr_u
operator|.
name|dr_drok_u
operator|.
name|drok_fhandle
operator|=
name|slink
expr_stmt|;
name|res
operator|.
name|dr_u
operator|.
name|dr_drok_u
operator|.
name|drok_attributes
operator|=
name|slinkfattr
expr_stmt|;
name|res
operator|.
name|dr_status
operator|=
name|NFS_OK
expr_stmt|;
return|return
operator|&
name|res
return|;
block|}
if|if
condition|(
name|gid
operator|!=
name|hlfs_gid
condition|)
block|{
name|res
operator|.
name|dr_status
operator|=
name|NFSERR_NOENT
expr_stmt|;
return|return
operator|&
name|res
return|;
block|}
comment|/* if gets here, gid == hlfs_gid */
if|if
condition|(
operator|(
name|idx
operator|=
name|untab_index
argument_list|(
name|argp
operator|->
name|da_name
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|res
operator|.
name|dr_status
operator|=
name|NFSERR_NOENT
expr_stmt|;
return|return
operator|&
name|res
return|;
block|}
else|else
block|{
comment|/* entry found and gid is permitted */
name|un_fattr
operator|.
name|na_fileid
operator|=
name|untab
index|[
name|idx
index|]
operator|.
name|uid
expr_stmt|;
name|res
operator|.
name|dr_u
operator|.
name|dr_drok_u
operator|.
name|drok_attributes
operator|=
name|un_fattr
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|un_fhandle
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|am_nfs_fh
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_int
operator|*
operator|)
name|un_fhandle
operator|.
name|fh_data
operator|=
operator|(
name|u_int
operator|)
name|untab
index|[
name|idx
index|]
operator|.
name|uid
expr_stmt|;
name|xstrlcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|un_fhandle
operator|.
name|fh_data
index|[
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
argument_list|,
name|untab
index|[
name|idx
index|]
operator|.
name|username
argument_list|,
sizeof|sizeof
argument_list|(
name|am_nfs_fh
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|.
name|dr_u
operator|.
name|dr_drok_u
operator|.
name|drok_fhandle
operator|=
name|un_fhandle
expr_stmt|;
name|res
operator|.
name|dr_status
operator|=
name|NFS_OK
expr_stmt|;
name|dlog
argument_list|(
literal|"nfs_lookup: successful lookup for uid=%ld, gid=%ld: username=%s"
argument_list|,
operator|(
name|long
operator|)
name|uid
argument_list|,
operator|(
name|long
operator|)
name|gid
argument_list|,
name|untab
index|[
name|idx
index|]
operator|.
name|username
argument_list|)
expr_stmt|;
return|return
operator|&
name|res
return|;
block|}
block|}
comment|/* end of "if (eq_fh(argp->dir.data, root.data)) {" */
name|res
operator|.
name|dr_status
operator|=
name|NFSERR_STALE
expr_stmt|;
return|return
operator|&
name|res
return|;
block|}
end_function

begin_function
name|nfsreadlinkres
modifier|*
name|nfsproc_readlink_2_svc
parameter_list|(
name|am_nfs_fh
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|nfsreadlinkres
name|res
decl_stmt|;
name|uid_t
name|userid
init|=
operator|(
name|uid_t
operator|)
name|INVALIDID
decl_stmt|;
name|gid_t
name|groupid
init|=
name|hlfs_gid
operator|+
literal|1
decl_stmt|;
comment|/* anything not hlfs_gid */
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|path_val
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|username
decl_stmt|;
specifier|static
name|uid_t
name|last_uid
init|=
operator|(
name|uid_t
operator|)
name|INVALIDID
decl_stmt|;
if|if
condition|(
name|eq_fh
argument_list|(
name|argp
argument_list|,
operator|&
name|root
argument_list|)
condition|)
block|{
name|res
operator|.
name|rlr_status
operator|=
name|NFSERR_ISDIR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eq_fh
argument_list|(
name|argp
argument_list|,
operator|&
name|slink
argument_list|)
condition|)
block|{
if|if
condition|(
name|getcreds
argument_list|(
name|rqstp
argument_list|,
operator|&
name|userid
argument_list|,
operator|&
name|groupid
argument_list|,
name|nfsxprt
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|nfsreadlinkres
operator|*
operator|)
name|NULL
return|;
name|clocktime
argument_list|(
operator|&
name|slinkfattr
operator|.
name|na_atime
argument_list|)
expr_stmt|;
name|res
operator|.
name|rlr_status
operator|=
name|NFS_OK
expr_stmt|;
if|if
condition|(
name|groupid
operator|==
name|hlfs_gid
condition|)
block|{
name|res
operator|.
name|rlr_u
operator|.
name|rlr_data_u
operator|=
name|DOTSTRING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|res
operator|.
name|rlr_u
operator|.
name|rlr_data_u
operator|=
name|path_val
operator|=
name|homedir
argument_list|(
name|userid
argument_list|,
name|groupid
argument_list|)
operator|)
condition|)
block|{
comment|/*        * parent process (fork in homedir()) continues        * processing, by getting a NULL returned as a        * "special".  Child returns result.        */
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
comment|/* check if asked for user mailbox */
if|if
condition|(
name|getcreds
argument_list|(
name|rqstp
argument_list|,
operator|&
name|userid
argument_list|,
operator|&
name|groupid
argument_list|,
name|nfsxprt
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|nfsreadlinkres
operator|*
operator|)
name|NULL
return|;
block|}
if|if
condition|(
name|groupid
operator|==
name|hlfs_gid
condition|)
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|userid
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|userid
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|argp
operator|->
name|fh_data
expr_stmt|;
name|username
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|argp
operator|->
name|fh_data
index|[
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|res
operator|.
name|rlr_u
operator|.
name|rlr_data_u
operator|=
name|mailbox
argument_list|(
name|userid
argument_list|,
name|username
argument_list|)
operator|)
condition|)
return|return
operator|(
name|nfsreadlinkres
operator|*
operator|)
name|NULL
return|;
block|}
else|else
block|{
name|res
operator|.
name|rlr_status
operator|=
name|NFSERR_STALE
expr_stmt|;
block|}
block|}
comment|/* print info, but try to avoid repetitions */
if|if
condition|(
name|userid
operator|!=
name|last_uid
condition|)
block|{
name|plog
argument_list|(
name|XLOG_USER
argument_list|,
literal|"mailbox for uid=%ld, gid=%ld is %s"
argument_list|,
operator|(
name|long
operator|)
name|userid
argument_list|,
operator|(
name|long
operator|)
name|groupid
argument_list|,
operator|(
name|char
operator|*
operator|)
name|res
operator|.
name|rlr_u
operator|.
name|rlr_data_u
argument_list|)
expr_stmt|;
name|last_uid
operator|=
name|userid
expr_stmt|;
block|}
comment|/* I don't think it will pass this if -D fork */
if|if
condition|(
name|serverpid
operator|==
name|getpid
argument_list|()
condition|)
return|return
operator|&
name|res
return|;
if|if
condition|(
operator|!
name|svc_sendreply
argument_list|(
name|nfsxprt
argument_list|,
operator|(
name|XDRPROC_T_TYPE
operator|)
name|xdr_readlinkres
argument_list|,
operator|(
name|SVC_IN_ARG_TYPE
operator|)
operator|&
name|res
argument_list|)
condition|)
name|svcerr_systemerr
argument_list|(
name|nfsxprt
argument_list|)
expr_stmt|;
comment|/*    * Child exists here.   We need to determine which    * exist status to return.  The exit status    * is gathered using wait() and determines    * if we returned $HOME/.hlfsspool or $ALTDIR.  The parent    * needs this info so it can update the lookup table.    */
if|if
condition|(
name|path_val
operator|&&
name|alt_spooldir
operator|&&
name|STREQ
argument_list|(
name|path_val
argument_list|,
name|alt_spooldir
argument_list|)
condition|)
name|retval
operator|=
literal|1
expr_stmt|;
comment|/* could not get real home dir (or uid 0 user) */
else|else
name|retval
operator|=
literal|0
expr_stmt|;
comment|/*    * If asked for -D nofork, then must return the value,    * NOT exit, or else the main hlfsd server exits.    * If -D fork (default), then we do want to exit from the process.    * Bug: where is that status information being collected?    */
if|if
condition|(
name|amuDebug
argument_list|(
name|D_FORK
argument_list|)
condition|)
name|exit
argument_list|(
name|retval
argument_list|)
expr_stmt|;
else|else
return|return
operator|&
name|res
return|;
block|}
end_function

begin_function
name|nfsreadres
modifier|*
name|nfsproc_read_2_svc
parameter_list|(
name|nfsreadargs
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|nfsreadres
name|res
init|=
block|{
name|NFSERR_ACCES
block|}
decl_stmt|;
return|return
operator|&
name|res
return|;
block|}
end_function

begin_function
name|voidp
name|nfsproc_writecache_2_svc
parameter_list|(
name|voidp
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|char
name|res
decl_stmt|;
return|return
operator|(
name|voidp
operator|)
operator|&
name|res
return|;
block|}
end_function

begin_function
name|nfsattrstat
modifier|*
name|nfsproc_write_2_svc
parameter_list|(
name|nfswriteargs
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|nfsattrstat
name|res
init|=
block|{
name|NFSERR_ROFS
block|}
decl_stmt|;
return|return
operator|&
name|res
return|;
block|}
end_function

begin_function
name|nfsdiropres
modifier|*
name|nfsproc_create_2_svc
parameter_list|(
name|nfscreateargs
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|nfsdiropres
name|res
init|=
block|{
name|NFSERR_ROFS
block|}
decl_stmt|;
return|return
operator|&
name|res
return|;
block|}
end_function

begin_function
name|nfsstat
modifier|*
name|nfsproc_remove_2_svc
parameter_list|(
name|nfsdiropargs
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|nfsstat
name|res
init|=
block|{
name|NFSERR_ROFS
block|}
decl_stmt|;
return|return
operator|&
name|res
return|;
block|}
end_function

begin_function
name|nfsstat
modifier|*
name|nfsproc_rename_2_svc
parameter_list|(
name|nfsrenameargs
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|nfsstat
name|res
init|=
block|{
name|NFSERR_ROFS
block|}
decl_stmt|;
return|return
operator|&
name|res
return|;
block|}
end_function

begin_function
name|nfsstat
modifier|*
name|nfsproc_link_2_svc
parameter_list|(
name|nfslinkargs
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|nfsstat
name|res
init|=
block|{
name|NFSERR_ROFS
block|}
decl_stmt|;
return|return
operator|&
name|res
return|;
block|}
end_function

begin_function
name|nfsstat
modifier|*
name|nfsproc_symlink_2_svc
parameter_list|(
name|nfssymlinkargs
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|nfsstat
name|res
init|=
block|{
name|NFSERR_ROFS
block|}
decl_stmt|;
return|return
operator|&
name|res
return|;
block|}
end_function

begin_function
name|nfsdiropres
modifier|*
name|nfsproc_mkdir_2_svc
parameter_list|(
name|nfscreateargs
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|nfsdiropres
name|res
init|=
block|{
name|NFSERR_ROFS
block|}
decl_stmt|;
return|return
operator|&
name|res
return|;
block|}
end_function

begin_function
name|nfsstat
modifier|*
name|nfsproc_rmdir_2_svc
parameter_list|(
name|nfsdiropargs
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|nfsstat
name|res
init|=
block|{
name|NFSERR_ROFS
block|}
decl_stmt|;
return|return
operator|&
name|res
return|;
block|}
end_function

begin_function
name|nfsreaddirres
modifier|*
name|nfsproc_readdir_2_svc
parameter_list|(
name|nfsreaddirargs
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|nfsreaddirres
name|res
decl_stmt|;
specifier|static
name|nfsentry
name|slinkent
init|=
block|{
name|SLINKID
block|,
name|NULL
block|,
block|{
name|SLINKCOOKIE
block|}
block|}
decl_stmt|;
specifier|static
name|nfsentry
name|dotdotent
init|=
block|{
name|ROOTID
block|,
literal|".."
block|,
block|{
name|DOTDOTCOOKIE
block|}
block|,
operator|&
name|slinkent
block|}
decl_stmt|;
specifier|static
name|nfsentry
name|dotent
init|=
block|{
name|ROOTID
block|,
literal|"."
block|,
block|{
name|DOTCOOKIE
block|}
block|,
operator|&
name|dotdotent
block|}
decl_stmt|;
name|slinkent
operator|.
name|ne_name
operator|=
name|slinkname
expr_stmt|;
if|if
condition|(
name|eq_fh
argument_list|(
operator|&
name|argp
operator|->
name|rda_fhandle
argument_list|,
operator|&
name|slink
argument_list|)
condition|)
block|{
name|res
operator|.
name|rdr_status
operator|=
name|NFSERR_NOTDIR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eq_fh
argument_list|(
operator|&
name|argp
operator|->
name|rda_fhandle
argument_list|,
operator|&
name|root
argument_list|)
condition|)
block|{
name|clocktime
argument_list|(
operator|&
name|rootfattr
operator|.
name|na_atime
argument_list|)
expr_stmt|;
name|res
operator|.
name|rdr_status
operator|=
name|NFS_OK
expr_stmt|;
switch|switch
condition|(
name|argp
operator|->
name|rda_cookie
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0
case|:
name|res
operator|.
name|rdr_u
operator|.
name|rdr_reply_u
operator|.
name|dl_entries
operator|=
operator|&
name|dotent
expr_stmt|;
break|break;
case|case
name|DOTCOOKIE
case|:
name|res
operator|.
name|rdr_u
operator|.
name|rdr_reply_u
operator|.
name|dl_entries
operator|=
operator|&
name|dotdotent
expr_stmt|;
break|break;
case|case
name|DOTDOTCOOKIE
case|:
name|res
operator|.
name|rdr_u
operator|.
name|rdr_reply_u
operator|.
name|dl_entries
operator|=
operator|&
name|slinkent
expr_stmt|;
break|break;
case|case
name|SLINKCOOKIE
case|:
name|res
operator|.
name|rdr_u
operator|.
name|rdr_reply_u
operator|.
name|dl_entries
operator|=
operator|(
name|nfsentry
operator|*
operator|)
name|NULL
expr_stmt|;
break|break;
block|}
name|res
operator|.
name|rdr_u
operator|.
name|rdr_reply_u
operator|.
name|dl_eof
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|res
operator|.
name|rdr_status
operator|=
name|NFSERR_STALE
expr_stmt|;
block|}
return|return
operator|&
name|res
return|;
block|}
end_function

begin_function
name|nfsstatfsres
modifier|*
name|nfsproc_statfs_2_svc
parameter_list|(
name|am_nfs_fh
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|nfsstatfsres
name|res
init|=
block|{
name|NFS_OK
block|}
decl_stmt|;
name|res
operator|.
name|sfr_u
operator|.
name|sfr_reply_u
operator|.
name|sfrok_tsize
operator|=
literal|1024
expr_stmt|;
name|res
operator|.
name|sfr_u
operator|.
name|sfr_reply_u
operator|.
name|sfrok_bsize
operator|=
literal|1024
expr_stmt|;
comment|/*    * Some "df" programs automatically assume that file systems    * with zero blocks are meta-filesystems served by automounters.    */
name|res
operator|.
name|sfr_u
operator|.
name|sfr_reply_u
operator|.
name|sfrok_blocks
operator|=
literal|0
expr_stmt|;
name|res
operator|.
name|sfr_u
operator|.
name|sfr_reply_u
operator|.
name|sfrok_bfree
operator|=
literal|0
expr_stmt|;
name|res
operator|.
name|sfr_u
operator|.
name|sfr_reply_u
operator|.
name|sfrok_bavail
operator|=
literal|0
expr_stmt|;
return|return
operator|&
name|res
return|;
block|}
end_function

end_unit

