begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997-1999 Erez Zadok  * Copyright (c) 1989 Jan-Simon Pendry  * Copyright (c) 1989 Imperial College of Science, Technology& Medicine  * Copyright (c) 1989 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry at Imperial College, London.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgment:  *      This product includes software developed by the University of  *      California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      %W% (Berkeley) %G%  *  * $Id: hlfsd.c,v 1.5 1999/09/08 23:36:51 ezk Exp $  * $FreeBSD$  *  * HLFSD was written at Columbia University Computer Science Department, by  * Erez Zadok<ezk@cs.columbia.edu> and Alexander Dupuy<dupuy@cs.columbia.edu>  * It is being distributed under the same terms and conditions as amd does.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<am_defs.h>
end_include

begin_include
include|#
directive|include
file|<hlfsd.h>
end_include

begin_comment
comment|/*  * STATIC VARIABLES:  */
end_comment

begin_function_decl
specifier|static
name|RETSIGTYPE
name|proceed
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|RETSIGTYPE
name|reaper
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|RETSIGTYPE
name|reload
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
modifier|*
name|hlfs_group
init|=
name|DEFAULT_HLFS_GROUP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|default_dir_name
index|[]
init|=
name|DEFAULT_DIRNAME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dir_name
init|=
name|default_dir_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|printpid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stoplight
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|hlfsd_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|itimerval
name|reloadinterval
init|=
block|{
block|{
name|DEFAULT_INTERVAL
block|,
literal|0
block|}
block|,
block|{
name|DEFAULT_INTERVAL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * default mount options.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|default_mntopts
index|[]
init|=
literal|"ro,noac"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * GLOBALS:  */
end_comment

begin_decl_stmt
name|SVCXPRT
modifier|*
name|nfsxprt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|alt_spooldir
init|=
name|ALT_SPOOLDIR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|home_subdir
init|=
name|HOME_SUBDIR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|logfile
init|=
name|DEFAULT_LOGFILE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|passwdfile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* alternate passwd file to use */
end_comment

begin_decl_stmt
name|char
modifier|*
name|slinkname
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|hostname
index|[
name|MAXHOSTNAMELEN
operator|+
literal|1
index|]
init|=
literal|"localhost"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cache_interval
init|=
name|DEFAULT_CACHE_INTERVAL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|gid_t
name|hlfs_gid
init|=
operator|(
name|gid_t
operator|)
name|INVALIDID
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|masterpid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|noverify
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|orig_umask
init|=
literal|022
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|serverpid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|nfstime
name|startup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|nfs_port
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* symbol must be available always */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MOUNT_TABLE_ON_FILE
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|mnttab_file_name
init|=
name|MNTTAB_FILE_NAME
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not MOUNT_TABLE_ON_FILE */
end_comment

begin_decl_stmt
name|char
modifier|*
name|mnttab_file_name
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not MOUNT_TABLE_ON_FILE */
end_comment

begin_comment
comment|/* forward declarations */
end_comment

begin_function_decl
name|void
name|hlfsd_going_down
parameter_list|(
name|int
name|rc
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [-Cfhnpv] [-a altdir] [-c cache-interval] [-g group]\n"
argument_list|,
name|am_get_progname
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t[-i interval] [-l logfile] [-o mntopts] [-P passwdfile]\n"
argument_list|)
expr_stmt|;
name|show_opts
argument_list|(
literal|'x'
argument_list|,
name|xlog_opt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|show_opts
argument_list|(
literal|'D'
argument_list|,
name|dbg_opt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t[dir_name [subdir]]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
modifier|*
name|dot
decl_stmt|;
name|char
modifier|*
name|mntopts
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|char
name|hostpid_fs
index|[
name|MAXHOSTNAMELEN
operator|+
literal|1
operator|+
literal|16
index|]
decl_stmt|;
comment|/* room for ":(pid###)" */
name|char
name|progpid_fs
index|[
name|PROGNAMESZ
operator|+
literal|1
operator|+
literal|11
index|]
decl_stmt|;
comment|/* room for ":pid" */
name|char
name|preopts
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|progname
decl_stmt|;
name|int
name|forcecache
init|=
literal|0
decl_stmt|;
name|int
name|forcefast
init|=
literal|0
decl_stmt|;
name|int
name|genflags
init|=
literal|0
decl_stmt|;
name|int
name|opt
decl_stmt|,
name|ret
decl_stmt|;
name|int
name|opterrs
init|=
literal|0
decl_stmt|;
name|int
name|retry
decl_stmt|;
name|int
name|soNFS
decl_stmt|;
comment|/* NFS socket */
name|int
name|s
init|=
operator|-
literal|99
decl_stmt|;
name|mntent_t
name|mnt
decl_stmt|;
name|nfs_args_t
name|nfs_args
decl_stmt|;
name|am_nfs_handle_t
name|anh
decl_stmt|;
name|struct
name|dirent
modifier|*
name|direntry
decl_stmt|;
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|struct
name|stat
name|stmodes
decl_stmt|;
name|DIR
modifier|*
name|mountdir
decl_stmt|;
name|MTYPE_TYPE
name|type
init|=
name|MOUNT_TYPE_NFS
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SIGACTION
name|struct
name|sigaction
name|sa
decl_stmt|;
endif|#
directive|endif
comment|/* not HAVE_SIGACTION */
ifndef|#
directive|ifndef
name|HAVE_TRANSPORT_TYPE_TLI
name|struct
name|sockaddr_in
name|localsocket
decl_stmt|;
endif|#
directive|endif
comment|/* not HAVE_TRANSPORT_TYPE_TLI */
comment|/* get program name and truncate so we don't overflow progpid_fs */
if|if
condition|(
operator|(
name|progname
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|progname
operator|++
expr_stmt|;
else|else
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|progname
argument_list|)
operator|>
name|PROGNAMESZ
condition|)
comment|/* truncate to reasonable size */
name|progname
index|[
name|PROGNAMESZ
index|]
operator|=
literal|'\0'
expr_stmt|;
name|am_set_progname
argument_list|(
name|progname
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"a:c:CD:fg:hi:l:no:pP:x:v"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'a'
case|:
if|if
condition|(
operator|!
name|optarg
operator|||
name|optarg
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|printf
argument_list|(
literal|"%s: invalid directory for -a: %s\n"
argument_list|,
name|am_get_progname
argument_list|()
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
name|alt_spooldir
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
operator|!
name|atoi
argument_list|(
name|optarg
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: invalid interval for -c: %s\n"
argument_list|,
name|am_get_progname
argument_list|()
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
name|cache_interval
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|forcecache
operator|++
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|forcefast
operator|++
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|hlfs_group
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
operator|!
name|atoi
argument_list|(
name|optarg
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: invalid interval for -i: %s\n"
argument_list|,
name|am_get_progname
argument_list|()
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
name|reloadinterval
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|reloadinterval
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|logfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|noverify
operator|++
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|mntopts
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|printpid
operator|++
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|passwdfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|HLFSD_VERSION
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'x'
case|:
name|opterrs
operator|+=
name|switch_option
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|opterrs
operator|+=
name|debug_option
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not DEBUG */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: not compiled with DEBUG -- sorry.\n"
argument_list|,
name|am_get_progname
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not DEBUG */
break|break;
case|case
literal|'h'
case|:
case|case
literal|'?'
case|:
name|opterrs
operator|++
expr_stmt|;
block|}
comment|/* set some default debugging options */
if|if
condition|(
name|xlog_level_init
operator|==
operator|~
literal|0
condition|)
name|switch_option
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* need my pid before any dlog/plog */
name|am_set_mypid
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|switch_option
argument_list|(
literal|"debug"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/*  * Terminate if did not ask to forcecache (-C) and hlfsd would not be able  * to set the minimum cache intervals.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MNT2_NFS_OPT_ACREGMIN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MNT2_NFS_OPT_NOAC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_FIELD_NFS_ARGS_T_ACREGMIN
argument_list|)
if|if
condition|(
operator|!
name|forcecache
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: will not be able to turn off attribute caches.\n"
argument_list|,
name|am_get_progname
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !defined(MNT2_NFS_OPT_ACREGMIN)&& !defined(MNT2_NFS_OPT_NOAC)&& !defined(HAVE_FIELD_NFS_ARGS_T_ACREGMIN) */
switch|switch
condition|(
name|argc
operator|-
name|optind
condition|)
block|{
case|case
literal|2
case|:
name|home_subdir
operator|=
name|argv
index|[
name|optind
operator|+
literal|1
index|]
expr_stmt|;
case|case
literal|1
case|:
name|dir_name
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
case|case
literal|0
case|:
break|break;
default|default:
name|opterrs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|opterrs
condition|)
name|usage
argument_list|()
expr_stmt|;
comment|/* ensure that only root can run hlfsd */
if|if
condition|(
name|geteuid
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"hlfsd can only be run as root\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|setbuf
argument_list|(
name|stdout
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* find gid for hlfs_group */
if|if
condition|(
operator|(
name|grp
operator|=
name|getgrnam
argument_list|(
name|hlfs_group
argument_list|)
operator|)
operator|==
operator|(
expr|struct
name|group
operator|*
operator|)
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: cannot get gid for group \"%s\".\n"
argument_list|,
name|am_get_progname
argument_list|()
argument_list|,
name|hlfs_group
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hlfs_gid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
block|}
comment|/* get hostname for logging and open log before we reset umask */
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
name|hostname
index|[
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|dot
operator|=
name|strchr
argument_list|(
name|hostname
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|dot
operator|=
literal|'\0'
expr_stmt|;
name|orig_umask
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|logfile
condition|)
name|switch_to_logfile
argument_list|(
name|logfile
argument_list|,
name|orig_umask
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MOUNT_TABLE_ON_FILE
argument_list|)
if|if
condition|(
name|debug_flags
operator|&
name|D_MTAB
condition|)
name|dlog
argument_list|(
literal|"-D mtab option ignored"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DEBUG)&& !defined(MOUNT_TABLE_ON_FILE) */
comment|/* avoid hanging on other NFS servers if started elsewhere */
if|if
condition|(
name|chdir
argument_list|(
literal|"/"
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"cannot chdir to /: %m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|geteuid
argument_list|()
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"must be root to mount filesystems"
argument_list|)
expr_stmt|;
comment|/*    * dir_name must match "^(/.*)/([^/]+)$", and is split at last '/' with    * slinkname = `basename $dir_name` - requires dir_name be writable    */
if|if
condition|(
name|dir_name
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|||
operator|(
operator|(
name|slinkname
operator|=
name|strrchr
argument_list|(
name|dir_name
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|,
operator|*
name|slinkname
operator|++
operator|=
literal|'\0'
operator|,
operator|(
name|dir_name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|slinkname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|slinkname
condition|)
operator|*
operator|--
name|slinkname
operator|=
literal|'/'
expr_stmt|;
name|printf
argument_list|(
literal|"%s: invalid mount directory/link %s\n"
argument_list|,
name|am_get_progname
argument_list|()
argument_list|,
name|dir_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
name|clock_valid
operator|=
literal|0
expr_stmt|;
comment|/* invalidate logging clock */
if|if
condition|(
operator|!
name|forcefast
condition|)
block|{
comment|/* make sure mount point exists and is at least mode 555 */
if|if
condition|(
name|stat
argument_list|(
name|dir_name
argument_list|,
operator|&
name|stmodes
argument_list|)
operator|<
literal|0
condition|)
if|if
condition|(
name|errno
operator|!=
name|ENOENT
operator|||
name|mkdirs
argument_list|(
name|dir_name
argument_list|,
literal|0555
argument_list|)
operator|<
literal|0
operator|||
name|stat
argument_list|(
name|dir_name
argument_list|,
operator|&
name|stmodes
argument_list|)
operator|<
literal|0
condition|)
name|fatalerror
argument_list|(
name|dir_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stmodes
operator|.
name|st_mode
operator|&
literal|0555
operator|)
operator|!=
literal|0555
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: directory %s not read/executable\n"
argument_list|,
name|am_get_progname
argument_list|()
argument_list|,
name|dir_name
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"directory %s not read/executable"
argument_list|,
name|dir_name
argument_list|)
expr_stmt|;
block|}
comment|/* warn if extraneous stuff will be hidden by mount */
if|if
condition|(
operator|(
name|mountdir
operator|=
name|opendir
argument_list|(
name|dir_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatalerror
argument_list|(
name|dir_name
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|direntry
operator|=
name|readdir
argument_list|(
name|mountdir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|NSTREQ
argument_list|(
literal|"."
argument_list|,
name|direntry
operator|->
name|d_name
argument_list|,
name|NAMLEN
argument_list|(
name|direntry
argument_list|)
argument_list|)
operator|&&
operator|!
name|NSTREQ
argument_list|(
literal|".."
argument_list|,
name|direntry
operator|->
name|d_name
argument_list|,
name|NAMLEN
argument_list|(
name|direntry
argument_list|)
argument_list|)
operator|&&
operator|!
name|NSTREQ
argument_list|(
name|slinkname
argument_list|,
name|direntry
operator|->
name|d_name
argument_list|,
name|NAMLEN
argument_list|(
name|direntry
argument_list|)
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|direntry
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s/%s will be hidden by mount\n"
argument_list|,
name|am_get_progname
argument_list|()
argument_list|,
name|dir_name
argument_list|,
name|direntry
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"%s/%s will be hidden by mount\n"
argument_list|,
name|dir_name
argument_list|,
name|direntry
operator|->
name|d_name
argument_list|)
expr_stmt|;
block|}
name|closedir
argument_list|(
name|mountdir
argument_list|)
expr_stmt|;
comment|/* make sure alternate spool dir exists */
if|if
condition|(
operator|(
name|errno
operator|=
name|mkdirs
argument_list|(
name|alt_spooldir
argument_list|,
name|OPEN_SPOOLMODE
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: cannot create alternate dir "
argument_list|,
name|am_get_progname
argument_list|()
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|alt_spooldir
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"cannot create alternate dir %s: %m"
argument_list|,
name|alt_spooldir
argument_list|)
expr_stmt|;
block|}
name|chmod
argument_list|(
name|alt_spooldir
argument_list|,
name|OPEN_SPOOLMODE
argument_list|)
expr_stmt|;
comment|/* create failsafe link to alternate spool directory */
name|slinkname
index|[
operator|-
literal|1
index|]
operator|=
literal|'/'
expr_stmt|;
comment|/* unsplit dir_name to include link */
if|if
condition|(
name|lstat
argument_list|(
name|dir_name
argument_list|,
operator|&
name|stmodes
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|stmodes
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFLNK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: failsafe %s not a symlink\n"
argument_list|,
name|am_get_progname
argument_list|()
argument_list|,
name|dir_name
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"failsafe %s not a symlink\n"
argument_list|,
name|dir_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unlink
argument_list|(
name|dir_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|symlink
argument_list|(
name|alt_spooldir
argument_list|,
name|dir_name
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: cannot create failsafe symlink %s -> "
argument_list|,
name|am_get_progname
argument_list|()
argument_list|,
name|dir_name
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|alt_spooldir
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"cannot create failsafe symlink %s -> %s: %m"
argument_list|,
name|dir_name
argument_list|,
name|alt_spooldir
argument_list|)
expr_stmt|;
block|}
block|}
name|slinkname
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* resplit dir_name */
block|}
comment|/* end of "if (!forcefast) {" */
comment|/*    * Register hlfsd as an nfs service with the portmapper.    */
ifdef|#
directive|ifdef
name|HAVE_TRANSPORT_TYPE_TLI
name|ret
operator|=
name|create_nfs_service
argument_list|(
operator|&
name|soNFS
argument_list|,
operator|&
name|nfs_port
argument_list|,
operator|&
name|nfsxprt
argument_list|,
name|nfs_program_2
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_TRANSPORT_TYPE_TLI */
name|ret
operator|=
name|create_nfs_service
argument_list|(
operator|&
name|soNFS
argument_list|,
operator|&
name|nfs_port
argument_list|,
operator|&
name|nfsxprt
argument_list|,
name|nfs_program_2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_TRANSPORT_TYPE_TLI */
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"cannot create NFS service"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SIGACTION
name|sa
operator|.
name|sa_handler
operator|=
name|proceed
expr_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
operator|(
name|sa
operator|.
name|sa_mask
operator|)
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
operator|(
name|sa
operator|.
name|sa_mask
operator|)
argument_list|,
name|SIGUSR2
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGUSR2
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_SIGACTION */
name|signal
argument_list|(
name|SIGUSR2
argument_list|,
name|proceed
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_SIGACTION */
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"Initializing hlfsd..."
argument_list|)
expr_stmt|;
name|hlfsd_init
argument_list|()
expr_stmt|;
comment|/* start up child (forking) to run svc_run */
ifdef|#
directive|ifdef
name|HAVE_SIGACTION
name|sa
operator|.
name|sa_handler
operator|=
name|reaper
expr_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
operator|(
name|sa
operator|.
name|sa_mask
operator|)
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
operator|(
name|sa
operator|.
name|sa_mask
operator|)
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGCHLD
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_SIGACTION */
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|reaper
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_SIGACTION */
ifdef|#
directive|ifdef
name|DEBUG
comment|/*    * In the parent, if -D nodaemon (or -D daemon) , we don't need to    * set this signal handler.    */
name|amuDebug
argument_list|(
argument|D_DAEMON
argument_list|)
block|{
endif|#
directive|endif
comment|/* DEBUG */
comment|/* XXX: port to use pure svr4 signals */
name|s
operator|=
operator|-
literal|99
expr_stmt|;
while|while
condition|(
name|stoplight
operator|!=
name|SIGUSR2
condition|)
block|{
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"parent waits for child to setup (stoplight=%d)"
argument_list|,
name|stoplight
argument_list|)
expr_stmt|;
name|s
operator|=
name|sigpause
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* wait for child to set up */
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
block|}
endif|#
directive|endif
comment|/* DEBUG */
comment|/*    * setup options to mount table (/etc/{mtab,mnttab}) entry    */
name|sprintf
argument_list|(
name|hostpid_fs
argument_list|,
literal|"%s:(pid%d)"
argument_list|,
name|hostname
argument_list|,
name|masterpid
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mnt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mnt
argument_list|)
argument_list|)
expr_stmt|;
name|mnt
operator|.
name|mnt_dir
operator|=
name|dir_name
expr_stmt|;
comment|/* i.e., "/mail" */
name|mnt
operator|.
name|mnt_fsname
operator|=
name|hostpid_fs
expr_stmt|;
if|if
condition|(
name|mntopts
condition|)
block|{
name|mnt
operator|.
name|mnt_opts
operator|=
name|mntopts
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|preopts
argument_list|,
name|default_mntopts
argument_list|)
expr_stmt|;
comment|/*      * Turn off all kinds of attribute and symlink caches as      * much as possible.  Also make sure that mount does not      * show up to df.      */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_INTR
name|strcat
argument_list|(
name|preopts
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|preopts
argument_list|,
name|MNTTAB_OPT_INTR
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_OPT_INTR */
ifdef|#
directive|ifdef
name|MNTTAB_OPT_IGNORE
name|strcat
argument_list|(
name|preopts
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|preopts
argument_list|,
name|MNTTAB_OPT_IGNORE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNTTAB_OPT_IGNORE */
ifdef|#
directive|ifdef
name|MNT2_GEN_OPT_CACHE
name|strcat
argument_list|(
name|preopts
argument_list|,
literal|",nocache"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_GEN_OPT_CACHE */
ifdef|#
directive|ifdef
name|MNT2_NFS_OPT_SYMTTL
name|strcat
argument_list|(
name|preopts
argument_list|,
literal|",symttl=0"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MNT2_NFS_OPT_SYMTTL */
name|mnt
operator|.
name|mnt_opts
operator|=
name|preopts
expr_stmt|;
block|}
comment|/*    * Make sure that amd's top-level NFS mounts are hidden by default    * from df.    * If they don't appear to support the either the "ignore" mnttab    * option entry, or the "auto" one, set the mount type to "nfs".    */
name|mnt
operator|.
name|mnt_type
operator|=
name|HIDE_MOUNT_TYPE
expr_stmt|;
comment|/* some systems don't have a mount type, but a mount flag */
ifndef|#
directive|ifndef
name|HAVE_TRANSPORT_TYPE_TLI
name|amu_get_myaddress
argument_list|(
operator|&
name|localsocket
operator|.
name|sin_addr
argument_list|)
expr_stmt|;
name|localsocket
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|localsocket
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|nfsxprt
operator|->
name|xp_port
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_TRANSPORT_TYPE_TLI */
comment|/*    * Update hostname field.    * Make some name prog:pid (i.e., hlfsd:174) for hostname    */
name|sprintf
argument_list|(
name|progpid_fs
argument_list|,
literal|"%s:%d"
argument_list|,
name|am_get_progname
argument_list|()
argument_list|,
name|masterpid
argument_list|)
expr_stmt|;
comment|/* Most kernels have a name length restriction. */
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|progpid_fs
argument_list|)
operator|>=
operator|(
name|int
operator|)
name|MAXHOSTNAMELEN
condition|)
name|strcpy
argument_list|(
name|progpid_fs
operator|+
name|MAXHOSTNAMELEN
operator|-
literal|3
argument_list|,
literal|".."
argument_list|)
expr_stmt|;
name|genflags
operator|=
name|compute_mount_flags
argument_list|(
operator|&
name|mnt
argument_list|)
expr_stmt|;
name|retry
operator|=
name|hasmntval
argument_list|(
operator|&
name|mnt
argument_list|,
name|MNTTAB_OPT_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry
operator|<=
literal|0
condition|)
name|retry
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
name|memmove
argument_list|(
operator|&
name|anh
operator|.
name|v2
operator|.
name|fhs_fh
argument_list|,
name|root_fhp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|root_fhp
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TRANSPORT_TYPE_TLI
name|compute_nfs_args
argument_list|(
operator|&
name|nfs_args
argument_list|,
operator|&
name|mnt
argument_list|,
name|genflags
argument_list|,
name|nfsncp
argument_list|,
name|NULL
argument_list|,
comment|/* remote host IP addr is set below */
name|NFS_VERSION
argument_list|,
comment|/* version 2 */
literal|"udp"
argument_list|,
comment|/* XXX: shouldn't this be "udp"? */
operator|&
name|anh
argument_list|,
name|progpid_fs
argument_list|,
comment|/* host name for kernel */
name|hostpid_fs
argument_list|)
expr_stmt|;
comment|/* filesystem name for kernel */
comment|/*    * IMPORTANT: set the correct IP address AFTERWARDS.  It cannot    * be done using the normal mechanism of compute_nfs_args(), because    * that one will allocate a new address and use NFS_SA_DREF() to copy    * parts to it, while assuming that the ip_addr passed is always    * a "struct sockaddr_in".  That assumption is incorrect on TLI systems,    * because they define a special macro HOST_SELF which is DIFFERENT    * than localhost (127.0.0.1)!    */
name|nfs_args
operator|.
name|addr
operator|=
operator|&
name|nfsxprt
operator|->
name|xp_ltaddr
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_TRANSPORT_TYPE_TLI */
name|compute_nfs_args
argument_list|(
operator|&
name|nfs_args
argument_list|,
operator|&
name|mnt
argument_list|,
name|genflags
argument_list|,
operator|&
name|localsocket
argument_list|,
name|NFS_VERSION
argument_list|,
comment|/* version 2 */
literal|"udp"
argument_list|,
comment|/* XXX: shouldn't this be "udp"? */
operator|&
name|anh
argument_list|,
name|progpid_fs
argument_list|,
comment|/* host name for kernel */
name|hostpid_fs
argument_list|)
expr_stmt|;
comment|/* filesystem name for kernel */
endif|#
directive|endif
comment|/* not HAVE_TRANSPORT_TYPE_TLI */
comment|/*************************************************************************    * NOTE: while compute_nfs_args() works ok for regular NFS mounts	   *    * the toplvl one is not, and so some options must be corrected by hand  *    * more carefully, *after* compute_nfs_args() runs.			   *    *************************************************************************/
name|compute_automounter_nfs_args
argument_list|(
operator|&
name|nfs_args
argument_list|,
operator|&
name|mnt
argument_list|)
expr_stmt|;
name|clock_valid
operator|=
literal|0
expr_stmt|;
comment|/* invalidate logging clock */
comment|/*  * The following code could be cleverly ifdef-ed, but I duplicated the  * mount_fs call three times for simplicity and readability.  */
ifdef|#
directive|ifdef
name|DEBUG
comment|/*  * For some reason, this mount may have to be done in the background, if I am  * using -D nodebug.  I suspect that the actual act of mounting requires  * calling to hlfsd itself to invoke one or more of its nfs calls, to stat  * /mail.  That means that even if you say -D nodaemon, at least the mount  * of hlfsd itself on top of /mail will be done in the background.  * The other alternative I have is to run svc_run, but set a special  * signal handler to perform the mount in N seconds via some alarm.  *      -Erez Zadok.  */
if|if
condition|(
name|debug_flags
operator|&
name|D_DAEMON
condition|)
block|{
comment|/* asked for -D daemon */
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"parent NFS mounting hlfsd service points"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mount_fs
argument_list|(
operator|&
name|mnt
argument_list|,
name|genflags
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|nfs_args
argument_list|,
name|retry
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|mnttab_file_name
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"nfsmount: %m"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* asked for -D nodaemon */
if|if
condition|(
name|fork
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|/* child runs mount */
name|am_set_mypid
argument_list|()
expr_stmt|;
name|foreground
operator|=
literal|0
expr_stmt|;
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"child NFS mounting hlfsd service points"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mount_fs
argument_list|(
operator|&
name|mnt
argument_list|,
name|genflags
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|nfs_args
argument_list|,
name|retry
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|mnttab_file_name
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fatal
argument_list|(
literal|"nfsmount: %m"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* all went well */
block|}
else|else
block|{
comment|/* fork failed or parent running */
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"parent waiting 1sec for mount..."
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* not DEBUG */
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"normal NFS mounting hlfsd service points"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mount_fs
argument_list|(
operator|&
name|mnt
argument_list|,
name|genflags
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|nfs_args
argument_list|,
name|retry
argument_list|,
name|type
argument_list|,
literal|2
argument_list|,
literal|"udp"
argument_list|,
name|mnttab_file_name
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"nfsmount: %m"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not DEBUG */
ifdef|#
directive|ifdef
name|HAVE_TRANSPORT_TYPE_TLI
comment|/*    * XXX: this free_knetconfig() was not done for hlfsd before,    * and apparently there was a reason for it, but why? -Erez    */
name|free_knetconfig
argument_list|(
name|nfs_args
operator|.
name|knconf
argument_list|)
expr_stmt|;
comment|/*    * local automounter mounts do not allocate a special address, so    * no need to XFREE(nfs_args.addr) under TLI.    */
endif|#
directive|endif
comment|/* HAVE_TRANSPORT_TYPE_TLI */
if|if
condition|(
name|printpid
condition|)
name|printf
argument_list|(
literal|"%d\n"
argument_list|,
name|masterpid
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"hlfsd ready to serve"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/*    * If asked not to fork a daemon (-D nodaemon), then hlfsd_init()    * will not run svc_run.  We must start svc_run here.    */
name|dlog
argument_list|(
literal|"starting no-daemon debugging svc_run"
argument_list|)
expr_stmt|;
name|amuDebugNo
argument_list|(
argument|D_DAEMON
argument_list|)
name|svc_run
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|cleanup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* should never happen here */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* everything went fine? */
block|}
end_function

begin_function
specifier|static
name|void
name|hlfsd_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|child
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SIGACTION
name|struct
name|sigaction
name|sa
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_SIGACTION */
name|clock_valid
operator|=
literal|0
expr_stmt|;
comment|/* invalidate logging clock */
comment|/*    * Initialize file handles.    */
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"initializing hlfsd file handles"
argument_list|)
expr_stmt|;
name|hlfsd_init_filehandles
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/*    * If -D daemon then we must fork.    */
name|amuDebug
argument_list|(
argument|D_DAEMON
argument_list|)
endif|#
directive|endif
comment|/* DEBUG */
name|child
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|child
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"fork: %m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|!=
literal|0
condition|)
block|{
comment|/* parent process - save child pid */
name|masterpid
operator|=
name|child
expr_stmt|;
name|am_set_mypid
argument_list|()
expr_stmt|;
comment|/* for logging routines */
return|return;
block|}
comment|/*    * CHILD CODE:    * initialize server    */
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"initializing home directory database"
argument_list|)
expr_stmt|;
name|plt_init
argument_list|()
expr_stmt|;
comment|/* initialize database */
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"home directory database initialized"
argument_list|)
expr_stmt|;
name|masterpid
operator|=
name|serverpid
operator|=
name|am_set_mypid
argument_list|()
expr_stmt|;
comment|/* for logging routines */
comment|/*    * SIGALRM/SIGHUP: reload password database if timer expired    * or user sent HUP signal.    */
ifdef|#
directive|ifdef
name|HAVE_SIGACTION
name|sa
operator|.
name|sa_handler
operator|=
name|reload
expr_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
operator|(
name|sa
operator|.
name|sa_mask
operator|)
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
operator|(
name|sa
operator|.
name|sa_mask
operator|)
argument_list|,
name|SIGALRM
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
operator|(
name|sa
operator|.
name|sa_mask
operator|)
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGHUP
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_SIGACTION */
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|reload
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|reload
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_SIGACTION */
comment|/*    * SIGTERM: cleanup and exit.    */
ifdef|#
directive|ifdef
name|HAVE_SIGACTION
name|sa
operator|.
name|sa_handler
operator|=
name|cleanup
expr_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
operator|(
name|sa
operator|.
name|sa_mask
operator|)
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
operator|(
name|sa
operator|.
name|sa_mask
operator|)
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGTERM
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_SIGACTION */
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_SIGACTION */
comment|/*    * SIGCHLD: interlock synchronization and testing    */
ifdef|#
directive|ifdef
name|HAVE_SIGACTION
name|sa
operator|.
name|sa_handler
operator|=
name|interlock
expr_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
operator|(
name|sa
operator|.
name|sa_mask
operator|)
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
operator|(
name|sa
operator|.
name|sa_mask
operator|)
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGCHLD
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_SIGACTION */
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|interlock
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_SIGACTION */
comment|/*    * SIGUSR1: dump internal hlfsd maps/cache to file    */
ifdef|#
directive|ifdef
name|HAVE_SIGACTION
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|DEBUG_PRINT
argument_list|)
name|sa
operator|.
name|sa_handler
operator|=
name|plt_print
expr_stmt|;
else|#
directive|else
comment|/* not defined(DEBUG) || defined(DEBUG_PRINT) */
name|sa
operator|.
name|sa_handler
operator|=
name|SIG_IGN
expr_stmt|;
endif|#
directive|endif
comment|/* not defined(DEBUG) || defined(DEBUG_PRINT) */
name|sa
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
operator|(
name|sa
operator|.
name|sa_mask
operator|)
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
operator|(
name|sa
operator|.
name|sa_mask
operator|)
argument_list|,
name|SIGUSR1
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGUSR1
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_SIGACTION */
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|DEBUG_PRINT
argument_list|)
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|plt_print
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not defined(DEBUG) || defined(DEBUG_PRINT) */
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not defined(DEBUG) || defined(DEBUG_PRINT) */
endif|#
directive|endif
comment|/* not HAVE_SIGACTION */
if|if
condition|(
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|reloadinterval
argument_list|,
operator|(
expr|struct
name|itimerval
operator|*
operator|)
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"setitimer: %m"
argument_list|)
expr_stmt|;
name|gettimeofday
argument_list|(
operator|(
expr|struct
name|timeval
operator|*
operator|)
operator|&
name|startup
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/*    * If -D daemon, then start serving here in the child,    * and the parent will exit.  But if -D nodaemon, then    * skip this code and make sure svc_run is entered elsewhere.    */
name|amuDebug
argument_list|(
argument|D_DAEMON
argument_list|)
block|{
endif|#
directive|endif
comment|/* DEBUG */
comment|/*      * Dissociate from the controlling terminal      */
name|amu_release_controlling_tty
argument_list|()
expr_stmt|;
comment|/*      * signal parent we are ready. parent should      * mount(2) and die.      */
if|if
condition|(
name|kill
argument_list|(
name|getppid
argument_list|()
argument_list|,
name|SIGUSR2
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"kill: %m"
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"starting svc_run"
argument_list|)
expr_stmt|;
name|svc_run
argument_list|()
expr_stmt|;
name|cleanup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* should never happen, just in case */
ifdef|#
directive|ifdef
name|DEBUG
block|}
comment|/* end of code that runs iff hlfsd daemonizes */
endif|#
directive|endif
comment|/* DEBUG */
block|}
end_function

begin_function
specifier|static
name|RETSIGTYPE
name|proceed
parameter_list|(
name|int
name|signum
parameter_list|)
block|{
name|stoplight
operator|=
name|signum
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|RETSIGTYPE
name|reload
parameter_list|(
name|int
name|signum
parameter_list|)
block|{
name|int
name|child
decl_stmt|;
name|int
name|status
decl_stmt|;
name|clock_valid
operator|=
literal|0
expr_stmt|;
comment|/* invalidate logging clock */
if|if
condition|(
name|getpid
argument_list|()
operator|!=
name|masterpid
condition|)
return|return;
comment|/*    * If received a SIGHUP, close and reopen the log file (so that it    * can be rotated)    */
if|if
condition|(
name|signum
operator|==
name|SIGHUP
operator|&&
name|logfile
condition|)
name|switch_to_logfile
argument_list|(
name|logfile
argument_list|,
name|orig_umask
argument_list|)
expr_stmt|;
comment|/*    * parent performs the reload, while the child continues to serve    * clients accessing the home dir link.    */
if|if
condition|(
operator|(
name|child
operator|=
name|fork
argument_list|()
operator|)
operator|>
literal|0
condition|)
block|{
name|serverpid
operator|=
name|child
expr_stmt|;
comment|/* parent runs here */
name|am_set_mypid
argument_list|()
expr_stmt|;
name|plt_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|kill
argument_list|(
name|child
argument_list|,
name|SIGKILL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"kill child: %m"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* wait for child to die before continue */
if|if
condition|(
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|!=
name|child
condition|)
block|{
comment|/* 	 * I took out this line because it generates annoying output.  It 	 * indicates a very small bug in hlfsd which is totally harmless. 	 * It causes hlfsd to work a bit harder than it should. 	 * Nevertheless, I intend on fixing it in a future release. 	 * -Erez Zadok<ezk@cs.columbia.edu> 	 */
comment|/* plog(XLOG_ERROR, "unknown child"); */
block|}
block|}
name|serverpid
operator|=
name|masterpid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|<
literal|0
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"unable to fork: %m"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* let child handle requests while we reload */
name|serverpid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|am_set_mypid
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|RETSIGTYPE
name|cleanup
parameter_list|(
name|int
name|signum
parameter_list|)
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
name|int
name|umount_result
decl_stmt|;
name|clock_valid
operator|=
literal|0
expr_stmt|;
comment|/* invalidate logging clock */
ifdef|#
directive|ifdef
name|DEBUG
name|amuDebug
argument_list|(
argument|D_DAEMON
argument_list|)
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|getpid
argument_list|()
operator|!=
name|masterpid
condition|)
return|return;
ifdef|#
directive|ifdef
name|DEBUG
name|amuDebug
argument_list|(
argument|D_DAEMON
argument_list|)
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|fork
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|masterpid
operator|=
literal|0
expr_stmt|;
name|am_set_mypid
argument_list|()
expr_stmt|;
return|return;
block|}
name|am_set_mypid
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|(
name|umount_result
operator|=
name|UMOUNT_FS
argument_list|(
name|dir_name
argument_list|,
name|mnttab_file_name
argument_list|)
operator|)
operator|==
name|EBUSY
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"cleanup(): umount delaying for 10 seconds"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|dir_name
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|==
literal|0
operator|&&
name|stbuf
operator|.
name|st_ino
operator|==
name|ROOTID
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"unable to unmount %s"
argument_list|,
name|dir_name
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"suspending, unmount before terminating"
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|am_mypid
argument_list|,
name|SIGSTOP
argument_list|)
expr_stmt|;
continue|continue;
comment|/* retry unmount */
block|}
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"cleanup(): killing processes and terminating"
argument_list|)
expr_stmt|;
name|amuDebug
argument_list|(
argument|D_DAEMON
argument_list|)
endif|#
directive|endif
comment|/* DEBUG */
name|kill
argument_list|(
name|masterpid
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|amuDebug
argument_list|(
argument|D_DAEMON
argument_list|)
endif|#
directive|endif
comment|/* DEBUG */
name|kill
argument_list|(
name|serverpid
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"hlfsd terminating with status 0\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|RETSIGTYPE
name|reaper
parameter_list|(
name|int
name|signum
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
if|if
condition|(
name|wait
argument_list|(
operator|&
name|result
argument_list|)
operator|==
name|masterpid
condition|)
block|{
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|hlfsd_going_down
parameter_list|(
name|int
name|rc
parameter_list|)
block|{
name|int
name|mypid
init|=
name|getpid
argument_list|()
decl_stmt|;
comment|/* XXX: should this be the global am_mypid */
if|if
condition|(
name|mypid
operator|==
name|masterpid
condition|)
name|cleanup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mypid
operator|==
name|serverpid
condition|)
name|kill
argument_list|(
name|masterpid
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|rc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fatal
parameter_list|(
name|char
modifier|*
name|mess
parameter_list|)
block|{
if|if
condition|(
name|logfile
operator|&&
operator|!
name|STREQ
argument_list|(
name|logfile
argument_list|,
literal|"stderr"
argument_list|)
condition|)
block|{
name|char
name|lessmess
index|[
literal|128
index|]
decl_stmt|;
name|int
name|messlen
decl_stmt|;
name|messlen
operator|=
name|strlen
argument_list|(
name|mess
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|STREQ
argument_list|(
operator|&
name|mess
index|[
name|messlen
operator|+
literal|1
operator|-
sizeof|sizeof
argument_list|(
name|ERRM
argument_list|)
index|]
argument_list|,
name|ERRM
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|am_get_progname
argument_list|()
argument_list|,
name|mess
argument_list|)
expr_stmt|;
else|else
block|{
name|strcpy
argument_list|(
name|lessmess
argument_list|,
name|mess
argument_list|)
expr_stmt|;
name|lessmess
index|[
name|messlen
operator|-
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|errno
operator|<
name|sys_nerr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: %s\n"
argument_list|,
name|am_get_progname
argument_list|()
argument_list|,
name|lessmess
argument_list|,
ifdef|#
directive|ifdef
name|HAVE_STRERROR
name|strerror
argument_list|(
argument|errno
argument_list|)
else|#
directive|else
comment|/* not HAVE_STRERROR */
name|sys_errlist
index|[
name|errno
index|]
endif|#
directive|endif
comment|/* not HAVE_STRERROR */
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: Error %d\n"
argument_list|,
name|am_get_progname
argument_list|()
argument_list|,
name|lessmess
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
block|}
name|plog
argument_list|(
name|XLOG_FATAL
argument_list|,
name|mess
argument_list|)
expr_stmt|;
name|hlfsd_going_down
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

