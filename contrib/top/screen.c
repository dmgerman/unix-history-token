begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Top users/processes display for Unix  *  Version 3  *  *  This program may be freely redistributed,  *  but this entire comment MUST remain intact.  *  *  Copyright (c) 1984, 1989, William LeFebvre, Rice University  *  Copyright (c) 1989, 1990, 1992, William LeFebvre, Northwestern University  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  This file contains the routines that interface to termcap and stty/gtty.  *  *  Paul Vixie, February 1987: converted to use ioctl() instead of stty/gtty.  *  *  I put in code to turn on the TOSTOP bit while top was running, but I  *  didn't really like the results.  If you desire it, turn on the  *  preprocessor variable "TOStop".   --wnl  */
end_comment

begin_include
include|#
directive|include
file|"os.h"
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CBREAK
end_ifdef

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_define
define|#
directive|define
name|SGTTY
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|TCGETA
end_ifdef

begin_define
define|#
directive|define
name|TERMIO
end_define

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TERMIOS
end_define

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TERMIO
argument_list|)
operator|||
name|defined
argument_list|(
name|TERMIOS
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|TAB3
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|OXTABS
end_ifdef

begin_define
define|#
directive|define
name|TAB3
value|OXTABS
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TAB3
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"screen.h"
end_include

begin_include
include|#
directive|include
file|"boolean.h"
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|myname
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|putstdout
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|overstrike
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|screen_length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|screen_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ch_erase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ch_kill
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|smart_terminal
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|PC
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|tgetstr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|tgoto
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
name|termcap_buf
index|[
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|string_buffer
index|[
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|home
index|[
literal|15
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|lower_left
index|[
literal|15
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|clear_line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|clear_screen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|clear_to_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cursor_motion
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|start_standout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|end_standout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|terminal_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|terminal_end
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SGTTY
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|sgttyb
name|old_settings
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sgttyb
name|new_settings
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TERMIO
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|termio
name|old_settings
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|termio
name|new_settings
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TERMIOS
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|termios
name|old_settings
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|termios
name|new_settings
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|is_a_terminal
init|=
name|No
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TOStop
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|old_lword
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|new_lword
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|STDIN
value|0
end_define

begin_define
define|#
directive|define
name|STDOUT
value|1
end_define

begin_define
define|#
directive|define
name|STDERR
value|2
end_define

begin_macro
name|init_termcap
argument_list|(
argument|interactive
argument_list|)
end_macro

begin_decl_stmt
name|int
name|interactive
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|bufptr
decl_stmt|;
name|char
modifier|*
name|PCptr
decl_stmt|;
name|char
modifier|*
name|term_name
decl_stmt|;
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
name|int
name|status
decl_stmt|;
comment|/* set defaults in case we aren't smart */
name|screen_width
operator|=
name|MAX_COLS
expr_stmt|;
name|screen_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|interactive
condition|)
block|{
comment|/* pretend we have a dumb terminal */
name|smart_terminal
operator|=
name|No
expr_stmt|;
return|return;
block|}
comment|/* assume we have a smart terminal until proven otherwise */
name|smart_terminal
operator|=
name|Yes
expr_stmt|;
comment|/* get the terminal name */
name|term_name
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
comment|/* if there is no TERM, assume it's a dumb terminal */
comment|/* patch courtesy of Sam Horrocks at telegraph.ics.uci.edu */
if|if
condition|(
name|term_name
operator|==
name|NULL
condition|)
block|{
name|smart_terminal
operator|=
name|No
expr_stmt|;
return|return;
block|}
comment|/* now get the termcap entry */
if|if
condition|(
operator|(
name|status
operator|=
name|tgetent
argument_list|(
name|termcap_buf
argument_list|,
name|term_name
argument_list|)
operator|)
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't open termcap file\n"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: no termcap entry for a `%s' terminal\n"
argument_list|,
name|myname
argument_list|,
name|term_name
argument_list|)
expr_stmt|;
block|}
comment|/* pretend it's dumb and proceed */
name|smart_terminal
operator|=
name|No
expr_stmt|;
return|return;
block|}
comment|/* "hardcopy" immediately indicates a very stupid terminal */
if|if
condition|(
name|tgetflag
argument_list|(
literal|"hc"
argument_list|)
condition|)
block|{
name|smart_terminal
operator|=
name|No
expr_stmt|;
return|return;
block|}
comment|/* set up common terminal capabilities */
if|if
condition|(
operator|(
name|screen_length
operator|=
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|screen_length
operator|=
name|smart_terminal
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* screen_width is a little different */
if|if
condition|(
operator|(
name|screen_width
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|screen_width
operator|=
literal|79
expr_stmt|;
block|}
else|else
block|{
name|screen_width
operator|-=
literal|1
expr_stmt|;
block|}
comment|/* terminals that overstrike need special attention */
name|overstrike
operator|=
name|tgetflag
argument_list|(
literal|"os"
argument_list|)
expr_stmt|;
comment|/* initialize the pointer into the termcap string buffer */
name|bufptr
operator|=
name|string_buffer
expr_stmt|;
comment|/* get "ce", clear to end */
if|if
condition|(
operator|!
name|overstrike
condition|)
block|{
name|clear_line
operator|=
name|tgetstr
argument_list|(
literal|"ce"
argument_list|,
operator|&
name|bufptr
argument_list|)
expr_stmt|;
block|}
comment|/* get necessary capabilities */
if|if
condition|(
operator|(
name|clear_screen
operator|=
name|tgetstr
argument_list|(
literal|"cl"
argument_list|,
operator|&
name|bufptr
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|cursor_motion
operator|=
name|tgetstr
argument_list|(
literal|"cm"
argument_list|,
operator|&
name|bufptr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|smart_terminal
operator|=
name|No
expr_stmt|;
return|return;
block|}
comment|/* get some more sophisticated stuff -- these are optional */
name|clear_to_end
operator|=
name|tgetstr
argument_list|(
literal|"cd"
argument_list|,
operator|&
name|bufptr
argument_list|)
expr_stmt|;
name|terminal_init
operator|=
name|tgetstr
argument_list|(
literal|"ti"
argument_list|,
operator|&
name|bufptr
argument_list|)
expr_stmt|;
name|terminal_end
operator|=
name|tgetstr
argument_list|(
literal|"te"
argument_list|,
operator|&
name|bufptr
argument_list|)
expr_stmt|;
name|start_standout
operator|=
name|tgetstr
argument_list|(
literal|"so"
argument_list|,
operator|&
name|bufptr
argument_list|)
expr_stmt|;
name|end_standout
operator|=
name|tgetstr
argument_list|(
literal|"se"
argument_list|,
operator|&
name|bufptr
argument_list|)
expr_stmt|;
comment|/* pad character */
name|PC
operator|=
operator|(
name|PCptr
operator|=
name|tgetstr
argument_list|(
literal|"pc"
argument_list|,
operator|&
name|bufptr
argument_list|)
operator|)
condition|?
operator|*
name|PCptr
else|:
literal|0
expr_stmt|;
comment|/* set convenience strings */
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|home
argument_list|,
name|tgoto
argument_list|(
name|cursor_motion
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|home
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|home
index|[
sizeof|sizeof
argument_list|(
name|home
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* (lower_left is set in get_screensize) */
comment|/* get the actual screen size with an ioctl, if needed */
comment|/* This may change screen_width and screen_length, and it always        sets lower_left. */
name|get_screensize
argument_list|()
expr_stmt|;
comment|/* if stdout is not a terminal, pretend we are a dumb terminal */
ifdef|#
directive|ifdef
name|SGTTY
if|if
condition|(
name|ioctl
argument_list|(
name|STDOUT
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|old_settings
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|smart_terminal
operator|=
name|No
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERMIO
if|if
condition|(
name|ioctl
argument_list|(
name|STDOUT
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|old_settings
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|smart_terminal
operator|=
name|No
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERMIOS
if|if
condition|(
name|tcgetattr
argument_list|(
name|STDOUT
argument_list|,
operator|&
name|old_settings
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|smart_terminal
operator|=
name|No
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_macro
name|init_screen
argument_list|()
end_macro

begin_block
block|{
comment|/* get the old settings for safe keeping */
ifdef|#
directive|ifdef
name|SGTTY
if|if
condition|(
name|ioctl
argument_list|(
name|STDOUT
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|old_settings
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* copy the settings so we can modify them */
name|new_settings
operator|=
name|old_settings
expr_stmt|;
comment|/* turn on CBREAK and turn off character echo and tab expansion */
name|new_settings
operator|.
name|sg_flags
operator||=
name|CBREAK
expr_stmt|;
name|new_settings
operator|.
name|sg_flags
operator|&=
operator|~
operator|(
name|ECHO
operator||
name|XTABS
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|STDOUT
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|new_settings
argument_list|)
expr_stmt|;
comment|/* remember the erase and kill characters */
name|ch_erase
operator|=
name|old_settings
operator|.
name|sg_erase
expr_stmt|;
name|ch_kill
operator|=
name|old_settings
operator|.
name|sg_kill
expr_stmt|;
ifdef|#
directive|ifdef
name|TOStop
comment|/* get the local mode word */
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|STDOUT
argument_list|,
name|TIOCLGET
argument_list|,
operator|&
name|old_lword
argument_list|)
expr_stmt|;
comment|/* modify it */
name|new_lword
operator|=
name|old_lword
operator||
name|LTOSTOP
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|STDOUT
argument_list|,
name|TIOCLSET
argument_list|,
operator|&
name|new_lword
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* remember that it really is a terminal */
name|is_a_terminal
operator|=
name|Yes
expr_stmt|;
comment|/* send the termcap initialization string */
name|putcap
argument_list|(
name|terminal_init
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERMIO
if|if
condition|(
name|ioctl
argument_list|(
name|STDOUT
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|old_settings
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* copy the settings so we can modify them */
name|new_settings
operator|=
name|old_settings
expr_stmt|;
comment|/* turn off ICANON, character echo and tab expansion */
name|new_settings
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ICANON
operator||
name|ECHO
operator|)
expr_stmt|;
name|new_settings
operator|.
name|c_oflag
operator|&=
operator|~
operator|(
name|TAB3
operator|)
expr_stmt|;
name|new_settings
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|new_settings
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|STDOUT
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|new_settings
argument_list|)
expr_stmt|;
comment|/* remember the erase and kill characters */
name|ch_erase
operator|=
name|old_settings
operator|.
name|c_cc
index|[
name|VERASE
index|]
expr_stmt|;
name|ch_kill
operator|=
name|old_settings
operator|.
name|c_cc
index|[
name|VKILL
index|]
expr_stmt|;
comment|/* remember that it really is a terminal */
name|is_a_terminal
operator|=
name|Yes
expr_stmt|;
comment|/* send the termcap initialization string */
name|putcap
argument_list|(
name|terminal_init
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERMIOS
if|if
condition|(
name|tcgetattr
argument_list|(
name|STDOUT
argument_list|,
operator|&
name|old_settings
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* copy the settings so we can modify them */
name|new_settings
operator|=
name|old_settings
expr_stmt|;
comment|/* turn off ICANON, character echo and tab expansion */
name|new_settings
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ICANON
operator||
name|ECHO
operator|)
expr_stmt|;
name|new_settings
operator|.
name|c_oflag
operator|&=
operator|~
operator|(
name|TAB3
operator|)
expr_stmt|;
name|new_settings
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|new_settings
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|tcsetattr
argument_list|(
name|STDOUT
argument_list|,
name|TCSADRAIN
argument_list|,
operator|&
name|new_settings
argument_list|)
expr_stmt|;
comment|/* remember the erase and kill characters */
name|ch_erase
operator|=
name|old_settings
operator|.
name|c_cc
index|[
name|VERASE
index|]
expr_stmt|;
name|ch_kill
operator|=
name|old_settings
operator|.
name|c_cc
index|[
name|VKILL
index|]
expr_stmt|;
comment|/* remember that it really is a terminal */
name|is_a_terminal
operator|=
name|Yes
expr_stmt|;
comment|/* send the termcap initialization string */
name|putcap
argument_list|(
name|terminal_init
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|is_a_terminal
condition|)
block|{
comment|/* not a terminal at all---consider it dumb */
name|smart_terminal
operator|=
name|No
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|end_screen
argument_list|()
end_macro

begin_block
block|{
comment|/* move to the lower left, clear the line and send "te" */
if|if
condition|(
name|smart_terminal
condition|)
block|{
name|putcap
argument_list|(
name|lower_left
argument_list|)
expr_stmt|;
name|putcap
argument_list|(
name|clear_line
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|putcap
argument_list|(
name|terminal_end
argument_list|)
expr_stmt|;
block|}
comment|/* if we have settings to reset, then do so */
if|if
condition|(
name|is_a_terminal
condition|)
block|{
ifdef|#
directive|ifdef
name|SGTTY
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|STDOUT
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|old_settings
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TOStop
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|STDOUT
argument_list|,
name|TIOCLSET
argument_list|,
operator|&
name|old_lword
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERMIO
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|STDOUT
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|old_settings
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERMIOS
operator|(
name|void
operator|)
name|tcsetattr
argument_list|(
name|STDOUT
argument_list|,
name|TCSADRAIN
argument_list|,
operator|&
name|old_settings
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_block

begin_macro
name|reinit_screen
argument_list|()
end_macro

begin_block
block|{
comment|/* install our settings if it is a terminal */
if|if
condition|(
name|is_a_terminal
condition|)
block|{
ifdef|#
directive|ifdef
name|SGTTY
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|STDOUT
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|new_settings
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TOStop
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|STDOUT
argument_list|,
name|TIOCLSET
argument_list|,
operator|&
name|new_lword
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERMIO
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|STDOUT
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|new_settings
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERMIOS
operator|(
name|void
operator|)
name|tcsetattr
argument_list|(
name|STDOUT
argument_list|,
name|TCSADRAIN
argument_list|,
operator|&
name|new_settings
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* send init string */
if|if
condition|(
name|smart_terminal
condition|)
block|{
name|putcap
argument_list|(
name|terminal_init
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|get_screensize
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|TIOCGWINSZ
name|struct
name|winsize
name|ws
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|1
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|ws
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ws
operator|.
name|ws_row
operator|!=
literal|0
condition|)
block|{
name|screen_length
operator|=
name|ws
operator|.
name|ws_row
expr_stmt|;
block|}
if|if
condition|(
name|ws
operator|.
name|ws_col
operator|!=
literal|0
condition|)
block|{
name|screen_width
operator|=
name|ws
operator|.
name|ws_col
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|TIOCGSIZE
name|struct
name|ttysize
name|ts
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|1
argument_list|,
name|TIOCGSIZE
argument_list|,
operator|&
name|ts
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ts
operator|.
name|ts_lines
operator|!=
literal|0
condition|)
block|{
name|screen_length
operator|=
name|ts
operator|.
name|ts_lines
expr_stmt|;
block|}
if|if
condition|(
name|ts
operator|.
name|ts_cols
operator|!=
literal|0
condition|)
block|{
name|screen_width
operator|=
name|ts
operator|.
name|ts_cols
operator|-
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* TIOCGSIZE */
endif|#
directive|endif
comment|/* TIOCGWINSZ */
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|lower_left
argument_list|,
name|tgoto
argument_list|(
name|cursor_motion
argument_list|,
literal|0
argument_list|,
name|screen_length
operator|-
literal|1
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|lower_left
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|lower_left
index|[
sizeof|sizeof
argument_list|(
name|lower_left
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_macro
name|standout
argument_list|(
argument|msg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|smart_terminal
condition|)
block|{
name|putcap
argument_list|(
name|start_standout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|msg
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putcap
argument_list|(
name|end_standout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputs
argument_list|(
name|msg
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|clear
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|smart_terminal
condition|)
block|{
name|putcap
argument_list|(
name|clear_screen
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|clear_eol
argument_list|(
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|smart_terminal
operator|&&
operator|!
name|overstrike
operator|&&
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|clear_line
condition|)
block|{
name|putcap
argument_list|(
name|clear_line
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|go_home
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|smart_terminal
condition|)
block|{
name|putcap
argument_list|(
name|home
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* This has to be defined as a subroutine for tputs (instead of a macro) */
end_comment

begin_macro
name|putstdout
argument_list|(
argument|ch
argument_list|)
end_macro

begin_decl_stmt
name|char
name|ch
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

