begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Top users/processes display for Unix  *  Version 3  *  *  This program may be freely redistributed,  *  but this entire comment MUST remain intact.  *  *  Copyright (c) 1984, 1989, William LeFebvre, Rice University  *  Copyright (c) 1989, 1990, 1992, William LeFebvre, Northwestern University  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  *  This file contains the routines that display information on the screen.  *  Each section of the screen has two routines:  one for initially writing  *  all constant and dynamic text, and one for only updating the text that  *  changes.  The prefix "i_" is used on all the "initial" routines and the  *  prefix "u_" is used for all the "updating" routines.  *  *  ASSUMPTIONS:  *        None of the "i_" routines use any of the termcap capabilities.  *        In this way, those routines can be safely used on terminals that  *        have minimal (or nonexistant) terminal capabilities.  *  *        The routines are called in this order:  *_loadave, i_timeofday,  *        *_procstates, *_cpustates, *_memory, *_message, *_header,  *        *_process, u_endscreen.  */
end_comment

begin_include
include|#
directive|include
file|"os.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"screen.h"
end_include

begin_comment
comment|/* interface to screen package */
end_comment

begin_include
include|#
directive|include
file|"layout.h"
end_include

begin_comment
comment|/* defines for screen position layout */
end_comment

begin_include
include|#
directive|include
file|"display.h"
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_include
include|#
directive|include
file|"top.local.h"
end_include

begin_include
include|#
directive|include
file|"boolean.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_comment
comment|/* we should eliminate this!!! */
end_comment

begin_include
include|#
directive|include
file|"utils.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|FILE
modifier|*
name|debug
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* imported from screen.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|overstrike
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lmpid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|last_hi
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used in u_process and u_endscreen */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lastline
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|display_width
init|=
name|MAX_COLS
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|lineindex
parameter_list|(
name|l
parameter_list|)
value|((l)*display_width)
end_define

begin_function_decl
name|char
modifier|*
name|printable
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* things initialized by display_init and used thruout */
end_comment

begin_comment
comment|/* buffer of proc information lines for display updating */
end_comment

begin_decl_stmt
name|char
modifier|*
name|screenbuf
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|procstate_names
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|cpustate_names
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|memory_names
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|swap_names
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_procstates
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_cpustates
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_memory
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_swap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|lprocstates
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|lcpustates
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|lmemory
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|lswap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|cpustate_columns
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cpustate_total_length
decl_stmt|;
end_decl_stmt

begin_enum
specifier|static
enum|enum
block|{
name|OFF
block|,
name|ON
block|,
name|ERASE
block|}
name|header_status
init|=
name|ON
enum|;
end_enum

begin_function_decl
specifier|static
name|int
name|string_count
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|summary_format
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|line_update
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|int
name|display_resize
parameter_list|()
block|{
specifier|register
name|int
name|lines
decl_stmt|;
comment|/* first, deallocate any previous buffer that may have been there */
if|if
condition|(
name|screenbuf
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|screenbuf
argument_list|)
expr_stmt|;
block|}
comment|/* calculate the current dimensions */
comment|/* if operating in "dumb" mode, we only need one line */
name|lines
operator|=
name|smart_terminal
condition|?
name|screen_length
operator|-
name|Header_lines
else|:
literal|1
expr_stmt|;
comment|/* we don't want more than MAX_COLS columns, since the machine-dependent        modules make static allocations based on MAX_COLS and we don't want        to run off the end of their buffers */
name|display_width
operator|=
name|screen_width
expr_stmt|;
if|if
condition|(
name|display_width
operator|>=
name|MAX_COLS
condition|)
block|{
name|display_width
operator|=
name|MAX_COLS
operator|-
literal|1
expr_stmt|;
block|}
comment|/* now, allocate space for the screen buffer */
name|screenbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|lines
operator|*
name|display_width
argument_list|)
expr_stmt|;
if|if
condition|(
name|screenbuf
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* oops! */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* return number of lines available */
comment|/* for dumb terminals, pretend like we can show any amount */
return|return
operator|(
name|smart_terminal
condition|?
name|lines
else|:
name|Largest
operator|)
return|;
block|}
end_function

begin_function
name|int
name|display_init
parameter_list|(
name|statics
parameter_list|)
name|struct
name|statics
modifier|*
name|statics
decl_stmt|;
block|{
specifier|register
name|int
name|lines
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|register
name|int
modifier|*
name|ip
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* call resize to do the dirty work */
name|lines
operator|=
name|display_resize
argument_list|()
expr_stmt|;
comment|/* only do the rest if we need to */
if|if
condition|(
name|lines
operator|>
operator|-
literal|1
condition|)
block|{
comment|/* save pointers and allocate space for names */
name|procstate_names
operator|=
name|statics
operator|->
name|procstate_names
expr_stmt|;
name|num_procstates
operator|=
name|string_count
argument_list|(
name|procstate_names
argument_list|)
expr_stmt|;
name|lprocstates
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
name|num_procstates
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|cpustate_names
operator|=
name|statics
operator|->
name|cpustate_names
expr_stmt|;
name|swap_names
operator|=
name|statics
operator|->
name|swap_names
expr_stmt|;
name|num_swap
operator|=
name|string_count
argument_list|(
name|swap_names
argument_list|)
expr_stmt|;
name|lswap
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
name|num_swap
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|num_cpustates
operator|=
name|string_count
argument_list|(
name|cpustate_names
argument_list|)
expr_stmt|;
name|lcpustates
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
name|num_cpustates
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|cpustate_columns
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
name|num_cpustates
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memory_names
operator|=
name|statics
operator|->
name|memory_names
expr_stmt|;
name|num_memory
operator|=
name|string_count
argument_list|(
name|memory_names
argument_list|)
expr_stmt|;
name|lmemory
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
name|num_memory
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* calculate starting columns where needed */
name|cpustate_total_length
operator|=
literal|0
expr_stmt|;
name|pp
operator|=
name|cpustate_names
expr_stmt|;
name|ip
operator|=
name|cpustate_columns
expr_stmt|;
while|while
condition|(
operator|*
name|pp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ip
operator|++
operator|=
name|cpustate_total_length
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|strlen
argument_list|(
operator|*
name|pp
operator|++
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|cpustate_total_length
operator|+=
name|i
operator|+
literal|8
expr_stmt|;
block|}
block|}
block|}
comment|/* return number of lines available */
return|return
operator|(
name|lines
operator|)
return|;
block|}
end_function

begin_macro
name|i_loadave
argument_list|(
argument|mpid
argument_list|,
argument|avenrun
argument_list|)
end_macro

begin_decl_stmt
name|int
name|mpid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
modifier|*
name|avenrun
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* i_loadave also clears the screen, since it is first */
name|clear
argument_list|()
expr_stmt|;
comment|/* mpid == -1 implies this system doesn't have an _mpid */
if|if
condition|(
name|mpid
operator|!=
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"last pid: %5d;  "
argument_list|,
name|mpid
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"load averages"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%c %5.2f"
argument_list|,
name|i
operator|==
literal|0
condition|?
literal|':'
else|:
literal|','
argument_list|,
name|avenrun
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|lmpid
operator|=
name|mpid
expr_stmt|;
block|}
end_block

begin_macro
name|u_loadave
argument_list|(
argument|mpid
argument_list|,
argument|avenrun
argument_list|)
end_macro

begin_decl_stmt
name|int
name|mpid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
modifier|*
name|avenrun
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|mpid
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* change screen only when value has really changed */
if|if
condition|(
name|mpid
operator|!=
name|lmpid
condition|)
block|{
name|Move_to
argument_list|(
name|x_lastpid
argument_list|,
name|y_lastpid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%5d"
argument_list|,
name|mpid
argument_list|)
expr_stmt|;
name|lmpid
operator|=
name|mpid
expr_stmt|;
block|}
comment|/* i remembers x coordinate to move to */
name|i
operator|=
name|x_loadave
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|x_loadave_nompid
expr_stmt|;
block|}
comment|/* move into position for load averages */
name|Move_to
argument_list|(
name|i
argument_list|,
name|y_loadave
argument_list|)
expr_stmt|;
comment|/* display new load averages */
comment|/* we should optimize this and only display changes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%s%5.2f"
argument_list|,
name|i
operator|==
literal|0
condition|?
literal|""
else|:
literal|", "
argument_list|,
name|avenrun
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|i_timeofday
argument_list|(
argument|tod
argument_list|)
end_macro

begin_decl_stmt
name|time_t
modifier|*
name|tod
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/*      *  Display the current time.      *  "ctime" always returns a string that looks like this:      *        *	Sun Sep 16 01:03:52 1973      *      012345678901234567890123      *	          1         2      *      *  We want indices 11 thru 18 (length 8).      */
if|if
condition|(
name|smart_terminal
condition|)
block|{
name|Move_to
argument_list|(
name|screen_width
operator|-
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputs
argument_list|(
literal|"    "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
block|{
name|char
modifier|*
name|foo
decl_stmt|;
name|foo
operator|=
name|ctime
argument_list|(
name|tod
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|foo
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|printf
argument_list|(
literal|"%-8.8s\n"
argument_list|,
operator|&
operator|(
name|ctime
argument_list|(
name|tod
argument_list|)
index|[
literal|11
index|]
operator|)
argument_list|)
expr_stmt|;
name|lastline
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|int
name|ltotal
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|procstates_buffer
index|[
name|MAX_COLS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  *_procstates(total, brkdn, names) - print the process summary line  *  *  Assumptions:  cursor is at the beginning of the line on entry  *		  lastline is valid  */
end_comment

begin_macro
name|i_procstates
argument_list|(
argument|total
argument_list|,
argument|brkdn
argument_list|)
end_macro

begin_decl_stmt
name|int
name|total
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|brkdn
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* write current number of processes and remember the value */
name|printf
argument_list|(
literal|"%d processes:"
argument_list|,
name|total
argument_list|)
expr_stmt|;
name|ltotal
operator|=
name|total
expr_stmt|;
comment|/* put out enough spaces to get to column 15 */
name|i
operator|=
name|digits
argument_list|(
name|total
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|++
operator|<
literal|4
condition|)
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
comment|/* format and print the process state summary */
name|summary_format
argument_list|(
name|procstates_buffer
argument_list|,
name|brkdn
argument_list|,
name|procstate_names
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|procstates_buffer
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* save the numbers for next time */
name|memcpy
argument_list|(
name|lprocstates
argument_list|,
name|brkdn
argument_list|,
name|num_procstates
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|u_procstates
argument_list|(
argument|total
argument_list|,
argument|brkdn
argument_list|)
end_macro

begin_decl_stmt
name|int
name|total
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|brkdn
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
name|new
index|[
name|MAX_COLS
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* update number of processes only if it has changed */
if|if
condition|(
name|ltotal
operator|!=
name|total
condition|)
block|{
comment|/* move and overwrite */
if|#
directive|if
operator|(
name|x_procstate
operator|==
literal|0
operator|)
name|Move_to
argument_list|(
name|x_procstate
argument_list|,
name|y_procstate
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* cursor is already there...no motion needed */
comment|/* assert(lastline == 1); */
endif|#
directive|endif
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|total
argument_list|)
expr_stmt|;
comment|/* if number of digits differs, rewrite the label */
if|if
condition|(
name|digits
argument_list|(
name|total
argument_list|)
operator|!=
name|digits
argument_list|(
name|ltotal
argument_list|)
condition|)
block|{
name|fputs
argument_list|(
literal|" processes:"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* put out enough spaces to get to column 15 */
name|i
operator|=
name|digits
argument_list|(
name|total
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|++
operator|<
literal|4
condition|)
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
comment|/* cursor may end up right where we want it!!! */
block|}
comment|/* save new total */
name|ltotal
operator|=
name|total
expr_stmt|;
block|}
comment|/* see if any of the state numbers has changed */
if|if
condition|(
name|memcmp
argument_list|(
name|lprocstates
argument_list|,
name|brkdn
argument_list|,
name|num_procstates
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* format and update the line */
name|summary_format
argument_list|(
name|new
argument_list|,
name|brkdn
argument_list|,
name|procstate_names
argument_list|)
expr_stmt|;
name|line_update
argument_list|(
name|procstates_buffer
argument_list|,
name|new
argument_list|,
name|x_brkdn
argument_list|,
name|y_brkdn
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|lprocstates
argument_list|,
name|brkdn
argument_list|,
name|num_procstates
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *  *_cpustates(states, names) - print the cpu state percentages  *  *  Assumptions:  cursor is on the PREVIOUS line  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cpustates_column
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cpustates_tag() calculates the correct tag to use to label the line */
end_comment

begin_function
name|char
modifier|*
name|cpustates_tag
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|use
decl_stmt|;
specifier|static
name|char
modifier|*
name|short_tag
init|=
literal|"CPU: "
decl_stmt|;
specifier|static
name|char
modifier|*
name|long_tag
init|=
literal|"CPU states: "
decl_stmt|;
comment|/* if length + strlen(long_tag)>= screen_width, then we have to        use the shorter tag (we subtract 2 to account for ": ") */
if|if
condition|(
name|cpustate_total_length
operator|+
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|long_tag
argument_list|)
operator|-
literal|2
operator|>=
name|screen_width
condition|)
block|{
name|use
operator|=
name|short_tag
expr_stmt|;
block|}
else|else
block|{
name|use
operator|=
name|long_tag
expr_stmt|;
block|}
comment|/* set cpustates_column accordingly then return result */
name|cpustates_column
operator|=
name|strlen
argument_list|(
name|use
argument_list|)
expr_stmt|;
return|return
operator|(
name|use
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|i_cpustates
argument_list|(
name|states
argument_list|)
specifier|register
name|int
operator|*
name|states
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|value
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|names
init|=
name|cpustate_names
decl_stmt|;
specifier|register
name|char
modifier|*
name|thisname
decl_stmt|;
comment|/* print tag and bump lastline */
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|cpustates_tag
argument_list|()
argument_list|)
expr_stmt|;
name|lastline
operator|++
expr_stmt|;
comment|/* now walk thru the names and print the line */
while|while
condition|(
operator|(
name|thisname
operator|=
operator|*
name|names
operator|++
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|thisname
operator|!=
literal|'\0'
condition|)
block|{
comment|/* retrieve the value and remember it */
name|value
operator|=
operator|*
name|states
operator|++
expr_stmt|;
comment|/* if percentage is>= 1000, print it as 100% */
name|printf
argument_list|(
operator|(
name|value
operator|>=
literal|1000
condition|?
literal|"%s%4.0f%% %s"
else|:
literal|"%s%4.1f%% %s"
operator|)
argument_list|,
name|i
operator|++
operator|==
literal|0
condition|?
literal|""
else|:
literal|", "
argument_list|,
operator|(
operator|(
name|float
operator|)
name|value
operator|)
operator|/
literal|10.
argument_list|,
name|thisname
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* copy over values into "last" array */
name|memcpy
argument_list|(
name|lcpustates
argument_list|,
name|states
argument_list|,
name|num_cpustates
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|u_cpustates
argument_list|(
name|states
argument_list|)
specifier|register
name|int
operator|*
name|states
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|value
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|names
init|=
name|cpustate_names
decl_stmt|;
specifier|register
name|char
modifier|*
name|thisname
decl_stmt|;
specifier|register
name|int
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
modifier|*
name|colp
decl_stmt|;
name|Move_to
argument_list|(
name|cpustates_column
argument_list|,
name|y_cpustates
argument_list|)
expr_stmt|;
name|lastline
operator|=
name|y_cpustates
expr_stmt|;
name|lp
operator|=
name|lcpustates
expr_stmt|;
name|colp
operator|=
name|cpustate_columns
expr_stmt|;
comment|/* we could be much more optimal about this */
while|while
condition|(
operator|(
name|thisname
operator|=
operator|*
name|names
operator|++
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|thisname
operator|!=
literal|'\0'
condition|)
block|{
comment|/* did the value change since last time? */
if|if
condition|(
operator|*
name|lp
operator|!=
operator|*
name|states
condition|)
block|{
comment|/* yes, move and change */
name|Move_to
argument_list|(
name|cpustates_column
operator|+
operator|*
name|colp
argument_list|,
name|y_cpustates
argument_list|)
expr_stmt|;
name|lastline
operator|=
name|y_cpustates
expr_stmt|;
comment|/* retrieve value and remember it */
name|value
operator|=
operator|*
name|states
expr_stmt|;
comment|/* if percentage is>= 1000, print it as 100% */
name|printf
argument_list|(
operator|(
name|value
operator|>=
literal|1000
condition|?
literal|"%4.0f"
else|:
literal|"%4.1f"
operator|)
argument_list|,
operator|(
operator|(
name|double
operator|)
name|value
operator|)
operator|/
literal|10.
argument_list|)
expr_stmt|;
comment|/* remember it for next time */
operator|*
name|lp
operator|=
name|value
expr_stmt|;
block|}
block|}
comment|/* increment and move on */
name|lp
operator|++
expr_stmt|;
name|states
operator|++
expr_stmt|;
name|colp
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|z_cpustates
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|names
init|=
name|cpustate_names
decl_stmt|;
specifier|register
name|char
modifier|*
name|thisname
decl_stmt|;
specifier|register
name|int
modifier|*
name|lp
decl_stmt|;
comment|/* show tag and bump lastline */
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|cpustates_tag
argument_list|()
argument_list|)
expr_stmt|;
name|lastline
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|thisname
operator|=
operator|*
name|names
operator|++
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|thisname
operator|!=
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"%s    %% %s"
argument_list|,
name|i
operator|++
operator|==
literal|0
condition|?
literal|""
else|:
literal|", "
argument_list|,
name|thisname
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* fill the "last" array with all -1s, to insure correct updating */
name|lp
operator|=
name|lcpustates
expr_stmt|;
name|i
operator|=
name|num_cpustates
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
operator|*
name|lp
operator|++
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *  *_memory(stats) - print "Memory: " followed by the memory summary string  *  *  Assumptions:  cursor is on "lastline"  *                for i_memory ONLY: cursor is on the previous line  */
end_comment

begin_decl_stmt
name|char
name|memory_buffer
index|[
name|MAX_COLS
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|i_memory
argument_list|(
argument|stats
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|stats
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fputs
argument_list|(
literal|"\nMem: "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|lastline
operator|++
expr_stmt|;
comment|/* format and print the memory summary */
name|summary_format
argument_list|(
name|memory_buffer
argument_list|,
name|stats
argument_list|,
name|memory_names
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|memory_buffer
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|u_memory
argument_list|(
argument|stats
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|stats
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
name|new
index|[
name|MAX_COLS
index|]
decl_stmt|;
comment|/* format the new line */
name|summary_format
argument_list|(
name|new
argument_list|,
name|stats
argument_list|,
name|memory_names
argument_list|)
expr_stmt|;
name|line_update
argument_list|(
name|memory_buffer
argument_list|,
name|new
argument_list|,
name|x_mem
argument_list|,
name|y_mem
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  *_swap(stats) - print "Swap: " followed by the swap summary string  *  *  Assumptions:  cursor is on "lastline"  *                for i_swap ONLY: cursor is on the previous line  */
end_comment

begin_decl_stmt
name|char
name|swap_buffer
index|[
name|MAX_COLS
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|i_swap
argument_list|(
argument|stats
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|stats
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fputs
argument_list|(
literal|"\nSwap: "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|lastline
operator|++
expr_stmt|;
comment|/* format and print the swap summary */
name|summary_format
argument_list|(
name|swap_buffer
argument_list|,
name|stats
argument_list|,
name|swap_names
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|swap_buffer
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|u_swap
argument_list|(
argument|stats
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|stats
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
name|new
index|[
name|MAX_COLS
index|]
decl_stmt|;
comment|/* format the new line */
name|summary_format
argument_list|(
name|new
argument_list|,
name|stats
argument_list|,
name|swap_names
argument_list|)
expr_stmt|;
name|line_update
argument_list|(
name|swap_buffer
argument_list|,
name|new
argument_list|,
name|x_swap
argument_list|,
name|y_swap
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *  *_message() - print the next pending message line, or erase the one  *                that is there.  *  *  Note that u_message is (currently) the same as i_message.  *  *  Assumptions:  lastline is consistent  */
end_comment

begin_comment
comment|/*  *  i_message is funny because it gets its message asynchronously (with  *	respect to screen updates).  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|next_msg
index|[
name|MAX_COLS
operator|+
literal|5
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|msglen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Invariant: msglen is always the length of the message currently displayed    on the screen (even when next_msg doesn't contain that message). */
end_comment

begin_macro
name|i_message
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
name|lastline
operator|<
name|y_message
condition|)
block|{
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|lastline
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|next_msg
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|standout
argument_list|(
name|next_msg
argument_list|)
expr_stmt|;
name|msglen
operator|=
name|strlen
argument_list|(
name|next_msg
argument_list|)
expr_stmt|;
name|next_msg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|msglen
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|clear_eol
argument_list|(
name|msglen
argument_list|)
expr_stmt|;
name|msglen
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|u_message
argument_list|()
end_macro

begin_block
block|{
name|i_message
argument_list|()
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|int
name|header_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  *_header(text) - print the header for the process area  *  *  Assumptions:  cursor is on the previous line and lastline is consistent  */
end_comment

begin_macro
name|i_header
argument_list|(
argument|text
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|text
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|header_length
operator|=
name|strlen
argument_list|(
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|header_status
operator|==
name|ON
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|text
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|lastline
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|header_status
operator|==
name|ERASE
condition|)
block|{
name|header_status
operator|=
name|OFF
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|u_header
argument_list|(
argument|text
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|text
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ignored */
end_comment

begin_block
block|{
if|if
condition|(
name|header_status
operator|==
name|ERASE
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|lastline
operator|++
expr_stmt|;
name|clear_eol
argument_list|(
name|header_length
argument_list|)
expr_stmt|;
name|header_status
operator|=
name|OFF
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *  *_process(line, thisline) - print one process line  *  *  Assumptions:  lastline is consistent  */
end_comment

begin_macro
name|i_process
argument_list|(
argument|line
argument_list|,
argument|thisline
argument_list|)
end_macro

begin_decl_stmt
name|int
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|thisline
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|base
decl_stmt|;
comment|/* make sure we are on the correct line */
while|while
condition|(
name|lastline
operator|<
name|y_procs
operator|+
name|line
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|lastline
operator|++
expr_stmt|;
block|}
comment|/* truncate the line to conform to our current screen width */
name|thisline
index|[
name|display_width
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* write the line out */
name|fputs
argument_list|(
name|thisline
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* copy it in to our buffer */
name|base
operator|=
name|smart_terminal
condition|?
name|screenbuf
operator|+
name|lineindex
argument_list|(
name|line
argument_list|)
else|:
name|screenbuf
expr_stmt|;
name|p
operator|=
name|strecpy
argument_list|(
name|base
argument_list|,
name|thisline
argument_list|)
expr_stmt|;
comment|/* zero fill the rest of it */
name|memzero
argument_list|(
name|p
argument_list|,
name|display_width
operator|-
operator|(
name|p
operator|-
name|base
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|u_process
argument_list|(
argument|line
argument_list|,
argument|newline
argument_list|)
end_macro

begin_decl_stmt
name|int
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|newline
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|optr
decl_stmt|;
specifier|register
name|int
name|screen_line
init|=
name|line
operator|+
name|Header_lines
decl_stmt|;
specifier|register
name|char
modifier|*
name|bufferline
decl_stmt|;
comment|/* remember a pointer to the current line in the screen buffer */
name|bufferline
operator|=
operator|&
name|screenbuf
index|[
name|lineindex
argument_list|(
name|line
argument_list|)
index|]
expr_stmt|;
comment|/* truncate the line to conform to our current screen width */
name|newline
index|[
name|display_width
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* is line higher than we went on the last display? */
if|if
condition|(
name|line
operator|>=
name|last_hi
condition|)
block|{
comment|/* yes, just ignore screenbuf and write it out directly */
comment|/* get positioned on the correct line */
if|if
condition|(
name|screen_line
operator|-
name|lastline
operator|==
literal|1
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|lastline
operator|++
expr_stmt|;
block|}
else|else
block|{
name|Move_to
argument_list|(
literal|0
argument_list|,
name|screen_line
argument_list|)
expr_stmt|;
name|lastline
operator|=
name|screen_line
expr_stmt|;
block|}
comment|/* now write the line */
name|fputs
argument_list|(
name|newline
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* copy it in to the buffer */
name|optr
operator|=
name|strecpy
argument_list|(
name|bufferline
argument_list|,
name|newline
argument_list|)
expr_stmt|;
comment|/* zero fill the rest of it */
name|memzero
argument_list|(
name|optr
argument_list|,
name|display_width
operator|-
operator|(
name|optr
operator|-
name|bufferline
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|line_update
argument_list|(
name|bufferline
argument_list|,
name|newline
argument_list|,
literal|0
argument_list|,
name|line
operator|+
name|Header_lines
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|u_endscreen
argument_list|(
name|hi
argument_list|)
specifier|register
name|int
name|hi
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|screen_line
init|=
name|hi
operator|+
name|Header_lines
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|smart_terminal
condition|)
block|{
if|if
condition|(
name|hi
operator|<
name|last_hi
condition|)
block|{
comment|/* need to blank the remainder of the screen */
comment|/* but only if there is any screen left below this line */
if|if
condition|(
name|lastline
operator|+
literal|1
operator|<
name|screen_length
condition|)
block|{
comment|/* efficiently move to the end of currently displayed info */
if|if
condition|(
name|screen_line
operator|-
name|lastline
operator|<
literal|5
condition|)
block|{
while|while
condition|(
name|lastline
operator|<
name|screen_line
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|lastline
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|Move_to
argument_list|(
literal|0
argument_list|,
name|screen_line
argument_list|)
expr_stmt|;
name|lastline
operator|=
name|screen_line
expr_stmt|;
block|}
if|if
condition|(
name|clear_to_end
condition|)
block|{
comment|/* we can do this the easy way */
name|putcap
argument_list|(
name|clear_to_end
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* use clear_eol on each line */
name|i
operator|=
name|hi
expr_stmt|;
while|while
condition|(
operator|(
name|void
operator|)
name|clear_eol
argument_list|(
name|strlen
argument_list|(
operator|&
name|screenbuf
index|[
name|lineindex
argument_list|(
name|i
operator|++
argument_list|)
index|]
argument_list|)
argument_list|)
operator|,
name|i
operator|<
name|last_hi
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|last_hi
operator|=
name|hi
expr_stmt|;
comment|/* move the cursor to a pleasant place */
name|Move_to
argument_list|(
name|x_idlecursor
argument_list|,
name|y_idlecursor
argument_list|)
expr_stmt|;
name|lastline
operator|=
name|y_idlecursor
expr_stmt|;
block|}
else|else
block|{
comment|/* separate this display from the next with some vertical room */
name|fputs
argument_list|(
literal|"\n\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|display_header
argument_list|(
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|int
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|t
condition|)
block|{
name|header_status
operator|=
name|ON
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|header_status
operator|==
name|ON
condition|)
block|{
name|header_status
operator|=
name|ERASE
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*VARARGS2*/
end_comment

begin_macro
name|new_message
argument_list|(
argument|type
argument_list|,
argument|msgfmt
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|)
end_macro

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|msgfmt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* first, format the message */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|next_msg
argument_list|,
sizeof|sizeof
argument_list|(
name|next_msg
argument_list|)
argument_list|,
name|msgfmt
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|)
expr_stmt|;
if|if
condition|(
name|msglen
operator|>
literal|0
condition|)
block|{
comment|/* message there already -- can we clear it? */
if|if
condition|(
operator|!
name|overstrike
condition|)
block|{
comment|/* yes -- write it and clear to end */
name|i
operator|=
name|strlen
argument_list|(
name|next_msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|MT_delayed
operator|)
operator|==
literal|0
condition|)
block|{
name|type
operator|&
name|MT_standout
condition|?
name|standout
argument_list|(
name|next_msg
argument_list|)
else|:
name|fputs
argument_list|(
name|next_msg
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|clear_eol
argument_list|(
name|msglen
operator|-
name|i
argument_list|)
expr_stmt|;
name|msglen
operator|=
name|i
expr_stmt|;
name|next_msg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|type
operator|&
name|MT_delayed
operator|)
operator|==
literal|0
condition|)
block|{
name|type
operator|&
name|MT_standout
condition|?
name|standout
argument_list|(
name|next_msg
argument_list|)
else|:
name|fputs
argument_list|(
name|next_msg
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|msglen
operator|=
name|strlen
argument_list|(
name|next_msg
argument_list|)
expr_stmt|;
name|next_msg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|clear_message
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|clear_eol
argument_list|(
name|msglen
argument_list|)
operator|==
literal|1
condition|)
block|{
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|readline
argument_list|(
argument|buffer
argument_list|,
argument|size
argument_list|,
argument|numeric
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numeric
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ptr
init|=
name|buffer
decl_stmt|;
specifier|register
name|char
name|ch
decl_stmt|;
specifier|register
name|char
name|cnt
init|=
literal|0
decl_stmt|;
specifier|register
name|char
name|maxcnt
init|=
literal|0
decl_stmt|;
comment|/* allow room for null terminator */
name|size
operator|-=
literal|1
expr_stmt|;
comment|/* read loop */
while|while
condition|(
operator|(
name|fflush
argument_list|(
name|stdout
argument_list|)
operator|,
name|read
argument_list|(
literal|0
argument_list|,
name|ptr
argument_list|,
literal|1
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* newline means we are done */
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
name|ptr
operator|)
operator|==
literal|'\n'
operator|||
name|ch
operator|==
literal|'\r'
condition|)
block|{
break|break;
block|}
comment|/* handle special editing characters */
if|if
condition|(
name|ch
operator|==
name|ch_kill
condition|)
block|{
comment|/* kill line -- account for overstriking */
if|if
condition|(
name|overstrike
condition|)
block|{
name|msglen
operator|+=
name|maxcnt
expr_stmt|;
block|}
comment|/* return null string */
operator|*
name|buffer
operator|=
literal|'\0'
expr_stmt|;
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|ch_erase
condition|)
block|{
comment|/* erase previous character */
if|if
condition|(
name|cnt
operator|<=
literal|0
condition|)
block|{
comment|/* none to erase! */
name|putchar
argument_list|(
literal|'\7'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputs
argument_list|(
literal|"\b \b"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|ptr
operator|--
expr_stmt|;
name|cnt
operator|--
expr_stmt|;
block|}
block|}
comment|/* check for character validity and buffer overflow */
elseif|else
if|if
condition|(
name|cnt
operator|==
name|size
operator|||
operator|(
name|numeric
operator|&&
operator|!
name|isdigit
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
operator|!
name|isprint
argument_list|(
name|ch
argument_list|)
condition|)
block|{
comment|/* not legal */
name|putchar
argument_list|(
literal|'\7'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* echo it and store it in the buffer */
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
name|maxcnt
condition|)
block|{
name|maxcnt
operator|=
name|cnt
expr_stmt|;
block|}
block|}
block|}
comment|/* all done -- null terminate the string */
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
comment|/* account for the extra characters in the message area */
comment|/* (if terminal overstrikes, remember the furthest they went) */
name|msglen
operator|+=
name|overstrike
condition|?
name|maxcnt
else|:
name|cnt
expr_stmt|;
comment|/* return either inputted number or string length */
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
return|return
operator|(
name|cnt
operator|==
literal|0
condition|?
operator|-
literal|1
else|:
name|numeric
condition|?
name|atoi
argument_list|(
name|buffer
argument_list|)
else|:
name|cnt
operator|)
return|;
block|}
end_block

begin_comment
comment|/* internal support routines */
end_comment

begin_function
specifier|static
name|int
name|string_count
parameter_list|(
name|pp
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
block|{
specifier|register
name|int
name|cnt
decl_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|pp
operator|++
operator|!=
name|NULL
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|summary_format
parameter_list|(
name|str
parameter_list|,
name|numbers
parameter_list|,
name|names
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
modifier|*
name|numbers
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|names
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|num
decl_stmt|;
specifier|register
name|char
modifier|*
name|thisname
decl_stmt|;
specifier|register
name|int
name|useM
init|=
name|No
decl_stmt|;
comment|/* format each number followed by its string */
name|p
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|(
name|thisname
operator|=
operator|*
name|names
operator|++
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* get the number to format */
name|num
operator|=
operator|*
name|numbers
operator|++
expr_stmt|;
comment|/* display only non-zero numbers */
if|if
condition|(
name|num
operator|>
literal|0
condition|)
block|{
comment|/* is this number in kilobytes? */
if|if
condition|(
name|thisname
index|[
literal|0
index|]
operator|==
literal|'K'
condition|)
block|{
comment|/* yes: format it as a memory value */
name|p
operator|=
name|strecpy
argument_list|(
name|p
argument_list|,
name|format_k
argument_list|(
name|num
argument_list|)
argument_list|)
expr_stmt|;
comment|/* skip over the K, since it was included by format_k */
name|p
operator|=
name|strecpy
argument_list|(
name|p
argument_list|,
name|thisname
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|strecpy
argument_list|(
name|p
argument_list|,
name|itoa
argument_list|(
name|num
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|strecpy
argument_list|(
name|p
argument_list|,
name|thisname
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ignore negative numbers, but display corresponding string */
elseif|else
if|if
condition|(
name|num
operator|<
literal|0
condition|)
block|{
name|p
operator|=
name|strecpy
argument_list|(
name|p
argument_list|,
name|thisname
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if the last two characters in the string are ", ", delete them */
name|p
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|str
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|','
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|' '
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|line_update
parameter_list|(
name|old
parameter_list|,
name|new
parameter_list|,
name|start
parameter_list|,
name|line
parameter_list|)
specifier|register
name|char
modifier|*
name|old
decl_stmt|;
specifier|register
name|char
modifier|*
name|new
decl_stmt|;
name|int
name|start
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
specifier|register
name|int
name|ch
decl_stmt|;
specifier|register
name|int
name|diff
decl_stmt|;
specifier|register
name|int
name|newcol
init|=
name|start
operator|+
literal|1
decl_stmt|;
specifier|register
name|int
name|lastcol
init|=
name|start
decl_stmt|;
name|char
name|cursor_on_line
init|=
name|No
decl_stmt|;
name|char
modifier|*
name|current
decl_stmt|;
comment|/* compare the two strings and only rewrite what has changed */
name|current
operator|=
name|old
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|debug
argument_list|,
literal|"line_update, starting at %d\n"
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|old
argument_list|,
name|debug
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|debug
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|new
argument_list|,
name|debug
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n-\n"
argument_list|,
name|debug
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* start things off on the right foot		    */
comment|/* this is to make sure the invariants get set up right */
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
name|new
operator|++
operator|)
operator|!=
operator|*
name|old
condition|)
block|{
if|if
condition|(
name|line
operator|-
name|lastline
operator|==
literal|1
operator|&&
name|start
operator|==
literal|0
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Move_to
argument_list|(
name|start
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
name|cursor_on_line
operator|=
name|Yes
expr_stmt|;
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
operator|*
name|old
operator|=
name|ch
expr_stmt|;
name|lastcol
operator|=
literal|1
expr_stmt|;
block|}
name|old
operator|++
expr_stmt|;
comment|/*      *  main loop -- check each character.  If the old and new aren't the      *	same, then update the display.  When the distance from the      *	current cursor position to the new change is small enough,      *	the characters that belong there are written to move the      *	cursor over.      *      *	Invariants:      *	    lastcol is the column where the cursor currently is sitting      *		(always one beyond the end of the last mismatch).      */
do|do
comment|/* yes, a do...while */
block|{
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
name|new
operator|++
operator|)
operator|!=
operator|*
name|old
condition|)
block|{
comment|/* new character is different from old	  */
comment|/* make sure the cursor is on top of this character */
name|diff
operator|=
name|newcol
operator|-
name|lastcol
expr_stmt|;
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
block|{
comment|/* some motion is required--figure out which is shorter */
if|if
condition|(
name|diff
operator|<
literal|6
operator|&&
name|cursor_on_line
condition|)
block|{
comment|/* overwrite old stuff--get it out of the old buffer */
name|printf
argument_list|(
literal|"%.*s"
argument_list|,
name|diff
argument_list|,
operator|&
name|current
index|[
name|lastcol
operator|-
name|start
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* use cursor addressing */
name|Move_to
argument_list|(
name|newcol
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|cursor_on_line
operator|=
name|Yes
expr_stmt|;
block|}
comment|/* remember where the cursor is */
name|lastcol
operator|=
name|newcol
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* already there, update position */
name|lastcol
operator|++
expr_stmt|;
block|}
comment|/* write what we need to */
if|if
condition|(
name|ch
operator|==
literal|'\0'
condition|)
block|{
comment|/* at the end--terminate with a clear-to-end-of-line */
operator|(
name|void
operator|)
name|clear_eol
argument_list|(
name|strlen
argument_list|(
name|old
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* write the new character */
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
comment|/* put the new character in the screen buffer */
operator|*
name|old
operator|=
name|ch
expr_stmt|;
block|}
comment|/* update working column and screen buffer pointer */
name|newcol
operator|++
expr_stmt|;
name|old
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|!=
literal|'\0'
condition|)
do|;
comment|/* zero out the rest of the line buffer -- MUST BE DONE! */
name|diff
operator|=
name|display_width
operator|-
name|newcol
expr_stmt|;
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
block|{
name|memzero
argument_list|(
name|old
argument_list|,
name|diff
argument_list|)
expr_stmt|;
block|}
comment|/* remember where the current line is */
if|if
condition|(
name|cursor_on_line
condition|)
block|{
name|lastline
operator|=
name|line
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *  printable(str) - make the string pointed to by "str" into one that is  *	printable (i.e.: all ascii), by converting all non-printable  *	characters into '?'.  Replacements are done in place and a pointer  *	to the original buffer is returned.  */
end_comment

begin_function
name|char
modifier|*
name|printable
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|register
name|char
name|ch
decl_stmt|;
name|ptr
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|ptr
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|isprint
argument_list|(
name|ch
argument_list|)
condition|)
block|{
operator|*
name|ptr
operator|=
literal|'?'
expr_stmt|;
block|}
name|ptr
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|str
operator|)
return|;
block|}
end_function

begin_macro
name|i_uptime
argument_list|(
argument|bt
argument_list|,
argument|tod
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|timeval
modifier|*
name|bt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|time_t
modifier|*
name|tod
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|time_t
name|uptime
decl_stmt|;
name|int
name|days
decl_stmt|,
name|hrs
decl_stmt|,
name|mins
decl_stmt|,
name|secs
decl_stmt|;
if|if
condition|(
name|bt
operator|->
name|tv_sec
operator|!=
operator|-
literal|1
condition|)
block|{
name|uptime
operator|=
operator|*
name|tod
operator|-
name|bt
operator|->
name|tv_sec
expr_stmt|;
name|uptime
operator|+=
literal|30
expr_stmt|;
name|days
operator|=
name|uptime
operator|/
literal|86400
expr_stmt|;
name|uptime
operator|%=
literal|86400
expr_stmt|;
name|hrs
operator|=
name|uptime
operator|/
literal|3600
expr_stmt|;
name|uptime
operator|%=
literal|3600
expr_stmt|;
name|mins
operator|=
name|uptime
operator|/
literal|60
expr_stmt|;
name|secs
operator|=
name|uptime
operator|%
literal|60
expr_stmt|;
comment|/* 	 *  Display the uptime. 	 */
if|if
condition|(
name|smart_terminal
condition|)
block|{
name|Move_to
argument_list|(
operator|(
name|screen_width
operator|-
literal|24
operator|)
operator|-
operator|(
name|days
operator|>
literal|9
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputs
argument_list|(
literal|" "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" up %d+%02d:%02d:%02d"
argument_list|,
name|days
argument_list|,
name|hrs
argument_list|,
name|mins
argument_list|,
name|secs
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

