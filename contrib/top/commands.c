begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Top users/processes display for Unix  *  Version 3  *  *  This program may be freely redistributed,  *  but this entire comment MUST remain intact.  *  *  Copyright (c) 1984, 1989, William LeFebvre, Rice University  *  Copyright (c) 1989, 1990, 1992, William LeFebvre, Northwestern University  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  *  This file contains the routines that implement some of the interactive  *  mode commands.  Note that some of the commands are implemented in-line  *  in "main".  This is necessary because they change the global state of  *  "top" (i.e.:  changing the number of processes to display).  */
end_comment

begin_include
include|#
directive|include
file|"os.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|"sigdesc.h"
end_include

begin_comment
comment|/* generated automatically */
end_comment

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_include
include|#
directive|include
file|"boolean.h"
end_include

begin_include
include|#
directive|include
file|"utils.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|copyright
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* imported from screen.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|overstrike
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|err_compar
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|err_string
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  *  show_help() - display the help screen; invoked in response to  *		either 'h' or '?'.  */
end_comment

begin_macro
name|show_help
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"Top version %s, %s\n"
argument_list|,
name|version_string
argument_list|()
argument_list|,
name|copyright
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n\n\ A top users display for Unix\n\ \n\ These single-character commands are available:\n\ \n\ ^L      - redraw screen\n\ q       - quit\n\ h or ?  - help; show this text\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* not all commands are availalbe with overstrike terminals */
if|if
condition|(
name|overstrike
condition|)
block|{
name|fputs
argument_list|(
literal|"\n\ Other commands are also available, but this terminal is not\n\ sophisticated enough to handle those commands gracefully.\n\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputs
argument_list|(
literal|"\ C       - toggle the displaying of weighted CPU percentage\n\ d       - change number of displays to show\n\ e       - list errors generated by last \"kill\" or \"renice\" command\n\ H       - toggle the displaying of threads\n\ i or I  - toggle the displaying of idle processes\n\ j       - toggle the displaying of jail id\n\ k       - kill processes; send a signal to a list of processes\n\ m       - toggle the display between 'cpu' and 'io' modes\n\ n or #  - change number of processes to display\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ORDER
if|if
condition|(
name|displaymode
operator|==
name|DISP_CPU
condition|)
name|fputs
argument_list|(
literal|"\ o       - specify sort order (pri, size, res, cpu, time, threads)\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"\ o       - specify sort order (vcsw, ivcsw, read, write, fault, total)\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fputs
argument_list|(
literal|"\ r       - renice a process\n\ s       - change number of seconds to delay between updates\n\ S       - toggle the displaying of system processes\n\ a       - toggle the displaying of process titles\n\ t       - toggle the display of this process\n\ u       - display processes for only one user (+ selects all users)\n\ \n\ \n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *  Utility routines that help with some of the commands.  */
end_comment

begin_function
name|char
modifier|*
name|next_field
parameter_list|(
name|str
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|str
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|str
operator|==
literal|' '
condition|)
comment|/* loop */
empty_stmt|;
comment|/* if there is nothing left of the string, return NULL */
comment|/* This fix is dedicated to Greg Earle */
return|return
operator|(
operator|*
name|str
operator|==
literal|'\0'
condition|?
name|NULL
else|:
name|str
operator|)
return|;
block|}
end_function

begin_macro
name|scanint
argument_list|(
argument|str
argument_list|,
argument|intp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|intp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|val
init|=
literal|0
decl_stmt|;
specifier|register
name|char
name|ch
decl_stmt|;
comment|/* if there is nothing left of the string, flag it as an error */
comment|/* This fix is dedicated to Greg Earle */
if|if
condition|(
operator|*
name|str
operator|==
literal|'\0'
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|str
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|val
operator|=
name|val
operator|*
literal|10
operator|+
operator|(
name|ch
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isspace
argument_list|(
name|ch
argument_list|)
condition|)
block|{
break|break;
block|}
else|else
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
operator|*
name|intp
operator|=
name|val
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *  Some of the commands make system calls that could generate errors.  *  These errors are collected up in an array of structures for later  *  contemplation and display.  Such routines return a string containing an  *  error message, or NULL if no errors occurred.  The next few routines are  *  for manipulating and displaying these errors.  We need an upper limit on  *  the number of errors, so we arbitrarily choose 20.  */
end_comment

begin_define
define|#
directive|define
name|ERRMAX
value|20
end_define

begin_struct
struct|struct
name|errs
comment|/* structure for a system-call error */
block|{
name|int
name|errnum
decl_stmt|;
comment|/* value of errno (that is, the actual error) */
name|char
modifier|*
name|arg
decl_stmt|;
comment|/* argument that caused the error */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|errs
name|errs
index|[
name|ERRMAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|errcnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|err_toomany
init|=
literal|" too many errors occurred"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|err_listem
init|=
literal|" Many errors occurred.  Press `e' to display the list of errors."
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These macros get used to reset and log the errors */
end_comment

begin_define
define|#
directive|define
name|ERR_RESET
value|errcnt = 0
end_define

begin_define
define|#
directive|define
name|ERROR
parameter_list|(
name|p
parameter_list|,
name|e
parameter_list|)
value|if (errcnt>= ERRMAX) \ 		    { \ 			return(err_toomany); \ 		    } \ 		    else \ 		    { \ 			errs[errcnt].arg = (p); \ 			errs[errcnt++].errnum = (e); \ 		    }
end_define

begin_comment
comment|/*  *  err_string() - return an appropriate error string.  This is what the  *	command will return for displaying.  If no errors were logged, then  *	return NULL.  The maximum length of the error string is defined by  *	"STRMAX".  */
end_comment

begin_define
define|#
directive|define
name|STRMAX
value|80
end_define

begin_function
name|char
modifier|*
name|err_string
parameter_list|()
block|{
specifier|register
name|struct
name|errs
modifier|*
name|errp
decl_stmt|;
specifier|register
name|int
name|cnt
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|first
init|=
name|Yes
decl_stmt|;
specifier|register
name|int
name|currerr
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|stringlen
decl_stmt|;
comment|/* characters still available in "string" */
specifier|static
name|char
name|string
index|[
name|STRMAX
index|]
decl_stmt|;
comment|/* if there are no errors, return NULL */
if|if
condition|(
name|errcnt
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* sort the errors */
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|errs
argument_list|,
name|errcnt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|errs
argument_list|)
argument_list|,
name|err_compar
argument_list|)
expr_stmt|;
comment|/* need a space at the front of the error string */
name|string
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
name|string
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|stringlen
operator|=
name|STRMAX
operator|-
literal|2
expr_stmt|;
comment|/* loop thru the sorted list, building an error string */
while|while
condition|(
name|cnt
operator|<
name|errcnt
condition|)
block|{
name|errp
operator|=
operator|&
operator|(
name|errs
index|[
name|cnt
operator|++
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|errp
operator|->
name|errnum
operator|!=
name|currerr
condition|)
block|{
if|if
condition|(
name|currerr
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|stringlen
operator|=
name|str_adderr
argument_list|(
name|string
argument_list|,
name|stringlen
argument_list|,
name|currerr
argument_list|)
operator|)
operator|<
literal|2
condition|)
block|{
return|return
operator|(
name|err_listem
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|string
argument_list|,
literal|"; "
argument_list|)
expr_stmt|;
comment|/* we know there's more */
block|}
name|currerr
operator|=
name|errp
operator|->
name|errnum
expr_stmt|;
name|first
operator|=
name|Yes
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stringlen
operator|=
name|str_addarg
argument_list|(
name|string
argument_list|,
name|stringlen
argument_list|,
name|errp
operator|->
name|arg
argument_list|,
name|first
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|err_listem
operator|)
return|;
block|}
name|first
operator|=
name|No
expr_stmt|;
block|}
comment|/* add final message */
name|stringlen
operator|=
name|str_adderr
argument_list|(
name|string
argument_list|,
name|stringlen
argument_list|,
name|currerr
argument_list|)
expr_stmt|;
comment|/* return the error string */
return|return
operator|(
name|stringlen
operator|==
literal|0
condition|?
name|err_listem
else|:
name|string
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  str_adderr(str, len, err) - add an explanation of error "err" to  *	the string "str".  */
end_comment

begin_macro
name|str_adderr
argument_list|(
argument|str
argument_list|,
argument|len
argument_list|,
argument|err
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|err
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|msg
decl_stmt|;
specifier|register
name|int
name|msglen
decl_stmt|;
name|msg
operator|=
name|err
operator|==
literal|0
condition|?
literal|"Not a number"
else|:
name|errmsg
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|msglen
operator|=
name|strlen
argument_list|(
name|msg
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|len
operator|<=
name|msglen
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|str
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|str
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|len
operator|-
name|msglen
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *  str_addarg(str, len, arg, first) - add the string argument "arg" to  *	the string "str".  This is the first in the group when "first"  *	is set (indicating that a comma should NOT be added to the front).  */
end_comment

begin_macro
name|str_addarg
argument_list|(
argument|str
argument_list|,
argument|len
argument_list|,
argument|arg
argument_list|,
argument|first
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|first
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|arglen
decl_stmt|;
name|arglen
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|first
condition|)
block|{
name|arglen
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<=
name|arglen
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|first
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|str
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|str
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
name|len
operator|-
name|arglen
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *  err_compar(p1, p2) - comparison routine used by "qsort"  *	for sorting errors.  */
end_comment

begin_expr_stmt
name|err_compar
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
specifier|register
expr|struct
name|errs
operator|*
name|p1
operator|,
operator|*
name|p2
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|result
operator|=
name|p1
operator|->
name|errnum
operator|-
name|p2
operator|->
name|errnum
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|p1
operator|->
name|arg
argument_list|,
name|p2
operator|->
name|arg
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *  error_count() - return the number of errors currently logged.  */
end_comment

begin_macro
name|error_count
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|errcnt
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *  show_errors() - display on stdout the current log of errors.  */
end_comment

begin_macro
name|show_errors
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|cnt
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|errs
modifier|*
name|errp
init|=
name|errs
decl_stmt|;
name|printf
argument_list|(
literal|"%d error%s:\n\n"
argument_list|,
name|errcnt
argument_list|,
name|errcnt
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
while|while
condition|(
name|cnt
operator|++
operator|<
name|errcnt
condition|)
block|{
name|printf
argument_list|(
literal|"%5s: %s\n"
argument_list|,
name|errp
operator|->
name|arg
argument_list|,
name|errp
operator|->
name|errnum
operator|==
literal|0
condition|?
literal|"Not a number"
else|:
name|errmsg
argument_list|(
name|errp
operator|->
name|errnum
argument_list|)
argument_list|)
expr_stmt|;
name|errp
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *  kill_procs(str) - send signals to processes, much like the "kill"  *		command does; invoked in response to 'k'.  */
end_comment

begin_function
name|char
modifier|*
name|kill_procs
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|nptr
decl_stmt|;
name|int
name|signum
init|=
name|SIGTERM
decl_stmt|;
comment|/* default */
name|int
name|procnum
decl_stmt|;
name|struct
name|sigdesc
modifier|*
name|sigp
decl_stmt|;
name|int
name|uid
decl_stmt|;
comment|/* reset error array */
name|ERR_RESET
expr_stmt|;
comment|/* remember our uid */
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
comment|/* skip over leading white space */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
comment|/* explicit signal specified */
if|if
condition|(
operator|(
name|nptr
operator|=
name|next_field
argument_list|(
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|" kill: no processes specified"
operator|)
return|;
block|}
if|if
condition|(
name|isdigit
argument_list|(
name|str
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|scanint
argument_list|(
name|str
operator|+
literal|1
argument_list|,
operator|&
name|signum
argument_list|)
expr_stmt|;
if|if
condition|(
name|signum
operator|<=
literal|0
operator|||
name|signum
operator|>=
name|NSIG
condition|)
block|{
return|return
operator|(
literal|" invalid signal number"
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* translate the name into a number */
for|for
control|(
name|sigp
operator|=
name|sigdesc
init|;
name|sigp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|sigp
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|sigp
operator|->
name|name
argument_list|,
name|str
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|signum
operator|=
name|sigp
operator|->
name|number
expr_stmt|;
break|break;
block|}
block|}
comment|/* was it ever found */
if|if
condition|(
name|sigp
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|" bad signal name"
operator|)
return|;
block|}
block|}
comment|/* put the new pointer in place */
name|str
operator|=
name|nptr
expr_stmt|;
block|}
comment|/* loop thru the string, killing processes */
do|do
block|{
if|if
condition|(
name|scanint
argument_list|(
name|str
argument_list|,
operator|&
name|procnum
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ERROR
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* check process owner if we're not root */
if|if
condition|(
name|uid
operator|&&
operator|(
name|uid
operator|!=
name|proc_owner
argument_list|(
name|procnum
argument_list|)
operator|)
condition|)
block|{
name|ERROR
argument_list|(
name|str
argument_list|,
name|EACCES
argument_list|)
expr_stmt|;
block|}
comment|/* go in for the kill */
elseif|else
if|if
condition|(
name|kill
argument_list|(
name|procnum
argument_list|,
name|signum
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* chalk up an error */
name|ERROR
argument_list|(
name|str
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|(
name|str
operator|=
name|next_field
argument_list|(
name|str
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
do|;
comment|/* return appropriate error string */
return|return
operator|(
name|err_string
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  renice_procs(str) - change the "nice" of processes, much like the  *		"renice" command does; invoked in response to 'r'.  */
end_comment

begin_function
name|char
modifier|*
name|renice_procs
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|char
name|negate
decl_stmt|;
name|int
name|prio
decl_stmt|;
name|int
name|procnum
decl_stmt|;
name|int
name|uid
decl_stmt|;
name|ERR_RESET
expr_stmt|;
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
comment|/* allow for negative priority values */
if|if
condition|(
operator|(
name|negate
operator|=
operator|(
operator|*
name|str
operator|==
literal|'-'
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* move past the minus sign */
name|str
operator|++
expr_stmt|;
block|}
comment|/* use procnum as a temporary holding place and get the number */
name|procnum
operator|=
name|scanint
argument_list|(
name|str
argument_list|,
operator|&
name|prio
argument_list|)
expr_stmt|;
comment|/* negate if necessary */
if|if
condition|(
name|negate
condition|)
block|{
name|prio
operator|=
operator|-
name|prio
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|PRIO_MIN
argument_list|)
operator|&&
name|defined
argument_list|(
name|PRIO_MAX
argument_list|)
comment|/* check for validity */
if|if
condition|(
name|procnum
operator|==
operator|-
literal|1
operator|||
name|prio
operator|<
name|PRIO_MIN
operator|||
name|prio
operator|>
name|PRIO_MAX
condition|)
block|{
return|return
operator|(
literal|" bad priority value"
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* move to the first process number */
if|if
condition|(
operator|(
name|str
operator|=
name|next_field
argument_list|(
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|" no processes specified"
operator|)
return|;
block|}
comment|/* loop thru the process numbers, renicing each one */
do|do
block|{
if|if
condition|(
name|scanint
argument_list|(
name|str
argument_list|,
operator|&
name|procnum
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ERROR
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* check process owner if we're not root */
elseif|else
if|if
condition|(
name|uid
operator|&&
operator|(
name|uid
operator|!=
name|proc_owner
argument_list|(
name|procnum
argument_list|)
operator|)
condition|)
block|{
name|ERROR
argument_list|(
name|str
argument_list|,
name|EACCES
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
name|procnum
argument_list|,
name|prio
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ERROR
argument_list|(
name|str
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|str
operator|=
name|next_field
argument_list|(
name|str
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
do|;
comment|/* return appropriate error string */
return|return
operator|(
name|err_string
argument_list|()
operator|)
return|;
block|}
end_function

end_unit

