begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
name|char
modifier|*
name|copyright
init|=
literal|"Copyright (c) 1984 through 1996, William LeFebvre"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  Top users/processes display for Unix  *  Version 3  *  *  This program may be freely redistributed,  *  but this entire comment MUST remain intact.  *  *  Copyright (c) 1984, 1989, William LeFebvre, Rice University  *  Copyright (c) 1989 - 1994, William LeFebvre, Northwestern University  *  Copyright (c) 1994, 1995, William LeFebvre, Argonne National Laboratory  *  Copyright (c) 1996, William LeFebvre, Group sys Consulting  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  *  See the file "Changes" for information on version-to-version changes.  */
end_comment

begin_comment
comment|/*  *  This file contains "main" and other high-level routines.  */
end_comment

begin_comment
comment|/*  * The following preprocessor variables, when defined, are used to  * distinguish between different Unix implementations:  *  *	SIGHOLD  - use SVR4 sighold function when defined  *	SIGRELSE - use SVR4 sigrelse function when defined  *	FD_SET   - macros FD_SET and FD_ZERO are used when defined  */
end_comment

begin_include
include|#
directive|include
file|"os.h"
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<jail.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* includes specific to top */
end_comment

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_include
include|#
directive|include
file|"display.h"
end_include

begin_comment
comment|/* interface to display package */
end_comment

begin_include
include|#
directive|include
file|"screen.h"
end_include

begin_comment
comment|/* interface to screen package */
end_comment

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_include
include|#
directive|include
file|"top.local.h"
end_include

begin_include
include|#
directive|include
file|"boolean.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_include
include|#
directive|include
file|"utils.h"
end_include

begin_include
include|#
directive|include
file|"username.h"
end_include

begin_comment
comment|/* Size of the stdio buffer given to stdout */
end_comment

begin_define
define|#
directive|define
name|Buffersize
value|2048
end_define

begin_comment
comment|/* The buffer that stdio will use */
end_comment

begin_decl_stmt
name|char
name|stdoutbuf
index|[
name|Buffersize
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* build Signal masks */
end_comment

begin_define
define|#
directive|define
name|Smask
parameter_list|(
name|s
parameter_list|)
value|(1<< ((s) - 1))
end_define

begin_comment
comment|/* for getopt: */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|optind
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* imported from screen.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|overstrike
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fmt_flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pcpu_stats
init|=
name|No
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* signal handling routines */
end_comment

begin_function_decl
name|sigret_t
name|leave
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|sigret_t
name|tstop
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SIGWINCH
end_ifdef

begin_function_decl
name|sigret_t
name|winch
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|volatile
name|sig_atomic_t
name|leaveflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|sig_atomic_t
name|tstopflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|sig_atomic_t
name|winchflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* internal routines */
end_comment

begin_function_decl
name|void
name|quit
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* values which need to be accessed by signal handlers */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_topn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum displayable processes */
end_comment

begin_comment
comment|/* miscellaneous things */
end_comment

begin_decl_stmt
name|struct
name|process_select
name|ps
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|myname
init|=
literal|"top"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|jmp_int
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* routines that don't return int */
end_comment

begin_function_decl
name|char
modifier|*
name|username
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|kill_procs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|renice_procs
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ORDER
end_ifdef

begin_function_decl
specifier|extern
name|int
function_decl|(
modifier|*
name|compares
index|[]
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|int
name|proc_compare
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|io_compare
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|time_t
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|caddr_t
name|get_process_info
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* different routines for displaying the user's identification */
end_comment

begin_comment
comment|/* (values assigned to get_userid) */
end_comment

begin_function_decl
name|char
modifier|*
name|username
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|itoa7
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* pointers to display routines */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|d_loadave
function_decl|)
parameter_list|()
init|=
name|i_loadave
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|d_procstates
function_decl|)
parameter_list|()
init|=
name|i_procstates
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|d_cpustates
function_decl|)
parameter_list|()
init|=
name|i_cpustates
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|d_memory
function_decl|)
parameter_list|()
init|=
name|i_memory
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|d_arc
function_decl|)
parameter_list|()
init|=
name|i_arc
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|d_carc
function_decl|)
parameter_list|()
init|=
name|i_carc
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|d_swap
function_decl|)
parameter_list|()
init|=
name|i_swap
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|d_message
function_decl|)
parameter_list|()
init|=
name|i_message
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|d_header
function_decl|)
parameter_list|()
init|=
name|i_header
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|d_process
function_decl|)
parameter_list|()
init|=
name|i_process
function_decl|;
end_function_decl

begin_function_decl
name|void
name|reset_display
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|reset_uids
parameter_list|()
block|{
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|TOP_MAX_UIDS
condition|;
operator|++
name|i
control|)
name|ps
operator|.
name|uid
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_uid
parameter_list|(
name|int
name|uid
parameter_list|)
block|{
name|size_t
name|i
init|=
literal|0
decl_stmt|;
comment|/* Add the uid if there's room */
for|for
control|(
init|;
name|i
operator|<
name|TOP_MAX_UIDS
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|ps
operator|.
name|uid
index|[
name|i
index|]
operator|==
operator|-
literal|1
operator|||
name|ps
operator|.
name|uid
index|[
name|i
index|]
operator|==
name|uid
condition|)
block|{
name|ps
operator|.
name|uid
index|[
name|i
index|]
operator|=
name|uid
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|i
operator|==
name|TOP_MAX_UIDS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rem_uid
parameter_list|(
name|int
name|uid
parameter_list|)
block|{
name|size_t
name|i
init|=
literal|0
decl_stmt|;
name|size_t
name|where
init|=
name|TOP_MAX_UIDS
decl_stmt|;
comment|/* Look for the user to remove - no problem if it's not there */
for|for
control|(
init|;
name|i
operator|<
name|TOP_MAX_UIDS
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|ps
operator|.
name|uid
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|ps
operator|.
name|uid
index|[
name|i
index|]
operator|==
name|uid
condition|)
name|where
operator|=
name|i
expr_stmt|;
block|}
comment|/* Make sure we don't leave a hole in the middle */
if|if
condition|(
name|where
operator|!=
name|TOP_MAX_UIDS
condition|)
block|{
name|ps
operator|.
name|uid
index|[
name|where
index|]
operator|=
name|ps
operator|.
name|uid
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|ps
operator|.
name|uid
index|[
name|i
operator|-
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|handle_user
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|int
name|uid
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|buf2
init|=
name|buf
decl_stmt|;
name|new_message
argument_list|(
name|MT_standout
argument_list|,
literal|"Username to show (+ for all): "
argument_list|)
expr_stmt|;
if|if
condition|(
name|readline
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
name|No
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|clear_message
argument_list|()
expr_stmt|;
return|return
name|rc
return|;
block|}
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'+'
operator|||
name|buf
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|reset_uids
argument_list|()
expr_stmt|;
goto|goto
name|end
goto|;
block|}
else|else
operator|++
name|buf2
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|uid
operator|=
name|userid
argument_list|(
name|buf2
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|new_message
argument_list|(
name|MT_standout
argument_list|,
literal|" %s: unknown user"
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|buf2
operator|==
name|buf
condition|)
block|{
name|reset_uids
argument_list|()
expr_stmt|;
name|ps
operator|.
name|uid
index|[
literal|0
index|]
operator|=
name|uid
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
name|add_uid
argument_list|(
name|uid
argument_list|)
condition|)
block|{
name|new_message
argument_list|(
name|MT_standout
argument_list|,
literal|" too many users, reset with '+'"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|end
goto|;
block|}
block|}
else|else
name|rem_uid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
name|end
label|:
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|active_procs
decl_stmt|;
specifier|register
name|int
name|change
decl_stmt|;
name|struct
name|system_info
name|system_info
decl_stmt|;
name|struct
name|statics
name|statics
decl_stmt|;
name|caddr_t
name|processes
decl_stmt|;
specifier|static
name|char
name|tempbuf1
index|[
literal|50
index|]
decl_stmt|;
specifier|static
name|char
name|tempbuf2
index|[
literal|50
index|]
decl_stmt|;
name|int
name|old_sigmask
decl_stmt|;
comment|/* only used for BSD-style signals */
name|int
name|topn
init|=
name|Default_TOPN
decl_stmt|;
name|int
name|delay
init|=
name|Default_DELAY
decl_stmt|;
name|int
name|displays
init|=
literal|0
decl_stmt|;
comment|/* indicates unspecified */
name|int
name|sel_ret
init|=
literal|0
decl_stmt|;
name|time_t
name|curr_time
decl_stmt|;
name|char
modifier|*
function_decl|(
modifier|*
name|get_userid
function_decl|)
parameter_list|()
init|=
name|username
function_decl|;
name|char
modifier|*
name|uname_field
init|=
literal|"USERNAME"
decl_stmt|;
name|char
modifier|*
name|header_text
decl_stmt|;
name|char
modifier|*
name|env_top
decl_stmt|;
name|char
modifier|*
modifier|*
name|preset_argv
decl_stmt|;
name|int
name|preset_argc
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
name|int
name|ac
decl_stmt|;
name|char
name|dostates
init|=
name|No
decl_stmt|;
name|char
name|do_unames
init|=
name|Yes
decl_stmt|;
name|char
name|interactive
init|=
name|Maybe
decl_stmt|;
name|char
name|warnings
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|Default_TOPN
operator|==
name|Infinity
name|char
name|topn_specified
init|=
name|No
decl_stmt|;
endif|#
directive|endif
name|char
name|ch
decl_stmt|;
name|char
modifier|*
name|iptr
decl_stmt|;
name|char
name|no_command
init|=
literal|1
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
ifdef|#
directive|ifdef
name|ORDER
name|char
modifier|*
name|order_name
init|=
name|NULL
decl_stmt|;
name|int
name|order_index
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|FD_SET
comment|/* FD_SET and friends are not present:  fake it */
typedef|typedef
name|int
name|fd_set
typedef|;
define|#
directive|define
name|FD_ZERO
parameter_list|(
name|x
parameter_list|)
value|(*(x) = 0)
define|#
directive|define
name|FD_SET
parameter_list|(
name|f
parameter_list|,
name|x
parameter_list|)
value|(*(x) = 1<<f)
endif|#
directive|endif
name|fd_set
name|readfds
decl_stmt|;
ifdef|#
directive|ifdef
name|ORDER
specifier|static
name|char
name|command_chars
index|[]
init|=
literal|"\f qh?en#sdkriIutHmSCajzPJwo"
decl_stmt|;
else|#
directive|else
specifier|static
name|char
name|command_chars
index|[]
init|=
literal|"\f qh?en#sdkriIutHmSCajzPJw"
decl_stmt|;
endif|#
directive|endif
comment|/* these defines enumerate the "strchr"s of the commands in command_chars */
define|#
directive|define
name|CMD_redraw
value|0
define|#
directive|define
name|CMD_update
value|1
define|#
directive|define
name|CMD_quit
value|2
define|#
directive|define
name|CMD_help1
value|3
define|#
directive|define
name|CMD_help2
value|4
define|#
directive|define
name|CMD_OSLIMIT
value|4
comment|/* terminals with OS can only handle commands */
define|#
directive|define
name|CMD_errors
value|5
comment|/* less than or equal to CMD_OSLIMIT	   */
define|#
directive|define
name|CMD_number1
value|6
define|#
directive|define
name|CMD_number2
value|7
define|#
directive|define
name|CMD_delay
value|8
define|#
directive|define
name|CMD_displays
value|9
define|#
directive|define
name|CMD_kill
value|10
define|#
directive|define
name|CMD_renice
value|11
define|#
directive|define
name|CMD_idletog
value|12
define|#
directive|define
name|CMD_idletog2
value|13
define|#
directive|define
name|CMD_user
value|14
define|#
directive|define
name|CMD_selftog
value|15
define|#
directive|define
name|CMD_thrtog
value|16
define|#
directive|define
name|CMD_viewtog
value|17
define|#
directive|define
name|CMD_viewsys
value|18
define|#
directive|define
name|CMD_wcputog
value|19
define|#
directive|define
name|CMD_showargs
value|20
define|#
directive|define
name|CMD_jidtog
value|21
define|#
directive|define
name|CMD_kidletog
value|22
define|#
directive|define
name|CMD_pcputog
value|23
define|#
directive|define
name|CMD_jail
value|24
define|#
directive|define
name|CMD_swaptog
value|25
ifdef|#
directive|ifdef
name|ORDER
define|#
directive|define
name|CMD_order
value|26
endif|#
directive|endif
comment|/* set the buffer for stdout */
ifdef|#
directive|ifdef
name|DEBUG
specifier|extern
name|FILE
modifier|*
name|debug
decl_stmt|;
name|debug
operator|=
name|fopen
argument_list|(
literal|"debug.run"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|setbuffer
argument_list|(
name|stdout
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|setbuffer
argument_list|(
name|stdout
argument_list|,
name|stdoutbuf
argument_list|,
name|Buffersize
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* get our name */
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|myname
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|myname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|myname
operator|++
expr_stmt|;
block|}
block|}
comment|/* initialize some selection options */
name|ps
operator|.
name|idle
operator|=
name|Yes
expr_stmt|;
name|ps
operator|.
name|self
operator|=
operator|-
literal|1
expr_stmt|;
name|ps
operator|.
name|system
operator|=
name|No
expr_stmt|;
name|reset_uids
argument_list|()
expr_stmt|;
name|ps
operator|.
name|thread
operator|=
name|No
expr_stmt|;
name|ps
operator|.
name|wcpu
operator|=
literal|1
expr_stmt|;
name|ps
operator|.
name|jid
operator|=
operator|-
literal|1
expr_stmt|;
name|ps
operator|.
name|jail
operator|=
name|No
expr_stmt|;
name|ps
operator|.
name|swap
operator|=
name|No
expr_stmt|;
name|ps
operator|.
name|kidle
operator|=
name|Yes
expr_stmt|;
name|ps
operator|.
name|command
operator|=
name|NULL
expr_stmt|;
comment|/* get preset options from the environment */
if|if
condition|(
operator|(
name|env_top
operator|=
name|getenv
argument_list|(
literal|"TOP"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|av
operator|=
name|preset_argv
operator|=
name|argparse
argument_list|(
name|env_top
argument_list|,
operator|&
name|preset_argc
argument_list|)
expr_stmt|;
name|ac
operator|=
name|preset_argc
expr_stmt|;
comment|/* set the dummy argument to an explanatory message, in case 	   getopt encounters a bad argument */
name|preset_argv
index|[
literal|0
index|]
operator|=
literal|"while processing environment"
expr_stmt|;
block|}
comment|/* process options */
do|do
block|{
comment|/* if we're done doing the presets, then process the real arguments */
if|if
condition|(
name|preset_argc
operator|==
literal|0
condition|)
block|{
name|ac
operator|=
name|argc
expr_stmt|;
name|av
operator|=
name|argv
expr_stmt|;
comment|/* this should keep getopt happy... */
name|optind
operator|=
literal|1
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|i
operator|=
name|getopt
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
literal|"CSIHPabijJ:nquvzs:d:U:m:o:tw"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'v'
case|:
comment|/* show version number */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: version %s\n"
argument_list|,
name|myname
argument_list|,
name|version_string
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* toggle uid/username display */
name|do_unames
operator|=
operator|!
name|do_unames
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/* display only username's processes */
if|if
condition|(
operator|(
name|ps
operator|.
name|uid
index|[
literal|0
index|]
operator|=
name|userid
argument_list|(
name|optarg
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown user\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
comment|/* show system processes */
name|ps
operator|.
name|system
operator|=
operator|!
name|ps
operator|.
name|system
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* show idle processes */
name|ps
operator|.
name|idle
operator|=
operator|!
name|ps
operator|.
name|idle
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* go interactive regardless */
name|interactive
operator|=
name|Yes
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* batch, or non-interactive */
case|case
literal|'b'
case|:
name|interactive
operator|=
name|No
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|fmt_flags
operator|^=
name|FMT_SHOWARGS
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* number of displays to show */
if|if
condition|(
operator|(
name|i
operator|=
name|atoiwi
argument_list|(
name|optarg
argument_list|)
operator|)
operator|==
name|Invalid
operator|||
name|i
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: warning: display count should be positive -- option ignored\n"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|warnings
operator|++
expr_stmt|;
block|}
else|else
block|{
name|displays
operator|=
name|i
expr_stmt|;
block|}
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
operator|(
name|delay
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|delay
operator|==
literal|0
operator|&&
name|getuid
argument_list|()
operator|!=
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: warning: seconds delay should be positive -- using default\n"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|delay
operator|=
name|Default_DELAY
expr_stmt|;
name|warnings
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'q'
case|:
comment|/* be quick about it */
comment|/* only allow this if user is really root */
if|if
condition|(
name|getuid
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|/* be very un-nice! */
operator|(
name|void
operator|)
name|nice
argument_list|(
operator|-
literal|20
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: warning: `-q' option can only be used by root\n"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|warnings
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'m'
case|:
comment|/* select display mode */
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"io"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|displaymode
operator|=
name|DISP_IO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"cpu"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|displaymode
operator|=
name|DISP_CPU
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: warning: `-m' option can only take args "
literal|"'io' or 'cpu'\n"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'o'
case|:
comment|/* select sort order */
ifdef|#
directive|ifdef
name|ORDER
name|order_name
operator|=
name|optarg
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: this platform does not support arbitrary ordering.  Sorry.\n"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|warnings
operator|++
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'t'
case|:
name|ps
operator|.
name|self
operator|=
operator|(
name|ps
operator|.
name|self
operator|==
operator|-
literal|1
operator|)
condition|?
name|getpid
argument_list|()
else|:
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|ps
operator|.
name|wcpu
operator|=
operator|!
name|ps
operator|.
name|wcpu
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|ps
operator|.
name|thread
operator|=
operator|!
name|ps
operator|.
name|thread
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|ps
operator|.
name|jail
operator|=
operator|!
name|ps
operator|.
name|jail
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
comment|/* display only jail's processes */
if|if
condition|(
operator|(
name|ps
operator|.
name|jid
operator|=
name|jail_getid
argument_list|(
name|optarg
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown jail\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ps
operator|.
name|jail
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|pcpu_stats
operator|=
operator|!
name|pcpu_stats
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|ps
operator|.
name|swap
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|ps
operator|.
name|kidle
operator|=
operator|!
name|ps
operator|.
name|kidle
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Top version %s\n"
literal|"Usage: %s [-abCHIijnPqStuvz] [-d count] [-m io | cpu] [-o field] [-s time]\n"
literal|"       [-J jail] [-U username] [number]\n"
argument_list|,
name|version_string
argument_list|()
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* get count of top processes to display (if any) */
if|if
condition|(
name|optind
operator|<
name|ac
condition|)
block|{
if|if
condition|(
operator|(
name|topn
operator|=
name|atoiwi
argument_list|(
name|av
index|[
name|optind
index|]
argument_list|)
operator|)
operator|==
name|Invalid
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: warning: process display count should be non-negative -- using default\n"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|warnings
operator|++
expr_stmt|;
block|}
if|#
directive|if
name|Default_TOPN
operator|==
name|Infinity
else|else
block|{
name|topn_specified
operator|=
name|Yes
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* tricky:  remember old value of preset_argc& set preset_argc = 0 */
name|i
operator|=
name|preset_argc
expr_stmt|;
name|preset_argc
operator|=
literal|0
expr_stmt|;
comment|/* repeat only if we really did the preset arguments */
block|}
do|while
condition|(
name|i
operator|!=
literal|0
condition|)
do|;
comment|/* set constants for username/uid display correctly */
if|if
condition|(
operator|!
name|do_unames
condition|)
block|{
name|uname_field
operator|=
literal|"   UID  "
expr_stmt|;
name|get_userid
operator|=
name|itoa7
expr_stmt|;
block|}
comment|/* initialize the kernel memory interface */
if|if
condition|(
name|machine_init
argument_list|(
operator|&
name|statics
argument_list|,
name|do_unames
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ORDER
comment|/* determine sorting order index, if necessary */
if|if
condition|(
name|order_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|order_index
operator|=
name|string_index
argument_list|(
name|order_name
argument_list|,
name|statics
operator|.
name|order_names
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: '%s' is not a recognized sorting order.\n"
argument_list|,
name|myname
argument_list|,
name|order_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tTry one of these:"
argument_list|)
expr_stmt|;
name|pp
operator|=
name|statics
operator|.
name|order_names
expr_stmt|;
while|while
condition|(
operator|*
name|pp
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
operator|*
name|pp
operator|++
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|no_initialization_needed
comment|/* initialize the hashing stuff */
if|if
condition|(
name|do_unames
condition|)
block|{
name|init_hash
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* initialize termcap */
name|init_termcap
argument_list|(
name|interactive
argument_list|)
expr_stmt|;
comment|/* get the string to use for the process area header */
name|header_text
operator|=
name|format_header
argument_list|(
name|uname_field
argument_list|)
expr_stmt|;
comment|/* initialize display interface */
if|if
condition|(
operator|(
name|max_topn
operator|=
name|display_init
argument_list|(
operator|&
name|statics
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't allocate sufficient memory\n"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* print warning if user requested more processes than we can display */
if|if
condition|(
name|topn
operator|>
name|max_topn
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: warning: this terminal can only display %d processes.\n"
argument_list|,
name|myname
argument_list|,
name|max_topn
argument_list|)
expr_stmt|;
name|warnings
operator|++
expr_stmt|;
block|}
comment|/* adjust for topn == Infinity */
if|if
condition|(
name|topn
operator|==
name|Infinity
condition|)
block|{
comment|/* 	 *  For smart terminals, infinity really means everything that can 	 *  be displayed, or Largest. 	 *  On dumb terminals, infinity means every process in the system! 	 *  We only really want to do that if it was explicitly specified. 	 *  This is always the case when "Default_TOPN != Infinity".  But if 	 *  topn wasn't explicitly specified and we are on a dumb terminal 	 *  and the default is Infinity, then (and only then) we use 	 *  "Nominal_TOPN" instead. 	 */
if|#
directive|if
name|Default_TOPN
operator|==
name|Infinity
name|topn
operator|=
name|smart_terminal
condition|?
name|Largest
else|:
operator|(
name|topn_specified
condition|?
name|Largest
else|:
name|Nominal_TOPN
operator|)
expr_stmt|;
else|#
directive|else
name|topn
operator|=
name|Largest
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* set header display accordingly */
name|display_header
argument_list|(
name|topn
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* determine interactive state */
if|if
condition|(
name|interactive
operator|==
name|Maybe
condition|)
block|{
name|interactive
operator|=
name|smart_terminal
expr_stmt|;
block|}
comment|/* if # of displays not specified, fill it in */
if|if
condition|(
name|displays
operator|==
literal|0
condition|)
block|{
name|displays
operator|=
name|smart_terminal
condition|?
name|Infinity
else|:
literal|1
expr_stmt|;
block|}
comment|/* hold interrupt signals while setting up the screen and the handlers */
ifdef|#
directive|ifdef
name|SIGHOLD
name|sighold
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
name|sighold
argument_list|(
name|SIGQUIT
argument_list|)
expr_stmt|;
name|sighold
argument_list|(
name|SIGTSTP
argument_list|)
expr_stmt|;
else|#
directive|else
name|old_sigmask
operator|=
name|sigblock
argument_list|(
name|Smask
argument_list|(
name|SIGINT
argument_list|)
operator||
name|Smask
argument_list|(
name|SIGQUIT
argument_list|)
operator||
name|Smask
argument_list|(
name|SIGTSTP
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|init_screen
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|leave
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|leave
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|tstop
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGWINCH
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|winch
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGRELSE
name|sigrelse
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
name|sigrelse
argument_list|(
name|SIGQUIT
argument_list|)
expr_stmt|;
name|sigrelse
argument_list|(
name|SIGTSTP
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|old_sigmask
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|warnings
condition|)
block|{
name|fputs
argument_list|(
literal|"...."
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* why must I do this? */
name|sleep
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
literal|3
operator|*
name|warnings
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|restart
label|:
comment|/*      *  main loop -- repeat while display count is positive or while it      *		indicates infinity (by being -1)      */
while|while
condition|(
operator|(
name|displays
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|displays
operator|--
operator|>
literal|0
operator|)
condition|)
block|{
name|int
function_decl|(
modifier|*
name|compare
function_decl|)
parameter_list|()
function_decl|;
comment|/* get the current stats */
name|get_system_info
argument_list|(
operator|&
name|system_info
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ORDER
name|compare
operator|=
name|compares
index|[
name|order_index
index|]
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|displaymode
operator|==
name|DISP_CPU
condition|)
name|compare
operator|=
name|proc_compare
expr_stmt|;
else|else
name|compare
operator|=
name|io_compare
expr_stmt|;
endif|#
directive|endif
comment|/* get the current set of processes */
name|processes
operator|=
name|get_process_info
argument_list|(
operator|&
name|system_info
argument_list|,
operator|&
name|ps
argument_list|,
name|compare
argument_list|)
expr_stmt|;
comment|/* display the load averages */
call|(
modifier|*
name|d_loadave
call|)
argument_list|(
name|system_info
operator|.
name|last_pid
argument_list|,
name|system_info
operator|.
name|load_avg
argument_list|)
expr_stmt|;
comment|/* display the current time */
comment|/* this method of getting the time SHOULD be fairly portable */
name|time
argument_list|(
operator|&
name|curr_time
argument_list|)
expr_stmt|;
name|i_uptime
argument_list|(
operator|&
name|system_info
operator|.
name|boottime
argument_list|,
operator|&
name|curr_time
argument_list|)
expr_stmt|;
name|i_timeofday
argument_list|(
operator|&
name|curr_time
argument_list|)
expr_stmt|;
comment|/* display process state breakdown */
call|(
modifier|*
name|d_procstates
call|)
argument_list|(
name|system_info
operator|.
name|p_total
argument_list|,
name|system_info
operator|.
name|procstates
argument_list|)
expr_stmt|;
comment|/* display the cpu state percentage breakdown */
if|if
condition|(
name|dostates
condition|)
comment|/* but not the first time */
block|{
call|(
modifier|*
name|d_cpustates
call|)
argument_list|(
name|system_info
operator|.
name|cpustates
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* we'll do it next time */
if|if
condition|(
name|smart_terminal
condition|)
block|{
name|z_cpustates
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|dostates
operator|=
name|Yes
expr_stmt|;
block|}
comment|/* display memory stats */
call|(
modifier|*
name|d_memory
call|)
argument_list|(
name|system_info
operator|.
name|memory
argument_list|)
expr_stmt|;
call|(
modifier|*
name|d_arc
call|)
argument_list|(
name|system_info
operator|.
name|arc
argument_list|)
expr_stmt|;
call|(
modifier|*
name|d_carc
call|)
argument_list|(
name|system_info
operator|.
name|carc
argument_list|)
expr_stmt|;
comment|/* display swap stats */
call|(
modifier|*
name|d_swap
call|)
argument_list|(
name|system_info
operator|.
name|swap
argument_list|)
expr_stmt|;
comment|/* handle message area */
call|(
modifier|*
name|d_message
call|)
argument_list|()
expr_stmt|;
comment|/* update the header area */
call|(
modifier|*
name|d_header
call|)
argument_list|(
name|header_text
argument_list|)
expr_stmt|;
if|if
condition|(
name|topn
operator|>
literal|0
condition|)
block|{
comment|/* determine number of processes to actually display */
comment|/* this number will be the smallest of:  active processes, 	       number user requested, number current screen accomodates */
name|active_procs
operator|=
name|system_info
operator|.
name|P_ACTIVE
expr_stmt|;
if|if
condition|(
name|active_procs
operator|>
name|topn
condition|)
block|{
name|active_procs
operator|=
name|topn
expr_stmt|;
block|}
if|if
condition|(
name|active_procs
operator|>
name|max_topn
condition|)
block|{
name|active_procs
operator|=
name|max_topn
expr_stmt|;
block|}
comment|/* now show the top "n" processes. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|active_procs
condition|;
name|i
operator|++
control|)
block|{
call|(
modifier|*
name|d_process
call|)
argument_list|(
name|i
argument_list|,
name|format_next_process
argument_list|(
name|processes
argument_list|,
name|get_userid
argument_list|,
name|fmt_flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
block|}
comment|/* do end-screen processing */
name|u_endscreen
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* now, flush the output buffer */
if|if
condition|(
name|fflush
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|new_message
argument_list|(
name|MT_standout
argument_list|,
literal|" Write error on stdout"
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
comment|/* only do the rest if we have more displays to show */
if|if
condition|(
name|displays
condition|)
block|{
comment|/* switch out for new display on smart terminals */
if|if
condition|(
name|smart_terminal
condition|)
block|{
if|if
condition|(
name|overstrike
condition|)
block|{
name|reset_display
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|d_loadave
operator|=
name|u_loadave
expr_stmt|;
name|d_procstates
operator|=
name|u_procstates
expr_stmt|;
name|d_cpustates
operator|=
name|u_cpustates
expr_stmt|;
name|d_memory
operator|=
name|u_memory
expr_stmt|;
name|d_arc
operator|=
name|u_arc
expr_stmt|;
name|d_carc
operator|=
name|u_carc
expr_stmt|;
name|d_swap
operator|=
name|u_swap
expr_stmt|;
name|d_message
operator|=
name|u_message
expr_stmt|;
name|d_header
operator|=
name|u_header
expr_stmt|;
name|d_process
operator|=
name|u_process
expr_stmt|;
block|}
block|}
name|no_command
operator|=
name|Yes
expr_stmt|;
if|if
condition|(
operator|!
name|interactive
condition|)
block|{
name|sleep
argument_list|(
name|delay
argument_list|)
expr_stmt|;
if|if
condition|(
name|leaveflag
condition|)
block|{
name|end_screen
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
while|while
condition|(
name|no_command
condition|)
block|{
comment|/* assume valid command unless told otherwise */
name|no_command
operator|=
name|No
expr_stmt|;
comment|/* set up arguments for select with timeout */
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
literal|0
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
comment|/* for standard input */
name|timeout
operator|.
name|tv_sec
operator|=
name|delay
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|leaveflag
condition|)
block|{
name|end_screen
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tstopflag
condition|)
block|{
comment|/* move to the lower left */
name|end_screen
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* default the signal handler action */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* unblock the signal and send ourselves one */
ifdef|#
directive|ifdef
name|SIGRELSE
name|sigrelse
argument_list|(
name|SIGTSTP
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|sigblock
argument_list|(
literal|0
argument_list|)
operator|&
operator|~
operator|(
literal|1
operator|<<
operator|(
name|SIGTSTP
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
comment|/* reset the signal handler */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|tstop
argument_list|)
expr_stmt|;
comment|/* reinit screen */
name|reinit_screen
argument_list|()
expr_stmt|;
name|reset_display
argument_list|()
expr_stmt|;
name|tstopflag
operator|=
literal|0
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
if|if
condition|(
name|winchflag
condition|)
block|{
comment|/* reascertain the screen dimensions */
name|get_screensize
argument_list|()
expr_stmt|;
comment|/* tell display to resize */
name|max_topn
operator|=
name|display_resize
argument_list|()
expr_stmt|;
comment|/* reset the signal handler */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|winch
argument_list|)
expr_stmt|;
name|reset_display
argument_list|()
expr_stmt|;
name|winchflag
operator|=
literal|0
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
comment|/* wait for either input or the end of the delay period */
name|sel_ret
operator|=
name|select
argument_list|(
literal|2
argument_list|,
operator|&
name|readfds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|sel_ret
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
name|quit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sel_ret
operator|>
literal|0
condition|)
block|{
name|int
name|newval
decl_stmt|;
name|char
modifier|*
name|errmsg
decl_stmt|;
comment|/* something to read -- clear the message area first */
name|clear_message
argument_list|()
expr_stmt|;
comment|/* now read it and convert to command strchr */
comment|/* (use "change" as a temporary to hold strchr) */
if|if
condition|(
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
block|{
comment|/* read error: either 0 or -1 */
name|new_message
argument_list|(
name|MT_standout
argument_list|,
literal|" Read error on stdin"
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
operator|(
name|iptr
operator|=
name|strchr
argument_list|(
name|command_chars
argument_list|,
name|ch
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ch
operator|!=
literal|'\r'
operator|&&
name|ch
operator|!=
literal|'\n'
condition|)
block|{
comment|/* illegal command */
name|new_message
argument_list|(
name|MT_standout
argument_list|,
literal|" Command not understood"
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|no_command
operator|=
name|Yes
expr_stmt|;
block|}
else|else
block|{
name|change
operator|=
name|iptr
operator|-
name|command_chars
expr_stmt|;
if|if
condition|(
name|overstrike
operator|&&
name|change
operator|>
name|CMD_OSLIMIT
condition|)
block|{
comment|/* error */
name|new_message
argument_list|(
name|MT_standout
argument_list|,
literal|" Command cannot be handled by this terminal"
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|no_command
operator|=
name|Yes
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|change
condition|)
block|{
case|case
name|CMD_redraw
case|:
comment|/* redraw screen */
name|reset_display
argument_list|()
expr_stmt|;
break|break;
case|case
name|CMD_update
case|:
comment|/* merely update display */
comment|/* is the load average high? */
if|if
condition|(
name|system_info
operator|.
name|load_avg
index|[
literal|0
index|]
operator|>
name|LoadMax
condition|)
block|{
comment|/* yes, go home for visual feedback */
name|go_home
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_quit
case|:
comment|/* quit */
name|quit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
break|break;
case|case
name|CMD_help1
case|:
comment|/* help */
case|case
name|CMD_help2
case|:
name|reset_display
argument_list|()
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|show_help
argument_list|()
expr_stmt|;
name|standout
argument_list|(
literal|"Hit any key to continue: "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_errors
case|:
comment|/* show errors */
if|if
condition|(
name|error_count
argument_list|()
operator|==
literal|0
condition|)
block|{
name|new_message
argument_list|(
name|MT_standout
argument_list|,
literal|" Currently no errors to report."
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|no_command
operator|=
name|Yes
expr_stmt|;
block|}
else|else
block|{
name|reset_display
argument_list|()
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|show_errors
argument_list|()
expr_stmt|;
name|standout
argument_list|(
literal|"Hit any key to continue: "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_number1
case|:
comment|/* new number */
case|case
name|CMD_number2
case|:
name|new_message
argument_list|(
name|MT_standout
argument_list|,
literal|"Number of processes to show: "
argument_list|)
expr_stmt|;
name|newval
operator|=
name|readline
argument_list|(
name|tempbuf1
argument_list|,
literal|8
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
if|if
condition|(
name|newval
operator|>
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|newval
operator|>
name|max_topn
condition|)
block|{
name|new_message
argument_list|(
name|MT_standout
operator||
name|MT_delayed
argument_list|,
literal|" This terminal can only display %d processes."
argument_list|,
name|max_topn
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newval
operator|==
literal|0
condition|)
block|{
comment|/* inhibit the header */
name|display_header
argument_list|(
name|No
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newval
operator|>
name|topn
operator|&&
name|topn
operator|==
literal|0
condition|)
block|{
comment|/* redraw the header */
name|display_header
argument_list|(
name|Yes
argument_list|)
expr_stmt|;
name|d_header
operator|=
name|i_header
expr_stmt|;
block|}
name|topn
operator|=
name|newval
expr_stmt|;
block|}
break|break;
case|case
name|CMD_delay
case|:
comment|/* new seconds delay */
name|new_message
argument_list|(
name|MT_standout
argument_list|,
literal|"Seconds to delay: "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|readline
argument_list|(
name|tempbuf1
argument_list|,
literal|8
argument_list|,
name|Yes
argument_list|)
operator|)
operator|>
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|delay
operator|=
name|i
operator|)
operator|==
literal|0
operator|&&
name|getuid
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|delay
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|clear_message
argument_list|()
expr_stmt|;
break|break;
case|case
name|CMD_displays
case|:
comment|/* change display count */
name|new_message
argument_list|(
name|MT_standout
argument_list|,
literal|"Displays to show (currently %s): "
argument_list|,
name|displays
operator|==
operator|-
literal|1
condition|?
literal|"infinite"
else|:
name|itoa
argument_list|(
name|displays
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|readline
argument_list|(
name|tempbuf1
argument_list|,
literal|10
argument_list|,
name|Yes
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|displays
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|quit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|clear_message
argument_list|()
expr_stmt|;
break|break;
case|case
name|CMD_kill
case|:
comment|/* kill program */
name|new_message
argument_list|(
literal|0
argument_list|,
literal|"kill "
argument_list|)
expr_stmt|;
if|if
condition|(
name|readline
argument_list|(
name|tempbuf2
argument_list|,
sizeof|sizeof
argument_list|(
name|tempbuf2
argument_list|)
argument_list|,
name|No
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|errmsg
operator|=
name|kill_procs
argument_list|(
name|tempbuf2
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|new_message
argument_list|(
name|MT_standout
argument_list|,
literal|"%s"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|no_command
operator|=
name|Yes
expr_stmt|;
block|}
block|}
else|else
block|{
name|clear_message
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CMD_renice
case|:
comment|/* renice program */
name|new_message
argument_list|(
literal|0
argument_list|,
literal|"renice "
argument_list|)
expr_stmt|;
if|if
condition|(
name|readline
argument_list|(
name|tempbuf2
argument_list|,
sizeof|sizeof
argument_list|(
name|tempbuf2
argument_list|)
argument_list|,
name|No
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|errmsg
operator|=
name|renice_procs
argument_list|(
name|tempbuf2
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|new_message
argument_list|(
name|MT_standout
argument_list|,
literal|"%s"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|no_command
operator|=
name|Yes
expr_stmt|;
block|}
block|}
else|else
block|{
name|clear_message
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CMD_idletog
case|:
case|case
name|CMD_idletog2
case|:
name|ps
operator|.
name|idle
operator|=
operator|!
name|ps
operator|.
name|idle
expr_stmt|;
name|new_message
argument_list|(
name|MT_standout
operator||
name|MT_delayed
argument_list|,
literal|" %sisplaying idle processes."
argument_list|,
name|ps
operator|.
name|idle
condition|?
literal|"D"
else|:
literal|"Not d"
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_selftog
case|:
name|ps
operator|.
name|self
operator|=
operator|(
name|ps
operator|.
name|self
operator|==
operator|-
literal|1
operator|)
condition|?
name|getpid
argument_list|()
else|:
operator|-
literal|1
expr_stmt|;
name|new_message
argument_list|(
name|MT_standout
operator||
name|MT_delayed
argument_list|,
literal|" %sisplaying self."
argument_list|,
operator|(
name|ps
operator|.
name|self
operator|==
operator|-
literal|1
operator|)
condition|?
literal|"D"
else|:
literal|"Not d"
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_user
case|:
if|if
condition|(
name|handle_user
argument_list|(
name|tempbuf2
argument_list|,
sizeof|sizeof
argument_list|(
name|tempbuf2
argument_list|)
argument_list|)
condition|)
name|no_command
operator|=
name|Yes
expr_stmt|;
break|break;
case|case
name|CMD_thrtog
case|:
name|ps
operator|.
name|thread
operator|=
operator|!
name|ps
operator|.
name|thread
expr_stmt|;
name|new_message
argument_list|(
name|MT_standout
operator||
name|MT_delayed
argument_list|,
literal|" Displaying threads %s"
argument_list|,
name|ps
operator|.
name|thread
condition|?
literal|"separately"
else|:
literal|"as a count"
argument_list|)
expr_stmt|;
name|header_text
operator|=
name|format_header
argument_list|(
name|uname_field
argument_list|)
expr_stmt|;
name|reset_display
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_wcputog
case|:
name|ps
operator|.
name|wcpu
operator|=
operator|!
name|ps
operator|.
name|wcpu
expr_stmt|;
name|new_message
argument_list|(
name|MT_standout
operator||
name|MT_delayed
argument_list|,
literal|" Displaying %s CPU"
argument_list|,
name|ps
operator|.
name|wcpu
condition|?
literal|"weighted"
else|:
literal|"raw"
argument_list|)
expr_stmt|;
name|header_text
operator|=
name|format_header
argument_list|(
name|uname_field
argument_list|)
expr_stmt|;
name|reset_display
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_viewtog
case|:
if|if
condition|(
operator|++
name|displaymode
operator|==
name|DISP_MAX
condition|)
name|displaymode
operator|=
literal|0
expr_stmt|;
name|header_text
operator|=
name|format_header
argument_list|(
name|uname_field
argument_list|)
expr_stmt|;
name|display_header
argument_list|(
name|Yes
argument_list|)
expr_stmt|;
name|d_header
operator|=
name|i_header
expr_stmt|;
name|reset_display
argument_list|()
expr_stmt|;
break|break;
case|case
name|CMD_viewsys
case|:
name|ps
operator|.
name|system
operator|=
operator|!
name|ps
operator|.
name|system
expr_stmt|;
break|break;
case|case
name|CMD_showargs
case|:
name|fmt_flags
operator|^=
name|FMT_SHOWARGS
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|ORDER
case|case
name|CMD_order
case|:
name|new_message
argument_list|(
name|MT_standout
argument_list|,
literal|"Order to sort: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|readline
argument_list|(
name|tempbuf2
argument_list|,
sizeof|sizeof
argument_list|(
name|tempbuf2
argument_list|)
argument_list|,
name|No
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|string_index
argument_list|(
name|tempbuf2
argument_list|,
name|statics
operator|.
name|order_names
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|new_message
argument_list|(
name|MT_standout
argument_list|,
literal|" %s: unrecognized sorting order"
argument_list|,
name|tempbuf2
argument_list|)
expr_stmt|;
name|no_command
operator|=
name|Yes
expr_stmt|;
block|}
else|else
block|{
name|order_index
operator|=
name|i
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clear_message
argument_list|()
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|CMD_jidtog
case|:
name|ps
operator|.
name|jail
operator|=
operator|!
name|ps
operator|.
name|jail
expr_stmt|;
name|new_message
argument_list|(
name|MT_standout
operator||
name|MT_delayed
argument_list|,
literal|" %sisplaying jail ID."
argument_list|,
name|ps
operator|.
name|jail
condition|?
literal|"D"
else|:
literal|"Not d"
argument_list|)
expr_stmt|;
name|header_text
operator|=
name|format_header
argument_list|(
name|uname_field
argument_list|)
expr_stmt|;
name|reset_display
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_jail
case|:
name|new_message
argument_list|(
name|MT_standout
argument_list|,
literal|"Jail to show (+ for all): "
argument_list|)
expr_stmt|;
if|if
condition|(
name|readline
argument_list|(
name|tempbuf2
argument_list|,
sizeof|sizeof
argument_list|(
name|tempbuf2
argument_list|)
argument_list|,
name|No
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|tempbuf2
index|[
literal|0
index|]
operator|==
literal|'+'
operator|&&
name|tempbuf2
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|ps
operator|.
name|jid
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|=
name|jail_getid
argument_list|(
name|tempbuf2
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|new_message
argument_list|(
name|MT_standout
argument_list|,
literal|" %s: unknown jail"
argument_list|,
name|tempbuf2
argument_list|)
expr_stmt|;
name|no_command
operator|=
name|Yes
expr_stmt|;
block|}
else|else
block|{
name|ps
operator|.
name|jid
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|ps
operator|.
name|jail
operator|==
literal|0
condition|)
block|{
name|ps
operator|.
name|jail
operator|=
literal|1
expr_stmt|;
name|new_message
argument_list|(
name|MT_standout
operator||
name|MT_delayed
argument_list|,
literal|" Displaying jail "
literal|"ID."
argument_list|)
expr_stmt|;
name|header_text
operator|=
name|format_header
argument_list|(
name|uname_field
argument_list|)
expr_stmt|;
name|reset_display
argument_list|()
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clear_message
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CMD_kidletog
case|:
name|ps
operator|.
name|kidle
operator|=
operator|!
name|ps
operator|.
name|kidle
expr_stmt|;
name|new_message
argument_list|(
name|MT_standout
operator||
name|MT_delayed
argument_list|,
literal|" %sisplaying system idle process."
argument_list|,
name|ps
operator|.
name|kidle
condition|?
literal|"D"
else|:
literal|"Not d"
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_pcputog
case|:
name|pcpu_stats
operator|=
operator|!
name|pcpu_stats
expr_stmt|;
name|new_message
argument_list|(
name|MT_standout
operator||
name|MT_delayed
argument_list|,
literal|" Displaying %sCPU statistics."
argument_list|,
name|pcpu_stats
condition|?
literal|"per-"
else|:
literal|"global "
argument_list|)
expr_stmt|;
name|toggle_pcpustats
argument_list|()
expr_stmt|;
name|max_topn
operator|=
name|display_updatecpus
argument_list|(
operator|&
name|statics
argument_list|)
expr_stmt|;
name|reset_display
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_swaptog
case|:
name|ps
operator|.
name|swap
operator|=
operator|!
name|ps
operator|.
name|swap
expr_stmt|;
name|new_message
argument_list|(
name|MT_standout
operator||
name|MT_delayed
argument_list|,
literal|" %sisplaying per-process swap usage."
argument_list|,
name|ps
operator|.
name|swap
condition|?
literal|"D"
else|:
literal|"Not d"
argument_list|)
expr_stmt|;
name|header_text
operator|=
name|format_header
argument_list|(
name|uname_field
argument_list|)
expr_stmt|;
name|reset_display
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
break|break;
default|default:
name|new_message
argument_list|(
name|MT_standout
argument_list|,
literal|" BAD CASE IN SWITCH!"
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* flush out stuff that may have been written */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fclose
argument_list|(
name|debug
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|quit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/*  *  reset_display() - reset all the display routine pointers so that entire  *	screen will get redrawn.  */
end_comment

begin_function
name|void
name|reset_display
parameter_list|()
block|{
name|d_loadave
operator|=
name|i_loadave
expr_stmt|;
name|d_procstates
operator|=
name|i_procstates
expr_stmt|;
name|d_cpustates
operator|=
name|i_cpustates
expr_stmt|;
name|d_memory
operator|=
name|i_memory
expr_stmt|;
name|d_arc
operator|=
name|i_arc
expr_stmt|;
name|d_carc
operator|=
name|i_carc
expr_stmt|;
name|d_swap
operator|=
name|i_swap
expr_stmt|;
name|d_message
operator|=
name|i_message
expr_stmt|;
name|d_header
operator|=
name|i_header
expr_stmt|;
name|d_process
operator|=
name|i_process
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  signal handlers  */
end_comment

begin_function
name|sigret_t
name|leave
parameter_list|()
comment|/* exit under normal conditions -- INT handler */
block|{
name|leaveflag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|sigret_t
name|tstop
parameter_list|(
name|i
parameter_list|)
comment|/* SIGTSTP handler */
name|int
name|i
decl_stmt|;
block|{
name|tstopflag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SIGWINCH
end_ifdef

begin_function
name|sigret_t
name|winch
parameter_list|(
name|i
parameter_list|)
comment|/* SIGWINCH handler */
name|int
name|i
decl_stmt|;
block|{
name|winchflag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|quit
parameter_list|(
name|status
parameter_list|)
comment|/* exit under duress */
name|int
name|status
decl_stmt|;
block|{
name|end_screen
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

end_unit

