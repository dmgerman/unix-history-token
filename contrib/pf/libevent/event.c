begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2004 Niels Provos<provos@citi.umich.edu>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_define
define|#
directive|define
name|WIN32_LEAN_AND_MEAN
end_define

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_undef
undef|#
directive|undef
name|WIN32_LEAN_AND_MEAN
end_undef

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/tree.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/_time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|WIN32
end_ifndef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"event.h"
end_include

begin_include
include|#
directive|include
file|"event-internal.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EVENT_PORTS
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eventop
name|evportops
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SELECT
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eventop
name|selectops
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_POLL
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eventop
name|pollops
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_RTSIG
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eventop
name|rtsigops
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EPOLL
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eventop
name|epollops
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_WORKING_KQUEUE
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eventop
name|kqops
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DEVPOLL
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eventop
name|devpollops
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eventop
name|win32ops
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* In order of preference */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|eventop
modifier|*
name|eventops
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|HAVE_EVENT_PORTS
operator|&
name|evportops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_WORKING_KQUEUE
operator|&
name|kqops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_EPOLL
operator|&
name|epollops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_DEVPOLL
operator|&
name|devpollops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_RTSIG
operator|&
name|rtsigops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_POLL
operator|&
name|pollops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SELECT
operator|&
name|selectops
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WIN32
operator|&
name|win32ops
block|,
endif|#
directive|endif
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global state */
end_comment

begin_decl_stmt
name|struct
name|event_list
name|signalqueue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|event_base
modifier|*
name|current_base
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle signals - This is a deprecated interface */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
name|event_sigcb
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Signal callback when gotsig is set */
end_comment

begin_decl_stmt
specifier|volatile
name|sig_atomic_t
name|event_gotsig
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set in signal handler */
end_comment

begin_comment
comment|/* Prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|event_queue_insert
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|struct
name|event
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|event_queue_remove
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|struct
name|event
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|event_haveevents
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|event_process_active
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|timeout_next
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|timeout_process
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|timeout_correct
parameter_list|(
name|struct
name|event_base
modifier|*
parameter_list|,
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|compare
parameter_list|(
name|struct
name|event
modifier|*
name|a
parameter_list|,
name|struct
name|event
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|a
operator|->
name|ev_timeout
argument_list|,
operator|&
name|b
operator|->
name|ev_timeout
argument_list|,
operator|<
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|a
operator|->
name|ev_timeout
argument_list|,
operator|&
name|b
operator|->
name|ev_timeout
argument_list|,
operator|>
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|<
name|b
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|a
operator|>
name|b
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gettime
parameter_list|(
name|struct
name|timeval
modifier|*
name|tp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_CLOCK_GETTIME
name|struct
name|timespec
name|ts
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_CLOCK_MONOTONIC
if|if
condition|(
name|clock_gettime
argument_list|(
name|CLOCK_MONOTONIC
argument_list|,
operator|&
name|ts
argument_list|)
operator|==
operator|-
literal|1
condition|)
else|#
directive|else
if|if
condition|(
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|ts
argument_list|)
operator|==
operator|-
literal|1
condition|)
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|tp
operator|->
name|tv_sec
operator|=
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|tp
operator|->
name|tv_usec
operator|=
name|ts
operator|.
name|tv_nsec
operator|/
literal|1000
expr_stmt|;
else|#
directive|else
name|gettimeofday
argument_list|(
name|tp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|RB_PROTOTYPE
argument_list|(
name|event_tree
argument_list|,
name|event
argument_list|,
name|ev_timeout_node
argument_list|,
name|compare
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RB_GENERATE
argument_list|(
name|event_tree
argument_list|,
name|event
argument_list|,
name|ev_timeout_node
argument_list|,
name|compare
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
modifier|*
name|event_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|current_base
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|event_base
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|event_err
argument_list|(
literal|1
argument_list|,
literal|"%s: calloc"
argument_list|)
expr_stmt|;
name|event_sigcb
operator|=
name|NULL
expr_stmt|;
name|event_gotsig
operator|=
literal|0
expr_stmt|;
name|gettime
argument_list|(
operator|&
name|current_base
operator|->
name|event_tv
argument_list|)
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|current_base
operator|->
name|timetree
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|current_base
operator|->
name|eventqueue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|signalqueue
argument_list|)
expr_stmt|;
name|current_base
operator|->
name|evbase
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|eventops
index|[
name|i
index|]
operator|&&
operator|!
name|current_base
operator|->
name|evbase
condition|;
name|i
operator|++
control|)
block|{
name|current_base
operator|->
name|evsel
operator|=
name|eventops
index|[
name|i
index|]
expr_stmt|;
name|current_base
operator|->
name|evbase
operator|=
name|current_base
operator|->
name|evsel
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|current_base
operator|->
name|evbase
operator|==
name|NULL
condition|)
name|event_errx
argument_list|(
literal|1
argument_list|,
literal|"%s: no event mechanism available"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|getenv
argument_list|(
literal|"EVENT_SHOW_METHOD"
argument_list|)
condition|)
name|event_msgx
argument_list|(
literal|"libevent using: %s\n"
argument_list|,
name|current_base
operator|->
name|evsel
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* allocate a single active event queue */
name|event_base_priority_init
argument_list|(
name|current_base
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|current_base
operator|)
return|;
block|}
end_function

begin_function
name|void
name|event_base_free
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|base
operator|==
name|NULL
operator|&&
name|current_base
condition|)
name|base
operator|=
name|current_base
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|current_base
condition|)
name|current_base
operator|=
name|NULL
expr_stmt|;
name|assert
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|base
operator|->
name|eventqueue
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|base
operator|->
name|nactivequeues
condition|;
operator|++
name|i
control|)
name|assert
argument_list|(
name|TAILQ_EMPTY
argument_list|(
name|base
operator|->
name|activequeues
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|RB_EMPTY
argument_list|(
operator|&
name|base
operator|->
name|timetree
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|base
operator|->
name|nactivequeues
condition|;
operator|++
name|i
control|)
name|free
argument_list|(
name|base
operator|->
name|activequeues
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|base
operator|->
name|activequeues
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|->
name|evsel
operator|->
name|dealloc
operator|!=
name|NULL
condition|)
name|base
operator|->
name|evsel
operator|->
name|dealloc
argument_list|(
name|base
operator|->
name|evbase
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|event_priority_init
parameter_list|(
name|int
name|npriorities
parameter_list|)
block|{
return|return
name|event_base_priority_init
argument_list|(
name|current_base
argument_list|,
name|npriorities
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|event_base_priority_init
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|int
name|npriorities
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|base
operator|->
name|event_count_active
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|base
operator|->
name|nactivequeues
operator|&&
name|npriorities
operator|!=
name|base
operator|->
name|nactivequeues
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|base
operator|->
name|nactivequeues
condition|;
operator|++
name|i
control|)
block|{
name|free
argument_list|(
name|base
operator|->
name|activequeues
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|base
operator|->
name|activequeues
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate our priority queues */
name|base
operator|->
name|nactivequeues
operator|=
name|npriorities
expr_stmt|;
name|base
operator|->
name|activequeues
operator|=
operator|(
expr|struct
name|event_list
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|base
operator|->
name|nactivequeues
argument_list|,
name|npriorities
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|event_list
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|->
name|activequeues
operator|==
name|NULL
condition|)
name|event_err
argument_list|(
literal|1
argument_list|,
literal|"%s: calloc"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|base
operator|->
name|nactivequeues
condition|;
operator|++
name|i
control|)
block|{
name|base
operator|->
name|activequeues
index|[
name|i
index|]
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|event_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|->
name|activequeues
index|[
name|i
index|]
operator|==
name|NULL
condition|)
name|event_err
argument_list|(
literal|1
argument_list|,
literal|"%s: malloc"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
name|base
operator|->
name|activequeues
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|event_haveevents
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
return|return
operator|(
name|base
operator|->
name|event_count
operator|>
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Active events are stored in priority queues.  Lower priorities are always  * process before higher priorities.  Low priority events can starve high  * priority ones.  */
end_comment

begin_function
specifier|static
name|void
name|event_process_active
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|struct
name|event
modifier|*
name|ev
decl_stmt|;
name|struct
name|event_list
modifier|*
name|activeq
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|short
name|ncalls
decl_stmt|;
if|if
condition|(
operator|!
name|base
operator|->
name|event_count_active
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|base
operator|->
name|nactivequeues
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
name|base
operator|->
name|activequeues
index|[
name|i
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|activeq
operator|=
name|base
operator|->
name|activequeues
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
name|assert
argument_list|(
name|activeq
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|ev
operator|=
name|TAILQ_FIRST
argument_list|(
name|activeq
argument_list|)
init|;
name|ev
condition|;
name|ev
operator|=
name|TAILQ_FIRST
argument_list|(
name|activeq
argument_list|)
control|)
block|{
name|event_queue_remove
argument_list|(
name|base
argument_list|,
name|ev
argument_list|,
name|EVLIST_ACTIVE
argument_list|)
expr_stmt|;
comment|/* Allows deletes to work */
name|ncalls
operator|=
name|ev
operator|->
name|ev_ncalls
expr_stmt|;
name|ev
operator|->
name|ev_pncalls
operator|=
operator|&
name|ncalls
expr_stmt|;
while|while
condition|(
name|ncalls
condition|)
block|{
name|ncalls
operator|--
expr_stmt|;
name|ev
operator|->
name|ev_ncalls
operator|=
name|ncalls
expr_stmt|;
call|(
modifier|*
name|ev
operator|->
name|ev_callback
call|)
argument_list|(
operator|(
name|int
operator|)
name|ev
operator|->
name|ev_fd
argument_list|,
name|ev
operator|->
name|ev_res
argument_list|,
name|ev
operator|->
name|ev_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_gotsig
condition|)
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Wait continously for events.  We exit only if no events are left.  */
end_comment

begin_function
name|int
name|event_dispatch
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|event_loop
argument_list|(
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|event_base_dispatch
parameter_list|(
name|struct
name|event_base
modifier|*
name|event_base
parameter_list|)
block|{
return|return
operator|(
name|event_base_loop
argument_list|(
name|event_base
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|event_loopexit_cb
parameter_list|(
name|int
name|fd
parameter_list|,
name|short
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|event_base
modifier|*
name|base
init|=
name|arg
decl_stmt|;
name|base
operator|->
name|event_gotterm
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* not thread safe */
end_comment

begin_function
name|int
name|event_loopexit
parameter_list|(
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
return|return
operator|(
name|event_once
argument_list|(
operator|-
literal|1
argument_list|,
name|EV_TIMEOUT
argument_list|,
name|event_loopexit_cb
argument_list|,
name|current_base
argument_list|,
name|tv
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|event_base_loopexit
parameter_list|(
name|struct
name|event_base
modifier|*
name|event_base
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
return|return
operator|(
name|event_once
argument_list|(
operator|-
literal|1
argument_list|,
name|EV_TIMEOUT
argument_list|,
name|event_loopexit_cb
argument_list|,
name|event_base
argument_list|,
name|tv
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* not thread safe */
end_comment

begin_function
name|int
name|event_loop
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
return|return
name|event_base_loop
argument_list|(
name|current_base
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|event_base_loop
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
specifier|const
name|struct
name|eventop
modifier|*
name|evsel
init|=
name|base
operator|->
name|evsel
decl_stmt|;
name|void
modifier|*
name|evbase
init|=
name|base
operator|->
name|evbase
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|res
decl_stmt|,
name|done
decl_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
comment|/* Calculate the initial events that we are waiting for */
if|if
condition|(
name|evsel
operator|->
name|recalc
argument_list|(
name|base
argument_list|,
name|evbase
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Terminate the loop if we have been asked to */
if|if
condition|(
name|base
operator|->
name|event_gotterm
condition|)
block|{
name|base
operator|->
name|event_gotterm
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* You cannot use this interface for multi-threaded apps */
while|while
condition|(
name|event_gotsig
condition|)
block|{
name|event_gotsig
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|event_sigcb
condition|)
block|{
name|res
operator|=
call|(
modifier|*
name|event_sigcb
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
name|res
operator|==
operator|-
literal|1
condition|)
block|{
name|errno
operator|=
name|EINTR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
comment|/* Check if time is running backwards */
name|gettime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|base
operator|->
name|event_tv
argument_list|,
operator|<
argument_list|)
condition|)
block|{
name|struct
name|timeval
name|off
decl_stmt|;
name|event_debug
argument_list|(
operator|(
literal|"%s: time is running backwards, corrected"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|timersub
argument_list|(
operator|&
name|base
operator|->
name|event_tv
argument_list|,
operator|&
name|tv
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
name|timeout_correct
argument_list|(
name|base
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
block|}
name|base
operator|->
name|event_tv
operator|=
name|tv
expr_stmt|;
if|if
condition|(
operator|!
name|base
operator|->
name|event_count_active
operator|&&
operator|!
operator|(
name|flags
operator|&
name|EVLOOP_NONBLOCK
operator|)
condition|)
name|timeout_next
argument_list|(
name|base
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
else|else
name|timerclear
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
comment|/* If we have no events, we just exit */
if|if
condition|(
operator|!
name|event_haveevents
argument_list|(
name|base
argument_list|)
condition|)
block|{
name|event_debug
argument_list|(
operator|(
literal|"%s: no events registered."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|res
operator|=
name|evsel
operator|->
name|dispatch
argument_list|(
name|base
argument_list|,
name|evbase
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|timeout_process
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|->
name|event_count_active
condition|)
block|{
name|event_process_active
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base
operator|->
name|event_count_active
operator|&&
operator|(
name|flags
operator|&
name|EVLOOP_ONCE
operator|)
condition|)
name|done
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|EVLOOP_NONBLOCK
condition|)
name|done
operator|=
literal|1
expr_stmt|;
block|}
name|event_debug
argument_list|(
operator|(
literal|"%s: asked to terminate loop."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Sets up an event for processing once */
end_comment

begin_struct
struct|struct
name|event_once
block|{
name|struct
name|event
name|ev
decl_stmt|;
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|arg
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* One-time callback, it deletes itself */
end_comment

begin_function
specifier|static
name|void
name|event_once_cb
parameter_list|(
name|int
name|fd
parameter_list|,
name|short
name|events
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|event_once
modifier|*
name|eonce
init|=
name|arg
decl_stmt|;
call|(
modifier|*
name|eonce
operator|->
name|cb
call|)
argument_list|(
name|fd
argument_list|,
name|events
argument_list|,
name|eonce
operator|->
name|arg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|eonce
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Schedules an event once */
end_comment

begin_function
name|int
name|event_once
parameter_list|(
name|int
name|fd
parameter_list|,
name|short
name|events
parameter_list|,
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
name|struct
name|event_once
modifier|*
name|eonce
decl_stmt|;
name|struct
name|timeval
name|etv
decl_stmt|;
name|int
name|res
decl_stmt|;
comment|/* We cannot support signals that just fire once */
if|if
condition|(
name|events
operator|&
name|EV_SIGNAL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|eonce
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|event_once
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|eonce
operator|->
name|cb
operator|=
name|callback
expr_stmt|;
name|eonce
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|events
operator|==
name|EV_TIMEOUT
condition|)
block|{
if|if
condition|(
name|tv
operator|==
name|NULL
condition|)
block|{
name|timerclear
argument_list|(
operator|&
name|etv
argument_list|)
expr_stmt|;
name|tv
operator|=
operator|&
name|etv
expr_stmt|;
block|}
name|evtimer_set
argument_list|(
operator|&
name|eonce
operator|->
name|ev
argument_list|,
name|event_once_cb
argument_list|,
name|eonce
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|events
operator|&
operator|(
name|EV_READ
operator||
name|EV_WRITE
operator|)
condition|)
block|{
name|events
operator|&=
name|EV_READ
operator||
name|EV_WRITE
expr_stmt|;
name|event_set
argument_list|(
operator|&
name|eonce
operator|->
name|ev
argument_list|,
name|fd
argument_list|,
name|events
argument_list|,
name|event_once_cb
argument_list|,
name|eonce
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Bad event combination */
name|free
argument_list|(
name|eonce
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|res
operator|=
name|event_add
argument_list|(
operator|&
name|eonce
operator|->
name|ev
argument_list|,
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|eonce
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|event_set
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|int
name|fd
parameter_list|,
name|short
name|events
parameter_list|,
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|short
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* Take the current base - caller needs to set the real base later */
name|ev
operator|->
name|ev_base
operator|=
name|current_base
expr_stmt|;
name|ev
operator|->
name|ev_callback
operator|=
name|callback
expr_stmt|;
name|ev
operator|->
name|ev_arg
operator|=
name|arg
expr_stmt|;
name|ev
operator|->
name|ev_fd
operator|=
name|fd
expr_stmt|;
name|ev
operator|->
name|ev_events
operator|=
name|events
expr_stmt|;
name|ev
operator|->
name|ev_flags
operator|=
name|EVLIST_INIT
expr_stmt|;
name|ev
operator|->
name|ev_ncalls
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|ev_pncalls
operator|=
name|NULL
expr_stmt|;
comment|/* by default, we put new events into the middle priority */
name|ev
operator|->
name|ev_pri
operator|=
name|current_base
operator|->
name|nactivequeues
operator|/
literal|2
expr_stmt|;
block|}
end_function

begin_function
name|int
name|event_base_set
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|event
modifier|*
name|ev
parameter_list|)
block|{
comment|/* Only innocent events may be assigned to a different base */
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|!=
name|EVLIST_INIT
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ev
operator|->
name|ev_base
operator|=
name|base
expr_stmt|;
name|ev
operator|->
name|ev_pri
operator|=
name|base
operator|->
name|nactivequeues
operator|/
literal|2
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set's the priority of an event - if an event is already scheduled  * changing the priority is going to fail.  */
end_comment

begin_function
name|int
name|event_priority_set
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|int
name|pri
parameter_list|)
block|{
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_ACTIVE
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|pri
operator|<
literal|0
operator|||
name|pri
operator|>=
name|ev
operator|->
name|ev_base
operator|->
name|nactivequeues
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ev
operator|->
name|ev_pri
operator|=
name|pri
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Checks if a specific event is pending or scheduled.  */
end_comment

begin_function
name|int
name|event_pending
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|short
name|event
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
name|struct
name|timeval
name|now
decl_stmt|,
name|res
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_INSERTED
condition|)
name|flags
operator||=
operator|(
name|ev
operator|->
name|ev_events
operator|&
operator|(
name|EV_READ
operator||
name|EV_WRITE
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_ACTIVE
condition|)
name|flags
operator||=
name|ev
operator|->
name|ev_res
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_TIMEOUT
condition|)
name|flags
operator||=
name|EV_TIMEOUT
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_SIGNAL
condition|)
name|flags
operator||=
name|EV_SIGNAL
expr_stmt|;
name|event
operator|&=
operator|(
name|EV_TIMEOUT
operator||
name|EV_READ
operator||
name|EV_WRITE
operator||
name|EV_SIGNAL
operator|)
expr_stmt|;
comment|/* See if there is a timeout that we should report */
if|if
condition|(
name|tv
operator|!=
name|NULL
operator|&&
operator|(
name|flags
operator|&
name|event
operator|&
name|EV_TIMEOUT
operator|)
condition|)
block|{
name|gettime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|timersub
argument_list|(
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|,
operator|&
name|now
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
comment|/* correctly remap to real time */
name|gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|timeradd
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|res
argument_list|,
name|tv
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|flags
operator|&
name|event
operator|)
return|;
block|}
end_function

begin_function
name|int
name|event_add
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
name|struct
name|event_base
modifier|*
name|base
init|=
name|ev
operator|->
name|ev_base
decl_stmt|;
specifier|const
name|struct
name|eventop
modifier|*
name|evsel
init|=
name|base
operator|->
name|evsel
decl_stmt|;
name|void
modifier|*
name|evbase
init|=
name|base
operator|->
name|evbase
decl_stmt|;
name|event_debug
argument_list|(
operator|(
literal|"event_add: event: %p, %s%s%scall %p"
operator|,
name|ev
operator|,
name|ev
operator|->
name|ev_events
operator|&
name|EV_READ
condition|?
literal|"EV_READ "
else|:
literal|" "
operator|,
name|ev
operator|->
name|ev_events
operator|&
name|EV_WRITE
condition|?
literal|"EV_WRITE "
else|:
literal|" "
operator|,
name|tv
condition|?
literal|"EV_TIMEOUT "
else|:
literal|" "
operator|,
name|ev
operator|->
name|ev_callback
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|ev
operator|->
name|ev_flags
operator|&
operator|~
name|EVLIST_ALL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tv
operator|!=
name|NULL
condition|)
block|{
name|struct
name|timeval
name|now
decl_stmt|;
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_TIMEOUT
condition|)
name|event_queue_remove
argument_list|(
name|base
argument_list|,
name|ev
argument_list|,
name|EVLIST_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* Check if it is active due to a timeout.  Rescheduling 		 * this timeout before the callback can be executed 		 * removes it from the active list. */
if|if
condition|(
operator|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_ACTIVE
operator|)
operator|&&
operator|(
name|ev
operator|->
name|ev_res
operator|&
name|EV_TIMEOUT
operator|)
condition|)
block|{
comment|/* See if we are just active executing this 			 * event in a loop 			 */
if|if
condition|(
name|ev
operator|->
name|ev_ncalls
operator|&&
name|ev
operator|->
name|ev_pncalls
condition|)
block|{
comment|/* Abort loop */
operator|*
name|ev
operator|->
name|ev_pncalls
operator|=
literal|0
expr_stmt|;
block|}
name|event_queue_remove
argument_list|(
name|base
argument_list|,
name|ev
argument_list|,
name|EVLIST_ACTIVE
argument_list|)
expr_stmt|;
block|}
name|gettime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|timeradd
argument_list|(
operator|&
name|now
argument_list|,
name|tv
argument_list|,
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|)
expr_stmt|;
name|event_debug
argument_list|(
operator|(
literal|"event_add: timeout in %d seconds, call %p"
operator|,
name|tv
operator|->
name|tv_sec
operator|,
name|ev
operator|->
name|ev_callback
operator|)
argument_list|)
expr_stmt|;
name|event_queue_insert
argument_list|(
name|base
argument_list|,
name|ev
argument_list|,
name|EVLIST_TIMEOUT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ev
operator|->
name|ev_events
operator|&
operator|(
name|EV_READ
operator||
name|EV_WRITE
operator|)
operator|)
operator|&&
operator|!
operator|(
name|ev
operator|->
name|ev_flags
operator|&
operator|(
name|EVLIST_INSERTED
operator||
name|EVLIST_ACTIVE
operator|)
operator|)
condition|)
block|{
name|event_queue_insert
argument_list|(
name|base
argument_list|,
name|ev
argument_list|,
name|EVLIST_INSERTED
argument_list|)
expr_stmt|;
return|return
operator|(
name|evsel
operator|->
name|add
argument_list|(
name|evbase
argument_list|,
name|ev
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ev
operator|->
name|ev_events
operator|&
name|EV_SIGNAL
operator|)
operator|&&
operator|!
operator|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_SIGNAL
operator|)
condition|)
block|{
name|event_queue_insert
argument_list|(
name|base
argument_list|,
name|ev
argument_list|,
name|EVLIST_SIGNAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|evsel
operator|->
name|add
argument_list|(
name|evbase
argument_list|,
name|ev
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|event_del
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|)
block|{
name|struct
name|event_base
modifier|*
name|base
decl_stmt|;
specifier|const
name|struct
name|eventop
modifier|*
name|evsel
decl_stmt|;
name|void
modifier|*
name|evbase
decl_stmt|;
name|event_debug
argument_list|(
operator|(
literal|"event_del: %p, callback %p"
operator|,
name|ev
operator|,
name|ev
operator|->
name|ev_callback
operator|)
argument_list|)
expr_stmt|;
comment|/* An event without a base has not been added */
if|if
condition|(
name|ev
operator|->
name|ev_base
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|base
operator|=
name|ev
operator|->
name|ev_base
expr_stmt|;
name|evsel
operator|=
name|base
operator|->
name|evsel
expr_stmt|;
name|evbase
operator|=
name|base
operator|->
name|evbase
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|ev
operator|->
name|ev_flags
operator|&
operator|~
name|EVLIST_ALL
operator|)
argument_list|)
expr_stmt|;
comment|/* See if we are just active executing this event in a loop */
if|if
condition|(
name|ev
operator|->
name|ev_ncalls
operator|&&
name|ev
operator|->
name|ev_pncalls
condition|)
block|{
comment|/* Abort loop */
operator|*
name|ev
operator|->
name|ev_pncalls
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_TIMEOUT
condition|)
name|event_queue_remove
argument_list|(
name|base
argument_list|,
name|ev
argument_list|,
name|EVLIST_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_ACTIVE
condition|)
name|event_queue_remove
argument_list|(
name|base
argument_list|,
name|ev
argument_list|,
name|EVLIST_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_INSERTED
condition|)
block|{
name|event_queue_remove
argument_list|(
name|base
argument_list|,
name|ev
argument_list|,
name|EVLIST_INSERTED
argument_list|)
expr_stmt|;
return|return
operator|(
name|evsel
operator|->
name|del
argument_list|(
name|evbase
argument_list|,
name|ev
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_SIGNAL
condition|)
block|{
name|event_queue_remove
argument_list|(
name|base
argument_list|,
name|ev
argument_list|,
name|EVLIST_SIGNAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|evsel
operator|->
name|del
argument_list|(
name|evbase
argument_list|,
name|ev
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|event_active
parameter_list|(
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|int
name|res
parameter_list|,
name|short
name|ncalls
parameter_list|)
block|{
comment|/* We get different kinds of events, add them together */
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_ACTIVE
condition|)
block|{
name|ev
operator|->
name|ev_res
operator||=
name|res
expr_stmt|;
return|return;
block|}
name|ev
operator|->
name|ev_res
operator|=
name|res
expr_stmt|;
name|ev
operator|->
name|ev_ncalls
operator|=
name|ncalls
expr_stmt|;
name|ev
operator|->
name|ev_pncalls
operator|=
name|NULL
expr_stmt|;
name|event_queue_insert
argument_list|(
name|ev
operator|->
name|ev_base
argument_list|,
name|ev
argument_list|,
name|EVLIST_ACTIVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|timeout_next
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv
parameter_list|)
block|{
name|struct
name|timeval
name|dflt
init|=
name|TIMEOUT_DEFAULT
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|struct
name|event
modifier|*
name|ev
decl_stmt|;
if|if
condition|(
operator|(
name|ev
operator|=
name|RB_MIN
argument_list|(
name|event_tree
argument_list|,
operator|&
name|base
operator|->
name|timetree
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|tv
operator|=
name|dflt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|gettime
argument_list|(
operator|&
name|now
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|,
operator|&
name|now
argument_list|,
operator|<=
argument_list|)
condition|)
block|{
name|timerclear
argument_list|(
name|tv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|timersub
argument_list|(
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|,
operator|&
name|now
argument_list|,
name|tv
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tv
operator|->
name|tv_sec
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tv
operator|->
name|tv_usec
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|event_debug
argument_list|(
operator|(
literal|"timeout_next: in %d seconds"
operator|,
name|tv
operator|->
name|tv_sec
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|timeout_correct
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|timeval
modifier|*
name|off
parameter_list|)
block|{
name|struct
name|event
modifier|*
name|ev
decl_stmt|;
comment|/* 	 * We can modify the key element of the node without destroying 	 * the key, beause we apply it to all in the right order. 	 */
name|RB_FOREACH
argument_list|(
argument|ev
argument_list|,
argument|event_tree
argument_list|,
argument|&base->timetree
argument_list|)
name|timersub
argument_list|(
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|,
name|off
argument_list|,
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|timeout_process
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|)
block|{
name|struct
name|timeval
name|now
decl_stmt|;
name|struct
name|event
modifier|*
name|ev
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|gettime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
for|for
control|(
name|ev
operator|=
name|RB_MIN
argument_list|(
name|event_tree
argument_list|,
operator|&
name|base
operator|->
name|timetree
argument_list|)
init|;
name|ev
condition|;
name|ev
operator|=
name|next
control|)
block|{
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|ev
operator|->
name|ev_timeout
argument_list|,
operator|&
name|now
argument_list|,
operator|>
argument_list|)
condition|)
break|break;
name|next
operator|=
name|RB_NEXT
argument_list|(
name|event_tree
argument_list|,
operator|&
name|base
operator|->
name|timetree
argument_list|,
name|ev
argument_list|)
expr_stmt|;
name|event_queue_remove
argument_list|(
name|base
argument_list|,
name|ev
argument_list|,
name|EVLIST_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* delete this event from the I/O queues */
name|event_del
argument_list|(
name|ev
argument_list|)
expr_stmt|;
name|event_debug
argument_list|(
operator|(
literal|"timeout_process: call %p"
operator|,
name|ev
operator|->
name|ev_callback
operator|)
argument_list|)
expr_stmt|;
name|event_active
argument_list|(
name|ev
argument_list|,
name|EV_TIMEOUT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|event_queue_remove
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|int
name|queue
parameter_list|)
block|{
name|int
name|docount
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ev
operator|->
name|ev_flags
operator|&
name|queue
operator|)
condition|)
name|event_errx
argument_list|(
literal|1
argument_list|,
literal|"%s: %p(fd %d) not on queue %x"
argument_list|,
name|__func__
argument_list|,
name|ev
argument_list|,
name|ev
operator|->
name|ev_fd
argument_list|,
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_INTERNAL
condition|)
name|docount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|docount
condition|)
name|base
operator|->
name|event_count
operator|--
expr_stmt|;
name|ev
operator|->
name|ev_flags
operator|&=
operator|~
name|queue
expr_stmt|;
switch|switch
condition|(
name|queue
condition|)
block|{
case|case
name|EVLIST_ACTIVE
case|:
if|if
condition|(
name|docount
condition|)
name|base
operator|->
name|event_count_active
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|base
operator|->
name|activequeues
index|[
name|ev
operator|->
name|ev_pri
index|]
argument_list|,
name|ev
argument_list|,
name|ev_active_next
argument_list|)
expr_stmt|;
break|break;
case|case
name|EVLIST_SIGNAL
case|:
name|TAILQ_REMOVE
argument_list|(
operator|&
name|signalqueue
argument_list|,
name|ev
argument_list|,
name|ev_signal_next
argument_list|)
expr_stmt|;
break|break;
case|case
name|EVLIST_TIMEOUT
case|:
name|RB_REMOVE
argument_list|(
name|event_tree
argument_list|,
operator|&
name|base
operator|->
name|timetree
argument_list|,
name|ev
argument_list|)
expr_stmt|;
break|break;
case|case
name|EVLIST_INSERTED
case|:
name|TAILQ_REMOVE
argument_list|(
operator|&
name|base
operator|->
name|eventqueue
argument_list|,
name|ev
argument_list|,
name|ev_next
argument_list|)
expr_stmt|;
break|break;
default|default:
name|event_errx
argument_list|(
literal|1
argument_list|,
literal|"%s: unknown queue %x"
argument_list|,
name|__func__
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|event_queue_insert
parameter_list|(
name|struct
name|event_base
modifier|*
name|base
parameter_list|,
name|struct
name|event
modifier|*
name|ev
parameter_list|,
name|int
name|queue
parameter_list|)
block|{
name|int
name|docount
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
name|queue
condition|)
block|{
comment|/* Double insertion is possible for active events */
if|if
condition|(
name|queue
operator|&
name|EVLIST_ACTIVE
condition|)
return|return;
name|event_errx
argument_list|(
literal|1
argument_list|,
literal|"%s: %p(fd %d) already on queue %x"
argument_list|,
name|__func__
argument_list|,
name|ev
argument_list|,
name|ev
operator|->
name|ev_fd
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ev
operator|->
name|ev_flags
operator|&
name|EVLIST_INTERNAL
condition|)
name|docount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|docount
condition|)
name|base
operator|->
name|event_count
operator|++
expr_stmt|;
name|ev
operator|->
name|ev_flags
operator||=
name|queue
expr_stmt|;
switch|switch
condition|(
name|queue
condition|)
block|{
case|case
name|EVLIST_ACTIVE
case|:
if|if
condition|(
name|docount
condition|)
name|base
operator|->
name|event_count_active
operator|++
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|base
operator|->
name|activequeues
index|[
name|ev
operator|->
name|ev_pri
index|]
argument_list|,
name|ev
argument_list|,
name|ev_active_next
argument_list|)
expr_stmt|;
break|break;
case|case
name|EVLIST_SIGNAL
case|:
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|signalqueue
argument_list|,
name|ev
argument_list|,
name|ev_signal_next
argument_list|)
expr_stmt|;
break|break;
case|case
name|EVLIST_TIMEOUT
case|:
block|{
name|struct
name|event
modifier|*
name|tmp
init|=
name|RB_INSERT
argument_list|(
name|event_tree
argument_list|,
operator|&
name|base
operator|->
name|timetree
argument_list|,
name|ev
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|tmp
operator|==
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|EVLIST_INSERTED
case|:
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|base
operator|->
name|eventqueue
argument_list|,
name|ev
argument_list|,
name|ev_next
argument_list|)
expr_stmt|;
break|break;
default|default:
name|event_errx
argument_list|(
literal|1
argument_list|,
literal|"%s: unknown queue %x"
argument_list|,
name|__func__
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Functions for debugging */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|event_get_version
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|VERSION
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * No thread-safe interface needed - the information should be the same  * for all threads.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|event_get_method
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|current_base
operator|->
name|evsel
operator|->
name|name
operator|)
return|;
block|}
end_function

end_unit

