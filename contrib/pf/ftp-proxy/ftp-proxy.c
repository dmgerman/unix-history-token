begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: ftp-proxy.c,v 1.33 2003/08/22 21:50:34 david Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 1996-2001  *	Obtuse Systems Corporation.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the Obtuse Systems nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY OBTUSE SYSTEMS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL OBTUSE SYSTEMS CORPORATION OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  */
end_comment

begin_comment
comment|/*  * ftp proxy, Originally based on juniper_ftp_proxy from the Obtuse  * Systems juniper firewall, written by Dan Boulet<danny@obtuse.com>  * and Bob Beck<beck@obtuse.com>  *  * This version basically passes everything through unchanged except  * for the PORT and the * "227 Entering Passive Mode" reply.  *  * A PORT command is handled by noting the IP address and port number  * specified and then configuring a listen port on some very high port  * number and telling the server about it using a PORT message.  * We then watch for an in-bound connection on the port from the server  * and connect to the client's port when it happens.  *  * A "227 Entering Passive Mode" reply is handled by noting the IP address  * and port number specified and then configuring a listen port on some  * very high port number and telling the client about it using a  * "227 Entering Passive Mode" reply.  * We then watch for an in-bound connection on the port from the client  * and connect to the server's port when it happens.  *  * supports tcp wrapper lookups/access control with the -w flag using  * the real destination address - the tcp wrapper stuff is done after  * the real destination address is retrieved from pf  *  */
end_comment

begin_comment
comment|/*  * TODO:  * Plenty, this is very basic, with the idea to get it in clean first.  *  * - IPv6 and EPASV support  * - Content filter support  * - filename filter support  * - per-user rules perhaps.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|LIBWRAP
end_ifdef

begin_include
include|#
directive|include
file|<tcpd.h>
end_include

begin_decl_stmt
name|int
name|allow_severity
init|=
name|LOG_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|deny_severity
init|=
name|LOG_NOTICE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBWRAP */
end_comment

begin_decl_stmt
name|int
name|min_port
init|=
name|IPPORT_HIFIRSTAUTO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|max_port
init|=
name|IPPORT_HILASTAUTO
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|STARTBUFSIZE
value|1024
end_define

begin_comment
comment|/* Must be at least 3 */
end_comment

begin_comment
comment|/*  * Variables used to support PORT mode connections.  *  * This gets a bit complicated.  *  * If PORT mode is on then client_listen_sa describes the socket that  * the real client is listening on and server_listen_sa describes the  * socket that we are listening on (waiting for the real server to connect  * with us).  *  * If PASV mode is on then client_listen_sa describes the socket that  * we are listening on (waiting for the real client to connect to us on)  * and server_listen_sa describes the socket that the real server is  * listening on.  *  * If the socket we are listening on gets a connection then we connect  * to the other side's socket.  Similarly, if a connected socket is  * shutdown then we shutdown the other side's socket.  */
end_comment

begin_decl_stmt
name|double
name|xfer_start_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
name|real_server_sa
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
name|client_listen_sa
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
name|server_listen_sa
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|client_listen_socket
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Only used in PASV mode */
end_comment

begin_decl_stmt
name|int
name|client_data_socket
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Connected socket to real client */
end_comment

begin_decl_stmt
name|int
name|server_listen_socket
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Only used in PORT mode */
end_comment

begin_decl_stmt
name|int
name|server_data_socket
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Connected socket to real server */
end_comment

begin_decl_stmt
name|int
name|client_data_bytes
decl_stmt|,
name|server_data_bytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|AnonFtpOnly
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|NatMode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ClientName
index|[
name|NI_MAXHOST
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|RealServerName
index|[
name|NI_MAXHOST
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|OurName
index|[
name|NI_MAXHOST
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|User
init|=
literal|"proxy"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Group
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|Debug_Level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|Use_Rdns
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|__progname
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
enum|enum
block|{
name|UNKNOWN_MODE
block|,
name|PORT_MODE
block|,
name|PASV_MODE
block|,
name|EPRT_MODE
block|,
name|EPSV_MODE
block|}
name|connection_mode_t
typedef|;
end_typedef

begin_decl_stmt
name|connection_mode_t
name|connection_mode
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|debuglog
parameter_list|(
name|int
name|debug_level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|double
name|wallclock_time
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|show_xfer_stats
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|log_control_command
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|client
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|new_dataconn
parameter_list|(
name|int
name|server
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|do_client_cmd
parameter_list|(
name|struct
name|csiob
modifier|*
name|client
parameter_list|,
name|struct
name|csiob
modifier|*
name|server
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|do_server_reply
parameter_list|(
name|struct
name|csiob
modifier|*
name|server
parameter_list|,
name|struct
name|csiob
modifier|*
name|client
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"usage: %s [-AnrVw] [-D debuglevel] [-g group] %s %s"
argument_list|,
name|__progname
argument_list|,
literal|"[-m minport] [-M maxport] [-t timeout]"
argument_list|,
literal|"[-u user]"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|close_client_data
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|client_data_socket
operator|>=
literal|0
condition|)
block|{
name|shutdown
argument_list|(
name|client_data_socket
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|client_data_socket
argument_list|)
expr_stmt|;
name|client_data_socket
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|close_server_data
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|server_data_socket
operator|>=
literal|0
condition|)
block|{
name|shutdown
argument_list|(
name|server_data_socket
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|server_data_socket
argument_list|)
expr_stmt|;
name|server_data_socket
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|drop_privs
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|struct
name|group
modifier|*
name|gr
decl_stmt|;
name|uid_t
name|uid
init|=
literal|0
decl_stmt|;
name|gid_t
name|gid
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|User
operator|!=
name|NULL
condition|)
block|{
name|pw
operator|=
name|getpwnam
argument_list|(
name|User
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot find user %s"
argument_list|,
name|User
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
name|uid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
name|gid
operator|=
name|pw
operator|->
name|pw_gid
expr_stmt|;
block|}
if|if
condition|(
name|Group
operator|!=
name|NULL
condition|)
block|{
name|gr
operator|=
name|getgrnam
argument_list|(
name|Group
argument_list|)
expr_stmt|;
if|if
condition|(
name|gr
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot find group %s"
argument_list|,
name|Group
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
name|gid
operator|=
name|gr
operator|->
name|gr_gid
expr_stmt|;
block|}
if|if
condition|(
name|gid
operator|!=
literal|0
operator|&&
operator|(
name|setegid
argument_list|(
name|gid
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|setgid
argument_list|(
name|gid
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot drop group privs (%m)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_CONFIG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uid
operator|!=
literal|0
operator|&&
operator|(
name|seteuid
argument_list|(
name|uid
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|setuid
argument_list|(
name|uid
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot drop root privs (%m)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_CONFIG
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LIBWRAP
end_ifdef

begin_comment
comment|/*  * Check a connection against the tcpwrapper, log if we're going to  * reject it, returns: 0 -> reject, 1 -> accept. We add in hostnames  * if we are set to do reverse DNS, otherwise no.  */
end_comment

begin_function
specifier|static
name|int
name|check_host
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|client_sin
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|server_sin
parameter_list|)
block|{
name|char
name|cname
index|[
name|NI_MAXHOST
index|]
decl_stmt|;
name|char
name|sname
index|[
name|NI_MAXHOST
index|]
decl_stmt|;
name|struct
name|request_info
name|request
decl_stmt|;
name|int
name|i
decl_stmt|;
name|request_init
argument_list|(
operator|&
name|request
argument_list|,
name|RQ_DAEMON
argument_list|,
name|__progname
argument_list|,
name|RQ_CLIENT_SIN
argument_list|,
name|client_sin
argument_list|,
name|RQ_SERVER_SIN
argument_list|,
name|server_sin
argument_list|,
name|RQ_CLIENT_ADDR
argument_list|,
name|inet_ntoa
argument_list|(
name|client_sin
operator|->
name|sin_addr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|Use_Rdns
condition|)
block|{
comment|/* 		 * We already looked these up, but we have to do it again 		 * for tcp wrapper, to ensure that we get the DNS name, since 		 * the tcp wrapper cares about these things, and we don't 		 * want to pass in a printed address as a name. 		 */
name|i
operator|=
name|getnameinfo
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|client_sin
operator|->
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
operator|&
name|client_sin
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|cname
argument_list|,
sizeof|sizeof
argument_list|(
name|cname
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NI_NAMEREQD
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
name|i
operator|!=
name|EAI_NONAME
operator|&&
name|i
operator|!=
name|EAI_AGAIN
condition|)
name|strlcpy
argument_list|(
name|cname
argument_list|,
name|STRING_UNKNOWN
argument_list|,
sizeof|sizeof
argument_list|(
name|cname
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|getnameinfo
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|server_sin
operator|->
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
operator|&
name|server_sin
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|sname
argument_list|,
sizeof|sizeof
argument_list|(
name|sname
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NI_NAMEREQD
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
name|i
operator|!=
name|EAI_NONAME
operator|&&
name|i
operator|!=
name|EAI_AGAIN
condition|)
name|strlcpy
argument_list|(
name|sname
argument_list|,
name|STRING_UNKNOWN
argument_list|,
sizeof|sizeof
argument_list|(
name|sname
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * ensure the TCP wrapper doesn't start doing 		 * reverse DNS lookups if we aren't supposed to. 		 */
name|strlcpy
argument_list|(
name|cname
argument_list|,
name|STRING_UNKNOWN
argument_list|,
sizeof|sizeof
argument_list|(
name|cname
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|sname
argument_list|,
name|STRING_UNKNOWN
argument_list|,
sizeof|sizeof
argument_list|(
name|sname
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|request_set
argument_list|(
operator|&
name|request
argument_list|,
name|RQ_SERVER_ADDR
argument_list|,
name|inet_ntoa
argument_list|(
name|server_sin
operator|->
name|sin_addr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|request_set
argument_list|(
operator|&
name|request
argument_list|,
name|RQ_CLIENT_NAME
argument_list|,
name|cname
argument_list|,
name|RQ_SERVER_NAME
argument_list|,
name|sname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hosts_access
argument_list|(
operator|&
name|request
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"tcpwrappers rejected: %s -> %s"
argument_list|,
name|ClientName
argument_list|,
name|RealServerName
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBWRAP */
end_comment

begin_function
name|double
name|wallclock_time
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|tv
operator|.
name|tv_sec
operator|+
name|tv
operator|.
name|tv_usec
operator|/
literal|1e6
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Show the stats for this data transfer  */
end_comment

begin_function
name|void
name|show_xfer_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|tbuf
index|[
literal|1000
index|]
decl_stmt|;
name|double
name|delta
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|Verbose
condition|)
return|return;
name|delta
operator|=
name|wallclock_time
argument_list|()
operator|-
name|xfer_start_time
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0.001
condition|)
name|delta
operator|=
literal|0.001
expr_stmt|;
if|if
condition|(
name|client_data_bytes
operator|==
literal|0
operator|&&
name|server_data_bytes
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"data transfer complete (no bytes transferred)"
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|>=
literal|60
condition|)
block|{
name|int
name|idelta
decl_stmt|;
name|idelta
operator|=
name|delta
operator|+
literal|0.5
expr_stmt|;
if|if
condition|(
name|idelta
operator|>=
literal|60
operator|*
literal|60
condition|)
block|{
name|i
operator|=
name|snprintf
argument_list|(
name|tbuf
argument_list|,
name|len
argument_list|,
literal|"data transfer complete (%dh %dm %ds"
argument_list|,
name|idelta
operator|/
operator|(
literal|60
operator|*
literal|60
operator|)
argument_list|,
operator|(
name|idelta
operator|%
operator|(
literal|60
operator|*
literal|60
operator|)
operator|)
operator|/
literal|60
argument_list|,
name|idelta
operator|%
literal|60
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|len
condition|)
goto|goto
name|logit
goto|;
name|len
operator|-=
name|i
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|snprintf
argument_list|(
name|tbuf
argument_list|,
name|len
argument_list|,
literal|"data transfer complete (%dm %ds"
argument_list|,
name|idelta
operator|/
literal|60
argument_list|,
name|idelta
operator|%
literal|60
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|len
condition|)
goto|goto
name|logit
goto|;
name|len
operator|-=
name|i
expr_stmt|;
block|}
block|}
else|else
block|{
name|i
operator|=
name|snprintf
argument_list|(
name|tbuf
argument_list|,
name|len
argument_list|,
literal|"data transfer complete (%.1fs"
argument_list|,
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|len
condition|)
goto|goto
name|logit
goto|;
name|len
operator|-=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|client_data_bytes
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|snprintf
argument_list|(
operator|&
name|tbuf
index|[
name|strlen
argument_list|(
name|tbuf
argument_list|)
index|]
argument_list|,
name|len
argument_list|,
literal|", %d bytes to server) (%.1fKB/s"
argument_list|,
name|client_data_bytes
argument_list|,
operator|(
name|client_data_bytes
operator|/
name|delta
operator|)
operator|/
operator|(
name|double
operator|)
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|len
condition|)
goto|goto
name|logit
goto|;
name|len
operator|-=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|server_data_bytes
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|snprintf
argument_list|(
operator|&
name|tbuf
index|[
name|strlen
argument_list|(
name|tbuf
argument_list|)
index|]
argument_list|,
name|len
argument_list|,
literal|", %d bytes to client) (%.1fKB/s"
argument_list|,
name|server_data_bytes
argument_list|,
operator|(
name|server_data_bytes
operator|/
name|delta
operator|)
operator|/
operator|(
name|double
operator|)
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|len
condition|)
goto|goto
name|logit
goto|;
name|len
operator|-=
name|i
expr_stmt|;
block|}
name|strlcat
argument_list|(
name|tbuf
argument_list|,
literal|")"
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|)
expr_stmt|;
name|logit
label|:
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|log_control_command
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|client
parameter_list|)
block|{
comment|/* log an ftp control command or reply */
name|char
modifier|*
name|logstring
decl_stmt|;
name|int
name|level
init|=
name|LOG_DEBUG
decl_stmt|;
if|if
condition|(
operator|!
name|Verbose
condition|)
return|return;
comment|/* don't log passwords */
if|if
condition|(
name|strncasecmp
argument_list|(
name|cmd
argument_list|,
literal|"pass "
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|logstring
operator|=
literal|"PASS XXXX"
expr_stmt|;
else|else
name|logstring
operator|=
name|cmd
expr_stmt|;
if|if
condition|(
name|client
condition|)
block|{
comment|/* log interesting stuff at LOG_INFO, rest at LOG_DEBUG */
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|cmd
argument_list|,
literal|"user "
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncasecmp
argument_list|(
name|cmd
argument_list|,
literal|"retr "
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncasecmp
argument_list|(
name|cmd
argument_list|,
literal|"cwd "
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncasecmp
argument_list|(
name|cmd
argument_list|,
literal|"stor "
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|level
operator|=
name|LOG_INFO
expr_stmt|;
block|}
name|syslog
argument_list|(
name|level
argument_list|,
literal|"%s %s"
argument_list|,
name|client
condition|?
literal|"client:"
else|:
literal|" server:"
argument_list|,
name|logstring
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * set ourselves up for a new data connection. Direction is toward client if  * "server" is 0, towards server otherwise.  */
end_comment

begin_function
name|int
name|new_dataconn
parameter_list|(
name|int
name|server
parameter_list|)
block|{
comment|/* 	 * Close existing data conn. 	 */
if|if
condition|(
name|client_listen_socket
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|client_listen_socket
argument_list|)
expr_stmt|;
name|client_listen_socket
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|close_client_data
argument_list|()
expr_stmt|;
if|if
condition|(
name|server_listen_socket
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|server_listen_socket
argument_list|)
expr_stmt|;
name|server_listen_socket
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|close_server_data
argument_list|()
expr_stmt|;
if|if
condition|(
name|server
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|server_listen_sa
argument_list|,
sizeof|sizeof
argument_list|(
name|server_listen_sa
argument_list|)
argument_list|)
expr_stmt|;
name|server_listen_socket
operator|=
name|get_backchannel_socket
argument_list|(
name|SOCK_STREAM
argument_list|,
name|min_port
argument_list|,
name|max_port
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
operator|&
name|server_listen_sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_listen_socket
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"server socket bind() failed (%m)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|listen
argument_list|(
name|server_listen_socket
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"server socket listen() failed (%m)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|bzero
argument_list|(
operator|&
name|client_listen_sa
argument_list|,
sizeof|sizeof
argument_list|(
name|client_listen_sa
argument_list|)
argument_list|)
expr_stmt|;
name|client_listen_socket
operator|=
name|get_backchannel_socket
argument_list|(
name|SOCK_STREAM
argument_list|,
name|min_port
argument_list|,
name|max_port
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
operator|&
name|client_listen_sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|client_listen_socket
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"cannot get client listen socket (%m)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|listen
argument_list|(
name|client_listen_socket
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"cannot listen on client socket (%m)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|connect_pasv_backchannel
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|listen_sa
decl_stmt|;
name|socklen_t
name|salen
decl_stmt|;
comment|/* 	 * We are about to accept a connection from the client. 	 * This is a PASV data connection. 	 */
name|debuglog
argument_list|(
literal|2
argument_list|,
literal|"client listen socket ready"
argument_list|)
expr_stmt|;
name|close_server_data
argument_list|()
expr_stmt|;
name|close_client_data
argument_list|()
expr_stmt|;
name|salen
operator|=
sizeof|sizeof
argument_list|(
name|listen_sa
argument_list|)
expr_stmt|;
name|client_data_socket
operator|=
name|accept
argument_list|(
name|client_listen_socket
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|listen_sa
argument_list|,
operator|&
name|salen
argument_list|)
expr_stmt|;
if|if
condition|(
name|client_data_socket
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"accept() failed (%m)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|client_listen_socket
argument_list|)
expr_stmt|;
name|client_listen_socket
operator|=
operator|-
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|listen_sa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|listen_sa
argument_list|)
argument_list|)
expr_stmt|;
name|server_data_socket
operator|=
name|get_backchannel_socket
argument_list|(
name|SOCK_STREAM
argument_list|,
name|min_port
argument_list|,
name|max_port
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
operator|&
name|listen_sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_data_socket
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"get_backchannel_socket() failed (%m)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|connect
argument_list|(
name|server_data_socket
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|server_listen_sa
argument_list|,
sizeof|sizeof
argument_list|(
name|server_listen_sa
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"connect() failed (%m)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_NOHOST
argument_list|)
expr_stmt|;
block|}
name|client_data_bytes
operator|=
literal|0
expr_stmt|;
name|server_data_bytes
operator|=
literal|0
expr_stmt|;
name|xfer_start_time
operator|=
name|wallclock_time
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|connect_port_backchannel
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|listen_sa
decl_stmt|;
name|socklen_t
name|salen
decl_stmt|;
comment|/* 	 * We are about to accept a connection from the server. 	 * This is a PORT or EPRT data connection. 	 */
name|debuglog
argument_list|(
literal|2
argument_list|,
literal|"server listen socket ready"
argument_list|)
expr_stmt|;
name|close_server_data
argument_list|()
expr_stmt|;
name|close_client_data
argument_list|()
expr_stmt|;
name|salen
operator|=
sizeof|sizeof
argument_list|(
name|listen_sa
argument_list|)
expr_stmt|;
name|server_data_socket
operator|=
name|accept
argument_list|(
name|server_listen_socket
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|listen_sa
argument_list|,
operator|&
name|salen
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_data_socket
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"accept() failed (%m)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|server_listen_socket
argument_list|)
expr_stmt|;
name|server_listen_socket
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|getuid
argument_list|()
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * We're not running as root, so we get a backchannel 		 * socket bound in our designated range, instead of 		 * getting one bound to port 20 - This is deliberately 		 * not RFC compliant. 		 */
name|bzero
argument_list|(
operator|&
name|listen_sa
operator|.
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|client_data_socket
operator|=
name|get_backchannel_socket
argument_list|(
name|SOCK_STREAM
argument_list|,
name|min_port
argument_list|,
name|max_port
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
operator|&
name|listen_sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|client_data_socket
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"get_backchannel_socket() failed (%m)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * We're root, get our backchannel socket bound to port 		 * 20 here, so we're fully RFC compliant. 		 */
name|client_data_socket
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|salen
operator|=
literal|1
expr_stmt|;
name|listen_sa
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|listen_sa
operator|.
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|listen_sa
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|client_data_socket
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|&
name|salen
argument_list|,
sizeof|sizeof
argument_list|(
name|salen
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"setsockopt() failed (%m)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bind
argument_list|(
name|client_data_socket
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|listen_sa
argument_list|,
sizeof|sizeof
argument_list|(
name|listen_sa
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"data channel bind() failed (%m)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|connect
argument_list|(
name|client_data_socket
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|client_listen_sa
argument_list|,
sizeof|sizeof
argument_list|(
name|client_listen_sa
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"cannot connect data channel (%m)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_NOHOST
argument_list|)
expr_stmt|;
block|}
name|client_data_bytes
operator|=
literal|0
expr_stmt|;
name|server_data_bytes
operator|=
literal|0
expr_stmt|;
name|xfer_start_time
operator|=
name|wallclock_time
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|do_client_cmd
parameter_list|(
name|struct
name|csiob
modifier|*
name|client
parameter_list|,
name|struct
name|csiob
modifier|*
name|server
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|rv
decl_stmt|;
name|char
name|tbuf
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|sendbuf
init|=
name|NULL
decl_stmt|;
name|log_control_command
argument_list|(
operator|(
name|char
operator|*
operator|)
name|client
operator|->
name|line_buffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* client->line_buffer is an ftp control command. 	 * There is no reason for these to be very long. 	 * In the interest of limiting buffer overrun attempts, 	 * we catch them here. 	 */
if|if
condition|(
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|client
operator|->
name|line_buffer
argument_list|)
operator|>
literal|512
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"excessively long control command"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_DATAERR
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check the client user provided if needed 	 */
if|if
condition|(
name|AnonFtpOnly
operator|&&
name|strncasecmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|client
operator|->
name|line_buffer
argument_list|,
literal|"user "
argument_list|,
name|strlen
argument_list|(
literal|"user "
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|client
operator|->
name|line_buffer
operator|+
name|strlen
argument_list|(
literal|"user "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|strcasecmp
argument_list|(
name|cp
argument_list|,
literal|"ftp\r\n"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcasecmp
argument_list|(
name|cp
argument_list|,
literal|"anonymous\r\n"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 			 * this isn't anonymous - give the client an 			 * error before they send a password 			 */
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"500 Only anonymous FTP is allowed\r\n"
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
do|do
block|{
name|rv
operator|=
name|send
argument_list|(
name|client
operator|->
name|fd
argument_list|,
name|tbuf
operator|+
name|j
argument_list|,
name|i
operator|-
name|j
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EAGAIN
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
break|break;
elseif|else
if|if
condition|(
name|rv
operator|!=
operator|-
literal|1
condition|)
name|j
operator|+=
name|rv
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|>=
literal|0
operator|&&
name|j
operator|<
name|i
condition|)
do|;
name|sendbuf
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|sendbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|client
operator|->
name|line_buffer
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|client
operator|->
name|line_buffer
argument_list|,
literal|"eprt "
argument_list|,
name|strlen
argument_list|(
literal|"eprt "
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Watch out for EPRT commands */
name|char
modifier|*
name|line
init|=
name|NULL
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|result
index|[
literal|3
index|]
decl_stmt|,
name|delim
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|proto
decl_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|line
operator|=
name|strdup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|client
operator|->
name|line_buffer
operator|+
name|strlen
argument_list|(
literal|"eprt "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"insufficient memory"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|line
expr_stmt|;
name|delim
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|memset
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
name|delim
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|||
operator|*
name|q
operator|!=
name|delim
condition|)
goto|goto
name|parsefail
goto|;
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|result
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
name|proto
operator|=
name|strtoul
argument_list|(
name|result
index|[
literal|0
index|]
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|result
index|[
literal|0
index|]
operator|||
operator|*
name|p
condition|)
goto|goto
name|protounsupp
goto|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
operator|!=
literal|1
condition|)
comment|/* 1 == AF_INET - all we support for now */
goto|goto
name|protounsupp
goto|;
name|hints
operator|.
name|ai_family
operator|=
name|AF_INET
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|AI_NUMERICHOST
expr_stmt|;
comment|/*no DNS*/
if|if
condition|(
name|getaddrinfo
argument_list|(
name|result
index|[
literal|1
index|]
argument_list|,
name|result
index|[
literal|2
index|]
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|res
argument_list|)
condition|)
goto|goto
name|parsefail
goto|;
if|if
condition|(
name|res
operator|->
name|ai_next
condition|)
goto|goto
name|parsefail
goto|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|client_listen_sa
argument_list|)
operator|<
name|res
operator|->
name|ai_addrlen
condition|)
goto|goto
name|parsefail
goto|;
name|memcpy
argument_list|(
operator|&
name|client_listen_sa
argument_list|,
name|res
operator|->
name|ai_addr
argument_list|,
name|res
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|1
argument_list|,
literal|"client wants us to use %s:%u"
argument_list|,
name|inet_ntoa
argument_list|(
name|client_listen_sa
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|htons
argument_list|(
name|client_listen_sa
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Configure our own listen socket and tell the server about it 		 */
name|new_dataconn
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|connection_mode
operator|=
name|EPRT_MODE
expr_stmt|;
name|debuglog
argument_list|(
literal|1
argument_list|,
literal|"we want server to use %s:%u"
argument_list|,
name|inet_ntoa
argument_list|(
name|server
operator|->
name|sa
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|server_listen_sa
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"EPRT |%d|%s|%u|\r\n"
argument_list|,
literal|1
argument_list|,
name|inet_ntoa
argument_list|(
name|server
operator|->
name|sa
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|server_listen_sa
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|1
argument_list|,
literal|"to server (modified): %s"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
name|sendbuf
operator|=
name|tbuf
expr_stmt|;
goto|goto
name|out
goto|;
name|parsefail
label|:
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"500 Invalid argument; rejected\r\n"
argument_list|)
expr_stmt|;
name|sendbuf
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
name|protounsupp
label|:
comment|/* we only support AF_INET for now */
if|if
condition|(
name|proto
operator|==
literal|2
condition|)
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"522 Protocol not supported, use (1)\r\n"
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"501 Protocol not supported\r\n"
argument_list|)
expr_stmt|;
name|sendbuf
operator|=
name|NULL
expr_stmt|;
name|out
label|:
if|if
condition|(
name|line
condition|)
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
name|freeaddrinfo
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendbuf
operator|==
name|NULL
condition|)
block|{
name|debuglog
argument_list|(
literal|1
argument_list|,
literal|"to client (modified): %s"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
do|do
block|{
name|rv
operator|=
name|send
argument_list|(
name|client
operator|->
name|fd
argument_list|,
name|tbuf
operator|+
name|j
argument_list|,
name|i
operator|-
name|j
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EAGAIN
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
break|break;
elseif|else
if|if
condition|(
name|rv
operator|!=
operator|-
literal|1
condition|)
name|j
operator|+=
name|rv
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|>=
literal|0
operator|&&
name|j
operator|<
name|i
condition|)
do|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|NatMode
operator|&&
operator|(
name|strncasecmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|client
operator|->
name|line_buffer
argument_list|,
literal|"epsv"
argument_list|,
name|strlen
argument_list|(
literal|"epsv"
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * If we aren't in NAT mode, deal with EPSV. 		 * EPSV is a problem - Unlike PASV, the reply from the 		 * server contains *only* a port, we can't modify the reply 		 * to the client and get the client to connect to us without 		 * resorting to using a dynamic rdr rule we have to add in 		 * for the reply to this connection, and take away afterwards. 		 * so this will wait until we have the right solution for rule 		 * additions/deletions in pf. 		 * 		 * in the meantime we just tell the client we don't do it, 		 * and most clients should fall back to using PASV. 		 */
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"500 EPSV command not understood\r\n"
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|1
argument_list|,
literal|"to client (modified): %s"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|tbuf
argument_list|)
expr_stmt|;
do|do
block|{
name|rv
operator|=
name|send
argument_list|(
name|client
operator|->
name|fd
argument_list|,
name|tbuf
operator|+
name|j
argument_list|,
name|i
operator|-
name|j
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EAGAIN
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
break|break;
elseif|else
if|if
condition|(
name|rv
operator|!=
operator|-
literal|1
condition|)
name|j
operator|+=
name|rv
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|>=
literal|0
operator|&&
name|j
operator|<
name|i
condition|)
do|;
name|sendbuf
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|client
operator|->
name|line_buffer
argument_list|,
literal|"port "
argument_list|,
name|strlen
argument_list|(
literal|"port "
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|int
name|values
index|[
literal|6
index|]
decl_stmt|;
name|char
modifier|*
name|tailptr
decl_stmt|;
name|debuglog
argument_list|(
literal|1
argument_list|,
literal|"Got a PORT command"
argument_list|)
expr_stmt|;
name|tailptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|client
operator|->
name|line_buffer
index|[
name|strlen
argument_list|(
literal|"port "
argument_list|)
index|]
expr_stmt|;
name|values
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|sscanf
argument_list|(
name|tailptr
argument_list|,
literal|"%u,%u,%u,%u,%u,%u"
argument_list|,
operator|&
name|values
index|[
literal|0
index|]
argument_list|,
operator|&
name|values
index|[
literal|1
index|]
argument_list|,
operator|&
name|values
index|[
literal|2
index|]
argument_list|,
operator|&
name|values
index|[
literal|3
index|]
argument_list|,
operator|&
name|values
index|[
literal|4
index|]
argument_list|,
operator|&
name|values
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|6
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"malformed PORT command (%s)"
argument_list|,
name|client
operator|->
name|line_buffer
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_DATAERR
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|values
index|[
name|i
index|]
operator|>
literal|255
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"malformed PORT command (%s)"
argument_list|,
name|client
operator|->
name|line_buffer
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_DATAERR
argument_list|)
expr_stmt|;
block|}
block|}
name|client_listen_sa
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|client_listen_sa
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
operator|(
name|values
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|values
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|values
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|values
index|[
literal|3
index|]
operator|<<
literal|0
operator|)
argument_list|)
expr_stmt|;
name|client_listen_sa
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
operator|(
name|values
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
name|values
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|1
argument_list|,
literal|"client wants us to use %u.%u.%u.%u:%u"
argument_list|,
name|values
index|[
literal|0
index|]
argument_list|,
name|values
index|[
literal|1
index|]
argument_list|,
name|values
index|[
literal|2
index|]
argument_list|,
name|values
index|[
literal|3
index|]
argument_list|,
operator|(
name|values
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
name|values
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
comment|/* 		 * Configure our own listen socket and tell the server about it 		 */
name|new_dataconn
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|connection_mode
operator|=
name|PORT_MODE
expr_stmt|;
name|debuglog
argument_list|(
literal|1
argument_list|,
literal|"we want server to use %s:%u"
argument_list|,
name|inet_ntoa
argument_list|(
name|server
operator|->
name|sa
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|server_listen_sa
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"PORT %u,%u,%u,%u,%u,%u\r\n"
argument_list|,
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|server
operator|->
name|sa
operator|.
name|sin_addr
operator|.
name|s_addr
operator|)
index|[
literal|0
index|]
argument_list|,
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|server
operator|->
name|sa
operator|.
name|sin_addr
operator|.
name|s_addr
operator|)
index|[
literal|1
index|]
argument_list|,
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|server
operator|->
name|sa
operator|.
name|sin_addr
operator|.
name|s_addr
operator|)
index|[
literal|2
index|]
argument_list|,
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|server
operator|->
name|sa
operator|.
name|sin_addr
operator|.
name|s_addr
operator|)
index|[
literal|3
index|]
argument_list|,
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|server_listen_sa
operator|.
name|sin_port
operator|)
index|[
literal|0
index|]
argument_list|,
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|server_listen_sa
operator|.
name|sin_port
operator|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|1
argument_list|,
literal|"to server (modified): %s"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
name|sendbuf
operator|=
name|tbuf
expr_stmt|;
block|}
else|else
name|sendbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|client
operator|->
name|line_buffer
expr_stmt|;
comment|/* 	 *send our (possibly modified) control command in sendbuf 	 * on it's way to the server 	 */
if|if
condition|(
name|sendbuf
operator|!=
name|NULL
condition|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|sendbuf
argument_list|)
expr_stmt|;
do|do
block|{
name|rv
operator|=
name|send
argument_list|(
name|server
operator|->
name|fd
argument_list|,
name|sendbuf
operator|+
name|j
argument_list|,
name|i
operator|-
name|j
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EAGAIN
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
break|break;
elseif|else
if|if
condition|(
name|rv
operator|!=
operator|-
literal|1
condition|)
name|j
operator|+=
name|rv
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|>=
literal|0
operator|&&
name|j
operator|<
name|i
condition|)
do|;
block|}
block|}
end_function

begin_function
name|void
name|do_server_reply
parameter_list|(
name|struct
name|csiob
modifier|*
name|server
parameter_list|,
name|struct
name|csiob
modifier|*
name|client
parameter_list|)
block|{
name|int
name|code
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|rv
decl_stmt|;
name|struct
name|in_addr
modifier|*
name|iap
decl_stmt|;
specifier|static
name|int
name|continuing
init|=
literal|0
decl_stmt|;
name|char
name|tbuf
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|sendbuf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|log_control_command
argument_list|(
operator|(
name|char
operator|*
operator|)
name|server
operator|->
name|line_buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|server
operator|->
name|line_buffer
argument_list|)
operator|>
literal|512
condition|)
block|{
comment|/* 		 * someone's playing games. Have a cow in the syslogs and 		 * exit - we don't pass this on for fear of hurting 		 * our other end, which might be poorly implemented. 		 */
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"long FTP control reply"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_DATAERR
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Watch out for "227 Entering Passive Mode ..." replies 	 */
name|code
operator|=
name|strtol
argument_list|(
operator|(
name|char
operator|*
operator|)
name|server
operator|->
name|line_buffer
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|server
operator|->
name|line_buffer
index|[
literal|0
index|]
argument_list|)
condition|)
name|code
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|*
operator|(
name|server
operator|->
name|line_buffer
operator|)
operator|||
operator|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'-'
operator|)
condition|)
block|{
if|if
condition|(
name|continuing
condition|)
goto|goto
name|sendit
goto|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"malformed control reply"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_DATAERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|<=
literal|0
operator|||
name|code
operator|>
literal|999
condition|)
block|{
if|if
condition|(
name|continuing
condition|)
goto|goto
name|sendit
goto|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"invalid server reply code %d"
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_DATAERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
name|continuing
operator|=
literal|1
expr_stmt|;
else|else
name|continuing
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|227
operator|&&
operator|!
name|NatMode
condition|)
block|{
name|unsigned
name|int
name|values
index|[
literal|6
index|]
decl_stmt|;
name|char
modifier|*
name|tailptr
decl_stmt|;
name|debuglog
argument_list|(
literal|1
argument_list|,
literal|"Got a PASV reply"
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|1
argument_list|,
literal|"{%s}"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|server
operator|->
name|line_buffer
argument_list|)
expr_stmt|;
name|tailptr
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|server
operator|->
name|line_buffer
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|tailptr
operator|==
name|NULL
condition|)
block|{
name|tailptr
operator|=
name|strrchr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|server
operator|->
name|line_buffer
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|tailptr
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"malformed 227 reply"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_DATAERR
argument_list|)
expr_stmt|;
block|}
block|}
name|tailptr
operator|++
expr_stmt|;
comment|/* skip past space or ( */
name|values
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|sscanf
argument_list|(
name|tailptr
argument_list|,
literal|"%u,%u,%u,%u,%u,%u"
argument_list|,
operator|&
name|values
index|[
literal|0
index|]
argument_list|,
operator|&
name|values
index|[
literal|1
index|]
argument_list|,
operator|&
name|values
index|[
literal|2
index|]
argument_list|,
operator|&
name|values
index|[
literal|3
index|]
argument_list|,
operator|&
name|values
index|[
literal|4
index|]
argument_list|,
operator|&
name|values
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|6
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"malformed PASV reply (%s)"
argument_list|,
name|client
operator|->
name|line_buffer
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_DATAERR
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|values
index|[
name|i
index|]
operator|>
literal|255
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"malformed PASV reply(%s)"
argument_list|,
name|client
operator|->
name|line_buffer
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_DATAERR
argument_list|)
expr_stmt|;
block|}
name|server_listen_sa
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|server_listen_sa
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
operator|(
name|values
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|values
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|values
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|values
index|[
literal|3
index|]
operator|<<
literal|0
operator|)
argument_list|)
expr_stmt|;
name|server_listen_sa
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
operator|(
name|values
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
name|values
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|1
argument_list|,
literal|"server wants us to use %s:%u"
argument_list|,
name|inet_ntoa
argument_list|(
name|server_listen_sa
operator|.
name|sin_addr
argument_list|)
argument_list|,
operator|(
name|values
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
name|values
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|new_dataconn
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|connection_mode
operator|=
name|PASV_MODE
expr_stmt|;
name|iap
operator|=
operator|&
operator|(
name|server
operator|->
name|sa
operator|.
name|sin_addr
operator|)
expr_stmt|;
name|debuglog
argument_list|(
literal|1
argument_list|,
literal|"we want client to use %s:%u"
argument_list|,
name|inet_ntoa
argument_list|(
operator|*
name|iap
argument_list|)
argument_list|,
name|htons
argument_list|(
name|client_listen_sa
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|"227 Entering Passive Mode (%u,%u,%u,%u,%u,%u)\r\n"
argument_list|,
operator|(
operator|(
name|u_char
operator|*
operator|)
name|iap
operator|)
index|[
literal|0
index|]
argument_list|,
operator|(
operator|(
name|u_char
operator|*
operator|)
name|iap
operator|)
index|[
literal|1
index|]
argument_list|,
operator|(
operator|(
name|u_char
operator|*
operator|)
name|iap
operator|)
index|[
literal|2
index|]
argument_list|,
operator|(
operator|(
name|u_char
operator|*
operator|)
name|iap
operator|)
index|[
literal|3
index|]
argument_list|,
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|client_listen_sa
operator|.
name|sin_port
operator|)
index|[
literal|0
index|]
argument_list|,
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|client_listen_sa
operator|.
name|sin_port
operator|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|1
argument_list|,
literal|"to client (modified): %s"
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
name|sendbuf
operator|=
name|tbuf
expr_stmt|;
block|}
else|else
block|{
name|sendit
label|:
name|sendbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|server
operator|->
name|line_buffer
expr_stmt|;
block|}
comment|/* 	 * send our (possibly modified) control command in sendbuf 	 * on it's way to the client 	 */
name|j
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|sendbuf
argument_list|)
expr_stmt|;
do|do
block|{
name|rv
operator|=
name|send
argument_list|(
name|client
operator|->
name|fd
argument_list|,
name|sendbuf
operator|+
name|j
argument_list|,
name|i
operator|-
name|j
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EAGAIN
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
break|break;
elseif|else
if|if
condition|(
name|rv
operator|!=
operator|-
literal|1
condition|)
name|j
operator|+=
name|rv
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|>=
literal|0
operator|&&
name|j
operator|<
name|i
condition|)
do|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|struct
name|csiob
name|client_iob
decl_stmt|,
name|server_iob
decl_stmt|;
name|struct
name|sigaction
name|new_sa
decl_stmt|,
name|old_sa
decl_stmt|;
name|int
name|sval
decl_stmt|,
name|ch
decl_stmt|,
name|flags
decl_stmt|,
name|i
decl_stmt|;
name|socklen_t
name|salen
decl_stmt|;
name|int
name|one
init|=
literal|1
decl_stmt|;
name|long
name|timeout_seconds
init|=
literal|0
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
ifdef|#
directive|ifdef
name|LIBWRAP
name|int
name|use_tcpwrapper
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* LIBWRAP */
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"D:g:m:M:t:u:AnVwr"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'A'
case|:
name|AnonFtpOnly
operator|=
literal|1
expr_stmt|;
comment|/* restrict to anon usernames only */
break|break;
case|case
literal|'D'
case|:
name|Debug_Level
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|optarg
operator|||
operator|*
name|p
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|Group
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|min_port
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|optarg
operator|||
operator|*
name|p
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|min_port
operator|<
literal|0
operator|||
name|min_port
operator|>
name|USHRT_MAX
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|max_port
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|optarg
operator|||
operator|*
name|p
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|max_port
operator|<
literal|0
operator|||
name|max_port
operator|>
name|USHRT_MAX
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|NatMode
operator|=
literal|1
expr_stmt|;
comment|/* pass all passives, we're using NAT */
break|break;
case|case
literal|'r'
case|:
name|Use_Rdns
operator|=
literal|1
expr_stmt|;
comment|/* look up hostnames */
break|break;
case|case
literal|'t'
case|:
name|timeout_seconds
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|optarg
operator|||
operator|*
name|p
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|User
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|Verbose
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|LIBWRAP
case|case
literal|'w'
case|:
name|use_tcpwrapper
operator|=
literal|1
expr_stmt|;
comment|/* do the libwrap thing */
break|break;
endif|#
directive|endif
comment|/* LIBWRAP */
default|default:
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|max_port
operator|<
name|min_port
condition|)
name|usage
argument_list|()
expr_stmt|;
name|openlog
argument_list|(
name|__progname
argument_list|,
name|LOG_NDELAY
operator||
name|LOG_PID
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
name|setlinebuf
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|setlinebuf
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|client_iob
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|client_iob
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|server_iob
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|server_iob
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_proxy_env
argument_list|(
literal|0
argument_list|,
operator|&
name|real_server_sa
argument_list|,
operator|&
name|client_iob
operator|.
name|sa
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|exit
argument_list|(
name|EX_PROTOCOL
argument_list|)
expr_stmt|;
comment|/* 	 * We may now drop root privs, as we have done our ioctl for 	 * pf. If we do drop root, we can't make backchannel connections 	 * for PORT and EPRT come from port 20, which is not strictly 	 * RFC compliant. This shouldn't cause problems for all but 	 * the stupidest ftp clients and the stupidest packet filters. 	 */
name|drop_privs
argument_list|()
expr_stmt|;
comment|/* 	 * We check_host after get_proxy_env so that checks are done 	 * against the original destination endpoint, not the endpoint 	 * of our side of the rdr. This allows the use of tcpwrapper 	 * rules to restrict destinations as well as sources of connections 	 * for ftp. 	 */
if|if
condition|(
name|Use_Rdns
condition|)
name|flags
operator|=
literal|0
expr_stmt|;
else|else
name|flags
operator|=
name|NI_NUMERICHOST
operator||
name|NI_NUMERICSERV
expr_stmt|;
name|i
operator|=
name|getnameinfo
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|client_iob
operator|.
name|sa
argument_list|,
sizeof|sizeof
argument_list|(
name|client_iob
operator|.
name|sa
argument_list|)
argument_list|,
name|ClientName
argument_list|,
sizeof|sizeof
argument_list|(
name|ClientName
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
name|i
operator|!=
name|EAI_NONAME
operator|&&
name|i
operator|!=
name|EAI_AGAIN
condition|)
block|{
name|debuglog
argument_list|(
literal|2
argument_list|,
literal|"name resolution failure (client)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|getnameinfo
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|real_server_sa
argument_list|,
sizeof|sizeof
argument_list|(
name|real_server_sa
argument_list|)
argument_list|,
name|RealServerName
argument_list|,
sizeof|sizeof
argument_list|(
name|RealServerName
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
name|i
operator|!=
name|EAI_NONAME
operator|&&
name|i
operator|!=
name|EAI_AGAIN
condition|)
block|{
name|debuglog
argument_list|(
literal|2
argument_list|,
literal|"name resolution failure (server)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LIBWRAP
if|if
condition|(
name|use_tcpwrapper
operator|&&
operator|!
name|check_host
argument_list|(
operator|&
name|client_iob
operator|.
name|sa
argument_list|,
operator|&
name|real_server_sa
argument_list|)
condition|)
name|exit
argument_list|(
name|EX_NOPERM
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|client_iob
operator|.
name|fd
operator|=
literal|0
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"accepted connection from %s:%u to %s:%u"
argument_list|,
name|ClientName
argument_list|,
name|ntohs
argument_list|(
name|client_iob
operator|.
name|sa
operator|.
name|sin_port
argument_list|)
argument_list|,
name|RealServerName
argument_list|,
name|ntohs
argument_list|(
name|real_server_sa
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|server_iob
operator|.
name|fd
operator|=
name|get_backchannel_socket
argument_list|(
name|SOCK_STREAM
argument_list|,
name|min_port
argument_list|,
name|max_port
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
operator|&
name|server_iob
operator|.
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|server_iob
operator|.
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|real_server_sa
argument_list|,
sizeof|sizeof
argument_list|(
name|real_server_sa
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"cannot connect to %s:%u (%m)"
argument_list|,
name|RealServerName
argument_list|,
name|ntohs
argument_list|(
name|real_server_sa
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_NOHOST
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now that we are connected to the real server, get the name 	 * of our end of the server socket so we know our IP address 	 * from the real server's perspective. 	 */
name|salen
operator|=
sizeof|sizeof
argument_list|(
name|server_iob
operator|.
name|sa
argument_list|)
expr_stmt|;
name|getsockname
argument_list|(
name|server_iob
operator|.
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|server_iob
operator|.
name|sa
argument_list|,
operator|&
name|salen
argument_list|)
expr_stmt|;
name|i
operator|=
name|getnameinfo
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|server_iob
operator|.
name|sa
argument_list|,
sizeof|sizeof
argument_list|(
name|server_iob
operator|.
name|sa
argument_list|)
argument_list|,
name|OurName
argument_list|,
sizeof|sizeof
argument_list|(
name|OurName
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
name|i
operator|!=
name|EAI_NONAME
operator|&&
name|i
operator|!=
name|EAI_AGAIN
condition|)
block|{
name|debuglog
argument_list|(
literal|2
argument_list|,
literal|"name resolution failure (local)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
name|debuglog
argument_list|(
literal|1
argument_list|,
literal|"local socket is %s:%u"
argument_list|,
name|OurName
argument_list|,
name|ntohs
argument_list|(
name|server_iob
operator|.
name|sa
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ignore SIGPIPE */
name|bzero
argument_list|(
operator|&
name|new_sa
argument_list|,
sizeof|sizeof
argument_list|(
name|new_sa
argument_list|)
argument_list|)
expr_stmt|;
name|new_sa
operator|.
name|sa_handler
operator|=
name|SIG_IGN
expr_stmt|;
operator|(
name|void
operator|)
name|sigemptyset
argument_list|(
operator|&
name|new_sa
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|new_sa
operator|.
name|sa_flags
operator|=
name|SA_RESTART
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|SIGPIPE
argument_list|,
operator|&
name|new_sa
argument_list|,
operator|&
name|old_sa
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sigaction() failed (%m)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setsockopt
argument_list|(
name|client_iob
operator|.
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_OOBINLINE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|one
argument_list|,
sizeof|sizeof
argument_list|(
name|one
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"cannot set SO_OOBINLINE (%m)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
name|client_iob
operator|.
name|line_buffer_size
operator|=
name|STARTBUFSIZE
expr_stmt|;
name|client_iob
operator|.
name|line_buffer
operator|=
name|malloc
argument_list|(
name|client_iob
operator|.
name|line_buffer_size
argument_list|)
expr_stmt|;
name|client_iob
operator|.
name|io_buffer_size
operator|=
name|STARTBUFSIZE
expr_stmt|;
name|client_iob
operator|.
name|io_buffer
operator|=
name|malloc
argument_list|(
name|client_iob
operator|.
name|io_buffer_size
argument_list|)
expr_stmt|;
name|client_iob
operator|.
name|next_byte
operator|=
literal|0
expr_stmt|;
name|client_iob
operator|.
name|io_buffer_len
operator|=
literal|0
expr_stmt|;
name|client_iob
operator|.
name|alive
operator|=
literal|1
expr_stmt|;
name|client_iob
operator|.
name|who
operator|=
literal|"client"
expr_stmt|;
name|client_iob
operator|.
name|send_oob_flags
operator|=
literal|0
expr_stmt|;
name|client_iob
operator|.
name|real_sa
operator|=
name|client_iob
operator|.
name|sa
expr_stmt|;
name|server_iob
operator|.
name|line_buffer_size
operator|=
name|STARTBUFSIZE
expr_stmt|;
name|server_iob
operator|.
name|line_buffer
operator|=
name|malloc
argument_list|(
name|server_iob
operator|.
name|line_buffer_size
argument_list|)
expr_stmt|;
name|server_iob
operator|.
name|io_buffer_size
operator|=
name|STARTBUFSIZE
expr_stmt|;
name|server_iob
operator|.
name|io_buffer
operator|=
name|malloc
argument_list|(
name|server_iob
operator|.
name|io_buffer_size
argument_list|)
expr_stmt|;
name|server_iob
operator|.
name|next_byte
operator|=
literal|0
expr_stmt|;
name|server_iob
operator|.
name|io_buffer_len
operator|=
literal|0
expr_stmt|;
name|server_iob
operator|.
name|alive
operator|=
literal|1
expr_stmt|;
name|server_iob
operator|.
name|who
operator|=
literal|"server"
expr_stmt|;
name|server_iob
operator|.
name|send_oob_flags
operator|=
name|MSG_OOB
expr_stmt|;
name|server_iob
operator|.
name|real_sa
operator|=
name|real_server_sa
expr_stmt|;
if|if
condition|(
name|client_iob
operator|.
name|line_buffer
operator|==
name|NULL
operator|||
name|client_iob
operator|.
name|io_buffer
operator|==
name|NULL
operator|||
name|server_iob
operator|.
name|line_buffer
operator|==
name|NULL
operator|||
name|server_iob
operator|.
name|io_buffer
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"insufficient memory"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|client_iob
operator|.
name|alive
operator|||
name|server_iob
operator|.
name|alive
condition|)
block|{
name|int
name|maxfd
init|=
literal|0
decl_stmt|;
name|fd_set
modifier|*
name|fdsp
decl_stmt|;
if|if
condition|(
name|client_iob
operator|.
name|fd
operator|>
name|maxfd
condition|)
name|maxfd
operator|=
name|client_iob
operator|.
name|fd
expr_stmt|;
if|if
condition|(
name|client_listen_socket
operator|>
name|maxfd
condition|)
name|maxfd
operator|=
name|client_listen_socket
expr_stmt|;
if|if
condition|(
name|client_data_socket
operator|>
name|maxfd
condition|)
name|maxfd
operator|=
name|client_data_socket
expr_stmt|;
if|if
condition|(
name|server_iob
operator|.
name|fd
operator|>
name|maxfd
condition|)
name|maxfd
operator|=
name|server_iob
operator|.
name|fd
expr_stmt|;
if|if
condition|(
name|server_listen_socket
operator|>
name|maxfd
condition|)
name|maxfd
operator|=
name|server_listen_socket
expr_stmt|;
if|if
condition|(
name|server_data_socket
operator|>
name|maxfd
condition|)
name|maxfd
operator|=
name|server_data_socket
expr_stmt|;
name|debuglog
argument_list|(
literal|3
argument_list|,
literal|"client is %s; server is %s"
argument_list|,
name|client_iob
operator|.
name|alive
condition|?
literal|"alive"
else|:
literal|"dead"
argument_list|,
name|server_iob
operator|.
name|alive
condition|?
literal|"alive"
else|:
literal|"dead"
argument_list|)
expr_stmt|;
name|fdsp
operator|=
operator|(
name|fd_set
operator|*
operator|)
name|calloc
argument_list|(
name|howmany
argument_list|(
name|maxfd
operator|+
literal|1
argument_list|,
name|NFDBITS
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdsp
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"insufficient memory"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|client_iob
operator|.
name|alive
operator|&&
name|telnet_getline
argument_list|(
operator|&
name|client_iob
argument_list|,
operator|&
name|server_iob
argument_list|)
condition|)
block|{
name|debuglog
argument_list|(
literal|3
argument_list|,
literal|"client line buffer is \"%s\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|client_iob
operator|.
name|line_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|client_iob
operator|.
name|line_buffer
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|do_client_cmd
argument_list|(
operator|&
name|client_iob
argument_list|,
operator|&
name|server_iob
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|server_iob
operator|.
name|alive
operator|&&
name|telnet_getline
argument_list|(
operator|&
name|server_iob
argument_list|,
operator|&
name|client_iob
argument_list|)
condition|)
block|{
name|debuglog
argument_list|(
literal|3
argument_list|,
literal|"server line buffer is \"%s\""
argument_list|,
operator|(
name|char
operator|*
operator|)
name|server_iob
operator|.
name|line_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_iob
operator|.
name|line_buffer
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|do_server_reply
argument_list|(
operator|&
name|server_iob
argument_list|,
operator|&
name|client_iob
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|client_iob
operator|.
name|alive
condition|)
block|{
name|FD_SET
argument_list|(
name|client_iob
operator|.
name|fd
argument_list|,
name|fdsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|client_listen_socket
operator|>=
literal|0
condition|)
name|FD_SET
argument_list|(
name|client_listen_socket
argument_list|,
name|fdsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|client_data_socket
operator|>=
literal|0
condition|)
name|FD_SET
argument_list|(
name|client_data_socket
argument_list|,
name|fdsp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|server_iob
operator|.
name|alive
condition|)
block|{
name|FD_SET
argument_list|(
name|server_iob
operator|.
name|fd
argument_list|,
name|fdsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_listen_socket
operator|>=
literal|0
condition|)
name|FD_SET
argument_list|(
name|server_listen_socket
argument_list|,
name|fdsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_data_socket
operator|>=
literal|0
condition|)
name|FD_SET
argument_list|(
name|server_data_socket
argument_list|,
name|fdsp
argument_list|)
expr_stmt|;
block|}
name|tv
operator|.
name|tv_sec
operator|=
name|timeout_seconds
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|doselect
label|:
name|sval
operator|=
name|select
argument_list|(
name|maxfd
operator|+
literal|1
argument_list|,
name|fdsp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
name|tv
operator|.
name|tv_sec
operator|==
literal|0
operator|)
condition|?
name|NULL
else|:
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|sval
operator|==
literal|0
condition|)
block|{
comment|/* 				 * This proxy has timed out. Expire it 				 * quietly with an obituary in the syslogs 				 * for any passing mourners. 				 */
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"timeout: no data for %ld seconds"
argument_list|,
name|timeout_seconds
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sval
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
condition|)
goto|goto
name|doselect
goto|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"select() failed (%m)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|client_data_socket
operator|>=
literal|0
operator|&&
name|FD_ISSET
argument_list|(
name|client_data_socket
argument_list|,
name|fdsp
argument_list|)
condition|)
block|{
name|int
name|rval
decl_stmt|;
name|debuglog
argument_list|(
literal|3
argument_list|,
literal|"transfer: client to server"
argument_list|)
expr_stmt|;
name|rval
operator|=
name|xfer_data
argument_list|(
literal|"client to server"
argument_list|,
name|client_data_socket
argument_list|,
name|server_data_socket
argument_list|,
name|client_iob
operator|.
name|sa
operator|.
name|sin_addr
argument_list|,
name|real_server_sa
operator|.
name|sin_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|<=
literal|0
condition|)
block|{
name|close_client_data
argument_list|()
expr_stmt|;
name|close_server_data
argument_list|()
expr_stmt|;
name|show_xfer_stats
argument_list|()
expr_stmt|;
block|}
else|else
name|client_data_bytes
operator|+=
name|rval
expr_stmt|;
block|}
if|if
condition|(
name|server_data_socket
operator|>=
literal|0
operator|&&
name|FD_ISSET
argument_list|(
name|server_data_socket
argument_list|,
name|fdsp
argument_list|)
condition|)
block|{
name|int
name|rval
decl_stmt|;
name|debuglog
argument_list|(
literal|3
argument_list|,
literal|"transfer: server to client"
argument_list|)
expr_stmt|;
name|rval
operator|=
name|xfer_data
argument_list|(
literal|"server to client"
argument_list|,
name|server_data_socket
argument_list|,
name|client_data_socket
argument_list|,
name|real_server_sa
operator|.
name|sin_addr
argument_list|,
name|client_iob
operator|.
name|sa
operator|.
name|sin_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|<=
literal|0
condition|)
block|{
name|close_client_data
argument_list|()
expr_stmt|;
name|close_server_data
argument_list|()
expr_stmt|;
name|show_xfer_stats
argument_list|()
expr_stmt|;
block|}
else|else
name|server_data_bytes
operator|+=
name|rval
expr_stmt|;
block|}
if|if
condition|(
name|server_listen_socket
operator|>=
literal|0
operator|&&
name|FD_ISSET
argument_list|(
name|server_listen_socket
argument_list|,
name|fdsp
argument_list|)
condition|)
block|{
name|connect_port_backchannel
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|client_listen_socket
operator|>=
literal|0
operator|&&
name|FD_ISSET
argument_list|(
name|client_listen_socket
argument_list|,
name|fdsp
argument_list|)
condition|)
block|{
name|connect_pasv_backchannel
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|client_iob
operator|.
name|alive
operator|&&
name|FD_ISSET
argument_list|(
name|client_iob
operator|.
name|fd
argument_list|,
name|fdsp
argument_list|)
condition|)
block|{
name|client_iob
operator|.
name|data_available
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|server_iob
operator|.
name|alive
operator|&&
name|FD_ISSET
argument_list|(
name|server_iob
operator|.
name|fd
argument_list|,
name|fdsp
argument_list|)
condition|)
block|{
name|server_iob
operator|.
name|data_available
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|fdsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|client_iob
operator|.
name|got_eof
condition|)
block|{
name|shutdown
argument_list|(
name|server_iob
operator|.
name|fd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|shutdown
argument_list|(
name|client_iob
operator|.
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|client_iob
operator|.
name|got_eof
operator|=
literal|0
expr_stmt|;
name|client_iob
operator|.
name|alive
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|server_iob
operator|.
name|got_eof
condition|)
block|{
name|shutdown
argument_list|(
name|client_iob
operator|.
name|fd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|shutdown
argument_list|(
name|server_iob
operator|.
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|server_iob
operator|.
name|got_eof
operator|=
literal|0
expr_stmt|;
name|server_iob
operator|.
name|alive
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Verbose
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"session ended"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

