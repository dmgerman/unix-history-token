begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: authpf.c,v 1.89 2005/02/10 04:24:15 joel Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (C) 1998 - 2002 Bob Beck (beck@openbsd.org).  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/pfvar.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<login_cap.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_function_decl
specifier|extern
name|int
name|symset
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_config
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_message
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|allowed_luser
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_luser
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|remove_stale_rulesets
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|change_filter
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|change_table
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|authpf_kill_states
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|dev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pf device */
end_comment

begin_decl_stmt
name|char
name|anchorname
index|[
name|PF_ANCHOR_NAME_SIZE
index|]
init|=
literal|"authpf"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|rulesetname
index|[
name|MAXPATHLEN
operator|-
name|PF_ANCHOR_NAME_SIZE
operator|-
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|tablename
index|[
name|PF_TABLE_NAME_SIZE
index|]
init|=
literal|"authpf_users"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|pidfp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|infile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file name printed by yyerror() in parse.y */
end_comment

begin_decl_stmt
name|char
name|luser
index|[
name|MAXLOGNAME
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* username */
end_comment

begin_decl_stmt
name|char
name|ipsrc
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ip as a string */
end_comment

begin_decl_stmt
name|char
name|pidfile
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* we save pid in this file. */
end_comment

begin_decl_stmt
name|struct
name|timeval
name|Tstart
decl_stmt|,
name|Tend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start and end times of session */
end_comment

begin_decl_stmt
specifier|volatile
name|sig_atomic_t
name|want_death
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|need_death
parameter_list|(
name|int
name|signo
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_function_decl
specifier|static
name|__dead2
name|void
name|do_death
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|__dead
name|void
name|do_death
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * User shell for authenticating gateways. Sole purpose is to allow  * a user to ssh to a gateway, and have the gateway modify packet  * filters to allow access, then remove access when the user finishes  * up. Meant to be used only from ssh(1) connections.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|lockcnt
init|=
literal|0
decl_stmt|,
name|n
decl_stmt|,
name|pidfd
decl_stmt|;
name|FILE
modifier|*
name|config
decl_stmt|;
name|struct
name|in6_addr
name|ina
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|char
modifier|*
name|shell
decl_stmt|;
name|login_cap_t
modifier|*
name|lc
decl_stmt|;
name|config
operator|=
name|fopen
argument_list|(
name|PATH_CONFFILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"SSH_TTY"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"non-interactive session connection for authpf"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"SSH_CLIENT"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot determine connection source"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strlcpy
argument_list|(
name|ipsrc
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|ipsrc
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|ipsrc
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"SSH_CLIENT variable too long"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|strchr
argument_list|(
name|ipsrc
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"corrupt SSH_CLIENT variable %s"
argument_list|,
name|ipsrc
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET
argument_list|,
name|ipsrc
argument_list|,
operator|&
name|ina
argument_list|)
operator|!=
literal|1
operator|&&
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|ipsrc
argument_list|,
operator|&
name|ina
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot determine IP from SSH_CLIENT %s"
argument_list|,
name|ipsrc
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* open the pf device */
name|dev
operator|=
name|open
argument_list|(
name|PATH_DEVFILE
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot open packet filter device (%m)"
argument_list|)
expr_stmt|;
goto|goto
name|die
goto|;
block|}
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|pw
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot find user for uid %u"
argument_list|,
name|uid
argument_list|)
expr_stmt|;
goto|goto
name|die
goto|;
block|}
if|if
condition|(
operator|(
name|lc
operator|=
name|login_getclass
argument_list|(
name|pw
operator|->
name|pw_class
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|shell
operator|=
operator|(
name|char
operator|*
operator|)
name|login_getcapstr
argument_list|(
name|lc
argument_list|,
literal|"shell"
argument_list|,
name|pw
operator|->
name|pw_shell
argument_list|,
name|pw
operator|->
name|pw_shell
argument_list|)
expr_stmt|;
else|else
name|shell
operator|=
name|pw
operator|->
name|pw_shell
expr_stmt|;
name|login_close
argument_list|(
name|lc
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|shell
argument_list|,
name|PATH_AUTHPF_SHELL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"wrong shell for user %s, uid %u"
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
name|pw
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|shell
operator|!=
name|pw
operator|->
name|pw_shell
condition|)
name|free
argument_list|(
name|shell
argument_list|)
expr_stmt|;
goto|goto
name|die
goto|;
block|}
if|if
condition|(
name|shell
operator|!=
name|pw
operator|->
name|pw_shell
condition|)
name|free
argument_list|(
name|shell
argument_list|)
expr_stmt|;
comment|/* 	 * Paranoia, but this data _does_ come from outside authpf, and 	 * truncation would be bad. 	 */
if|if
condition|(
name|strlcpy
argument_list|(
name|luser
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
sizeof|sizeof
argument_list|(
name|luser
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|luser
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"username too long: %s"
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
goto|goto
name|die
goto|;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|snprintf
argument_list|(
name|rulesetname
argument_list|,
sizeof|sizeof
argument_list|(
name|rulesetname
argument_list|)
argument_list|,
literal|"%s(%ld)"
argument_list|,
name|luser
argument_list|,
operator|(
name|long
operator|)
name|getpid
argument_list|()
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|u_int
operator|)
name|n
operator|>=
sizeof|sizeof
argument_list|(
name|rulesetname
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s(%ld) too large, ruleset name will be %ld"
argument_list|,
name|luser
argument_list|,
operator|(
name|long
operator|)
name|getpid
argument_list|()
argument_list|,
operator|(
name|long
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|snprintf
argument_list|(
name|rulesetname
argument_list|,
sizeof|sizeof
argument_list|(
name|rulesetname
argument_list|)
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|getpid
argument_list|()
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|u_int
operator|)
name|n
operator|>=
sizeof|sizeof
argument_list|(
name|rulesetname
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pid too large for ruleset name"
argument_list|)
expr_stmt|;
goto|goto
name|die
goto|;
block|}
block|}
comment|/* Make our entry in /var/authpf as /var/authpf/ipaddr */
name|n
operator|=
name|snprintf
argument_list|(
name|pidfile
argument_list|,
sizeof|sizeof
argument_list|(
name|pidfile
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|PATH_PIDFILE
argument_list|,
name|ipsrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
operator|(
name|u_int
operator|)
name|n
operator|>=
sizeof|sizeof
argument_list|(
name|pidfile
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"path to pidfile too long"
argument_list|)
expr_stmt|;
goto|goto
name|die
goto|;
block|}
comment|/* 	 * If someone else is already using this ip, then this person 	 * wants to switch users - so kill the old process and exit 	 * as well. 	 * 	 * Note, we could print a message and tell them to log out, but the 	 * usual case of this is that someone has left themselves logged in, 	 * with the authenticated connection iconized and someone else walks 	 * up to use and automatically logs in before using. If this just 	 * gets rid of the old one silently, the new user never knows they 	 * could have used someone else's old authentication. If we 	 * tell them to log out before switching users it is an invitation 	 * for abuse. 	 */
do|do
block|{
name|int
name|save_errno
decl_stmt|,
name|otherpid
init|=
operator|-
literal|1
decl_stmt|;
name|char
name|otherluser
index|[
name|MAXLOGNAME
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|pidfd
operator|=
name|open
argument_list|(
name|pidfile
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0644
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|||
operator|(
name|pidfp
operator|=
name|fdopen
argument_list|(
name|pidfd
argument_list|,
literal|"r+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|pidfd
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|pidfd
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot open or create %s: %s"
argument_list|,
name|pidfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|die
goto|;
block|}
if|if
condition|(
name|flock
argument_list|(
name|fileno
argument_list|(
name|pidfp
argument_list|)
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|save_errno
operator|=
name|errno
expr_stmt|;
comment|/* Mark our pid, and username to our file. */
name|rewind
argument_list|(
name|pidfp
argument_list|)
expr_stmt|;
comment|/* 31 == MAXLOGNAME - 1 */
if|if
condition|(
name|fscanf
argument_list|(
name|pidfp
argument_list|,
literal|"%d\n%31s\n"
argument_list|,
operator|&
name|otherpid
argument_list|,
name|otherluser
argument_list|)
operator|!=
literal|2
condition|)
name|otherpid
operator|=
operator|-
literal|1
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"tried to lock %s, in use by pid %d: %s"
argument_list|,
name|pidfile
argument_list|,
name|otherpid
argument_list|,
name|strerror
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|otherpid
operator|>
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"killing prior auth (pid %d) of %s by user %s"
argument_list|,
name|otherpid
argument_list|,
name|ipsrc
argument_list|,
name|otherluser
argument_list|)
expr_stmt|;
if|if
condition|(
name|kill
argument_list|(
operator|(
name|pid_t
operator|)
name|otherpid
argument_list|,
name|SIGTERM
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"could not kill process %d: (%m)"
argument_list|,
name|otherpid
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * we try to kill the previous process and acquire the lock 		 * for 10 seconds, trying once a second. if we can't after 		 * 10 attempts we log an error and give up 		 */
if|if
condition|(
operator|++
name|lockcnt
operator|>
literal|10
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot kill previous authpf (pid %d)"
argument_list|,
name|otherpid
argument_list|)
expr_stmt|;
goto|goto
name|dogdeath
goto|;
block|}
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* re-open, and try again. The previous authpf process 		 * we killed above should unlink the file and release 		 * it's lock, giving us a chance to get it now 		 */
name|fclose
argument_list|(
name|pidfp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
comment|/* revoke privs */
name|seteuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|openlog
argument_list|(
literal|"authpf"
argument_list|,
name|LOG_PID
operator||
name|LOG_NDELAY
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|check_luser
argument_list|(
name|PATH_BAN_DIR
argument_list|,
name|luser
argument_list|)
operator|||
operator|!
name|allowed_luser
argument_list|(
name|luser
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"user %s prohibited"
argument_list|,
name|luser
argument_list|)
expr_stmt|;
name|do_death
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config
operator|==
name|NULL
operator|||
name|read_config
argument_list|(
name|config
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"bad or nonexistent %s"
argument_list|,
name|PATH_CONFFILE
argument_list|)
expr_stmt|;
name|do_death
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|remove_stale_rulesets
argument_list|()
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"error removing stale rulesets"
argument_list|)
expr_stmt|;
name|do_death
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* We appear to be making headway, so actually mark our pid */
name|rewind
argument_list|(
name|pidfp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pidfp
argument_list|,
literal|"%ld\n%s\n"
argument_list|,
operator|(
name|long
operator|)
name|getpid
argument_list|()
argument_list|,
name|luser
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|pidfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ftruncate
argument_list|(
name|fileno
argument_list|(
name|pidfp
argument_list|)
argument_list|,
name|ftello
argument_list|(
name|pidfp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|change_filter
argument_list|(
literal|1
argument_list|,
name|luser
argument_list|,
name|ipsrc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Unable to modify filters\r\n"
argument_list|)
expr_stmt|;
name|do_death
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|change_table
argument_list|(
literal|1
argument_list|,
name|luser
argument_list|,
name|ipsrc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Unable to modify table\r\n"
argument_list|)
expr_stmt|;
name|change_filter
argument_list|(
literal|0
argument_list|,
name|luser
argument_list|,
name|ipsrc
argument_list|)
expr_stmt|;
name|do_death
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|need_death
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|need_death
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|need_death
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|need_death
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|need_death
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGSTOP
argument_list|,
name|need_death
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|need_death
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\r\nHello %s. "
argument_list|,
name|luser
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"You are authenticated from host \"%s\"\r\n"
argument_list|,
name|ipsrc
argument_list|)
expr_stmt|;
name|setproctitle
argument_list|(
literal|"%s@%s"
argument_list|,
name|luser
argument_list|,
name|ipsrc
argument_list|)
expr_stmt|;
name|print_message
argument_list|(
name|PATH_MESSAGE
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_death
condition|)
name|do_death
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* NOTREACHED */
name|dogdeath
label|:
name|printf
argument_list|(
literal|"\r\n\r\nSorry, this service is currently unavailable due to "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"technical difficulties\r\n\r\n"
argument_list|)
expr_stmt|;
name|print_message
argument_list|(
name|PATH_PROBLEM
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\r\nYour authentication process (pid %ld) was unable to run\n"
argument_list|,
operator|(
name|long
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|180
argument_list|)
expr_stmt|;
comment|/* them lusers read reaaaaal slow */
name|die
label|:
name|do_death
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * reads config file in PATH_CONFFILE to set optional behaviours up  */
end_comment

begin_function
specifier|static
name|int
name|read_config
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
do|do
block|{
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
name|char
modifier|*
name|pair
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|f
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|i
operator|++
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\n'
operator|&&
operator|!
name|feof
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"line %d too long in %s"
argument_list|,
name|i
argument_list|,
name|PATH_CONFFILE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|buf
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|buf
init|;
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|;
name|cp
operator|++
control|)
empty_stmt|;
comment|/* nothing */
if|if
condition|(
operator|!
operator|*
name|cp
operator|||
operator|*
name|cp
operator|==
literal|'#'
operator|||
operator|*
name|cp
operator|==
literal|'\n'
condition|)
continue|continue;
for|for
control|(
name|ap
operator|=
name|pair
init|;
name|ap
operator|<
operator|&
name|pair
index|[
literal|3
index|]
operator|&&
operator|(
operator|*
name|ap
operator|=
name|strsep
argument_list|(
operator|&
name|cp
argument_list|,
literal|"="
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
operator|*
operator|*
name|ap
operator|!=
literal|'\0'
condition|)
name|ap
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|!=
operator|&
name|pair
index|[
literal|2
index|]
condition|)
goto|goto
name|parse_error
goto|;
name|tp
operator|=
name|pair
index|[
literal|1
index|]
operator|+
name|strlen
argument_list|(
name|pair
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|tp
operator|==
literal|' '
operator|||
operator|*
name|tp
operator|==
literal|'\t'
operator|)
operator|&&
name|tp
operator|>=
name|pair
index|[
literal|1
index|]
condition|)
operator|*
name|tp
operator|--
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|pair
index|[
literal|0
index|]
argument_list|,
literal|"anchor"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|pair
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|||
name|strlcpy
argument_list|(
name|anchorname
argument_list|,
name|pair
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|anchorname
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|anchorname
argument_list|)
condition|)
goto|goto
name|parse_error
goto|;
block|}
if|if
condition|(
name|strcasecmp
argument_list|(
name|pair
index|[
literal|0
index|]
argument_list|,
literal|"table"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|pair
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|||
name|strlcpy
argument_list|(
name|tablename
argument_list|,
name|pair
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|tablename
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|tablename
argument_list|)
condition|)
goto|goto
name|parse_error
goto|;
block|}
block|}
do|while
condition|(
operator|!
name|feof
argument_list|(
name|f
argument_list|)
operator|&&
operator|!
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
do|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|parse_error
label|:
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"parse error, line %d of %s"
argument_list|,
name|i
argument_list|,
name|PATH_CONFFILE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * splatter a file to stdout - max line length of 1024,  * used for spitting message files at users to tell them  * they've been bad or we're unavailable.  */
end_comment

begin_function
specifier|static
name|void
name|print_message
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* fail silently, we don't care if it isn't there */
do|do
block|{
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|f
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
do|while
condition|(
name|fputs
argument_list|(
name|buf
argument_list|,
name|stdout
argument_list|)
operator|!=
name|EOF
operator|&&
operator|!
name|feof
argument_list|(
name|f
argument_list|)
condition|)
do|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * allowed_luser checks to see if user "luser" is allowed to  * use this gateway by virtue of being listed in an allowed  * users file, namely /etc/authpf/authpf.allow .  *  * If /etc/authpf/authpf.allow does not exist, then we assume that  * all users who are allowed in by sshd(8) are permitted to  * use this gateway. If /etc/authpf/authpf.allow does exist, then a  * user must be listed if the connection is to continue, else  * the session terminates in the same manner as being banned.  */
end_comment

begin_function
specifier|static
name|int
name|allowed_luser
parameter_list|(
name|char
modifier|*
name|luser
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|lbuf
decl_stmt|;
name|int
name|matched
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|PATH_ALLOWFILE
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
comment|/* 			 * allowfile doesn't exist, thus this gateway 			 * isn't restricted to certain users... 			 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * luser may in fact be allowed, but we can't open 		 * the file even though it's there. probably a config 		 * problem. 		 */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot open allowed users file %s (%s)"
argument_list|,
name|PATH_ALLOWFILE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* 		 * /etc/authpf/authpf.allow exists, thus we do a linear 		 * search to see if they are allowed. 		 * also, if username "*" exists, then this is a 		 * "public" gateway, such as it is, so let 		 * everyone use it. 		 */
name|lbuf
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|buf
operator|=
name|fgetln
argument_list|(
name|f
argument_list|,
operator|&
name|len
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|buf
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|buf
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|lbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|lbuf
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|lbuf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|buf
operator|=
name|lbuf
expr_stmt|;
block|}
name|matched
operator|=
name|strcmp
argument_list|(
name|luser
argument_list|,
name|buf
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
literal|"*"
argument_list|,
name|buf
argument_list|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|lbuf
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|lbuf
argument_list|)
expr_stmt|;
name|lbuf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|matched
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* matched an allowed username */
block|}
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"denied access to %s: not listed in %s"
argument_list|,
name|luser
argument_list|,
name|PATH_ALLOWFILE
argument_list|)
expr_stmt|;
comment|/* reuse buf */
name|buf
operator|=
literal|"\n\nSorry, you are not allowed to use this facility!\n"
expr_stmt|;
name|fputs
argument_list|(
name|buf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * check_luser checks to see if user "luser" has been banned  * from using us by virtue of having an file of the same name  * in the "luserdir" directory.  *  * If the user has been banned, we copy the contents of the file  * to the user's screen. (useful for telling the user what to  * do to get un-banned, or just to tell them they aren't  * going to be un-banned.)  */
end_comment

begin_function
specifier|static
name|int
name|check_luser
parameter_list|(
name|char
modifier|*
name|luserdir
parameter_list|,
name|char
modifier|*
name|luser
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
name|tmp
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|n
operator|=
name|snprintf
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|luserdir
argument_list|,
name|luser
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
operator|(
name|u_int
operator|)
name|n
operator|>=
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"provided banned directory line too long (%s)"
argument_list|,
name|luserdir
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|tmp
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
comment|/* 			 * file or dir doesn't exist, so therefore 			 * this luser isn't banned..  all is well 			 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* 			 * luser may in fact be banned, but we can't open the 			 * file even though it's there. probably a config 			 * problem. 			 */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot open banned file %s (%s)"
argument_list|,
name|tmp
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 * luser is banned - spit the file at them to 		 * tell what they can do and where they can go. 		 */
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"denied access to %s: %s exists"
argument_list|,
name|luser
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* reuse tmp */
name|strlcpy
argument_list|(
name|tmp
argument_list|,
literal|"\n\n-**- Sorry, you have been banned! -**-\n\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|fputs
argument_list|(
name|tmp
argument_list|,
name|stdout
argument_list|)
operator|!=
name|EOF
operator|&&
operator|!
name|feof
argument_list|(
name|f
argument_list|)
condition|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|f
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Search for rulesets left by other authpf processes (either because they  * died ungracefully or were terminated) and remove them.  */
end_comment

begin_function
specifier|static
name|int
name|remove_stale_rulesets
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pfioc_ruleset
name|prs
decl_stmt|;
name|u_int32_t
name|nr
decl_stmt|,
name|mnr
decl_stmt|;
name|memset
argument_list|(
operator|&
name|prs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|prs
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|prs
operator|.
name|path
argument_list|,
name|anchorname
argument_list|,
sizeof|sizeof
argument_list|(
name|prs
operator|.
name|path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETRULESETS
argument_list|,
operator|&
name|prs
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINVAL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|mnr
operator|=
name|prs
operator|.
name|nr
expr_stmt|;
name|nr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nr
operator|<
name|mnr
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|prs
operator|.
name|nr
operator|=
name|nr
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETRULESET
argument_list|,
operator|&
name|prs
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|strchr
argument_list|(
name|prs
operator|.
name|name
argument_list|,
literal|'('
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|t
operator|=
name|prs
operator|.
name|name
expr_stmt|;
else|else
name|t
operator|++
expr_stmt|;
name|pid
operator|=
name|strtoul
argument_list|(
name|t
argument_list|,
operator|&
name|s
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prs
operator|.
name|name
index|[
literal|0
index|]
operator|||
name|errno
operator|||
operator|(
operator|*
name|s
operator|&&
operator|(
name|t
operator|==
name|prs
operator|.
name|name
operator|||
operator|*
name|s
operator|!=
literal|')'
operator|)
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|kill
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|)
operator|&&
name|errno
operator|!=
name|EPERM
condition|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|pfioc_trans_e
name|t_e
index|[
name|PF_RULESET_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|pfioc_trans
name|t
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|t
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|t_e
argument_list|,
sizeof|sizeof
argument_list|(
name|t_e
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|.
name|size
operator|=
name|PF_RULESET_MAX
operator|+
literal|1
expr_stmt|;
name|t
operator|.
name|esize
operator|=
sizeof|sizeof
argument_list|(
name|t_e
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|t
operator|.
name|array
operator|=
name|t_e
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PF_RULESET_MAX
operator|+
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|t_e
index|[
name|i
index|]
operator|.
name|rs_num
operator|=
name|i
expr_stmt|;
name|snprintf
argument_list|(
name|t_e
index|[
name|i
index|]
operator|.
name|anchor
argument_list|,
sizeof|sizeof
argument_list|(
name|t_e
index|[
name|i
index|]
operator|.
name|anchor
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|anchorname
argument_list|,
name|prs
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|t_e
index|[
name|PF_RULESET_MAX
index|]
operator|.
name|rs_num
operator|=
name|PF_RULESET_TABLE
expr_stmt|;
if|if
condition|(
operator|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCXBEGIN
argument_list|,
operator|&
name|t
argument_list|)
operator|||
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCXCOMMIT
argument_list|,
operator|&
name|t
argument_list|)
operator|)
operator|&&
name|errno
operator|!=
name|EINVAL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|mnr
operator|--
expr_stmt|;
block|}
else|else
name|nr
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add/remove filter entries for user "luser" from ip "ipsrc"  */
end_comment

begin_function
specifier|static
name|int
name|change_filter
parameter_list|(
name|int
name|add
parameter_list|,
specifier|const
name|char
modifier|*
name|luser
parameter_list|,
specifier|const
name|char
modifier|*
name|ipsrc
parameter_list|)
block|{
name|char
modifier|*
name|pargv
index|[
literal|13
index|]
init|=
block|{
literal|"pfctl"
block|,
literal|"-p"
block|,
literal|"/dev/pf"
block|,
literal|"-q"
block|,
literal|"-a"
block|,
literal|"anchor/ruleset"
block|,
literal|"-D"
block|,
literal|"user_ip=X"
block|,
literal|"-D"
block|,
literal|"user_id=X"
block|,
literal|"-f"
block|,
literal|"file"
block|,
name|NULL
block|}
decl_stmt|;
name|char
modifier|*
name|fdpath
init|=
name|NULL
decl_stmt|,
modifier|*
name|userstr
init|=
name|NULL
decl_stmt|,
modifier|*
name|ipstr
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|rsn
init|=
name|NULL
decl_stmt|,
modifier|*
name|fn
init|=
name|NULL
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|luser
operator|==
name|NULL
operator|||
operator|!
name|luser
index|[
literal|0
index|]
operator|||
name|ipsrc
operator|==
name|NULL
operator|||
operator|!
name|ipsrc
index|[
literal|0
index|]
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"invalid luser/ipsrc"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|asprintf
argument_list|(
operator|&
name|rsn
argument_list|,
literal|"%s/%s"
argument_list|,
name|anchorname
argument_list|,
name|rulesetname
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|no_mem
goto|;
if|if
condition|(
name|asprintf
argument_list|(
operator|&
name|fdpath
argument_list|,
literal|"/dev/fd/%d"
argument_list|,
name|dev
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|no_mem
goto|;
if|if
condition|(
name|asprintf
argument_list|(
operator|&
name|ipstr
argument_list|,
literal|"user_ip=%s"
argument_list|,
name|ipsrc
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|no_mem
goto|;
if|if
condition|(
name|asprintf
argument_list|(
operator|&
name|userstr
argument_list|,
literal|"user_id=%s"
argument_list|,
name|luser
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|no_mem
goto|;
if|if
condition|(
name|add
condition|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|asprintf
argument_list|(
operator|&
name|fn
argument_list|,
literal|"%s/%s/authpf.rules"
argument_list|,
name|PATH_USER_DIR
argument_list|,
name|luser
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|no_mem
goto|;
if|if
condition|(
name|stat
argument_list|(
name|fn
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fn
operator|=
name|strdup
argument_list|(
name|PATH_PFRULES
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
block|}
block|}
name|pargv
index|[
literal|2
index|]
operator|=
name|fdpath
expr_stmt|;
name|pargv
index|[
literal|5
index|]
operator|=
name|rsn
expr_stmt|;
name|pargv
index|[
literal|7
index|]
operator|=
name|userstr
expr_stmt|;
name|pargv
index|[
literal|9
index|]
operator|=
name|ipstr
expr_stmt|;
if|if
condition|(
operator|!
name|add
condition|)
name|pargv
index|[
literal|11
index|]
operator|=
literal|"/dev/null"
expr_stmt|;
else|else
name|pargv
index|[
literal|11
index|]
operator|=
name|fn
expr_stmt|;
switch|switch
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|err
argument_list|(
literal|1
argument_list|,
literal|"fork failed"
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
name|execvp
argument_list|(
name|PATH_PFCTL
argument_list|,
name|pargv
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"exec of %s failed"
argument_list|,
name|PATH_PFCTL
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* parent */
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|WIFEXITED
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pfctl exited abnormally"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
if|if
condition|(
name|add
condition|)
block|{
name|gettimeofday
argument_list|(
operator|&
name|Tstart
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"allowing %s, user %s"
argument_list|,
name|ipsrc
argument_list|,
name|luser
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gettimeofday
argument_list|(
operator|&
name|Tend
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"removed %s, user %s - duration %jd seconds"
argument_list|,
name|ipsrc
argument_list|,
name|luser
argument_list|,
call|(
name|intmax_t
call|)
argument_list|(
name|Tend
operator|.
name|tv_sec
operator|-
name|Tstart
operator|.
name|tv_sec
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"removed %s, user %s - duration %ld seconds"
argument_list|,
name|ipsrc
argument_list|,
name|luser
argument_list|,
name|Tend
operator|.
name|tv_sec
operator|-
name|Tstart
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|no_mem
label|:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|error
label|:
name|free
argument_list|(
name|fdpath
argument_list|)
expr_stmt|;
name|fdpath
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|rsn
argument_list|)
expr_stmt|;
name|rsn
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|userstr
argument_list|)
expr_stmt|;
name|userstr
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|ipstr
argument_list|)
expr_stmt|;
name|ipstr
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|fn
operator|=
name|NULL
expr_stmt|;
name|infile
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add/remove this IP from the "authpf_users" table.  */
end_comment

begin_function
specifier|static
name|int
name|change_table
parameter_list|(
name|int
name|add
parameter_list|,
specifier|const
name|char
modifier|*
name|luser
parameter_list|,
specifier|const
name|char
modifier|*
name|ipsrc
parameter_list|)
block|{
name|struct
name|pfioc_table
name|io
decl_stmt|;
name|struct
name|pfr_addr
name|addr
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|io
argument_list|,
sizeof|sizeof
argument_list|(
name|io
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|io
operator|.
name|pfrio_table
operator|.
name|pfrt_name
argument_list|,
name|tablename
argument_list|,
sizeof|sizeof
argument_list|(
name|io
operator|.
name|pfrio_table
argument_list|)
argument_list|)
expr_stmt|;
name|io
operator|.
name|pfrio_buffer
operator|=
operator|&
name|addr
expr_stmt|;
name|io
operator|.
name|pfrio_esize
operator|=
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|io
operator|.
name|pfrio_size
operator|=
literal|1
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipsrc
operator|==
name|NULL
operator|||
operator|!
name|ipsrc
index|[
literal|0
index|]
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET
argument_list|,
name|ipsrc
argument_list|,
operator|&
name|addr
operator|.
name|pfra_ip4addr
argument_list|)
operator|==
literal|1
condition|)
block|{
name|addr
operator|.
name|pfra_af
operator|=
name|AF_INET
expr_stmt|;
name|addr
operator|.
name|pfra_net
operator|=
literal|32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|ipsrc
argument_list|,
operator|&
name|addr
operator|.
name|pfra_ip6addr
argument_list|)
operator|==
literal|1
condition|)
block|{
name|addr
operator|.
name|pfra_af
operator|=
name|AF_INET6
expr_stmt|;
name|addr
operator|.
name|pfra_net
operator|=
literal|128
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"invalid ipsrc"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|add
condition|?
name|DIOCRADDADDRS
else|:
name|DIOCRDELADDRS
argument_list|,
operator|&
name|io
argument_list|)
operator|&&
name|errno
operator|!=
name|ESRCH
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot %s %s from table %s: %s"
argument_list|,
name|add
condition|?
literal|"add"
else|:
literal|"remove"
argument_list|,
name|ipsrc
argument_list|,
name|tablename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is to kill off states that would otherwise be left behind stateful  * rules. This means we don't need to allow in more traffic than we really  * want to, since we don't have to worry about any luser sessions lasting  * longer than their ssh session. This function is based on  * pfctl_kill_states from pfctl.  */
end_comment

begin_function
specifier|static
name|void
name|authpf_kill_states
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pfioc_state_kill
name|psk
decl_stmt|;
name|struct
name|pf_addr
name|target
decl_stmt|;
name|memset
argument_list|(
operator|&
name|psk
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|psk
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|target
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET
argument_list|,
name|ipsrc
argument_list|,
operator|&
name|target
operator|.
name|v4
argument_list|)
operator|==
literal|1
condition|)
name|psk
operator|.
name|psk_af
operator|=
name|AF_INET
expr_stmt|;
elseif|else
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|ipsrc
argument_list|,
operator|&
name|target
operator|.
name|v6
argument_list|)
operator|==
literal|1
condition|)
name|psk
operator|.
name|psk_af
operator|=
name|AF_INET6
expr_stmt|;
else|else
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"inet_pton(%s) failed"
argument_list|,
name|ipsrc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Kill all states from ipsrc */
name|memcpy
argument_list|(
operator|&
name|psk
operator|.
name|psk_src
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
argument_list|,
operator|&
name|target
argument_list|,
sizeof|sizeof
argument_list|(
name|psk
operator|.
name|psk_src
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|psk
operator|.
name|psk_src
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|psk
operator|.
name|psk_src
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCKILLSTATES
argument_list|,
operator|&
name|psk
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"DIOCKILLSTATES failed (%m)"
argument_list|)
expr_stmt|;
comment|/* Kill all states to ipsrc */
name|memset
argument_list|(
operator|&
name|psk
operator|.
name|psk_src
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|psk
operator|.
name|psk_src
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|psk
operator|.
name|psk_dst
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
argument_list|,
operator|&
name|target
argument_list|,
sizeof|sizeof
argument_list|(
name|psk
operator|.
name|psk_dst
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|psk
operator|.
name|psk_dst
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|psk
operator|.
name|psk_dst
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCKILLSTATES
argument_list|,
operator|&
name|psk
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"DIOCKILLSTATES failed (%m)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* signal handler that makes us go away properly */
end_comment

begin_function
specifier|static
name|void
name|need_death
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|want_death
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * function that removes our stuff when we go away.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_function
specifier|static
name|__dead2
name|void
else|#
directive|else
specifier|static
name|__dead
name|void
endif|#
directive|endif
name|do_death
parameter_list|(
name|int
name|active
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|active
condition|)
block|{
name|change_filter
argument_list|(
literal|0
argument_list|,
name|luser
argument_list|,
name|ipsrc
argument_list|)
expr_stmt|;
name|change_table
argument_list|(
literal|0
argument_list|,
name|luser
argument_list|,
name|ipsrc
argument_list|)
expr_stmt|;
name|authpf_kill_states
argument_list|()
expr_stmt|;
name|remove_stale_rulesets
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|pidfp
condition|)
name|ftruncate
argument_list|(
name|fileno
argument_list|(
name|pidfp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pidfile
index|[
literal|0
index|]
condition|)
if|if
condition|(
name|unlink
argument_list|(
name|pidfile
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot unlink %s (%m)"
argument_list|,
name|pidfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

