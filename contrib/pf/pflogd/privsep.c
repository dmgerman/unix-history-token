begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: privsep.c,v 1.13 2004/12/22 09:21:02 otto Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 2003 Can Erkin Acar  * Copyright (c) 2003 Anil Madhavapeddy<anil@recoil.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<pcap.h>
end_include

begin_include
include|#
directive|include
file|<pcap-int.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"pflogd.h"
end_include

begin_enum
enum|enum
name|cmd_types
block|{
name|PRIV_SET_SNAPLEN
block|,
comment|/* set the snaplength */
name|PRIV_OPEN_LOG
comment|/* open logfile for appending */
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|int
name|priv_fd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|pid_t
name|child_pid
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|sig_atomic_t
name|gotsig_chld
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|sig_pass_to_chld
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sig_chld
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|may_read
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|must_read
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|must_write
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_snaplen
parameter_list|(
name|int
name|snap
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* bpf filter expression common to parent and child */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|filter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|errbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|pcap_t
modifier|*
name|hpcap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* based on syslogd privsep */
end_comment

begin_function
name|int
name|priv_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|fd
decl_stmt|,
name|socks
index|[
literal|2
index|]
decl_stmt|,
name|cmd
decl_stmt|;
name|int
name|snaplen
decl_stmt|,
name|ret
decl_stmt|,
name|olderrno
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NSIG
condition|;
name|i
operator|++
control|)
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|_NSIG
condition|;
name|i
operator|++
control|)
endif|#
directive|endif
name|signal
argument_list|(
name|i
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* Create sockets */
if|if
condition|(
name|socketpair
argument_list|(
name|AF_LOCAL
argument_list|,
name|SOCK_STREAM
argument_list|,
name|PF_UNSPEC
argument_list|,
name|socks
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"socketpair() failed"
argument_list|)
expr_stmt|;
name|pw
operator|=
name|getpwnam
argument_list|(
literal|"_pflogd"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unknown user _pflogd"
argument_list|)
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
name|child_pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|child_pid
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fork() failed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|child_pid
condition|)
block|{
name|gid_t
name|gidset
index|[
literal|1
index|]
decl_stmt|;
comment|/* Child - drop privileges and return */
if|if
condition|(
name|chroot
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"unable to chroot"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
literal|"/"
argument_list|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"unable to chdir"
argument_list|)
expr_stmt|;
name|gidset
index|[
literal|0
index|]
operator|=
name|pw
operator|->
name|pw_gid
expr_stmt|;
if|if
condition|(
name|setgroups
argument_list|(
literal|1
argument_list|,
name|gidset
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"setgroups() failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|setegid
argument_list|(
name|pw
operator|->
name|pw_gid
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"setegid() failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|setgid
argument_list|(
name|pw
operator|->
name|pw_gid
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"setgid() failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|seteuid
argument_list|(
name|pw
operator|->
name|pw_uid
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"seteuid() failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|setuid
argument_list|(
name|pw
operator|->
name|pw_uid
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"setuid() failed"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|socks
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|priv_fd
operator|=
name|socks
index|[
literal|1
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Father */
comment|/* Pass ALRM/TERM/HUP/INT/QUIT through to child, and accept CHLD */
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|sig_pass_to_chld
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|sig_pass_to_chld
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|sig_pass_to_chld
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|sig_pass_to_chld
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|sig_pass_to_chld
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|sig_chld
argument_list|)
expr_stmt|;
name|setproctitle
argument_list|(
literal|"[priv]"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|socks
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|gotsig_chld
condition|)
block|{
if|if
condition|(
name|may_read
argument_list|(
name|socks
index|[
literal|0
index|]
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
condition|)
break|break;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|PRIV_SET_SNAPLEN
case|:
name|logmsg
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"[priv]: msg PRIV_SET_SNAPLENGTH received"
argument_list|)
expr_stmt|;
name|must_read
argument_list|(
name|socks
index|[
literal|0
index|]
argument_list|,
operator|&
name|snaplen
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|set_snaplen
argument_list|(
name|snaplen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"[priv]: set_snaplen failed for snaplen %d"
argument_list|,
name|snaplen
argument_list|)
expr_stmt|;
block|}
name|must_write
argument_list|(
name|socks
index|[
literal|0
index|]
argument_list|,
operator|&
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRIV_OPEN_LOG
case|:
name|logmsg
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"[priv]: msg PRIV_OPEN_LOG received"
argument_list|)
expr_stmt|;
comment|/* create or append logs but do not follow symlinks */
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_APPEND
operator||
name|O_NONBLOCK
operator||
name|O_NOFOLLOW
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
name|olderrno
operator|=
name|errno
expr_stmt|;
name|send_fd
argument_list|(
name|socks
index|[
literal|0
index|]
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|logmsg
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"[priv]: failed to open %s: %s"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|olderrno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"[priv]: unknown command %d"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* this is called from parent */
end_comment

begin_function
specifier|static
name|int
name|set_snaplen
parameter_list|(
name|int
name|snap
parameter_list|)
block|{
if|if
condition|(
name|hpcap
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|hpcap
operator|->
name|snapshot
operator|=
name|snap
expr_stmt|;
name|set_pcap_filter
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * send the snaplength to privileged process  */
end_comment

begin_function
name|int
name|priv_set_snaplen
parameter_list|(
name|int
name|snaplen
parameter_list|)
block|{
name|int
name|cmd
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
name|priv_fd
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: called from privileged portion"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|PRIV_SET_SNAPLEN
expr_stmt|;
name|must_write
argument_list|(
name|priv_fd
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|must_write
argument_list|(
name|priv_fd
argument_list|,
operator|&
name|snaplen
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|must_read
argument_list|(
name|priv_fd
argument_list|,
operator|&
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* also set hpcap->snapshot in child */
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|hpcap
operator|->
name|snapshot
operator|=
name|snaplen
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Open log-file */
end_comment

begin_function
name|int
name|priv_open_log
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|cmd
decl_stmt|,
name|fd
decl_stmt|;
if|if
condition|(
name|priv_fd
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: called from privileged portion"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|PRIV_OPEN_LOG
expr_stmt|;
name|must_write
argument_list|(
name|priv_fd
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|fd
operator|=
name|receive_fd
argument_list|(
name|priv_fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If priv parent gets a TERM or HUP, pass it through to child instead */
end_comment

begin_function
specifier|static
name|void
name|sig_pass_to_chld
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|int
name|oerrno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|child_pid
operator|!=
operator|-
literal|1
condition|)
name|kill
argument_list|(
name|child_pid
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|errno
operator|=
name|oerrno
expr_stmt|;
block|}
end_function

begin_comment
comment|/* if parent gets a SIGCHLD, it will exit */
end_comment

begin_function
specifier|static
name|void
name|sig_chld
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|gotsig_chld
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read all data or return 1 for error.  */
end_comment

begin_function
specifier|static
name|int
name|may_read
parameter_list|(
name|int
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
name|buf
decl_stmt|;
name|ssize_t
name|res
decl_stmt|,
name|pos
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|n
operator|>
name|pos
condition|)
block|{
name|res
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|s
operator|+
name|pos
argument_list|,
name|n
operator|-
name|pos
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|res
condition|)
block|{
case|case
operator|-
literal|1
case|:
if|if
condition|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
condition|)
continue|continue;
case|case
literal|0
case|:
return|return
operator|(
literal|1
operator|)
return|;
default|default:
name|pos
operator|+=
name|res
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read data with the assertion that it all must come through, or  * else abort the process.  Based on atomicio() from openssh. */
end_comment

begin_function
specifier|static
name|void
name|must_read
parameter_list|(
name|int
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
name|buf
decl_stmt|;
name|ssize_t
name|res
decl_stmt|,
name|pos
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|n
operator|>
name|pos
condition|)
block|{
name|res
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|s
operator|+
name|pos
argument_list|,
name|n
operator|-
name|pos
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|res
condition|)
block|{
case|case
operator|-
literal|1
case|:
if|if
condition|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
condition|)
continue|continue;
case|case
literal|0
case|:
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
default|default:
name|pos
operator|+=
name|res
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Write data with the assertion that it all has to be written, or  * else abort the process.  Based on atomicio() from openssh. */
end_comment

begin_function
specifier|static
name|void
name|must_write
parameter_list|(
name|int
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
name|buf
decl_stmt|;
name|ssize_t
name|res
decl_stmt|,
name|pos
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|n
operator|>
name|pos
condition|)
block|{
name|res
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|s
operator|+
name|pos
argument_list|,
name|n
operator|-
name|pos
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|res
condition|)
block|{
case|case
operator|-
literal|1
case|:
if|if
condition|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
condition|)
continue|continue;
case|case
literal|0
case|:
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
default|default:
name|pos
operator|+=
name|res
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

