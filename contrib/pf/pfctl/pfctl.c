begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: pfctl.c,v 1.188 2003/08/29 21:47:36 cedric Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2001 Daniel Hartmeier  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *    - Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *    - Redistributions in binary form must reproduce the above  *      copyright notice, this list of conditions and the following  *      disclaimer in the documentation and/or other materials provided  *      with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE  * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<net/pfvar.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<altq/altq.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"pfctl_parser.h"
end_include

begin_include
include|#
directive|include
file|"pfctl.h"
end_include

begin_function_decl
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_enable
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_disable
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_clear_stats
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_clear_rules
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_clear_nat
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_clear_altq
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_clear_states
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_kill_states
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_get_pool
parameter_list|(
name|int
parameter_list|,
name|struct
name|pf_pool
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|,
name|u_int32_t
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pfctl_print_rule_counters
parameter_list|(
name|struct
name|pf_rule
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_show_rules
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_show_nat
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_show_states
parameter_list|(
name|int
parameter_list|,
name|u_int8_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_show_status
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_show_timeouts
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_show_limits
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_debug
parameter_list|(
name|int
parameter_list|,
name|u_int32_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_clear_rule_counters
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_test_altqsupport
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pfctl_show_anchors
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|const
name|char
modifier|*
name|pfctl_lookup_option
parameter_list|(
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|const
name|char
modifier|*
name|clearopt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|rulesopt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|showopt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|debugopt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|anchoropt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tableopt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|tblcmdopt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|state_killers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|state_kill
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|loadopt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|altqsupport
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dev
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|infile
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|index
decl_stmt|;
block|}
name|pf_limits
index|[]
init|=
block|{
block|{
literal|"states"
block|,
name|PF_LIMIT_STATES
block|}
block|,
block|{
literal|"frags"
block|,
name|PF_LIMIT_FRAGS
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pf_hint
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|timeout
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|pf_hint
name|pf_hint_normal
index|[]
init|=
block|{
block|{
literal|"tcp.first"
block|,
literal|2
operator|*
literal|60
block|}
block|,
block|{
literal|"tcp.opening"
block|,
literal|30
block|}
block|,
block|{
literal|"tcp.established"
block|,
literal|24
operator|*
literal|60
operator|*
literal|60
block|}
block|,
block|{
literal|"tcp.closing"
block|,
literal|15
operator|*
literal|60
block|}
block|,
block|{
literal|"tcp.finwait"
block|,
literal|45
block|}
block|,
block|{
literal|"tcp.closed"
block|,
literal|90
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|pf_hint
name|pf_hint_satellite
index|[]
init|=
block|{
block|{
literal|"tcp.first"
block|,
literal|3
operator|*
literal|60
block|}
block|,
block|{
literal|"tcp.opening"
block|,
literal|30
operator|+
literal|5
block|}
block|,
block|{
literal|"tcp.established"
block|,
literal|24
operator|*
literal|60
operator|*
literal|60
block|}
block|,
block|{
literal|"tcp.closing"
block|,
literal|15
operator|*
literal|60
operator|+
literal|5
block|}
block|,
block|{
literal|"tcp.finwait"
block|,
literal|45
operator|+
literal|5
block|}
block|,
block|{
literal|"tcp.closed"
block|,
literal|90
operator|+
literal|5
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|pf_hint
name|pf_hint_conservative
index|[]
init|=
block|{
block|{
literal|"tcp.first"
block|,
literal|60
operator|*
literal|60
block|}
block|,
block|{
literal|"tcp.opening"
block|,
literal|15
operator|*
literal|60
block|}
block|,
block|{
literal|"tcp.established"
block|,
literal|5
operator|*
literal|24
operator|*
literal|60
operator|*
literal|60
block|}
block|,
block|{
literal|"tcp.closing"
block|,
literal|60
operator|*
literal|60
block|}
block|,
block|{
literal|"tcp.finwait"
block|,
literal|10
operator|*
literal|60
block|}
block|,
block|{
literal|"tcp.closed"
block|,
literal|3
operator|*
literal|60
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|pf_hint
name|pf_hint_aggressive
index|[]
init|=
block|{
block|{
literal|"tcp.first"
block|,
literal|30
block|}
block|,
block|{
literal|"tcp.opening"
block|,
literal|5
block|}
block|,
block|{
literal|"tcp.established"
block|,
literal|5
operator|*
literal|60
operator|*
literal|60
block|}
block|,
block|{
literal|"tcp.closing"
block|,
literal|60
block|}
block|,
block|{
literal|"tcp.finwait"
block|,
literal|30
block|}
block|,
block|{
literal|"tcp.closed"
block|,
literal|30
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|struct
name|pf_hint
modifier|*
name|hint
decl_stmt|;
block|}
name|pf_hints
index|[]
init|=
block|{
block|{
literal|"normal"
block|,
name|pf_hint_normal
block|}
block|,
block|{
literal|"satellite"
block|,
name|pf_hint_satellite
block|}
block|,
block|{
literal|"high-latency"
block|,
name|pf_hint_satellite
block|}
block|,
block|{
literal|"conservative"
block|,
name|pf_hint_conservative
block|}
block|,
block|{
literal|"aggressive"
block|,
name|pf_hint_aggressive
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|clearopt_list
index|[]
init|=
block|{
literal|"nat"
block|,
literal|"queue"
block|,
literal|"rules"
block|,
literal|"state"
block|,
literal|"info"
block|,
literal|"Tables"
block|,
literal|"osfp"
block|,
literal|"all"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|showopt_list
index|[]
init|=
block|{
literal|"nat"
block|,
literal|"queue"
block|,
literal|"rules"
block|,
literal|"Anchors"
block|,
literal|"state"
block|,
literal|"info"
block|,
literal|"labels"
block|,
literal|"timeouts"
block|,
literal|"memory"
block|,
literal|"Tables"
block|,
literal|"osfp"
block|,
literal|"all"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|tblcmdopt_list
index|[]
init|=
block|{
literal|"kill"
block|,
literal|"flush"
block|,
literal|"add"
block|,
literal|"delete"
block|,
literal|"load"
block|,
literal|"replace"
block|,
literal|"show"
block|,
literal|"test"
block|,
literal|"zero"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|debugopt_list
index|[]
init|=
block|{
literal|"none"
block|,
literal|"urgent"
block|,
literal|"misc"
block|,
literal|"loud"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
specifier|extern
name|char
modifier|*
name|__progname
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-AdeghnNqrROvz] "
argument_list|,
name|__progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[-a anchor[:ruleset]] [-D macro=value]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"             "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[-f file] [-F modifier] [-k host] [-s modifier]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"             "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[-t table] [-T command [address ...]] [-x level]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pfctl_enable
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCSTART
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EEXIST
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"pf already enabled"
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCSTART"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pf enabled\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|altqsupport
operator|&&
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCSTARTALTQ
argument_list|)
condition|)
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCSTARTALTQ"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_disable
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCSTOP
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"pf not enabled"
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCSTOP"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pf disabled\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|altqsupport
operator|&&
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCSTOPALTQ
argument_list|)
condition|)
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCSTOPALTQ"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_clear_stats
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCCLRSTATUS
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCCLRSTATUS"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pf: statistics cleared\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_clear_rules
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|,
name|char
modifier|*
name|anchorname
parameter_list|,
name|char
modifier|*
name|rulesetname
parameter_list|)
block|{
name|struct
name|pfioc_rule
name|pr
decl_stmt|;
if|if
condition|(
operator|*
name|anchorname
operator|&&
operator|!
operator|*
name|rulesetname
condition|)
block|{
name|struct
name|pfioc_ruleset
name|pr
decl_stmt|;
name|int
name|mnr
decl_stmt|,
name|nr
decl_stmt|,
name|r
decl_stmt|;
name|memset
argument_list|(
operator|&
name|pr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pr
operator|.
name|anchor
argument_list|,
name|anchorname
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
operator|.
name|anchor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETRULESETS
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINVAL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No rulesets in anchor '%s'.\n"
argument_list|,
name|anchorname
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCGETRULESETS"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mnr
operator|=
name|pr
operator|.
name|nr
expr_stmt|;
for|for
control|(
name|nr
operator|=
name|mnr
operator|-
literal|1
init|;
name|nr
operator|>=
literal|0
condition|;
operator|--
name|nr
control|)
block|{
name|pr
operator|.
name|nr
operator|=
name|nr
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETRULESET
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCGETRULESET"
argument_list|)
expr_stmt|;
name|r
operator|=
name|pfctl_clear_rules
argument_list|(
name|dev
argument_list|,
name|opts
operator||
name|PF_OPT_QUIET
argument_list|,
name|anchorname
argument_list|,
name|pr
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rules cleared\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
operator|&
name|pr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pr
operator|.
name|anchor
argument_list|,
name|anchorname
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
operator|.
name|anchor
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pr
operator|.
name|ruleset
argument_list|,
name|rulesetname
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
operator|.
name|ruleset
argument_list|)
argument_list|)
expr_stmt|;
name|pr
operator|.
name|rule
operator|.
name|action
operator|=
name|PF_SCRUB
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCBEGINRULES
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCBEGINRULES"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCCOMMITRULES
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCCOMMITRULES"
argument_list|)
expr_stmt|;
name|pr
operator|.
name|rule
operator|.
name|action
operator|=
name|PF_PASS
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCBEGINRULES
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCBEGINRULES"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCCOMMITRULES
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCCOMMITRULES"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rules cleared\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_clear_nat
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|,
name|char
modifier|*
name|anchorname
parameter_list|,
name|char
modifier|*
name|rulesetname
parameter_list|)
block|{
name|struct
name|pfioc_rule
name|pr
decl_stmt|;
if|if
condition|(
operator|*
name|anchorname
operator|&&
operator|!
operator|*
name|rulesetname
condition|)
block|{
name|struct
name|pfioc_ruleset
name|pr
decl_stmt|;
name|int
name|mnr
decl_stmt|,
name|nr
decl_stmt|,
name|r
decl_stmt|;
name|memset
argument_list|(
operator|&
name|pr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pr
operator|.
name|anchor
argument_list|,
name|anchorname
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
operator|.
name|anchor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETRULESETS
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINVAL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No rulesets in anchor '%s'.\n"
argument_list|,
name|anchorname
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCGETRULESETS"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mnr
operator|=
name|pr
operator|.
name|nr
expr_stmt|;
for|for
control|(
name|nr
operator|=
name|mnr
operator|-
literal|1
init|;
name|nr
operator|>=
literal|0
condition|;
operator|--
name|nr
control|)
block|{
name|pr
operator|.
name|nr
operator|=
name|nr
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETRULESET
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCGETRULESET"
argument_list|)
expr_stmt|;
name|r
operator|=
name|pfctl_clear_nat
argument_list|(
name|dev
argument_list|,
name|opts
operator||
name|PF_OPT_QUIET
argument_list|,
name|anchorname
argument_list|,
name|pr
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nat cleared\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
operator|&
name|pr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pr
operator|.
name|anchor
argument_list|,
name|anchorname
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
operator|.
name|anchor
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pr
operator|.
name|ruleset
argument_list|,
name|rulesetname
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
operator|.
name|ruleset
argument_list|)
argument_list|)
expr_stmt|;
name|pr
operator|.
name|rule
operator|.
name|action
operator|=
name|PF_NAT
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCBEGINRULES
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCBEGINRULES"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCCOMMITRULES
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCCOMMITRULES"
argument_list|)
expr_stmt|;
name|pr
operator|.
name|rule
operator|.
name|action
operator|=
name|PF_BINAT
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCBEGINRULES
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCBEGINRULES"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCCOMMITRULES
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCCOMMITRULES"
argument_list|)
expr_stmt|;
name|pr
operator|.
name|rule
operator|.
name|action
operator|=
name|PF_RDR
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCBEGINRULES
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCBEGINRULES"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCCOMMITRULES
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCCOMMITRULES"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nat cleared\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_clear_altq
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
name|struct
name|pfioc_altq
name|pa
decl_stmt|;
if|if
condition|(
operator|!
name|altqsupport
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|memset
argument_list|(
operator|&
name|pa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCBEGINALTQS
argument_list|,
operator|&
name|pa
operator|.
name|ticket
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCBEGINALTQS"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCCOMMITALTQS
argument_list|,
operator|&
name|pa
operator|.
name|ticket
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCCOMMITALTQS"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"altq cleared\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_clear_states
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCCLRSTATES
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCCLRSTATES"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"states cleared\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_kill_states
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
name|struct
name|pfioc_state_kill
name|psk
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|res
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|resp
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|sockaddr
name|last_src
decl_stmt|,
name|last_dst
decl_stmt|;
name|int
name|killed
decl_stmt|,
name|sources
decl_stmt|,
name|dests
decl_stmt|;
name|int
name|ret_ga
decl_stmt|;
name|killed
operator|=
name|sources
operator|=
name|dests
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|psk
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|psk
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|psk
operator|.
name|psk_src
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|psk
operator|.
name|psk_src
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|last_src
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|last_src
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|last_dst
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|last_dst
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret_ga
operator|=
name|getaddrinfo
argument_list|(
name|state_kill
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|res
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"getaddrinfo: %s"
argument_list|,
name|gai_strerror
argument_list|(
name|ret_ga
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
for|for
control|(
name|resp
index|[
literal|0
index|]
operator|=
name|res
index|[
literal|0
index|]
init|;
name|resp
index|[
literal|0
index|]
condition|;
name|resp
index|[
literal|0
index|]
operator|=
name|resp
index|[
literal|0
index|]
operator|->
name|ai_next
control|)
block|{
if|if
condition|(
name|resp
index|[
literal|0
index|]
operator|->
name|ai_addr
operator|==
name|NULL
condition|)
continue|continue;
comment|/* We get lots of duplicates.  Catch the easy ones */
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|last_src
argument_list|,
name|resp
index|[
literal|0
index|]
operator|->
name|ai_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|last_src
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|last_src
operator|=
operator|*
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|resp
index|[
literal|0
index|]
operator|->
name|ai_addr
expr_stmt|;
name|psk
operator|.
name|psk_af
operator|=
name|resp
index|[
literal|0
index|]
operator|->
name|ai_family
expr_stmt|;
name|sources
operator|++
expr_stmt|;
if|if
condition|(
name|psk
operator|.
name|psk_af
operator|==
name|AF_INET
condition|)
name|psk
operator|.
name|psk_src
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
operator|.
name|v4
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|resp
index|[
literal|0
index|]
operator|->
name|ai_addr
operator|)
operator|->
name|sin_addr
expr_stmt|;
elseif|else
if|if
condition|(
name|psk
operator|.
name|psk_af
operator|==
name|AF_INET6
condition|)
name|psk
operator|.
name|psk_src
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
operator|.
name|v6
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|resp
index|[
literal|0
index|]
operator|->
name|ai_addr
operator|)
operator|->
name|sin6_addr
expr_stmt|;
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Unknown address family %d"
argument_list|,
name|psk
operator|.
name|psk_af
argument_list|)
expr_stmt|;
if|if
condition|(
name|state_killers
operator|>
literal|1
condition|)
block|{
name|dests
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|psk
operator|.
name|psk_dst
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|psk
operator|.
name|psk_dst
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|last_dst
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|last_dst
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret_ga
operator|=
name|getaddrinfo
argument_list|(
name|state_kill
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|res
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"getaddrinfo: %s"
argument_list|,
name|gai_strerror
argument_list|(
name|ret_ga
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
for|for
control|(
name|resp
index|[
literal|1
index|]
operator|=
name|res
index|[
literal|1
index|]
init|;
name|resp
index|[
literal|1
index|]
condition|;
name|resp
index|[
literal|1
index|]
operator|=
name|resp
index|[
literal|1
index|]
operator|->
name|ai_next
control|)
block|{
if|if
condition|(
name|resp
index|[
literal|1
index|]
operator|->
name|ai_addr
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|psk
operator|.
name|psk_af
operator|!=
name|resp
index|[
literal|1
index|]
operator|->
name|ai_family
condition|)
continue|continue;
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|last_dst
argument_list|,
name|resp
index|[
literal|1
index|]
operator|->
name|ai_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|last_dst
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|last_dst
operator|=
operator|*
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|resp
index|[
literal|1
index|]
operator|->
name|ai_addr
expr_stmt|;
name|dests
operator|++
expr_stmt|;
if|if
condition|(
name|psk
operator|.
name|psk_af
operator|==
name|AF_INET
condition|)
name|psk
operator|.
name|psk_dst
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
operator|.
name|v4
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|resp
index|[
literal|1
index|]
operator|->
name|ai_addr
operator|)
operator|->
name|sin_addr
expr_stmt|;
elseif|else
if|if
condition|(
name|psk
operator|.
name|psk_af
operator|==
name|AF_INET6
condition|)
name|psk
operator|.
name|psk_dst
operator|.
name|addr
operator|.
name|v
operator|.
name|a
operator|.
name|addr
operator|.
name|v6
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|resp
index|[
literal|1
index|]
operator|->
name|ai_addr
operator|)
operator|->
name|sin6_addr
expr_stmt|;
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Unknown address family %d"
argument_list|,
name|psk
operator|.
name|psk_af
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCKILLSTATES
argument_list|,
operator|&
name|psk
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCKILLSTATES"
argument_list|)
expr_stmt|;
name|killed
operator|+=
name|psk
operator|.
name|psk_af
expr_stmt|;
comment|/* fixup psk.psk_af */
name|psk
operator|.
name|psk_af
operator|=
name|resp
index|[
literal|1
index|]
operator|->
name|ai_family
expr_stmt|;
block|}
name|freeaddrinfo
argument_list|(
name|res
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCKILLSTATES
argument_list|,
operator|&
name|psk
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCKILLSTATES"
argument_list|)
expr_stmt|;
name|killed
operator|+=
name|psk
operator|.
name|psk_af
expr_stmt|;
comment|/* fixup psk.psk_af */
name|psk
operator|.
name|psk_af
operator|=
name|res
index|[
literal|0
index|]
operator|->
name|ai_family
expr_stmt|;
block|}
block|}
name|freeaddrinfo
argument_list|(
name|res
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"killed %d states from %d sources and %d "
literal|"destinations\n"
argument_list|,
name|killed
argument_list|,
name|sources
argument_list|,
name|dests
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_get_pool
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|pf_pool
modifier|*
name|pool
parameter_list|,
name|u_int32_t
name|nr
parameter_list|,
name|u_int32_t
name|ticket
parameter_list|,
name|int
name|r_action
parameter_list|,
name|char
modifier|*
name|anchorname
parameter_list|,
name|char
modifier|*
name|rulesetname
parameter_list|)
block|{
name|struct
name|pfioc_pooladdr
name|pp
decl_stmt|;
name|struct
name|pf_pooladdr
modifier|*
name|pa
decl_stmt|;
name|u_int32_t
name|pnr
decl_stmt|,
name|mpnr
decl_stmt|;
name|memset
argument_list|(
operator|&
name|pp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pp
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pp
operator|.
name|anchor
argument_list|,
name|anchorname
argument_list|,
sizeof|sizeof
argument_list|(
name|pp
operator|.
name|anchor
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pp
operator|.
name|ruleset
argument_list|,
name|rulesetname
argument_list|,
sizeof|sizeof
argument_list|(
name|pp
operator|.
name|ruleset
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|.
name|r_action
operator|=
name|r_action
expr_stmt|;
name|pp
operator|.
name|r_num
operator|=
name|nr
expr_stmt|;
name|pp
operator|.
name|ticket
operator|=
name|ticket
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETADDRS
argument_list|,
operator|&
name|pp
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"DIOCGETADDRS"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mpnr
operator|=
name|pp
operator|.
name|nr
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|)
expr_stmt|;
for|for
control|(
name|pnr
operator|=
literal|0
init|;
name|pnr
operator|<
name|mpnr
condition|;
operator|++
name|pnr
control|)
block|{
name|pp
operator|.
name|nr
operator|=
name|pnr
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETADDR
argument_list|,
operator|&
name|pp
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"DIOCGETADDR"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pa
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_pooladdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|pp
operator|.
name|addr
argument_list|,
name|pa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_pooladdr
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|,
name|pa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pfctl_clear_pool
parameter_list|(
name|struct
name|pf_pool
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|pf_pooladdr
modifier|*
name|pa
decl_stmt|;
while|while
condition|(
operator|(
name|pa
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pool
operator|->
name|list
argument_list|,
name|pa
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pa
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pfctl_print_rule_counters
parameter_list|(
name|struct
name|pf_rule
modifier|*
name|rule
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
if|if
condition|(
name|opts
operator|&
name|PF_OPT_DEBUG
condition|)
block|{
specifier|const
name|char
modifier|*
name|t
index|[
name|PF_SKIP_COUNT
index|]
init|=
block|{
literal|"i"
block|,
literal|"d"
block|,
literal|"f"
block|,
literal|"p"
block|,
literal|"sa"
block|,
literal|"sp"
block|,
literal|"da"
block|,
literal|"dp"
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"  [ Skip steps: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PF_SKIP_COUNT
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|rule
operator|->
name|skip
index|[
name|i
index|]
operator|.
name|nr
operator|==
name|rule
operator|->
name|nr
operator|+
literal|1
condition|)
continue|continue;
name|printf
argument_list|(
literal|"%s="
argument_list|,
name|t
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|skip
index|[
name|i
index|]
operator|.
name|nr
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"end "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%u "
argument_list|,
name|rule
operator|->
name|skip
index|[
name|i
index|]
operator|.
name|nr
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"]\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  [ queue: qname=%s qid=%u pqname=%s pqid=%u ]\n"
argument_list|,
name|rule
operator|->
name|qname
argument_list|,
name|rule
operator|->
name|qid
argument_list|,
name|rule
operator|->
name|pqname
argument_list|,
name|rule
operator|->
name|pqid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opts
operator|&
name|PF_OPT_VERBOSE
condition|)
name|printf
argument_list|(
literal|"  [ Evaluations: %-8llu  Packets: %-8llu  "
literal|"Bytes: %-10llu  States: %-6u]\n"
argument_list|,
name|rule
operator|->
name|evaluations
argument_list|,
name|rule
operator|->
name|packets
argument_list|,
name|rule
operator|->
name|bytes
argument_list|,
name|rule
operator|->
name|states
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pfctl_show_rules
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|,
name|int
name|format
parameter_list|,
name|char
modifier|*
name|anchorname
parameter_list|,
name|char
modifier|*
name|rulesetname
parameter_list|)
block|{
name|struct
name|pfioc_rule
name|pr
decl_stmt|;
name|u_int32_t
name|nr
decl_stmt|,
name|mnr
decl_stmt|;
name|int
name|rule_numbers
init|=
name|opts
operator|&
operator|(
name|PF_OPT_VERBOSE2
operator||
name|PF_OPT_DEBUG
operator|)
decl_stmt|;
if|if
condition|(
operator|*
name|anchorname
operator|&&
operator|!
operator|*
name|rulesetname
condition|)
block|{
name|struct
name|pfioc_ruleset
name|pr
decl_stmt|;
name|int
name|r
decl_stmt|;
name|memset
argument_list|(
operator|&
name|pr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pr
operator|.
name|anchor
argument_list|,
name|anchorname
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
operator|.
name|anchor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETRULESETS
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINVAL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No rulesets in anchor '%s'.\n"
argument_list|,
name|anchorname
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCGETRULESETS"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mnr
operator|=
name|pr
operator|.
name|nr
expr_stmt|;
for|for
control|(
name|nr
operator|=
literal|0
init|;
name|nr
operator|<
name|mnr
condition|;
operator|++
name|nr
control|)
block|{
name|pr
operator|.
name|nr
operator|=
name|nr
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETRULESET
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCGETRULESET"
argument_list|)
expr_stmt|;
name|r
operator|=
name|pfctl_show_rules
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|,
name|format
argument_list|,
name|anchorname
argument_list|,
name|pr
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
operator|&
name|pr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pr
operator|.
name|anchor
argument_list|,
name|anchorname
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
operator|.
name|anchor
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pr
operator|.
name|ruleset
argument_list|,
name|rulesetname
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
operator|.
name|ruleset
argument_list|)
argument_list|)
expr_stmt|;
name|pr
operator|.
name|rule
operator|.
name|action
operator|=
name|PF_SCRUB
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETRULES
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"DIOCGETRULES"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mnr
operator|=
name|pr
operator|.
name|nr
expr_stmt|;
for|for
control|(
name|nr
operator|=
literal|0
init|;
name|nr
operator|<
name|mnr
condition|;
operator|++
name|nr
control|)
block|{
name|pr
operator|.
name|nr
operator|=
name|nr
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETRULE
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"DIOCGETRULE"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|pfctl_get_pool
argument_list|(
name|dev
argument_list|,
operator|&
name|pr
operator|.
name|rule
operator|.
name|rpool
argument_list|,
name|nr
argument_list|,
name|pr
operator|.
name|ticket
argument_list|,
name|PF_SCRUB
argument_list|,
name|anchorname
argument_list|,
name|rulesetname
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|pr
operator|.
name|rule
operator|.
name|label
index|[
literal|0
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|pr
operator|.
name|rule
operator|.
name|label
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%llu %llu %llu\n"
argument_list|,
name|pr
operator|.
name|rule
operator|.
name|evaluations
argument_list|,
name|pr
operator|.
name|rule
operator|.
name|packets
argument_list|,
name|pr
operator|.
name|rule
operator|.
name|bytes
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|print_rule
argument_list|(
operator|&
name|pr
operator|.
name|rule
argument_list|,
name|rule_numbers
argument_list|)
expr_stmt|;
name|pfctl_print_rule_counters
argument_list|(
operator|&
name|pr
operator|.
name|rule
argument_list|,
name|opts
argument_list|)
expr_stmt|;
block|}
name|pfctl_clear_pool
argument_list|(
operator|&
name|pr
operator|.
name|rule
operator|.
name|rpool
argument_list|)
expr_stmt|;
block|}
name|pr
operator|.
name|rule
operator|.
name|action
operator|=
name|PF_PASS
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETRULES
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"DIOCGETRULES"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mnr
operator|=
name|pr
operator|.
name|nr
expr_stmt|;
for|for
control|(
name|nr
operator|=
literal|0
init|;
name|nr
operator|<
name|mnr
condition|;
operator|++
name|nr
control|)
block|{
name|pr
operator|.
name|nr
operator|=
name|nr
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETRULE
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"DIOCGETRULE"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|pfctl_get_pool
argument_list|(
name|dev
argument_list|,
operator|&
name|pr
operator|.
name|rule
operator|.
name|rpool
argument_list|,
name|nr
argument_list|,
name|pr
operator|.
name|ticket
argument_list|,
name|PF_PASS
argument_list|,
name|anchorname
argument_list|,
name|rulesetname
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|pr
operator|.
name|rule
operator|.
name|label
index|[
literal|0
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|pr
operator|.
name|rule
operator|.
name|label
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%llu %llu %llu\n"
argument_list|,
name|pr
operator|.
name|rule
operator|.
name|evaluations
argument_list|,
name|pr
operator|.
name|rule
operator|.
name|packets
argument_list|,
name|pr
operator|.
name|rule
operator|.
name|bytes
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|print_rule
argument_list|(
operator|&
name|pr
operator|.
name|rule
argument_list|,
name|rule_numbers
argument_list|)
expr_stmt|;
name|pfctl_print_rule_counters
argument_list|(
operator|&
name|pr
operator|.
name|rule
argument_list|,
name|opts
argument_list|)
expr_stmt|;
block|}
name|pfctl_clear_pool
argument_list|(
operator|&
name|pr
operator|.
name|rule
operator|.
name|rpool
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_show_nat
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|,
name|char
modifier|*
name|anchorname
parameter_list|,
name|char
modifier|*
name|rulesetname
parameter_list|)
block|{
name|struct
name|pfioc_rule
name|pr
decl_stmt|;
name|u_int32_t
name|mnr
decl_stmt|,
name|nr
decl_stmt|;
specifier|static
name|int
name|nattype
index|[
literal|3
index|]
init|=
block|{
name|PF_NAT
block|,
name|PF_RDR
block|,
name|PF_BINAT
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|anchorname
operator|&&
operator|!
operator|*
name|rulesetname
condition|)
block|{
name|struct
name|pfioc_ruleset
name|pr
decl_stmt|;
name|int
name|r
decl_stmt|;
name|memset
argument_list|(
operator|&
name|pr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pr
operator|.
name|anchor
argument_list|,
name|anchorname
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
operator|.
name|anchor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETRULESETS
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINVAL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No rulesets in anchor '%s'.\n"
argument_list|,
name|anchorname
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCGETRULESETS"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mnr
operator|=
name|pr
operator|.
name|nr
expr_stmt|;
for|for
control|(
name|nr
operator|=
literal|0
init|;
name|nr
operator|<
name|mnr
condition|;
operator|++
name|nr
control|)
block|{
name|pr
operator|.
name|nr
operator|=
name|nr
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETRULESET
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCGETRULESET"
argument_list|)
expr_stmt|;
name|r
operator|=
name|pfctl_show_nat
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|,
name|anchorname
argument_list|,
name|pr
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
operator|&
name|pr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pr
operator|.
name|anchor
argument_list|,
name|anchorname
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
operator|.
name|anchor
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pr
operator|.
name|ruleset
argument_list|,
name|rulesetname
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
operator|.
name|ruleset
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|pr
operator|.
name|rule
operator|.
name|action
operator|=
name|nattype
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETRULES
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"DIOCGETRULES"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mnr
operator|=
name|pr
operator|.
name|nr
expr_stmt|;
for|for
control|(
name|nr
operator|=
literal|0
init|;
name|nr
operator|<
name|mnr
condition|;
operator|++
name|nr
control|)
block|{
name|pr
operator|.
name|nr
operator|=
name|nr
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETRULE
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"DIOCGETRULE"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|pfctl_get_pool
argument_list|(
name|dev
argument_list|,
operator|&
name|pr
operator|.
name|rule
operator|.
name|rpool
argument_list|,
name|nr
argument_list|,
name|pr
operator|.
name|ticket
argument_list|,
name|nattype
index|[
name|i
index|]
argument_list|,
name|anchorname
argument_list|,
name|rulesetname
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|print_rule
argument_list|(
operator|&
name|pr
operator|.
name|rule
argument_list|,
name|opts
operator|&
name|PF_OPT_VERBOSE2
argument_list|)
expr_stmt|;
name|pfctl_print_rule_counters
argument_list|(
operator|&
name|pr
operator|.
name|rule
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_clear_pool
argument_list|(
operator|&
name|pr
operator|.
name|rule
operator|.
name|rpool
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_show_states
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_int8_t
name|proto
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
name|struct
name|pfioc_states
name|ps
decl_stmt|;
name|struct
name|pf_state
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|inbuf
init|=
name|NULL
decl_stmt|;
name|unsigned
name|len
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ps
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ps
operator|.
name|ps_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|ps
operator|.
name|ps_buf
operator|=
name|inbuf
operator|=
name|realloc
argument_list|(
name|inbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|inbuf
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"realloc"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETSTATES
argument_list|,
operator|&
name|ps
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"DIOCGETSTATES"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ps
operator|.
name|ps_len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pfioc_states
argument_list|)
operator|<
name|len
condition|)
break|break;
if|if
condition|(
name|len
operator|==
literal|0
operator|&&
name|ps
operator|.
name|ps_len
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|len
operator|==
literal|0
operator|&&
name|ps
operator|.
name|ps_len
operator|!=
literal|0
condition|)
name|len
operator|=
name|ps
operator|.
name|ps_len
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|ps_len
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* no states */
name|len
operator|*=
literal|2
expr_stmt|;
block|}
name|p
operator|=
name|ps
operator|.
name|ps_states
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ps
operator|.
name|ps_len
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|proto
operator|||
operator|(
name|p
operator|->
name|proto
operator|==
name|proto
operator|)
condition|)
name|print_state
argument_list|(
name|p
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_show_status
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|struct
name|pf_status
name|status
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETSTATUS
argument_list|,
operator|&
name|status
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"DIOCGETSTATUS"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|print_status
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_show_timeouts
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|struct
name|pfioc_tm
name|pt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|pt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pt
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pf_timeouts
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
name|pt
operator|.
name|timeout
operator|=
name|pf_timeouts
index|[
name|i
index|]
operator|.
name|timeout
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETTIMEOUT
argument_list|,
operator|&
name|pt
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCGETTIMEOUT"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-20s %10d"
argument_list|,
name|pf_timeouts
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|pt
operator|.
name|seconds
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|PFTM_ADAPTIVE_START
operator|&&
name|i
operator|<=
name|PFTM_ADAPTIVE_END
condition|)
name|printf
argument_list|(
literal|" states"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"s"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_show_limits
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|struct
name|pfioc_limit
name|pl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|pl
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pl
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pf_limits
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
name|pl
operator|.
name|index
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETLIMIT
argument_list|,
operator|&
name|pl
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCGETLIMIT"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-10s "
argument_list|,
name|pf_limits
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pl
operator|.
name|limit
operator|==
name|UINT_MAX
condition|)
name|printf
argument_list|(
literal|"unlimited\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"hard limit %6u\n"
argument_list|,
name|pl
operator|.
name|limit
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* callbacks for rule/nat/rdr/addr */
end_comment

begin_function
name|int
name|pfctl_add_pool
parameter_list|(
name|struct
name|pfctl
modifier|*
name|pf
parameter_list|,
name|struct
name|pf_pool
modifier|*
name|p
parameter_list|,
name|sa_family_t
name|af
parameter_list|)
block|{
name|struct
name|pf_pooladdr
modifier|*
name|pa
decl_stmt|;
if|if
condition|(
operator|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
name|DIOCBEGINADDRS
argument_list|,
operator|&
name|pf
operator|->
name|paddr
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCBEGINADDRS"
argument_list|)
expr_stmt|;
block|}
name|pf
operator|->
name|paddr
operator|.
name|af
operator|=
name|af
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pa
argument_list|,
argument|&p->list
argument_list|,
argument|entries
argument_list|)
block|{
name|memcpy
argument_list|(
operator|&
name|pf
operator|->
name|paddr
operator|.
name|addr
argument_list|,
name|pa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_pooladdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
name|DIOCADDADDR
argument_list|,
operator|&
name|pf
operator|->
name|paddr
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCADDADDR"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_add_rule
parameter_list|(
name|struct
name|pfctl
modifier|*
name|pf
parameter_list|,
name|struct
name|pf_rule
modifier|*
name|r
parameter_list|)
block|{
name|u_int8_t
name|rs_num
decl_stmt|;
switch|switch
condition|(
name|r
operator|->
name|action
condition|)
block|{
case|case
name|PF_SCRUB
case|:
if|if
condition|(
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_FILTER
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rs_num
operator|=
name|PF_RULESET_SCRUB
expr_stmt|;
break|break;
case|case
name|PF_DROP
case|:
case|case
name|PF_PASS
case|:
if|if
condition|(
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_FILTER
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rs_num
operator|=
name|PF_RULESET_FILTER
expr_stmt|;
break|break;
case|case
name|PF_NAT
case|:
case|case
name|PF_NONAT
case|:
if|if
condition|(
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_NAT
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rs_num
operator|=
name|PF_RULESET_NAT
expr_stmt|;
break|break;
case|case
name|PF_RDR
case|:
case|case
name|PF_NORDR
case|:
if|if
condition|(
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_NAT
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rs_num
operator|=
name|PF_RULESET_RDR
expr_stmt|;
break|break;
case|case
name|PF_BINAT
case|:
case|case
name|PF_NOBINAT
case|:
if|if
condition|(
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_NAT
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rs_num
operator|=
name|PF_RULESET_BINAT
expr_stmt|;
break|break;
default|default:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Invalid rule type"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pfctl_add_pool
argument_list|(
name|pf
argument_list|,
operator|&
name|r
operator|->
name|rpool
argument_list|,
name|r
operator|->
name|af
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|memcpy
argument_list|(
operator|&
name|pf
operator|->
name|prule
index|[
name|rs_num
index|]
operator|->
name|rule
argument_list|,
name|r
argument_list|,
sizeof|sizeof
argument_list|(
name|pf
operator|->
name|prule
index|[
name|rs_num
index|]
operator|->
name|rule
argument_list|)
argument_list|)
expr_stmt|;
name|pf
operator|->
name|prule
index|[
name|rs_num
index|]
operator|->
name|pool_ticket
operator|=
name|pf
operator|->
name|paddr
operator|.
name|ticket
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
name|DIOCADDRULE
argument_list|,
name|pf
operator|->
name|prule
index|[
name|rs_num
index|]
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCADDRULE"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_VERBOSE
condition|)
name|print_rule
argument_list|(
name|r
argument_list|,
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_VERBOSE2
argument_list|)
expr_stmt|;
name|pfctl_clear_pool
argument_list|(
operator|&
name|r
operator|->
name|rpool
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_add_altq
parameter_list|(
name|struct
name|pfctl
modifier|*
name|pf
parameter_list|,
name|struct
name|pf_altq
modifier|*
name|a
parameter_list|)
block|{
if|if
condition|(
name|altqsupport
operator|&&
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_ALTQ
operator|)
operator|!=
literal|0
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|pf
operator|->
name|paltq
operator|->
name|altq
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pf_altq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
name|DIOCADDALTQ
argument_list|,
name|pf
operator|->
name|paltq
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENXIO
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"qtype not configured"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|errno
operator|==
name|ENODEV
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: driver does not support "
literal|"altq"
argument_list|,
name|a
operator|->
name|ifname
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCADDALTQ"
argument_list|)
expr_stmt|;
block|}
block|}
name|pfaltq_store
argument_list|(
operator|&
name|pf
operator|->
name|paltq
operator|->
name|altq
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_rules
parameter_list|(
name|int
name|dev
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|opts
parameter_list|,
name|char
modifier|*
name|anchorname
parameter_list|,
name|char
modifier|*
name|rulesetname
parameter_list|)
block|{
define|#
directive|define
name|ERR
parameter_list|(
name|x
parameter_list|)
value|do { warn(x); goto _error; } while(0)
define|#
directive|define
name|ERRX
parameter_list|(
name|x
parameter_list|)
value|do { warnx(x); goto _error; } while(0)
name|FILE
modifier|*
name|fin
decl_stmt|;
name|struct
name|pfioc_rule
name|pr
index|[
name|PF_RULESET_MAX
index|]
decl_stmt|;
name|struct
name|pfioc_altq
name|pa
decl_stmt|;
name|struct
name|pfctl
name|pf
decl_stmt|;
name|struct
name|pfr_table
name|trs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|pa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pa
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pf
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|trs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|trs
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PF_RULESET_MAX
condition|;
name|i
operator|++
control|)
block|{
name|memset
argument_list|(
operator|&
name|pr
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pr
index|[
name|i
index|]
operator|.
name|anchor
argument_list|,
name|anchorname
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
index|[
name|i
index|]
operator|.
name|anchor
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pr
index|[
name|i
index|]
operator|.
name|ruleset
argument_list|,
name|rulesetname
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
index|[
name|i
index|]
operator|.
name|ruleset
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strlcpy
argument_list|(
name|trs
operator|.
name|pfrt_anchor
argument_list|,
name|anchorname
argument_list|,
sizeof|sizeof
argument_list|(
name|trs
operator|.
name|pfrt_anchor
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|trs
operator|.
name|pfrt_anchor
argument_list|)
operator|||
name|strlcpy
argument_list|(
name|trs
operator|.
name|pfrt_ruleset
argument_list|,
name|rulesetname
argument_list|,
sizeof|sizeof
argument_list|(
name|trs
operator|.
name|pfrt_ruleset
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|trs
operator|.
name|pfrt_ruleset
argument_list|)
condition|)
name|ERRX
argument_list|(
literal|"pfctl_rules: strlcpy"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fin
operator|=
name|stdin
expr_stmt|;
name|infile
operator|=
literal|"stdin"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|fin
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|infile
operator|=
name|filename
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_NAT
operator|)
operator|!=
literal|0
condition|)
block|{
name|pr
index|[
name|PF_RULESET_NAT
index|]
operator|.
name|rule
operator|.
name|action
operator|=
name|PF_NAT
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCBEGINRULES
argument_list|,
operator|&
name|pr
index|[
name|PF_RULESET_NAT
index|]
argument_list|)
condition|)
name|ERR
argument_list|(
literal|"DIOCBEGINRULES"
argument_list|)
expr_stmt|;
name|pr
index|[
name|PF_RULESET_RDR
index|]
operator|.
name|rule
operator|.
name|action
operator|=
name|PF_RDR
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCBEGINRULES
argument_list|,
operator|&
name|pr
index|[
name|PF_RULESET_RDR
index|]
argument_list|)
condition|)
name|ERR
argument_list|(
literal|"DIOCBEGINRULES"
argument_list|)
expr_stmt|;
name|pr
index|[
name|PF_RULESET_BINAT
index|]
operator|.
name|rule
operator|.
name|action
operator|=
name|PF_BINAT
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCBEGINRULES
argument_list|,
operator|&
name|pr
index|[
name|PF_RULESET_BINAT
index|]
argument_list|)
condition|)
name|ERR
argument_list|(
literal|"DIOCBEGINRULES"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|altqsupport
operator|&&
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_ALTQ
operator|)
operator|!=
literal|0
operator|)
operator|)
operator|&&
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCBEGINALTQS
argument_list|,
operator|&
name|pa
operator|.
name|ticket
argument_list|)
condition|)
block|{
name|ERR
argument_list|(
literal|"DIOCBEGINALTQS"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_FILTER
operator|)
operator|!=
literal|0
condition|)
block|{
name|pr
index|[
name|PF_RULESET_SCRUB
index|]
operator|.
name|rule
operator|.
name|action
operator|=
name|PF_SCRUB
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCBEGINRULES
argument_list|,
operator|&
name|pr
index|[
name|PF_RULESET_SCRUB
index|]
argument_list|)
condition|)
name|ERR
argument_list|(
literal|"DIOCBEGINRULES"
argument_list|)
expr_stmt|;
name|pr
index|[
name|PF_RULESET_FILTER
index|]
operator|.
name|rule
operator|.
name|action
operator|=
name|PF_PASS
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCBEGINRULES
argument_list|,
operator|&
name|pr
index|[
name|PF_RULESET_FILTER
index|]
argument_list|)
condition|)
name|ERR
argument_list|(
literal|"DIOCBEGINRULES"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loadopt
operator|&
name|PFCTL_FLAG_TABLE
condition|)
block|{
if|if
condition|(
name|pfr_ina_begin
argument_list|(
operator|&
name|trs
argument_list|,
operator|&
name|pf
operator|.
name|tticket
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|ERR
argument_list|(
literal|"begin table"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* fill in callback data */
name|pf
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|pf
operator|.
name|opts
operator|=
name|opts
expr_stmt|;
name|pf
operator|.
name|loadopt
operator|=
name|loadopt
expr_stmt|;
name|pf
operator|.
name|paltq
operator|=
operator|&
name|pa
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PF_RULESET_MAX
condition|;
name|i
operator|++
control|)
block|{
name|pf
operator|.
name|prule
index|[
name|i
index|]
operator|=
operator|&
name|pr
index|[
name|i
index|]
expr_stmt|;
block|}
name|pf
operator|.
name|rule_nr
operator|=
literal|0
expr_stmt|;
name|pf
operator|.
name|anchor
operator|=
name|anchorname
expr_stmt|;
name|pf
operator|.
name|ruleset
operator|=
name|rulesetname
expr_stmt|;
if|if
condition|(
name|parse_rules
argument_list|(
name|fin
argument_list|,
operator|&
name|pf
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|==
literal|0
condition|)
name|ERRX
argument_list|(
literal|"Syntax error in config file: "
literal|"pf rules not loaded"
argument_list|)
expr_stmt|;
else|else
goto|goto
name|_error
goto|;
block|}
if|if
condition|(
operator|(
name|altqsupport
operator|&&
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_ALTQ
operator|)
operator|!=
literal|0
operator|)
condition|)
if|if
condition|(
name|check_commit_altq
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
operator|!=
literal|0
condition|)
name|ERRX
argument_list|(
literal|"errors in altq config"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_NAT
operator|)
operator|!=
literal|0
condition|)
block|{
name|pr
index|[
name|PF_RULESET_NAT
index|]
operator|.
name|rule
operator|.
name|action
operator|=
name|PF_NAT
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCCOMMITRULES
argument_list|,
operator|&
name|pr
index|[
name|PF_RULESET_NAT
index|]
argument_list|)
operator|&&
operator|(
name|errno
operator|!=
name|EINVAL
operator|||
name|pf
operator|.
name|rule_nr
operator|)
condition|)
name|ERR
argument_list|(
literal|"DIOCCOMMITRULES NAT"
argument_list|)
expr_stmt|;
name|pr
index|[
name|PF_RULESET_RDR
index|]
operator|.
name|rule
operator|.
name|action
operator|=
name|PF_RDR
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCCOMMITRULES
argument_list|,
operator|&
name|pr
index|[
name|PF_RULESET_RDR
index|]
argument_list|)
operator|&&
operator|(
name|errno
operator|!=
name|EINVAL
operator|||
name|pf
operator|.
name|rule_nr
operator|)
condition|)
name|ERR
argument_list|(
literal|"DIOCCOMMITRULES RDR"
argument_list|)
expr_stmt|;
name|pr
index|[
name|PF_RULESET_BINAT
index|]
operator|.
name|rule
operator|.
name|action
operator|=
name|PF_BINAT
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCCOMMITRULES
argument_list|,
operator|&
name|pr
index|[
name|PF_RULESET_BINAT
index|]
argument_list|)
operator|&&
operator|(
name|errno
operator|!=
name|EINVAL
operator|||
name|pf
operator|.
name|rule_nr
operator|)
condition|)
name|ERR
argument_list|(
literal|"DIOCCOMMITRULES BINAT"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|altqsupport
operator|&&
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_ALTQ
operator|)
operator|!=
literal|0
operator|)
operator|)
operator|&&
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCCOMMITALTQS
argument_list|,
operator|&
name|pa
operator|.
name|ticket
argument_list|)
condition|)
name|ERR
argument_list|(
literal|"DIOCCOMMITALTQS"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_FILTER
operator|)
operator|!=
literal|0
condition|)
block|{
name|pr
index|[
name|PF_RULESET_SCRUB
index|]
operator|.
name|rule
operator|.
name|action
operator|=
name|PF_SCRUB
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCCOMMITRULES
argument_list|,
operator|&
name|pr
index|[
name|PF_RULESET_SCRUB
index|]
argument_list|)
operator|&&
operator|(
name|errno
operator|!=
name|EINVAL
operator|||
name|pf
operator|.
name|rule_nr
operator|)
condition|)
name|ERR
argument_list|(
literal|"DIOCCOMMITRULES SCRUB"
argument_list|)
expr_stmt|;
name|pr
index|[
name|PF_RULESET_FILTER
index|]
operator|.
name|rule
operator|.
name|action
operator|=
name|PF_PASS
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCCOMMITRULES
argument_list|,
operator|&
name|pr
index|[
name|PF_RULESET_FILTER
index|]
argument_list|)
operator|&&
operator|(
name|errno
operator|!=
name|EINVAL
operator|||
name|pf
operator|.
name|rule_nr
operator|)
condition|)
name|ERR
argument_list|(
literal|"DIOCCOMMITRULES FILTER"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loadopt
operator|&
name|PFCTL_FLAG_TABLE
condition|)
block|{
if|if
condition|(
name|pfr_ina_commit
argument_list|(
operator|&
name|trs
argument_list|,
name|pf
operator|.
name|tticket
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
name|ERR
argument_list|(
literal|"commit table"
argument_list|)
expr_stmt|;
name|pf
operator|.
name|tdirty
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fin
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|fin
argument_list|)
expr_stmt|;
comment|/* process "load anchor" directives */
if|if
condition|(
operator|!
name|anchorname
index|[
literal|0
index|]
operator|&&
operator|!
name|rulesetname
index|[
literal|0
index|]
condition|)
if|if
condition|(
name|pfctl_load_anchors
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|ERRX
argument_list|(
literal|"load anchors"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|_error
label|:
if|if
condition|(
name|pf
operator|.
name|tdirty
condition|)
comment|/* cleanup kernel leftover */
name|pfr_ina_begin
argument_list|(
operator|&
name|trs
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ERR
undef|#
directive|undef
name|ERRX
block|}
end_function

begin_function
name|int
name|pfctl_set_limit
parameter_list|(
name|struct
name|pfctl
modifier|*
name|pf
parameter_list|,
specifier|const
name|char
modifier|*
name|opt
parameter_list|,
name|unsigned
name|int
name|limit
parameter_list|)
block|{
name|struct
name|pfioc_limit
name|pl
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_OPTION
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|memset
argument_list|(
operator|&
name|pl
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pl
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pf_limits
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|opt
argument_list|,
name|pf_limits
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pl
operator|.
name|index
operator|=
name|i
expr_stmt|;
name|pl
operator|.
name|limit
operator|=
name|limit
expr_stmt|;
if|if
condition|(
operator|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
name|DIOCSETLIMIT
argument_list|,
operator|&
name|pl
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EBUSY
condition|)
block|{
name|warnx
argument_list|(
literal|"Current pool "
literal|"size exceeds requested "
literal|"hard limit"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCSETLIMIT"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
if|if
condition|(
name|pf_limits
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Bad pool name."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_VERBOSE
condition|)
name|printf
argument_list|(
literal|"set limit %s %d\n"
argument_list|,
name|opt
argument_list|,
name|limit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_set_timeout
parameter_list|(
name|struct
name|pfctl
modifier|*
name|pf
parameter_list|,
specifier|const
name|char
modifier|*
name|opt
parameter_list|,
name|int
name|seconds
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
name|struct
name|pfioc_tm
name|pt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_OPTION
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|memset
argument_list|(
operator|&
name|pt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pt
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pf_timeouts
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|opt
argument_list|,
name|pf_timeouts
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pt
operator|.
name|timeout
operator|=
name|pf_timeouts
index|[
name|i
index|]
operator|.
name|timeout
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pf_timeouts
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Bad timeout name."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|pt
operator|.
name|seconds
operator|=
name|seconds
expr_stmt|;
if|if
condition|(
operator|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
name|DIOCSETTIMEOUT
argument_list|,
operator|&
name|pt
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCSETTIMEOUT"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_VERBOSE
operator|&&
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"set timeout %s %d\n"
argument_list|,
name|opt
argument_list|,
name|seconds
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_set_optimization
parameter_list|(
name|struct
name|pfctl
modifier|*
name|pf
parameter_list|,
specifier|const
name|char
modifier|*
name|opt
parameter_list|)
block|{
specifier|const
name|struct
name|pf_hint
modifier|*
name|hint
decl_stmt|;
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_OPTION
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pf_hints
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|opt
argument_list|,
name|pf_hints
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|hint
operator|=
name|pf_hints
index|[
name|i
index|]
operator|.
name|hint
expr_stmt|;
if|if
condition|(
name|hint
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Bad hint name."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|hint
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|r
operator|=
name|pfctl_set_timeout
argument_list|(
name|pf
argument_list|,
name|hint
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|hint
index|[
name|i
index|]
operator|.
name|timeout
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
operator|(
name|r
operator|)
return|;
if|if
condition|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_VERBOSE
condition|)
name|printf
argument_list|(
literal|"set optimization %s\n"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_set_logif
parameter_list|(
name|struct
name|pfctl
modifier|*
name|pf
parameter_list|,
name|char
modifier|*
name|ifname
parameter_list|)
block|{
name|struct
name|pfioc_if
name|pi
decl_stmt|;
if|if
condition|(
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_OPTION
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|memset
argument_list|(
operator|&
name|pi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ifname
argument_list|,
literal|"none"
argument_list|)
condition|)
name|bzero
argument_list|(
name|pi
operator|.
name|ifname
argument_list|,
sizeof|sizeof
argument_list|(
name|pi
operator|.
name|ifname
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|strlcpy
argument_list|(
name|pi
operator|.
name|ifname
argument_list|,
name|ifname
argument_list|,
sizeof|sizeof
argument_list|(
name|pi
operator|.
name|ifname
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|pi
operator|.
name|ifname
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"pfctl_set_logif: strlcpy"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pf
operator|->
name|dev
argument_list|,
name|DIOCSETSTATUSIF
argument_list|,
operator|&
name|pi
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCSETSTATUSIF"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pf
operator|->
name|opts
operator|&
name|PF_OPT_VERBOSE
condition|)
name|printf
argument_list|(
literal|"set loginterface %s\n"
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_debug
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_int32_t
name|level
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCSETDEBUG
argument_list|,
operator|&
name|level
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCSETDEBUG"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"debug level set to '"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|level
condition|)
block|{
case|case
name|PF_DEBUG_NONE
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"none"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PF_DEBUG_URGENT
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"urgent"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PF_DEBUG_MISC
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"misc"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PF_DEBUG_NOISY
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"loud"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<invalid>"
argument_list|)
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"'\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_clear_rule_counters
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCCLRRULECTRS
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCCLRRULECTRS"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pf: rule counters cleared\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_test_altqsupport
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|)
block|{
name|struct
name|pfioc_altq
name|pa
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETALTQS
argument_list|,
operator|&
name|pa
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENODEV
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No ALTQ support in kernel\n"
literal|"ALTQ related functions disabled\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCGETALTQS"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pfctl_show_anchors
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|opts
parameter_list|,
name|char
modifier|*
name|anchorname
parameter_list|)
block|{
name|u_int32_t
name|nr
decl_stmt|,
name|mnr
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|anchorname
condition|)
block|{
name|struct
name|pfioc_anchor
name|pa
decl_stmt|;
name|memset
argument_list|(
operator|&
name|pa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETANCHORS
argument_list|,
operator|&
name|pa
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"DIOCGETANCHORS"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mnr
operator|=
name|pa
operator|.
name|nr
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
condition|)
name|printf
argument_list|(
literal|"%u anchors:\n"
argument_list|,
name|mnr
argument_list|)
expr_stmt|;
for|for
control|(
name|nr
operator|=
literal|0
init|;
name|nr
operator|<
name|mnr
condition|;
operator|++
name|nr
control|)
block|{
name|pa
operator|.
name|nr
operator|=
name|nr
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETANCHOR
argument_list|,
operator|&
name|pa
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"DIOCGETANCHOR"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"  %s\n"
argument_list|,
name|pa
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|pfioc_ruleset
name|pr
decl_stmt|;
name|memset
argument_list|(
operator|&
name|pr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pr
operator|.
name|anchor
argument_list|,
name|anchorname
argument_list|,
sizeof|sizeof
argument_list|(
name|pr
operator|.
name|anchor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETRULESETS
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINVAL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No rulesets in anchor '%s'.\n"
argument_list|,
name|anchorname
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCGETRULESETS"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mnr
operator|=
name|pr
operator|.
name|nr
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|opts
operator|&
name|PF_OPT_QUIET
operator|)
condition|)
name|printf
argument_list|(
literal|"%u rulesets in anchor %s:\n"
argument_list|,
name|mnr
argument_list|,
name|anchorname
argument_list|)
expr_stmt|;
for|for
control|(
name|nr
operator|=
literal|0
init|;
name|nr
operator|<
name|mnr
condition|;
operator|++
name|nr
control|)
block|{
name|pr
operator|.
name|nr
operator|=
name|nr
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|dev
argument_list|,
name|DIOCGETRULESET
argument_list|,
operator|&
name|pr
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCGETRULESET"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %s:%s\n"
argument_list|,
name|pr
operator|.
name|anchor
argument_list|,
name|pr
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|pfctl_lookup_option
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|list
parameter_list|)
block|{
if|if
condition|(
name|cmd
operator|!=
name|NULL
operator|&&
operator|*
name|cmd
condition|)
for|for
control|(
init|;
operator|*
name|list
condition|;
name|list
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cmd
argument_list|,
operator|*
name|list
argument_list|,
name|strlen
argument_list|(
name|cmd
argument_list|)
argument_list|)
condition|)
return|return
operator|(
operator|*
name|list
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|mode
init|=
name|O_RDONLY
decl_stmt|;
name|int
name|opts
init|=
literal|0
decl_stmt|;
name|char
name|anchorname
index|[
name|PF_ANCHOR_NAME_SIZE
index|]
decl_stmt|;
name|char
name|rulesetname
index|[
name|PF_RULESET_NAME_SIZE
index|]
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"a:AdD:eqf:F:ghk:nNOrRs:t:T:vx:z"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'a'
case|:
name|anchoropt
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|opts
operator||=
name|PF_OPT_DISABLE
expr_stmt|;
name|mode
operator|=
name|O_RDWR
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|pfctl_cmdline_symset
argument_list|(
name|optarg
argument_list|)
operator|<
literal|0
condition|)
name|warnx
argument_list|(
literal|"could not parse macro definition %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|opts
operator||=
name|PF_OPT_ENABLE
expr_stmt|;
name|mode
operator|=
name|O_RDWR
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|opts
operator||=
name|PF_OPT_QUIET
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|clearopt
operator|=
name|pfctl_lookup_option
argument_list|(
name|optarg
argument_list|,
name|clearopt_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|clearopt
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Unknown flush modifier '%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|mode
operator|=
name|O_RDWR
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
if|if
condition|(
name|state_killers
operator|>=
literal|2
condition|)
block|{
name|warnx
argument_list|(
literal|"can only specify -k twice"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|state_kill
index|[
name|state_killers
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
name|mode
operator|=
name|O_RDWR
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|opts
operator||=
name|PF_OPT_NOACTION
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|loadopt
operator||=
name|PFCTL_FLAG_NAT
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|opts
operator||=
name|PF_OPT_USEDNS
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|rulesopt
operator|=
name|optarg
expr_stmt|;
name|mode
operator|=
name|O_RDWR
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|opts
operator||=
name|PF_OPT_DEBUG
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|loadopt
operator||=
name|PFCTL_FLAG_ALTQ
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|loadopt
operator||=
name|PFCTL_FLAG_FILTER
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|loadopt
operator||=
name|PFCTL_FLAG_OPTION
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|showopt
operator|=
name|pfctl_lookup_option
argument_list|(
name|optarg
argument_list|,
name|showopt_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|showopt
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Unknown show modifier '%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
name|tableopt
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|tblcmdopt
operator|=
name|pfctl_lookup_option
argument_list|(
name|optarg
argument_list|,
name|tblcmdopt_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|tblcmdopt
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Unknown table command '%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
if|if
condition|(
name|opts
operator|&
name|PF_OPT_VERBOSE
condition|)
name|opts
operator||=
name|PF_OPT_VERBOSE2
expr_stmt|;
name|opts
operator||=
name|PF_OPT_VERBOSE
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|debugopt
operator|=
name|pfctl_lookup_option
argument_list|(
name|optarg
argument_list|,
name|debugopt_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugopt
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Unknown debug level '%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|mode
operator|=
name|O_RDWR
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|opts
operator||=
name|PF_OPT_CLRRULECTRS
expr_stmt|;
name|mode
operator|=
name|O_RDWR
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* FALLTHROUGH */
default|default:
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
if|if
condition|(
name|tblcmdopt
operator|!=
name|NULL
condition|)
block|{
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
name|ch
operator|=
operator|*
name|tblcmdopt
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'l'
condition|)
block|{
name|loadopt
operator||=
name|PFCTL_FLAG_TABLE
expr_stmt|;
name|tblcmdopt
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
name|strchr
argument_list|(
literal|"acdfkrz"
argument_list|,
name|ch
argument_list|)
condition|?
name|O_RDWR
else|:
name|O_RDONLY
expr_stmt|;
if|if
condition|(
name|opts
operator|&
name|PF_OPT_NOACTION
condition|)
block|{
name|dev
operator|=
name|open
argument_list|(
literal|"/dev/pf"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|>=
literal|0
condition|)
name|opts
operator||=
name|PF_OPT_DUMMYACTION
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|argc
operator|!=
name|optind
condition|)
block|{
name|warnx
argument_list|(
literal|"unknown command line argument: %s ..."
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|loadopt
operator|==
literal|0
condition|)
name|loadopt
operator|=
operator|~
literal|0
expr_stmt|;
name|memset
argument_list|(
name|anchorname
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|anchorname
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|rulesetname
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rulesetname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|anchoropt
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|strchr
argument_list|(
name|anchoropt
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|strlcpy
argument_list|(
name|anchorname
argument_list|,
name|anchoropt
argument_list|,
sizeof|sizeof
argument_list|(
name|anchorname
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|anchorname
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"anchor name '%s' too long"
argument_list|,
name|anchoropt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strdup
argument_list|(
name|anchoropt
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"anchoropt: strdup"
argument_list|)
expr_stmt|;
name|t
operator|=
name|strsep
argument_list|(
operator|&
name|p
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'\0'
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"anchor '%s' invalid"
argument_list|,
name|anchoropt
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlcpy
argument_list|(
name|anchorname
argument_list|,
name|t
argument_list|,
sizeof|sizeof
argument_list|(
name|anchorname
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|anchorname
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"anchor name '%s' too long"
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlcpy
argument_list|(
name|rulesetname
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|rulesetname
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|rulesetname
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"ruleset name '%s' too long"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* not p */
block|}
name|loadopt
operator|&=
name|PFCTL_FLAG_FILTER
operator||
name|PFCTL_FLAG_NAT
operator||
name|PFCTL_FLAG_TABLE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|==
literal|0
condition|)
block|{
name|dev
operator|=
name|open
argument_list|(
literal|"/dev/pf"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"/dev/pf"
argument_list|)
expr_stmt|;
name|altqsupport
operator|=
name|pfctl_test_altqsupport
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* turn off options */
name|opts
operator|&=
operator|~
operator|(
name|PF_OPT_DISABLE
operator||
name|PF_OPT_ENABLE
operator|)
expr_stmt|;
name|clearopt
operator|=
name|showopt
operator|=
name|debugopt
operator|=
name|NULL
expr_stmt|;
name|altqsupport
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|opts
operator|&
name|PF_OPT_DISABLE
condition|)
if|if
condition|(
name|pfctl_disable
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
condition|)
name|error
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|showopt
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
operator|*
name|showopt
condition|)
block|{
case|case
literal|'A'
case|:
name|pfctl_show_anchors
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|,
name|anchorname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|pfctl_load_fingerprints
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_show_rules
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|,
literal|0
argument_list|,
name|anchorname
argument_list|,
name|rulesetname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|pfctl_load_fingerprints
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_show_rules
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|,
literal|1
argument_list|,
name|anchorname
argument_list|,
name|rulesetname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|pfctl_load_fingerprints
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_show_nat
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|,
name|anchorname
argument_list|,
name|rulesetname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|pfctl_show_altq
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|,
name|opts
operator|&
name|PF_OPT_VERBOSE2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|pfctl_show_states
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|pfctl_show_status
argument_list|(
name|dev
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|pfctl_show_timeouts
argument_list|(
name|dev
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|pfctl_show_limits
argument_list|(
name|dev
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|pfctl_load_fingerprints
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_show_rules
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|,
literal|0
argument_list|,
name|anchorname
argument_list|,
name|rulesetname
argument_list|)
expr_stmt|;
name|pfctl_show_nat
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|,
name|anchorname
argument_list|,
name|rulesetname
argument_list|)
expr_stmt|;
name|pfctl_show_altq
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pfctl_show_states
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_show_status
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pfctl_show_rules
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|,
literal|1
argument_list|,
name|anchorname
argument_list|,
name|rulesetname
argument_list|)
expr_stmt|;
name|pfctl_show_timeouts
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pfctl_show_limits
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pfctl_show_tables
argument_list|(
name|anchorname
argument_list|,
name|rulesetname
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_show_fingerprints
argument_list|(
name|opts
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|pfctl_show_tables
argument_list|(
name|anchorname
argument_list|,
name|rulesetname
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|pfctl_load_fingerprints
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_show_fingerprints
argument_list|(
name|opts
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|clearopt
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
operator|*
name|clearopt
condition|)
block|{
case|case
literal|'r'
case|:
name|pfctl_clear_rules
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|,
name|anchorname
argument_list|,
name|rulesetname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|pfctl_clear_nat
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|,
name|anchorname
argument_list|,
name|rulesetname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|pfctl_clear_altq
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|pfctl_clear_states
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|pfctl_clear_stats
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|pfctl_clear_rules
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|,
name|anchorname
argument_list|,
name|rulesetname
argument_list|)
expr_stmt|;
name|pfctl_clear_nat
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|,
name|anchorname
argument_list|,
name|rulesetname
argument_list|)
expr_stmt|;
name|pfctl_clear_altq
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_clear_states
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_clear_stats
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_clear_tables
argument_list|(
name|anchorname
argument_list|,
name|rulesetname
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|pfctl_clear_fingerprints
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|pfctl_clear_fingerprints
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|pfctl_clear_tables
argument_list|(
name|anchorname
argument_list|,
name|rulesetname
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|state_killers
condition|)
name|pfctl_kill_states
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|tblcmdopt
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|pfctl_command_tables
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|tableopt
argument_list|,
name|tblcmdopt
argument_list|,
name|rulesopt
argument_list|,
name|anchorname
argument_list|,
name|rulesetname
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|rulesopt
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|rulesopt
operator|!=
name|NULL
condition|)
if|if
condition|(
name|pfctl_file_fingerprints
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|,
name|PF_OSFP_FILE
argument_list|)
condition|)
name|error
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rulesopt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pfctl_rules
argument_list|(
name|dev
argument_list|,
name|rulesopt
argument_list|,
name|opts
argument_list|,
name|anchorname
argument_list|,
name|rulesetname
argument_list|)
condition|)
name|error
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|opts
operator|&
name|PF_OPT_NOACTION
operator|)
operator|&&
operator|(
name|loadopt
operator|&
name|PFCTL_FLAG_TABLE
operator|)
condition|)
name|warn_namespace_collision
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opts
operator|&
name|PF_OPT_ENABLE
condition|)
if|if
condition|(
name|pfctl_enable
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
condition|)
name|error
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|debugopt
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
operator|*
name|debugopt
condition|)
block|{
case|case
literal|'n'
case|:
name|pfctl_debug
argument_list|(
name|dev
argument_list|,
name|PF_DEBUG_NONE
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|pfctl_debug
argument_list|(
name|dev
argument_list|,
name|PF_DEBUG_URGENT
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|pfctl_debug
argument_list|(
name|dev
argument_list|,
name|PF_DEBUG_MISC
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|pfctl_debug
argument_list|(
name|dev
argument_list|,
name|PF_DEBUG_NOISY
argument_list|,
name|opts
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|opts
operator|&
name|PF_OPT_CLRRULECTRS
condition|)
block|{
if|if
condition|(
name|pfctl_clear_rule_counters
argument_list|(
name|dev
argument_list|,
name|opts
argument_list|)
condition|)
name|error
operator|=
literal|1
expr_stmt|;
block|}
name|exit
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

