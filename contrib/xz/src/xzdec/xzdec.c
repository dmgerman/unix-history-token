begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       xzdec.c
end_comment

begin_comment
comment|/// \brief      Simple single-threaded tool to uncompress .xz or .lzma files
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Author:     Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"sysdefs.h"
end_include

begin_include
include|#
directive|include
file|"lzma.h"
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"tuklib_progname.h"
end_include

begin_include
include|#
directive|include
file|"tuklib_exit.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TUKLIB_DOSLIKE
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LZMADEC
end_ifdef

begin_define
define|#
directive|define
name|TOOL_FORMAT
value|"lzma"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TOOL_FORMAT
value|"xz"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/// Number of bytes to use memory at maximum
end_comment

begin_decl_stmt
specifier|static
name|uint64_t
name|memlimit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Total amount of physical RAM
end_comment

begin_decl_stmt
specifier|static
name|uint64_t
name|total_ram
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Error messages are suppressed if this is zero, which is the case when
end_comment

begin_comment
comment|/// --quiet has been given at least twice.
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|display_errors
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lzma_attribute
argument_list|(
operator|(
name|format
argument_list|(
name|printf
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
operator|)
argument_list|)
name|my_errorf
argument_list|(
specifier|const
name|char
operator|*
name|fmt
argument_list|,
operator|...
argument_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|display_errors
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lzma_attribute
argument_list|(
operator|(
name|noreturn
operator|)
argument_list|)
name|help
argument_list|(
name|void
argument_list|)
block|{
comment|// Round up to the next MiB and do it correctly also with UINT64_MAX.
specifier|const
name|uint64_t
name|mem_mib
init|=
operator|(
name|memlimit
operator|>>
literal|20
operator|)
operator|+
operator|(
operator|(
name|memlimit
operator|&
operator|(
operator|(
name|UINT32_C
argument_list|(
literal|1
argument_list|)
operator|<<
literal|20
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
operator|)
decl_stmt|;
name|printf
argument_list|(
literal|"Usage: %s [OPTION]... [FILE]...\n"
literal|"Uncompress files in the ."
name|TOOL_FORMAT
literal|" format to the standard output.\n"
literal|"\n"
literal|"  -c, --stdout       (ignored)\n"
literal|"  -d, --decompress   (ignored)\n"
literal|"  -k, --keep         (ignored)\n"
literal|"  -M, --memory=NUM   use NUM bytes of memory at maximum (0 means default)\n"
literal|"  -q, --quiet        specify *twice* to suppress errors\n"
literal|"  -Q, --no-warn      (ignored)\n"
literal|"  -h, --help         display this help and exit\n"
literal|"  -V, --version      display the version number and exit\n"
literal|"\n"
literal|"With no FILE, or when FILE is -, read standard input.\n"
literal|"\n"
literal|"On this system and configuration, this program will use a maximum of roughly\n"
literal|"%"
name|PRIu64
literal|" MiB RAM.\n"
literal|"\n"
literal|"Report bugs to<"
name|PACKAGE_BUGREPORT
literal|"> (in English or Finnish).\n"
name|PACKAGE_NAME
literal|" home page:<"
name|PACKAGE_URL
literal|">\n"
argument_list|,
name|progname
argument_list|,
name|mem_mib
argument_list|)
expr_stmt|;
name|tuklib_exit
argument_list|(
name|EXIT_SUCCESS
argument_list|,
name|EXIT_FAILURE
argument_list|,
name|display_errors
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lzma_attribute
argument_list|(
operator|(
name|noreturn
operator|)
argument_list|)
name|version
argument_list|(
name|void
argument_list|)
block|{
name|printf
argument_list|(
name|TOOL_FORMAT
literal|"dec ("
name|PACKAGE_NAME
literal|") "
name|LZMA_VERSION_STRING
literal|"\n"
literal|"liblzma %s\n"
argument_list|,
name|lzma_version_string
argument_list|()
argument_list|)
expr_stmt|;
name|tuklib_exit
argument_list|(
name|EXIT_SUCCESS
argument_list|,
name|EXIT_FAILURE
argument_list|,
name|display_errors
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/// Find out the amount of physical memory (RAM) in the system, and set
end_comment

begin_comment
comment|/// the memory usage limit to the given percentage of RAM.
end_comment

begin_function
specifier|static
name|void
name|memlimit_set_percentage
parameter_list|(
name|uint32_t
name|percentage
parameter_list|)
block|{
name|memlimit
operator|=
name|percentage
operator|*
name|total_ram
operator|/
literal|100
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/// Set the memory usage limit to give number of bytes. Zero is a special
end_comment

begin_comment
comment|/// value to indicate the default limit.
end_comment

begin_function
specifier|static
name|void
name|memlimit_set
parameter_list|(
name|uint64_t
name|new_memlimit
parameter_list|)
block|{
if|if
condition|(
name|new_memlimit
operator|!=
literal|0
condition|)
block|{
name|memlimit
operator|=
name|new_memlimit
expr_stmt|;
block|}
else|else
block|{
name|memlimit
operator|=
literal|40
operator|*
name|total_ram
operator|/
literal|100
expr_stmt|;
if|if
condition|(
name|memlimit
operator|<
name|UINT64_C
argument_list|(
literal|80
argument_list|)
operator|*
literal|1024
operator|*
literal|1024
condition|)
block|{
name|memlimit
operator|=
literal|80
operator|*
name|total_ram
operator|/
literal|100
expr_stmt|;
if|if
condition|(
name|memlimit
operator|>
name|UINT64_C
argument_list|(
literal|80
argument_list|)
operator|*
literal|1024
operator|*
literal|1024
condition|)
name|memlimit
operator|=
name|UINT64_C
argument_list|(
literal|80
argument_list|)
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/// Get the total amount of physical RAM and set the memory usage limit
end_comment

begin_comment
comment|/// to the default value.
end_comment

begin_function
specifier|static
name|void
name|memlimit_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|// If we cannot determine the amount of RAM, use the assumption
comment|// defined by the configure script.
name|total_ram
operator|=
name|lzma_physmem
argument_list|()
expr_stmt|;
if|if
condition|(
name|total_ram
operator|==
literal|0
condition|)
name|total_ram
operator|=
call|(
name|uint64_t
call|)
argument_list|(
name|ASSUME_RAM
argument_list|)
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
name|memlimit_set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/// \brief      Convert a string to uint64_t
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This is rudely copied from src/xz/util.c and modified a little. :-(
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \param      max     Return value when the string "max" was specified.
end_comment

begin_comment
comment|///
end_comment

begin_function
specifier|static
name|uint64_t
name|str_to_uint64
parameter_list|(
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|uint64_t
name|max
parameter_list|)
block|{
name|uint64_t
name|result
init|=
literal|0
decl_stmt|;
comment|// Accept special value "max".
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"max"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|max
return|;
if|if
condition|(
operator|*
name|value
operator|<
literal|'0'
operator|||
operator|*
name|value
operator|>
literal|'9'
condition|)
block|{
name|my_errorf
argument_list|(
literal|"%s: Value is not a non-negative decimal integer"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
do|do
block|{
comment|// Don't overflow.
if|if
condition|(
name|result
operator|>
operator|(
name|UINT64_MAX
operator|-
literal|9
operator|)
operator|/
literal|10
condition|)
return|return
name|UINT64_MAX
return|;
name|result
operator|*=
literal|10
expr_stmt|;
name|result
operator|+=
operator|*
name|value
operator|-
literal|'0'
expr_stmt|;
operator|++
name|value
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|value
operator|>=
literal|'0'
operator|&&
operator|*
name|value
operator|<=
literal|'9'
condition|)
do|;
if|if
condition|(
operator|*
name|value
operator|!=
literal|'\0'
condition|)
block|{
comment|// Look for suffix.
name|uint64_t
name|multiplier
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|value
operator|==
literal|'k'
operator|||
operator|*
name|value
operator|==
literal|'K'
condition|)
name|multiplier
operator|=
name|UINT64_C
argument_list|(
literal|1
argument_list|)
operator|<<
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|value
operator|==
literal|'m'
operator|||
operator|*
name|value
operator|==
literal|'M'
condition|)
name|multiplier
operator|=
name|UINT64_C
argument_list|(
literal|1
argument_list|)
operator|<<
literal|20
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|value
operator|==
literal|'g'
operator|||
operator|*
name|value
operator|==
literal|'G'
condition|)
name|multiplier
operator|=
name|UINT64_C
argument_list|(
literal|1
argument_list|)
operator|<<
literal|30
expr_stmt|;
operator|++
name|value
expr_stmt|;
comment|// Allow also e.g. Ki, KiB, and KB.
if|if
condition|(
operator|*
name|value
operator|!=
literal|'\0'
operator|&&
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"i"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"iB"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"B"
argument_list|)
operator|!=
literal|0
condition|)
name|multiplier
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|multiplier
operator|==
literal|0
condition|)
block|{
name|my_errorf
argument_list|(
literal|"%s: Invalid suffix"
argument_list|,
name|value
operator|-
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
comment|// Don't overflow here either.
if|if
condition|(
name|result
operator|>
name|UINT64_MAX
operator|/
name|multiplier
condition|)
name|result
operator|=
name|UINT64_MAX
expr_stmt|;
else|else
name|result
operator|*=
name|multiplier
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/// Parses command line options.
end_comment

begin_function
specifier|static
name|void
name|parse_options
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|short_opts
index|[]
init|=
literal|"cdkM:hqQV"
decl_stmt|;
specifier|static
specifier|const
name|struct
name|option
name|long_opts
index|[]
init|=
block|{
block|{
literal|"stdout"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'c'
block|}
block|,
block|{
literal|"to-stdout"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'c'
block|}
block|,
block|{
literal|"decompress"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
block|{
literal|"uncompress"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
block|{
literal|"keep"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'k'
block|}
block|,
block|{
literal|"memory"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'M'
block|}
block|,
block|{
literal|"quiet"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'q'
block|}
block|,
block|{
literal|"no-warn"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'Q'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'V'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|short_opts
argument_list|,
name|long_opts
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'k'
case|:
case|case
literal|'Q'
case|:
break|break;
case|case
literal|'M'
case|:
block|{
comment|// Support specifying the limit as a percentage of
comment|// installed physical RAM.
specifier|const
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|optarg
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|optarg
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'%'
condition|)
block|{
comment|// Memory limit is a percentage of total
comment|// installed RAM.
name|optarg
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
specifier|const
name|uint64_t
name|percentage
init|=
name|str_to_uint64
argument_list|(
name|optarg
argument_list|,
literal|100
argument_list|)
decl_stmt|;
if|if
condition|(
name|percentage
operator|<
literal|1
operator|||
name|percentage
operator|>
literal|100
condition|)
block|{
name|my_errorf
argument_list|(
literal|"Percentage must be in "
literal|"the range [1, 100]"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|memlimit_set_percentage
argument_list|(
name|percentage
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memlimit_set
argument_list|(
name|str_to_uint64
argument_list|(
name|optarg
argument_list|,
name|UINT64_MAX
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'q'
case|:
if|if
condition|(
name|display_errors
operator|>
literal|0
condition|)
operator|--
name|display_errors
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|help
argument_list|()
expr_stmt|;
case|case
literal|'V'
case|:
name|version
argument_list|()
expr_stmt|;
default|default:
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|uncompress
parameter_list|(
name|lzma_stream
modifier|*
name|strm
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|lzma_ret
name|ret
decl_stmt|;
comment|// Initialize the decoder
ifdef|#
directive|ifdef
name|LZMADEC
name|ret
operator|=
name|lzma_alone_decoder
argument_list|(
name|strm
argument_list|,
name|memlimit
argument_list|)
expr_stmt|;
else|#
directive|else
name|ret
operator|=
name|lzma_stream_decoder
argument_list|(
name|strm
argument_list|,
name|memlimit
argument_list|,
name|LZMA_CONCATENATED
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// The only reasonable error here is LZMA_MEM_ERROR.
comment|// FIXME: Maybe also LZMA_MEMLIMIT_ERROR in future?
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
name|my_errorf
argument_list|(
literal|"%s"
argument_list|,
name|ret
operator|==
name|LZMA_MEM_ERROR
condition|?
name|strerror
argument_list|(
name|ENOMEM
argument_list|)
else|:
literal|"Internal error (bug)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
comment|// Input and output buffers
name|uint8_t
name|in_buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|uint8_t
name|out_buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|strm
operator|->
name|avail_in
operator|=
literal|0
expr_stmt|;
name|strm
operator|->
name|next_out
operator|=
name|out_buf
expr_stmt|;
name|strm
operator|->
name|avail_out
operator|=
name|BUFSIZ
expr_stmt|;
name|lzma_action
name|action
init|=
name|LZMA_RUN
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|==
literal|0
condition|)
block|{
name|strm
operator|->
name|next_in
operator|=
name|in_buf
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|=
name|fread
argument_list|(
name|in_buf
argument_list|,
literal|1
argument_list|,
name|BUFSIZ
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|file
argument_list|)
condition|)
block|{
comment|// POSIX says that fread() sets errno if
comment|// an error occurred. ferror() doesn't
comment|// touch errno.
name|my_errorf
argument_list|(
literal|"%s: Error reading input file: %s"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|LZMADEC
comment|// When using LZMA_CONCATENATED, we need to tell
comment|// liblzma when it has got all the input.
if|if
condition|(
name|feof
argument_list|(
name|file
argument_list|)
condition|)
name|action
operator|=
name|LZMA_FINISH
expr_stmt|;
endif|#
directive|endif
block|}
name|ret
operator|=
name|lzma_code
argument_list|(
name|strm
argument_list|,
name|action
argument_list|)
expr_stmt|;
comment|// Write and check write error before checking decoder error.
comment|// This way as much data as possible gets written to output
comment|// even if decoder detected an error.
if|if
condition|(
name|strm
operator|->
name|avail_out
operator|==
literal|0
operator|||
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
specifier|const
name|size_t
name|write_size
init|=
name|BUFSIZ
operator|-
name|strm
operator|->
name|avail_out
decl_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|out_buf
argument_list|,
literal|1
argument_list|,
name|write_size
argument_list|,
name|stdout
argument_list|)
operator|!=
name|write_size
condition|)
block|{
comment|// Wouldn't be a surprise if writing to stderr
comment|// would fail too but at least try to show an
comment|// error message.
name|my_errorf
argument_list|(
literal|"Cannot write to standard output: "
literal|"%s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|strm
operator|->
name|next_out
operator|=
name|out_buf
expr_stmt|;
name|strm
operator|->
name|avail_out
operator|=
name|BUFSIZ
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
if|if
condition|(
name|ret
operator|==
name|LZMA_STREAM_END
condition|)
block|{
ifdef|#
directive|ifdef
name|LZMADEC
comment|// Check that there's no trailing garbage.
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|!=
literal|0
operator|||
name|fread
argument_list|(
name|in_buf
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|feof
argument_list|(
name|file
argument_list|)
condition|)
name|ret
operator|=
name|LZMA_DATA_ERROR
expr_stmt|;
else|else
return|return;
else|#
directive|else
comment|// lzma_stream_decoder() already guarantees
comment|// that there's no trailing garbage.
name|assert
argument_list|(
name|strm
operator|->
name|avail_in
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|action
operator|==
name|LZMA_FINISH
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|feof
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
block|}
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|LZMA_MEM_ERROR
case|:
name|msg
operator|=
name|strerror
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
break|break;
case|case
name|LZMA_MEMLIMIT_ERROR
case|:
name|msg
operator|=
literal|"Memory usage limit reached"
expr_stmt|;
break|break;
case|case
name|LZMA_FORMAT_ERROR
case|:
name|msg
operator|=
literal|"File format not recognized"
expr_stmt|;
break|break;
case|case
name|LZMA_OPTIONS_ERROR
case|:
comment|// FIXME: Better message?
name|msg
operator|=
literal|"Unsupported compression options"
expr_stmt|;
break|break;
case|case
name|LZMA_DATA_ERROR
case|:
name|msg
operator|=
literal|"File is corrupt"
expr_stmt|;
break|break;
case|case
name|LZMA_BUF_ERROR
case|:
name|msg
operator|=
literal|"Unexpected end of input"
expr_stmt|;
break|break;
default|default:
name|msg
operator|=
literal|"Internal error (bug)"
expr_stmt|;
break|break;
block|}
name|my_errorf
argument_list|(
literal|"%s: %s"
argument_list|,
name|filename
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
comment|// Initialize progname which we will be used in error messages.
name|tuklib_progname_init
argument_list|(
name|argv
argument_list|)
expr_stmt|;
comment|// Set the default memory usage limit. This is needed before parsing
comment|// the command line arguments.
name|memlimit_init
argument_list|()
expr_stmt|;
comment|// Parse the command line options.
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|// The same lzma_stream is used for all files that we decode. This way
comment|// we don't need to reallocate memory for every file if they use same
comment|// compression settings.
name|lzma_stream
name|strm
init|=
name|LZMA_STREAM_INIT
decl_stmt|;
comment|// Some systems require setting stdin and stdout to binary mode.
ifdef|#
directive|ifdef
name|TUKLIB_DOSLIKE
name|setmode
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
name|setmode
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
block|{
comment|// No filenames given, decode from stdin.
name|uncompress
argument_list|(
operator|&
name|strm
argument_list|,
name|stdin
argument_list|,
literal|"(stdin)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Loop through the filenames given on the command line.
do|do
block|{
comment|// "-" indicates stdin.
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|uncompress
argument_list|(
operator|&
name|strm
argument_list|,
name|stdin
argument_list|,
literal|"(stdin)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FILE
modifier|*
name|file
init|=
name|fopen
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"rb"
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|my_errorf
argument_list|(
literal|"%s: %s"
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|uncompress
argument_list|(
operator|&
name|strm
argument_list|,
name|file
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|++
name|optind
operator|<
name|argc
condition|)
do|;
block|}
ifndef|#
directive|ifndef
name|NDEBUG
comment|// Free the memory only when debugging. Freeing wastes some time,
comment|// but allows detecting possible memory leaks with Valgrind.
name|lzma_end
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tuklib_exit
argument_list|(
name|EXIT_SUCCESS
argument_list|,
name|EXIT_FAILURE
argument_list|,
name|display_errors
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

