begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       xzdec.c
end_comment

begin_comment
comment|/// \brief      Simple single-threaded tool to uncompress .xz or .lzma files
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Author:     Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"sysdefs.h"
end_include

begin_include
include|#
directive|include
file|"lzma.h"
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"tuklib_progname.h"
end_include

begin_include
include|#
directive|include
file|"tuklib_exit.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TUKLIB_DOSLIKE
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LZMADEC
end_ifdef

begin_define
define|#
directive|define
name|TOOL_FORMAT
value|"lzma"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TOOL_FORMAT
value|"xz"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/// Error messages are suppressed if this is zero, which is the case when
end_comment

begin_comment
comment|/// --quiet has been given at least twice.
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|display_errors
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lzma_attribute
argument_list|(
operator|(
name|__format__
argument_list|(
name|__printf__
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
operator|)
argument_list|)
name|my_errorf
argument_list|(
specifier|const
name|char
operator|*
name|fmt
argument_list|,
operator|...
argument_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|display_errors
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lzma_attribute
argument_list|(
operator|(
name|__noreturn__
operator|)
argument_list|)
name|help
argument_list|(
name|void
argument_list|)
block|{
name|printf
argument_list|(
literal|"Usage: %s [OPTION]... [FILE]...\n"
literal|"Uncompress files in the ."
name|TOOL_FORMAT
literal|" format to the standard output.\n"
literal|"\n"
literal|"  -c, --stdout       (ignored)\n"
literal|"  -d, --decompress   (ignored)\n"
literal|"  -k, --keep         (ignored)\n"
literal|"  -q, --quiet        specify *twice* to suppress errors\n"
literal|"  -Q, --no-warn      (ignored)\n"
literal|"  -h, --help         display this help and exit\n"
literal|"  -V, --version      display the version number and exit\n"
literal|"\n"
literal|"With no FILE, or when FILE is -, read standard input.\n"
literal|"\n"
literal|"Report bugs to<"
name|PACKAGE_BUGREPORT
literal|"> (in English or Finnish).\n"
name|PACKAGE_NAME
literal|" home page:<"
name|PACKAGE_URL
literal|">\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|tuklib_exit
argument_list|(
name|EXIT_SUCCESS
argument_list|,
name|EXIT_FAILURE
argument_list|,
name|display_errors
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lzma_attribute
argument_list|(
operator|(
name|__noreturn__
operator|)
argument_list|)
name|version
argument_list|(
name|void
argument_list|)
block|{
name|printf
argument_list|(
name|TOOL_FORMAT
literal|"dec ("
name|PACKAGE_NAME
literal|") "
name|LZMA_VERSION_STRING
literal|"\n"
literal|"liblzma %s\n"
argument_list|,
name|lzma_version_string
argument_list|()
argument_list|)
expr_stmt|;
name|tuklib_exit
argument_list|(
name|EXIT_SUCCESS
argument_list|,
name|EXIT_FAILURE
argument_list|,
name|display_errors
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/// Parses command line options.
end_comment

begin_function
specifier|static
name|void
name|parse_options
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|short_opts
index|[]
init|=
literal|"cdkM:hqQV"
decl_stmt|;
specifier|static
specifier|const
name|struct
name|option
name|long_opts
index|[]
init|=
block|{
block|{
literal|"stdout"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'c'
block|}
block|,
block|{
literal|"to-stdout"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'c'
block|}
block|,
block|{
literal|"decompress"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
block|{
literal|"uncompress"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
block|{
literal|"keep"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'k'
block|}
block|,
block|{
literal|"quiet"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'q'
block|}
block|,
block|{
literal|"no-warn"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'Q'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'V'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|short_opts
argument_list|,
name|long_opts
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'k'
case|:
case|case
literal|'Q'
case|:
break|break;
case|case
literal|'q'
case|:
if|if
condition|(
name|display_errors
operator|>
literal|0
condition|)
operator|--
name|display_errors
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|help
argument_list|()
expr_stmt|;
case|case
literal|'V'
case|:
name|version
argument_list|()
expr_stmt|;
default|default:
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|uncompress
parameter_list|(
name|lzma_stream
modifier|*
name|strm
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|lzma_ret
name|ret
decl_stmt|;
comment|// Initialize the decoder
ifdef|#
directive|ifdef
name|LZMADEC
name|ret
operator|=
name|lzma_alone_decoder
argument_list|(
name|strm
argument_list|,
name|UINT64_MAX
argument_list|)
expr_stmt|;
else|#
directive|else
name|ret
operator|=
name|lzma_stream_decoder
argument_list|(
name|strm
argument_list|,
name|UINT64_MAX
argument_list|,
name|LZMA_CONCATENATED
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// The only reasonable error here is LZMA_MEM_ERROR.
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
name|my_errorf
argument_list|(
literal|"%s"
argument_list|,
name|ret
operator|==
name|LZMA_MEM_ERROR
condition|?
name|strerror
argument_list|(
name|ENOMEM
argument_list|)
else|:
literal|"Internal error (bug)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
comment|// Input and output buffers
name|uint8_t
name|in_buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|uint8_t
name|out_buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|strm
operator|->
name|avail_in
operator|=
literal|0
expr_stmt|;
name|strm
operator|->
name|next_out
operator|=
name|out_buf
expr_stmt|;
name|strm
operator|->
name|avail_out
operator|=
name|BUFSIZ
expr_stmt|;
name|lzma_action
name|action
init|=
name|LZMA_RUN
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|==
literal|0
condition|)
block|{
name|strm
operator|->
name|next_in
operator|=
name|in_buf
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|=
name|fread
argument_list|(
name|in_buf
argument_list|,
literal|1
argument_list|,
name|BUFSIZ
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|file
argument_list|)
condition|)
block|{
comment|// POSIX says that fread() sets errno if
comment|// an error occurred. ferror() doesn't
comment|// touch errno.
name|my_errorf
argument_list|(
literal|"%s: Error reading input file: %s"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|LZMADEC
comment|// When using LZMA_CONCATENATED, we need to tell
comment|// liblzma when it has got all the input.
if|if
condition|(
name|feof
argument_list|(
name|file
argument_list|)
condition|)
name|action
operator|=
name|LZMA_FINISH
expr_stmt|;
endif|#
directive|endif
block|}
name|ret
operator|=
name|lzma_code
argument_list|(
name|strm
argument_list|,
name|action
argument_list|)
expr_stmt|;
comment|// Write and check write error before checking decoder error.
comment|// This way as much data as possible gets written to output
comment|// even if decoder detected an error.
if|if
condition|(
name|strm
operator|->
name|avail_out
operator|==
literal|0
operator|||
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
specifier|const
name|size_t
name|write_size
init|=
name|BUFSIZ
operator|-
name|strm
operator|->
name|avail_out
decl_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|out_buf
argument_list|,
literal|1
argument_list|,
name|write_size
argument_list|,
name|stdout
argument_list|)
operator|!=
name|write_size
condition|)
block|{
comment|// Wouldn't be a surprise if writing to stderr
comment|// would fail too but at least try to show an
comment|// error message.
name|my_errorf
argument_list|(
literal|"Cannot write to standard output: "
literal|"%s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|strm
operator|->
name|next_out
operator|=
name|out_buf
expr_stmt|;
name|strm
operator|->
name|avail_out
operator|=
name|BUFSIZ
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
if|if
condition|(
name|ret
operator|==
name|LZMA_STREAM_END
condition|)
block|{
ifdef|#
directive|ifdef
name|LZMADEC
comment|// Check that there's no trailing garbage.
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|!=
literal|0
operator|||
name|fread
argument_list|(
name|in_buf
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|feof
argument_list|(
name|file
argument_list|)
condition|)
name|ret
operator|=
name|LZMA_DATA_ERROR
expr_stmt|;
else|else
return|return;
else|#
directive|else
comment|// lzma_stream_decoder() already guarantees
comment|// that there's no trailing garbage.
name|assert
argument_list|(
name|strm
operator|->
name|avail_in
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|action
operator|==
name|LZMA_FINISH
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|feof
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
block|}
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|LZMA_MEM_ERROR
case|:
name|msg
operator|=
name|strerror
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
break|break;
case|case
name|LZMA_FORMAT_ERROR
case|:
name|msg
operator|=
literal|"File format not recognized"
expr_stmt|;
break|break;
case|case
name|LZMA_OPTIONS_ERROR
case|:
comment|// FIXME: Better message?
name|msg
operator|=
literal|"Unsupported compression options"
expr_stmt|;
break|break;
case|case
name|LZMA_DATA_ERROR
case|:
name|msg
operator|=
literal|"File is corrupt"
expr_stmt|;
break|break;
case|case
name|LZMA_BUF_ERROR
case|:
name|msg
operator|=
literal|"Unexpected end of input"
expr_stmt|;
break|break;
default|default:
name|msg
operator|=
literal|"Internal error (bug)"
expr_stmt|;
break|break;
block|}
name|my_errorf
argument_list|(
literal|"%s: %s"
argument_list|,
name|filename
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
comment|// Initialize progname which we will be used in error messages.
name|tuklib_progname_init
argument_list|(
name|argv
argument_list|)
expr_stmt|;
comment|// Parse the command line options.
name|parse_options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|// The same lzma_stream is used for all files that we decode. This way
comment|// we don't need to reallocate memory for every file if they use same
comment|// compression settings.
name|lzma_stream
name|strm
init|=
name|LZMA_STREAM_INIT
decl_stmt|;
comment|// Some systems require setting stdin and stdout to binary mode.
ifdef|#
directive|ifdef
name|TUKLIB_DOSLIKE
name|setmode
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
name|setmode
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
block|{
comment|// No filenames given, decode from stdin.
name|uncompress
argument_list|(
operator|&
name|strm
argument_list|,
name|stdin
argument_list|,
literal|"(stdin)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Loop through the filenames given on the command line.
do|do
block|{
comment|// "-" indicates stdin.
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|uncompress
argument_list|(
operator|&
name|strm
argument_list|,
name|stdin
argument_list|,
literal|"(stdin)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FILE
modifier|*
name|file
init|=
name|fopen
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"rb"
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|my_errorf
argument_list|(
literal|"%s: %s"
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|uncompress
argument_list|(
operator|&
name|strm
argument_list|,
name|file
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|++
name|optind
operator|<
name|argc
condition|)
do|;
block|}
ifndef|#
directive|ifndef
name|NDEBUG
comment|// Free the memory only when debugging. Freeing wastes some time,
comment|// but allows detecting possible memory leaks with Valgrind.
name|lzma_end
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tuklib_exit
argument_list|(
name|EXIT_SUCCESS
argument_list|,
name|EXIT_FAILURE
argument_list|,
name|display_errors
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

