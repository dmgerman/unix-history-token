begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       args.c
end_comment

begin_comment
comment|/// \brief      Argument parsing
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \note       Filter-specific options parsing is in options.c.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Author:     Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"private.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_decl_stmt
name|bool
name|opt_stdout
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_force
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_keep_original
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_robot
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|// We don't modify or free() this, but we need to assign it in some
end_comment

begin_comment
comment|// non-const pointers.
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|stdin_filename
init|=
literal|"(stdin)"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|parse_real
parameter_list|(
name|args_info
modifier|*
name|args
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
enum|enum
block|{
name|OPT_SUBBLOCK
init|=
name|INT_MIN
block|,
name|OPT_X86
block|,
name|OPT_POWERPC
block|,
name|OPT_IA64
block|,
name|OPT_ARM
block|,
name|OPT_ARMTHUMB
block|,
name|OPT_SPARC
block|,
name|OPT_DELTA
block|,
name|OPT_LZMA1
block|,
name|OPT_LZMA2
block|,
name|OPT_NO_SPARSE
block|,
name|OPT_FILES
block|,
name|OPT_FILES0
block|,
name|OPT_INFO_MEMORY
block|,
name|OPT_ROBOT
block|, 	}
enum|;
specifier|static
specifier|const
name|char
name|short_opts
index|[]
init|=
literal|"cC:defF:hHlkM:qQrS:tT:vVz0123456789"
decl_stmt|;
specifier|static
specifier|const
name|struct
name|option
name|long_opts
index|[]
init|=
block|{
comment|// Operation mode
block|{
literal|"compress"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'z'
block|}
block|,
block|{
literal|"decompress"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
block|{
literal|"uncompress"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
block|{
literal|"test"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'t'
block|}
block|,
block|{
literal|"list"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'l'
block|}
block|,
comment|// Operation modifiers
block|{
literal|"keep"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'k'
block|}
block|,
block|{
literal|"force"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'f'
block|}
block|,
block|{
literal|"stdout"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'c'
block|}
block|,
block|{
literal|"to-stdout"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'c'
block|}
block|,
block|{
literal|"no-sparse"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPT_NO_SPARSE
block|}
block|,
block|{
literal|"suffix"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'S'
block|}
block|,
comment|// { "recursive",      no_argument,       NULL,  'r' }, // TODO
block|{
literal|"files"
block|,
name|optional_argument
block|,
name|NULL
block|,
name|OPT_FILES
block|}
block|,
block|{
literal|"files0"
block|,
name|optional_argument
block|,
name|NULL
block|,
name|OPT_FILES0
block|}
block|,
comment|// Basic compression settings
block|{
literal|"format"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'F'
block|}
block|,
block|{
literal|"check"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'C'
block|}
block|,
block|{
literal|"memory"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'M'
block|}
block|,
block|{
literal|"threads"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'T'
block|}
block|,
block|{
literal|"extreme"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'e'
block|}
block|,
block|{
literal|"fast"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'0'
block|}
block|,
block|{
literal|"best"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'9'
block|}
block|,
comment|// Filters
block|{
literal|"lzma1"
block|,
name|optional_argument
block|,
name|NULL
block|,
name|OPT_LZMA1
block|}
block|,
block|{
literal|"lzma2"
block|,
name|optional_argument
block|,
name|NULL
block|,
name|OPT_LZMA2
block|}
block|,
block|{
literal|"x86"
block|,
name|optional_argument
block|,
name|NULL
block|,
name|OPT_X86
block|}
block|,
block|{
literal|"powerpc"
block|,
name|optional_argument
block|,
name|NULL
block|,
name|OPT_POWERPC
block|}
block|,
block|{
literal|"ia64"
block|,
name|optional_argument
block|,
name|NULL
block|,
name|OPT_IA64
block|}
block|,
block|{
literal|"arm"
block|,
name|optional_argument
block|,
name|NULL
block|,
name|OPT_ARM
block|}
block|,
block|{
literal|"armthumb"
block|,
name|optional_argument
block|,
name|NULL
block|,
name|OPT_ARMTHUMB
block|}
block|,
block|{
literal|"sparc"
block|,
name|optional_argument
block|,
name|NULL
block|,
name|OPT_SPARC
block|}
block|,
block|{
literal|"delta"
block|,
name|optional_argument
block|,
name|NULL
block|,
name|OPT_DELTA
block|}
block|,
block|{
literal|"subblock"
block|,
name|optional_argument
block|,
name|NULL
block|,
name|OPT_SUBBLOCK
block|}
block|,
comment|// Other options
block|{
literal|"quiet"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'q'
block|}
block|,
block|{
literal|"verbose"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'v'
block|}
block|,
block|{
literal|"no-warn"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'Q'
block|}
block|,
block|{
literal|"robot"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPT_ROBOT
block|}
block|,
block|{
literal|"info-memory"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPT_INFO_MEMORY
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"long-help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'H'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'V'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|short_opts
argument_list|,
name|long_opts
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
comment|// Compression preset (also for decompression if --format=raw)
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|coder_set_preset
argument_list|(
name|c
operator|-
literal|'0'
argument_list|)
expr_stmt|;
break|break;
comment|// --memory
case|case
literal|'M'
case|:
block|{
comment|// Support specifying the limit as a percentage of
comment|// installed physical RAM.
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|optarg
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|optarg
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'%'
condition|)
block|{
name|optarg
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|hardware_memlimit_set_percentage
argument_list|(
name|str_to_uint64
argument_list|(
literal|"memory%"
argument_list|,
name|optarg
argument_list|,
literal|1
argument_list|,
literal|100
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// On 32-bit systems, SIZE_MAX would make more
comment|// sense than UINT64_MAX. But use UINT64_MAX
comment|// still so that scripts that assume> 4 GiB
comment|// values don't break.
name|hardware_memlimit_set
argument_list|(
name|str_to_uint64
argument_list|(
literal|"memory"
argument_list|,
name|optarg
argument_list|,
literal|0
argument_list|,
name|UINT64_MAX
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|// --suffix
case|case
literal|'S'
case|:
name|suffix_set
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|hardware_threadlimit_set
argument_list|(
name|str_to_uint64
argument_list|(
literal|"threads"
argument_list|,
name|optarg
argument_list|,
literal|0
argument_list|,
name|UINT32_MAX
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// --version
case|case
literal|'V'
case|:
comment|// This doesn't return.
name|message_version
argument_list|()
expr_stmt|;
comment|// --stdout
case|case
literal|'c'
case|:
name|opt_stdout
operator|=
name|true
expr_stmt|;
break|break;
comment|// --decompress
case|case
literal|'d'
case|:
name|opt_mode
operator|=
name|MODE_DECOMPRESS
expr_stmt|;
break|break;
comment|// --extreme
case|case
literal|'e'
case|:
name|coder_set_extreme
argument_list|()
expr_stmt|;
break|break;
comment|// --force
case|case
literal|'f'
case|:
name|opt_force
operator|=
name|true
expr_stmt|;
break|break;
comment|// --info-memory
case|case
name|OPT_INFO_MEMORY
case|:
comment|// This doesn't return.
name|message_memlimit
argument_list|()
expr_stmt|;
comment|// --help
case|case
literal|'h'
case|:
comment|// This doesn't return.
name|message_help
argument_list|(
name|false
argument_list|)
expr_stmt|;
comment|// --long-help
case|case
literal|'H'
case|:
comment|// This doesn't return.
name|message_help
argument_list|(
name|true
argument_list|)
expr_stmt|;
comment|// --list
case|case
literal|'l'
case|:
name|opt_mode
operator|=
name|MODE_LIST
expr_stmt|;
break|break;
comment|// --keep
case|case
literal|'k'
case|:
name|opt_keep_original
operator|=
name|true
expr_stmt|;
break|break;
comment|// --quiet
case|case
literal|'q'
case|:
name|message_verbosity_decrease
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
name|set_exit_no_warn
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|opt_mode
operator|=
name|MODE_TEST
expr_stmt|;
break|break;
comment|// --verbose
case|case
literal|'v'
case|:
name|message_verbosity_increase
argument_list|()
expr_stmt|;
break|break;
comment|// --robot
case|case
name|OPT_ROBOT
case|:
name|opt_robot
operator|=
name|true
expr_stmt|;
comment|// This is to make sure that floating point numbers
comment|// always have a dot as decimal separator.
name|setlocale
argument_list|(
name|LC_NUMERIC
argument_list|,
literal|"C"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|opt_mode
operator|=
name|MODE_COMPRESS
expr_stmt|;
break|break;
comment|// Filter setup
case|case
name|OPT_SUBBLOCK
case|:
name|coder_add_filter
argument_list|(
name|LZMA_FILTER_SUBBLOCK
argument_list|,
name|options_subblock
argument_list|(
name|optarg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_X86
case|:
name|coder_add_filter
argument_list|(
name|LZMA_FILTER_X86
argument_list|,
name|options_bcj
argument_list|(
name|optarg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_POWERPC
case|:
name|coder_add_filter
argument_list|(
name|LZMA_FILTER_POWERPC
argument_list|,
name|options_bcj
argument_list|(
name|optarg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_IA64
case|:
name|coder_add_filter
argument_list|(
name|LZMA_FILTER_IA64
argument_list|,
name|options_bcj
argument_list|(
name|optarg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_ARM
case|:
name|coder_add_filter
argument_list|(
name|LZMA_FILTER_ARM
argument_list|,
name|options_bcj
argument_list|(
name|optarg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_ARMTHUMB
case|:
name|coder_add_filter
argument_list|(
name|LZMA_FILTER_ARMTHUMB
argument_list|,
name|options_bcj
argument_list|(
name|optarg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_SPARC
case|:
name|coder_add_filter
argument_list|(
name|LZMA_FILTER_SPARC
argument_list|,
name|options_bcj
argument_list|(
name|optarg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_DELTA
case|:
name|coder_add_filter
argument_list|(
name|LZMA_FILTER_DELTA
argument_list|,
name|options_delta
argument_list|(
name|optarg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_LZMA1
case|:
name|coder_add_filter
argument_list|(
name|LZMA_FILTER_LZMA1
argument_list|,
name|options_lzma
argument_list|(
name|optarg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_LZMA2
case|:
name|coder_add_filter
argument_list|(
name|LZMA_FILTER_LZMA2
argument_list|,
name|options_lzma
argument_list|(
name|optarg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// Other
comment|// --format
case|case
literal|'F'
case|:
block|{
comment|// Just in case, support both "lzma" and "alone" since
comment|// the latter was used for forward compatibility in
comment|// LZMA Utils 4.32.x.
specifier|static
specifier|const
struct|struct
block|{
name|char
name|str
index|[
literal|8
index|]
decl_stmt|;
name|enum
name|format_type
name|format
decl_stmt|;
block|}
name|types
index|[]
init|=
block|{
block|{
literal|"auto"
block|,
name|FORMAT_AUTO
block|}
block|,
block|{
literal|"xz"
block|,
name|FORMAT_XZ
block|}
block|,
block|{
literal|"lzma"
block|,
name|FORMAT_LZMA
block|}
block|,
block|{
literal|"alone"
block|,
name|FORMAT_LZMA
block|}
block|,
comment|// { "gzip",   FORMAT_GZIP },
comment|// { "gz",     FORMAT_GZIP },
block|{
literal|"raw"
block|,
name|FORMAT_RAW
block|}
block|, 			}
struct|;
name|size_t
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|strcmp
argument_list|(
name|types
index|[
name|i
index|]
operator|.
name|str
argument_list|,
name|optarg
argument_list|)
operator|!=
literal|0
condition|)
if|if
condition|(
operator|++
name|i
operator|==
name|ARRAY_SIZE
argument_list|(
name|types
argument_list|)
condition|)
name|message_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: Unknown file "
literal|"format type"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|opt_format
operator|=
name|types
index|[
name|i
index|]
operator|.
name|format
expr_stmt|;
break|break;
block|}
comment|// --check
case|case
literal|'C'
case|:
block|{
specifier|static
specifier|const
struct|struct
block|{
name|char
name|str
index|[
literal|8
index|]
decl_stmt|;
name|lzma_check
name|check
decl_stmt|;
block|}
name|types
index|[]
init|=
block|{
block|{
literal|"none"
block|,
name|LZMA_CHECK_NONE
block|}
block|,
block|{
literal|"crc32"
block|,
name|LZMA_CHECK_CRC32
block|}
block|,
block|{
literal|"crc64"
block|,
name|LZMA_CHECK_CRC64
block|}
block|,
block|{
literal|"sha256"
block|,
name|LZMA_CHECK_SHA256
block|}
block|, 			}
struct|;
name|size_t
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|strcmp
argument_list|(
name|types
index|[
name|i
index|]
operator|.
name|str
argument_list|,
name|optarg
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|==
name|ARRAY_SIZE
argument_list|(
name|types
argument_list|)
condition|)
name|message_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: Unsupported "
literal|"integrity "
literal|"check type"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
block|}
comment|// Use a separate check in case we are using different
comment|// liblzma than what was used to compile us.
if|if
condition|(
operator|!
name|lzma_check_is_supported
argument_list|(
name|types
index|[
name|i
index|]
operator|.
name|check
argument_list|)
condition|)
name|message_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: Unsupported integrity "
literal|"check type"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|coder_set_check
argument_list|(
name|types
index|[
name|i
index|]
operator|.
name|check
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OPT_NO_SPARSE
case|:
name|io_no_sparse
argument_list|()
expr_stmt|;
break|break;
case|case
name|OPT_FILES
case|:
name|args
operator|->
name|files_delim
operator|=
literal|'\n'
expr_stmt|;
comment|// Fall through
case|case
name|OPT_FILES0
case|:
if|if
condition|(
name|args
operator|->
name|files_name
operator|!=
name|NULL
condition|)
name|message_fatal
argument_list|(
name|_
argument_list|(
literal|"Only one file can be "
literal|"specified with `--files' "
literal|"or `--files0'."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|optarg
operator|==
name|NULL
condition|)
block|{
name|args
operator|->
name|files_name
operator|=
operator|(
name|char
operator|*
operator|)
name|stdin_filename
expr_stmt|;
name|args
operator|->
name|files_file
operator|=
name|stdin
expr_stmt|;
block|}
else|else
block|{
name|args
operator|->
name|files_name
operator|=
name|optarg
expr_stmt|;
name|args
operator|->
name|files_file
operator|=
name|fopen
argument_list|(
name|optarg
argument_list|,
name|c
operator|==
name|OPT_FILES
condition|?
literal|"r"
else|:
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|files_file
operator|==
name|NULL
condition|)
name|message_fatal
argument_list|(
literal|"%s: %s"
argument_list|,
name|optarg
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|message_try_help
argument_list|()
expr_stmt|;
name|tuklib_exit
argument_list|(
name|E_ERROR
argument_list|,
name|E_ERROR
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_environment
parameter_list|(
name|args_info
modifier|*
name|args
parameter_list|,
name|char
modifier|*
name|argv0
parameter_list|)
block|{
name|char
modifier|*
name|env
init|=
name|getenv
argument_list|(
literal|"XZ_OPT"
argument_list|)
decl_stmt|;
if|if
condition|(
name|env
operator|==
name|NULL
condition|)
return|return;
comment|// We modify the string, so make a copy of it.
name|env
operator|=
name|xstrdup
argument_list|(
name|env
argument_list|)
expr_stmt|;
comment|// Calculate the number of arguments in env. argc stats at one
comment|// to include space for the program name.
name|int
name|argc
init|=
literal|1
decl_stmt|;
name|bool
name|prev_was_space
init|=
name|true
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|env
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
operator|++
name|i
control|)
block|{
comment|// NOTE: Cast to unsigned char is needed so that correct
comment|// value gets passed to isspace(), which expects
comment|// unsigned char cast to int. Casting to int is done
comment|// automatically due to integer promotion, but we need to
comment|// force char to unsigned char manually. Otherwise 8-bit
comment|// characters would get promoted to wrong value if
comment|// char is signed.
if|if
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|env
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|prev_was_space
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prev_was_space
condition|)
block|{
name|prev_was_space
operator|=
name|false
expr_stmt|;
comment|// Keep argc small enough to fit into a singed int
comment|// and to keep it usable for memory allocation.
if|if
condition|(
operator|++
name|argc
operator|==
name|MIN
argument_list|(
name|INT_MAX
argument_list|,
name|SIZE_MAX
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
condition|)
name|message_fatal
argument_list|(
name|_
argument_list|(
literal|"The environment variable "
literal|"XZ_OPT contains too many "
literal|"arguments"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Allocate memory to hold pointers to the arguments. Add one to get
comment|// space for the terminating NULL (if some systems happen to need it).
name|char
modifier|*
modifier|*
name|argv
init|=
name|xmalloc
argument_list|(
operator|(
call|(
name|size_t
call|)
argument_list|(
name|argc
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|argv0
expr_stmt|;
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
comment|// Go through the string again. Split the arguments using '\0'
comment|// characters and add pointers to the resulting strings to argv.
name|argc
operator|=
literal|1
expr_stmt|;
name|prev_was_space
operator|=
name|true
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|env
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|env
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|prev_was_space
operator|=
name|true
expr_stmt|;
name|env
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prev_was_space
condition|)
block|{
name|prev_was_space
operator|=
name|false
expr_stmt|;
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|env
operator|+
name|i
expr_stmt|;
block|}
block|}
comment|// Parse the argument list we got from the environment. All non-option
comment|// arguments i.e. filenames are ignored.
name|parse_real
argument_list|(
name|args
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|// Reset the state of the getopt_long() so that we can parse the
comment|// command line options too. There are two incompatible ways to
comment|// do it.
ifdef|#
directive|ifdef
name|HAVE_OPTRESET
comment|// BSD
name|optind
operator|=
literal|1
expr_stmt|;
name|optreset
operator|=
literal|1
expr_stmt|;
else|#
directive|else
comment|// GNU, Solaris
name|optind
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|// We don't need the argument list from environment anymore.
name|free
argument_list|(
name|argv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|env
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|extern
name|void
name|args_parse
parameter_list|(
name|args_info
modifier|*
name|args
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
comment|// Initialize those parts of *args that we need later.
name|args
operator|->
name|files_name
operator|=
name|NULL
expr_stmt|;
name|args
operator|->
name|files_file
operator|=
name|NULL
expr_stmt|;
name|args
operator|->
name|files_delim
operator|=
literal|'\0'
expr_stmt|;
comment|// Check how we were called.
block|{
comment|// Remove the leading path name, if any.
specifier|const
name|char
modifier|*
name|name
init|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
else|else
operator|++
name|name
expr_stmt|;
comment|// NOTE: It's possible that name[0] is now '\0' if argv[0]
comment|// is weird, but it doesn't matter here.
comment|// Look for full command names instead of substrings like
comment|// "un", "cat", and "lz" to reduce possibility of false
comment|// positives when the programs have been renamed.
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"xzcat"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|opt_mode
operator|=
name|MODE_DECOMPRESS
expr_stmt|;
name|opt_stdout
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"unxz"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|opt_mode
operator|=
name|MODE_DECOMPRESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"lzcat"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|opt_format
operator|=
name|FORMAT_LZMA
expr_stmt|;
name|opt_mode
operator|=
name|MODE_DECOMPRESS
expr_stmt|;
name|opt_stdout
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"unlzma"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|opt_format
operator|=
name|FORMAT_LZMA
expr_stmt|;
name|opt_mode
operator|=
name|MODE_DECOMPRESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"lzma"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|opt_format
operator|=
name|FORMAT_LZMA
expr_stmt|;
block|}
block|}
comment|// First the flags from environment
name|parse_environment
argument_list|(
name|args
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Then from the command line
name|parse_real
argument_list|(
name|args
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|// Never remove the source file when the destination is not on disk.
comment|// In test mode the data is written nowhere, but setting opt_stdout
comment|// will make the rest of the code behave well.
if|if
condition|(
name|opt_stdout
operator|||
name|opt_mode
operator|==
name|MODE_TEST
condition|)
block|{
name|opt_keep_original
operator|=
name|true
expr_stmt|;
name|opt_stdout
operator|=
name|true
expr_stmt|;
block|}
comment|// When compressing, if no --format flag was used, or it
comment|// was --format=auto, we compress to the .xz format.
if|if
condition|(
name|opt_mode
operator|==
name|MODE_COMPRESS
operator|&&
name|opt_format
operator|==
name|FORMAT_AUTO
condition|)
name|opt_format
operator|=
name|FORMAT_XZ
expr_stmt|;
comment|// Compression settings need to be validated (options themselves and
comment|// their memory usage) when compressing to any file format. It has to
comment|// be done also when uncompressing raw data, since for raw decoding
comment|// the options given on the command line are used to know what kind
comment|// of raw data we are supposed to decode.
if|if
condition|(
name|opt_mode
operator|==
name|MODE_COMPRESS
operator|||
name|opt_format
operator|==
name|FORMAT_RAW
condition|)
name|coder_set_compression_settings
argument_list|()
expr_stmt|;
comment|// If no filenames are given, use stdin.
if|if
condition|(
name|argv
index|[
name|optind
index|]
operator|==
name|NULL
operator|&&
name|args
operator|->
name|files_name
operator|==
name|NULL
condition|)
block|{
comment|// We don't modify or free() the "-" constant. The caller
comment|// modifies this so don't make the struct itself const.
specifier|static
name|char
modifier|*
name|names_stdin
index|[
literal|2
index|]
init|=
block|{
operator|(
name|char
operator|*
operator|)
literal|"-"
block|,
name|NULL
block|}
decl_stmt|;
name|args
operator|->
name|arg_names
operator|=
name|names_stdin
expr_stmt|;
name|args
operator|->
name|arg_count
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|// We got at least one filename from the command line, or
comment|// --files or --files0 was specified.
name|args
operator|->
name|arg_names
operator|=
name|argv
operator|+
name|optind
expr_stmt|;
name|args
operator|->
name|arg_count
operator|=
name|argc
operator|-
name|optind
expr_stmt|;
block|}
return|return;
block|}
end_function

end_unit

