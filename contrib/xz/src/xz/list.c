begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       list.c
end_comment

begin_comment
comment|/// \brief      Listing information about .xz files
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Author:     Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"private.h"
end_include

begin_include
include|#
directive|include
file|"tuklib_integer.h"
end_include

begin_comment
comment|/// Totals that are displayed if there was more than one file.
end_comment

begin_comment
comment|/// The "files" counter is also used in print_info_adv() to show
end_comment

begin_comment
comment|/// the file number.
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|uint64_t
name|files
decl_stmt|;
name|uint64_t
name|streams
decl_stmt|;
name|uint64_t
name|blocks
decl_stmt|;
name|uint64_t
name|compressed_size
decl_stmt|;
name|uint64_t
name|uncompressed_size
decl_stmt|;
name|uint32_t
name|checks
decl_stmt|;
block|}
name|totals
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
struct|;
end_struct

begin_comment
comment|/// \brief      Parse the Index(es) from the given .xz file
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \param      idx     If decoding is successful, *idx will be set to point
end_comment

begin_comment
comment|///                     to lzma_index containing the decoded information.
end_comment

begin_comment
comment|///                     On error, *idx is not modified.
end_comment

begin_comment
comment|/// \param      pair    Input file
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \return     On success, false is returned. On error, true is returned.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|// TODO: This function is pretty big. liblzma should have a function that
end_comment

begin_comment
comment|// takes a callback function to parse the Index(es) from a .xz file to make
end_comment

begin_comment
comment|// it easy for applications.
end_comment

begin_function
specifier|static
name|bool
name|parse_indexes
parameter_list|(
name|lzma_index
modifier|*
modifier|*
name|idx
parameter_list|,
name|file_pair
modifier|*
name|pair
parameter_list|)
block|{
if|if
condition|(
name|pair
operator|->
name|src_st
operator|.
name|st_size
operator|<=
literal|0
condition|)
block|{
name|message_error
argument_list|(
name|_
argument_list|(
literal|"%s: File is empty"
argument_list|)
argument_list|,
name|pair
operator|->
name|src_name
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|pair
operator|->
name|src_st
operator|.
name|st_size
operator|<
literal|2
operator|*
name|LZMA_STREAM_HEADER_SIZE
condition|)
block|{
name|message_error
argument_list|(
name|_
argument_list|(
literal|"%s: Too small to be a valid .xz file"
argument_list|)
argument_list|,
name|pair
operator|->
name|src_name
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|io_buf
name|buf
decl_stmt|;
name|lzma_stream_flags
name|header_flags
decl_stmt|;
name|lzma_stream_flags
name|footer_flags
decl_stmt|;
name|lzma_ret
name|ret
decl_stmt|;
comment|// lzma_stream for the Index decoder
name|lzma_stream
name|strm
init|=
name|LZMA_STREAM_INIT
decl_stmt|;
comment|// All Indexes decoded so far
name|lzma_index
modifier|*
name|combined_index
init|=
name|NULL
decl_stmt|;
comment|// The Index currently being decoded
name|lzma_index
modifier|*
name|this_index
init|=
name|NULL
decl_stmt|;
comment|// Current position in the file. We parse the file backwards so
comment|// initialize it to point to the end of the file.
name|off_t
name|pos
init|=
name|pair
operator|->
name|src_st
operator|.
name|st_size
decl_stmt|;
comment|// Each loop iteration decodes one Index.
do|do
block|{
comment|// Check that there is enough data left to contain at least
comment|// the Stream Header and Stream Footer. This check cannot
comment|// fail in the first pass of this loop.
if|if
condition|(
name|pos
operator|<
literal|2
operator|*
name|LZMA_STREAM_HEADER_SIZE
condition|)
block|{
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|message_strm
argument_list|(
name|LZMA_DATA_ERROR
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|pos
operator|-=
name|LZMA_STREAM_HEADER_SIZE
expr_stmt|;
name|lzma_vli
name|stream_padding
init|=
literal|0
decl_stmt|;
comment|// Locate the Stream Footer. There may be Stream Padding which
comment|// we must skip when reading backwards.
while|while
condition|(
name|true
condition|)
block|{
if|if
condition|(
name|pos
operator|<
name|LZMA_STREAM_HEADER_SIZE
condition|)
block|{
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|message_strm
argument_list|(
name|LZMA_DATA_ERROR
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|io_pread
argument_list|(
name|pair
argument_list|,
operator|&
name|buf
argument_list|,
name|LZMA_STREAM_HEADER_SIZE
argument_list|,
name|pos
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|// Stream Padding is always a multiple of four bytes.
name|int
name|i
init|=
literal|2
decl_stmt|;
if|if
condition|(
name|buf
operator|.
name|u32
index|[
name|i
index|]
operator|!=
literal|0
condition|)
break|break;
comment|// To avoid calling io_pread() for every four bytes
comment|// of Stream Padding, take advantage that we read
comment|// 12 bytes (LZMA_STREAM_HEADER_SIZE) already and
comment|// check them too before calling io_pread() again.
do|do
block|{
name|stream_padding
operator|+=
literal|4
expr_stmt|;
name|pos
operator|-=
literal|4
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|>=
literal|0
operator|&&
name|buf
operator|.
name|u32
index|[
name|i
index|]
operator|==
literal|0
condition|)
do|;
block|}
comment|// Decode the Stream Footer.
name|ret
operator|=
name|lzma_stream_footer_decode
argument_list|(
operator|&
name|footer_flags
argument_list|,
name|buf
operator|.
name|u8
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|message_strm
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|// Check that the size of the Index field looks sane.
name|lzma_vli
name|index_size
init|=
name|footer_flags
operator|.
name|backward_size
decl_stmt|;
if|if
condition|(
call|(
name|lzma_vli
call|)
argument_list|(
name|pos
argument_list|)
operator|<
name|index_size
operator|+
name|LZMA_STREAM_HEADER_SIZE
condition|)
block|{
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|message_strm
argument_list|(
name|LZMA_DATA_ERROR
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|// Set pos to the beginning of the Index.
name|pos
operator|-=
name|index_size
expr_stmt|;
comment|// See how much memory we can use for decoding this Index.
name|uint64_t
name|memlimit
init|=
name|hardware_memlimit_get
argument_list|()
decl_stmt|;
name|uint64_t
name|memused
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|combined_index
operator|!=
name|NULL
condition|)
block|{
name|memused
operator|=
name|lzma_index_memused
argument_list|(
name|combined_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|memused
operator|>
name|memlimit
condition|)
name|message_bug
argument_list|()
expr_stmt|;
name|memlimit
operator|-=
name|memused
expr_stmt|;
block|}
comment|// Decode the Index.
name|ret
operator|=
name|lzma_index_decoder
argument_list|(
operator|&
name|strm
argument_list|,
operator|&
name|this_index
argument_list|,
name|memlimit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|message_strm
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
do|do
block|{
comment|// Don't give the decoder more input than the
comment|// Index size.
name|strm
operator|.
name|avail_in
operator|=
name|MIN
argument_list|(
name|IO_BUFFER_SIZE
argument_list|,
name|index_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|io_pread
argument_list|(
name|pair
argument_list|,
operator|&
name|buf
argument_list|,
name|strm
operator|.
name|avail_in
argument_list|,
name|pos
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|pos
operator|+=
name|strm
operator|.
name|avail_in
expr_stmt|;
name|index_size
operator|-=
name|strm
operator|.
name|avail_in
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
name|buf
operator|.
name|u8
expr_stmt|;
name|ret
operator|=
name|lzma_code
argument_list|(
operator|&
name|strm
argument_list|,
name|LZMA_RUN
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|==
name|LZMA_OK
condition|)
do|;
comment|// If the decoding seems to be successful, check also that
comment|// the Index decoder consumed as much input as indicated
comment|// by the Backward Size field.
if|if
condition|(
name|ret
operator|==
name|LZMA_STREAM_END
condition|)
if|if
condition|(
name|index_size
operator|!=
literal|0
operator|||
name|strm
operator|.
name|avail_in
operator|!=
literal|0
condition|)
name|ret
operator|=
name|LZMA_DATA_ERROR
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_STREAM_END
condition|)
block|{
comment|// LZMA_BUFFER_ERROR means that the Index decoder
comment|// would have liked more input than what the Index
comment|// size should be according to Stream Footer.
comment|// The message for LZMA_DATA_ERROR makes more
comment|// sense in that case.
if|if
condition|(
name|ret
operator|==
name|LZMA_BUF_ERROR
condition|)
name|ret
operator|=
name|LZMA_DATA_ERROR
expr_stmt|;
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|message_strm
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
comment|// If the error was too low memory usage limit,
comment|// show also how much memory would have been needed.
if|if
condition|(
name|ret
operator|==
name|LZMA_MEMLIMIT_ERROR
condition|)
block|{
name|uint64_t
name|needed
init|=
name|lzma_memusage
argument_list|(
operator|&
name|strm
argument_list|)
decl_stmt|;
if|if
condition|(
name|UINT64_MAX
operator|-
name|needed
operator|<
name|memused
condition|)
name|needed
operator|=
name|UINT64_MAX
expr_stmt|;
else|else
name|needed
operator|+=
name|memused
expr_stmt|;
name|message_mem_needed
argument_list|(
name|V_ERROR
argument_list|,
name|needed
argument_list|)
expr_stmt|;
block|}
goto|goto
name|error
goto|;
block|}
comment|// Decode the Stream Header and check that its Stream Flags
comment|// match the Stream Footer.
name|pos
operator|-=
name|footer_flags
operator|.
name|backward_size
operator|+
name|LZMA_STREAM_HEADER_SIZE
expr_stmt|;
if|if
condition|(
call|(
name|lzma_vli
call|)
argument_list|(
name|pos
argument_list|)
operator|<
name|lzma_index_total_size
argument_list|(
name|this_index
argument_list|)
condition|)
block|{
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|message_strm
argument_list|(
name|LZMA_DATA_ERROR
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|pos
operator|-=
name|lzma_index_total_size
argument_list|(
name|this_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|io_pread
argument_list|(
name|pair
argument_list|,
operator|&
name|buf
argument_list|,
name|LZMA_STREAM_HEADER_SIZE
argument_list|,
name|pos
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|ret
operator|=
name|lzma_stream_header_decode
argument_list|(
operator|&
name|header_flags
argument_list|,
name|buf
operator|.
name|u8
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|message_strm
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|ret
operator|=
name|lzma_stream_flags_compare
argument_list|(
operator|&
name|header_flags
argument_list|,
operator|&
name|footer_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|message_strm
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|// Store the decoded Stream Flags into this_index. This is
comment|// needed so that we can print which Check is used in each
comment|// Stream.
name|ret
operator|=
name|lzma_index_stream_flags
argument_list|(
name|this_index
argument_list|,
operator|&
name|footer_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
name|message_bug
argument_list|()
expr_stmt|;
comment|// Store also the size of the Stream Padding field. It is
comment|// needed to show the offsets of the Streams correctly.
name|ret
operator|=
name|lzma_index_stream_padding
argument_list|(
name|this_index
argument_list|,
name|stream_padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
name|message_bug
argument_list|()
expr_stmt|;
if|if
condition|(
name|combined_index
operator|!=
name|NULL
condition|)
block|{
comment|// Append the earlier decoded Indexes
comment|// after this_index.
name|ret
operator|=
name|lzma_index_cat
argument_list|(
name|this_index
argument_list|,
name|combined_index
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|message_strm
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
name|combined_index
operator|=
name|this_index
expr_stmt|;
name|this_index
operator|=
name|NULL
expr_stmt|;
block|}
do|while
condition|(
name|pos
operator|>
literal|0
condition|)
do|;
name|lzma_end
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
comment|// All OK. Make combined_index available to the caller.
operator|*
name|idx
operator|=
name|combined_index
expr_stmt|;
return|return
name|false
return|;
name|error
label|:
comment|// Something went wrong, free the allocated memory.
name|lzma_end
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
name|lzma_index_end
argument_list|(
name|combined_index
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|lzma_index_end
argument_list|(
name|this_index
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/// \brief      Get the compression ratio
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This has slightly different format than that is used by in message.c.
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_ratio
parameter_list|(
name|uint64_t
name|compressed_size
parameter_list|,
name|uint64_t
name|uncompressed_size
parameter_list|)
block|{
if|if
condition|(
name|uncompressed_size
operator|==
literal|0
condition|)
return|return
literal|"---"
return|;
specifier|const
name|double
name|ratio
init|=
call|(
name|double
call|)
argument_list|(
name|compressed_size
argument_list|)
operator|/
call|(
name|double
call|)
argument_list|(
name|uncompressed_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|ratio
operator|>
literal|9.999
condition|)
return|return
literal|"---"
return|;
specifier|static
name|char
name|buf
index|[
literal|6
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%.3f"
argument_list|,
name|ratio
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
name|check_names
index|[
name|LZMA_CHECK_ID_MAX
operator|+
literal|1
index|]
index|[
literal|12
index|]
init|=
block|{
literal|"None"
block|,
literal|"CRC32"
block|,
literal|"Unknown-2"
block|,
literal|"Unknown-3"
block|,
literal|"CRC64"
block|,
literal|"Unknown-5"
block|,
literal|"Unknown-6"
block|,
literal|"Unknown-7"
block|,
literal|"Unknown-8"
block|,
literal|"Unknown-9"
block|,
literal|"SHA-256"
block|,
literal|"Unknown-11"
block|,
literal|"Unknown-12"
block|,
literal|"Unknown-13"
block|,
literal|"Unknown-14"
block|,
literal|"Unknown-15"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// \brief      Get a comma-separated list of Check names
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \param      checks  Bit mask of Checks to print
end_comment

begin_comment
comment|/// \param      space_after_comma
end_comment

begin_comment
comment|///                     It's better to not use spaces in table-like listings,
end_comment

begin_comment
comment|///                     but in more verbose formats a space after a comma
end_comment

begin_comment
comment|///                     is good for readability.
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_check_names
parameter_list|(
name|uint32_t
name|checks
parameter_list|,
name|bool
name|space_after_comma
parameter_list|)
block|{
name|assert
argument_list|(
name|checks
operator|!=
literal|0
argument_list|)
expr_stmt|;
specifier|static
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|check_names
argument_list|)
index|]
decl_stmt|;
name|char
modifier|*
name|pos
init|=
name|buf
decl_stmt|;
name|size_t
name|left
init|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|sep
init|=
name|space_after_comma
condition|?
literal|", "
else|:
literal|","
decl_stmt|;
name|bool
name|comma
init|=
name|false
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|LZMA_CHECK_ID_MAX
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|checks
operator|&
operator|(
name|UINT32_C
argument_list|(
literal|1
argument_list|)
operator|<<
name|i
operator|)
condition|)
block|{
name|my_snprintf
argument_list|(
operator|&
name|pos
argument_list|,
operator|&
name|left
argument_list|,
literal|"%s%s"
argument_list|,
name|comma
condition|?
name|sep
else|:
literal|""
argument_list|,
name|check_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|comma
operator|=
name|true
expr_stmt|;
block|}
block|}
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/// \brief      Read the Check value from the .xz file and print it
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Since this requires a seek, listing all Check values for all Blocks can
end_comment

begin_comment
comment|/// be slow.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \param      pair    Input file
end_comment

begin_comment
comment|/// \param      iter    Location of the Block whose Check value should
end_comment

begin_comment
comment|///                     be printed.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \return     False on success, true on I/O error.
end_comment

begin_function
specifier|static
name|bool
name|print_check_value
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|,
specifier|const
name|lzma_index_iter
modifier|*
name|iter
parameter_list|)
block|{
comment|// Don't read anything from the file if there is no integrity Check.
if|if
condition|(
name|iter
operator|->
name|stream
operator|.
name|flags
operator|->
name|check
operator|==
name|LZMA_CHECK_NONE
condition|)
block|{
name|printf
argument_list|(
literal|"---"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|// Locate and read the Check field.
specifier|const
name|uint32_t
name|size
init|=
name|lzma_check_size
argument_list|(
name|iter
operator|->
name|stream
operator|.
name|flags
operator|->
name|check
argument_list|)
decl_stmt|;
specifier|const
name|off_t
name|offset
init|=
name|iter
operator|->
name|block
operator|.
name|compressed_file_offset
operator|+
name|iter
operator|->
name|block
operator|.
name|total_size
operator|-
name|size
decl_stmt|;
name|io_buf
name|buf
decl_stmt|;
if|if
condition|(
name|io_pread
argument_list|(
name|pair
argument_list|,
operator|&
name|buf
argument_list|,
name|size
argument_list|,
name|offset
argument_list|)
condition|)
return|return
name|true
return|;
comment|// CRC32 and CRC64 are in little endian. Guess that all the future
comment|// 32-bit and 64-bit Check values are little endian too. It shouldn't
comment|// be a too big problem if this guess is wrong.
if|if
condition|(
name|size
operator|==
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"%08"
name|PRIx32
argument_list|,
name|conv32le
argument_list|(
name|buf
operator|.
name|u32
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|8
condition|)
block|{
name|printf
argument_list|(
literal|"%016"
name|PRIx64
argument_list|,
name|conv64le
argument_list|(
name|buf
operator|.
name|u64
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|buf
operator|.
name|u8
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_info_basic
parameter_list|(
specifier|const
name|lzma_index
modifier|*
name|idx
parameter_list|,
name|file_pair
modifier|*
name|pair
parameter_list|)
block|{
specifier|static
name|bool
name|headings_displayed
init|=
name|false
decl_stmt|;
if|if
condition|(
operator|!
name|headings_displayed
condition|)
block|{
name|headings_displayed
operator|=
name|true
expr_stmt|;
comment|// TRANSLATORS: These are column titles. From Strms (Streams)
comment|// to Ratio, the columns are right aligned. Check and Filename
comment|// are left aligned. If you need longer words, it's OK to
comment|// use two lines here. Test with xz --list.
name|puts
argument_list|(
name|_
argument_list|(
literal|"Strms  Blocks   Compressed Uncompressed  Ratio  "
literal|"Check   Filename"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%5s %7s  %11s  %11s  %5s  %-7s %s\n"
argument_list|,
name|uint64_to_str
argument_list|(
name|lzma_index_stream_count
argument_list|(
name|idx
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|uint64_to_str
argument_list|(
name|lzma_index_block_count
argument_list|(
name|idx
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|uint64_to_nicestr
argument_list|(
name|lzma_index_file_size
argument_list|(
name|idx
argument_list|)
argument_list|,
name|NICESTR_B
argument_list|,
name|NICESTR_TIB
argument_list|,
name|false
argument_list|,
literal|2
argument_list|)
argument_list|,
name|uint64_to_nicestr
argument_list|(
name|lzma_index_uncompressed_size
argument_list|(
name|idx
argument_list|)
argument_list|,
name|NICESTR_B
argument_list|,
name|NICESTR_TIB
argument_list|,
name|false
argument_list|,
literal|3
argument_list|)
argument_list|,
name|get_ratio
argument_list|(
name|lzma_index_file_size
argument_list|(
name|idx
argument_list|)
argument_list|,
name|lzma_index_uncompressed_size
argument_list|(
name|idx
argument_list|)
argument_list|)
argument_list|,
name|get_check_names
argument_list|(
name|lzma_index_checks
argument_list|(
name|idx
argument_list|)
argument_list|,
name|false
argument_list|)
argument_list|,
name|pair
operator|->
name|src_name
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|print_adv_helper
parameter_list|(
name|uint64_t
name|stream_count
parameter_list|,
name|uint64_t
name|block_count
parameter_list|,
name|uint64_t
name|compressed_size
parameter_list|,
name|uint64_t
name|uncompressed_size
parameter_list|,
name|uint32_t
name|checks
parameter_list|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Stream count:       %s\n"
argument_list|)
argument_list|,
name|uint64_to_str
argument_list|(
name|stream_count
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Block count:        %s\n"
argument_list|)
argument_list|,
name|uint64_to_str
argument_list|(
name|block_count
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Compressed size:    %s\n"
argument_list|)
argument_list|,
name|uint64_to_nicestr
argument_list|(
name|compressed_size
argument_list|,
name|NICESTR_B
argument_list|,
name|NICESTR_TIB
argument_list|,
name|true
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Uncompressed size:  %s\n"
argument_list|)
argument_list|,
name|uint64_to_nicestr
argument_list|(
name|uncompressed_size
argument_list|,
name|NICESTR_B
argument_list|,
name|NICESTR_TIB
argument_list|,
name|true
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Ratio:              %s\n"
argument_list|)
argument_list|,
name|get_ratio
argument_list|(
name|compressed_size
argument_list|,
name|uncompressed_size
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Check:              %s\n"
argument_list|)
argument_list|,
name|get_check_names
argument_list|(
name|checks
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|print_info_adv
parameter_list|(
specifier|const
name|lzma_index
modifier|*
name|idx
parameter_list|,
name|file_pair
modifier|*
name|pair
parameter_list|)
block|{
comment|// Print the overall information.
name|print_adv_helper
argument_list|(
name|lzma_index_stream_count
argument_list|(
name|idx
argument_list|)
argument_list|,
name|lzma_index_block_count
argument_list|(
name|idx
argument_list|)
argument_list|,
name|lzma_index_file_size
argument_list|(
name|idx
argument_list|)
argument_list|,
name|lzma_index_uncompressed_size
argument_list|(
name|idx
argument_list|)
argument_list|,
name|lzma_index_checks
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
comment|// TODO: The rest of this function needs some work. Currently
comment|// the offsets are not printed, which could be useful even when
comment|// printed in a less accurate format. On the other hand, maybe
comment|// this should print the information with exact byte values,
comment|// or maybe there should be at least an option to do that.
comment|//
comment|// We could also display some other info. E.g. it could be useful
comment|// to quickly see how big is the biggest Block (uncompressed size)
comment|// and if all Blocks have Compressed Size and Uncompressed Size
comment|// fields present, which can be used e.g. for multithreaded
comment|// decompression.
comment|// Avoid printing Stream and Block lists when they wouldn't be useful.
name|bool
name|show_blocks
init|=
name|false
decl_stmt|;
if|if
condition|(
name|lzma_index_stream_count
argument_list|(
name|idx
argument_list|)
operator|>
literal|1
condition|)
block|{
name|puts
argument_list|(
name|_
argument_list|(
literal|"  Streams:"
argument_list|)
argument_list|)
expr_stmt|;
name|puts
argument_list|(
name|_
argument_list|(
literal|"      Number      Blocks    Compressed   "
literal|"Uncompressed   Ratio   Check"
argument_list|)
argument_list|)
expr_stmt|;
name|lzma_index_iter
name|iter
decl_stmt|;
name|lzma_index_iter_init
argument_list|(
operator|&
name|iter
argument_list|,
name|idx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|lzma_index_iter_next
argument_list|(
operator|&
name|iter
argument_list|,
name|LZMA_INDEX_ITER_STREAM
argument_list|)
condition|)
block|{
if|if
condition|(
name|iter
operator|.
name|stream
operator|.
name|block_count
operator|>
literal|1
condition|)
name|show_blocks
operator|=
name|true
expr_stmt|;
name|printf
argument_list|(
literal|"    %8s  %10s   %11s    %11s   %5s   %s\n"
argument_list|,
name|uint64_to_str
argument_list|(
name|iter
operator|.
name|stream
operator|.
name|number
argument_list|,
literal|0
argument_list|)
argument_list|,
name|uint64_to_str
argument_list|(
name|iter
operator|.
name|stream
operator|.
name|block_count
argument_list|,
literal|1
argument_list|)
argument_list|,
name|uint64_to_nicestr
argument_list|(
name|iter
operator|.
name|stream
operator|.
name|compressed_size
argument_list|,
name|NICESTR_B
argument_list|,
name|NICESTR_TIB
argument_list|,
name|false
argument_list|,
literal|2
argument_list|)
argument_list|,
name|uint64_to_nicestr
argument_list|(
name|iter
operator|.
name|stream
operator|.
name|uncompressed_size
argument_list|,
name|NICESTR_B
argument_list|,
name|NICESTR_TIB
argument_list|,
name|false
argument_list|,
literal|3
argument_list|)
argument_list|,
name|get_ratio
argument_list|(
name|iter
operator|.
name|stream
operator|.
name|compressed_size
argument_list|,
name|iter
operator|.
name|stream
operator|.
name|uncompressed_size
argument_list|)
argument_list|,
name|check_names
index|[
name|iter
operator|.
name|stream
operator|.
name|flags
operator|->
name|check
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|show_blocks
operator|||
name|lzma_index_block_count
argument_list|(
name|idx
argument_list|)
operator|>
name|lzma_index_stream_count
argument_list|(
name|idx
argument_list|)
operator|||
name|message_verbosity_get
argument_list|()
operator|>=
name|V_DEBUG
condition|)
block|{
name|puts
argument_list|(
name|_
argument_list|(
literal|"  Blocks:"
argument_list|)
argument_list|)
expr_stmt|;
comment|// FIXME: Number in Stream/file, which one is better?
name|puts
argument_list|(
name|_
argument_list|(
literal|"      Stream      Number    Compressed   "
literal|"Uncompressed   Ratio   Check"
argument_list|)
argument_list|)
expr_stmt|;
name|lzma_index_iter
name|iter
decl_stmt|;
name|lzma_index_iter_init
argument_list|(
operator|&
name|iter
argument_list|,
name|idx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|lzma_index_iter_next
argument_list|(
operator|&
name|iter
argument_list|,
name|LZMA_INDEX_ITER_BLOCK
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"    %8s  %10s   %11s    %11s   %5s   %-7s"
argument_list|,
name|uint64_to_str
argument_list|(
name|iter
operator|.
name|stream
operator|.
name|number
argument_list|,
literal|0
argument_list|)
argument_list|,
name|uint64_to_str
argument_list|(
name|iter
operator|.
name|block
operator|.
name|number_in_stream
argument_list|,
literal|1
argument_list|)
argument_list|,
name|uint64_to_nicestr
argument_list|(
name|iter
operator|.
name|block
operator|.
name|total_size
argument_list|,
name|NICESTR_B
argument_list|,
name|NICESTR_TIB
argument_list|,
name|false
argument_list|,
literal|2
argument_list|)
argument_list|,
name|uint64_to_nicestr
argument_list|(
name|iter
operator|.
name|block
operator|.
name|uncompressed_size
argument_list|,
name|NICESTR_B
argument_list|,
name|NICESTR_TIB
argument_list|,
name|false
argument_list|,
literal|3
argument_list|)
argument_list|,
name|get_ratio
argument_list|(
name|iter
operator|.
name|block
operator|.
name|total_size
argument_list|,
name|iter
operator|.
name|block
operator|.
name|uncompressed_size
argument_list|)
argument_list|,
name|check_names
index|[
name|iter
operator|.
name|stream
operator|.
name|flags
operator|->
name|check
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|message_verbosity_get
argument_list|()
operator|>=
name|V_DEBUG
condition|)
if|if
condition|(
name|print_check_value
argument_list|(
name|pair
argument_list|,
operator|&
name|iter
argument_list|)
condition|)
return|return;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_info_robot
parameter_list|(
specifier|const
name|lzma_index
modifier|*
name|idx
parameter_list|,
name|file_pair
modifier|*
name|pair
parameter_list|)
block|{
name|printf
argument_list|(
literal|"file\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%s\t%s\t%s\n"
argument_list|,
name|lzma_index_stream_count
argument_list|(
name|idx
argument_list|)
argument_list|,
name|lzma_index_block_count
argument_list|(
name|idx
argument_list|)
argument_list|,
name|lzma_index_file_size
argument_list|(
name|idx
argument_list|)
argument_list|,
name|lzma_index_uncompressed_size
argument_list|(
name|idx
argument_list|)
argument_list|,
name|get_ratio
argument_list|(
name|lzma_index_file_size
argument_list|(
name|idx
argument_list|)
argument_list|,
name|lzma_index_uncompressed_size
argument_list|(
name|idx
argument_list|)
argument_list|)
argument_list|,
name|get_check_names
argument_list|(
name|lzma_index_checks
argument_list|(
name|idx
argument_list|)
argument_list|,
name|false
argument_list|)
argument_list|,
name|pair
operator|->
name|src_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|message_verbosity_get
argument_list|()
operator|>=
name|V_VERBOSE
condition|)
block|{
name|lzma_index_iter
name|iter
decl_stmt|;
name|lzma_index_iter_init
argument_list|(
operator|&
name|iter
argument_list|,
name|idx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|lzma_index_iter_next
argument_list|(
operator|&
name|iter
argument_list|,
name|LZMA_INDEX_ITER_STREAM
argument_list|)
condition|)
name|printf
argument_list|(
literal|"stream\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%s\t%"
name|PRIu64
literal|"\t%s\n"
argument_list|,
name|iter
operator|.
name|stream
operator|.
name|number
argument_list|,
name|iter
operator|.
name|stream
operator|.
name|compressed_offset
argument_list|,
name|iter
operator|.
name|stream
operator|.
name|uncompressed_offset
argument_list|,
name|iter
operator|.
name|stream
operator|.
name|compressed_size
argument_list|,
name|iter
operator|.
name|stream
operator|.
name|uncompressed_size
argument_list|,
name|get_ratio
argument_list|(
name|iter
operator|.
name|stream
operator|.
name|compressed_size
argument_list|,
name|iter
operator|.
name|stream
operator|.
name|uncompressed_size
argument_list|)
argument_list|,
name|iter
operator|.
name|stream
operator|.
name|padding
argument_list|,
name|check_names
index|[
name|iter
operator|.
name|stream
operator|.
name|flags
operator|->
name|check
index|]
argument_list|)
expr_stmt|;
name|lzma_index_iter_rewind
argument_list|(
operator|&
name|iter
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|lzma_index_iter_next
argument_list|(
operator|&
name|iter
argument_list|,
name|LZMA_INDEX_ITER_BLOCK
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"block\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%s\t%s"
argument_list|,
name|iter
operator|.
name|stream
operator|.
name|number
argument_list|,
name|iter
operator|.
name|block
operator|.
name|number_in_stream
argument_list|,
name|iter
operator|.
name|block
operator|.
name|number_in_file
argument_list|,
name|iter
operator|.
name|block
operator|.
name|compressed_file_offset
argument_list|,
name|iter
operator|.
name|block
operator|.
name|uncompressed_file_offset
argument_list|,
name|iter
operator|.
name|block
operator|.
name|total_size
argument_list|,
name|iter
operator|.
name|block
operator|.
name|uncompressed_size
argument_list|,
name|get_ratio
argument_list|(
name|iter
operator|.
name|block
operator|.
name|total_size
argument_list|,
name|iter
operator|.
name|block
operator|.
name|uncompressed_size
argument_list|)
argument_list|,
name|check_names
index|[
name|iter
operator|.
name|stream
operator|.
name|flags
operator|->
name|check
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|message_verbosity_get
argument_list|()
operator|>=
name|V_DEBUG
condition|)
block|{
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_check_value
argument_list|(
name|pair
argument_list|,
operator|&
name|iter
argument_list|)
condition|)
return|return;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|update_totals
parameter_list|(
specifier|const
name|lzma_index
modifier|*
name|idx
parameter_list|)
block|{
comment|// TODO: Integer overflow checks
operator|++
name|totals
operator|.
name|files
expr_stmt|;
name|totals
operator|.
name|streams
operator|+=
name|lzma_index_stream_count
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|totals
operator|.
name|blocks
operator|+=
name|lzma_index_block_count
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|totals
operator|.
name|compressed_size
operator|+=
name|lzma_index_file_size
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|totals
operator|.
name|uncompressed_size
operator|+=
name|lzma_index_uncompressed_size
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|totals
operator|.
name|checks
operator||=
name|lzma_index_checks
argument_list|(
name|idx
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|print_totals_basic
parameter_list|(
name|void
parameter_list|)
block|{
comment|// Print a separator line.
name|char
name|line
index|[
literal|80
index|]
decl_stmt|;
name|memset
argument_list|(
name|line
argument_list|,
literal|'-'
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|line
index|[
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|puts
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|// Print the totals except the file count, which needs
comment|// special handling.
name|printf
argument_list|(
literal|"%5s %7s  %11s  %11s  %5s  %-7s "
argument_list|,
name|uint64_to_str
argument_list|(
name|totals
operator|.
name|streams
argument_list|,
literal|0
argument_list|)
argument_list|,
name|uint64_to_str
argument_list|(
name|totals
operator|.
name|blocks
argument_list|,
literal|1
argument_list|)
argument_list|,
name|uint64_to_nicestr
argument_list|(
name|totals
operator|.
name|compressed_size
argument_list|,
name|NICESTR_B
argument_list|,
name|NICESTR_TIB
argument_list|,
name|false
argument_list|,
literal|2
argument_list|)
argument_list|,
name|uint64_to_nicestr
argument_list|(
name|totals
operator|.
name|uncompressed_size
argument_list|,
name|NICESTR_B
argument_list|,
name|NICESTR_TIB
argument_list|,
name|false
argument_list|,
literal|3
argument_list|)
argument_list|,
name|get_ratio
argument_list|(
name|totals
operator|.
name|compressed_size
argument_list|,
name|totals
operator|.
name|uncompressed_size
argument_list|)
argument_list|,
name|get_check_names
argument_list|(
name|totals
operator|.
name|checks
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// Since we print totals only when there are at least two files,
comment|// the English message will always use "%s files". But some other
comment|// languages need different forms for different plurals so we
comment|// have to translate this string still.
comment|//
comment|// TRANSLATORS: This simply indicates the number of files shown
comment|// by --list even though the format string uses %s.
name|printf
argument_list|(
name|N_
argument_list|(
literal|"%s file"
argument_list|,
literal|"%s files\n"
argument_list|,
name|totals
operator|.
name|files
operator|<=
name|ULONG_MAX
condition|?
name|totals
operator|.
name|files
else|:
operator|(
name|totals
operator|.
name|files
operator|%
literal|1000000
operator|)
operator|+
literal|1000000
argument_list|)
argument_list|,
name|uint64_to_str
argument_list|(
name|totals
operator|.
name|files
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|print_totals_adv
parameter_list|(
name|void
parameter_list|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|puts
argument_list|(
name|_
argument_list|(
literal|"Totals:"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Number of files:    %s\n"
argument_list|)
argument_list|,
name|uint64_to_str
argument_list|(
name|totals
operator|.
name|files
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|print_adv_helper
argument_list|(
name|totals
operator|.
name|streams
argument_list|,
name|totals
operator|.
name|blocks
argument_list|,
name|totals
operator|.
name|compressed_size
argument_list|,
name|totals
operator|.
name|uncompressed_size
argument_list|,
name|totals
operator|.
name|checks
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|print_totals_robot
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"totals\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%s\t%s\t%"
name|PRIu64
literal|"\n"
argument_list|,
name|totals
operator|.
name|streams
argument_list|,
name|totals
operator|.
name|blocks
argument_list|,
name|totals
operator|.
name|compressed_size
argument_list|,
name|totals
operator|.
name|uncompressed_size
argument_list|,
name|get_ratio
argument_list|(
name|totals
operator|.
name|compressed_size
argument_list|,
name|totals
operator|.
name|uncompressed_size
argument_list|)
argument_list|,
name|get_check_names
argument_list|(
name|totals
operator|.
name|checks
argument_list|,
name|false
argument_list|)
argument_list|,
name|totals
operator|.
name|files
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|extern
name|void
name|list_totals
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|opt_robot
condition|)
block|{
comment|// Always print totals in --robot mode. It can be convenient
comment|// in some cases and doesn't complicate usage of the
comment|// single-file case much.
name|print_totals_robot
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|totals
operator|.
name|files
operator|>
literal|1
condition|)
block|{
comment|// For non-robot mode, totals are printed only if there
comment|// is more than one file.
if|if
condition|(
name|message_verbosity_get
argument_list|()
operator|<=
name|V_WARNING
condition|)
name|print_totals_basic
argument_list|()
expr_stmt|;
else|else
name|print_totals_adv
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|extern
name|void
name|list_file
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
if|if
condition|(
name|opt_format
operator|!=
name|FORMAT_XZ
operator|&&
name|opt_format
operator|!=
name|FORMAT_AUTO
condition|)
name|message_fatal
argument_list|(
name|_
argument_list|(
literal|"--list works only on .xz files "
literal|"(--format=xz or --format=auto)"
argument_list|)
argument_list|)
expr_stmt|;
name|message_filename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|stdin_filename
condition|)
block|{
name|message_error
argument_list|(
name|_
argument_list|(
literal|"--list does not support reading from "
literal|"standard input"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Unset opt_stdout so that io_open_src() won't accept special files.
comment|// Set opt_force so that io_open_src() will follow symlinks.
name|opt_stdout
operator|=
name|false
expr_stmt|;
name|opt_force
operator|=
name|true
expr_stmt|;
name|file_pair
modifier|*
name|pair
init|=
name|io_open_src
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
name|NULL
condition|)
return|return;
name|lzma_index
modifier|*
name|idx
decl_stmt|;
if|if
condition|(
operator|!
name|parse_indexes
argument_list|(
operator|&
name|idx
argument_list|,
name|pair
argument_list|)
condition|)
block|{
comment|// Update the totals that are displayed after all
comment|// the individual files have been listed.
name|update_totals
argument_list|(
name|idx
argument_list|)
expr_stmt|;
comment|// We have three main modes:
comment|//  - --robot, which has submodes if --verbose is specified
comment|//    once or twice
comment|//  - Normal --list without --verbose
comment|//  - --list with one or two --verbose
if|if
condition|(
name|opt_robot
condition|)
name|print_info_robot
argument_list|(
name|idx
argument_list|,
name|pair
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|message_verbosity_get
argument_list|()
operator|<=
name|V_WARNING
condition|)
name|print_info_basic
argument_list|(
name|idx
argument_list|,
name|pair
argument_list|)
expr_stmt|;
else|else
name|print_info_adv
argument_list|(
name|idx
argument_list|,
name|pair
argument_list|)
expr_stmt|;
name|lzma_index_end
argument_list|(
name|idx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|io_close
argument_list|(
name|pair
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

