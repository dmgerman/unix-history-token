begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       options.c
end_comment

begin_comment
comment|/// \brief      Parser for filter-specific options
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Author:     Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"private.h"
end_include

begin_comment
comment|///////////////////
end_comment

begin_comment
comment|// Generic stuff //
end_comment

begin_comment
comment|///////////////////
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|uint64_t
name|id
decl_stmt|;
block|}
name|name_id_map
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|name_id_map
modifier|*
name|map
decl_stmt|;
name|uint64_t
name|min
decl_stmt|;
name|uint64_t
name|max
decl_stmt|;
block|}
name|option_map
typedef|;
end_typedef

begin_comment
comment|/// Parses option=value pairs that are separated with commas:
end_comment

begin_comment
comment|/// opt=val,opt=val,opt=val
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Each option is a string, that is converted to an integer using the
end_comment

begin_comment
comment|/// index where the option string is in the array.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Value can be
end_comment

begin_comment
comment|///  - a string-id map mapping a list of possible string values to integers
end_comment

begin_comment
comment|///    (opts[i].map != NULL, opts[i].min and opts[i].max are ignored);
end_comment

begin_comment
comment|///  - a number with minimum and maximum value limit
end_comment

begin_comment
comment|///    (opts[i].map == NULL&& opts[i].min != UINT64_MAX);
end_comment

begin_comment
comment|///  - a string that will be parsed by the filter-specific code
end_comment

begin_comment
comment|///    (opts[i].map == NULL&& opts[i].min == UINT64_MAX, opts[i].max ignored)
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// When parsing both option and value succeed, a filter-specific function
end_comment

begin_comment
comment|/// is called, which should update the given value to filter-specific
end_comment

begin_comment
comment|/// options structure.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \param      str     String containing the options from the command line
end_comment

begin_comment
comment|/// \param      opts    Filter-specific option map
end_comment

begin_comment
comment|/// \param      set     Filter-specific function to update filter_options
end_comment

begin_comment
comment|/// \param      filter_options  Pointer to filter-specific options structure
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \return     Returns only if no errors occur.
end_comment

begin_comment
comment|///
end_comment

begin_function
specifier|static
name|void
name|parse_options
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|option_map
modifier|*
name|opts
parameter_list|,
name|void
function_decl|(
modifier|*
name|set
function_decl|)
parameter_list|(
name|void
modifier|*
name|filter_options
parameter_list|,
name|unsigned
name|key
parameter_list|,
name|uint64_t
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|valuestr
parameter_list|)
parameter_list|,
name|void
modifier|*
name|filter_options
parameter_list|)
block|{
if|if
condition|(
name|str
operator|==
name|NULL
operator|||
name|str
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return;
name|char
modifier|*
name|s
init|=
name|xstrdup
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|s
decl_stmt|;
while|while
condition|(
operator|*
name|name
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|name
operator|==
literal|','
condition|)
block|{
operator|++
name|name
expr_stmt|;
continue|continue;
block|}
name|char
modifier|*
name|split
init|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|','
argument_list|)
decl_stmt|;
if|if
condition|(
name|split
operator|!=
name|NULL
condition|)
operator|*
name|split
operator|=
literal|'\0'
expr_stmt|;
name|char
modifier|*
name|value
init|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'='
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
operator|*
name|value
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
operator|||
name|value
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|message_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: Options must be `name=value' "
literal|"pairs separated with commas"
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|// Look for the option name from the option map.
name|unsigned
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
if|if
condition|(
name|opts
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
name|message_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: Invalid option name"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|opts
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
operator|++
name|i
expr_stmt|;
block|}
comment|// Option was found from the map. See how we should handle it.
if|if
condition|(
name|opts
index|[
name|i
index|]
operator|.
name|map
operator|!=
name|NULL
condition|)
block|{
comment|// value is a string which we should map
comment|// to an integer.
name|unsigned
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|opts
index|[
name|i
index|]
operator|.
name|map
index|[
name|j
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|opts
index|[
name|i
index|]
operator|.
name|map
index|[
name|j
index|]
operator|.
name|name
argument_list|,
name|value
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|opts
index|[
name|i
index|]
operator|.
name|map
index|[
name|j
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
name|message_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: Invalid option value"
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|filter_options
argument_list|,
name|i
argument_list|,
name|opts
index|[
name|i
index|]
operator|.
name|map
index|[
name|j
index|]
operator|.
name|id
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opts
index|[
name|i
index|]
operator|.
name|min
operator|==
name|UINT64_MAX
condition|)
block|{
comment|// value is a special string that will be
comment|// parsed by set().
name|set
argument_list|(
name|filter_options
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// value is an integer.
specifier|const
name|uint64_t
name|v
init|=
name|str_to_uint64
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|opts
index|[
name|i
index|]
operator|.
name|min
argument_list|,
name|opts
index|[
name|i
index|]
operator|.
name|max
argument_list|)
decl_stmt|;
name|set
argument_list|(
name|filter_options
argument_list|,
name|i
argument_list|,
name|v
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|// Check if it was the last option.
if|if
condition|(
name|split
operator|==
name|NULL
condition|)
break|break;
name|name
operator|=
name|split
operator|+
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|///////////
end_comment

begin_comment
comment|// Delta //
end_comment

begin_comment
comment|///////////
end_comment

begin_enum
enum|enum
block|{
name|OPT_DIST
block|, }
enum|;
end_enum

begin_decl_stmt
specifier|static
name|void
name|set_delta
argument_list|(
name|void
operator|*
name|options
argument_list|,
name|unsigned
name|key
argument_list|,
name|uint64_t
name|value
argument_list|,
specifier|const
name|char
operator|*
name|valuestr
name|lzma_attribute
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|)
block|{
name|lzma_options_delta
modifier|*
name|opt
init|=
name|options
decl_stmt|;
switch|switch
condition|(
name|key
condition|)
block|{
case|case
name|OPT_DIST
case|:
name|opt
operator|->
name|dist
operator|=
name|value
expr_stmt|;
break|break;
block|}
block|}
end_decl_stmt

begin_function
specifier|extern
name|lzma_options_delta
modifier|*
name|options_delta
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|static
specifier|const
name|option_map
name|opts
index|[]
init|=
block|{
block|{
literal|"dist"
block|,
name|NULL
block|,
name|LZMA_DELTA_DIST_MIN
block|,
name|LZMA_DELTA_DIST_MAX
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
name|lzma_options_delta
modifier|*
name|options
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lzma_options_delta
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|options
operator|=
operator|(
name|lzma_options_delta
operator|)
block|{
comment|// It's hard to give a useful default for this.
operator|.
name|type
operator|=
name|LZMA_DELTA_TYPE_BYTE
block|,
operator|.
name|dist
operator|=
name|LZMA_DELTA_DIST_MIN
block|, 	}
expr_stmt|;
name|parse_options
argument_list|(
name|str
argument_list|,
name|opts
argument_list|,
operator|&
name|set_delta
argument_list|,
name|options
argument_list|)
expr_stmt|;
return|return
name|options
return|;
block|}
end_function

begin_comment
comment|/////////
end_comment

begin_comment
comment|// BCJ //
end_comment

begin_comment
comment|/////////
end_comment

begin_enum
enum|enum
block|{
name|OPT_START_OFFSET
block|, }
enum|;
end_enum

begin_decl_stmt
specifier|static
name|void
name|set_bcj
argument_list|(
name|void
operator|*
name|options
argument_list|,
name|unsigned
name|key
argument_list|,
name|uint64_t
name|value
argument_list|,
specifier|const
name|char
operator|*
name|valuestr
name|lzma_attribute
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|)
block|{
name|lzma_options_bcj
modifier|*
name|opt
init|=
name|options
decl_stmt|;
switch|switch
condition|(
name|key
condition|)
block|{
case|case
name|OPT_START_OFFSET
case|:
name|opt
operator|->
name|start_offset
operator|=
name|value
expr_stmt|;
break|break;
block|}
block|}
end_decl_stmt

begin_function
specifier|extern
name|lzma_options_bcj
modifier|*
name|options_bcj
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|static
specifier|const
name|option_map
name|opts
index|[]
init|=
block|{
block|{
literal|"start"
block|,
name|NULL
block|,
literal|0
block|,
name|UINT32_MAX
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
name|lzma_options_bcj
modifier|*
name|options
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lzma_options_bcj
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|options
operator|=
operator|(
name|lzma_options_bcj
operator|)
block|{
operator|.
name|start_offset
operator|=
literal|0
block|, 	}
expr_stmt|;
name|parse_options
argument_list|(
name|str
argument_list|,
name|opts
argument_list|,
operator|&
name|set_bcj
argument_list|,
name|options
argument_list|)
expr_stmt|;
return|return
name|options
return|;
block|}
end_function

begin_comment
comment|//////////
end_comment

begin_comment
comment|// LZMA //
end_comment

begin_comment
comment|//////////
end_comment

begin_enum
enum|enum
block|{
name|OPT_PRESET
block|,
name|OPT_DICT
block|,
name|OPT_LC
block|,
name|OPT_LP
block|,
name|OPT_PB
block|,
name|OPT_MODE
block|,
name|OPT_NICE
block|,
name|OPT_MF
block|,
name|OPT_DEPTH
block|, }
enum|;
end_enum

begin_decl_stmt
specifier|static
name|void
name|lzma_attribute
argument_list|(
operator|(
name|__noreturn__
operator|)
argument_list|)
name|error_lzma_preset
argument_list|(
specifier|const
name|char
operator|*
name|valuestr
argument_list|)
block|{
name|message_fatal
argument_list|(
name|_
argument_list|(
literal|"Unsupported LZMA1/LZMA2 preset: %s"
argument_list|)
argument_list|,
name|valuestr
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|set_lzma
parameter_list|(
name|void
modifier|*
name|options
parameter_list|,
name|unsigned
name|key
parameter_list|,
name|uint64_t
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|valuestr
parameter_list|)
block|{
name|lzma_options_lzma
modifier|*
name|opt
init|=
name|options
decl_stmt|;
switch|switch
condition|(
name|key
condition|)
block|{
case|case
name|OPT_PRESET
case|:
block|{
if|if
condition|(
name|valuestr
index|[
literal|0
index|]
operator|<
literal|'0'
operator|||
name|valuestr
index|[
literal|0
index|]
operator|>
literal|'9'
condition|)
name|error_lzma_preset
argument_list|(
name|valuestr
argument_list|)
expr_stmt|;
name|uint32_t
name|preset
init|=
name|valuestr
index|[
literal|0
index|]
operator|-
literal|'0'
decl_stmt|;
comment|// Currently only "e" is supported as a modifier,
comment|// so keep this simple for now.
if|if
condition|(
name|valuestr
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|valuestr
index|[
literal|1
index|]
operator|==
literal|'e'
condition|)
name|preset
operator||=
name|LZMA_PRESET_EXTREME
expr_stmt|;
else|else
name|error_lzma_preset
argument_list|(
name|valuestr
argument_list|)
expr_stmt|;
if|if
condition|(
name|valuestr
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
name|error_lzma_preset
argument_list|(
name|valuestr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lzma_lzma_preset
argument_list|(
name|options
argument_list|,
name|preset
argument_list|)
condition|)
name|error_lzma_preset
argument_list|(
name|valuestr
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OPT_DICT
case|:
name|opt
operator|->
name|dict_size
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_LC
case|:
name|opt
operator|->
name|lc
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_LP
case|:
name|opt
operator|->
name|lp
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_PB
case|:
name|opt
operator|->
name|pb
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_MODE
case|:
name|opt
operator|->
name|mode
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_NICE
case|:
name|opt
operator|->
name|nice_len
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_MF
case|:
name|opt
operator|->
name|mf
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|OPT_DEPTH
case|:
name|opt
operator|->
name|depth
operator|=
name|value
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|extern
name|lzma_options_lzma
modifier|*
name|options_lzma
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|static
specifier|const
name|name_id_map
name|modes
index|[]
init|=
block|{
block|{
literal|"fast"
block|,
name|LZMA_MODE_FAST
block|}
block|,
block|{
literal|"normal"
block|,
name|LZMA_MODE_NORMAL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|name_id_map
name|mfs
index|[]
init|=
block|{
block|{
literal|"hc3"
block|,
name|LZMA_MF_HC3
block|}
block|,
block|{
literal|"hc4"
block|,
name|LZMA_MF_HC4
block|}
block|,
block|{
literal|"bt2"
block|,
name|LZMA_MF_BT2
block|}
block|,
block|{
literal|"bt3"
block|,
name|LZMA_MF_BT3
block|}
block|,
block|{
literal|"bt4"
block|,
name|LZMA_MF_BT4
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
specifier|static
specifier|const
name|option_map
name|opts
index|[]
init|=
block|{
block|{
literal|"preset"
block|,
name|NULL
block|,
name|UINT64_MAX
block|,
literal|0
block|}
block|,
block|{
literal|"dict"
block|,
name|NULL
block|,
name|LZMA_DICT_SIZE_MIN
block|,
operator|(
name|UINT32_C
argument_list|(
literal|1
argument_list|)
operator|<<
literal|30
operator|)
operator|+
operator|(
name|UINT32_C
argument_list|(
literal|1
argument_list|)
operator|<<
literal|29
operator|)
block|}
block|,
block|{
literal|"lc"
block|,
name|NULL
block|,
name|LZMA_LCLP_MIN
block|,
name|LZMA_LCLP_MAX
block|}
block|,
block|{
literal|"lp"
block|,
name|NULL
block|,
name|LZMA_LCLP_MIN
block|,
name|LZMA_LCLP_MAX
block|}
block|,
block|{
literal|"pb"
block|,
name|NULL
block|,
name|LZMA_PB_MIN
block|,
name|LZMA_PB_MAX
block|}
block|,
block|{
literal|"mode"
block|,
name|modes
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"nice"
block|,
name|NULL
block|,
literal|2
block|,
literal|273
block|}
block|,
block|{
literal|"mf"
block|,
name|mfs
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"depth"
block|,
name|NULL
block|,
literal|0
block|,
name|UINT32_MAX
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
name|lzma_options_lzma
modifier|*
name|options
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lzma_options_lzma
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|lzma_lzma_preset
argument_list|(
name|options
argument_list|,
name|LZMA_PRESET_DEFAULT
argument_list|)
condition|)
name|message_bug
argument_list|()
expr_stmt|;
name|parse_options
argument_list|(
name|str
argument_list|,
name|opts
argument_list|,
operator|&
name|set_lzma
argument_list|,
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|->
name|lc
operator|+
name|options
operator|->
name|lp
operator|>
name|LZMA_LCLP_MAX
condition|)
name|message_fatal
argument_list|(
name|_
argument_list|(
literal|"The sum of lc and lp must not exceed 4"
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|uint32_t
name|nice_len_min
init|=
name|options
operator|->
name|mf
operator|&
literal|0x0F
decl_stmt|;
if|if
condition|(
name|options
operator|->
name|nice_len
operator|<
name|nice_len_min
condition|)
name|message_fatal
argument_list|(
name|_
argument_list|(
literal|"The selected match finder requires at "
literal|"least nice=%"
name|PRIu32
argument_list|)
argument_list|,
name|nice_len_min
argument_list|)
expr_stmt|;
return|return
name|options
return|;
block|}
end_function

end_unit

