begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       coder.c
end_comment

begin_comment
comment|/// \brief      Compresses or uncompresses a file
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Author:     Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"private.h"
end_include

begin_comment
comment|/// Return value type for coder_init().
end_comment

begin_enum
enum|enum
name|coder_init_ret
block|{
name|CODER_INIT_NORMAL
block|,
name|CODER_INIT_PASSTHRU
block|,
name|CODER_INIT_ERROR
block|, }
enum|;
end_enum

begin_decl_stmt
name|enum
name|operation_mode
name|opt_mode
init|=
name|MODE_COMPRESS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|format_type
name|opt_format
init|=
name|FORMAT_AUTO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_auto_adjust
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Stream used to communicate with liblzma
end_comment

begin_decl_stmt
specifier|static
name|lzma_stream
name|strm
init|=
name|LZMA_STREAM_INIT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Filters needed for all encoding all formats, and also decoding in raw data
end_comment

begin_decl_stmt
specifier|static
name|lzma_filter
name|filters
index|[
name|LZMA_FILTERS_MAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Input and output buffers
end_comment

begin_decl_stmt
specifier|static
name|io_buf
name|in_buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|io_buf
name|out_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Number of filters. Zero indicates that we are using a preset.
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|filters_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Number of the preset (0-9)
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|preset_number
init|=
name|LZMA_PRESET_DEFAULT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Integrity check type
end_comment

begin_decl_stmt
specifier|static
name|lzma_check
name|check
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// This becomes false if the --check=CHECK option is used.
end_comment

begin_decl_stmt
specifier|static
name|bool
name|check_default
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_function
specifier|extern
name|void
name|coder_set_check
parameter_list|(
name|lzma_check
name|new_check
parameter_list|)
block|{
name|check
operator|=
name|new_check
expr_stmt|;
name|check_default
operator|=
name|false
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|forget_filter_chain
parameter_list|(
name|void
parameter_list|)
block|{
comment|// Setting a preset makes us forget a possibly defined custom
comment|// filter chain.
while|while
condition|(
name|filters_count
operator|>
literal|0
condition|)
block|{
operator|--
name|filters_count
expr_stmt|;
name|free
argument_list|(
name|filters
index|[
name|filters_count
index|]
operator|.
name|options
argument_list|)
expr_stmt|;
name|filters
index|[
name|filters_count
index|]
operator|.
name|options
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|extern
name|void
name|coder_set_preset
parameter_list|(
name|uint32_t
name|new_preset
parameter_list|)
block|{
name|preset_number
operator|&=
operator|~
name|LZMA_PRESET_LEVEL_MASK
expr_stmt|;
name|preset_number
operator||=
name|new_preset
expr_stmt|;
name|forget_filter_chain
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|extern
name|void
name|coder_set_extreme
parameter_list|(
name|void
parameter_list|)
block|{
name|preset_number
operator||=
name|LZMA_PRESET_EXTREME
expr_stmt|;
name|forget_filter_chain
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|extern
name|void
name|coder_add_filter
parameter_list|(
name|lzma_vli
name|id
parameter_list|,
name|void
modifier|*
name|options
parameter_list|)
block|{
if|if
condition|(
name|filters_count
operator|==
name|LZMA_FILTERS_MAX
condition|)
name|message_fatal
argument_list|(
name|_
argument_list|(
literal|"Maximum number of filters is four"
argument_list|)
argument_list|)
expr_stmt|;
name|filters
index|[
name|filters_count
index|]
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|filters
index|[
name|filters_count
index|]
operator|.
name|options
operator|=
name|options
expr_stmt|;
operator|++
name|filters_count
expr_stmt|;
comment|// Setting a custom filter chain makes us forget the preset options.
comment|// This makes a difference if one specifies e.g. "xz -9 --lzma2 -e"
comment|// where the custom filter chain resets the preset level back to
comment|// the default 6, making the example equivalent to "xz -6e".
name|preset_number
operator|=
name|LZMA_PRESET_DEFAULT
expr_stmt|;
return|return;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|lzma_attribute
argument_list|(
operator|(
name|__noreturn__
operator|)
argument_list|)
name|memlimit_too_small
argument_list|(
name|uint64_t
name|memory_usage
argument_list|)
block|{
name|message
argument_list|(
name|V_ERROR
argument_list|,
name|_
argument_list|(
literal|"Memory usage limit is too low for the given "
literal|"filter setup."
argument_list|)
argument_list|)
expr_stmt|;
name|message_mem_needed
argument_list|(
name|V_ERROR
argument_list|,
name|memory_usage
argument_list|)
expr_stmt|;
name|tuklib_exit
argument_list|(
name|E_ERROR
argument_list|,
name|E_ERROR
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|extern
name|void
name|coder_set_compression_settings
parameter_list|(
name|void
parameter_list|)
block|{
comment|// Options for LZMA1 or LZMA2 in case we are using a preset.
specifier|static
name|lzma_options_lzma
name|opt_lzma
decl_stmt|;
if|if
condition|(
name|filters_count
operator|==
literal|0
condition|)
block|{
comment|// We are using a preset. This is not a good idea in raw mode
comment|// except when playing around with things. Different versions
comment|// of this software may use different options in presets, and
comment|// thus make uncompressing the raw data difficult.
if|if
condition|(
name|opt_format
operator|==
name|FORMAT_RAW
condition|)
block|{
comment|// The message is shown only if warnings are allowed
comment|// but the exit status isn't changed.
name|message
argument_list|(
name|V_WARNING
argument_list|,
name|_
argument_list|(
literal|"Using a preset in raw mode "
literal|"is discouraged."
argument_list|)
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|V_WARNING
argument_list|,
name|_
argument_list|(
literal|"The exact options of the "
literal|"presets may vary between software "
literal|"versions."
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Get the preset for LZMA1 or LZMA2.
if|if
condition|(
name|lzma_lzma_preset
argument_list|(
operator|&
name|opt_lzma
argument_list|,
name|preset_number
argument_list|)
condition|)
name|message_bug
argument_list|()
expr_stmt|;
comment|// Use LZMA2 except with --format=lzma we use LZMA1.
name|filters
index|[
literal|0
index|]
operator|.
name|id
operator|=
name|opt_format
operator|==
name|FORMAT_LZMA
condition|?
name|LZMA_FILTER_LZMA1
else|:
name|LZMA_FILTER_LZMA2
expr_stmt|;
name|filters
index|[
literal|0
index|]
operator|.
name|options
operator|=
operator|&
name|opt_lzma
expr_stmt|;
name|filters_count
operator|=
literal|1
expr_stmt|;
block|}
comment|// Terminate the filter options array.
name|filters
index|[
name|filters_count
index|]
operator|.
name|id
operator|=
name|LZMA_VLI_UNKNOWN
expr_stmt|;
comment|// If we are using the .lzma format, allow exactly one filter
comment|// which has to be LZMA1.
if|if
condition|(
name|opt_format
operator|==
name|FORMAT_LZMA
operator|&&
operator|(
name|filters_count
operator|!=
literal|1
operator|||
name|filters
index|[
literal|0
index|]
operator|.
name|id
operator|!=
name|LZMA_FILTER_LZMA1
operator|)
condition|)
name|message_fatal
argument_list|(
name|_
argument_list|(
literal|"The .lzma format supports only "
literal|"the LZMA1 filter"
argument_list|)
argument_list|)
expr_stmt|;
comment|// If we are using the .xz format, make sure that there is no LZMA1
comment|// filter to prevent LZMA_PROG_ERROR.
if|if
condition|(
name|opt_format
operator|==
name|FORMAT_XZ
condition|)
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|filters_count
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|filters
index|[
name|i
index|]
operator|.
name|id
operator|==
name|LZMA_FILTER_LZMA1
condition|)
name|message_fatal
argument_list|(
name|_
argument_list|(
literal|"LZMA1 cannot be used "
literal|"with the .xz format"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Print the selected filter chain.
name|message_filters_show
argument_list|(
name|V_DEBUG
argument_list|,
name|filters
argument_list|)
expr_stmt|;
comment|// If using --format=raw, we can be decoding. The memusage function
comment|// also validates the filter chain and the options used for the
comment|// filters.
specifier|const
name|uint64_t
name|memory_limit
init|=
name|hardware_memlimit_get
argument_list|(
name|opt_mode
argument_list|)
decl_stmt|;
name|uint64_t
name|memory_usage
decl_stmt|;
if|if
condition|(
name|opt_mode
operator|==
name|MODE_COMPRESS
condition|)
name|memory_usage
operator|=
name|lzma_raw_encoder_memusage
argument_list|(
name|filters
argument_list|)
expr_stmt|;
else|else
name|memory_usage
operator|=
name|lzma_raw_decoder_memusage
argument_list|(
name|filters
argument_list|)
expr_stmt|;
if|if
condition|(
name|memory_usage
operator|==
name|UINT64_MAX
condition|)
name|message_fatal
argument_list|(
name|_
argument_list|(
literal|"Unsupported filter chain or filter options"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Print memory usage info before possible dictionary
comment|// size auto-adjusting.
name|message_mem_needed
argument_list|(
name|V_DEBUG
argument_list|,
name|memory_usage
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_mode
operator|==
name|MODE_COMPRESS
condition|)
block|{
specifier|const
name|uint64_t
name|decmem
init|=
name|lzma_raw_decoder_memusage
argument_list|(
name|filters
argument_list|)
decl_stmt|;
if|if
condition|(
name|decmem
operator|!=
name|UINT64_MAX
condition|)
name|message
argument_list|(
name|V_DEBUG
argument_list|,
name|_
argument_list|(
literal|"Decompression will need "
literal|"%s MiB of memory."
argument_list|)
argument_list|,
name|uint64_to_str
argument_list|(
name|round_up_to_mib
argument_list|(
name|decmem
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|memory_usage
operator|>
name|memory_limit
condition|)
block|{
comment|// If --no-adjust was used or we didn't find LZMA1 or
comment|// LZMA2 as the last filter, give an error immediately.
comment|// --format=raw implies --no-adjust.
if|if
condition|(
operator|!
name|opt_auto_adjust
operator|||
name|opt_format
operator|==
name|FORMAT_RAW
condition|)
name|memlimit_too_small
argument_list|(
name|memory_usage
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|opt_mode
operator|==
name|MODE_COMPRESS
argument_list|)
expr_stmt|;
comment|// Look for the last filter if it is LZMA2 or LZMA1, so
comment|// we can make it use less RAM. With other filters we don't
comment|// know what to do.
name|size_t
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|filters
index|[
name|i
index|]
operator|.
name|id
operator|!=
name|LZMA_FILTER_LZMA2
operator|&&
name|filters
index|[
name|i
index|]
operator|.
name|id
operator|!=
name|LZMA_FILTER_LZMA1
condition|)
block|{
if|if
condition|(
name|filters
index|[
name|i
index|]
operator|.
name|id
operator|==
name|LZMA_VLI_UNKNOWN
condition|)
name|memlimit_too_small
argument_list|(
name|memory_usage
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
comment|// Decrease the dictionary size until we meet the memory
comment|// usage limit. First round down to full mebibytes.
name|lzma_options_lzma
modifier|*
name|opt
init|=
name|filters
index|[
name|i
index|]
operator|.
name|options
decl_stmt|;
specifier|const
name|uint32_t
name|orig_dict_size
init|=
name|opt
operator|->
name|dict_size
decl_stmt|;
name|opt
operator|->
name|dict_size
operator|&=
operator|~
operator|(
operator|(
name|UINT32_C
argument_list|(
literal|1
argument_list|)
operator|<<
literal|20
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|true
condition|)
block|{
comment|// If it is below 1 MiB, auto-adjusting failed. We
comment|// could be more sophisticated and scale it down even
comment|// more, but let's see if many complain about this
comment|// version.
comment|//
comment|// FIXME: Displays the scaled memory usage instead
comment|// of the original.
if|if
condition|(
name|opt
operator|->
name|dict_size
operator|<
operator|(
name|UINT32_C
argument_list|(
literal|1
argument_list|)
operator|<<
literal|20
operator|)
condition|)
name|memlimit_too_small
argument_list|(
name|memory_usage
argument_list|)
expr_stmt|;
name|memory_usage
operator|=
name|lzma_raw_encoder_memusage
argument_list|(
name|filters
argument_list|)
expr_stmt|;
if|if
condition|(
name|memory_usage
operator|==
name|UINT64_MAX
condition|)
name|message_bug
argument_list|()
expr_stmt|;
comment|// Accept it if it is low enough.
if|if
condition|(
name|memory_usage
operator|<=
name|memory_limit
condition|)
break|break;
comment|// Otherwise 1 MiB down and try again. I hope this
comment|// isn't too slow method for cases where the original
comment|// dict_size is very big.
name|opt
operator|->
name|dict_size
operator|-=
name|UINT32_C
argument_list|(
literal|1
argument_list|)
operator|<<
literal|20
expr_stmt|;
block|}
comment|// Tell the user that we decreased the dictionary size.
name|message
argument_list|(
name|V_WARNING
argument_list|,
name|_
argument_list|(
literal|"Adjusted LZMA%c dictionary size "
literal|"from %s MiB to %s MiB to not exceed "
literal|"the memory usage limit of %s MiB"
argument_list|)
argument_list|,
name|filters
index|[
name|i
index|]
operator|.
name|id
operator|==
name|LZMA_FILTER_LZMA2
condition|?
literal|'2'
else|:
literal|'1'
argument_list|,
name|uint64_to_str
argument_list|(
name|orig_dict_size
operator|>>
literal|20
argument_list|,
literal|0
argument_list|)
argument_list|,
name|uint64_to_str
argument_list|(
name|opt
operator|->
name|dict_size
operator|>>
literal|20
argument_list|,
literal|1
argument_list|)
argument_list|,
name|uint64_to_str
argument_list|(
name|round_up_to_mib
argument_list|(
name|memory_limit
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	// Limit the number of worker threads so that memory usage 	// limit isn't exceeded. 	assert(memory_usage> 0); 	size_t thread_limit = memory_limit / memory_usage; 	if (thread_limit == 0) 		thread_limit = 1;  	if (opt_threads> thread_limit) 		opt_threads = thread_limit; */
if|if
condition|(
name|check_default
condition|)
block|{
comment|// The default check type is CRC64, but fallback to CRC32
comment|// if CRC64 isn't supported by the copy of liblzma we are
comment|// using. CRC32 is always supported.
name|check
operator|=
name|LZMA_CHECK_CRC64
expr_stmt|;
if|if
condition|(
operator|!
name|lzma_check_is_supported
argument_list|(
name|check
argument_list|)
condition|)
name|check
operator|=
name|LZMA_CHECK_CRC32
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/// Return true if the data in in_buf seems to be in the .xz format.
end_comment

begin_function
specifier|static
name|bool
name|is_format_xz
parameter_list|(
name|void
parameter_list|)
block|{
comment|// Specify the magic as hex to be compatible with EBCDIC systems.
specifier|static
specifier|const
name|uint8_t
name|magic
index|[
literal|6
index|]
init|=
block|{
literal|0xFD
block|,
literal|0x37
block|,
literal|0x7A
block|,
literal|0x58
block|,
literal|0x5A
block|,
literal|0x00
block|}
decl_stmt|;
return|return
name|strm
operator|.
name|avail_in
operator|>=
sizeof|sizeof
argument_list|(
name|magic
argument_list|)
operator|&&
name|memcmp
argument_list|(
name|in_buf
operator|.
name|u8
argument_list|,
name|magic
argument_list|,
sizeof|sizeof
argument_list|(
name|magic
argument_list|)
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/// Return true if the data in in_buf seems to be in the .lzma format.
end_comment

begin_function
specifier|static
name|bool
name|is_format_lzma
parameter_list|(
name|void
parameter_list|)
block|{
comment|// The .lzma header is 13 bytes.
if|if
condition|(
name|strm
operator|.
name|avail_in
operator|<
literal|13
condition|)
return|return
name|false
return|;
comment|// Decode the LZMA1 properties.
name|lzma_filter
name|filter
init|=
block|{
operator|.
name|id
operator|=
name|LZMA_FILTER_LZMA1
block|}
decl_stmt|;
if|if
condition|(
name|lzma_properties_decode
argument_list|(
operator|&
name|filter
argument_list|,
name|NULL
argument_list|,
name|in_buf
operator|.
name|u8
argument_list|,
literal|5
argument_list|)
operator|!=
name|LZMA_OK
condition|)
return|return
name|false
return|;
comment|// A hack to ditch tons of false positives: We allow only dictionary
comment|// sizes that are 2^n or 2^n + 2^(n-1) or UINT32_MAX. LZMA_Alone
comment|// created only files with 2^n, but accepts any dictionary size.
comment|// If someone complains, this will be reconsidered.
name|lzma_options_lzma
modifier|*
name|opt
init|=
name|filter
operator|.
name|options
decl_stmt|;
specifier|const
name|uint32_t
name|dict_size
init|=
name|opt
operator|->
name|dict_size
decl_stmt|;
name|free
argument_list|(
name|opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|dict_size
operator|!=
name|UINT32_MAX
condition|)
block|{
name|uint32_t
name|d
init|=
name|dict_size
operator|-
literal|1
decl_stmt|;
name|d
operator||=
name|d
operator|>>
literal|2
expr_stmt|;
name|d
operator||=
name|d
operator|>>
literal|3
expr_stmt|;
name|d
operator||=
name|d
operator|>>
literal|4
expr_stmt|;
name|d
operator||=
name|d
operator|>>
literal|8
expr_stmt|;
name|d
operator||=
name|d
operator|>>
literal|16
expr_stmt|;
operator|++
name|d
expr_stmt|;
if|if
condition|(
name|d
operator|!=
name|dict_size
operator|||
name|dict_size
operator|==
literal|0
condition|)
return|return
name|false
return|;
block|}
comment|// Another hack to ditch false positives: Assume that if the
comment|// uncompressed size is known, it must be less than 256 GiB.
comment|// Again, if someone complains, this will be reconsidered.
name|uint64_t
name|uncompressed_size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
name|uncompressed_size
operator||=
call|(
name|uint64_t
call|)
argument_list|(
name|in_buf
operator|.
name|u8
index|[
literal|5
operator|+
name|i
index|]
argument_list|)
operator|<<
operator|(
name|i
operator|*
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|uncompressed_size
operator|!=
name|UINT64_MAX
operator|&&
name|uncompressed_size
operator|>
operator|(
name|UINT64_C
argument_list|(
literal|1
argument_list|)
operator|<<
literal|38
operator|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/// Detect the input file type (for now, this done only when decompressing),
end_comment

begin_comment
comment|/// and initialize an appropriate coder. Return value indicates if a normal
end_comment

begin_comment
comment|/// liblzma-based coder was initialized (CODER_INIT_NORMAL), if passthru
end_comment

begin_comment
comment|/// mode should be used (CODER_INIT_PASSTHRU), or if an error occurred
end_comment

begin_comment
comment|/// (CODER_INIT_ERROR).
end_comment

begin_function
specifier|static
name|enum
name|coder_init_ret
name|coder_init
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|)
block|{
name|lzma_ret
name|ret
init|=
name|LZMA_PROG_ERROR
decl_stmt|;
if|if
condition|(
name|opt_mode
operator|==
name|MODE_COMPRESS
condition|)
block|{
switch|switch
condition|(
name|opt_format
condition|)
block|{
case|case
name|FORMAT_AUTO
case|:
comment|// args.c ensures this.
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FORMAT_XZ
case|:
name|ret
operator|=
name|lzma_stream_encoder
argument_list|(
operator|&
name|strm
argument_list|,
name|filters
argument_list|,
name|check
argument_list|)
expr_stmt|;
break|break;
case|case
name|FORMAT_LZMA
case|:
name|ret
operator|=
name|lzma_alone_encoder
argument_list|(
operator|&
name|strm
argument_list|,
name|filters
index|[
literal|0
index|]
operator|.
name|options
argument_list|)
expr_stmt|;
break|break;
case|case
name|FORMAT_RAW
case|:
name|ret
operator|=
name|lzma_raw_encoder
argument_list|(
operator|&
name|strm
argument_list|,
name|filters
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
specifier|const
name|uint32_t
name|flags
init|=
name|LZMA_TELL_UNSUPPORTED_CHECK
operator||
name|LZMA_CONCATENATED
decl_stmt|;
comment|// We abuse FORMAT_AUTO to indicate unknown file format,
comment|// for which we may consider passthru mode.
name|enum
name|format_type
name|init_format
init|=
name|FORMAT_AUTO
decl_stmt|;
switch|switch
condition|(
name|opt_format
condition|)
block|{
case|case
name|FORMAT_AUTO
case|:
if|if
condition|(
name|is_format_xz
argument_list|()
condition|)
name|init_format
operator|=
name|FORMAT_XZ
expr_stmt|;
elseif|else
if|if
condition|(
name|is_format_lzma
argument_list|()
condition|)
name|init_format
operator|=
name|FORMAT_LZMA
expr_stmt|;
break|break;
case|case
name|FORMAT_XZ
case|:
if|if
condition|(
name|is_format_xz
argument_list|()
condition|)
name|init_format
operator|=
name|FORMAT_XZ
expr_stmt|;
break|break;
case|case
name|FORMAT_LZMA
case|:
if|if
condition|(
name|is_format_lzma
argument_list|()
condition|)
name|init_format
operator|=
name|FORMAT_LZMA
expr_stmt|;
break|break;
case|case
name|FORMAT_RAW
case|:
name|init_format
operator|=
name|FORMAT_RAW
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|init_format
condition|)
block|{
case|case
name|FORMAT_AUTO
case|:
comment|// Uknown file format. If --decompress --stdout
comment|// --force have been given, then we copy the input
comment|// as is to stdout. Checking for MODE_DECOMPRESS
comment|// is needed, because we don't want to do use
comment|// passthru mode with --test.
if|if
condition|(
name|opt_mode
operator|==
name|MODE_DECOMPRESS
operator|&&
name|opt_stdout
operator|&&
name|opt_force
condition|)
return|return
name|CODER_INIT_PASSTHRU
return|;
name|ret
operator|=
name|LZMA_FORMAT_ERROR
expr_stmt|;
break|break;
case|case
name|FORMAT_XZ
case|:
name|ret
operator|=
name|lzma_stream_decoder
argument_list|(
operator|&
name|strm
argument_list|,
name|hardware_memlimit_get
argument_list|(
name|MODE_DECOMPRESS
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|FORMAT_LZMA
case|:
name|ret
operator|=
name|lzma_alone_decoder
argument_list|(
operator|&
name|strm
argument_list|,
name|hardware_memlimit_get
argument_list|(
name|MODE_DECOMPRESS
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FORMAT_RAW
case|:
comment|// Memory usage has already been checked in
comment|// coder_set_compression_settings().
name|ret
operator|=
name|lzma_raw_decoder
argument_list|(
operator|&
name|strm
argument_list|,
name|filters
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// Try to decode the headers. This will catch too low
comment|// memory usage limit in case it happens in the first
comment|// Block of the first Stream, which is where it very
comment|// probably will happen if it is going to happen.
if|if
condition|(
name|ret
operator|==
name|LZMA_OK
operator|&&
name|init_format
operator|!=
name|FORMAT_RAW
condition|)
block|{
name|strm
operator|.
name|next_out
operator|=
name|NULL
expr_stmt|;
name|strm
operator|.
name|avail_out
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|lzma_code
argument_list|(
operator|&
name|strm
argument_list|,
name|LZMA_RUN
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|message_strm
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|LZMA_MEMLIMIT_ERROR
condition|)
name|message_mem_needed
argument_list|(
name|V_ERROR
argument_list|,
name|lzma_memusage
argument_list|(
operator|&
name|strm
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|CODER_INIT_ERROR
return|;
block|}
return|return
name|CODER_INIT_NORMAL
return|;
block|}
end_function

begin_comment
comment|/// Compress or decompress using liblzma.
end_comment

begin_function
specifier|static
name|bool
name|coder_normal
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|)
block|{
comment|// Encoder needs to know when we have given all the input to it.
comment|// The decoders need to know it too when we are using
comment|// LZMA_CONCATENATED. We need to check for src_eof here, because
comment|// the first input chunk has been already read, and that may
comment|// have been the only chunk we will read.
name|lzma_action
name|action
init|=
name|pair
operator|->
name|src_eof
condition|?
name|LZMA_FINISH
else|:
name|LZMA_RUN
decl_stmt|;
name|lzma_ret
name|ret
decl_stmt|;
comment|// Assume that something goes wrong.
name|bool
name|success
init|=
name|false
decl_stmt|;
name|strm
operator|.
name|next_out
operator|=
name|out_buf
operator|.
name|u8
expr_stmt|;
name|strm
operator|.
name|avail_out
operator|=
name|IO_BUFFER_SIZE
expr_stmt|;
while|while
condition|(
operator|!
name|user_abort
condition|)
block|{
comment|// Fill the input buffer if it is empty and we haven't reached
comment|// end of file yet.
if|if
condition|(
name|strm
operator|.
name|avail_in
operator|==
literal|0
operator|&&
operator|!
name|pair
operator|->
name|src_eof
condition|)
block|{
name|strm
operator|.
name|next_in
operator|=
name|in_buf
operator|.
name|u8
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
name|io_read
argument_list|(
name|pair
argument_list|,
operator|&
name|in_buf
argument_list|,
name|IO_BUFFER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strm
operator|.
name|avail_in
operator|==
name|SIZE_MAX
condition|)
break|break;
if|if
condition|(
name|pair
operator|->
name|src_eof
condition|)
name|action
operator|=
name|LZMA_FINISH
expr_stmt|;
block|}
comment|// Let liblzma do the actual work.
name|ret
operator|=
name|lzma_code
argument_list|(
operator|&
name|strm
argument_list|,
name|action
argument_list|)
expr_stmt|;
comment|// Write out if the output buffer became full.
if|if
condition|(
name|strm
operator|.
name|avail_out
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|opt_mode
operator|!=
name|MODE_TEST
operator|&&
name|io_write
argument_list|(
name|pair
argument_list|,
operator|&
name|out_buf
argument_list|,
name|IO_BUFFER_SIZE
operator|-
name|strm
operator|.
name|avail_out
argument_list|)
condition|)
break|break;
name|strm
operator|.
name|next_out
operator|=
name|out_buf
operator|.
name|u8
expr_stmt|;
name|strm
operator|.
name|avail_out
operator|=
name|IO_BUFFER_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
comment|// Determine if the return value indicates that we
comment|// won't continue coding.
specifier|const
name|bool
name|stop
init|=
name|ret
operator|!=
name|LZMA_NO_CHECK
operator|&&
name|ret
operator|!=
name|LZMA_UNSUPPORTED_CHECK
decl_stmt|;
if|if
condition|(
name|stop
condition|)
block|{
comment|// Write the remaining bytes even if something
comment|// went wrong, because that way the user gets
comment|// as much data as possible, which can be good
comment|// when trying to get at least some useful
comment|// data out of damaged files.
if|if
condition|(
name|opt_mode
operator|!=
name|MODE_TEST
operator|&&
name|io_write
argument_list|(
name|pair
argument_list|,
operator|&
name|out_buf
argument_list|,
name|IO_BUFFER_SIZE
operator|-
name|strm
operator|.
name|avail_out
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|ret
operator|==
name|LZMA_STREAM_END
condition|)
block|{
comment|// Check that there is no trailing garbage.
comment|// This is needed for LZMA_Alone and raw
comment|// streams.
if|if
condition|(
name|strm
operator|.
name|avail_in
operator|==
literal|0
operator|&&
operator|!
name|pair
operator|->
name|src_eof
condition|)
block|{
comment|// Try reading one more byte.
comment|// Hopefully we don't get any more
comment|// input, and thus pair->src_eof
comment|// becomes true.
name|strm
operator|.
name|avail_in
operator|=
name|io_read
argument_list|(
name|pair
argument_list|,
operator|&
name|in_buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|strm
operator|.
name|avail_in
operator|==
name|SIZE_MAX
condition|)
break|break;
name|assert
argument_list|(
name|strm
operator|.
name|avail_in
operator|==
literal|0
operator|||
name|strm
operator|.
name|avail_in
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strm
operator|.
name|avail_in
operator|==
literal|0
condition|)
block|{
name|assert
argument_list|(
name|pair
operator|->
name|src_eof
argument_list|)
expr_stmt|;
name|success
operator|=
name|true
expr_stmt|;
break|break;
block|}
comment|// We hadn't reached the end of the file.
name|ret
operator|=
name|LZMA_DATA_ERROR
expr_stmt|;
name|assert
argument_list|(
name|stop
argument_list|)
expr_stmt|;
block|}
comment|// If we get here and stop is true, something went
comment|// wrong and we print an error. Otherwise it's just
comment|// a warning and coding can continue.
if|if
condition|(
name|stop
condition|)
block|{
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|message_strm
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|message_warning
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|message_strm
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
comment|// When compressing, all possible errors set
comment|// stop to true.
name|assert
argument_list|(
name|opt_mode
operator|!=
name|MODE_COMPRESS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|LZMA_MEMLIMIT_ERROR
condition|)
block|{
comment|// Display how much memory it would have
comment|// actually needed.
name|message_mem_needed
argument_list|(
name|V_ERROR
argument_list|,
name|lzma_memusage
argument_list|(
operator|&
name|strm
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stop
condition|)
break|break;
block|}
comment|// Show progress information under certain conditions.
name|message_progress_update
argument_list|()
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/// Copy from input file to output file without processing the data in any
end_comment

begin_comment
comment|/// way. This is used only when trying to decompress unrecognized files
end_comment

begin_comment
comment|/// with --decompress --stdout --force, so the output is always stdout.
end_comment

begin_function
specifier|static
name|bool
name|coder_passthru
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|)
block|{
while|while
condition|(
name|strm
operator|.
name|avail_in
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|user_abort
condition|)
return|return
name|false
return|;
if|if
condition|(
name|io_write
argument_list|(
name|pair
argument_list|,
operator|&
name|in_buf
argument_list|,
name|strm
operator|.
name|avail_in
argument_list|)
condition|)
return|return
name|false
return|;
name|strm
operator|.
name|total_in
operator|+=
name|strm
operator|.
name|avail_in
expr_stmt|;
name|strm
operator|.
name|total_out
operator|=
name|strm
operator|.
name|total_in
expr_stmt|;
name|message_progress_update
argument_list|()
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
name|io_read
argument_list|(
name|pair
argument_list|,
operator|&
name|in_buf
argument_list|,
name|IO_BUFFER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strm
operator|.
name|avail_in
operator|==
name|SIZE_MAX
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|extern
name|void
name|coder_run
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
comment|// Set and possibly print the filename for the progress message.
name|message_filename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|// Try to open the input file.
name|file_pair
modifier|*
name|pair
init|=
name|io_open_src
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
name|NULL
condition|)
return|return;
comment|// Assume that something goes wrong.
name|bool
name|success
init|=
name|false
decl_stmt|;
comment|// Read the first chunk of input data. This is needed to detect
comment|// the input file type (for now, only for decompression).
name|strm
operator|.
name|next_in
operator|=
name|in_buf
operator|.
name|u8
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
name|io_read
argument_list|(
name|pair
argument_list|,
operator|&
name|in_buf
argument_list|,
name|IO_BUFFER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strm
operator|.
name|avail_in
operator|!=
name|SIZE_MAX
condition|)
block|{
comment|// Initialize the coder. This will detect the file format
comment|// and, in decompression or testing mode, check the memory
comment|// usage of the first Block too. This way we don't try to
comment|// open the destination file if we see that coding wouldn't
comment|// work at all anyway. This also avoids deleting the old
comment|// "target" file if --force was used.
specifier|const
name|enum
name|coder_init_ret
name|init_ret
init|=
name|coder_init
argument_list|(
name|pair
argument_list|)
decl_stmt|;
if|if
condition|(
name|init_ret
operator|!=
name|CODER_INIT_ERROR
operator|&&
operator|!
name|user_abort
condition|)
block|{
comment|// Don't open the destination file when --test
comment|// is used.
if|if
condition|(
name|opt_mode
operator|==
name|MODE_TEST
operator|||
operator|!
name|io_open_dest
argument_list|(
name|pair
argument_list|)
condition|)
block|{
comment|// Initialize the progress indicator.
specifier|const
name|uint64_t
name|in_size
init|=
name|pair
operator|->
name|src_st
operator|.
name|st_size
operator|<=
literal|0
condition|?
literal|0
else|:
name|pair
operator|->
name|src_st
operator|.
name|st_size
decl_stmt|;
name|message_progress_start
argument_list|(
operator|&
name|strm
argument_list|,
name|in_size
argument_list|)
expr_stmt|;
comment|// Do the actual coding or passthru.
if|if
condition|(
name|init_ret
operator|==
name|CODER_INIT_NORMAL
condition|)
name|success
operator|=
name|coder_normal
argument_list|(
name|pair
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
name|coder_passthru
argument_list|(
name|pair
argument_list|)
expr_stmt|;
name|message_progress_end
argument_list|(
name|success
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Close the file pair. It needs to know if coding was successful to
comment|// know if the source or target file should be unlinked.
name|io_close
argument_list|(
name|pair
argument_list|,
name|success
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

