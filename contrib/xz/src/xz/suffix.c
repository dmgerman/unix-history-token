begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       suffix.c
end_comment

begin_comment
comment|/// \brief      Checks filename suffix and creates the destination filename
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Author:     Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"private.h"
end_include

begin_comment
comment|// For case-insensitive filename suffix on case-insensitive systems
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TUKLIB_DOSLIKE
argument_list|)
operator|||
name|defined
argument_list|(
name|__VMS
argument_list|)
end_if

begin_define
define|#
directive|define
name|strcmp
value|strcasecmp
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|custom_suffix
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// \brief      Test if the char is a directory separator
end_comment

begin_function
specifier|static
name|bool
name|is_dir_sep
parameter_list|(
name|char
name|c
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|TUKLIB_DOSLIKE
return|return
name|c
operator|==
literal|'/'
operator|||
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
literal|':'
return|;
else|#
directive|else
return|return
name|c
operator|==
literal|'/'
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/// \brief      Test if the string contains a directory separator
end_comment

begin_function
specifier|static
name|bool
name|has_dir_sep
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|TUKLIB_DOSLIKE
return|return
name|strpbrk
argument_list|(
name|str
argument_list|,
literal|"/\\:"
argument_list|)
operator|!=
name|NULL
return|;
else|#
directive|else
return|return
name|strchr
argument_list|(
name|str
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/// \brief      Checks if src_name has given compressed_suffix
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \param      suffix      Filename suffix to look for
end_comment

begin_comment
comment|/// \param      src_name    Input filename
end_comment

begin_comment
comment|/// \param      src_len     strlen(src_name)
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \return     If src_name has the suffix, src_len - strlen(suffix) is
end_comment

begin_comment
comment|///             returned. It's always a positive integer. Otherwise zero
end_comment

begin_comment
comment|///             is returned.
end_comment

begin_function
specifier|static
name|size_t
name|test_suffix
parameter_list|(
specifier|const
name|char
modifier|*
name|suffix
parameter_list|,
specifier|const
name|char
modifier|*
name|src_name
parameter_list|,
name|size_t
name|src_len
parameter_list|)
block|{
specifier|const
name|size_t
name|suffix_len
init|=
name|strlen
argument_list|(
name|suffix
argument_list|)
decl_stmt|;
comment|// The filename must have at least one character in addition to
comment|// the suffix. src_name may contain path to the filename, so we
comment|// need to check for directory separator too.
if|if
condition|(
name|src_len
operator|<=
name|suffix_len
operator|||
name|is_dir_sep
argument_list|(
name|src_name
index|[
name|src_len
operator|-
name|suffix_len
operator|-
literal|1
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|suffix
argument_list|,
name|src_name
operator|+
name|src_len
operator|-
name|suffix_len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|src_len
operator|-
name|suffix_len
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/// \brief      Removes the filename suffix of the compressed file
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \return     Name of the uncompressed file, or NULL if file has unknown
end_comment

begin_comment
comment|///             suffix.
end_comment

begin_function
specifier|static
name|char
modifier|*
name|uncompressed_name
parameter_list|(
specifier|const
name|char
modifier|*
name|src_name
parameter_list|,
specifier|const
name|size_t
name|src_len
parameter_list|)
block|{
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|compressed
decl_stmt|;
specifier|const
name|char
modifier|*
name|uncompressed
decl_stmt|;
block|}
name|suffixes
index|[]
init|=
block|{
block|{
literal|".xz"
block|,
literal|""
block|}
block|,
block|{
literal|".txz"
block|,
literal|".tar"
block|}
block|,
comment|// .txz abbreviation for .txt.gz is rare.
block|{
literal|".lzma"
block|,
literal|""
block|}
block|,
block|{
literal|".tlz"
block|,
literal|".tar"
block|}
block|,
comment|// { ".gz",    "" },
comment|// { ".tgz",   ".tar" },
block|}
struct|;
specifier|const
name|char
modifier|*
name|new_suffix
init|=
literal|""
decl_stmt|;
name|size_t
name|new_len
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|opt_format
operator|==
name|FORMAT_RAW
condition|)
block|{
comment|// Don't check for known suffixes when --format=raw was used.
if|if
condition|(
name|custom_suffix
operator|==
name|NULL
condition|)
block|{
name|message_error
argument_list|(
name|_
argument_list|(
literal|"%s: With --format=raw, "
literal|"--suffix=.SUF is required unless "
literal|"writing to stdout"
argument_list|)
argument_list|,
name|src_name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|suffixes
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|new_len
operator|=
name|test_suffix
argument_list|(
name|suffixes
index|[
name|i
index|]
operator|.
name|compressed
argument_list|,
name|src_name
argument_list|,
name|src_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_len
operator|!=
literal|0
condition|)
block|{
name|new_suffix
operator|=
name|suffixes
index|[
name|i
index|]
operator|.
name|uncompressed
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|new_len
operator|==
literal|0
operator|&&
name|custom_suffix
operator|!=
name|NULL
condition|)
name|new_len
operator|=
name|test_suffix
argument_list|(
name|custom_suffix
argument_list|,
name|src_name
argument_list|,
name|src_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_len
operator|==
literal|0
condition|)
block|{
name|message_warning
argument_list|(
name|_
argument_list|(
literal|"%s: Filename has an unknown suffix, "
literal|"skipping"
argument_list|)
argument_list|,
name|src_name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
specifier|const
name|size_t
name|new_suffix_len
init|=
name|strlen
argument_list|(
name|new_suffix
argument_list|)
decl_stmt|;
name|char
modifier|*
name|dest_name
init|=
name|xmalloc
argument_list|(
name|new_len
operator|+
name|new_suffix_len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|dest_name
argument_list|,
name|src_name
argument_list|,
name|new_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dest_name
operator|+
name|new_len
argument_list|,
name|new_suffix
argument_list|,
name|new_suffix_len
argument_list|)
expr_stmt|;
name|dest_name
index|[
name|new_len
operator|+
name|new_suffix_len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|dest_name
return|;
block|}
end_function

begin_comment
comment|/// \brief      Appends suffix to src_name
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// In contrast to uncompressed_name(), we check only suffixes that are valid
end_comment

begin_comment
comment|/// for the specified file format.
end_comment

begin_function
specifier|static
name|char
modifier|*
name|compressed_name
parameter_list|(
specifier|const
name|char
modifier|*
name|src_name
parameter_list|,
specifier|const
name|size_t
name|src_len
parameter_list|)
block|{
comment|// The order of these must match the order in args.h.
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|all_suffixes
index|[]
index|[
literal|3
index|]
init|=
block|{
block|{
literal|".xz"
block|,
literal|".txz"
block|,
name|NULL
block|}
block|,
block|{
literal|".lzma"
block|,
literal|".tlz"
block|,
name|NULL
comment|/* 		}, { 			".gz", 			".tgz", 			NULL */
block|}
block|,
block|{
comment|// --format=raw requires specifying the suffix
comment|// manually or using stdout.
name|NULL
block|}
block|}
decl_stmt|;
comment|// args.c ensures this.
name|assert
argument_list|(
name|opt_format
operator|!=
name|FORMAT_AUTO
argument_list|)
expr_stmt|;
specifier|const
name|size_t
name|format
init|=
name|opt_format
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|suffixes
init|=
name|all_suffixes
index|[
name|format
index|]
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|suffixes
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|test_suffix
argument_list|(
name|suffixes
index|[
name|i
index|]
argument_list|,
name|src_name
argument_list|,
name|src_len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|message_warning
argument_list|(
name|_
argument_list|(
literal|"%s: File already has `%s' "
literal|"suffix, skipping"
argument_list|)
argument_list|,
name|src_name
argument_list|,
name|suffixes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|custom_suffix
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|test_suffix
argument_list|(
name|custom_suffix
argument_list|,
name|src_name
argument_list|,
name|src_len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|message_warning
argument_list|(
name|_
argument_list|(
literal|"%s: File already has `%s' "
literal|"suffix, skipping"
argument_list|)
argument_list|,
name|src_name
argument_list|,
name|custom_suffix
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|// TODO: Hmm, maybe it would be better to validate this in args.c,
comment|// since the suffix handling when decoding is weird now.
if|if
condition|(
name|opt_format
operator|==
name|FORMAT_RAW
operator|&&
name|custom_suffix
operator|==
name|NULL
condition|)
block|{
name|message_error
argument_list|(
name|_
argument_list|(
literal|"%s: With --format=raw, "
literal|"--suffix=.SUF is required unless "
literal|"writing to stdout"
argument_list|)
argument_list|,
name|src_name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
specifier|const
name|char
modifier|*
name|suffix
init|=
name|custom_suffix
operator|!=
name|NULL
condition|?
name|custom_suffix
else|:
name|suffixes
index|[
literal|0
index|]
decl_stmt|;
specifier|const
name|size_t
name|suffix_len
init|=
name|strlen
argument_list|(
name|suffix
argument_list|)
decl_stmt|;
name|char
modifier|*
name|dest_name
init|=
name|xmalloc
argument_list|(
name|src_len
operator|+
name|suffix_len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|dest_name
argument_list|,
name|src_name
argument_list|,
name|src_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dest_name
operator|+
name|src_len
argument_list|,
name|suffix
argument_list|,
name|suffix_len
argument_list|)
expr_stmt|;
name|dest_name
index|[
name|src_len
operator|+
name|suffix_len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|dest_name
return|;
block|}
end_function

begin_function
specifier|extern
name|char
modifier|*
name|suffix_get_dest_name
parameter_list|(
specifier|const
name|char
modifier|*
name|src_name
parameter_list|)
block|{
name|assert
argument_list|(
name|src_name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|// Length of the name is needed in all cases to locate the end of
comment|// the string to compare the suffix, so calculate the length here.
specifier|const
name|size_t
name|src_len
init|=
name|strlen
argument_list|(
name|src_name
argument_list|)
decl_stmt|;
return|return
name|opt_mode
operator|==
name|MODE_COMPRESS
condition|?
name|compressed_name
argument_list|(
name|src_name
argument_list|,
name|src_len
argument_list|)
else|:
name|uncompressed_name
argument_list|(
name|src_name
argument_list|,
name|src_len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|extern
name|void
name|suffix_set
parameter_list|(
specifier|const
name|char
modifier|*
name|suffix
parameter_list|)
block|{
comment|// Empty suffix and suffixes having a directory separator are
comment|// rejected. Such suffixes would break things later.
if|if
condition|(
name|suffix
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|has_dir_sep
argument_list|(
name|suffix
argument_list|)
condition|)
name|message_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: Invalid filename suffix"
argument_list|)
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
comment|// Replace the old custom_suffix (if any) with the new suffix.
name|free
argument_list|(
name|custom_suffix
argument_list|)
expr_stmt|;
name|custom_suffix
operator|=
name|xstrdup
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

