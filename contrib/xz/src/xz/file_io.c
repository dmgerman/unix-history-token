begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       file_io.c
end_comment

begin_comment
comment|/// \brief      File opening, unlinking, and closing
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Author:     Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"private.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TUKLIB_DOSLIKE
end_ifdef

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|bool
name|warn_fchown
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_FUTIMES
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_FUTIMESAT
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_UTIMES
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_UTIME
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"tuklib_open_stdxxx.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|O_BINARY
end_ifndef

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_NOCTTY
end_ifndef

begin_define
define|#
directive|define
name|O_NOCTTY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/// If true, try to create sparse files when decompressing.
end_comment

begin_decl_stmt
specifier|static
name|bool
name|try_sparse
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|TUKLIB_DOSLIKE
end_ifndef

begin_comment
comment|/// Original file status flags of standard output. This is used by
end_comment

begin_comment
comment|/// io_open_dest() and io_close_dest() to save and restore the flags.
end_comment

begin_decl_stmt
specifier|static
name|int
name|stdout_flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|restore_stdout_flags
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|bool
name|io_write_buf
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|extern
name|void
name|io_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|// Make sure that stdin, stdout, and stderr are connected to
comment|// a valid file descriptor. Exit immediately with exit code ERROR
comment|// if we cannot make the file descriptors valid. Maybe we should
comment|// print an error message, but our stderr could be screwed anyway.
name|tuklib_open_stdxxx
argument_list|(
name|E_ERROR
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|TUKLIB_DOSLIKE
comment|// If fchown() fails setting the owner, we warn about it only if
comment|// we are root.
name|warn_fchown
operator|=
name|geteuid
argument_list|()
operator|==
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__DJGPP__
comment|// Avoid doing useless things when statting files.
comment|// This isn't important but doesn't hurt.
name|_djstat_flags
operator|=
name|_STAT_INODE
operator||
name|_STAT_EXEC_EXT
operator||
name|_STAT_EXEC_MAGIC
operator||
name|_STAT_DIRSIZE
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_function
specifier|extern
name|void
name|io_no_sparse
parameter_list|(
name|void
parameter_list|)
block|{
name|try_sparse
operator|=
name|false
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/// \brief      Unlink a file
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This tries to verify that the file being unlinked really is the file that
end_comment

begin_comment
comment|/// we want to unlink by verifying device and inode numbers. There's still
end_comment

begin_comment
comment|/// a small unavoidable race, but this is much better than nothing (the file
end_comment

begin_comment
comment|/// could have been moved/replaced even hours earlier).
end_comment

begin_function
specifier|static
name|void
name|io_unlink
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|struct
name|stat
modifier|*
name|known_st
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TUKLIB_DOSLIKE
argument_list|)
comment|// On DOS-like systems, st_ino is meaningless, so don't bother
comment|// testing it. Just silence a compiler warning.
operator|(
name|void
operator|)
name|known_st
expr_stmt|;
else|#
directive|else
name|struct
name|stat
name|new_st
decl_stmt|;
comment|// If --force was used, use stat() instead of lstat(). This way
comment|// (de)compressing symlinks works correctly. However, it also means
comment|// that xz cannot detect if a regular file foo is renamed to bar
comment|// and then a symlink foo -> bar is created. Because of stat()
comment|// instead of lstat(), xz will think that foo hasn't been replaced
comment|// with another file. Thus, xz will remove foo even though it no
comment|// longer is the same file that xz used when it started compressing.
comment|// Probably it's not too bad though, so this doesn't need a more
comment|// complex fix.
specifier|const
name|int
name|stat_ret
init|=
name|opt_force
condition|?
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|new_st
argument_list|)
else|:
name|lstat
argument_list|(
name|name
argument_list|,
operator|&
name|new_st
argument_list|)
decl_stmt|;
if|if
condition|(
name|stat_ret
ifdef|#
directive|ifdef
name|__VMS
comment|// st_ino is an array, and we don't want to
comment|// compare st_dev at all.
operator|||
name|memcmp
argument_list|(
operator|&
name|new_st
operator|.
name|st_ino
argument_list|,
operator|&
name|known_st
operator|->
name|st_ino
argument_list|,
sizeof|sizeof
argument_list|(
name|new_st
operator|.
name|st_ino
argument_list|)
argument_list|)
operator|!=
literal|0
else|#
directive|else
comment|// Typical POSIX-like system
operator|||
name|new_st
operator|.
name|st_dev
operator|!=
name|known_st
operator|->
name|st_dev
operator|||
name|new_st
operator|.
name|st_ino
operator|!=
name|known_st
operator|->
name|st_ino
endif|#
directive|endif
condition|)
comment|// TRANSLATORS: When compression or decompression finishes,
comment|// and xz is going to remove the source file, xz first checks
comment|// if the source file still exists, and if it does, does its
comment|// device and inode numbers match what xz saw when it opened
comment|// the source file. If these checks fail, this message is
comment|// shown, %s being the filename, and the file is not deleted.
comment|// The check for device and inode numbers is there, because
comment|// it is possible that the user has put a new file in place
comment|// of the original file, and in that case it obviously
comment|// shouldn't be removed.
name|message_error
argument_list|(
name|_
argument_list|(
literal|"%s: File seems to have been moved, "
literal|"not removing"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
comment|// There's a race condition between lstat() and unlink()
comment|// but at least we have tried to avoid removing wrong file.
if|if
condition|(
name|unlink
argument_list|(
name|name
argument_list|)
condition|)
name|message_error
argument_list|(
name|_
argument_list|(
literal|"%s: Cannot remove: %s"
argument_list|)
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/// \brief      Copies owner/group and permissions
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \todo       ACL and EA support
end_comment

begin_comment
comment|///
end_comment

begin_function
specifier|static
name|void
name|io_copy_attrs
parameter_list|(
specifier|const
name|file_pair
modifier|*
name|pair
parameter_list|)
block|{
comment|// Skip chown and chmod on Windows.
ifndef|#
directive|ifndef
name|TUKLIB_DOSLIKE
comment|// This function is more tricky than you may think at first.
comment|// Blindly copying permissions may permit users to access the
comment|// destination file who didn't have permission to access the
comment|// source file.
comment|// Try changing the owner of the file. If we aren't root or the owner
comment|// isn't already us, fchown() probably doesn't succeed. We warn
comment|// about failing fchown() only if we are root.
if|if
condition|(
name|fchown
argument_list|(
name|pair
operator|->
name|dest_fd
argument_list|,
name|pair
operator|->
name|src_st
operator|.
name|st_uid
argument_list|,
operator|-
literal|1
argument_list|)
operator|&&
name|warn_fchown
condition|)
name|message_warning
argument_list|(
name|_
argument_list|(
literal|"%s: Cannot set the file owner: %s"
argument_list|)
argument_list|,
name|pair
operator|->
name|dest_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|mode_t
name|mode
decl_stmt|;
if|if
condition|(
name|fchown
argument_list|(
name|pair
operator|->
name|dest_fd
argument_list|,
operator|-
literal|1
argument_list|,
name|pair
operator|->
name|src_st
operator|.
name|st_gid
argument_list|)
condition|)
block|{
name|message_warning
argument_list|(
name|_
argument_list|(
literal|"%s: Cannot set the file group: %s"
argument_list|)
argument_list|,
name|pair
operator|->
name|dest_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|// We can still safely copy some additional permissions:
comment|// `group' must be at least as strict as `other' and
comment|// also vice versa.
comment|//
comment|// NOTE: After this, the owner of the source file may
comment|// get additional permissions. This shouldn't be too bad,
comment|// because the owner would have had permission to chmod
comment|// the original file anyway.
name|mode
operator|=
operator|(
operator|(
name|pair
operator|->
name|src_st
operator|.
name|st_mode
operator|&
literal|0070
operator|)
operator|>>
literal|3
operator|)
operator|&
operator|(
name|pair
operator|->
name|src_st
operator|.
name|st_mode
operator|&
literal|0007
operator|)
expr_stmt|;
name|mode
operator|=
operator|(
name|pair
operator|->
name|src_st
operator|.
name|st_mode
operator|&
literal|0700
operator|)
operator||
operator|(
name|mode
operator|<<
literal|3
operator|)
operator||
name|mode
expr_stmt|;
block|}
else|else
block|{
comment|// Drop the setuid, setgid, and sticky bits.
name|mode
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_mode
operator|&
literal|0777
expr_stmt|;
block|}
if|if
condition|(
name|fchmod
argument_list|(
name|pair
operator|->
name|dest_fd
argument_list|,
name|mode
argument_list|)
condition|)
name|message_warning
argument_list|(
name|_
argument_list|(
literal|"%s: Cannot set the file permissions: %s"
argument_list|)
argument_list|,
name|pair
operator|->
name|dest_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Copy the timestamps. We have several possible ways to do this, of
comment|// which some are better in both security and precision.
comment|//
comment|// First, get the nanosecond part of the timestamps. As of writing,
comment|// it's not standardized by POSIX, and there are several names for
comment|// the same thing in struct stat.
name|long
name|atime_nsec
decl_stmt|;
name|long
name|mtime_nsec
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC
argument_list|)
comment|// GNU and Solaris
name|atime_nsec
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_atim
operator|.
name|tv_nsec
expr_stmt|;
name|mtime_nsec
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_mtim
operator|.
name|tv_nsec
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_STRUCT_STAT_ST_ATIMESPEC_TV_NSEC
argument_list|)
comment|// BSD
name|atime_nsec
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_atimespec
operator|.
name|tv_nsec
expr_stmt|;
name|mtime_nsec
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_mtimespec
operator|.
name|tv_nsec
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_STRUCT_STAT_ST_ATIMENSEC
argument_list|)
comment|// GNU and BSD without extensions
name|atime_nsec
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_atimensec
expr_stmt|;
name|mtime_nsec
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_mtimensec
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_STRUCT_STAT_ST_UATIME
argument_list|)
comment|// Tru64
name|atime_nsec
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_uatime
operator|*
literal|1000
expr_stmt|;
name|mtime_nsec
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_umtime
operator|*
literal|1000
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_STRUCT_STAT_ST_ATIM_ST__TIM_TV_NSEC
argument_list|)
comment|// UnixWare
name|atime_nsec
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_atim
operator|.
name|st__tim
operator|.
name|tv_nsec
expr_stmt|;
name|mtime_nsec
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_mtim
operator|.
name|st__tim
operator|.
name|tv_nsec
expr_stmt|;
else|#
directive|else
comment|// Safe fallback
name|atime_nsec
operator|=
literal|0
expr_stmt|;
name|mtime_nsec
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|// Construct a structure to hold the timestamps and call appropriate
comment|// function to set the timestamps.
if|#
directive|if
name|defined
argument_list|(
name|HAVE_FUTIMENS
argument_list|)
comment|// Use nanosecond precision.
name|struct
name|timespec
name|tv
index|[
literal|2
index|]
decl_stmt|;
name|tv
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_atime
expr_stmt|;
name|tv
index|[
literal|0
index|]
operator|.
name|tv_nsec
operator|=
name|atime_nsec
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_mtime
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_nsec
operator|=
name|mtime_nsec
expr_stmt|;
operator|(
name|void
operator|)
name|futimens
argument_list|(
name|pair
operator|->
name|dest_fd
argument_list|,
name|tv
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_FUTIMES
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_FUTIMESAT
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_UTIMES
argument_list|)
comment|// Use microsecond precision.
name|struct
name|timeval
name|tv
index|[
literal|2
index|]
decl_stmt|;
name|tv
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_atime
expr_stmt|;
name|tv
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
name|atime_nsec
operator|/
literal|1000
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_mtime
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
name|mtime_nsec
operator|/
literal|1000
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_FUTIMES
argument_list|)
operator|(
name|void
operator|)
name|futimes
argument_list|(
name|pair
operator|->
name|dest_fd
argument_list|,
name|tv
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_FUTIMESAT
argument_list|)
operator|(
name|void
operator|)
name|futimesat
argument_list|(
name|pair
operator|->
name|dest_fd
argument_list|,
name|NULL
argument_list|,
name|tv
argument_list|)
expr_stmt|;
else|#
directive|else
comment|// Argh, no function to use a file descriptor to set the timestamp.
operator|(
name|void
operator|)
name|utimes
argument_list|(
name|pair
operator|->
name|dest_name
argument_list|,
name|tv
argument_list|)
expr_stmt|;
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_UTIME
argument_list|)
comment|// Use one-second precision. utime() doesn't support using file
comment|// descriptor either. Some systems have broken utime() prototype
comment|// so don't make this const.
name|struct
name|utimbuf
name|buf
init|=
block|{
operator|.
name|actime
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_atime
block|,
operator|.
name|modtime
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_mtime
block|, 	}
decl_stmt|;
comment|// Avoid warnings.
operator|(
name|void
operator|)
name|atime_nsec
expr_stmt|;
operator|(
name|void
operator|)
name|mtime_nsec
expr_stmt|;
operator|(
name|void
operator|)
name|utime
argument_list|(
name|pair
operator|->
name|dest_name
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_comment
comment|/// Opens the source file. Returns false on success, true on error.
end_comment

begin_function
specifier|static
name|bool
name|io_open_src_real
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|)
block|{
comment|// There's nothing to open when reading from stdin.
if|if
condition|(
name|pair
operator|->
name|src_name
operator|==
name|stdin_filename
condition|)
block|{
name|pair
operator|->
name|src_fd
operator|=
name|STDIN_FILENO
expr_stmt|;
ifdef|#
directive|ifdef
name|TUKLIB_DOSLIKE
name|setmode
argument_list|(
name|STDIN_FILENO
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|false
return|;
block|}
comment|// Symlinks are not followed unless writing to stdout or --force
comment|// was used.
specifier|const
name|bool
name|follow_symlinks
init|=
name|opt_stdout
operator|||
name|opt_force
decl_stmt|;
comment|// We accept only regular files if we are writing the output
comment|// to disk too. bzip2 allows overriding this with --force but
comment|// gzip and xz don't.
specifier|const
name|bool
name|reg_files_only
init|=
operator|!
name|opt_stdout
decl_stmt|;
comment|// Flags for open()
name|int
name|flags
init|=
name|O_RDONLY
operator||
name|O_BINARY
operator||
name|O_NOCTTY
decl_stmt|;
ifndef|#
directive|ifndef
name|TUKLIB_DOSLIKE
comment|// If we accept only regular files, we need to be careful to avoid
comment|// problems with special files like devices and FIFOs. O_NONBLOCK
comment|// prevents blocking when opening such files. When we want to accept
comment|// special files, we must not use O_NONBLOCK, or otherwise we won't
comment|// block waiting e.g. FIFOs to become readable.
if|if
condition|(
name|reg_files_only
condition|)
name|flags
operator||=
name|O_NONBLOCK
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|O_NOFOLLOW
argument_list|)
if|if
condition|(
operator|!
name|follow_symlinks
condition|)
name|flags
operator||=
name|O_NOFOLLOW
expr_stmt|;
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|TUKLIB_DOSLIKE
argument_list|)
comment|// Some POSIX-like systems lack O_NOFOLLOW (it's not required
comment|// by POSIX). Check for symlinks with a separate lstat() on
comment|// these systems.
if|if
condition|(
operator|!
name|follow_symlinks
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|pair
operator|->
name|src_name
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|S_ISLNK
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|message_warning
argument_list|(
name|_
argument_list|(
literal|"%s: Is a symbolic link, "
literal|"skipping"
argument_list|)
argument_list|,
name|pair
operator|->
name|src_name
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
else|#
directive|else
comment|// Avoid warnings.
operator|(
name|void
operator|)
name|follow_symlinks
expr_stmt|;
endif|#
directive|endif
comment|// Try to open the file. If we are accepting non-regular files,
comment|// unblock the caught signals so that open() can be interrupted
comment|// if it blocks e.g. due to a FIFO file.
if|if
condition|(
operator|!
name|reg_files_only
condition|)
name|signals_unblock
argument_list|()
expr_stmt|;
comment|// Maybe this wouldn't need a loop, since all the signal handlers for
comment|// which we don't use SA_RESTART set user_abort to true. But it
comment|// doesn't hurt to have it just in case.
do|do
block|{
name|pair
operator|->
name|src_fd
operator|=
name|open
argument_list|(
name|pair
operator|->
name|src_name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|pair
operator|->
name|src_fd
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
operator|&&
operator|!
name|user_abort
condition|)
do|;
if|if
condition|(
operator|!
name|reg_files_only
condition|)
name|signals_block
argument_list|()
expr_stmt|;
if|if
condition|(
name|pair
operator|->
name|src_fd
operator|==
operator|-
literal|1
condition|)
block|{
comment|// If we were interrupted, don't display any error message.
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
comment|// All the signals that don't have SA_RESTART
comment|// set user_abort.
name|assert
argument_list|(
name|user_abort
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
ifdef|#
directive|ifdef
name|O_NOFOLLOW
comment|// Give an understandable error message if the reason
comment|// for failing was that the file was a symbolic link.
comment|//
comment|// Note that at least Linux, OpenBSD, Solaris, and Darwin
comment|// use ELOOP to indicate that O_NOFOLLOW was the reason
comment|// that open() failed. Because there may be
comment|// directories in the pathname, ELOOP may occur also
comment|// because of a symlink loop in the directory part.
comment|// So ELOOP doesn't tell us what actually went wrong,
comment|// and this stupidity went into POSIX-1.2008 too.
comment|//
comment|// FreeBSD associates EMLINK with O_NOFOLLOW and
comment|// Tru64 uses ENOTSUP. We use these directly here
comment|// and skip the lstat() call and the associated race.
comment|// I want to hear if there are other kernels that
comment|// fail with something else than ELOOP with O_NOFOLLOW.
name|bool
name|was_symlink
init|=
name|false
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
if|if
condition|(
name|errno
operator|==
name|EMLINK
condition|)
name|was_symlink
operator|=
name|true
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__digital__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__unix__
argument_list|)
if|if
condition|(
name|errno
operator|==
name|ENOTSUP
condition|)
name|was_symlink
operator|=
name|true
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
if|if
condition|(
name|errno
operator|==
name|EFTYPE
condition|)
name|was_symlink
operator|=
name|true
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|errno
operator|==
name|ELOOP
operator|&&
operator|!
name|follow_symlinks
condition|)
block|{
specifier|const
name|int
name|saved_errno
init|=
name|errno
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|pair
operator|->
name|src_name
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
operator|&&
name|S_ISLNK
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
name|was_symlink
operator|=
name|true
expr_stmt|;
name|errno
operator|=
name|saved_errno
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|was_symlink
condition|)
name|message_warning
argument_list|(
name|_
argument_list|(
literal|"%s: Is a symbolic link, "
literal|"skipping"
argument_list|)
argument_list|,
name|pair
operator|->
name|src_name
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|// Something else than O_NOFOLLOW failing
comment|// (assuming that the race conditions didn't
comment|// confuse us).
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
ifndef|#
directive|ifndef
name|TUKLIB_DOSLIKE
comment|// Drop O_NONBLOCK, which is used only when we are accepting only
comment|// regular files. After the open() call, we want things to block
comment|// instead of giving EAGAIN.
if|if
condition|(
name|reg_files_only
condition|)
block|{
name|flags
operator|=
name|fcntl
argument_list|(
name|pair
operator|->
name|src_fd
argument_list|,
name|F_GETFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error_msg
goto|;
name|flags
operator|&=
operator|~
name|O_NONBLOCK
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|pair
operator|->
name|src_fd
argument_list|,
name|F_SETFL
argument_list|,
name|flags
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error_msg
goto|;
block|}
endif|#
directive|endif
comment|// Stat the source file. We need the result also when we copy
comment|// the permissions, and when unlinking.
if|if
condition|(
name|fstat
argument_list|(
name|pair
operator|->
name|src_fd
argument_list|,
operator|&
name|pair
operator|->
name|src_st
argument_list|)
condition|)
goto|goto
name|error_msg
goto|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|pair
operator|->
name|src_st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|message_warning
argument_list|(
name|_
argument_list|(
literal|"%s: Is a directory, skipping"
argument_list|)
argument_list|,
name|pair
operator|->
name|src_name
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|reg_files_only
operator|&&
operator|!
name|S_ISREG
argument_list|(
name|pair
operator|->
name|src_st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|message_warning
argument_list|(
name|_
argument_list|(
literal|"%s: Not a regular file, skipping"
argument_list|)
argument_list|,
name|pair
operator|->
name|src_name
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
ifndef|#
directive|ifndef
name|TUKLIB_DOSLIKE
if|if
condition|(
name|reg_files_only
operator|&&
operator|!
name|opt_force
condition|)
block|{
if|if
condition|(
name|pair
operator|->
name|src_st
operator|.
name|st_mode
operator|&
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator|)
condition|)
block|{
comment|// gzip rejects setuid and setgid files even
comment|// when --force was used. bzip2 doesn't check
comment|// for them, but calls fchown() after fchmod(),
comment|// and many systems automatically drop setuid
comment|// and setgid bits there.
comment|//
comment|// We accept setuid and setgid files if
comment|// --force was used. We drop these bits
comment|// explicitly in io_copy_attr().
name|message_warning
argument_list|(
name|_
argument_list|(
literal|"%s: File has setuid or "
literal|"setgid bit set, skipping"
argument_list|)
argument_list|,
name|pair
operator|->
name|src_name
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|pair
operator|->
name|src_st
operator|.
name|st_mode
operator|&
name|S_ISVTX
condition|)
block|{
name|message_warning
argument_list|(
name|_
argument_list|(
literal|"%s: File has sticky bit "
literal|"set, skipping"
argument_list|)
argument_list|,
name|pair
operator|->
name|src_name
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|pair
operator|->
name|src_st
operator|.
name|st_nlink
operator|>
literal|1
condition|)
block|{
name|message_warning
argument_list|(
name|_
argument_list|(
literal|"%s: Input file has more "
literal|"than one hard link, "
literal|"skipping"
argument_list|)
argument_list|,
name|pair
operator|->
name|src_name
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
endif|#
directive|endif
return|return
name|false
return|;
name|error_msg
label|:
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|error
label|:
operator|(
name|void
operator|)
name|close
argument_list|(
name|pair
operator|->
name|src_fd
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|extern
name|file_pair
modifier|*
name|io_open_src
parameter_list|(
specifier|const
name|char
modifier|*
name|src_name
parameter_list|)
block|{
if|if
condition|(
name|is_empty_filename
argument_list|(
name|src_name
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|// Since we have only one file open at a time, we can use
comment|// a statically allocated structure.
specifier|static
name|file_pair
name|pair
decl_stmt|;
name|pair
operator|=
operator|(
name|file_pair
operator|)
block|{
operator|.
name|src_name
operator|=
name|src_name
block|,
operator|.
name|dest_name
operator|=
name|NULL
block|,
operator|.
name|src_fd
operator|=
operator|-
literal|1
block|,
operator|.
name|dest_fd
operator|=
operator|-
literal|1
block|,
operator|.
name|src_eof
operator|=
name|false
block|,
operator|.
name|dest_try_sparse
operator|=
name|false
block|,
operator|.
name|dest_pending_sparse
operator|=
literal|0
block|, 	}
expr_stmt|;
comment|// Block the signals, for which we have a custom signal handler, so
comment|// that we don't need to worry about EINTR.
name|signals_block
argument_list|()
expr_stmt|;
specifier|const
name|bool
name|error
init|=
name|io_open_src_real
argument_list|(
operator|&
name|pair
argument_list|)
decl_stmt|;
name|signals_unblock
argument_list|()
expr_stmt|;
return|return
name|error
condition|?
name|NULL
else|:
operator|&
name|pair
return|;
block|}
end_function

begin_comment
comment|/// \brief      Closes source file of the file_pair structure
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \param      pair    File whose src_fd should be closed
end_comment

begin_comment
comment|/// \param      success If true, the file will be removed from the disk if
end_comment

begin_comment
comment|///                     closing succeeds and --keep hasn't been used.
end_comment

begin_function
specifier|static
name|void
name|io_close_src
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|,
name|bool
name|success
parameter_list|)
block|{
if|if
condition|(
name|pair
operator|->
name|src_fd
operator|!=
name|STDIN_FILENO
operator|&&
name|pair
operator|->
name|src_fd
operator|!=
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|TUKLIB_DOSLIKE
operator|(
name|void
operator|)
name|close
argument_list|(
name|pair
operator|->
name|src_fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// If we are going to unlink(), do it before closing the file.
comment|// This way there's no risk that someone replaces the file and
comment|// happens to get same inode number, which would make us
comment|// unlink() wrong file.
comment|//
comment|// NOTE: DOS-like systems are an exception to this, because
comment|// they don't allow unlinking files that are open. *sigh*
if|if
condition|(
name|success
operator|&&
operator|!
name|opt_keep_original
condition|)
name|io_unlink
argument_list|(
name|pair
operator|->
name|src_name
argument_list|,
operator|&
name|pair
operator|->
name|src_st
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|TUKLIB_DOSLIKE
operator|(
name|void
operator|)
name|close
argument_list|(
name|pair
operator|->
name|src_fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|bool
name|io_open_dest_real
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|)
block|{
if|if
condition|(
name|opt_stdout
operator|||
name|pair
operator|->
name|src_fd
operator|==
name|STDIN_FILENO
condition|)
block|{
comment|// We don't modify or free() this.
name|pair
operator|->
name|dest_name
operator|=
operator|(
name|char
operator|*
operator|)
literal|"(stdout)"
expr_stmt|;
name|pair
operator|->
name|dest_fd
operator|=
name|STDOUT_FILENO
expr_stmt|;
ifdef|#
directive|ifdef
name|TUKLIB_DOSLIKE
name|setmode
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|pair
operator|->
name|dest_name
operator|=
name|suffix_get_dest_name
argument_list|(
name|pair
operator|->
name|src_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pair
operator|->
name|dest_name
operator|==
name|NULL
condition|)
return|return
name|true
return|;
comment|// If --force was used, unlink the target file first.
if|if
condition|(
name|opt_force
operator|&&
name|unlink
argument_list|(
name|pair
operator|->
name|dest_name
argument_list|)
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|message_error
argument_list|(
name|_
argument_list|(
literal|"%s: Cannot remove: %s"
argument_list|)
argument_list|,
name|pair
operator|->
name|dest_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pair
operator|->
name|dest_name
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|// Open the file.
specifier|const
name|int
name|flags
init|=
name|O_WRONLY
operator||
name|O_BINARY
operator||
name|O_NOCTTY
operator||
name|O_CREAT
operator||
name|O_EXCL
decl_stmt|;
specifier|const
name|mode_t
name|mode
init|=
name|S_IRUSR
operator||
name|S_IWUSR
decl_stmt|;
name|pair
operator|->
name|dest_fd
operator|=
name|open
argument_list|(
name|pair
operator|->
name|dest_name
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|pair
operator|->
name|dest_fd
operator|==
operator|-
literal|1
condition|)
block|{
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|dest_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pair
operator|->
name|dest_name
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
comment|// If this really fails... well, we have a safe fallback.
if|if
condition|(
name|fstat
argument_list|(
name|pair
operator|->
name|dest_fd
argument_list|,
operator|&
name|pair
operator|->
name|dest_st
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__VMS
argument_list|)
name|pair
operator|->
name|dest_st
operator|.
name|st_ino
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|pair
operator|->
name|dest_st
operator|.
name|st_ino
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|pair
operator|->
name|dest_st
operator|.
name|st_ino
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|TUKLIB_DOSLIKE
argument_list|)
name|pair
operator|->
name|dest_st
operator|.
name|st_dev
operator|=
literal|0
expr_stmt|;
name|pair
operator|->
name|dest_st
operator|.
name|st_ino
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|TUKLIB_DOSLIKE
block|}
elseif|else
if|if
condition|(
name|try_sparse
operator|&&
name|opt_mode
operator|==
name|MODE_DECOMPRESS
condition|)
block|{
comment|// When writing to standard output, we need to be extra
comment|// careful:
comment|//  - It may be connected to something else than
comment|//    a regular file.
comment|//  - We aren't necessarily writing to a new empty file
comment|//    or to the end of an existing file.
comment|//  - O_APPEND may be active.
comment|//
comment|// TODO: I'm keeping this disabled for DOS-like systems
comment|// for now. FAT doesn't support sparse files, but NTFS
comment|// does, so maybe this should be enabled on Windows after
comment|// some testing.
if|if
condition|(
name|pair
operator|->
name|dest_fd
operator|==
name|STDOUT_FILENO
condition|)
block|{
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|pair
operator|->
name|dest_st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
name|false
return|;
name|stdout_flags
operator|=
name|fcntl
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|F_GETFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdout_flags
operator|==
operator|-
literal|1
condition|)
return|return
name|false
return|;
if|if
condition|(
name|stdout_flags
operator|&
name|O_APPEND
condition|)
block|{
comment|// Creating a sparse file is not possible
comment|// when O_APPEND is active (it's used by
comment|// shell's>> redirection). As I understand
comment|// it, it is safe to temporarily disable
comment|// O_APPEND in xz, because if someone
comment|// happened to write to the same file at the
comment|// same time, results would be bad anyway
comment|// (users shouldn't assume that xz uses any
comment|// specific block size when writing data).
comment|//
comment|// The write position may be something else
comment|// than the end of the file, so we must fix
comment|// it to start writing at the end of the file
comment|// to imitate O_APPEND.
if|if
condition|(
name|lseek
argument_list|(
name|STDOUT_FILENO
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|false
return|;
if|if
condition|(
name|fcntl
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|F_SETFL
argument_list|,
name|stdout_flags
operator|&
operator|~
name|O_APPEND
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|false
return|;
comment|// Disabling O_APPEND succeeded. Mark
comment|// that the flags should be restored
comment|// in io_close_dest().
name|restore_stdout_flags
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lseek
argument_list|(
name|STDOUT_FILENO
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
name|pair
operator|->
name|dest_st
operator|.
name|st_size
condition|)
block|{
comment|// Writing won't start exactly at the end
comment|// of the file. We cannot use sparse output,
comment|// because it would probably corrupt the file.
return|return
name|false
return|;
block|}
block|}
name|pair
operator|->
name|dest_try_sparse
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|extern
name|bool
name|io_open_dest
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|)
block|{
name|signals_block
argument_list|()
expr_stmt|;
specifier|const
name|bool
name|ret
init|=
name|io_open_dest_real
argument_list|(
name|pair
argument_list|)
decl_stmt|;
name|signals_unblock
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/// \brief      Closes destination file of the file_pair structure
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \param      pair    File whose dest_fd should be closed
end_comment

begin_comment
comment|/// \param      success If false, the file will be removed from the disk.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \return     Zero if closing succeeds. On error, -1 is returned and
end_comment

begin_comment
comment|///             error message printed.
end_comment

begin_function
specifier|static
name|bool
name|io_close_dest
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|,
name|bool
name|success
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|TUKLIB_DOSLIKE
comment|// If io_open_dest() has disabled O_APPEND, restore it here.
if|if
condition|(
name|restore_stdout_flags
condition|)
block|{
name|assert
argument_list|(
name|pair
operator|->
name|dest_fd
operator|==
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|restore_stdout_flags
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|F_SETFL
argument_list|,
name|stdout_flags
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|message_error
argument_list|(
name|_
argument_list|(
literal|"Error restoring the O_APPEND flag "
literal|"to standard output: %s"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|pair
operator|->
name|dest_fd
operator|==
operator|-
literal|1
operator|||
name|pair
operator|->
name|dest_fd
operator|==
name|STDOUT_FILENO
condition|)
return|return
name|false
return|;
if|if
condition|(
name|close
argument_list|(
name|pair
operator|->
name|dest_fd
argument_list|)
condition|)
block|{
name|message_error
argument_list|(
name|_
argument_list|(
literal|"%s: Closing the file failed: %s"
argument_list|)
argument_list|,
name|pair
operator|->
name|dest_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|// Closing destination file failed, so we cannot trust its
comment|// contents. Get rid of junk:
name|io_unlink
argument_list|(
name|pair
operator|->
name|dest_name
argument_list|,
operator|&
name|pair
operator|->
name|dest_st
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pair
operator|->
name|dest_name
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|// If the operation using this file wasn't successful, we git rid
comment|// of the junk file.
if|if
condition|(
operator|!
name|success
condition|)
name|io_unlink
argument_list|(
name|pair
operator|->
name|dest_name
argument_list|,
operator|&
name|pair
operator|->
name|dest_st
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pair
operator|->
name|dest_name
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|extern
name|void
name|io_close
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|,
name|bool
name|success
parameter_list|)
block|{
comment|// Take care of sparseness at the end of the output file.
if|if
condition|(
name|success
operator|&&
name|pair
operator|->
name|dest_try_sparse
operator|&&
name|pair
operator|->
name|dest_pending_sparse
operator|>
literal|0
condition|)
block|{
comment|// Seek forward one byte less than the size of the pending
comment|// hole, then write one zero-byte. This way the file grows
comment|// to its correct size. An alternative would be to use
comment|// ftruncate() but that isn't portable enough (e.g. it
comment|// doesn't work with FAT on Linux; FAT isn't that important
comment|// since it doesn't support sparse files anyway, but we don't
comment|// want to create corrupt files on it).
if|if
condition|(
name|lseek
argument_list|(
name|pair
operator|->
name|dest_fd
argument_list|,
name|pair
operator|->
name|dest_pending_sparse
operator|-
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|message_error
argument_list|(
name|_
argument_list|(
literal|"%s: Seeking failed when trying "
literal|"to create a sparse file: %s"
argument_list|)
argument_list|,
name|pair
operator|->
name|dest_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|success
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|uint8_t
name|zero
index|[
literal|1
index|]
init|=
block|{
literal|'\0'
block|}
decl_stmt|;
if|if
condition|(
name|io_write_buf
argument_list|(
name|pair
argument_list|,
name|zero
argument_list|,
literal|1
argument_list|)
condition|)
name|success
operator|=
name|false
expr_stmt|;
block|}
block|}
name|signals_block
argument_list|()
expr_stmt|;
comment|// Copy the file attributes. We need to skip this if destination
comment|// file isn't open or it is standard output.
if|if
condition|(
name|success
operator|&&
name|pair
operator|->
name|dest_fd
operator|!=
operator|-
literal|1
operator|&&
name|pair
operator|->
name|dest_fd
operator|!=
name|STDOUT_FILENO
condition|)
name|io_copy_attrs
argument_list|(
name|pair
argument_list|)
expr_stmt|;
comment|// Close the destination first. If it fails, we must not remove
comment|// the source file!
if|if
condition|(
name|io_close_dest
argument_list|(
name|pair
argument_list|,
name|success
argument_list|)
condition|)
name|success
operator|=
name|false
expr_stmt|;
comment|// Close the source file, and unlink it if the operation using this
comment|// file pair was successful and we haven't requested to keep the
comment|// source file.
name|io_close_src
argument_list|(
name|pair
argument_list|,
name|success
argument_list|)
expr_stmt|;
name|signals_unblock
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|extern
name|size_t
name|io_read
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|,
name|io_buf
modifier|*
name|buf_union
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
comment|// We use small buffers here.
name|assert
argument_list|(
name|size
operator|<
name|SSIZE_MAX
argument_list|)
expr_stmt|;
name|uint8_t
modifier|*
name|buf
init|=
name|buf_union
operator|->
name|u8
decl_stmt|;
name|size_t
name|left
init|=
name|size
decl_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
specifier|const
name|ssize_t
name|amount
init|=
name|read
argument_list|(
name|pair
operator|->
name|src_fd
argument_list|,
name|buf
argument_list|,
name|left
argument_list|)
decl_stmt|;
if|if
condition|(
name|amount
operator|==
literal|0
condition|)
block|{
name|pair
operator|->
name|src_eof
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|amount
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
if|if
condition|(
name|user_abort
condition|)
return|return
name|SIZE_MAX
return|;
continue|continue;
block|}
name|message_error
argument_list|(
name|_
argument_list|(
literal|"%s: Read error: %s"
argument_list|)
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|// FIXME Is this needed?
name|pair
operator|->
name|src_eof
operator|=
name|true
expr_stmt|;
return|return
name|SIZE_MAX
return|;
block|}
name|buf
operator|+=
call|(
name|size_t
call|)
argument_list|(
name|amount
argument_list|)
expr_stmt|;
name|left
operator|-=
call|(
name|size_t
call|)
argument_list|(
name|amount
argument_list|)
expr_stmt|;
block|}
return|return
name|size
operator|-
name|left
return|;
block|}
end_function

begin_function
specifier|extern
name|bool
name|io_pread
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|,
name|io_buf
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|off_t
name|pos
parameter_list|)
block|{
comment|// Using lseek() and read() is more portable than pread() and
comment|// for us it is as good as real pread().
if|if
condition|(
name|lseek
argument_list|(
name|pair
operator|->
name|src_fd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|pos
condition|)
block|{
name|message_error
argument_list|(
name|_
argument_list|(
literal|"%s: Error seeking the file: %s"
argument_list|)
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
specifier|const
name|size_t
name|amount
init|=
name|io_read
argument_list|(
name|pair
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|amount
operator|==
name|SIZE_MAX
condition|)
return|return
name|true
return|;
if|if
condition|(
name|amount
operator|!=
name|size
condition|)
block|{
name|message_error
argument_list|(
name|_
argument_list|(
literal|"%s: Unexpected end of file"
argument_list|)
argument_list|,
name|pair
operator|->
name|src_name
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|is_sparse
parameter_list|(
specifier|const
name|io_buf
modifier|*
name|buf
parameter_list|)
block|{
name|assert
argument_list|(
name|IO_BUFFER_SIZE
operator|%
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|buf
operator|->
name|u64
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|buf
operator|->
name|u64
index|[
name|i
index|]
operator|!=
literal|0
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|io_write_buf
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|assert
argument_list|(
name|size
operator|<
name|SSIZE_MAX
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
specifier|const
name|ssize_t
name|amount
init|=
name|write
argument_list|(
name|pair
operator|->
name|dest_fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|amount
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
if|if
condition|(
name|user_abort
condition|)
return|return
name|true
return|;
continue|continue;
block|}
comment|// Handle broken pipe specially. gzip and bzip2
comment|// don't print anything on SIGPIPE. In addition,
comment|// gzip --quiet uses exit status 2 (warning) on
comment|// broken pipe instead of whatever raise(SIGPIPE)
comment|// would make it return. It is there to hide "Broken
comment|// pipe" message on some old shells (probably old
comment|// GNU bash).
comment|//
comment|// We don't do anything special with --quiet, which
comment|// is what bzip2 does too. If we get SIGPIPE, we
comment|// will handle it like other signals by setting
comment|// user_abort, and get EPIPE here.
if|if
condition|(
name|errno
operator|!=
name|EPIPE
condition|)
name|message_error
argument_list|(
name|_
argument_list|(
literal|"%s: Write error: %s"
argument_list|)
argument_list|,
name|pair
operator|->
name|dest_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|buf
operator|+=
call|(
name|size_t
call|)
argument_list|(
name|amount
argument_list|)
expr_stmt|;
name|size
operator|-=
call|(
name|size_t
call|)
argument_list|(
name|amount
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|extern
name|bool
name|io_write
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|,
specifier|const
name|io_buf
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|assert
argument_list|(
name|size
operator|<=
name|IO_BUFFER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pair
operator|->
name|dest_try_sparse
condition|)
block|{
comment|// Check if the block is sparse (contains only zeros). If it
comment|// sparse, we just store the amount and return. We will take
comment|// care of actually skipping over the hole when we hit the
comment|// next data block or close the file.
comment|//
comment|// Since io_close() requires that dest_pending_sparse> 0
comment|// if the file ends with sparse block, we must also return
comment|// if size == 0 to avoid doing the lseek().
if|if
condition|(
name|size
operator|==
name|IO_BUFFER_SIZE
condition|)
block|{
if|if
condition|(
name|is_sparse
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|pair
operator|->
name|dest_pending_sparse
operator|+=
name|size
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
name|false
return|;
block|}
comment|// This is not a sparse block. If we have a pending hole,
comment|// skip it now.
if|if
condition|(
name|pair
operator|->
name|dest_pending_sparse
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|pair
operator|->
name|dest_fd
argument_list|,
name|pair
operator|->
name|dest_pending_sparse
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|message_error
argument_list|(
name|_
argument_list|(
literal|"%s: Seeking failed when "
literal|"trying to create a sparse "
literal|"file: %s"
argument_list|)
argument_list|,
name|pair
operator|->
name|dest_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|pair
operator|->
name|dest_pending_sparse
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|io_write_buf
argument_list|(
name|pair
argument_list|,
name|buf
operator|->
name|u8
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

end_unit

