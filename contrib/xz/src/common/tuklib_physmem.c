begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       tuklib_physmem.c
end_comment

begin_comment
comment|/// \brief      Get the amount of physical memory
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Author:     Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"tuklib_physmem.h"
end_include

begin_comment
comment|// We want to use Windows-specific code on Cygwin, which also has memory
end_comment

begin_comment
comment|// information available via sysconf(), but on Cygwin 1.5 and older it
end_comment

begin_comment
comment|// gives wrong results (from our point of view).
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32_WINNT
end_ifndef

begin_define
define|#
directive|define
name|_WIN32_WINNT
value|0x0500
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__OS2__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|INCL_DOSMISC
end_define

begin_include
include|#
directive|include
file|<os2.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__DJGPP__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<dpmi.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__VMS
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<lib$routines.h>
end_include

begin_include
include|#
directive|include
file|<syidef.h>
end_include

begin_include
include|#
directive|include
file|<ssdef.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|AMIGA
argument_list|)
operator|||
name|defined
argument_list|(
name|__AROS__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|__USE_INLINE__
end_define

begin_include
include|#
directive|include
file|<proto/exec.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__QNX__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/syspage.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|TUKLIB_PHYSMEM_AIX
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/systemcfg.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|TUKLIB_PHYSMEM_SYSCONF
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|TUKLIB_PHYSMEM_SYSCTL
argument_list|)
end_elif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PARAM_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_comment
comment|// Tru64
end_comment

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|TUKLIB_PHYSMEM_GETSYSINFO
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/sysinfo.h>
end_include

begin_include
include|#
directive|include
file|<machine/hal_sysinfo.h>
end_include

begin_comment
comment|// HP-UX
end_comment

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|TUKLIB_PHYSMEM_PSTAT_GETSTATIC
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/pstat.h>
end_include

begin_comment
comment|// IRIX
end_comment

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|TUKLIB_PHYSMEM_GETINVENT_R
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<invent.h>
end_include

begin_comment
comment|// This sysinfo() is Linux-specific.
end_comment

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|TUKLIB_PHYSMEM_SYSINFO
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<sys/sysinfo.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|extern
name|uint64_t
name|tuklib_physmem
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|ret
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
if|if
condition|(
operator|(
name|GetVersion
argument_list|()
operator|&
literal|0xFF
operator|)
operator|>=
literal|5
condition|)
block|{
comment|// Windows 2000 and later have GlobalMemoryStatusEx() which
comment|// supports reporting values greater than 4 GiB. To keep the
comment|// code working also on older Windows versions, use
comment|// GlobalMemoryStatusEx() conditionally.
name|HMODULE
name|kernel32
init|=
name|GetModuleHandle
argument_list|(
literal|"kernel32.dll"
argument_list|)
decl_stmt|;
if|if
condition|(
name|kernel32
operator|!=
name|NULL
condition|)
block|{
typedef|typedef
name|BOOL
function_decl|(
name|WINAPI
modifier|*
name|gmse_type
function_decl|)
parameter_list|(
name|LPMEMORYSTATUSEX
parameter_list|)
function_decl|;
name|gmse_type
name|gmse
init|=
operator|(
name|gmse_type
operator|)
name|GetProcAddress
argument_list|(
name|kernel32
argument_list|,
literal|"GlobalMemoryStatusEx"
argument_list|)
decl_stmt|;
if|if
condition|(
name|gmse
operator|!=
name|NULL
condition|)
block|{
name|MEMORYSTATUSEX
name|meminfo
decl_stmt|;
name|meminfo
operator|.
name|dwLength
operator|=
sizeof|sizeof
argument_list|(
name|meminfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmse
argument_list|(
operator|&
name|meminfo
argument_list|)
condition|)
name|ret
operator|=
name|meminfo
operator|.
name|ullTotalPhys
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
comment|// GlobalMemoryStatus() is supported by Windows 95 and later,
comment|// so it is fine to link against it unconditionally. Note that
comment|// GlobalMemoryStatus() has no return value.
name|MEMORYSTATUS
name|meminfo
decl_stmt|;
name|meminfo
operator|.
name|dwLength
operator|=
sizeof|sizeof
argument_list|(
name|meminfo
argument_list|)
expr_stmt|;
name|GlobalMemoryStatus
argument_list|(
operator|&
name|meminfo
argument_list|)
expr_stmt|;
name|ret
operator|=
name|meminfo
operator|.
name|dwTotalPhys
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|__OS2__
argument_list|)
name|unsigned
name|long
name|mem
decl_stmt|;
if|if
condition|(
name|DosQuerySysInfo
argument_list|(
name|QSV_TOTPHYSMEM
argument_list|,
name|QSV_TOTPHYSMEM
argument_list|,
operator|&
name|mem
argument_list|,
sizeof|sizeof
argument_list|(
name|mem
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|mem
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__DJGPP__
argument_list|)
name|__dpmi_free_mem_info
name|meminfo
decl_stmt|;
if|if
condition|(
name|__dpmi_get_free_memory_information
argument_list|(
operator|&
name|meminfo
argument_list|)
operator|==
literal|0
operator|&&
name|meminfo
operator|.
name|total_number_of_physical_pages
operator|!=
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
name|ret
operator|=
operator|(
name|uint64_t
operator|)
name|meminfo
operator|.
name|total_number_of_physical_pages
operator|*
literal|4096
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__VMS
argument_list|)
name|int
name|vms_mem
decl_stmt|;
name|int
name|val
init|=
name|SYI$_MEMSIZE
decl_stmt|;
if|if
condition|(
name|LIB$GETSYI
argument_list|(
operator|&
name|val
argument_list|,
operator|&
name|vms_mem
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|SS$_NORMAL
condition|)
name|ret
operator|=
operator|(
name|uint64_t
operator|)
name|vms_mem
operator|*
literal|8192
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|AMIGA
argument_list|)
operator|||
name|defined
argument_list|(
name|__AROS__
argument_list|)
name|ret
operator|=
name|AvailMem
argument_list|(
name|MEMF_TOTAL
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__QNX__
argument_list|)
specifier|const
name|struct
name|asinfo_entry
modifier|*
name|entries
init|=
name|SYSPAGE_ENTRY
argument_list|(
name|asinfo
argument_list|)
decl_stmt|;
name|size_t
name|count
init|=
name|SYSPAGE_ENTRY_SIZE
argument_list|(
name|asinfo
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|asinfo_entry
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|strings
init|=
name|SYSPAGE_ENTRY
argument_list|(
name|strings
argument_list|)
operator|->
name|data
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|strings
operator|+
name|entries
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"ram"
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|+=
name|entries
index|[
name|i
index|]
operator|.
name|end
operator|-
name|entries
index|[
name|i
index|]
operator|.
name|start
operator|+
literal|1
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|TUKLIB_PHYSMEM_AIX
argument_list|)
name|ret
operator|=
name|_system_configuration
operator|.
name|physmem
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|TUKLIB_PHYSMEM_SYSCONF
argument_list|)
specifier|const
name|long
name|pagesize
init|=
name|sysconf
argument_list|(
name|_SC_PAGESIZE
argument_list|)
decl_stmt|;
specifier|const
name|long
name|pages
init|=
name|sysconf
argument_list|(
name|_SC_PHYS_PAGES
argument_list|)
decl_stmt|;
if|if
condition|(
name|pagesize
operator|!=
operator|-
literal|1
operator|&&
name|pages
operator|!=
operator|-
literal|1
condition|)
comment|// According to docs, pagesize * pages can overflow.
comment|// Simple case is 32-bit box with 4 GiB or more RAM,
comment|// which may report exactly 4 GiB of RAM, and "long"
comment|// being 32-bit will overflow. Casting to uint64_t
comment|// hopefully avoids overflows in the near future.
name|ret
operator|=
operator|(
name|uint64_t
operator|)
name|pagesize
operator|*
operator|(
name|uint64_t
operator|)
name|pages
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|TUKLIB_PHYSMEM_SYSCTL
argument_list|)
name|int
name|name
index|[
literal|2
index|]
init|=
block|{
name|CTL_HW
block|,
ifdef|#
directive|ifdef
name|HW_PHYSMEM64
name|HW_PHYSMEM64
else|#
directive|else
name|HW_PHYSMEM
endif|#
directive|endif
block|}
decl_stmt|;
union|union
block|{
name|uint32_t
name|u32
decl_stmt|;
name|uint64_t
name|u64
decl_stmt|;
block|}
name|mem
union|;
name|size_t
name|mem_ptr_size
init|=
sizeof|sizeof
argument_list|(
name|mem
operator|.
name|u64
argument_list|)
decl_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|name
argument_list|,
literal|2
argument_list|,
operator|&
name|mem
operator|.
name|u64
argument_list|,
operator|&
name|mem_ptr_size
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// IIRC, 64-bit "return value" is possible on some 64-bit
comment|// BSD systems even with HW_PHYSMEM (instead of HW_PHYSMEM64),
comment|// so support both.
if|if
condition|(
name|mem_ptr_size
operator|==
sizeof|sizeof
argument_list|(
name|mem
operator|.
name|u64
argument_list|)
condition|)
name|ret
operator|=
name|mem
operator|.
name|u64
expr_stmt|;
elseif|else
if|if
condition|(
name|mem_ptr_size
operator|==
sizeof|sizeof
argument_list|(
name|mem
operator|.
name|u32
argument_list|)
condition|)
name|ret
operator|=
name|mem
operator|.
name|u32
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|TUKLIB_PHYSMEM_GETSYSINFO
argument_list|)
comment|// Docs are unclear if "start" is needed, but it doesn't hurt
comment|// much to have it.
name|int
name|memkb
decl_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|getsysinfo
argument_list|(
name|GSI_PHYSMEM
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|memkb
argument_list|,
sizeof|sizeof
argument_list|(
name|memkb
argument_list|)
argument_list|,
operator|&
name|start
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|ret
operator|=
operator|(
name|uint64_t
operator|)
name|memkb
operator|*
literal|1024
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|TUKLIB_PHYSMEM_PSTAT_GETSTATIC
argument_list|)
name|struct
name|pst_static
name|pst
decl_stmt|;
if|if
condition|(
name|pstat_getstatic
argument_list|(
operator|&
name|pst
argument_list|,
sizeof|sizeof
argument_list|(
name|pst
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|ret
operator|=
operator|(
name|uint64_t
operator|)
name|pst
operator|.
name|physical_memory
operator|*
operator|(
name|uint64_t
operator|)
name|pst
operator|.
name|page_size
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|TUKLIB_PHYSMEM_GETINVENT_R
argument_list|)
name|inv_state_t
modifier|*
name|st
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|setinvent_r
argument_list|(
operator|&
name|st
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|inventory_t
modifier|*
name|i
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|getinvent_r
argument_list|(
name|st
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|i
operator|->
name|inv_class
operator|==
name|INV_MEMORY
operator|&&
name|i
operator|->
name|inv_type
operator|==
name|INV_MAIN_MB
condition|)
block|{
name|ret
operator|=
operator|(
name|uint64_t
operator|)
name|i
operator|->
name|inv_state
operator|<<
literal|20
expr_stmt|;
break|break;
block|}
block|}
name|endinvent_r
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|TUKLIB_PHYSMEM_SYSINFO
argument_list|)
name|struct
name|sysinfo
name|si
decl_stmt|;
if|if
condition|(
name|sysinfo
argument_list|(
operator|&
name|si
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
operator|(
name|uint64_t
operator|)
name|si
operator|.
name|totalram
operator|*
name|si
operator|.
name|mem_unit
expr_stmt|;
endif|#
directive|endif
return|return
name|ret
return|;
block|}
end_function

end_unit

