begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       lz_encoder_mf.c
end_comment

begin_comment
comment|/// \brief      Match finders
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//  Authors:    Igor Pavlov
end_comment

begin_comment
comment|//              Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"lz_encoder.h"
end_include

begin_include
include|#
directive|include
file|"lz_encoder_hash.h"
end_include

begin_comment
comment|/// \brief      Find matches starting from the current byte
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \return     The length of the longest match found
end_comment

begin_function
specifier|extern
name|uint32_t
name|lzma_mf_find
parameter_list|(
name|lzma_mf
modifier|*
name|mf
parameter_list|,
name|uint32_t
modifier|*
name|count_ptr
parameter_list|,
name|lzma_match
modifier|*
name|matches
parameter_list|)
block|{
comment|// Call the match finder. It returns the number of length-distance
comment|// pairs found.
comment|// FIXME: Minimum count is zero, what _exactly_ is the maximum?
specifier|const
name|uint32_t
name|count
init|=
name|mf
operator|->
name|find
argument_list|(
name|mf
argument_list|,
name|matches
argument_list|)
decl_stmt|;
comment|// Length of the longest match; assume that no matches were found
comment|// and thus the maximum length is zero.
name|uint32_t
name|len_best
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
comment|// Validate the matches.
for|for
control|(
name|uint32_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|assert
argument_list|(
name|matches
index|[
name|i
index|]
operator|.
name|len
operator|<=
name|mf
operator|->
name|nice_len
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|matches
index|[
name|i
index|]
operator|.
name|dist
operator|<
name|mf
operator|->
name|read_pos
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|memcmp
argument_list|(
name|mf_ptr
argument_list|(
name|mf
argument_list|)
operator|-
literal|1
argument_list|,
name|mf_ptr
argument_list|(
name|mf
argument_list|)
operator|-
name|matches
index|[
name|i
index|]
operator|.
name|dist
operator|-
literal|2
argument_list|,
name|matches
index|[
name|i
index|]
operator|.
name|len
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// The last used element in the array contains
comment|// the longest match.
name|len_best
operator|=
name|matches
index|[
name|count
operator|-
literal|1
index|]
operator|.
name|len
expr_stmt|;
comment|// If a match of maximum search length was found, try to
comment|// extend the match to maximum possible length.
if|if
condition|(
name|len_best
operator|==
name|mf
operator|->
name|nice_len
condition|)
block|{
comment|// The limit for the match length is either the
comment|// maximum match length supported by the LZ-based
comment|// encoder or the number of bytes left in the
comment|// dictionary, whichever is smaller.
name|uint32_t
name|limit
init|=
name|mf_avail
argument_list|(
name|mf
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|limit
operator|>
name|mf
operator|->
name|match_len_max
condition|)
name|limit
operator|=
name|mf
operator|->
name|match_len_max
expr_stmt|;
comment|// Pointer to the byte we just ran through
comment|// the match finder.
specifier|const
name|uint8_t
modifier|*
name|p1
init|=
name|mf_ptr
argument_list|(
name|mf
argument_list|)
operator|-
literal|1
decl_stmt|;
comment|// Pointer to the beginning of the match. We need -1
comment|// here because the match distances are zero based.
specifier|const
name|uint8_t
modifier|*
name|p2
init|=
name|p1
operator|-
name|matches
index|[
name|count
operator|-
literal|1
index|]
operator|.
name|dist
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|len_best
operator|<
name|limit
operator|&&
name|p1
index|[
name|len_best
index|]
operator|==
name|p2
index|[
name|len_best
index|]
condition|)
operator|++
name|len_best
expr_stmt|;
block|}
block|}
operator|*
name|count_ptr
operator|=
name|count
expr_stmt|;
comment|// Finally update the read position to indicate that match finder was
comment|// run for this dictionary offset.
operator|++
name|mf
operator|->
name|read_ahead
expr_stmt|;
return|return
name|len_best
return|;
block|}
end_function

begin_comment
comment|/// Hash value to indicate unused element in the hash. Since we start the
end_comment

begin_comment
comment|/// positions from dict_size + 1, zero is always too far to qualify
end_comment

begin_comment
comment|/// as usable match position.
end_comment

begin_define
define|#
directive|define
name|EMPTY_HASH_VALUE
value|0
end_define

begin_comment
comment|/// Normalization must be done when lzma_mf.offset + lzma_mf.read_pos
end_comment

begin_comment
comment|/// reaches MUST_NORMALIZE_POS.
end_comment

begin_define
define|#
directive|define
name|MUST_NORMALIZE_POS
value|UINT32_MAX
end_define

begin_comment
comment|/// \brief      Normalizes hash values
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// The hash arrays store positions of match candidates. The positions are
end_comment

begin_comment
comment|/// relative to an arbitrary offset that is not the same as the absolute
end_comment

begin_comment
comment|/// offset in the input stream. The relative position of the current byte
end_comment

begin_comment
comment|/// is lzma_mf.offset + lzma_mf.read_pos. The distances of the matches are
end_comment

begin_comment
comment|/// the differences of the current read position and the position found from
end_comment

begin_comment
comment|/// the hash.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// To prevent integer overflows of the offsets stored in the hash arrays,
end_comment

begin_comment
comment|/// we need to "normalize" the stored values now and then. During the
end_comment

begin_comment
comment|/// normalization, we drop values that indicate distance greater than the
end_comment

begin_comment
comment|/// dictionary size, thus making space for new values.
end_comment

begin_function
specifier|static
name|void
name|normalize
parameter_list|(
name|lzma_mf
modifier|*
name|mf
parameter_list|)
block|{
name|assert
argument_list|(
name|mf
operator|->
name|read_pos
operator|+
name|mf
operator|->
name|offset
operator|==
name|MUST_NORMALIZE_POS
argument_list|)
expr_stmt|;
comment|// In future we may not want to touch the lowest bits, because there
comment|// may be match finders that use larger resolution than one byte.
specifier|const
name|uint32_t
name|subvalue
init|=
operator|(
name|MUST_NORMALIZE_POS
operator|-
name|mf
operator|->
name|cyclic_size
operator|)
decl_stmt|;
comment|//& (~(UINT32_C(1)<< 10) - 1);
specifier|const
name|uint32_t
name|count
init|=
name|mf
operator|->
name|hash_size_sum
operator|+
name|mf
operator|->
name|sons_count
decl_stmt|;
name|uint32_t
modifier|*
name|hash
init|=
name|mf
operator|->
name|hash
decl_stmt|;
for|for
control|(
name|uint32_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
comment|// If the distance is greater than the dictionary size,
comment|// we can simply mark the hash element as empty.
comment|//
comment|// NOTE: Only the first mf->hash_size_sum elements are
comment|// initialized for sure. There may be uninitialized elements
comment|// in mf->son. Since we go through both mf->hash and
comment|// mf->son here in normalization, Valgrind may complain
comment|// that the "if" below depends on uninitialized value. In
comment|// this case it is safe to ignore the warning. See also the
comment|// comments in lz_encoder_init() in lz_encoder.c.
if|if
condition|(
name|hash
index|[
name|i
index|]
operator|<=
name|subvalue
condition|)
name|hash
index|[
name|i
index|]
operator|=
name|EMPTY_HASH_VALUE
expr_stmt|;
else|else
name|hash
index|[
name|i
index|]
operator|-=
name|subvalue
expr_stmt|;
block|}
comment|// Update offset to match the new locations.
name|mf
operator|->
name|offset
operator|-=
name|subvalue
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/// Mark the current byte as processed from point of view of the match finder.
end_comment

begin_function
specifier|static
name|void
name|move_pos
parameter_list|(
name|lzma_mf
modifier|*
name|mf
parameter_list|)
block|{
if|if
condition|(
operator|++
name|mf
operator|->
name|cyclic_pos
operator|==
name|mf
operator|->
name|cyclic_size
condition|)
name|mf
operator|->
name|cyclic_pos
operator|=
literal|0
expr_stmt|;
operator|++
name|mf
operator|->
name|read_pos
expr_stmt|;
name|assert
argument_list|(
name|mf
operator|->
name|read_pos
operator|<=
name|mf
operator|->
name|write_pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|mf
operator|->
name|read_pos
operator|+
name|mf
operator|->
name|offset
operator|==
name|UINT32_MAX
argument_list|)
condition|)
name|normalize
argument_list|(
name|mf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// When flushing, we cannot run the match finder unless there is nice_len
end_comment

begin_comment
comment|/// bytes available in the dictionary. Instead, we skip running the match
end_comment

begin_comment
comment|/// finder (indicating that no match was found), and count how many bytes we
end_comment

begin_comment
comment|/// have ignored this way.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// When new data is given after the flushing was completed, the match finder
end_comment

begin_comment
comment|/// is restarted by rewinding mf->read_pos backwards by mf->pending. Then
end_comment

begin_comment
comment|/// the missed bytes are added to the hash using the match finder's skip
end_comment

begin_comment
comment|/// function (with small amount of input, it may start using mf->pending
end_comment

begin_comment
comment|/// again if flushing).
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Due to this rewinding, we don't touch cyclic_pos or test for
end_comment

begin_comment
comment|/// normalization. It will be done when the match finder's skip function
end_comment

begin_comment
comment|/// catches up after a flush.
end_comment

begin_function
specifier|static
name|void
name|move_pending
parameter_list|(
name|lzma_mf
modifier|*
name|mf
parameter_list|)
block|{
operator|++
name|mf
operator|->
name|read_pos
expr_stmt|;
name|assert
argument_list|(
name|mf
operator|->
name|read_pos
operator|<=
name|mf
operator|->
name|write_pos
argument_list|)
expr_stmt|;
operator|++
name|mf
operator|->
name|pending
expr_stmt|;
block|}
end_function

begin_comment
comment|/// Calculate len_limit and determine if there is enough input to run
end_comment

begin_comment
comment|/// the actual match finder code. Sets up "cur" and "pos". This macro
end_comment

begin_comment
comment|/// is used by all find functions and binary tree skip functions. Hash
end_comment

begin_comment
comment|/// chain skip function doesn't need len_limit so a simpler code is used
end_comment

begin_comment
comment|/// in them.
end_comment

begin_define
define|#
directive|define
name|header
parameter_list|(
name|is_bt
parameter_list|,
name|len_min
parameter_list|,
name|ret_op
parameter_list|)
define|\
value|uint32_t len_limit = mf_avail(mf); \ 	if (mf->nice_len<= len_limit) { \ 		len_limit = mf->nice_len; \ 	} else if (len_limit< (len_min) \ 			|| (is_bt&& mf->action == LZMA_SYNC_FLUSH)) { \ 		assert(mf->action != LZMA_RUN); \ 		move_pending(mf); \ 		ret_op; \ 	} \ 	const uint8_t *cur = mf_ptr(mf); \ 	const uint32_t pos = mf->read_pos + mf->offset
end_define

begin_comment
comment|/// Header for find functions. "return 0" indicates that zero matches
end_comment

begin_comment
comment|/// were found.
end_comment

begin_define
define|#
directive|define
name|header_find
parameter_list|(
name|is_bt
parameter_list|,
name|len_min
parameter_list|)
define|\
value|header(is_bt, len_min, return 0); \ 	uint32_t matches_count = 0
end_define

begin_comment
comment|/// Header for a loop in a skip function. "continue" tells to skip the rest
end_comment

begin_comment
comment|/// of the code in the loop.
end_comment

begin_define
define|#
directive|define
name|header_skip
parameter_list|(
name|is_bt
parameter_list|,
name|len_min
parameter_list|)
define|\
value|header(is_bt, len_min, continue)
end_define

begin_comment
comment|/// Calls hc_find_func() or bt_find_func() and calculates the total number
end_comment

begin_comment
comment|/// of matches found. Updates the dictionary position and returns the number
end_comment

begin_comment
comment|/// of matches found.
end_comment

begin_define
define|#
directive|define
name|call_find
parameter_list|(
name|func
parameter_list|,
name|len_best
parameter_list|)
define|\
value|do { \ 	matches_count = func(len_limit, pos, cur, cur_match, mf->depth, \ 				mf->son, mf->cyclic_pos, mf->cyclic_size, \ 				matches + matches_count, len_best) \ 			- matches; \ 	move_pos(mf); \ 	return matches_count; \ } while (0)
end_define

begin_comment
comment|////////////////
end_comment

begin_comment
comment|// Hash Chain //
end_comment

begin_comment
comment|////////////////
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MF_HC3
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_MF_HC4
argument_list|)
end_if

begin_comment
comment|///
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \param      len_limit       Don't look for matches longer than len_limit.
end_comment

begin_comment
comment|/// \param      pos             lzma_mf.read_pos + lzma_mf.offset
end_comment

begin_comment
comment|/// \param      cur             Pointer to current byte (mf_ptr(mf))
end_comment

begin_comment
comment|/// \param      cur_match       Start position of the current match candidate
end_comment

begin_comment
comment|/// \param      depth           Maximum length of the hash chain
end_comment

begin_comment
comment|/// \param      son             lzma_mf.son (contains the hash chain)
end_comment

begin_comment
comment|/// \param      cyclic_pos
end_comment

begin_comment
comment|/// \param      cyclic_size
end_comment

begin_comment
comment|/// \param      matches         Array to hold the matches.
end_comment

begin_comment
comment|/// \param      len_best        The length of the longest match found so far.
end_comment

begin_function
specifier|static
name|lzma_match
modifier|*
name|hc_find_func
parameter_list|(
specifier|const
name|uint32_t
name|len_limit
parameter_list|,
specifier|const
name|uint32_t
name|pos
parameter_list|,
specifier|const
name|uint8_t
modifier|*
specifier|const
name|cur
parameter_list|,
name|uint32_t
name|cur_match
parameter_list|,
name|uint32_t
name|depth
parameter_list|,
name|uint32_t
modifier|*
specifier|const
name|son
parameter_list|,
specifier|const
name|uint32_t
name|cyclic_pos
parameter_list|,
specifier|const
name|uint32_t
name|cyclic_size
parameter_list|,
name|lzma_match
modifier|*
name|matches
parameter_list|,
name|uint32_t
name|len_best
parameter_list|)
block|{
name|son
index|[
name|cyclic_pos
index|]
operator|=
name|cur_match
expr_stmt|;
while|while
condition|(
name|true
condition|)
block|{
specifier|const
name|uint32_t
name|delta
init|=
name|pos
operator|-
name|cur_match
decl_stmt|;
if|if
condition|(
name|depth
operator|--
operator|==
literal|0
operator|||
name|delta
operator|>=
name|cyclic_size
condition|)
return|return
name|matches
return|;
specifier|const
name|uint8_t
modifier|*
specifier|const
name|pb
init|=
name|cur
operator|-
name|delta
decl_stmt|;
name|cur_match
operator|=
name|son
index|[
name|cyclic_pos
operator|-
name|delta
operator|+
operator|(
name|delta
operator|>
name|cyclic_pos
condition|?
name|cyclic_size
else|:
literal|0
operator|)
index|]
expr_stmt|;
if|if
condition|(
name|pb
index|[
name|len_best
index|]
operator|==
name|cur
index|[
name|len_best
index|]
operator|&&
name|pb
index|[
literal|0
index|]
operator|==
name|cur
index|[
literal|0
index|]
condition|)
block|{
name|uint32_t
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|++
name|len
operator|!=
name|len_limit
condition|)
if|if
condition|(
name|pb
index|[
name|len
index|]
operator|!=
name|cur
index|[
name|len
index|]
condition|)
break|break;
if|if
condition|(
name|len_best
operator|<
name|len
condition|)
block|{
name|len_best
operator|=
name|len
expr_stmt|;
name|matches
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|matches
operator|->
name|dist
operator|=
name|delta
operator|-
literal|1
expr_stmt|;
operator|++
name|matches
expr_stmt|;
if|if
condition|(
name|len
operator|==
name|len_limit
condition|)
return|return
name|matches
return|;
block|}
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|hc_find
parameter_list|(
name|len_best
parameter_list|)
define|\
value|call_find(hc_find_func, len_best)
end_define

begin_define
define|#
directive|define
name|hc_skip
parameter_list|()
define|\
value|do { \ 	mf->son[mf->cyclic_pos] = cur_match; \ 	move_pos(mf); \ } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MF_HC3
end_ifdef

begin_function
specifier|extern
name|uint32_t
name|lzma_mf_hc3_find
parameter_list|(
name|lzma_mf
modifier|*
name|mf
parameter_list|,
name|lzma_match
modifier|*
name|matches
parameter_list|)
block|{
name|header_find
argument_list|(
name|false
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|hash_3_calc
argument_list|()
expr_stmt|;
specifier|const
name|uint32_t
name|delta2
init|=
name|pos
operator|-
name|mf
operator|->
name|hash
index|[
name|hash_2_value
index|]
decl_stmt|;
specifier|const
name|uint32_t
name|cur_match
init|=
name|mf
operator|->
name|hash
index|[
name|FIX_3_HASH_SIZE
operator|+
name|hash_value
index|]
decl_stmt|;
name|mf
operator|->
name|hash
index|[
name|hash_2_value
index|]
operator|=
name|pos
expr_stmt|;
name|mf
operator|->
name|hash
index|[
name|FIX_3_HASH_SIZE
operator|+
name|hash_value
index|]
operator|=
name|pos
expr_stmt|;
name|uint32_t
name|len_best
init|=
literal|2
decl_stmt|;
if|if
condition|(
name|delta2
operator|<
name|mf
operator|->
name|cyclic_size
operator|&&
operator|*
operator|(
name|cur
operator|-
name|delta2
operator|)
operator|==
operator|*
name|cur
condition|)
block|{
for|for
control|(
init|;
name|len_best
operator|!=
name|len_limit
condition|;
operator|++
name|len_best
control|)
if|if
condition|(
operator|*
operator|(
name|cur
operator|+
name|len_best
operator|-
name|delta2
operator|)
operator|!=
name|cur
index|[
name|len_best
index|]
condition|)
break|break;
name|matches
index|[
literal|0
index|]
operator|.
name|len
operator|=
name|len_best
expr_stmt|;
name|matches
index|[
literal|0
index|]
operator|.
name|dist
operator|=
name|delta2
operator|-
literal|1
expr_stmt|;
name|matches_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|len_best
operator|==
name|len_limit
condition|)
block|{
name|hc_skip
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
comment|// matches_count
block|}
block|}
name|hc_find
argument_list|(
name|len_best
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|extern
name|void
name|lzma_mf_hc3_skip
parameter_list|(
name|lzma_mf
modifier|*
name|mf
parameter_list|,
name|uint32_t
name|amount
parameter_list|)
block|{
do|do
block|{
if|if
condition|(
name|mf_avail
argument_list|(
name|mf
argument_list|)
operator|<
literal|3
condition|)
block|{
name|move_pending
argument_list|(
name|mf
argument_list|)
expr_stmt|;
continue|continue;
block|}
specifier|const
name|uint8_t
modifier|*
name|cur
init|=
name|mf_ptr
argument_list|(
name|mf
argument_list|)
decl_stmt|;
specifier|const
name|uint32_t
name|pos
init|=
name|mf
operator|->
name|read_pos
operator|+
name|mf
operator|->
name|offset
decl_stmt|;
name|hash_3_calc
argument_list|()
expr_stmt|;
specifier|const
name|uint32_t
name|cur_match
init|=
name|mf
operator|->
name|hash
index|[
name|FIX_3_HASH_SIZE
operator|+
name|hash_value
index|]
decl_stmt|;
name|mf
operator|->
name|hash
index|[
name|hash_2_value
index|]
operator|=
name|pos
expr_stmt|;
name|mf
operator|->
name|hash
index|[
name|FIX_3_HASH_SIZE
operator|+
name|hash_value
index|]
operator|=
name|pos
expr_stmt|;
name|hc_skip
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|amount
operator|!=
literal|0
condition|)
do|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MF_HC4
end_ifdef

begin_function
specifier|extern
name|uint32_t
name|lzma_mf_hc4_find
parameter_list|(
name|lzma_mf
modifier|*
name|mf
parameter_list|,
name|lzma_match
modifier|*
name|matches
parameter_list|)
block|{
name|header_find
argument_list|(
name|false
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|hash_4_calc
argument_list|()
expr_stmt|;
name|uint32_t
name|delta2
init|=
name|pos
operator|-
name|mf
operator|->
name|hash
index|[
name|hash_2_value
index|]
decl_stmt|;
specifier|const
name|uint32_t
name|delta3
init|=
name|pos
operator|-
name|mf
operator|->
name|hash
index|[
name|FIX_3_HASH_SIZE
operator|+
name|hash_3_value
index|]
decl_stmt|;
specifier|const
name|uint32_t
name|cur_match
init|=
name|mf
operator|->
name|hash
index|[
name|FIX_4_HASH_SIZE
operator|+
name|hash_value
index|]
decl_stmt|;
name|mf
operator|->
name|hash
index|[
name|hash_2_value
index|]
operator|=
name|pos
expr_stmt|;
name|mf
operator|->
name|hash
index|[
name|FIX_3_HASH_SIZE
operator|+
name|hash_3_value
index|]
operator|=
name|pos
expr_stmt|;
name|mf
operator|->
name|hash
index|[
name|FIX_4_HASH_SIZE
operator|+
name|hash_value
index|]
operator|=
name|pos
expr_stmt|;
name|uint32_t
name|len_best
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|delta2
operator|<
name|mf
operator|->
name|cyclic_size
operator|&&
operator|*
operator|(
name|cur
operator|-
name|delta2
operator|)
operator|==
operator|*
name|cur
condition|)
block|{
name|len_best
operator|=
literal|2
expr_stmt|;
name|matches
index|[
literal|0
index|]
operator|.
name|len
operator|=
literal|2
expr_stmt|;
name|matches
index|[
literal|0
index|]
operator|.
name|dist
operator|=
name|delta2
operator|-
literal|1
expr_stmt|;
name|matches_count
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|delta2
operator|!=
name|delta3
operator|&&
name|delta3
operator|<
name|mf
operator|->
name|cyclic_size
operator|&&
operator|*
operator|(
name|cur
operator|-
name|delta3
operator|)
operator|==
operator|*
name|cur
condition|)
block|{
name|len_best
operator|=
literal|3
expr_stmt|;
name|matches
index|[
name|matches_count
operator|++
index|]
operator|.
name|dist
operator|=
name|delta3
operator|-
literal|1
expr_stmt|;
name|delta2
operator|=
name|delta3
expr_stmt|;
block|}
if|if
condition|(
name|matches_count
operator|!=
literal|0
condition|)
block|{
for|for
control|(
init|;
name|len_best
operator|!=
name|len_limit
condition|;
operator|++
name|len_best
control|)
if|if
condition|(
operator|*
operator|(
name|cur
operator|+
name|len_best
operator|-
name|delta2
operator|)
operator|!=
name|cur
index|[
name|len_best
index|]
condition|)
break|break;
name|matches
index|[
name|matches_count
operator|-
literal|1
index|]
operator|.
name|len
operator|=
name|len_best
expr_stmt|;
if|if
condition|(
name|len_best
operator|==
name|len_limit
condition|)
block|{
name|hc_skip
argument_list|()
expr_stmt|;
return|return
name|matches_count
return|;
block|}
block|}
if|if
condition|(
name|len_best
operator|<
literal|3
condition|)
name|len_best
operator|=
literal|3
expr_stmt|;
name|hc_find
argument_list|(
name|len_best
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|extern
name|void
name|lzma_mf_hc4_skip
parameter_list|(
name|lzma_mf
modifier|*
name|mf
parameter_list|,
name|uint32_t
name|amount
parameter_list|)
block|{
do|do
block|{
if|if
condition|(
name|mf_avail
argument_list|(
name|mf
argument_list|)
operator|<
literal|4
condition|)
block|{
name|move_pending
argument_list|(
name|mf
argument_list|)
expr_stmt|;
continue|continue;
block|}
specifier|const
name|uint8_t
modifier|*
name|cur
init|=
name|mf_ptr
argument_list|(
name|mf
argument_list|)
decl_stmt|;
specifier|const
name|uint32_t
name|pos
init|=
name|mf
operator|->
name|read_pos
operator|+
name|mf
operator|->
name|offset
decl_stmt|;
name|hash_4_calc
argument_list|()
expr_stmt|;
specifier|const
name|uint32_t
name|cur_match
init|=
name|mf
operator|->
name|hash
index|[
name|FIX_4_HASH_SIZE
operator|+
name|hash_value
index|]
decl_stmt|;
name|mf
operator|->
name|hash
index|[
name|hash_2_value
index|]
operator|=
name|pos
expr_stmt|;
name|mf
operator|->
name|hash
index|[
name|FIX_3_HASH_SIZE
operator|+
name|hash_3_value
index|]
operator|=
name|pos
expr_stmt|;
name|mf
operator|->
name|hash
index|[
name|FIX_4_HASH_SIZE
operator|+
name|hash_value
index|]
operator|=
name|pos
expr_stmt|;
name|hc_skip
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|amount
operator|!=
literal|0
condition|)
do|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/////////////////
end_comment

begin_comment
comment|// Binary Tree //
end_comment

begin_comment
comment|/////////////////
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MF_BT2
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_MF_BT3
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_MF_BT4
argument_list|)
end_if

begin_function
specifier|static
name|lzma_match
modifier|*
name|bt_find_func
parameter_list|(
specifier|const
name|uint32_t
name|len_limit
parameter_list|,
specifier|const
name|uint32_t
name|pos
parameter_list|,
specifier|const
name|uint8_t
modifier|*
specifier|const
name|cur
parameter_list|,
name|uint32_t
name|cur_match
parameter_list|,
name|uint32_t
name|depth
parameter_list|,
name|uint32_t
modifier|*
specifier|const
name|son
parameter_list|,
specifier|const
name|uint32_t
name|cyclic_pos
parameter_list|,
specifier|const
name|uint32_t
name|cyclic_size
parameter_list|,
name|lzma_match
modifier|*
name|matches
parameter_list|,
name|uint32_t
name|len_best
parameter_list|)
block|{
name|uint32_t
modifier|*
name|ptr0
init|=
name|son
operator|+
operator|(
name|cyclic_pos
operator|<<
literal|1
operator|)
operator|+
literal|1
decl_stmt|;
name|uint32_t
modifier|*
name|ptr1
init|=
name|son
operator|+
operator|(
name|cyclic_pos
operator|<<
literal|1
operator|)
decl_stmt|;
name|uint32_t
name|len0
init|=
literal|0
decl_stmt|;
name|uint32_t
name|len1
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
specifier|const
name|uint32_t
name|delta
init|=
name|pos
operator|-
name|cur_match
decl_stmt|;
if|if
condition|(
name|depth
operator|--
operator|==
literal|0
operator|||
name|delta
operator|>=
name|cyclic_size
condition|)
block|{
operator|*
name|ptr0
operator|=
name|EMPTY_HASH_VALUE
expr_stmt|;
operator|*
name|ptr1
operator|=
name|EMPTY_HASH_VALUE
expr_stmt|;
return|return
name|matches
return|;
block|}
name|uint32_t
modifier|*
specifier|const
name|pair
init|=
name|son
operator|+
operator|(
operator|(
name|cyclic_pos
operator|-
name|delta
operator|+
operator|(
name|delta
operator|>
name|cyclic_pos
condition|?
name|cyclic_size
else|:
literal|0
operator|)
operator|)
operator|<<
literal|1
operator|)
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
specifier|const
name|pb
init|=
name|cur
operator|-
name|delta
decl_stmt|;
name|uint32_t
name|len
init|=
name|MIN
argument_list|(
name|len0
argument_list|,
name|len1
argument_list|)
decl_stmt|;
if|if
condition|(
name|pb
index|[
name|len
index|]
operator|==
name|cur
index|[
name|len
index|]
condition|)
block|{
while|while
condition|(
operator|++
name|len
operator|!=
name|len_limit
condition|)
if|if
condition|(
name|pb
index|[
name|len
index|]
operator|!=
name|cur
index|[
name|len
index|]
condition|)
break|break;
if|if
condition|(
name|len_best
operator|<
name|len
condition|)
block|{
name|len_best
operator|=
name|len
expr_stmt|;
name|matches
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|matches
operator|->
name|dist
operator|=
name|delta
operator|-
literal|1
expr_stmt|;
operator|++
name|matches
expr_stmt|;
if|if
condition|(
name|len
operator|==
name|len_limit
condition|)
block|{
operator|*
name|ptr1
operator|=
name|pair
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|ptr0
operator|=
name|pair
index|[
literal|1
index|]
expr_stmt|;
return|return
name|matches
return|;
block|}
block|}
block|}
if|if
condition|(
name|pb
index|[
name|len
index|]
operator|<
name|cur
index|[
name|len
index|]
condition|)
block|{
operator|*
name|ptr1
operator|=
name|cur_match
expr_stmt|;
name|ptr1
operator|=
name|pair
operator|+
literal|1
expr_stmt|;
name|cur_match
operator|=
operator|*
name|ptr1
expr_stmt|;
name|len1
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ptr0
operator|=
name|cur_match
expr_stmt|;
name|ptr0
operator|=
name|pair
expr_stmt|;
name|cur_match
operator|=
operator|*
name|ptr0
expr_stmt|;
name|len0
operator|=
name|len
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bt_skip_func
parameter_list|(
specifier|const
name|uint32_t
name|len_limit
parameter_list|,
specifier|const
name|uint32_t
name|pos
parameter_list|,
specifier|const
name|uint8_t
modifier|*
specifier|const
name|cur
parameter_list|,
name|uint32_t
name|cur_match
parameter_list|,
name|uint32_t
name|depth
parameter_list|,
name|uint32_t
modifier|*
specifier|const
name|son
parameter_list|,
specifier|const
name|uint32_t
name|cyclic_pos
parameter_list|,
specifier|const
name|uint32_t
name|cyclic_size
parameter_list|)
block|{
name|uint32_t
modifier|*
name|ptr0
init|=
name|son
operator|+
operator|(
name|cyclic_pos
operator|<<
literal|1
operator|)
operator|+
literal|1
decl_stmt|;
name|uint32_t
modifier|*
name|ptr1
init|=
name|son
operator|+
operator|(
name|cyclic_pos
operator|<<
literal|1
operator|)
decl_stmt|;
name|uint32_t
name|len0
init|=
literal|0
decl_stmt|;
name|uint32_t
name|len1
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
specifier|const
name|uint32_t
name|delta
init|=
name|pos
operator|-
name|cur_match
decl_stmt|;
if|if
condition|(
name|depth
operator|--
operator|==
literal|0
operator|||
name|delta
operator|>=
name|cyclic_size
condition|)
block|{
operator|*
name|ptr0
operator|=
name|EMPTY_HASH_VALUE
expr_stmt|;
operator|*
name|ptr1
operator|=
name|EMPTY_HASH_VALUE
expr_stmt|;
return|return;
block|}
name|uint32_t
modifier|*
name|pair
init|=
name|son
operator|+
operator|(
operator|(
name|cyclic_pos
operator|-
name|delta
operator|+
operator|(
name|delta
operator|>
name|cyclic_pos
condition|?
name|cyclic_size
else|:
literal|0
operator|)
operator|)
operator|<<
literal|1
operator|)
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|pb
init|=
name|cur
operator|-
name|delta
decl_stmt|;
name|uint32_t
name|len
init|=
name|MIN
argument_list|(
name|len0
argument_list|,
name|len1
argument_list|)
decl_stmt|;
if|if
condition|(
name|pb
index|[
name|len
index|]
operator|==
name|cur
index|[
name|len
index|]
condition|)
block|{
while|while
condition|(
operator|++
name|len
operator|!=
name|len_limit
condition|)
if|if
condition|(
name|pb
index|[
name|len
index|]
operator|!=
name|cur
index|[
name|len
index|]
condition|)
break|break;
if|if
condition|(
name|len
operator|==
name|len_limit
condition|)
block|{
operator|*
name|ptr1
operator|=
name|pair
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|ptr0
operator|=
name|pair
index|[
literal|1
index|]
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|pb
index|[
name|len
index|]
operator|<
name|cur
index|[
name|len
index|]
condition|)
block|{
operator|*
name|ptr1
operator|=
name|cur_match
expr_stmt|;
name|ptr1
operator|=
name|pair
operator|+
literal|1
expr_stmt|;
name|cur_match
operator|=
operator|*
name|ptr1
expr_stmt|;
name|len1
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ptr0
operator|=
name|cur_match
expr_stmt|;
name|ptr0
operator|=
name|pair
expr_stmt|;
name|cur_match
operator|=
operator|*
name|ptr0
expr_stmt|;
name|len0
operator|=
name|len
expr_stmt|;
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|bt_find
parameter_list|(
name|len_best
parameter_list|)
define|\
value|call_find(bt_find_func, len_best)
end_define

begin_define
define|#
directive|define
name|bt_skip
parameter_list|()
define|\
value|do { \ 	bt_skip_func(len_limit, pos, cur, cur_match, mf->depth, \ 			mf->son, mf->cyclic_pos, \ 			mf->cyclic_size); \ 	move_pos(mf); \ } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MF_BT2
end_ifdef

begin_function
specifier|extern
name|uint32_t
name|lzma_mf_bt2_find
parameter_list|(
name|lzma_mf
modifier|*
name|mf
parameter_list|,
name|lzma_match
modifier|*
name|matches
parameter_list|)
block|{
name|header_find
argument_list|(
name|true
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|hash_2_calc
argument_list|()
expr_stmt|;
specifier|const
name|uint32_t
name|cur_match
init|=
name|mf
operator|->
name|hash
index|[
name|hash_value
index|]
decl_stmt|;
name|mf
operator|->
name|hash
index|[
name|hash_value
index|]
operator|=
name|pos
expr_stmt|;
name|bt_find
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|extern
name|void
name|lzma_mf_bt2_skip
parameter_list|(
name|lzma_mf
modifier|*
name|mf
parameter_list|,
name|uint32_t
name|amount
parameter_list|)
block|{
do|do
block|{
name|header_skip
argument_list|(
name|true
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|hash_2_calc
argument_list|()
expr_stmt|;
specifier|const
name|uint32_t
name|cur_match
init|=
name|mf
operator|->
name|hash
index|[
name|hash_value
index|]
decl_stmt|;
name|mf
operator|->
name|hash
index|[
name|hash_value
index|]
operator|=
name|pos
expr_stmt|;
name|bt_skip
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|amount
operator|!=
literal|0
condition|)
do|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MF_BT3
end_ifdef

begin_function
specifier|extern
name|uint32_t
name|lzma_mf_bt3_find
parameter_list|(
name|lzma_mf
modifier|*
name|mf
parameter_list|,
name|lzma_match
modifier|*
name|matches
parameter_list|)
block|{
name|header_find
argument_list|(
name|true
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|hash_3_calc
argument_list|()
expr_stmt|;
specifier|const
name|uint32_t
name|delta2
init|=
name|pos
operator|-
name|mf
operator|->
name|hash
index|[
name|hash_2_value
index|]
decl_stmt|;
specifier|const
name|uint32_t
name|cur_match
init|=
name|mf
operator|->
name|hash
index|[
name|FIX_3_HASH_SIZE
operator|+
name|hash_value
index|]
decl_stmt|;
name|mf
operator|->
name|hash
index|[
name|hash_2_value
index|]
operator|=
name|pos
expr_stmt|;
name|mf
operator|->
name|hash
index|[
name|FIX_3_HASH_SIZE
operator|+
name|hash_value
index|]
operator|=
name|pos
expr_stmt|;
name|uint32_t
name|len_best
init|=
literal|2
decl_stmt|;
if|if
condition|(
name|delta2
operator|<
name|mf
operator|->
name|cyclic_size
operator|&&
operator|*
operator|(
name|cur
operator|-
name|delta2
operator|)
operator|==
operator|*
name|cur
condition|)
block|{
for|for
control|(
init|;
name|len_best
operator|!=
name|len_limit
condition|;
operator|++
name|len_best
control|)
if|if
condition|(
operator|*
operator|(
name|cur
operator|+
name|len_best
operator|-
name|delta2
operator|)
operator|!=
name|cur
index|[
name|len_best
index|]
condition|)
break|break;
name|matches
index|[
literal|0
index|]
operator|.
name|len
operator|=
name|len_best
expr_stmt|;
name|matches
index|[
literal|0
index|]
operator|.
name|dist
operator|=
name|delta2
operator|-
literal|1
expr_stmt|;
name|matches_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|len_best
operator|==
name|len_limit
condition|)
block|{
name|bt_skip
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
comment|// matches_count
block|}
block|}
name|bt_find
argument_list|(
name|len_best
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|extern
name|void
name|lzma_mf_bt3_skip
parameter_list|(
name|lzma_mf
modifier|*
name|mf
parameter_list|,
name|uint32_t
name|amount
parameter_list|)
block|{
do|do
block|{
name|header_skip
argument_list|(
name|true
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|hash_3_calc
argument_list|()
expr_stmt|;
specifier|const
name|uint32_t
name|cur_match
init|=
name|mf
operator|->
name|hash
index|[
name|FIX_3_HASH_SIZE
operator|+
name|hash_value
index|]
decl_stmt|;
name|mf
operator|->
name|hash
index|[
name|hash_2_value
index|]
operator|=
name|pos
expr_stmt|;
name|mf
operator|->
name|hash
index|[
name|FIX_3_HASH_SIZE
operator|+
name|hash_value
index|]
operator|=
name|pos
expr_stmt|;
name|bt_skip
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|amount
operator|!=
literal|0
condition|)
do|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MF_BT4
end_ifdef

begin_function
specifier|extern
name|uint32_t
name|lzma_mf_bt4_find
parameter_list|(
name|lzma_mf
modifier|*
name|mf
parameter_list|,
name|lzma_match
modifier|*
name|matches
parameter_list|)
block|{
name|header_find
argument_list|(
name|true
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|hash_4_calc
argument_list|()
expr_stmt|;
name|uint32_t
name|delta2
init|=
name|pos
operator|-
name|mf
operator|->
name|hash
index|[
name|hash_2_value
index|]
decl_stmt|;
specifier|const
name|uint32_t
name|delta3
init|=
name|pos
operator|-
name|mf
operator|->
name|hash
index|[
name|FIX_3_HASH_SIZE
operator|+
name|hash_3_value
index|]
decl_stmt|;
specifier|const
name|uint32_t
name|cur_match
init|=
name|mf
operator|->
name|hash
index|[
name|FIX_4_HASH_SIZE
operator|+
name|hash_value
index|]
decl_stmt|;
name|mf
operator|->
name|hash
index|[
name|hash_2_value
index|]
operator|=
name|pos
expr_stmt|;
name|mf
operator|->
name|hash
index|[
name|FIX_3_HASH_SIZE
operator|+
name|hash_3_value
index|]
operator|=
name|pos
expr_stmt|;
name|mf
operator|->
name|hash
index|[
name|FIX_4_HASH_SIZE
operator|+
name|hash_value
index|]
operator|=
name|pos
expr_stmt|;
name|uint32_t
name|len_best
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|delta2
operator|<
name|mf
operator|->
name|cyclic_size
operator|&&
operator|*
operator|(
name|cur
operator|-
name|delta2
operator|)
operator|==
operator|*
name|cur
condition|)
block|{
name|len_best
operator|=
literal|2
expr_stmt|;
name|matches
index|[
literal|0
index|]
operator|.
name|len
operator|=
literal|2
expr_stmt|;
name|matches
index|[
literal|0
index|]
operator|.
name|dist
operator|=
name|delta2
operator|-
literal|1
expr_stmt|;
name|matches_count
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|delta2
operator|!=
name|delta3
operator|&&
name|delta3
operator|<
name|mf
operator|->
name|cyclic_size
operator|&&
operator|*
operator|(
name|cur
operator|-
name|delta3
operator|)
operator|==
operator|*
name|cur
condition|)
block|{
name|len_best
operator|=
literal|3
expr_stmt|;
name|matches
index|[
name|matches_count
operator|++
index|]
operator|.
name|dist
operator|=
name|delta3
operator|-
literal|1
expr_stmt|;
name|delta2
operator|=
name|delta3
expr_stmt|;
block|}
if|if
condition|(
name|matches_count
operator|!=
literal|0
condition|)
block|{
for|for
control|(
init|;
name|len_best
operator|!=
name|len_limit
condition|;
operator|++
name|len_best
control|)
if|if
condition|(
operator|*
operator|(
name|cur
operator|+
name|len_best
operator|-
name|delta2
operator|)
operator|!=
name|cur
index|[
name|len_best
index|]
condition|)
break|break;
name|matches
index|[
name|matches_count
operator|-
literal|1
index|]
operator|.
name|len
operator|=
name|len_best
expr_stmt|;
if|if
condition|(
name|len_best
operator|==
name|len_limit
condition|)
block|{
name|bt_skip
argument_list|()
expr_stmt|;
return|return
name|matches_count
return|;
block|}
block|}
if|if
condition|(
name|len_best
operator|<
literal|3
condition|)
name|len_best
operator|=
literal|3
expr_stmt|;
name|bt_find
argument_list|(
name|len_best
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|extern
name|void
name|lzma_mf_bt4_skip
parameter_list|(
name|lzma_mf
modifier|*
name|mf
parameter_list|,
name|uint32_t
name|amount
parameter_list|)
block|{
do|do
block|{
name|header_skip
argument_list|(
name|true
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|hash_4_calc
argument_list|()
expr_stmt|;
specifier|const
name|uint32_t
name|cur_match
init|=
name|mf
operator|->
name|hash
index|[
name|FIX_4_HASH_SIZE
operator|+
name|hash_value
index|]
decl_stmt|;
name|mf
operator|->
name|hash
index|[
name|hash_2_value
index|]
operator|=
name|pos
expr_stmt|;
name|mf
operator|->
name|hash
index|[
name|FIX_3_HASH_SIZE
operator|+
name|hash_3_value
index|]
operator|=
name|pos
expr_stmt|;
name|mf
operator|->
name|hash
index|[
name|FIX_4_HASH_SIZE
operator|+
name|hash_value
index|]
operator|=
name|pos
expr_stmt|;
name|bt_skip
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|amount
operator|!=
literal|0
condition|)
do|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

