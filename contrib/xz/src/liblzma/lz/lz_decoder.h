begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       lz_decoder.h
end_comment

begin_comment
comment|/// \brief      LZ out window
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//  Authors:    Igor Pavlov
end_comment

begin_comment
comment|//              Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LZMA_LZ_DECODER_H
end_ifndef

begin_define
define|#
directive|define
name|LZMA_LZ_DECODER_H
end_define

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/// Pointer to the dictionary buffer. It can be an allocated buffer
comment|/// internal to liblzma, or it can a be a buffer given by the
comment|/// application when in single-call mode (not implemented yet).
name|uint8_t
modifier|*
name|buf
decl_stmt|;
comment|/// Write position in dictionary. The next byte will be written to
comment|/// buf[pos].
name|size_t
name|pos
decl_stmt|;
comment|/// Indicates how full the dictionary is. This is used by
comment|/// dict_is_distance_valid() to detect corrupt files that would
comment|/// read beyond the beginning of the dictionary.
name|size_t
name|full
decl_stmt|;
comment|/// Write limit
name|size_t
name|limit
decl_stmt|;
comment|/// Size of the dictionary
name|size_t
name|size
decl_stmt|;
comment|/// True when dictionary should be reset before decoding more data.
name|bool
name|need_reset
decl_stmt|;
block|}
name|lzma_dict
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|size_t
name|dict_size
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|preset_dict
decl_stmt|;
name|size_t
name|preset_dict_size
decl_stmt|;
block|}
name|lzma_lz_options
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/// Data specific to the LZ-based decoder
name|lzma_coder
modifier|*
name|coder
decl_stmt|;
comment|/// Function to decode from in[] to *dict
name|lzma_ret
function_decl|(
modifier|*
name|code
function_decl|)
parameter_list|(
name|lzma_coder
modifier|*
specifier|restrict
name|coder
parameter_list|,
name|lzma_dict
modifier|*
specifier|restrict
name|dict
parameter_list|,
specifier|const
name|uint8_t
modifier|*
specifier|restrict
name|in
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|in_pos
parameter_list|,
name|size_t
name|in_size
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|reset
function_decl|)
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
specifier|const
name|void
modifier|*
name|options
parameter_list|)
function_decl|;
comment|/// Set the uncompressed size
name|void
function_decl|(
modifier|*
name|set_uncompressed
function_decl|)
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|lzma_vli
name|uncompressed_size
parameter_list|)
function_decl|;
comment|/// Free allocated resources
name|void
function_decl|(
modifier|*
name|end
function_decl|)
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|)
function_decl|;
block|}
name|lzma_lz_decoder
typedef|;
end_typedef

begin_define
define|#
directive|define
name|LZMA_LZ_DECODER_INIT
define|\
value|(lzma_lz_decoder){ \ 		.coder = NULL, \ 		.code = NULL, \ 		.reset = NULL, \ 		.set_uncompressed = NULL, \ 		.end = NULL, \ 	}
end_define

begin_function_decl
specifier|extern
name|lzma_ret
name|lzma_lz_decoder_init
parameter_list|(
name|lzma_next_coder
modifier|*
name|next
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|lzma_filter_info
modifier|*
name|filters
parameter_list|,
name|lzma_ret
function_decl|(
modifier|*
name|lz_init
function_decl|)
parameter_list|(
name|lzma_lz_decoder
modifier|*
name|lz
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|void
modifier|*
name|options
parameter_list|,
name|lzma_lz_options
modifier|*
name|lz_options
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|uint64_t
name|lzma_lz_decoder_memusage
parameter_list|(
name|size_t
name|dictionary_size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lzma_lz_decoder_uncompressed
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|lzma_vli
name|uncompressed_size
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|//////////////////////
end_comment

begin_comment
comment|// Inline functions //
end_comment

begin_comment
comment|//////////////////////
end_comment

begin_comment
comment|/// Get a byte from the history buffer.
end_comment

begin_function
specifier|static
specifier|inline
name|uint8_t
name|dict_get
parameter_list|(
specifier|const
name|lzma_dict
modifier|*
specifier|const
name|dict
parameter_list|,
specifier|const
name|uint32_t
name|distance
parameter_list|)
block|{
return|return
name|dict
operator|->
name|buf
index|[
name|dict
operator|->
name|pos
operator|-
name|distance
operator|-
literal|1
operator|+
operator|(
name|distance
operator|<
name|dict
operator|->
name|pos
condition|?
literal|0
else|:
name|dict
operator|->
name|size
operator|)
index|]
return|;
block|}
end_function

begin_comment
comment|/// Test if dictionary is empty.
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|dict_is_empty
parameter_list|(
specifier|const
name|lzma_dict
modifier|*
specifier|const
name|dict
parameter_list|)
block|{
return|return
name|dict
operator|->
name|full
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/// Validate the match distance
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|dict_is_distance_valid
parameter_list|(
specifier|const
name|lzma_dict
modifier|*
specifier|const
name|dict
parameter_list|,
specifier|const
name|size_t
name|distance
parameter_list|)
block|{
return|return
name|dict
operator|->
name|full
operator|>
name|distance
return|;
block|}
end_function

begin_comment
comment|/// Repeat *len bytes at distance.
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|dict_repeat
parameter_list|(
name|lzma_dict
modifier|*
name|dict
parameter_list|,
name|uint32_t
name|distance
parameter_list|,
name|uint32_t
modifier|*
name|len
parameter_list|)
block|{
comment|// Don't write past the end of the dictionary.
specifier|const
name|size_t
name|dict_avail
init|=
name|dict
operator|->
name|limit
operator|-
name|dict
operator|->
name|pos
decl_stmt|;
name|uint32_t
name|left
init|=
name|MIN
argument_list|(
name|dict_avail
argument_list|,
operator|*
name|len
argument_list|)
decl_stmt|;
operator|*
name|len
operator|-=
name|left
expr_stmt|;
comment|// Repeat a block of data from the history. Because memcpy() is faster
comment|// than copying byte by byte in a loop, the copying process gets split
comment|// into three cases.
if|if
condition|(
name|distance
operator|<
name|left
condition|)
block|{
comment|// Source and target areas overlap, thus we can't use
comment|// memcpy() nor even memmove() safely.
do|do
block|{
name|dict
operator|->
name|buf
index|[
name|dict
operator|->
name|pos
index|]
operator|=
name|dict_get
argument_list|(
name|dict
argument_list|,
name|distance
argument_list|)
expr_stmt|;
operator|++
name|dict
operator|->
name|pos
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|left
operator|>
literal|0
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|distance
operator|<
name|dict
operator|->
name|pos
condition|)
block|{
comment|// The easiest and fastest case
name|memcpy
argument_list|(
name|dict
operator|->
name|buf
operator|+
name|dict
operator|->
name|pos
argument_list|,
name|dict
operator|->
name|buf
operator|+
name|dict
operator|->
name|pos
operator|-
name|distance
operator|-
literal|1
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|dict
operator|->
name|pos
operator|+=
name|left
expr_stmt|;
block|}
else|else
block|{
comment|// The bigger the dictionary, the more rare this
comment|// case occurs. We need to "wrap" the dict, thus
comment|// we might need two memcpy() to copy all the data.
name|assert
argument_list|(
name|dict
operator|->
name|full
operator|==
name|dict
operator|->
name|size
argument_list|)
expr_stmt|;
specifier|const
name|uint32_t
name|copy_pos
init|=
name|dict
operator|->
name|pos
operator|-
name|distance
operator|-
literal|1
operator|+
name|dict
operator|->
name|size
decl_stmt|;
name|uint32_t
name|copy_size
init|=
name|dict
operator|->
name|size
operator|-
name|copy_pos
decl_stmt|;
if|if
condition|(
name|copy_size
operator|<
name|left
condition|)
block|{
name|memmove
argument_list|(
name|dict
operator|->
name|buf
operator|+
name|dict
operator|->
name|pos
argument_list|,
name|dict
operator|->
name|buf
operator|+
name|copy_pos
argument_list|,
name|copy_size
argument_list|)
expr_stmt|;
name|dict
operator|->
name|pos
operator|+=
name|copy_size
expr_stmt|;
name|copy_size
operator|=
name|left
operator|-
name|copy_size
expr_stmt|;
name|memcpy
argument_list|(
name|dict
operator|->
name|buf
operator|+
name|dict
operator|->
name|pos
argument_list|,
name|dict
operator|->
name|buf
argument_list|,
name|copy_size
argument_list|)
expr_stmt|;
name|dict
operator|->
name|pos
operator|+=
name|copy_size
expr_stmt|;
block|}
else|else
block|{
name|memmove
argument_list|(
name|dict
operator|->
name|buf
operator|+
name|dict
operator|->
name|pos
argument_list|,
name|dict
operator|->
name|buf
operator|+
name|copy_pos
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|dict
operator|->
name|pos
operator|+=
name|left
expr_stmt|;
block|}
block|}
comment|// Update how full the dictionary is.
if|if
condition|(
name|dict
operator|->
name|full
operator|<
name|dict
operator|->
name|pos
condition|)
name|dict
operator|->
name|full
operator|=
name|dict
operator|->
name|pos
expr_stmt|;
return|return
name|unlikely
argument_list|(
operator|*
name|len
operator|!=
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/// Puts one byte into the dictionary. Returns true if the dictionary was
end_comment

begin_comment
comment|/// already full and the byte couldn't be added.
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|dict_put
parameter_list|(
name|lzma_dict
modifier|*
name|dict
parameter_list|,
name|uint8_t
name|byte
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|dict
operator|->
name|pos
operator|==
name|dict
operator|->
name|limit
argument_list|)
condition|)
return|return
name|true
return|;
name|dict
operator|->
name|buf
index|[
name|dict
operator|->
name|pos
operator|++
index|]
operator|=
name|byte
expr_stmt|;
if|if
condition|(
name|dict
operator|->
name|pos
operator|>
name|dict
operator|->
name|full
condition|)
name|dict
operator|->
name|full
operator|=
name|dict
operator|->
name|pos
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/// Copies arbitrary amount of data into the dictionary.
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|dict_write
parameter_list|(
name|lzma_dict
modifier|*
specifier|restrict
name|dict
parameter_list|,
specifier|const
name|uint8_t
modifier|*
specifier|restrict
name|in
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|in_pos
parameter_list|,
name|size_t
name|in_size
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|left
parameter_list|)
block|{
comment|// NOTE: If we are being given more data than the size of the
comment|// dictionary, it could be possible to optimize the LZ decoder
comment|// so that not everything needs to go through the dictionary.
comment|// This shouldn't be very common thing in practice though, and
comment|// the slowdown of one extra memcpy() isn't bad compared to how
comment|// much time it would have taken if the data were compressed.
if|if
condition|(
name|in_size
operator|-
operator|*
name|in_pos
operator|>
operator|*
name|left
condition|)
name|in_size
operator|=
operator|*
name|in_pos
operator|+
operator|*
name|left
expr_stmt|;
operator|*
name|left
operator|-=
name|lzma_bufcpy
argument_list|(
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|,
name|dict
operator|->
name|buf
argument_list|,
operator|&
name|dict
operator|->
name|pos
argument_list|,
name|dict
operator|->
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|dict
operator|->
name|pos
operator|>
name|dict
operator|->
name|full
condition|)
name|dict
operator|->
name|full
operator|=
name|dict
operator|->
name|pos
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|dict_reset
parameter_list|(
name|lzma_dict
modifier|*
name|dict
parameter_list|)
block|{
name|dict
operator|->
name|need_reset
operator|=
name|true
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

