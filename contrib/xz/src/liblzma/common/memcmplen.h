begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       memcmplen.h
end_comment

begin_comment
comment|/// \brief      Optimized comparison of two buffers
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Author:     Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LZMA_MEMCMPLEN_H
end_ifndef

begin_define
define|#
directive|define
name|LZMA_MEMCMPLEN_H
end_define

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_IMMINTRIN_H
end_ifdef

begin_include
include|#
directive|include
file|<immintrin.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/// How many extra bytes lzma_memcmplen() may read. This depends on
end_comment

begin_comment
comment|/// the method but since it is just a few bytes the biggest possible
end_comment

begin_comment
comment|/// value is used here.
end_comment

begin_define
define|#
directive|define
name|LZMA_MEMCMPLEN_EXTRA
value|16
end_define

begin_comment
comment|/// Find out how many equal bytes the two buffers have.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \param      buf1    First buffer
end_comment

begin_comment
comment|/// \param      buf2    Second buffer
end_comment

begin_comment
comment|/// \param      len     How many bytes have already been compared and will
end_comment

begin_comment
comment|///                     be assumed to match
end_comment

begin_comment
comment|/// \param      limit   How many bytes to compare at most, including the
end_comment

begin_comment
comment|///                     already-compared bytes. This must be significantly
end_comment

begin_comment
comment|///                     smaller than UINT32_MAX to avoid integer overflows.
end_comment

begin_comment
comment|///                     Up to LZMA_MEMCMPLEN_EXTRA bytes may be read past
end_comment

begin_comment
comment|///                     the specified limit from both buf1 and buf2.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \return     Number of equal bytes in the buffers is returned.
end_comment

begin_comment
comment|///             This is always at least len and at most limit.
end_comment

begin_decl_stmt
specifier|static
specifier|inline
name|uint32_t
name|lzma_attribute
argument_list|(
operator|(
name|__always_inline__
operator|)
argument_list|)
name|lzma_memcmplen
argument_list|(
specifier|const
name|uint8_t
operator|*
name|buf1
argument_list|,
specifier|const
name|uint8_t
operator|*
name|buf2
argument_list|,
name|uint32_t
name|len
argument_list|,
name|uint32_t
name|limit
argument_list|)
block|{
name|assert
argument_list|(
name|len
operator|<=
name|limit
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|limit
operator|<=
name|UINT32_MAX
operator|/
literal|2
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TUKLIB_FAST_UNALIGNED_ACCESS
argument_list|)
expr|\
operator|&&
operator|(
operator|(
name|TUKLIB_GNUC_REQ
argument_list|(
literal|3
operator|,
literal|4
argument_list|)
operator|&&
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|)
expr|\
operator|||
operator|(
name|defined
argument_list|(
name|__INTEL_COMPILER
argument_list|)
operator|&&
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|)
expr|\
operator|||
operator|(
name|defined
argument_list|(
name|__INTEL_COMPILER
argument_list|)
operator|&&
name|defined
argument_list|(
name|_M_X64
argument_list|)
operator|)
expr|\
operator|||
operator|(
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|defined
argument_list|(
name|_M_X64
argument_list|)
operator|)
operator|)
comment|// NOTE: This will use 64-bit unaligned access which
comment|// TUKLIB_FAST_UNALIGNED_ACCESS wasn't meant to permit, but
comment|// it's convenient here at least as long as it's x86-64 only.
comment|//
comment|// I keep this x86-64 only for now since that's where I know this
comment|// to be a good method. This may be fine on other 64-bit CPUs too.
comment|// On big endian one should use xor instead of subtraction and switch
comment|// to __builtin_clzll().
while|while
condition|(
name|len
operator|<
name|limit
condition|)
block|{
specifier|const
name|uint64_t
name|x
init|=
operator|*
operator|(
specifier|const
name|uint64_t
operator|*
operator|)
operator|(
name|buf1
operator|+
name|len
operator|)
operator|-
operator|*
operator|(
specifier|const
name|uint64_t
operator|*
operator|)
operator|(
name|buf2
operator|+
name|len
operator|)
decl_stmt|;
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_M_X64
argument_list|)
comment|// MSVC or Intel C compiler on Windows
name|unsigned
name|long
name|tmp
decl_stmt|;
name|_BitScanForward64
argument_list|(
operator|&
name|tmp
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|len
operator|+=
operator|(
name|uint32_t
operator|)
name|tmp
operator|>>
literal|3
expr_stmt|;
else|#
directive|else
comment|// GCC, clang, or Intel C compiler
name|len
operator|+=
operator|(
name|uint32_t
operator|)
name|__builtin_ctzll
argument_list|(
name|x
argument_list|)
operator|>>
literal|3
expr_stmt|;
endif|#
directive|endif
return|return
name|my_min
argument_list|(
name|len
argument_list|,
name|limit
argument_list|)
return|;
block|}
name|len
operator|+=
literal|8
expr_stmt|;
block|}
return|return
name|limit
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|TUKLIB_FAST_UNALIGNED_ACCESS
argument_list|)
expr|\
operator|&&
name|defined
argument_list|(
name|HAVE__MM_MOVEMASK_EPI8
argument_list|)
expr|\
operator|&&
operator|(
operator|(
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__SSE2_MATH__
argument_list|)
operator|)
expr|\
operator|||
operator|(
name|defined
argument_list|(
name|__INTEL_COMPILER
argument_list|)
operator|&&
name|defined
argument_list|(
name|__SSE2__
argument_list|)
operator|)
expr|\
operator|||
operator|(
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|defined
argument_list|(
name|_M_IX86_FP
argument_list|)
expr|\
operator|&&
name|_M_IX86_FP
operator|>=
literal|2
operator|)
operator|)
comment|// NOTE: Like above, this will use 128-bit unaligned access which
comment|// TUKLIB_FAST_UNALIGNED_ACCESS wasn't meant to permit.
comment|//
comment|// SSE2 version for 32-bit and 64-bit x86. On x86-64 the above
comment|// version is sometimes significantly faster and sometimes
comment|// slightly slower than this SSE2 version, so this SSE2
comment|// version isn't used on x86-64.
while|while
condition|(
name|len
operator|<
name|limit
condition|)
block|{
specifier|const
name|uint32_t
name|x
init|=
literal|0xFFFF
operator|^
name|_mm_movemask_epi8
argument_list|(
name|_mm_cmpeq_epi8
argument_list|(
name|_mm_loadu_si128
argument_list|(
operator|(
specifier|const
name|__m128i
operator|*
operator|)
operator|(
name|buf1
operator|+
name|len
operator|)
argument_list|)
argument_list|,
name|_mm_loadu_si128
argument_list|(
operator|(
specifier|const
name|__m128i
operator|*
operator|)
operator|(
name|buf2
operator|+
name|len
operator|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__INTEL_COMPILER
argument_list|)
name|len
operator|+=
name|_bit_scan_forward
argument_list|(
name|x
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
name|unsigned
name|long
name|tmp
decl_stmt|;
name|_BitScanForward
argument_list|(
operator|&
name|tmp
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|len
operator|+=
name|tmp
expr_stmt|;
else|#
directive|else
name|len
operator|+=
name|__builtin_ctz
argument_list|(
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|my_min
argument_list|(
name|len
argument_list|,
name|limit
argument_list|)
return|;
block|}
name|len
operator|+=
literal|16
expr_stmt|;
block|}
return|return
name|limit
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|TUKLIB_FAST_UNALIGNED_ACCESS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WORDS_BIGENDIAN
argument_list|)
comment|// Generic 32-bit little endian method
while|while
condition|(
name|len
operator|<
name|limit
condition|)
block|{
name|uint32_t
name|x
init|=
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
operator|(
name|buf1
operator|+
name|len
operator|)
operator|-
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
operator|(
name|buf2
operator|+
name|len
operator|)
decl_stmt|;
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|x
operator|&
literal|0xFFFF
operator|)
operator|==
literal|0
condition|)
block|{
name|len
operator|+=
literal|2
expr_stmt|;
name|x
operator|>>=
literal|16
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|x
operator|&
literal|0xFF
operator|)
operator|==
literal|0
condition|)
operator|++
name|len
expr_stmt|;
return|return
name|my_min
argument_list|(
name|len
argument_list|,
name|limit
argument_list|)
return|;
block|}
name|len
operator|+=
literal|4
expr_stmt|;
block|}
return|return
name|limit
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|TUKLIB_FAST_UNALIGNED_ACCESS
argument_list|)
operator|&&
name|defined
argument_list|(
name|WORDS_BIGENDIAN
argument_list|)
comment|// Generic 32-bit big endian method
while|while
condition|(
name|len
operator|<
name|limit
condition|)
block|{
name|uint32_t
name|x
init|=
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
operator|(
name|buf1
operator|+
name|len
operator|)
operator|^
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
operator|(
name|buf2
operator|+
name|len
operator|)
decl_stmt|;
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|x
operator|&
literal|0xFFFF0000
operator|)
operator|==
literal|0
condition|)
block|{
name|len
operator|+=
literal|2
expr_stmt|;
name|x
operator|<<=
literal|16
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|x
operator|&
literal|0xFF000000
operator|)
operator|==
literal|0
condition|)
operator|++
name|len
expr_stmt|;
return|return
name|my_min
argument_list|(
name|len
argument_list|,
name|limit
argument_list|)
return|;
block|}
name|len
operator|+=
literal|4
expr_stmt|;
block|}
return|return
name|limit
return|;
else|#
directive|else
comment|// Simple portable version that doesn't use unaligned access.
while|while
condition|(
name|len
operator|<
name|limit
operator|&&
name|buf1
index|[
name|len
index|]
operator|==
name|buf2
index|[
name|len
index|]
condition|)
operator|++
name|len
expr_stmt|;
return|return
name|len
return|;
endif|#
directive|endif
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

