begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       index.c
end_comment

begin_comment
comment|/// \brief      Handling of .xz Indexes and some other Stream information
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Author:     Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"index.h"
end_include

begin_include
include|#
directive|include
file|"stream_flags_common.h"
end_include

begin_comment
comment|/// \brief      How many Records to allocate at once
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This should be big enough to avoid making lots of tiny allocations
end_comment

begin_comment
comment|/// but small enough to avoid too much unused memory at once.
end_comment

begin_define
define|#
directive|define
name|INDEX_GROUP_SIZE
value|512
end_define

begin_comment
comment|/// \brief      How many Records can be allocated at once at maximum
end_comment

begin_define
define|#
directive|define
name|PREALLOC_MAX
value|((SIZE_MAX - sizeof(index_group)) / sizeof(index_record))
end_define

begin_comment
comment|/// \brief      Base structure for index_stream and index_group structures
end_comment

begin_typedef
typedef|typedef
name|struct
name|index_tree_node_s
name|index_tree_node
typedef|;
end_typedef

begin_struct
struct|struct
name|index_tree_node_s
block|{
comment|/// Uncompressed start offset of this Stream (relative to the
comment|/// beginning of the file) or Block (relative to the beginning
comment|/// of the Stream)
name|lzma_vli
name|uncompressed_base
decl_stmt|;
comment|/// Compressed start offset of this Stream or Block
name|lzma_vli
name|compressed_base
decl_stmt|;
name|index_tree_node
modifier|*
name|parent
decl_stmt|;
name|index_tree_node
modifier|*
name|left
decl_stmt|;
name|index_tree_node
modifier|*
name|right
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/// \brief      AVL tree to hold index_stream or index_group structures
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/// Root node
name|index_tree_node
modifier|*
name|root
decl_stmt|;
comment|/// Leftmost node. Since the tree will be filled sequentially,
comment|/// this won't change after the first node has been added to
comment|/// the tree.
name|index_tree_node
modifier|*
name|leftmost
decl_stmt|;
comment|/// The rightmost node in the tree. Since the tree is filled
comment|/// sequentially, this is always the node where to add the new data.
name|index_tree_node
modifier|*
name|rightmost
decl_stmt|;
comment|/// Number of nodes in the tree
name|uint32_t
name|count
decl_stmt|;
block|}
name|index_tree
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|lzma_vli
name|uncompressed_sum
decl_stmt|;
name|lzma_vli
name|unpadded_sum
decl_stmt|;
block|}
name|index_record
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/// Every Record group is part of index_stream.groups tree.
name|index_tree_node
name|node
decl_stmt|;
comment|/// Number of Blocks in this Stream before this group.
name|lzma_vli
name|number_base
decl_stmt|;
comment|/// Number of Records that can be put in records[].
name|size_t
name|allocated
decl_stmt|;
comment|/// Index of the last Record in use.
name|size_t
name|last
decl_stmt|;
comment|/// The sizes in this array are stored as cumulative sums relative
comment|/// to the beginning of the Stream. This makes it possible to
comment|/// use binary search in lzma_index_locate().
comment|///
comment|/// Note that the cumulative summing is done specially for
comment|/// unpadded_sum: The previous value is rounded up to the next
comment|/// multiple of four before adding the Unpadded Size of the new
comment|/// Block. The total encoded size of the Blocks in the Stream
comment|/// is records[last].unpadded_sum in the last Record group of
comment|/// the Stream.
comment|///
comment|/// For example, if the Unpadded Sizes are 39, 57, and 81, the
comment|/// stored values are 39, 97 (40 + 57), and 181 (100 + 181).
comment|/// The total encoded size of these Blocks is 184.
comment|///
comment|/// This is a flexible array, because it makes easy to optimize
comment|/// memory usage in case someone concatenates many Streams that
comment|/// have only one or few Blocks.
name|index_record
name|records
index|[]
decl_stmt|;
block|}
name|index_group
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/// Every index_stream is a node in the tree of Sreams.
name|index_tree_node
name|node
decl_stmt|;
comment|/// Number of this Stream (first one is 1)
name|uint32_t
name|number
decl_stmt|;
comment|/// Total number of Blocks before this Stream
name|lzma_vli
name|block_number_base
decl_stmt|;
comment|/// Record groups of this Stream are stored in a tree.
comment|/// It's a T-tree with AVL-tree balancing. There are
comment|/// INDEX_GROUP_SIZE Records per node by default.
comment|/// This keeps the number of memory allocations reasonable
comment|/// and finding a Record is fast.
name|index_tree
name|groups
decl_stmt|;
comment|/// Number of Records in this Stream
name|lzma_vli
name|record_count
decl_stmt|;
comment|/// Size of the List of Records field in this Stream. This is used
comment|/// together with record_count to calculate the size of the Index
comment|/// field and thus the total size of the Stream.
name|lzma_vli
name|index_list_size
decl_stmt|;
comment|/// Stream Flags of this Stream. This is meaningful only if
comment|/// the Stream Flags have been told us with lzma_index_stream_flags().
comment|/// Initially stream_flags.version is set to UINT32_MAX to indicate
comment|/// that the Stream Flags are unknown.
name|lzma_stream_flags
name|stream_flags
decl_stmt|;
comment|/// Amount of Stream Padding after this Stream. This defaults to
comment|/// zero and can be set with lzma_index_stream_padding().
name|lzma_vli
name|stream_padding
decl_stmt|;
block|}
name|index_stream
typedef|;
end_typedef

begin_struct
struct|struct
name|lzma_index_s
block|{
comment|/// AVL-tree containing the Stream(s). Often there is just one
comment|/// Stream, but using a tree keeps lookups fast even when there
comment|/// are many concatenated Streams.
name|index_tree
name|streams
decl_stmt|;
comment|/// Uncompressed size of all the Blocks in the Stream(s)
name|lzma_vli
name|uncompressed_size
decl_stmt|;
comment|/// Total size of all the Blocks in the Stream(s)
name|lzma_vli
name|total_size
decl_stmt|;
comment|/// Total number of Records in all Streams in this lzma_index
name|lzma_vli
name|record_count
decl_stmt|;
comment|/// Size of the List of Records field if all the Streams in this
comment|/// lzma_index were packed into a single Stream (makes it simpler to
comment|/// take many .xz files and combine them into a single Stream).
comment|///
comment|/// This value together with record_count is needed to calculate
comment|/// Backward Size that is stored into Stream Footer.
name|lzma_vli
name|index_list_size
decl_stmt|;
comment|/// How many Records to allocate at once in lzma_index_append().
comment|/// This defaults to INDEX_GROUP_SIZE but can be overriden with
comment|/// lzma_index_prealloc().
name|size_t
name|prealloc
decl_stmt|;
comment|/// Bitmask indicating what integrity check types have been used
comment|/// as set by lzma_index_stream_flags(). The bit of the last Stream
comment|/// is not included here, since it is possible to change it by
comment|/// calling lzma_index_stream_flags() again.
name|uint32_t
name|checks
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|index_tree_init
parameter_list|(
name|index_tree
modifier|*
name|tree
parameter_list|)
block|{
name|tree
operator|->
name|root
operator|=
name|NULL
expr_stmt|;
name|tree
operator|->
name|leftmost
operator|=
name|NULL
expr_stmt|;
name|tree
operator|->
name|rightmost
operator|=
name|NULL
expr_stmt|;
name|tree
operator|->
name|count
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/// Helper for index_tree_end()
end_comment

begin_function
specifier|static
name|void
name|index_tree_node_end
parameter_list|(
name|index_tree_node
modifier|*
name|node
parameter_list|,
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
name|void
function_decl|(
modifier|*
name|free_func
function_decl|)
parameter_list|(
name|void
modifier|*
name|node
parameter_list|,
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|)
parameter_list|)
block|{
comment|// The tree won't ever be very huge, so recursion should be fine.
comment|// 20 levels in the tree is likely quite a lot already in practice.
if|if
condition|(
name|node
operator|->
name|left
operator|!=
name|NULL
condition|)
name|index_tree_node_end
argument_list|(
name|node
operator|->
name|left
argument_list|,
name|allocator
argument_list|,
name|free_func
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|right
operator|!=
name|NULL
condition|)
name|index_tree_node_end
argument_list|(
name|node
operator|->
name|right
argument_list|,
name|allocator
argument_list|,
name|free_func
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_func
operator|!=
name|NULL
condition|)
name|free_func
argument_list|(
name|node
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|lzma_free
argument_list|(
name|node
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/// Free the meory allocated for a tree. If free_func is not NULL,
end_comment

begin_comment
comment|/// it is called on each node before freeing the node. This is used
end_comment

begin_comment
comment|/// to free the Record groups from each index_stream before freeing
end_comment

begin_comment
comment|/// the index_stream itself.
end_comment

begin_function
specifier|static
name|void
name|index_tree_end
parameter_list|(
name|index_tree
modifier|*
name|tree
parameter_list|,
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
name|void
function_decl|(
modifier|*
name|free_func
function_decl|)
parameter_list|(
name|void
modifier|*
name|node
parameter_list|,
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|)
parameter_list|)
block|{
if|if
condition|(
name|tree
operator|->
name|root
operator|!=
name|NULL
condition|)
name|index_tree_node_end
argument_list|(
name|tree
operator|->
name|root
argument_list|,
name|allocator
argument_list|,
name|free_func
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/// Add a new node to the tree. node->uncompressed_base and
end_comment

begin_comment
comment|/// node->compressed_base must have been set by the caller already.
end_comment

begin_function
specifier|static
name|void
name|index_tree_append
parameter_list|(
name|index_tree
modifier|*
name|tree
parameter_list|,
name|index_tree_node
modifier|*
name|node
parameter_list|)
block|{
name|node
operator|->
name|parent
operator|=
name|tree
operator|->
name|rightmost
expr_stmt|;
name|node
operator|->
name|left
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|right
operator|=
name|NULL
expr_stmt|;
operator|++
name|tree
operator|->
name|count
expr_stmt|;
comment|// Handle the special case of adding the first node.
if|if
condition|(
name|tree
operator|->
name|root
operator|==
name|NULL
condition|)
block|{
name|tree
operator|->
name|root
operator|=
name|node
expr_stmt|;
name|tree
operator|->
name|leftmost
operator|=
name|node
expr_stmt|;
name|tree
operator|->
name|rightmost
operator|=
name|node
expr_stmt|;
return|return;
block|}
comment|// The tree is always filled sequentially.
name|assert
argument_list|(
name|tree
operator|->
name|rightmost
operator|->
name|uncompressed_base
operator|<=
name|node
operator|->
name|uncompressed_base
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tree
operator|->
name|rightmost
operator|->
name|compressed_base
operator|<
name|node
operator|->
name|compressed_base
argument_list|)
expr_stmt|;
comment|// Add the new node after the rightmost node. It's the correct
comment|// place due to the reason above.
name|tree
operator|->
name|rightmost
operator|->
name|right
operator|=
name|node
expr_stmt|;
name|tree
operator|->
name|rightmost
operator|=
name|node
expr_stmt|;
comment|// Balance the AVL-tree if needed. We don't need to keep the balance
comment|// factors in nodes, because we always fill the tree sequentially,
comment|// and thus know the state of the tree just by looking at the node
comment|// count. From the node count we can calculate how many steps to go
comment|// up in the tree to find the rotation root.
name|uint32_t
name|up
init|=
name|tree
operator|->
name|count
operator|^
operator|(
name|UINT32_C
argument_list|(
literal|1
argument_list|)
operator|<<
name|bsr32
argument_list|(
name|tree
operator|->
name|count
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|up
operator|!=
literal|0
condition|)
block|{
comment|// Locate the root node for the rotation.
name|up
operator|=
name|ctz32
argument_list|(
name|tree
operator|->
name|count
argument_list|)
operator|+
literal|2
expr_stmt|;
do|do
block|{
name|node
operator|=
name|node
operator|->
name|parent
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|up
operator|>
literal|0
condition|)
do|;
comment|// Rotate left using node as the rotation root.
name|index_tree_node
modifier|*
name|pivot
init|=
name|node
operator|->
name|right
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|parent
operator|==
name|NULL
condition|)
block|{
name|tree
operator|->
name|root
operator|=
name|pivot
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|node
operator|->
name|parent
operator|->
name|right
operator|==
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|parent
operator|->
name|right
operator|=
name|pivot
expr_stmt|;
block|}
name|pivot
operator|->
name|parent
operator|=
name|node
operator|->
name|parent
expr_stmt|;
name|node
operator|->
name|right
operator|=
name|pivot
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|right
operator|!=
name|NULL
condition|)
name|node
operator|->
name|right
operator|->
name|parent
operator|=
name|node
expr_stmt|;
name|pivot
operator|->
name|left
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|parent
operator|=
name|pivot
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/// Get the next node in the tree. Return NULL if there are no more nodes.
end_comment

begin_function
specifier|static
name|void
modifier|*
name|index_tree_next
parameter_list|(
specifier|const
name|index_tree_node
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|right
operator|!=
name|NULL
condition|)
block|{
name|node
operator|=
name|node
operator|->
name|right
expr_stmt|;
while|while
condition|(
name|node
operator|->
name|left
operator|!=
name|NULL
condition|)
name|node
operator|=
name|node
operator|->
name|left
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
operator|(
name|node
operator|)
return|;
block|}
while|while
condition|(
name|node
operator|->
name|parent
operator|!=
name|NULL
operator|&&
name|node
operator|->
name|parent
operator|->
name|right
operator|==
name|node
condition|)
name|node
operator|=
name|node
operator|->
name|parent
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
operator|(
name|node
operator|->
name|parent
operator|)
return|;
block|}
end_function

begin_comment
comment|/// Locate a node that contains the given uncompressed offset. It is
end_comment

begin_comment
comment|/// caller's job to check that target is not bigger than the uncompressed
end_comment

begin_comment
comment|/// size of the tree (the last node would be returned in that case still).
end_comment

begin_function
specifier|static
name|void
modifier|*
name|index_tree_locate
parameter_list|(
specifier|const
name|index_tree
modifier|*
name|tree
parameter_list|,
name|lzma_vli
name|target
parameter_list|)
block|{
specifier|const
name|index_tree_node
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
specifier|const
name|index_tree_node
modifier|*
name|node
init|=
name|tree
operator|->
name|root
decl_stmt|;
name|assert
argument_list|(
name|tree
operator|->
name|leftmost
operator|==
name|NULL
operator|||
name|tree
operator|->
name|leftmost
operator|->
name|uncompressed_base
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// Consecutive nodes may have the same uncompressed_base.
comment|// We must pick the rightmost one.
while|while
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|uncompressed_base
operator|>
name|target
condition|)
block|{
name|node
operator|=
name|node
operator|->
name|left
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|node
expr_stmt|;
name|node
operator|=
name|node
operator|->
name|right
expr_stmt|;
block|}
block|}
return|return
operator|(
name|void
operator|*
operator|)
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/// Allocate and initialize a new Stream using the given base offsets.
end_comment

begin_function
specifier|static
name|index_stream
modifier|*
name|index_stream_init
parameter_list|(
name|lzma_vli
name|compressed_base
parameter_list|,
name|lzma_vli
name|uncompressed_base
parameter_list|,
name|lzma_vli
name|stream_number
parameter_list|,
name|lzma_vli
name|block_number_base
parameter_list|,
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|)
block|{
name|index_stream
modifier|*
name|s
init|=
name|lzma_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|index_stream
argument_list|)
argument_list|,
name|allocator
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|s
operator|->
name|node
operator|.
name|uncompressed_base
operator|=
name|uncompressed_base
expr_stmt|;
name|s
operator|->
name|node
operator|.
name|compressed_base
operator|=
name|compressed_base
expr_stmt|;
name|s
operator|->
name|node
operator|.
name|parent
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|node
operator|.
name|left
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|node
operator|.
name|right
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|number
operator|=
name|stream_number
expr_stmt|;
name|s
operator|->
name|block_number_base
operator|=
name|block_number_base
expr_stmt|;
name|index_tree_init
argument_list|(
operator|&
name|s
operator|->
name|groups
argument_list|)
expr_stmt|;
name|s
operator|->
name|record_count
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|index_list_size
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|stream_flags
operator|.
name|version
operator|=
name|UINT32_MAX
expr_stmt|;
name|s
operator|->
name|stream_padding
operator|=
literal|0
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/// Free the memory allocated for a Stream and its Record groups.
end_comment

begin_function
specifier|static
name|void
name|index_stream_end
parameter_list|(
name|void
modifier|*
name|node
parameter_list|,
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|)
block|{
name|index_stream
modifier|*
name|s
init|=
name|node
decl_stmt|;
name|index_tree_end
argument_list|(
operator|&
name|s
operator|->
name|groups
argument_list|,
name|allocator
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|lzma_index
modifier|*
name|index_init_plain
parameter_list|(
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|)
block|{
name|lzma_index
modifier|*
name|i
init|=
name|lzma_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lzma_index
argument_list|)
argument_list|,
name|allocator
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|NULL
condition|)
block|{
name|index_tree_init
argument_list|(
operator|&
name|i
operator|->
name|streams
argument_list|)
expr_stmt|;
name|i
operator|->
name|uncompressed_size
operator|=
literal|0
expr_stmt|;
name|i
operator|->
name|total_size
operator|=
literal|0
expr_stmt|;
name|i
operator|->
name|record_count
operator|=
literal|0
expr_stmt|;
name|i
operator|->
name|index_list_size
operator|=
literal|0
expr_stmt|;
name|i
operator|->
name|prealloc
operator|=
name|INDEX_GROUP_SIZE
expr_stmt|;
name|i
operator|->
name|checks
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_extern
extern|extern LZMA_API(lzma_index *
end_extern

begin_macro
unit|)
name|lzma_index_init
argument_list|(
argument|const lzma_allocator *allocator
argument_list|)
end_macro

begin_block
block|{
name|lzma_index
modifier|*
name|i
init|=
name|index_init_plain
argument_list|(
name|allocator
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|index_stream
modifier|*
name|s
init|=
name|index_stream_init
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|allocator
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|lzma_free
argument_list|(
name|i
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|index_tree_append
argument_list|(
operator|&
name|i
operator|->
name|streams
argument_list|,
operator|&
name|s
operator|->
name|node
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_block

begin_extern
extern|extern LZMA_API(void
end_extern

begin_macro
unit|)
name|lzma_index_end
argument_list|(
argument|lzma_index *i
argument_list|,
argument|const lzma_allocator *allocator
argument_list|)
end_macro

begin_block
block|{
comment|// NOTE: If you modify this function, check also the bottom
comment|// of lzma_index_cat().
if|if
condition|(
name|i
operator|!=
name|NULL
condition|)
block|{
name|index_tree_end
argument_list|(
operator|&
name|i
operator|->
name|streams
argument_list|,
name|allocator
argument_list|,
operator|&
name|index_stream_end
argument_list|)
expr_stmt|;
name|lzma_free
argument_list|(
name|i
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_function
specifier|extern
name|void
name|lzma_index_prealloc
parameter_list|(
name|lzma_index
modifier|*
name|i
parameter_list|,
name|lzma_vli
name|records
parameter_list|)
block|{
if|if
condition|(
name|records
operator|>
name|PREALLOC_MAX
condition|)
name|records
operator|=
name|PREALLOC_MAX
expr_stmt|;
name|i
operator|->
name|prealloc
operator|=
call|(
name|size_t
call|)
argument_list|(
name|records
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_extern
extern|extern LZMA_API(uint64_t
end_extern

begin_macro
unit|)
name|lzma_index_memusage
argument_list|(
argument|lzma_vli streams
argument_list|,
argument|lzma_vli blocks
argument_list|)
end_macro

begin_block
block|{
comment|// This calculates an upper bound that is only a little bit
comment|// bigger than the exact maximum memory usage with the given
comment|// parameters.
comment|// Typical malloc() overhead is 2 * sizeof(void *) but we take
comment|// a little bit extra just in case. Using LZMA_MEMUSAGE_BASE
comment|// instead would give too inaccurate estimate.
specifier|const
name|size_t
name|alloc_overhead
init|=
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
decl_stmt|;
comment|// Amount of memory needed for each Stream base structures.
comment|// We assume that every Stream has at least one Block and
comment|// thus at least one group.
specifier|const
name|size_t
name|stream_base
init|=
sizeof|sizeof
argument_list|(
name|index_stream
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|index_group
argument_list|)
operator|+
literal|2
operator|*
name|alloc_overhead
decl_stmt|;
comment|// Amount of memory needed per group.
specifier|const
name|size_t
name|group_base
init|=
sizeof|sizeof
argument_list|(
name|index_group
argument_list|)
operator|+
name|INDEX_GROUP_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|index_record
argument_list|)
operator|+
name|alloc_overhead
decl_stmt|;
comment|// Number of groups. There may actually be more, but that overhead
comment|// has been taken into account in stream_base already.
specifier|const
name|lzma_vli
name|groups
init|=
operator|(
name|blocks
operator|+
name|INDEX_GROUP_SIZE
operator|-
literal|1
operator|)
operator|/
name|INDEX_GROUP_SIZE
decl_stmt|;
comment|// Memory used by index_stream and index_group structures.
specifier|const
name|uint64_t
name|streams_mem
init|=
name|streams
operator|*
name|stream_base
decl_stmt|;
specifier|const
name|uint64_t
name|groups_mem
init|=
name|groups
operator|*
name|group_base
decl_stmt|;
comment|// Memory used by the base structure.
specifier|const
name|uint64_t
name|index_base
init|=
sizeof|sizeof
argument_list|(
name|lzma_index
argument_list|)
operator|+
name|alloc_overhead
decl_stmt|;
comment|// Validate the arguments and catch integer overflows.
comment|// Maximum number of Streams is "only" UINT32_MAX, because
comment|// that limit is used by the tree containing the Streams.
specifier|const
name|uint64_t
name|limit
init|=
name|UINT64_MAX
operator|-
name|index_base
decl_stmt|;
if|if
condition|(
name|streams
operator|==
literal|0
operator|||
name|streams
operator|>
name|UINT32_MAX
operator|||
name|blocks
operator|>
name|LZMA_VLI_MAX
operator|||
name|streams
operator|>
name|limit
operator|/
name|stream_base
operator|||
name|groups
operator|>
name|limit
operator|/
name|group_base
operator|||
name|limit
operator|-
name|streams_mem
operator|<
name|groups_mem
condition|)
return|return
name|UINT64_MAX
return|;
return|return
name|index_base
operator|+
name|streams_mem
operator|+
name|groups_mem
return|;
block|}
end_block

begin_extern
extern|extern LZMA_API(uint64_t
end_extern

begin_macro
unit|)
name|lzma_index_memused
argument_list|(
argument|const lzma_index *i
argument_list|)
end_macro

begin_block
block|{
return|return
name|lzma_index_memusage
argument_list|(
name|i
operator|->
name|streams
operator|.
name|count
argument_list|,
name|i
operator|->
name|record_count
argument_list|)
return|;
block|}
end_block

begin_extern
extern|extern LZMA_API(lzma_vli
end_extern

begin_macro
unit|)
name|lzma_index_block_count
argument_list|(
argument|const lzma_index *i
argument_list|)
end_macro

begin_block
block|{
return|return
name|i
operator|->
name|record_count
return|;
block|}
end_block

begin_extern
extern|extern LZMA_API(lzma_vli
end_extern

begin_macro
unit|)
name|lzma_index_stream_count
argument_list|(
argument|const lzma_index *i
argument_list|)
end_macro

begin_block
block|{
return|return
name|i
operator|->
name|streams
operator|.
name|count
return|;
block|}
end_block

begin_extern
extern|extern LZMA_API(lzma_vli
end_extern

begin_macro
unit|)
name|lzma_index_size
argument_list|(
argument|const lzma_index *i
argument_list|)
end_macro

begin_block
block|{
return|return
name|index_size
argument_list|(
name|i
operator|->
name|record_count
argument_list|,
name|i
operator|->
name|index_list_size
argument_list|)
return|;
block|}
end_block

begin_extern
extern|extern LZMA_API(lzma_vli
end_extern

begin_macro
unit|)
name|lzma_index_total_size
argument_list|(
argument|const lzma_index *i
argument_list|)
end_macro

begin_block
block|{
return|return
name|i
operator|->
name|total_size
return|;
block|}
end_block

begin_extern
extern|extern LZMA_API(lzma_vli
end_extern

begin_macro
unit|)
name|lzma_index_stream_size
argument_list|(
argument|const lzma_index *i
argument_list|)
end_macro

begin_block
block|{
comment|// Stream Header + Blocks + Index + Stream Footer
return|return
name|LZMA_STREAM_HEADER_SIZE
operator|+
name|i
operator|->
name|total_size
operator|+
name|index_size
argument_list|(
name|i
operator|->
name|record_count
argument_list|,
name|i
operator|->
name|index_list_size
argument_list|)
operator|+
name|LZMA_STREAM_HEADER_SIZE
return|;
block|}
end_block

begin_function
specifier|static
name|lzma_vli
name|index_file_size
parameter_list|(
name|lzma_vli
name|compressed_base
parameter_list|,
name|lzma_vli
name|unpadded_sum
parameter_list|,
name|lzma_vli
name|record_count
parameter_list|,
name|lzma_vli
name|index_list_size
parameter_list|,
name|lzma_vli
name|stream_padding
parameter_list|)
block|{
comment|// Earlier Streams and Stream Paddings + Stream Header
comment|// + Blocks + Index + Stream Footer + Stream Padding
comment|//
comment|// This might go over LZMA_VLI_MAX due to too big unpadded_sum
comment|// when this function is used in lzma_index_append().
name|lzma_vli
name|file_size
init|=
name|compressed_base
operator|+
literal|2
operator|*
name|LZMA_STREAM_HEADER_SIZE
operator|+
name|stream_padding
operator|+
name|vli_ceil4
argument_list|(
name|unpadded_sum
argument_list|)
decl_stmt|;
if|if
condition|(
name|file_size
operator|>
name|LZMA_VLI_MAX
condition|)
return|return
name|LZMA_VLI_UNKNOWN
return|;
comment|// The same applies here.
name|file_size
operator|+=
name|index_size
argument_list|(
name|record_count
argument_list|,
name|index_list_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_size
operator|>
name|LZMA_VLI_MAX
condition|)
return|return
name|LZMA_VLI_UNKNOWN
return|;
return|return
name|file_size
return|;
block|}
end_function

begin_extern
extern|extern LZMA_API(lzma_vli
end_extern

begin_macro
unit|)
name|lzma_index_file_size
argument_list|(
argument|const lzma_index *i
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|index_stream
modifier|*
name|s
init|=
operator|(
specifier|const
name|index_stream
operator|*
operator|)
operator|(
name|i
operator|->
name|streams
operator|.
name|rightmost
operator|)
decl_stmt|;
specifier|const
name|index_group
modifier|*
name|g
init|=
operator|(
specifier|const
name|index_group
operator|*
operator|)
operator|(
name|s
operator|->
name|groups
operator|.
name|rightmost
operator|)
decl_stmt|;
return|return
name|index_file_size
argument_list|(
name|s
operator|->
name|node
operator|.
name|compressed_base
argument_list|,
name|g
operator|==
name|NULL
condition|?
literal|0
else|:
name|g
operator|->
name|records
index|[
name|g
operator|->
name|last
index|]
operator|.
name|unpadded_sum
argument_list|,
name|s
operator|->
name|record_count
argument_list|,
name|s
operator|->
name|index_list_size
argument_list|,
name|s
operator|->
name|stream_padding
argument_list|)
return|;
block|}
end_block

begin_extern
extern|extern LZMA_API(lzma_vli
end_extern

begin_macro
unit|)
name|lzma_index_uncompressed_size
argument_list|(
argument|const lzma_index *i
argument_list|)
end_macro

begin_block
block|{
return|return
name|i
operator|->
name|uncompressed_size
return|;
block|}
end_block

begin_extern
extern|extern LZMA_API(uint32_t
end_extern

begin_macro
unit|)
name|lzma_index_checks
argument_list|(
argument|const lzma_index *i
argument_list|)
end_macro

begin_block
block|{
name|uint32_t
name|checks
init|=
name|i
operator|->
name|checks
decl_stmt|;
comment|// Get the type of the Check of the last Stream too.
specifier|const
name|index_stream
modifier|*
name|s
init|=
operator|(
specifier|const
name|index_stream
operator|*
operator|)
operator|(
name|i
operator|->
name|streams
operator|.
name|rightmost
operator|)
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|stream_flags
operator|.
name|version
operator|!=
name|UINT32_MAX
condition|)
name|checks
operator||=
name|UINT32_C
argument_list|(
literal|1
argument_list|)
operator|<<
name|s
operator|->
name|stream_flags
operator|.
name|check
expr_stmt|;
return|return
name|checks
return|;
block|}
end_block

begin_function
specifier|extern
name|uint32_t
name|lzma_index_padding_size
parameter_list|(
specifier|const
name|lzma_index
modifier|*
name|i
parameter_list|)
block|{
return|return
operator|(
name|LZMA_VLI_C
argument_list|(
literal|4
argument_list|)
operator|-
name|index_size_unpadded
argument_list|(
name|i
operator|->
name|record_count
argument_list|,
name|i
operator|->
name|index_list_size
argument_list|)
operator|)
operator|&
literal|3
return|;
block|}
end_function

begin_extern
extern|extern LZMA_API(lzma_ret
end_extern

begin_macro
unit|)
name|lzma_index_stream_flags
argument_list|(
argument|lzma_index *i
argument_list|,
argument|const lzma_stream_flags *stream_flags
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|i
operator|==
name|NULL
operator|||
name|stream_flags
operator|==
name|NULL
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
comment|// Validate the Stream Flags.
name|return_if_error
argument_list|(
name|lzma_stream_flags_compare
argument_list|(
name|stream_flags
argument_list|,
name|stream_flags
argument_list|)
argument_list|)
expr_stmt|;
name|index_stream
modifier|*
name|s
init|=
operator|(
name|index_stream
operator|*
operator|)
operator|(
name|i
operator|->
name|streams
operator|.
name|rightmost
operator|)
decl_stmt|;
name|s
operator|->
name|stream_flags
operator|=
operator|*
name|stream_flags
expr_stmt|;
return|return
name|LZMA_OK
return|;
block|}
end_block

begin_extern
extern|extern LZMA_API(lzma_ret
end_extern

begin_macro
unit|)
name|lzma_index_stream_padding
argument_list|(
argument|lzma_index *i
argument_list|,
argument|lzma_vli stream_padding
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|i
operator|==
name|NULL
operator|||
name|stream_padding
operator|>
name|LZMA_VLI_MAX
operator|||
operator|(
name|stream_padding
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
name|index_stream
modifier|*
name|s
init|=
operator|(
name|index_stream
operator|*
operator|)
operator|(
name|i
operator|->
name|streams
operator|.
name|rightmost
operator|)
decl_stmt|;
comment|// Check that the new value won't make the file grow too big.
specifier|const
name|lzma_vli
name|old_stream_padding
init|=
name|s
operator|->
name|stream_padding
decl_stmt|;
name|s
operator|->
name|stream_padding
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lzma_index_file_size
argument_list|(
name|i
argument_list|)
operator|+
name|stream_padding
operator|>
name|LZMA_VLI_MAX
condition|)
block|{
name|s
operator|->
name|stream_padding
operator|=
name|old_stream_padding
expr_stmt|;
return|return
name|LZMA_DATA_ERROR
return|;
block|}
name|s
operator|->
name|stream_padding
operator|=
name|stream_padding
expr_stmt|;
return|return
name|LZMA_OK
return|;
block|}
end_block

begin_extern
extern|extern LZMA_API(lzma_ret
end_extern

begin_macro
unit|)
name|lzma_index_append
argument_list|(
argument|lzma_index *i
argument_list|,
argument|const lzma_allocator *allocator
argument_list|,
argument|lzma_vli unpadded_size
argument_list|,
argument|lzma_vli uncompressed_size
argument_list|)
end_macro

begin_block
block|{
comment|// Validate.
if|if
condition|(
name|i
operator|==
name|NULL
operator|||
name|unpadded_size
operator|<
name|UNPADDED_SIZE_MIN
operator|||
name|unpadded_size
operator|>
name|UNPADDED_SIZE_MAX
operator|||
name|uncompressed_size
operator|>
name|LZMA_VLI_MAX
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
name|index_stream
modifier|*
name|s
init|=
operator|(
name|index_stream
operator|*
operator|)
operator|(
name|i
operator|->
name|streams
operator|.
name|rightmost
operator|)
decl_stmt|;
name|index_group
modifier|*
name|g
init|=
operator|(
name|index_group
operator|*
operator|)
operator|(
name|s
operator|->
name|groups
operator|.
name|rightmost
operator|)
decl_stmt|;
specifier|const
name|lzma_vli
name|compressed_base
init|=
name|g
operator|==
name|NULL
condition|?
literal|0
else|:
name|vli_ceil4
argument_list|(
name|g
operator|->
name|records
index|[
name|g
operator|->
name|last
index|]
operator|.
name|unpadded_sum
argument_list|)
decl_stmt|;
specifier|const
name|lzma_vli
name|uncompressed_base
init|=
name|g
operator|==
name|NULL
condition|?
literal|0
else|:
name|g
operator|->
name|records
index|[
name|g
operator|->
name|last
index|]
operator|.
name|uncompressed_sum
decl_stmt|;
specifier|const
name|uint32_t
name|index_list_size_add
init|=
name|lzma_vli_size
argument_list|(
name|unpadded_size
argument_list|)
operator|+
name|lzma_vli_size
argument_list|(
name|uncompressed_size
argument_list|)
decl_stmt|;
comment|// Check that the file size will stay within limits.
if|if
condition|(
name|index_file_size
argument_list|(
name|s
operator|->
name|node
operator|.
name|compressed_base
argument_list|,
name|compressed_base
operator|+
name|unpadded_size
argument_list|,
name|s
operator|->
name|record_count
operator|+
literal|1
argument_list|,
name|s
operator|->
name|index_list_size
operator|+
name|index_list_size_add
argument_list|,
name|s
operator|->
name|stream_padding
argument_list|)
operator|==
name|LZMA_VLI_UNKNOWN
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
comment|// The size of the Index field must not exceed the maximum value
comment|// that can be stored in the Backward Size field.
if|if
condition|(
name|index_size
argument_list|(
name|i
operator|->
name|record_count
operator|+
literal|1
argument_list|,
name|i
operator|->
name|index_list_size
operator|+
name|index_list_size_add
argument_list|)
operator|>
name|LZMA_BACKWARD_SIZE_MAX
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
if|if
condition|(
name|g
operator|!=
name|NULL
operator|&&
name|g
operator|->
name|last
operator|+
literal|1
operator|<
name|g
operator|->
name|allocated
condition|)
block|{
comment|// There is space in the last group at least for one Record.
operator|++
name|g
operator|->
name|last
expr_stmt|;
block|}
else|else
block|{
comment|// We need to allocate a new group.
name|g
operator|=
name|lzma_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|index_group
argument_list|)
operator|+
name|i
operator|->
name|prealloc
operator|*
sizeof|sizeof
argument_list|(
name|index_record
argument_list|)
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
return|return
name|LZMA_MEM_ERROR
return|;
name|g
operator|->
name|last
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|allocated
operator|=
name|i
operator|->
name|prealloc
expr_stmt|;
comment|// Reset prealloc so that if the application happens to
comment|// add new Records, the allocation size will be sane.
name|i
operator|->
name|prealloc
operator|=
name|INDEX_GROUP_SIZE
expr_stmt|;
comment|// Set the start offsets of this group.
name|g
operator|->
name|node
operator|.
name|uncompressed_base
operator|=
name|uncompressed_base
expr_stmt|;
name|g
operator|->
name|node
operator|.
name|compressed_base
operator|=
name|compressed_base
expr_stmt|;
name|g
operator|->
name|number_base
operator|=
name|s
operator|->
name|record_count
operator|+
literal|1
expr_stmt|;
comment|// Add the new group to the Stream.
name|index_tree_append
argument_list|(
operator|&
name|s
operator|->
name|groups
argument_list|,
operator|&
name|g
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
comment|// Add the new Record to the group.
name|g
operator|->
name|records
index|[
name|g
operator|->
name|last
index|]
operator|.
name|uncompressed_sum
operator|=
name|uncompressed_base
operator|+
name|uncompressed_size
expr_stmt|;
name|g
operator|->
name|records
index|[
name|g
operator|->
name|last
index|]
operator|.
name|unpadded_sum
operator|=
name|compressed_base
operator|+
name|unpadded_size
expr_stmt|;
comment|// Update the totals.
operator|++
name|s
operator|->
name|record_count
expr_stmt|;
name|s
operator|->
name|index_list_size
operator|+=
name|index_list_size_add
expr_stmt|;
name|i
operator|->
name|total_size
operator|+=
name|vli_ceil4
argument_list|(
name|unpadded_size
argument_list|)
expr_stmt|;
name|i
operator|->
name|uncompressed_size
operator|+=
name|uncompressed_size
expr_stmt|;
operator|++
name|i
operator|->
name|record_count
expr_stmt|;
name|i
operator|->
name|index_list_size
operator|+=
name|index_list_size_add
expr_stmt|;
return|return
name|LZMA_OK
return|;
block|}
end_block

begin_comment
comment|/// Structure to pass info to index_cat_helper()
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/// Uncompressed size of the destination
name|lzma_vli
name|uncompressed_size
decl_stmt|;
comment|/// Compressed file size of the destination
name|lzma_vli
name|file_size
decl_stmt|;
comment|/// Same as above but for Block numbers
name|lzma_vli
name|block_number_add
decl_stmt|;
comment|/// Number of Streams that were in the destination index before we
comment|/// started appending new Streams from the source index. This is
comment|/// used to fix the Stream numbering.
name|uint32_t
name|stream_number_add
decl_stmt|;
comment|/// Destination index' Stream tree
name|index_tree
modifier|*
name|streams
decl_stmt|;
block|}
name|index_cat_info
typedef|;
end_typedef

begin_comment
comment|/// Add the Stream nodes from the source index to dest using recursion.
end_comment

begin_comment
comment|/// Simplest iterative traversal of the source tree wouldn't work, because
end_comment

begin_comment
comment|/// we update the pointers in nodes when moving them to the destination tree.
end_comment

begin_function
specifier|static
name|void
name|index_cat_helper
parameter_list|(
specifier|const
name|index_cat_info
modifier|*
name|info
parameter_list|,
name|index_stream
modifier|*
name|this
parameter_list|)
block|{
name|index_stream
modifier|*
name|left
init|=
operator|(
name|index_stream
operator|*
operator|)
operator|(
name|this
operator|->
name|node
operator|.
name|left
operator|)
decl_stmt|;
name|index_stream
modifier|*
name|right
init|=
operator|(
name|index_stream
operator|*
operator|)
operator|(
name|this
operator|->
name|node
operator|.
name|right
operator|)
decl_stmt|;
if|if
condition|(
name|left
operator|!=
name|NULL
condition|)
name|index_cat_helper
argument_list|(
name|info
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|this
operator|->
name|node
operator|.
name|uncompressed_base
operator|+=
name|info
operator|->
name|uncompressed_size
expr_stmt|;
name|this
operator|->
name|node
operator|.
name|compressed_base
operator|+=
name|info
operator|->
name|file_size
expr_stmt|;
name|this
operator|->
name|number
operator|+=
name|info
operator|->
name|stream_number_add
expr_stmt|;
name|this
operator|->
name|block_number_base
operator|+=
name|info
operator|->
name|block_number_add
expr_stmt|;
name|index_tree_append
argument_list|(
name|info
operator|->
name|streams
argument_list|,
operator|&
name|this
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|right
operator|!=
name|NULL
condition|)
name|index_cat_helper
argument_list|(
name|info
argument_list|,
name|right
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_extern
extern|extern LZMA_API(lzma_ret
end_extern

begin_macro
unit|)
name|lzma_index_cat
argument_list|(
argument|lzma_index *restrict dest
argument_list|,
argument|lzma_index *restrict src
argument_list|,
argument|const lzma_allocator *allocator
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|lzma_vli
name|dest_file_size
init|=
name|lzma_index_file_size
argument_list|(
name|dest
argument_list|)
decl_stmt|;
comment|// Check that we don't exceed the file size limits.
if|if
condition|(
name|dest_file_size
operator|+
name|lzma_index_file_size
argument_list|(
name|src
argument_list|)
operator|>
name|LZMA_VLI_MAX
operator|||
name|dest
operator|->
name|uncompressed_size
operator|+
name|src
operator|->
name|uncompressed_size
operator|>
name|LZMA_VLI_MAX
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
comment|// Check that the encoded size of the combined lzma_indexes stays
comment|// within limits. In theory, this should be done only if we know
comment|// that the user plans to actually combine the Streams and thus
comment|// construct a single Index (probably rare). However, exceeding
comment|// this limit is quite theoretical, so we do this check always
comment|// to simplify things elsewhere.
block|{
specifier|const
name|lzma_vli
name|dest_size
init|=
name|index_size_unpadded
argument_list|(
name|dest
operator|->
name|record_count
argument_list|,
name|dest
operator|->
name|index_list_size
argument_list|)
decl_stmt|;
specifier|const
name|lzma_vli
name|src_size
init|=
name|index_size_unpadded
argument_list|(
name|src
operator|->
name|record_count
argument_list|,
name|src
operator|->
name|index_list_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|vli_ceil4
argument_list|(
name|dest_size
operator|+
name|src_size
argument_list|)
operator|>
name|LZMA_BACKWARD_SIZE_MAX
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
block|}
comment|// Optimize the last group to minimize memory usage. Allocation has
comment|// to be done before modifying dest or src.
block|{
name|index_stream
modifier|*
name|s
init|=
operator|(
name|index_stream
operator|*
operator|)
operator|(
name|dest
operator|->
name|streams
operator|.
name|rightmost
operator|)
decl_stmt|;
name|index_group
modifier|*
name|g
init|=
operator|(
name|index_group
operator|*
operator|)
operator|(
name|s
operator|->
name|groups
operator|.
name|rightmost
operator|)
decl_stmt|;
if|if
condition|(
name|g
operator|!=
name|NULL
operator|&&
name|g
operator|->
name|last
operator|+
literal|1
operator|<
name|g
operator|->
name|allocated
condition|)
block|{
name|assert
argument_list|(
name|g
operator|->
name|node
operator|.
name|left
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|g
operator|->
name|node
operator|.
name|right
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|index_group
modifier|*
name|newg
init|=
name|lzma_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|index_group
argument_list|)
operator|+
operator|(
name|g
operator|->
name|last
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|index_record
argument_list|)
argument_list|,
name|allocator
argument_list|)
decl_stmt|;
if|if
condition|(
name|newg
operator|==
name|NULL
condition|)
return|return
name|LZMA_MEM_ERROR
return|;
name|newg
operator|->
name|node
operator|=
name|g
operator|->
name|node
expr_stmt|;
name|newg
operator|->
name|allocated
operator|=
name|g
operator|->
name|last
operator|+
literal|1
expr_stmt|;
name|newg
operator|->
name|last
operator|=
name|g
operator|->
name|last
expr_stmt|;
name|newg
operator|->
name|number_base
operator|=
name|g
operator|->
name|number_base
expr_stmt|;
name|memcpy
argument_list|(
name|newg
operator|->
name|records
argument_list|,
name|g
operator|->
name|records
argument_list|,
name|newg
operator|->
name|allocated
operator|*
sizeof|sizeof
argument_list|(
name|index_record
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|node
operator|.
name|parent
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|g
operator|->
name|node
operator|.
name|parent
operator|->
name|right
operator|==
operator|&
name|g
operator|->
name|node
argument_list|)
expr_stmt|;
name|g
operator|->
name|node
operator|.
name|parent
operator|->
name|right
operator|=
operator|&
name|newg
operator|->
name|node
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|groups
operator|.
name|leftmost
operator|==
operator|&
name|g
operator|->
name|node
condition|)
block|{
name|assert
argument_list|(
name|s
operator|->
name|groups
operator|.
name|root
operator|==
operator|&
name|g
operator|->
name|node
argument_list|)
expr_stmt|;
name|s
operator|->
name|groups
operator|.
name|leftmost
operator|=
operator|&
name|newg
operator|->
name|node
expr_stmt|;
name|s
operator|->
name|groups
operator|.
name|root
operator|=
operator|&
name|newg
operator|->
name|node
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|groups
operator|.
name|rightmost
operator|==
operator|&
name|g
operator|->
name|node
condition|)
name|s
operator|->
name|groups
operator|.
name|rightmost
operator|=
operator|&
name|newg
operator|->
name|node
expr_stmt|;
name|lzma_free
argument_list|(
name|g
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Add all the Streams from src to dest. Update the base offsets
comment|// of each Stream from src.
specifier|const
name|index_cat_info
name|info
init|=
block|{
operator|.
name|uncompressed_size
operator|=
name|dest
operator|->
name|uncompressed_size
block|,
operator|.
name|file_size
operator|=
name|dest_file_size
block|,
operator|.
name|stream_number_add
operator|=
name|dest
operator|->
name|streams
operator|.
name|count
block|,
operator|.
name|block_number_add
operator|=
name|dest
operator|->
name|record_count
block|,
operator|.
name|streams
operator|=
operator|&
name|dest
operator|->
name|streams
block|, 	}
decl_stmt|;
name|index_cat_helper
argument_list|(
operator|&
name|info
argument_list|,
operator|(
name|index_stream
operator|*
operator|)
operator|(
name|src
operator|->
name|streams
operator|.
name|root
operator|)
argument_list|)
expr_stmt|;
comment|// Update info about all the combined Streams.
name|dest
operator|->
name|uncompressed_size
operator|+=
name|src
operator|->
name|uncompressed_size
expr_stmt|;
name|dest
operator|->
name|total_size
operator|+=
name|src
operator|->
name|total_size
expr_stmt|;
name|dest
operator|->
name|record_count
operator|+=
name|src
operator|->
name|record_count
expr_stmt|;
name|dest
operator|->
name|index_list_size
operator|+=
name|src
operator|->
name|index_list_size
expr_stmt|;
name|dest
operator|->
name|checks
operator|=
name|lzma_index_checks
argument_list|(
name|dest
argument_list|)
operator||
name|src
operator|->
name|checks
expr_stmt|;
comment|// There's nothing else left in src than the base structure.
name|lzma_free
argument_list|(
name|src
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
return|return
name|LZMA_OK
return|;
block|}
end_block

begin_comment
comment|/// Duplicate an index_stream.
end_comment

begin_function
specifier|static
name|index_stream
modifier|*
name|index_dup_stream
parameter_list|(
specifier|const
name|index_stream
modifier|*
name|src
parameter_list|,
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|)
block|{
comment|// Catch a somewhat theoretical integer overflow.
if|if
condition|(
name|src
operator|->
name|record_count
operator|>
name|PREALLOC_MAX
condition|)
return|return
name|NULL
return|;
comment|// Allocate and initialize a new Stream.
name|index_stream
modifier|*
name|dest
init|=
name|index_stream_init
argument_list|(
name|src
operator|->
name|node
operator|.
name|compressed_base
argument_list|,
name|src
operator|->
name|node
operator|.
name|uncompressed_base
argument_list|,
name|src
operator|->
name|number
argument_list|,
name|src
operator|->
name|block_number_base
argument_list|,
name|allocator
argument_list|)
decl_stmt|;
comment|// Return immediately if allocation failed or if there are
comment|// no groups to duplicate.
if|if
condition|(
name|dest
operator|==
name|NULL
operator|||
name|src
operator|->
name|groups
operator|.
name|leftmost
operator|==
name|NULL
condition|)
return|return
name|dest
return|;
comment|// Copy the overall information.
name|dest
operator|->
name|record_count
operator|=
name|src
operator|->
name|record_count
expr_stmt|;
name|dest
operator|->
name|index_list_size
operator|=
name|src
operator|->
name|index_list_size
expr_stmt|;
name|dest
operator|->
name|stream_flags
operator|=
name|src
operator|->
name|stream_flags
expr_stmt|;
name|dest
operator|->
name|stream_padding
operator|=
name|src
operator|->
name|stream_padding
expr_stmt|;
comment|// Allocate memory for the Records. We put all the Records into
comment|// a single group. It's simplest and also tends to make
comment|// lzma_index_locate() a little bit faster with very big Indexes.
name|index_group
modifier|*
name|destg
init|=
name|lzma_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|index_group
argument_list|)
operator|+
name|src
operator|->
name|record_count
operator|*
sizeof|sizeof
argument_list|(
name|index_record
argument_list|)
argument_list|,
name|allocator
argument_list|)
decl_stmt|;
if|if
condition|(
name|destg
operator|==
name|NULL
condition|)
block|{
name|index_stream_end
argument_list|(
name|dest
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|// Initialize destg.
name|destg
operator|->
name|node
operator|.
name|uncompressed_base
operator|=
literal|0
expr_stmt|;
name|destg
operator|->
name|node
operator|.
name|compressed_base
operator|=
literal|0
expr_stmt|;
name|destg
operator|->
name|number_base
operator|=
literal|1
expr_stmt|;
name|destg
operator|->
name|allocated
operator|=
name|src
operator|->
name|record_count
expr_stmt|;
name|destg
operator|->
name|last
operator|=
name|src
operator|->
name|record_count
operator|-
literal|1
expr_stmt|;
comment|// Go through all the groups in src and copy the Records into destg.
specifier|const
name|index_group
modifier|*
name|srcg
init|=
operator|(
specifier|const
name|index_group
operator|*
operator|)
operator|(
name|src
operator|->
name|groups
operator|.
name|leftmost
operator|)
decl_stmt|;
name|size_t
name|i
init|=
literal|0
decl_stmt|;
do|do
block|{
name|memcpy
argument_list|(
name|destg
operator|->
name|records
operator|+
name|i
argument_list|,
name|srcg
operator|->
name|records
argument_list|,
operator|(
name|srcg
operator|->
name|last
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|index_record
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|+=
name|srcg
operator|->
name|last
operator|+
literal|1
expr_stmt|;
name|srcg
operator|=
name|index_tree_next
argument_list|(
operator|&
name|srcg
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|srcg
operator|!=
name|NULL
condition|)
do|;
name|assert
argument_list|(
name|i
operator|==
name|destg
operator|->
name|allocated
argument_list|)
expr_stmt|;
comment|// Add the group to the new Stream.
name|index_tree_append
argument_list|(
operator|&
name|dest
operator|->
name|groups
argument_list|,
operator|&
name|destg
operator|->
name|node
argument_list|)
expr_stmt|;
return|return
name|dest
return|;
block|}
end_function

begin_extern
extern|extern LZMA_API(lzma_index *
end_extern

begin_macro
unit|)
name|lzma_index_dup
argument_list|(
argument|const lzma_index *src
argument_list|,
argument|const lzma_allocator *allocator
argument_list|)
end_macro

begin_block
block|{
comment|// Allocate the base structure (no initial Stream).
name|lzma_index
modifier|*
name|dest
init|=
name|index_init_plain
argument_list|(
name|allocator
argument_list|)
decl_stmt|;
if|if
condition|(
name|dest
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|// Copy the totals.
name|dest
operator|->
name|uncompressed_size
operator|=
name|src
operator|->
name|uncompressed_size
expr_stmt|;
name|dest
operator|->
name|total_size
operator|=
name|src
operator|->
name|total_size
expr_stmt|;
name|dest
operator|->
name|record_count
operator|=
name|src
operator|->
name|record_count
expr_stmt|;
name|dest
operator|->
name|index_list_size
operator|=
name|src
operator|->
name|index_list_size
expr_stmt|;
comment|// Copy the Streams and the groups in them.
specifier|const
name|index_stream
modifier|*
name|srcstream
init|=
operator|(
specifier|const
name|index_stream
operator|*
operator|)
operator|(
name|src
operator|->
name|streams
operator|.
name|leftmost
operator|)
decl_stmt|;
do|do
block|{
name|index_stream
modifier|*
name|deststream
init|=
name|index_dup_stream
argument_list|(
name|srcstream
argument_list|,
name|allocator
argument_list|)
decl_stmt|;
if|if
condition|(
name|deststream
operator|==
name|NULL
condition|)
block|{
name|lzma_index_end
argument_list|(
name|dest
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|index_tree_append
argument_list|(
operator|&
name|dest
operator|->
name|streams
argument_list|,
operator|&
name|deststream
operator|->
name|node
argument_list|)
expr_stmt|;
name|srcstream
operator|=
name|index_tree_next
argument_list|(
operator|&
name|srcstream
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|srcstream
operator|!=
name|NULL
condition|)
do|;
return|return
name|dest
return|;
block|}
end_block

begin_comment
comment|/// Indexing for lzma_index_iter.internal[]
end_comment

begin_enum
enum|enum
block|{
name|ITER_INDEX
block|,
name|ITER_STREAM
block|,
name|ITER_GROUP
block|,
name|ITER_RECORD
block|,
name|ITER_METHOD
block|, }
enum|;
end_enum

begin_comment
comment|/// Values for lzma_index_iter.internal[ITER_METHOD].s
end_comment

begin_enum
enum|enum
block|{
name|ITER_METHOD_NORMAL
block|,
name|ITER_METHOD_NEXT
block|,
name|ITER_METHOD_LEFTMOST
block|, }
enum|;
end_enum

begin_function
specifier|static
name|void
name|iter_set_info
parameter_list|(
name|lzma_index_iter
modifier|*
name|iter
parameter_list|)
block|{
specifier|const
name|lzma_index
modifier|*
name|i
init|=
name|iter
operator|->
name|internal
index|[
name|ITER_INDEX
index|]
operator|.
name|p
decl_stmt|;
specifier|const
name|index_stream
modifier|*
name|stream
init|=
name|iter
operator|->
name|internal
index|[
name|ITER_STREAM
index|]
operator|.
name|p
decl_stmt|;
specifier|const
name|index_group
modifier|*
name|group
init|=
name|iter
operator|->
name|internal
index|[
name|ITER_GROUP
index|]
operator|.
name|p
decl_stmt|;
specifier|const
name|size_t
name|record
init|=
name|iter
operator|->
name|internal
index|[
name|ITER_RECORD
index|]
operator|.
name|s
decl_stmt|;
comment|// lzma_index_iter.internal must not contain a pointer to the last
comment|// group in the index, because that may be reallocated by
comment|// lzma_index_cat().
if|if
condition|(
name|group
operator|==
name|NULL
condition|)
block|{
comment|// There are no groups.
name|assert
argument_list|(
name|stream
operator|->
name|groups
operator|.
name|root
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|iter
operator|->
name|internal
index|[
name|ITER_METHOD
index|]
operator|.
name|s
operator|=
name|ITER_METHOD_LEFTMOST
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|->
name|streams
operator|.
name|rightmost
operator|!=
operator|&
name|stream
operator|->
name|node
operator|||
name|stream
operator|->
name|groups
operator|.
name|rightmost
operator|!=
operator|&
name|group
operator|->
name|node
condition|)
block|{
comment|// The group is not not the last group in the index.
name|iter
operator|->
name|internal
index|[
name|ITER_METHOD
index|]
operator|.
name|s
operator|=
name|ITER_METHOD_NORMAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stream
operator|->
name|groups
operator|.
name|leftmost
operator|!=
operator|&
name|group
operator|->
name|node
condition|)
block|{
comment|// The group isn't the only group in the Stream, thus we
comment|// know that it must have a parent group i.e. it's not
comment|// the root node.
name|assert
argument_list|(
name|stream
operator|->
name|groups
operator|.
name|root
operator|!=
operator|&
name|group
operator|->
name|node
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|group
operator|->
name|node
operator|.
name|parent
operator|->
name|right
operator|==
operator|&
name|group
operator|->
name|node
argument_list|)
expr_stmt|;
name|iter
operator|->
name|internal
index|[
name|ITER_METHOD
index|]
operator|.
name|s
operator|=
name|ITER_METHOD_NEXT
expr_stmt|;
name|iter
operator|->
name|internal
index|[
name|ITER_GROUP
index|]
operator|.
name|p
operator|=
name|group
operator|->
name|node
operator|.
name|parent
expr_stmt|;
block|}
else|else
block|{
comment|// The Stream has only one group.
name|assert
argument_list|(
name|stream
operator|->
name|groups
operator|.
name|root
operator|==
operator|&
name|group
operator|->
name|node
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|group
operator|->
name|node
operator|.
name|parent
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|iter
operator|->
name|internal
index|[
name|ITER_METHOD
index|]
operator|.
name|s
operator|=
name|ITER_METHOD_LEFTMOST
expr_stmt|;
name|iter
operator|->
name|internal
index|[
name|ITER_GROUP
index|]
operator|.
name|p
operator|=
name|NULL
expr_stmt|;
block|}
name|iter
operator|->
name|stream
operator|.
name|number
operator|=
name|stream
operator|->
name|number
expr_stmt|;
name|iter
operator|->
name|stream
operator|.
name|block_count
operator|=
name|stream
operator|->
name|record_count
expr_stmt|;
name|iter
operator|->
name|stream
operator|.
name|compressed_offset
operator|=
name|stream
operator|->
name|node
operator|.
name|compressed_base
expr_stmt|;
name|iter
operator|->
name|stream
operator|.
name|uncompressed_offset
operator|=
name|stream
operator|->
name|node
operator|.
name|uncompressed_base
expr_stmt|;
comment|// iter->stream.flags will be NULL if the Stream Flags haven't been
comment|// set with lzma_index_stream_flags().
name|iter
operator|->
name|stream
operator|.
name|flags
operator|=
name|stream
operator|->
name|stream_flags
operator|.
name|version
operator|==
name|UINT32_MAX
condition|?
name|NULL
else|:
operator|&
name|stream
operator|->
name|stream_flags
expr_stmt|;
name|iter
operator|->
name|stream
operator|.
name|padding
operator|=
name|stream
operator|->
name|stream_padding
expr_stmt|;
if|if
condition|(
name|stream
operator|->
name|groups
operator|.
name|rightmost
operator|==
name|NULL
condition|)
block|{
comment|// Stream has no Blocks.
name|iter
operator|->
name|stream
operator|.
name|compressed_size
operator|=
name|index_size
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|+
literal|2
operator|*
name|LZMA_STREAM_HEADER_SIZE
expr_stmt|;
name|iter
operator|->
name|stream
operator|.
name|uncompressed_size
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|index_group
modifier|*
name|g
init|=
operator|(
specifier|const
name|index_group
operator|*
operator|)
operator|(
name|stream
operator|->
name|groups
operator|.
name|rightmost
operator|)
decl_stmt|;
comment|// Stream Header + Stream Footer + Index + Blocks
name|iter
operator|->
name|stream
operator|.
name|compressed_size
operator|=
literal|2
operator|*
name|LZMA_STREAM_HEADER_SIZE
operator|+
name|index_size
argument_list|(
name|stream
operator|->
name|record_count
argument_list|,
name|stream
operator|->
name|index_list_size
argument_list|)
operator|+
name|vli_ceil4
argument_list|(
name|g
operator|->
name|records
index|[
name|g
operator|->
name|last
index|]
operator|.
name|unpadded_sum
argument_list|)
expr_stmt|;
name|iter
operator|->
name|stream
operator|.
name|uncompressed_size
operator|=
name|g
operator|->
name|records
index|[
name|g
operator|->
name|last
index|]
operator|.
name|uncompressed_sum
expr_stmt|;
block|}
if|if
condition|(
name|group
operator|!=
name|NULL
condition|)
block|{
name|iter
operator|->
name|block
operator|.
name|number_in_stream
operator|=
name|group
operator|->
name|number_base
operator|+
name|record
expr_stmt|;
name|iter
operator|->
name|block
operator|.
name|number_in_file
operator|=
name|iter
operator|->
name|block
operator|.
name|number_in_stream
operator|+
name|stream
operator|->
name|block_number_base
expr_stmt|;
name|iter
operator|->
name|block
operator|.
name|compressed_stream_offset
operator|=
name|record
operator|==
literal|0
condition|?
name|group
operator|->
name|node
operator|.
name|compressed_base
else|:
name|vli_ceil4
argument_list|(
name|group
operator|->
name|records
index|[
name|record
operator|-
literal|1
index|]
operator|.
name|unpadded_sum
argument_list|)
expr_stmt|;
name|iter
operator|->
name|block
operator|.
name|uncompressed_stream_offset
operator|=
name|record
operator|==
literal|0
condition|?
name|group
operator|->
name|node
operator|.
name|uncompressed_base
else|:
name|group
operator|->
name|records
index|[
name|record
operator|-
literal|1
index|]
operator|.
name|uncompressed_sum
expr_stmt|;
name|iter
operator|->
name|block
operator|.
name|uncompressed_size
operator|=
name|group
operator|->
name|records
index|[
name|record
index|]
operator|.
name|uncompressed_sum
operator|-
name|iter
operator|->
name|block
operator|.
name|uncompressed_stream_offset
expr_stmt|;
name|iter
operator|->
name|block
operator|.
name|unpadded_size
operator|=
name|group
operator|->
name|records
index|[
name|record
index|]
operator|.
name|unpadded_sum
operator|-
name|iter
operator|->
name|block
operator|.
name|compressed_stream_offset
expr_stmt|;
name|iter
operator|->
name|block
operator|.
name|total_size
operator|=
name|vli_ceil4
argument_list|(
name|iter
operator|->
name|block
operator|.
name|unpadded_size
argument_list|)
expr_stmt|;
name|iter
operator|->
name|block
operator|.
name|compressed_stream_offset
operator|+=
name|LZMA_STREAM_HEADER_SIZE
expr_stmt|;
name|iter
operator|->
name|block
operator|.
name|compressed_file_offset
operator|=
name|iter
operator|->
name|block
operator|.
name|compressed_stream_offset
operator|+
name|iter
operator|->
name|stream
operator|.
name|compressed_offset
expr_stmt|;
name|iter
operator|->
name|block
operator|.
name|uncompressed_file_offset
operator|=
name|iter
operator|->
name|block
operator|.
name|uncompressed_stream_offset
operator|+
name|iter
operator|->
name|stream
operator|.
name|uncompressed_offset
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_extern
extern|extern LZMA_API(void
end_extern

begin_macro
unit|)
name|lzma_index_iter_init
argument_list|(
argument|lzma_index_iter *iter
argument_list|,
argument|const lzma_index *i
argument_list|)
end_macro

begin_block
block|{
name|iter
operator|->
name|internal
index|[
name|ITER_INDEX
index|]
operator|.
name|p
operator|=
name|i
expr_stmt|;
name|lzma_index_iter_rewind
argument_list|(
name|iter
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_extern
extern|extern LZMA_API(void
end_extern

begin_macro
unit|)
name|lzma_index_iter_rewind
argument_list|(
argument|lzma_index_iter *iter
argument_list|)
end_macro

begin_block
block|{
name|iter
operator|->
name|internal
index|[
name|ITER_STREAM
index|]
operator|.
name|p
operator|=
name|NULL
expr_stmt|;
name|iter
operator|->
name|internal
index|[
name|ITER_GROUP
index|]
operator|.
name|p
operator|=
name|NULL
expr_stmt|;
name|iter
operator|->
name|internal
index|[
name|ITER_RECORD
index|]
operator|.
name|s
operator|=
literal|0
expr_stmt|;
name|iter
operator|->
name|internal
index|[
name|ITER_METHOD
index|]
operator|.
name|s
operator|=
name|ITER_METHOD_NORMAL
expr_stmt|;
return|return;
block|}
end_block

begin_extern
extern|extern LZMA_API(lzma_bool
end_extern

begin_macro
unit|)
name|lzma_index_iter_next
argument_list|(
argument|lzma_index_iter *iter
argument_list|,
argument|lzma_index_iter_mode mode
argument_list|)
end_macro

begin_block
block|{
comment|// Catch unsupported mode values.
if|if
condition|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|mode
argument_list|)
operator|>
name|LZMA_INDEX_ITER_NONEMPTY_BLOCK
condition|)
return|return
name|true
return|;
specifier|const
name|lzma_index
modifier|*
name|i
init|=
name|iter
operator|->
name|internal
index|[
name|ITER_INDEX
index|]
operator|.
name|p
decl_stmt|;
specifier|const
name|index_stream
modifier|*
name|stream
init|=
name|iter
operator|->
name|internal
index|[
name|ITER_STREAM
index|]
operator|.
name|p
decl_stmt|;
specifier|const
name|index_group
modifier|*
name|group
init|=
name|NULL
decl_stmt|;
name|size_t
name|record
init|=
name|iter
operator|->
name|internal
index|[
name|ITER_RECORD
index|]
operator|.
name|s
decl_stmt|;
comment|// If we are being asked for the next Stream, leave group to NULL
comment|// so that the rest of the this function thinks that this Stream
comment|// has no groups and will thus go to the next Stream.
if|if
condition|(
name|mode
operator|!=
name|LZMA_INDEX_ITER_STREAM
condition|)
block|{
comment|// Get the pointer to the current group. See iter_set_inf()
comment|// for explanation.
switch|switch
condition|(
name|iter
operator|->
name|internal
index|[
name|ITER_METHOD
index|]
operator|.
name|s
condition|)
block|{
case|case
name|ITER_METHOD_NORMAL
case|:
name|group
operator|=
name|iter
operator|->
name|internal
index|[
name|ITER_GROUP
index|]
operator|.
name|p
expr_stmt|;
break|break;
case|case
name|ITER_METHOD_NEXT
case|:
name|group
operator|=
name|index_tree_next
argument_list|(
name|iter
operator|->
name|internal
index|[
name|ITER_GROUP
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|ITER_METHOD_LEFTMOST
case|:
name|group
operator|=
operator|(
specifier|const
name|index_group
operator|*
operator|)
operator|(
name|stream
operator|->
name|groups
operator|.
name|leftmost
operator|)
expr_stmt|;
break|break;
block|}
block|}
name|again
label|:
if|if
condition|(
name|stream
operator|==
name|NULL
condition|)
block|{
comment|// We at the beginning of the lzma_index.
comment|// Locate the first Stream.
name|stream
operator|=
operator|(
specifier|const
name|index_stream
operator|*
operator|)
operator|(
name|i
operator|->
name|streams
operator|.
name|leftmost
operator|)
expr_stmt|;
if|if
condition|(
name|mode
operator|>=
name|LZMA_INDEX_ITER_BLOCK
condition|)
block|{
comment|// Since we are being asked to return information
comment|// about the first a Block, skip Streams that have
comment|// no Blocks.
while|while
condition|(
name|stream
operator|->
name|groups
operator|.
name|leftmost
operator|==
name|NULL
condition|)
block|{
name|stream
operator|=
name|index_tree_next
argument_list|(
operator|&
name|stream
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|==
name|NULL
condition|)
return|return
name|true
return|;
block|}
block|}
comment|// Start from the first Record in the Stream.
name|group
operator|=
operator|(
specifier|const
name|index_group
operator|*
operator|)
operator|(
name|stream
operator|->
name|groups
operator|.
name|leftmost
operator|)
expr_stmt|;
name|record
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|group
operator|!=
name|NULL
operator|&&
name|record
operator|<
name|group
operator|->
name|last
condition|)
block|{
comment|// The next Record is in the same group.
operator|++
name|record
expr_stmt|;
block|}
else|else
block|{
comment|// This group has no more Records or this Stream has
comment|// no Blocks at all.
name|record
operator|=
literal|0
expr_stmt|;
comment|// If group is not NULL, this Stream has at least one Block
comment|// and thus at least one group. Find the next group.
if|if
condition|(
name|group
operator|!=
name|NULL
condition|)
name|group
operator|=
name|index_tree_next
argument_list|(
operator|&
name|group
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|group
operator|==
name|NULL
condition|)
block|{
comment|// This Stream has no more Records. Find the next
comment|// Stream. If we are being asked to return information
comment|// about a Block, we skip empty Streams.
do|do
block|{
name|stream
operator|=
name|index_tree_next
argument_list|(
operator|&
name|stream
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|==
name|NULL
condition|)
return|return
name|true
return|;
block|}
do|while
condition|(
name|mode
operator|>=
name|LZMA_INDEX_ITER_BLOCK
operator|&&
name|stream
operator|->
name|groups
operator|.
name|leftmost
operator|==
name|NULL
condition|)
do|;
name|group
operator|=
operator|(
specifier|const
name|index_group
operator|*
operator|)
operator|(
name|stream
operator|->
name|groups
operator|.
name|leftmost
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mode
operator|==
name|LZMA_INDEX_ITER_NONEMPTY_BLOCK
condition|)
block|{
comment|// We need to look for the next Block again if this Block
comment|// is empty.
if|if
condition|(
name|record
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|group
operator|->
name|node
operator|.
name|uncompressed_base
operator|==
name|group
operator|->
name|records
index|[
literal|0
index|]
operator|.
name|uncompressed_sum
condition|)
goto|goto
name|again
goto|;
block|}
elseif|else
if|if
condition|(
name|group
operator|->
name|records
index|[
name|record
operator|-
literal|1
index|]
operator|.
name|uncompressed_sum
operator|==
name|group
operator|->
name|records
index|[
name|record
index|]
operator|.
name|uncompressed_sum
condition|)
block|{
goto|goto
name|again
goto|;
block|}
block|}
name|iter
operator|->
name|internal
index|[
name|ITER_STREAM
index|]
operator|.
name|p
operator|=
name|stream
expr_stmt|;
name|iter
operator|->
name|internal
index|[
name|ITER_GROUP
index|]
operator|.
name|p
operator|=
name|group
expr_stmt|;
name|iter
operator|->
name|internal
index|[
name|ITER_RECORD
index|]
operator|.
name|s
operator|=
name|record
expr_stmt|;
name|iter_set_info
argument_list|(
name|iter
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_block

begin_extern
extern|extern LZMA_API(lzma_bool
end_extern

begin_macro
unit|)
name|lzma_index_iter_locate
argument_list|(
argument|lzma_index_iter *iter
argument_list|,
argument|lzma_vli target
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|lzma_index
modifier|*
name|i
init|=
name|iter
operator|->
name|internal
index|[
name|ITER_INDEX
index|]
operator|.
name|p
decl_stmt|;
comment|// If the target is past the end of the file, return immediately.
if|if
condition|(
name|i
operator|->
name|uncompressed_size
operator|<=
name|target
condition|)
return|return
name|true
return|;
comment|// Locate the Stream containing the target offset.
specifier|const
name|index_stream
modifier|*
name|stream
init|=
name|index_tree_locate
argument_list|(
operator|&
name|i
operator|->
name|streams
argument_list|,
name|target
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|stream
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|target
operator|-=
name|stream
operator|->
name|node
operator|.
name|uncompressed_base
expr_stmt|;
comment|// Locate the group containing the target offset.
specifier|const
name|index_group
modifier|*
name|group
init|=
name|index_tree_locate
argument_list|(
operator|&
name|stream
operator|->
name|groups
argument_list|,
name|target
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|group
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|// Use binary search to locate the exact Record. It is the first
comment|// Record whose uncompressed_sum is greater than target.
comment|// This is because we want the rightmost Record that fullfills the
comment|// search criterion. It is possible that there are empty Blocks;
comment|// we don't want to return them.
name|size_t
name|left
init|=
literal|0
decl_stmt|;
name|size_t
name|right
init|=
name|group
operator|->
name|last
decl_stmt|;
while|while
condition|(
name|left
operator|<
name|right
condition|)
block|{
specifier|const
name|size_t
name|pos
init|=
name|left
operator|+
operator|(
name|right
operator|-
name|left
operator|)
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|group
operator|->
name|records
index|[
name|pos
index|]
operator|.
name|uncompressed_sum
operator|<=
name|target
condition|)
name|left
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
else|else
name|right
operator|=
name|pos
expr_stmt|;
block|}
name|iter
operator|->
name|internal
index|[
name|ITER_STREAM
index|]
operator|.
name|p
operator|=
name|stream
expr_stmt|;
name|iter
operator|->
name|internal
index|[
name|ITER_GROUP
index|]
operator|.
name|p
operator|=
name|group
expr_stmt|;
name|iter
operator|->
name|internal
index|[
name|ITER_RECORD
index|]
operator|.
name|s
operator|=
name|left
expr_stmt|;
name|iter_set_info
argument_list|(
name|iter
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_block

end_unit

