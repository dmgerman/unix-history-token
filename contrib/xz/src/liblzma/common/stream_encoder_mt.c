begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       stream_encoder_mt.c
end_comment

begin_comment
comment|/// \brief      Multithreaded .xz Stream encoder
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Author:     Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"filter_encoder.h"
end_include

begin_include
include|#
directive|include
file|"easy_preset.h"
end_include

begin_include
include|#
directive|include
file|"block_encoder.h"
end_include

begin_include
include|#
directive|include
file|"block_buffer_encoder.h"
end_include

begin_include
include|#
directive|include
file|"index_encoder.h"
end_include

begin_include
include|#
directive|include
file|"outqueue.h"
end_include

begin_comment
comment|/// Maximum supported block size. This makes it simpler to prevent integer
end_comment

begin_comment
comment|/// overflows if we are given unusually large block size.
end_comment

begin_define
define|#
directive|define
name|BLOCK_SIZE_MAX
value|(UINT64_MAX / LZMA_THREADS_MAX)
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
comment|/// Waiting for work.
name|THR_IDLE
block|,
comment|/// Encoding is in progress.
name|THR_RUN
block|,
comment|/// Encoding is in progress but no more input data will
comment|/// be read.
name|THR_FINISH
block|,
comment|/// The main thread wants the thread to stop whatever it was doing
comment|/// but not exit.
name|THR_STOP
block|,
comment|/// The main thread wants the thread to exit. We could use
comment|/// cancellation but since there's stopped anyway, this is lazier.
name|THR_EXIT
block|,  }
name|worker_state
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|worker_thread_s
name|worker_thread
typedef|;
end_typedef

begin_struct
struct|struct
name|worker_thread_s
block|{
name|worker_state
name|state
decl_stmt|;
comment|/// Input buffer of coder->block_size bytes. The main thread will
comment|/// put new input into this and update in_size accordingly. Once
comment|/// no more input is coming, state will be set to THR_FINISH.
name|uint8_t
modifier|*
name|in
decl_stmt|;
comment|/// Amount of data available in the input buffer. This is modified
comment|/// only by the main thread.
name|size_t
name|in_size
decl_stmt|;
comment|/// Output buffer for this thread. This is set by the main
comment|/// thread every time a new Block is started with this thread
comment|/// structure.
name|lzma_outbuf
modifier|*
name|outbuf
decl_stmt|;
comment|/// Pointer to the main structure is needed when putting this
comment|/// thread back to the stack of free threads.
name|lzma_coder
modifier|*
name|coder
decl_stmt|;
comment|/// The allocator is set by the main thread. Since a copy of the
comment|/// pointer is kept here, the application must not change the
comment|/// allocator before calling lzma_end().
specifier|const
name|lzma_allocator
modifier|*
name|allocator
decl_stmt|;
comment|/// Amount of uncompressed data that has already been compressed.
name|uint64_t
name|progress_in
decl_stmt|;
comment|/// Amount of compressed data that is ready.
name|uint64_t
name|progress_out
decl_stmt|;
comment|/// Block encoder
name|lzma_next_coder
name|block_encoder
decl_stmt|;
comment|/// Compression options for this Block
name|lzma_block
name|block_options
decl_stmt|;
comment|/// Next structure in the stack of free worker threads.
name|worker_thread
modifier|*
name|next
decl_stmt|;
name|mythread_mutex
name|mutex
decl_stmt|;
name|mythread_cond
name|cond
decl_stmt|;
comment|/// The ID of this thread is used to join the thread
comment|/// when it's not needed anymore.
name|mythread
name|thread_id
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|lzma_coder_s
block|{
enum|enum
block|{
name|SEQ_STREAM_HEADER
block|,
name|SEQ_BLOCK
block|,
name|SEQ_INDEX
block|,
name|SEQ_STREAM_FOOTER
block|, 	}
name|sequence
enum|;
comment|/// Start a new Block every block_size bytes of input unless
comment|/// LZMA_FULL_FLUSH or LZMA_FULL_BARRIER is used earlier.
name|size_t
name|block_size
decl_stmt|;
comment|/// The filter chain currently in use
name|lzma_filter
name|filters
index|[
name|LZMA_FILTERS_MAX
operator|+
literal|1
index|]
decl_stmt|;
comment|/// Index to hold sizes of the Blocks
name|lzma_index
modifier|*
name|index
decl_stmt|;
comment|/// Index encoder
name|lzma_next_coder
name|index_encoder
decl_stmt|;
comment|/// Stream Flags for encoding the Stream Header and Stream Footer.
name|lzma_stream_flags
name|stream_flags
decl_stmt|;
comment|/// Buffer to hold Stream Header and Stream Footer.
name|uint8_t
name|header
index|[
name|LZMA_STREAM_HEADER_SIZE
index|]
decl_stmt|;
comment|/// Read position in header[]
name|size_t
name|header_pos
decl_stmt|;
comment|/// Output buffer queue for compressed data
name|lzma_outq
name|outq
decl_stmt|;
comment|/// Maximum wait time if cannot use all the input and cannot
comment|/// fill the output buffer. This is in milliseconds.
name|uint32_t
name|timeout
decl_stmt|;
comment|/// Error code from a worker thread
name|lzma_ret
name|thread_error
decl_stmt|;
comment|/// Array of allocated thread-specific structures
name|worker_thread
modifier|*
name|threads
decl_stmt|;
comment|/// Number of structures in "threads" above. This is also the
comment|/// number of threads that will be created at maximum.
name|uint32_t
name|threads_max
decl_stmt|;
comment|/// Number of thread structures that have been initialized, and
comment|/// thus the number of worker threads actually created so far.
name|uint32_t
name|threads_initialized
decl_stmt|;
comment|/// Stack of free threads. When a thread finishes, it puts itself
comment|/// back into this stack. This starts as empty because threads
comment|/// are created only when actually needed.
name|worker_thread
modifier|*
name|threads_free
decl_stmt|;
comment|/// The most recent worker thread to which the main thread writes
comment|/// the new input from the application.
name|worker_thread
modifier|*
name|thr
decl_stmt|;
comment|/// Amount of uncompressed data in Blocks that have already
comment|/// been finished.
name|uint64_t
name|progress_in
decl_stmt|;
comment|/// Amount of compressed data in Stream Header + Blocks that
comment|/// have already been finished.
name|uint64_t
name|progress_out
decl_stmt|;
name|mythread_mutex
name|mutex
decl_stmt|;
name|mythread_cond
name|cond
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/// Tell the main thread that something has gone wrong.
end_comment

begin_function
specifier|static
name|void
name|worker_error
parameter_list|(
name|worker_thread
modifier|*
name|thr
parameter_list|,
name|lzma_ret
name|ret
parameter_list|)
block|{
name|assert
argument_list|(
name|ret
operator|!=
name|LZMA_OK
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|!=
name|LZMA_STREAM_END
argument_list|)
expr_stmt|;
name|mythread_sync
argument_list|(
argument|thr->coder->mutex
argument_list|)
block|{
if|if
condition|(
name|thr
operator|->
name|coder
operator|->
name|thread_error
operator|==
name|LZMA_OK
condition|)
name|thr
operator|->
name|coder
operator|->
name|thread_error
operator|=
name|ret
expr_stmt|;
name|mythread_cond_signal
argument_list|(
operator|&
name|thr
operator|->
name|coder
operator|->
name|cond
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|worker_state
name|worker_encode
parameter_list|(
name|worker_thread
modifier|*
name|thr
parameter_list|,
name|worker_state
name|state
parameter_list|)
block|{
name|assert
argument_list|(
name|thr
operator|->
name|progress_in
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|thr
operator|->
name|progress_out
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// Set the Block options.
name|thr
operator|->
name|block_options
operator|=
operator|(
name|lzma_block
operator|)
block|{
operator|.
name|version
operator|=
literal|0
block|,
operator|.
name|check
operator|=
name|thr
operator|->
name|coder
operator|->
name|stream_flags
operator|.
name|check
block|,
operator|.
name|compressed_size
operator|=
name|thr
operator|->
name|coder
operator|->
name|outq
operator|.
name|buf_size_max
block|,
operator|.
name|uncompressed_size
operator|=
name|thr
operator|->
name|coder
operator|->
name|block_size
block|,
comment|// TODO: To allow changing the filter chain, the filters
comment|// array must be copied to each worker_thread.
operator|.
name|filters
operator|=
name|thr
operator|->
name|coder
operator|->
name|filters
block|, 	}
expr_stmt|;
comment|// Calculate maximum size of the Block Header. This amount is
comment|// reserved in the beginning of the buffer so that Block Header
comment|// along with Compressed Size and Uncompressed Size can be
comment|// written there.
name|lzma_ret
name|ret
init|=
name|lzma_block_header_size
argument_list|(
operator|&
name|thr
operator|->
name|block_options
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
name|worker_error
argument_list|(
name|thr
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|THR_STOP
return|;
block|}
comment|// Initialize the Block encoder.
name|ret
operator|=
name|lzma_block_encoder_init
argument_list|(
operator|&
name|thr
operator|->
name|block_encoder
argument_list|,
name|thr
operator|->
name|allocator
argument_list|,
operator|&
name|thr
operator|->
name|block_options
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
name|worker_error
argument_list|(
name|thr
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|THR_STOP
return|;
block|}
name|size_t
name|in_pos
init|=
literal|0
decl_stmt|;
name|size_t
name|in_size
init|=
literal|0
decl_stmt|;
name|thr
operator|->
name|outbuf
operator|->
name|size
operator|=
name|thr
operator|->
name|block_options
operator|.
name|header_size
expr_stmt|;
specifier|const
name|size_t
name|out_size
init|=
name|thr
operator|->
name|coder
operator|->
name|outq
operator|.
name|buf_size_max
decl_stmt|;
do|do
block|{
name|mythread_sync
argument_list|(
argument|thr->mutex
argument_list|)
block|{
comment|// Store in_pos and out_pos into *thr so that
comment|// an application may read them via
comment|// lzma_get_progress() to get progress information.
comment|//
comment|// NOTE: These aren't updated when the encoding
comment|// finishes. Instead, the final values are taken
comment|// later from thr->outbuf.
name|thr
operator|->
name|progress_in
operator|=
name|in_pos
expr_stmt|;
name|thr
operator|->
name|progress_out
operator|=
name|thr
operator|->
name|outbuf
operator|->
name|size
expr_stmt|;
while|while
condition|(
name|in_size
operator|==
name|thr
operator|->
name|in_size
operator|&&
name|thr
operator|->
name|state
operator|==
name|THR_RUN
condition|)
name|mythread_cond_wait
argument_list|(
operator|&
name|thr
operator|->
name|cond
argument_list|,
operator|&
name|thr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|state
operator|=
name|thr
operator|->
name|state
expr_stmt|;
name|in_size
operator|=
name|thr
operator|->
name|in_size
expr_stmt|;
block|}
comment|// Return if we were asked to stop or exit.
if|if
condition|(
name|state
operator|>=
name|THR_STOP
condition|)
return|return
name|state
return|;
name|lzma_action
name|action
init|=
name|state
operator|==
name|THR_FINISH
condition|?
name|LZMA_FINISH
else|:
name|LZMA_RUN
decl_stmt|;
comment|// Limit the amount of input given to the Block encoder
comment|// at once. This way this thread can react fairly quickly
comment|// if the main thread wants us to stop or exit.
specifier|static
specifier|const
name|size_t
name|in_chunk_max
init|=
literal|16384
decl_stmt|;
name|size_t
name|in_limit
init|=
name|in_size
decl_stmt|;
if|if
condition|(
name|in_size
operator|-
name|in_pos
operator|>
name|in_chunk_max
condition|)
block|{
name|in_limit
operator|=
name|in_pos
operator|+
name|in_chunk_max
expr_stmt|;
name|action
operator|=
name|LZMA_RUN
expr_stmt|;
block|}
name|ret
operator|=
name|thr
operator|->
name|block_encoder
operator|.
name|code
argument_list|(
name|thr
operator|->
name|block_encoder
operator|.
name|coder
argument_list|,
name|thr
operator|->
name|allocator
argument_list|,
name|thr
operator|->
name|in
argument_list|,
operator|&
name|in_pos
argument_list|,
name|in_limit
argument_list|,
name|thr
operator|->
name|outbuf
operator|->
name|buf
argument_list|,
operator|&
name|thr
operator|->
name|outbuf
operator|->
name|size
argument_list|,
name|out_size
argument_list|,
name|action
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|==
name|LZMA_OK
operator|&&
name|thr
operator|->
name|outbuf
operator|->
name|size
operator|<
name|out_size
condition|)
do|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|LZMA_STREAM_END
case|:
name|assert
argument_list|(
name|state
operator|==
name|THR_FINISH
argument_list|)
expr_stmt|;
comment|// Encode the Block Header. By doing it after
comment|// the compression, we can store the Compressed Size
comment|// and Uncompressed Size fields.
name|ret
operator|=
name|lzma_block_header_encode
argument_list|(
operator|&
name|thr
operator|->
name|block_options
argument_list|,
name|thr
operator|->
name|outbuf
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
name|worker_error
argument_list|(
name|thr
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|THR_STOP
return|;
block|}
break|break;
case|case
name|LZMA_OK
case|:
comment|// The data was incompressible. Encode it using uncompressed
comment|// LZMA2 chunks.
comment|//
comment|// First wait that we have gotten all the input.
name|mythread_sync
argument_list|(
argument|thr->mutex
argument_list|)
block|{
while|while
condition|(
name|thr
operator|->
name|state
operator|==
name|THR_RUN
condition|)
name|mythread_cond_wait
argument_list|(
operator|&
name|thr
operator|->
name|cond
argument_list|,
operator|&
name|thr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|state
operator|=
name|thr
operator|->
name|state
expr_stmt|;
name|in_size
operator|=
name|thr
operator|->
name|in_size
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|>=
name|THR_STOP
condition|)
return|return
name|state
return|;
comment|// Do the encoding. This takes care of the Block Header too.
name|thr
operator|->
name|outbuf
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|lzma_block_uncomp_encode
argument_list|(
operator|&
name|thr
operator|->
name|block_options
argument_list|,
name|thr
operator|->
name|in
argument_list|,
name|in_size
argument_list|,
name|thr
operator|->
name|outbuf
operator|->
name|buf
argument_list|,
operator|&
name|thr
operator|->
name|outbuf
operator|->
name|size
argument_list|,
name|out_size
argument_list|)
expr_stmt|;
comment|// It shouldn't fail.
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
name|worker_error
argument_list|(
name|thr
argument_list|,
name|LZMA_PROG_ERROR
argument_list|)
expr_stmt|;
return|return
name|THR_STOP
return|;
block|}
break|break;
default|default:
name|worker_error
argument_list|(
name|thr
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|THR_STOP
return|;
block|}
comment|// Set the size information that will be read by the main thread
comment|// to write the Index field.
name|thr
operator|->
name|outbuf
operator|->
name|unpadded_size
operator|=
name|lzma_block_unpadded_size
argument_list|(
operator|&
name|thr
operator|->
name|block_options
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|thr
operator|->
name|outbuf
operator|->
name|unpadded_size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|thr
operator|->
name|outbuf
operator|->
name|uncompressed_size
operator|=
name|thr
operator|->
name|block_options
operator|.
name|uncompressed_size
expr_stmt|;
return|return
name|THR_FINISH
return|;
block|}
end_function

begin_function
specifier|static
name|MYTHREAD_RET_TYPE
name|worker_start
parameter_list|(
name|void
modifier|*
name|thr_ptr
parameter_list|)
block|{
name|worker_thread
modifier|*
name|thr
init|=
name|thr_ptr
decl_stmt|;
name|worker_state
name|state
init|=
name|THR_IDLE
decl_stmt|;
comment|// Init to silence a warning
while|while
condition|(
name|true
condition|)
block|{
comment|// Wait for work.
name|mythread_sync
argument_list|(
argument|thr->mutex
argument_list|)
block|{
while|while
condition|(
name|true
condition|)
block|{
comment|// The thread is already idle so if we are
comment|// requested to stop, just set the state.
if|if
condition|(
name|thr
operator|->
name|state
operator|==
name|THR_STOP
condition|)
block|{
name|thr
operator|->
name|state
operator|=
name|THR_IDLE
expr_stmt|;
name|mythread_cond_signal
argument_list|(
operator|&
name|thr
operator|->
name|cond
argument_list|)
expr_stmt|;
block|}
name|state
operator|=
name|thr
operator|->
name|state
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|THR_IDLE
condition|)
break|break;
name|mythread_cond_wait
argument_list|(
operator|&
name|thr
operator|->
name|cond
argument_list|,
operator|&
name|thr
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
name|state
operator|!=
name|THR_IDLE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|state
operator|!=
name|THR_STOP
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|<=
name|THR_FINISH
condition|)
name|state
operator|=
name|worker_encode
argument_list|(
name|thr
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|THR_EXIT
condition|)
break|break;
comment|// Mark the thread as idle unless the main thread has
comment|// told us to exit. Signal is needed for the case
comment|// where the main thread is waiting for the threads to stop.
name|mythread_sync
argument_list|(
argument|thr->mutex
argument_list|)
block|{
if|if
condition|(
name|thr
operator|->
name|state
operator|!=
name|THR_EXIT
condition|)
block|{
name|thr
operator|->
name|state
operator|=
name|THR_IDLE
expr_stmt|;
name|mythread_cond_signal
argument_list|(
operator|&
name|thr
operator|->
name|cond
argument_list|)
expr_stmt|;
block|}
block|}
name|mythread_sync
argument_list|(
argument|thr->coder->mutex
argument_list|)
block|{
comment|// Mark the output buffer as finished if
comment|// no errors occurred.
name|thr
operator|->
name|outbuf
operator|->
name|finished
operator|=
name|state
operator|==
name|THR_FINISH
expr_stmt|;
comment|// Update the main progress info.
name|thr
operator|->
name|coder
operator|->
name|progress_in
operator|+=
name|thr
operator|->
name|outbuf
operator|->
name|uncompressed_size
expr_stmt|;
name|thr
operator|->
name|coder
operator|->
name|progress_out
operator|+=
name|thr
operator|->
name|outbuf
operator|->
name|size
expr_stmt|;
name|thr
operator|->
name|progress_in
operator|=
literal|0
expr_stmt|;
name|thr
operator|->
name|progress_out
operator|=
literal|0
expr_stmt|;
comment|// Return this thread to the stack of free threads.
name|thr
operator|->
name|next
operator|=
name|thr
operator|->
name|coder
operator|->
name|threads_free
expr_stmt|;
name|thr
operator|->
name|coder
operator|->
name|threads_free
operator|=
name|thr
expr_stmt|;
name|mythread_cond_signal
argument_list|(
operator|&
name|thr
operator|->
name|coder
operator|->
name|cond
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Exiting, free the resources.
name|mythread_mutex_destroy
argument_list|(
operator|&
name|thr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|mythread_cond_destroy
argument_list|(
operator|&
name|thr
operator|->
name|cond
argument_list|)
expr_stmt|;
name|lzma_next_end
argument_list|(
operator|&
name|thr
operator|->
name|block_encoder
argument_list|,
name|thr
operator|->
name|allocator
argument_list|)
expr_stmt|;
name|lzma_free
argument_list|(
name|thr
operator|->
name|in
argument_list|,
name|thr
operator|->
name|allocator
argument_list|)
expr_stmt|;
return|return
name|MYTHREAD_RET_VALUE
return|;
block|}
end_function

begin_comment
comment|/// Make the threads stop but not exit. Optionally wait for them to stop.
end_comment

begin_function
specifier|static
name|void
name|threads_stop
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|bool
name|wait_for_threads
parameter_list|)
block|{
comment|// Tell the threads to stop.
for|for
control|(
name|uint32_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|coder
operator|->
name|threads_initialized
condition|;
operator|++
name|i
control|)
block|{
name|mythread_sync
argument_list|(
argument|coder->threads[i].mutex
argument_list|)
block|{
name|coder
operator|->
name|threads
index|[
name|i
index|]
operator|.
name|state
operator|=
name|THR_STOP
expr_stmt|;
name|mythread_cond_signal
argument_list|(
operator|&
name|coder
operator|->
name|threads
index|[
name|i
index|]
operator|.
name|cond
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|wait_for_threads
condition|)
return|return;
comment|// Wait for the threads to settle in the idle state.
for|for
control|(
name|uint32_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|coder
operator|->
name|threads_initialized
condition|;
operator|++
name|i
control|)
block|{
name|mythread_sync
argument_list|(
argument|coder->threads[i].mutex
argument_list|)
block|{
while|while
condition|(
name|coder
operator|->
name|threads
index|[
name|i
index|]
operator|.
name|state
operator|!=
name|THR_IDLE
condition|)
name|mythread_cond_wait
argument_list|(
operator|&
name|coder
operator|->
name|threads
index|[
name|i
index|]
operator|.
name|cond
argument_list|,
operator|&
name|coder
operator|->
name|threads
index|[
name|i
index|]
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/// Stop the threads and free the resources associated with them.
end_comment

begin_comment
comment|/// Wait until the threads have exited.
end_comment

begin_function
specifier|static
name|void
name|threads_end
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|)
block|{
for|for
control|(
name|uint32_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|coder
operator|->
name|threads_initialized
condition|;
operator|++
name|i
control|)
block|{
name|mythread_sync
argument_list|(
argument|coder->threads[i].mutex
argument_list|)
block|{
name|coder
operator|->
name|threads
index|[
name|i
index|]
operator|.
name|state
operator|=
name|THR_EXIT
expr_stmt|;
name|mythread_cond_signal
argument_list|(
operator|&
name|coder
operator|->
name|threads
index|[
name|i
index|]
operator|.
name|cond
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|uint32_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|coder
operator|->
name|threads_initialized
condition|;
operator|++
name|i
control|)
block|{
name|int
name|ret
init|=
name|mythread_join
argument_list|(
name|coder
operator|->
name|threads
index|[
name|i
index|]
operator|.
name|thread_id
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|ret
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ret
expr_stmt|;
block|}
name|lzma_free
argument_list|(
name|coder
operator|->
name|threads
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/// Initialize a new worker_thread structure and create a new thread.
end_comment

begin_function
specifier|static
name|lzma_ret
name|initialize_new_thread
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|)
block|{
name|worker_thread
modifier|*
name|thr
init|=
operator|&
name|coder
operator|->
name|threads
index|[
name|coder
operator|->
name|threads_initialized
index|]
decl_stmt|;
name|thr
operator|->
name|in
operator|=
name|lzma_alloc
argument_list|(
name|coder
operator|->
name|block_size
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|thr
operator|->
name|in
operator|==
name|NULL
condition|)
return|return
name|LZMA_MEM_ERROR
return|;
if|if
condition|(
name|mythread_mutex_init
argument_list|(
operator|&
name|thr
operator|->
name|mutex
argument_list|)
condition|)
goto|goto
name|error_mutex
goto|;
if|if
condition|(
name|mythread_cond_init
argument_list|(
operator|&
name|thr
operator|->
name|cond
argument_list|)
condition|)
goto|goto
name|error_cond
goto|;
name|thr
operator|->
name|state
operator|=
name|THR_IDLE
expr_stmt|;
name|thr
operator|->
name|allocator
operator|=
name|allocator
expr_stmt|;
name|thr
operator|->
name|coder
operator|=
name|coder
expr_stmt|;
name|thr
operator|->
name|progress_in
operator|=
literal|0
expr_stmt|;
name|thr
operator|->
name|progress_out
operator|=
literal|0
expr_stmt|;
name|thr
operator|->
name|block_encoder
operator|=
name|LZMA_NEXT_CODER_INIT
expr_stmt|;
if|if
condition|(
name|mythread_create
argument_list|(
operator|&
name|thr
operator|->
name|thread_id
argument_list|,
operator|&
name|worker_start
argument_list|,
name|thr
argument_list|)
condition|)
goto|goto
name|error_thread
goto|;
operator|++
name|coder
operator|->
name|threads_initialized
expr_stmt|;
name|coder
operator|->
name|thr
operator|=
name|thr
expr_stmt|;
return|return
name|LZMA_OK
return|;
name|error_thread
label|:
name|mythread_cond_destroy
argument_list|(
operator|&
name|thr
operator|->
name|cond
argument_list|)
expr_stmt|;
name|error_cond
label|:
name|mythread_mutex_destroy
argument_list|(
operator|&
name|thr
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|error_mutex
label|:
name|lzma_free
argument_list|(
name|thr
operator|->
name|in
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
return|return
name|LZMA_MEM_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|lzma_ret
name|get_thread
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|)
block|{
comment|// If there are no free output subqueues, there is no
comment|// point to try getting a thread.
if|if
condition|(
operator|!
name|lzma_outq_has_buf
argument_list|(
operator|&
name|coder
operator|->
name|outq
argument_list|)
condition|)
return|return
name|LZMA_OK
return|;
comment|// If there is a free structure on the stack, use it.
name|mythread_sync
argument_list|(
argument|coder->mutex
argument_list|)
block|{
if|if
condition|(
name|coder
operator|->
name|threads_free
operator|!=
name|NULL
condition|)
block|{
name|coder
operator|->
name|thr
operator|=
name|coder
operator|->
name|threads_free
expr_stmt|;
name|coder
operator|->
name|threads_free
operator|=
name|coder
operator|->
name|threads_free
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|coder
operator|->
name|thr
operator|==
name|NULL
condition|)
block|{
comment|// If there are no uninitialized structures left, return.
if|if
condition|(
name|coder
operator|->
name|threads_initialized
operator|==
name|coder
operator|->
name|threads_max
condition|)
return|return
name|LZMA_OK
return|;
comment|// Initialize a new thread.
name|return_if_error
argument_list|(
name|initialize_new_thread
argument_list|(
name|coder
argument_list|,
name|allocator
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Reset the parts of the thread state that have to be done
comment|// in the main thread.
name|mythread_sync
argument_list|(
argument|coder->thr->mutex
argument_list|)
block|{
name|coder
operator|->
name|thr
operator|->
name|state
operator|=
name|THR_RUN
expr_stmt|;
name|coder
operator|->
name|thr
operator|->
name|in_size
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|thr
operator|->
name|outbuf
operator|=
name|lzma_outq_get_buf
argument_list|(
operator|&
name|coder
operator|->
name|outq
argument_list|)
expr_stmt|;
name|mythread_cond_signal
argument_list|(
operator|&
name|coder
operator|->
name|thr
operator|->
name|cond
argument_list|)
expr_stmt|;
block|}
return|return
name|LZMA_OK
return|;
block|}
end_function

begin_function
specifier|static
name|lzma_ret
name|stream_encode_in
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|uint8_t
modifier|*
specifier|restrict
name|in
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|in_pos
parameter_list|,
name|size_t
name|in_size
parameter_list|,
name|lzma_action
name|action
parameter_list|)
block|{
while|while
condition|(
operator|*
name|in_pos
operator|<
name|in_size
operator|||
operator|(
name|coder
operator|->
name|thr
operator|!=
name|NULL
operator|&&
name|action
operator|!=
name|LZMA_RUN
operator|)
condition|)
block|{
if|if
condition|(
name|coder
operator|->
name|thr
operator|==
name|NULL
condition|)
block|{
comment|// Get a new thread.
specifier|const
name|lzma_ret
name|ret
init|=
name|get_thread
argument_list|(
name|coder
argument_list|,
name|allocator
argument_list|)
decl_stmt|;
if|if
condition|(
name|coder
operator|->
name|thr
operator|==
name|NULL
condition|)
return|return
name|ret
return|;
block|}
comment|// Copy the input data to thread's buffer.
name|size_t
name|thr_in_size
init|=
name|coder
operator|->
name|thr
operator|->
name|in_size
decl_stmt|;
name|lzma_bufcpy
argument_list|(
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|,
name|coder
operator|->
name|thr
operator|->
name|in
argument_list|,
operator|&
name|thr_in_size
argument_list|,
name|coder
operator|->
name|block_size
argument_list|)
expr_stmt|;
comment|// Tell the Block encoder to finish if
comment|//  - it has got block_size bytes of input; or
comment|//  - all input was used and LZMA_FINISH, LZMA_FULL_FLUSH,
comment|//    or LZMA_FULL_BARRIER was used.
comment|//
comment|// TODO: LZMA_SYNC_FLUSH and LZMA_SYNC_BARRIER.
specifier|const
name|bool
name|finish
init|=
name|thr_in_size
operator|==
name|coder
operator|->
name|block_size
operator|||
operator|(
operator|*
name|in_pos
operator|==
name|in_size
operator|&&
name|action
operator|!=
name|LZMA_RUN
operator|)
decl_stmt|;
name|bool
name|block_error
init|=
name|false
decl_stmt|;
name|mythread_sync
argument_list|(
argument|coder->thr->mutex
argument_list|)
block|{
if|if
condition|(
name|coder
operator|->
name|thr
operator|->
name|state
operator|==
name|THR_IDLE
condition|)
block|{
comment|// Something has gone wrong with the Block
comment|// encoder. It has set coder->thread_error
comment|// which we will read a few lines later.
name|block_error
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
comment|// Tell the Block encoder its new amount
comment|// of input and update the state if needed.
name|coder
operator|->
name|thr
operator|->
name|in_size
operator|=
name|thr_in_size
expr_stmt|;
if|if
condition|(
name|finish
condition|)
name|coder
operator|->
name|thr
operator|->
name|state
operator|=
name|THR_FINISH
expr_stmt|;
name|mythread_cond_signal
argument_list|(
operator|&
name|coder
operator|->
name|thr
operator|->
name|cond
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|block_error
condition|)
block|{
name|lzma_ret
name|ret
decl_stmt|;
name|mythread_sync
argument_list|(
argument|coder->mutex
argument_list|)
block|{
name|ret
operator|=
name|coder
operator|->
name|thread_error
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
if|if
condition|(
name|finish
condition|)
name|coder
operator|->
name|thr
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|LZMA_OK
return|;
block|}
end_function

begin_comment
comment|/// Wait until more input can be consumed, more output can be read, or
end_comment

begin_comment
comment|/// an optional timeout is reached.
end_comment

begin_function
specifier|static
name|bool
name|wait_for_work
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|mythread_condtime
modifier|*
name|wait_abs
parameter_list|,
name|bool
modifier|*
name|has_blocked
parameter_list|,
name|bool
name|has_input
parameter_list|)
block|{
if|if
condition|(
name|coder
operator|->
name|timeout
operator|!=
literal|0
operator|&&
operator|!
operator|*
name|has_blocked
condition|)
block|{
comment|// Every time when stream_encode_mt() is called via
comment|// lzma_code(), *has_blocked starts as false. We set it
comment|// to true here and calculate the absolute time when
comment|// we must return if there's nothing to do.
comment|//
comment|// The idea of *has_blocked is to avoid unneeded calls
comment|// to mythread_condtime_set(), which may do a syscall
comment|// depending on the operating system.
operator|*
name|has_blocked
operator|=
name|true
expr_stmt|;
name|mythread_condtime_set
argument_list|(
name|wait_abs
argument_list|,
operator|&
name|coder
operator|->
name|cond
argument_list|,
name|coder
operator|->
name|timeout
argument_list|)
expr_stmt|;
block|}
name|bool
name|timed_out
init|=
name|false
decl_stmt|;
name|mythread_sync
argument_list|(
argument|coder->mutex
argument_list|)
block|{
comment|// There are four things that we wait. If one of them
comment|// becomes possible, we return.
comment|//  - If there is input left, we need to get a free
comment|//    worker thread and an output buffer for it.
comment|//  - Data ready to be read from the output queue.
comment|//  - A worker thread indicates an error.
comment|//  - Time out occurs.
while|while
condition|(
operator|(
operator|!
name|has_input
operator|||
name|coder
operator|->
name|threads_free
operator|==
name|NULL
operator|||
operator|!
name|lzma_outq_has_buf
argument_list|(
operator|&
name|coder
operator|->
name|outq
argument_list|)
operator|)
operator|&&
operator|!
name|lzma_outq_is_readable
argument_list|(
operator|&
name|coder
operator|->
name|outq
argument_list|)
operator|&&
name|coder
operator|->
name|thread_error
operator|==
name|LZMA_OK
operator|&&
operator|!
name|timed_out
condition|)
block|{
if|if
condition|(
name|coder
operator|->
name|timeout
operator|!=
literal|0
condition|)
name|timed_out
operator|=
name|mythread_cond_timedwait
argument_list|(
operator|&
name|coder
operator|->
name|cond
argument_list|,
operator|&
name|coder
operator|->
name|mutex
argument_list|,
name|wait_abs
argument_list|)
operator|!=
literal|0
expr_stmt|;
else|else
name|mythread_cond_wait
argument_list|(
operator|&
name|coder
operator|->
name|cond
argument_list|,
operator|&
name|coder
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|timed_out
return|;
block|}
end_function

begin_function
specifier|static
name|lzma_ret
name|stream_encode_mt
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|uint8_t
modifier|*
specifier|restrict
name|in
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|in_pos
parameter_list|,
name|size_t
name|in_size
parameter_list|,
name|uint8_t
modifier|*
specifier|restrict
name|out
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|out_pos
parameter_list|,
name|size_t
name|out_size
parameter_list|,
name|lzma_action
name|action
parameter_list|)
block|{
switch|switch
condition|(
name|coder
operator|->
name|sequence
condition|)
block|{
case|case
name|SEQ_STREAM_HEADER
case|:
name|lzma_bufcpy
argument_list|(
name|coder
operator|->
name|header
argument_list|,
operator|&
name|coder
operator|->
name|header_pos
argument_list|,
sizeof|sizeof
argument_list|(
name|coder
operator|->
name|header
argument_list|)
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|header_pos
operator|<
sizeof|sizeof
argument_list|(
name|coder
operator|->
name|header
argument_list|)
condition|)
return|return
name|LZMA_OK
return|;
name|coder
operator|->
name|header_pos
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_BLOCK
expr_stmt|;
comment|// Fall through
case|case
name|SEQ_BLOCK
case|:
block|{
comment|// Initialized to silence warnings.
name|lzma_vli
name|unpadded_size
init|=
literal|0
decl_stmt|;
name|lzma_vli
name|uncompressed_size
init|=
literal|0
decl_stmt|;
name|lzma_ret
name|ret
init|=
name|LZMA_OK
decl_stmt|;
comment|// These are for wait_for_work().
name|bool
name|has_blocked
init|=
name|false
decl_stmt|;
name|mythread_condtime
name|wait_abs
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|mythread_sync
argument_list|(
argument|coder->mutex
argument_list|)
block|{
comment|// Check for Block encoder errors.
name|ret
operator|=
name|coder
operator|->
name|thread_error
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
name|assert
argument_list|(
name|ret
operator|!=
name|LZMA_STREAM_END
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// Try to read compressed data to out[].
name|ret
operator|=
name|lzma_outq_read
argument_list|(
operator|&
name|coder
operator|->
name|outq
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|,
operator|&
name|unpadded_size
argument_list|,
operator|&
name|uncompressed_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|LZMA_STREAM_END
condition|)
block|{
comment|// End of Block. Add it to the Index.
name|ret
operator|=
name|lzma_index_append
argument_list|(
name|coder
operator|->
name|index
argument_list|,
name|allocator
argument_list|,
name|unpadded_size
argument_list|,
name|uncompressed_size
argument_list|)
expr_stmt|;
comment|// If we didn't fill the output buffer yet,
comment|// try to read more data. Maybe the next
comment|// outbuf has been finished already too.
if|if
condition|(
operator|*
name|out_pos
operator|<
name|out_size
condition|)
continue|continue;
block|}
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
comment|// coder->thread_error was set or
comment|// lzma_index_append() failed.
name|threads_stop
argument_list|(
name|coder
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|// Try to give uncompressed data to a worker thread.
name|ret
operator|=
name|stream_encode_in
argument_list|(
name|coder
argument_list|,
name|allocator
argument_list|,
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|,
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
name|threads_stop
argument_list|(
name|coder
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|// See if we should wait or return.
comment|//
comment|// TODO: LZMA_SYNC_FLUSH and LZMA_SYNC_BARRIER.
if|if
condition|(
operator|*
name|in_pos
operator|==
name|in_size
condition|)
block|{
comment|// LZMA_RUN: More data is probably coming
comment|// so return to let the caller fill the
comment|// input buffer.
if|if
condition|(
name|action
operator|==
name|LZMA_RUN
condition|)
return|return
name|LZMA_OK
return|;
comment|// LZMA_FULL_BARRIER: The same as with
comment|// LZMA_RUN but tell the caller that the
comment|// barrier was completed.
if|if
condition|(
name|action
operator|==
name|LZMA_FULL_BARRIER
condition|)
return|return
name|LZMA_STREAM_END
return|;
comment|// Finishing or flushing isn't completed until
comment|// all input data has been encoded and copied
comment|// to the output buffer.
if|if
condition|(
name|lzma_outq_is_empty
argument_list|(
operator|&
name|coder
operator|->
name|outq
argument_list|)
condition|)
block|{
comment|// LZMA_FINISH: Continue to encode
comment|// the Index field.
if|if
condition|(
name|action
operator|==
name|LZMA_FINISH
condition|)
break|break;
comment|// LZMA_FULL_FLUSH: Return to tell
comment|// the caller that flushing was
comment|// completed.
if|if
condition|(
name|action
operator|==
name|LZMA_FULL_FLUSH
condition|)
return|return
name|LZMA_STREAM_END
return|;
block|}
block|}
comment|// Return if there is no output space left.
comment|// This check must be done after testing the input
comment|// buffer, because we might want to use a different
comment|// return code.
if|if
condition|(
operator|*
name|out_pos
operator|==
name|out_size
condition|)
return|return
name|LZMA_OK
return|;
comment|// Neither in nor out has been used completely.
comment|// Wait until there's something we can do.
if|if
condition|(
name|wait_for_work
argument_list|(
name|coder
argument_list|,
operator|&
name|wait_abs
argument_list|,
operator|&
name|has_blocked
argument_list|,
operator|*
name|in_pos
operator|<
name|in_size
argument_list|)
condition|)
return|return
name|LZMA_TIMED_OUT
return|;
block|}
comment|// All Blocks have been encoded and the threads have stopped.
comment|// Prepare to encode the Index field.
name|return_if_error
argument_list|(
name|lzma_index_encoder_init
argument_list|(
operator|&
name|coder
operator|->
name|index_encoder
argument_list|,
name|allocator
argument_list|,
name|coder
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_INDEX
expr_stmt|;
comment|// Update the progress info to take the Index and
comment|// Stream Footer into account. Those are very fast to encode
comment|// so in terms of progress information they can be thought
comment|// to be ready to be copied out.
name|coder
operator|->
name|progress_out
operator|+=
name|lzma_index_size
argument_list|(
name|coder
operator|->
name|index
argument_list|)
operator|+
name|LZMA_STREAM_HEADER_SIZE
expr_stmt|;
block|}
comment|// Fall through
case|case
name|SEQ_INDEX
case|:
block|{
comment|// Call the Index encoder. It doesn't take any input, so
comment|// those pointers can be NULL.
specifier|const
name|lzma_ret
name|ret
init|=
name|coder
operator|->
name|index_encoder
operator|.
name|code
argument_list|(
name|coder
operator|->
name|index_encoder
operator|.
name|coder
argument_list|,
name|allocator
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|,
name|LZMA_RUN
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_STREAM_END
condition|)
return|return
name|ret
return|;
comment|// Encode the Stream Footer into coder->buffer.
name|coder
operator|->
name|stream_flags
operator|.
name|backward_size
operator|=
name|lzma_index_size
argument_list|(
name|coder
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|lzma_stream_footer_encode
argument_list|(
operator|&
name|coder
operator|->
name|stream_flags
argument_list|,
name|coder
operator|->
name|header
argument_list|)
operator|!=
name|LZMA_OK
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_STREAM_FOOTER
expr_stmt|;
block|}
comment|// Fall through
case|case
name|SEQ_STREAM_FOOTER
case|:
name|lzma_bufcpy
argument_list|(
name|coder
operator|->
name|header
argument_list|,
operator|&
name|coder
operator|->
name|header_pos
argument_list|,
sizeof|sizeof
argument_list|(
name|coder
operator|->
name|header
argument_list|)
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|)
expr_stmt|;
return|return
name|coder
operator|->
name|header_pos
operator|<
sizeof|sizeof
argument_list|(
name|coder
operator|->
name|header
argument_list|)
condition|?
name|LZMA_OK
else|:
name|LZMA_STREAM_END
return|;
block|}
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|LZMA_PROG_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|stream_encoder_mt_end
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|)
block|{
comment|// Threads must be killed before the output queue can be freed.
name|threads_end
argument_list|(
name|coder
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|lzma_outq_end
argument_list|(
operator|&
name|coder
operator|->
name|outq
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|coder
operator|->
name|filters
index|[
name|i
index|]
operator|.
name|id
operator|!=
name|LZMA_VLI_UNKNOWN
condition|;
operator|++
name|i
control|)
name|lzma_free
argument_list|(
name|coder
operator|->
name|filters
index|[
name|i
index|]
operator|.
name|options
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|lzma_next_end
argument_list|(
operator|&
name|coder
operator|->
name|index_encoder
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|lzma_index_end
argument_list|(
name|coder
operator|->
name|index
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|mythread_cond_destroy
argument_list|(
operator|&
name|coder
operator|->
name|cond
argument_list|)
expr_stmt|;
name|mythread_mutex_destroy
argument_list|(
operator|&
name|coder
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|lzma_free
argument_list|(
name|coder
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/// Options handling for lzma_stream_encoder_mt_init() and
end_comment

begin_comment
comment|/// lzma_stream_encoder_mt_memusage()
end_comment

begin_function
specifier|static
name|lzma_ret
name|get_options
parameter_list|(
specifier|const
name|lzma_mt
modifier|*
name|options
parameter_list|,
name|lzma_options_easy
modifier|*
name|opt_easy
parameter_list|,
specifier|const
name|lzma_filter
modifier|*
modifier|*
name|filters
parameter_list|,
name|uint64_t
modifier|*
name|block_size
parameter_list|,
name|uint64_t
modifier|*
name|outbuf_size_max
parameter_list|)
block|{
comment|// Validate some of the options.
if|if
condition|(
name|options
operator|==
name|NULL
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
if|if
condition|(
name|options
operator|->
name|flags
operator|!=
literal|0
operator|||
name|options
operator|->
name|threads
operator|==
literal|0
operator|||
name|options
operator|->
name|threads
operator|>
name|LZMA_THREADS_MAX
condition|)
return|return
name|LZMA_OPTIONS_ERROR
return|;
if|if
condition|(
name|options
operator|->
name|filters
operator|!=
name|NULL
condition|)
block|{
comment|// Filter chain was given, use it as is.
operator|*
name|filters
operator|=
name|options
operator|->
name|filters
expr_stmt|;
block|}
else|else
block|{
comment|// Use a preset.
if|if
condition|(
name|lzma_easy_preset
argument_list|(
name|opt_easy
argument_list|,
name|options
operator|->
name|preset
argument_list|)
condition|)
return|return
name|LZMA_OPTIONS_ERROR
return|;
operator|*
name|filters
operator|=
name|opt_easy
operator|->
name|filters
expr_stmt|;
block|}
comment|// Block size
if|if
condition|(
name|options
operator|->
name|block_size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|options
operator|->
name|block_size
operator|>
name|BLOCK_SIZE_MAX
condition|)
return|return
name|LZMA_OPTIONS_ERROR
return|;
operator|*
name|block_size
operator|=
name|options
operator|->
name|block_size
expr_stmt|;
block|}
else|else
block|{
comment|// Determine the Block size from the filter chain.
operator|*
name|block_size
operator|=
name|lzma_mt_block_size
argument_list|(
operator|*
name|filters
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|block_size
operator|==
literal|0
condition|)
return|return
name|LZMA_OPTIONS_ERROR
return|;
name|assert
argument_list|(
operator|*
name|block_size
operator|<=
name|BLOCK_SIZE_MAX
argument_list|)
expr_stmt|;
block|}
comment|// Calculate the maximum amount output that a single output buffer
comment|// may need to hold. This is the same as the maximum total size of
comment|// a Block.
operator|*
name|outbuf_size_max
operator|=
name|lzma_block_buffer_bound64
argument_list|(
operator|*
name|block_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|outbuf_size_max
operator|==
literal|0
condition|)
return|return
name|LZMA_MEM_ERROR
return|;
return|return
name|LZMA_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_progress
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|uint64_t
modifier|*
name|progress_in
parameter_list|,
name|uint64_t
modifier|*
name|progress_out
parameter_list|)
block|{
comment|// Lock coder->mutex to prevent finishing threads from moving their
comment|// progress info from the worker_thread structure to lzma_coder.
name|mythread_sync
argument_list|(
argument|coder->mutex
argument_list|)
block|{
operator|*
name|progress_in
operator|=
name|coder
operator|->
name|progress_in
expr_stmt|;
operator|*
name|progress_out
operator|=
name|coder
operator|->
name|progress_out
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|coder
operator|->
name|threads_initialized
condition|;
operator|++
name|i
control|)
block|{
name|mythread_sync
argument_list|(
argument|coder->threads[i].mutex
argument_list|)
block|{
operator|*
name|progress_in
operator|+=
name|coder
operator|->
name|threads
index|[
name|i
index|]
operator|.
name|progress_in
expr_stmt|;
operator|*
name|progress_out
operator|+=
name|coder
operator|->
name|threads
index|[
name|i
index|]
operator|.
name|progress_out
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|lzma_ret
name|stream_encoder_mt_init
parameter_list|(
name|lzma_next_coder
modifier|*
name|next
parameter_list|,
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|lzma_mt
modifier|*
name|options
parameter_list|)
block|{
name|lzma_next_coder_init
argument_list|(
operator|&
name|stream_encoder_mt_init
argument_list|,
name|next
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
comment|// Get the filter chain.
name|lzma_options_easy
name|easy
decl_stmt|;
specifier|const
name|lzma_filter
modifier|*
name|filters
decl_stmt|;
name|uint64_t
name|block_size
decl_stmt|;
name|uint64_t
name|outbuf_size_max
decl_stmt|;
name|return_if_error
argument_list|(
name|get_options
argument_list|(
name|options
argument_list|,
operator|&
name|easy
argument_list|,
operator|&
name|filters
argument_list|,
operator|&
name|block_size
argument_list|,
operator|&
name|outbuf_size_max
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|SIZE_MAX
operator|<
name|UINT64_MAX
if|if
condition|(
name|block_size
operator|>
name|SIZE_MAX
condition|)
return|return
name|LZMA_MEM_ERROR
return|;
endif|#
directive|endif
comment|// Validate the filter chain so that we can give an error in this
comment|// function instead of delaying it to the first call to lzma_code().
comment|// The memory usage calculation verifies the filter chain as
comment|// a side effect so we take advatange of that.
if|if
condition|(
name|lzma_raw_encoder_memusage
argument_list|(
name|filters
argument_list|)
operator|==
name|UINT64_MAX
condition|)
return|return
name|LZMA_OPTIONS_ERROR
return|;
comment|// Validate the Check ID.
if|if
condition|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|options
operator|->
name|check
argument_list|)
operator|>
name|LZMA_CHECK_ID_MAX
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
if|if
condition|(
operator|!
name|lzma_check_is_supported
argument_list|(
name|options
operator|->
name|check
argument_list|)
condition|)
return|return
name|LZMA_UNSUPPORTED_CHECK
return|;
comment|// Allocate and initialize the base structure if needed.
if|if
condition|(
name|next
operator|->
name|coder
operator|==
name|NULL
condition|)
block|{
name|next
operator|->
name|coder
operator|=
name|lzma_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lzma_coder
argument_list|)
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|coder
operator|==
name|NULL
condition|)
return|return
name|LZMA_MEM_ERROR
return|;
comment|// For the mutex and condition variable initializations
comment|// the error handling has to be done here because
comment|// stream_encoder_mt_end() doesn't know if they have
comment|// already been initialized or not.
if|if
condition|(
name|mythread_mutex_init
argument_list|(
operator|&
name|next
operator|->
name|coder
operator|->
name|mutex
argument_list|)
condition|)
block|{
name|lzma_free
argument_list|(
name|next
operator|->
name|coder
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|next
operator|->
name|coder
operator|=
name|NULL
expr_stmt|;
return|return
name|LZMA_MEM_ERROR
return|;
block|}
if|if
condition|(
name|mythread_cond_init
argument_list|(
operator|&
name|next
operator|->
name|coder
operator|->
name|cond
argument_list|)
condition|)
block|{
name|mythread_mutex_destroy
argument_list|(
operator|&
name|next
operator|->
name|coder
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|lzma_free
argument_list|(
name|next
operator|->
name|coder
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|next
operator|->
name|coder
operator|=
name|NULL
expr_stmt|;
return|return
name|LZMA_MEM_ERROR
return|;
block|}
name|next
operator|->
name|code
operator|=
operator|&
name|stream_encode_mt
expr_stmt|;
name|next
operator|->
name|end
operator|=
operator|&
name|stream_encoder_mt_end
expr_stmt|;
name|next
operator|->
name|get_progress
operator|=
operator|&
name|get_progress
expr_stmt|;
comment|// 		next->update =&stream_encoder_mt_update;
name|next
operator|->
name|coder
operator|->
name|filters
index|[
literal|0
index|]
operator|.
name|id
operator|=
name|LZMA_VLI_UNKNOWN
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|index_encoder
operator|=
name|LZMA_NEXT_CODER_INIT
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|index
operator|=
name|NULL
expr_stmt|;
name|memzero
argument_list|(
operator|&
name|next
operator|->
name|coder
operator|->
name|outq
argument_list|,
sizeof|sizeof
argument_list|(
name|next
operator|->
name|coder
operator|->
name|outq
argument_list|)
argument_list|)
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|threads
operator|=
name|NULL
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|threads_max
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|threads_initialized
operator|=
literal|0
expr_stmt|;
block|}
comment|// Basic initializations
name|next
operator|->
name|coder
operator|->
name|sequence
operator|=
name|SEQ_STREAM_HEADER
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|block_size
operator|=
call|(
name|size_t
call|)
argument_list|(
name|block_size
argument_list|)
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|thread_error
operator|=
name|LZMA_OK
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|thr
operator|=
name|NULL
expr_stmt|;
comment|// Allocate the thread-specific base structures.
name|assert
argument_list|(
name|options
operator|->
name|threads
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|coder
operator|->
name|threads_max
operator|!=
name|options
operator|->
name|threads
condition|)
block|{
name|threads_end
argument_list|(
name|next
operator|->
name|coder
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|threads
operator|=
name|NULL
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|threads_max
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|threads_initialized
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|threads_free
operator|=
name|NULL
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|threads
operator|=
name|lzma_alloc
argument_list|(
name|options
operator|->
name|threads
operator|*
sizeof|sizeof
argument_list|(
name|worker_thread
argument_list|)
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|coder
operator|->
name|threads
operator|==
name|NULL
condition|)
return|return
name|LZMA_MEM_ERROR
return|;
name|next
operator|->
name|coder
operator|->
name|threads_max
operator|=
name|options
operator|->
name|threads
expr_stmt|;
block|}
else|else
block|{
comment|// Reuse the old structures and threads. Tell the running
comment|// threads to stop and wait until they have stopped.
name|threads_stop
argument_list|(
name|next
operator|->
name|coder
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
comment|// Output queue
name|return_if_error
argument_list|(
name|lzma_outq_init
argument_list|(
operator|&
name|next
operator|->
name|coder
operator|->
name|outq
argument_list|,
name|allocator
argument_list|,
name|outbuf_size_max
argument_list|,
name|options
operator|->
name|threads
argument_list|)
argument_list|)
expr_stmt|;
comment|// Timeout
name|next
operator|->
name|coder
operator|->
name|timeout
operator|=
name|options
operator|->
name|timeout
expr_stmt|;
comment|// Free the old filter chain and copy the new one.
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|next
operator|->
name|coder
operator|->
name|filters
index|[
name|i
index|]
operator|.
name|id
operator|!=
name|LZMA_VLI_UNKNOWN
condition|;
operator|++
name|i
control|)
name|lzma_free
argument_list|(
name|next
operator|->
name|coder
operator|->
name|filters
index|[
name|i
index|]
operator|.
name|options
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|return_if_error
argument_list|(
name|lzma_filters_copy
argument_list|(
name|filters
argument_list|,
name|next
operator|->
name|coder
operator|->
name|filters
argument_list|,
name|allocator
argument_list|)
argument_list|)
expr_stmt|;
comment|// Index
name|lzma_index_end
argument_list|(
name|next
operator|->
name|coder
operator|->
name|index
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|index
operator|=
name|lzma_index_init
argument_list|(
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|coder
operator|->
name|index
operator|==
name|NULL
condition|)
return|return
name|LZMA_MEM_ERROR
return|;
comment|// Stream Header
name|next
operator|->
name|coder
operator|->
name|stream_flags
operator|.
name|version
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|stream_flags
operator|.
name|check
operator|=
name|options
operator|->
name|check
expr_stmt|;
name|return_if_error
argument_list|(
name|lzma_stream_header_encode
argument_list|(
operator|&
name|next
operator|->
name|coder
operator|->
name|stream_flags
argument_list|,
name|next
operator|->
name|coder
operator|->
name|header
argument_list|)
argument_list|)
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|header_pos
operator|=
literal|0
expr_stmt|;
comment|// Progress info
name|next
operator|->
name|coder
operator|->
name|progress_in
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|progress_out
operator|=
name|LZMA_STREAM_HEADER_SIZE
expr_stmt|;
return|return
name|LZMA_OK
return|;
block|}
end_function

begin_extern
extern|extern LZMA_API(lzma_ret
end_extern

begin_macro
unit|)
name|lzma_stream_encoder_mt
argument_list|(
argument|lzma_stream *strm
argument_list|,
argument|const lzma_mt *options
argument_list|)
end_macro

begin_block
block|{
name|lzma_next_strm_init
argument_list|(
name|stream_encoder_mt_init
argument_list|,
name|strm
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|strm
operator|->
name|internal
operator|->
name|supported_actions
index|[
name|LZMA_RUN
index|]
operator|=
name|true
expr_stmt|;
comment|// 	strm->internal->supported_actions[LZMA_SYNC_FLUSH] = true;
name|strm
operator|->
name|internal
operator|->
name|supported_actions
index|[
name|LZMA_FULL_FLUSH
index|]
operator|=
name|true
expr_stmt|;
name|strm
operator|->
name|internal
operator|->
name|supported_actions
index|[
name|LZMA_FULL_BARRIER
index|]
operator|=
name|true
expr_stmt|;
name|strm
operator|->
name|internal
operator|->
name|supported_actions
index|[
name|LZMA_FINISH
index|]
operator|=
name|true
expr_stmt|;
return|return
name|LZMA_OK
return|;
block|}
end_block

begin_comment
comment|// This function name is a monster but it's consistent with the older
end_comment

begin_comment
comment|// monster names. :-( 31 chars is the max that C99 requires so in that
end_comment

begin_comment
comment|// sense it's not too long. ;-)
end_comment

begin_extern
extern|extern LZMA_API(uint64_t
end_extern

begin_macro
unit|)
name|lzma_stream_encoder_mt_memusage
argument_list|(
argument|const lzma_mt *options
argument_list|)
end_macro

begin_block
block|{
name|lzma_options_easy
name|easy
decl_stmt|;
specifier|const
name|lzma_filter
modifier|*
name|filters
decl_stmt|;
name|uint64_t
name|block_size
decl_stmt|;
name|uint64_t
name|outbuf_size_max
decl_stmt|;
if|if
condition|(
name|get_options
argument_list|(
name|options
argument_list|,
operator|&
name|easy
argument_list|,
operator|&
name|filters
argument_list|,
operator|&
name|block_size
argument_list|,
operator|&
name|outbuf_size_max
argument_list|)
operator|!=
name|LZMA_OK
condition|)
return|return
name|UINT64_MAX
return|;
comment|// Memory usage of the input buffers
specifier|const
name|uint64_t
name|inbuf_memusage
init|=
name|options
operator|->
name|threads
operator|*
name|block_size
decl_stmt|;
comment|// Memory usage of the filter encoders
name|uint64_t
name|filters_memusage
init|=
name|lzma_raw_encoder_memusage
argument_list|(
name|filters
argument_list|)
decl_stmt|;
if|if
condition|(
name|filters_memusage
operator|==
name|UINT64_MAX
condition|)
return|return
name|UINT64_MAX
return|;
name|filters_memusage
operator|*=
name|options
operator|->
name|threads
expr_stmt|;
comment|// Memory usage of the output queue
specifier|const
name|uint64_t
name|outq_memusage
init|=
name|lzma_outq_memusage
argument_list|(
name|outbuf_size_max
argument_list|,
name|options
operator|->
name|threads
argument_list|)
decl_stmt|;
if|if
condition|(
name|outq_memusage
operator|==
name|UINT64_MAX
condition|)
return|return
name|UINT64_MAX
return|;
comment|// Sum them with overflow checking.
name|uint64_t
name|total_memusage
init|=
name|LZMA_MEMUSAGE_BASE
operator|+
sizeof|sizeof
argument_list|(
name|lzma_coder
argument_list|)
operator|+
name|options
operator|->
name|threads
operator|*
sizeof|sizeof
argument_list|(
name|worker_thread
argument_list|)
decl_stmt|;
if|if
condition|(
name|UINT64_MAX
operator|-
name|total_memusage
operator|<
name|inbuf_memusage
condition|)
return|return
name|UINT64_MAX
return|;
name|total_memusage
operator|+=
name|inbuf_memusage
expr_stmt|;
if|if
condition|(
name|UINT64_MAX
operator|-
name|total_memusage
operator|<
name|filters_memusage
condition|)
return|return
name|UINT64_MAX
return|;
name|total_memusage
operator|+=
name|filters_memusage
expr_stmt|;
if|if
condition|(
name|UINT64_MAX
operator|-
name|total_memusage
operator|<
name|outq_memusage
condition|)
return|return
name|UINT64_MAX
return|;
return|return
name|total_memusage
operator|+
name|outq_memusage
return|;
block|}
end_block

end_unit

