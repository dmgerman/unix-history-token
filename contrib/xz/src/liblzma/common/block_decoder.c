begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       block_decoder.c
end_comment

begin_comment
comment|/// \brief      Decodes .xz Blocks
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Author:     Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"block_decoder.h"
end_include

begin_include
include|#
directive|include
file|"filter_decoder.h"
end_include

begin_include
include|#
directive|include
file|"check.h"
end_include

begin_struct
struct|struct
name|lzma_coder_s
block|{
enum|enum
block|{
name|SEQ_CODE
block|,
name|SEQ_PADDING
block|,
name|SEQ_CHECK
block|, 	}
name|sequence
enum|;
comment|/// The filters in the chain; initialized with lzma_raw_decoder_init().
name|lzma_next_coder
name|next
decl_stmt|;
comment|/// Decoding options; we also write Compressed Size and Uncompressed
comment|/// Size back to this structure when the decoding has been finished.
name|lzma_block
modifier|*
name|block
decl_stmt|;
comment|/// Compressed Size calculated while decoding
name|lzma_vli
name|compressed_size
decl_stmt|;
comment|/// Uncompressed Size calculated while decoding
name|lzma_vli
name|uncompressed_size
decl_stmt|;
comment|/// Maximum allowed Compressed Size; this takes into account the
comment|/// size of the Block Header and Check fields when Compressed Size
comment|/// is unknown.
name|lzma_vli
name|compressed_limit
decl_stmt|;
comment|/// Position when reading the Check field
name|size_t
name|check_pos
decl_stmt|;
comment|/// Check of the uncompressed data
name|lzma_check_state
name|check
decl_stmt|;
comment|/// True if the integrity check won't be calculated and verified.
name|bool
name|ignore_check
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|bool
name|update_size
parameter_list|(
name|lzma_vli
modifier|*
name|size
parameter_list|,
name|lzma_vli
name|add
parameter_list|,
name|lzma_vli
name|limit
parameter_list|)
block|{
if|if
condition|(
name|limit
operator|>
name|LZMA_VLI_MAX
condition|)
name|limit
operator|=
name|LZMA_VLI_MAX
expr_stmt|;
if|if
condition|(
name|limit
operator|<
operator|*
name|size
operator|||
name|limit
operator|-
operator|*
name|size
operator|<
name|add
condition|)
return|return
name|true
return|;
operator|*
name|size
operator|+=
name|add
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|is_size_valid
parameter_list|(
name|lzma_vli
name|size
parameter_list|,
name|lzma_vli
name|reference
parameter_list|)
block|{
return|return
name|reference
operator|==
name|LZMA_VLI_UNKNOWN
operator|||
name|reference
operator|==
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|lzma_ret
name|block_decode
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|uint8_t
modifier|*
specifier|restrict
name|in
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|in_pos
parameter_list|,
name|size_t
name|in_size
parameter_list|,
name|uint8_t
modifier|*
specifier|restrict
name|out
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|out_pos
parameter_list|,
name|size_t
name|out_size
parameter_list|,
name|lzma_action
name|action
parameter_list|)
block|{
switch|switch
condition|(
name|coder
operator|->
name|sequence
condition|)
block|{
case|case
name|SEQ_CODE
case|:
block|{
specifier|const
name|size_t
name|in_start
init|=
operator|*
name|in_pos
decl_stmt|;
specifier|const
name|size_t
name|out_start
init|=
operator|*
name|out_pos
decl_stmt|;
specifier|const
name|lzma_ret
name|ret
init|=
name|coder
operator|->
name|next
operator|.
name|code
argument_list|(
name|coder
operator|->
name|next
operator|.
name|coder
argument_list|,
name|allocator
argument_list|,
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|,
name|action
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|in_used
init|=
operator|*
name|in_pos
operator|-
name|in_start
decl_stmt|;
specifier|const
name|size_t
name|out_used
init|=
operator|*
name|out_pos
operator|-
name|out_start
decl_stmt|;
comment|// NOTE: We compare to compressed_limit here, which prevents
comment|// the total size of the Block growing past LZMA_VLI_MAX.
if|if
condition|(
name|update_size
argument_list|(
operator|&
name|coder
operator|->
name|compressed_size
argument_list|,
name|in_used
argument_list|,
name|coder
operator|->
name|compressed_limit
argument_list|)
operator|||
name|update_size
argument_list|(
operator|&
name|coder
operator|->
name|uncompressed_size
argument_list|,
name|out_used
argument_list|,
name|coder
operator|->
name|block
operator|->
name|uncompressed_size
argument_list|)
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
if|if
condition|(
operator|!
name|coder
operator|->
name|ignore_check
condition|)
name|lzma_check_update
argument_list|(
operator|&
name|coder
operator|->
name|check
argument_list|,
name|coder
operator|->
name|block
operator|->
name|check
argument_list|,
name|out
operator|+
name|out_start
argument_list|,
name|out_used
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_STREAM_END
condition|)
return|return
name|ret
return|;
comment|// Compressed and Uncompressed Sizes are now at their final
comment|// values. Verify that they match the values given to us.
if|if
condition|(
operator|!
name|is_size_valid
argument_list|(
name|coder
operator|->
name|compressed_size
argument_list|,
name|coder
operator|->
name|block
operator|->
name|compressed_size
argument_list|)
operator|||
operator|!
name|is_size_valid
argument_list|(
name|coder
operator|->
name|uncompressed_size
argument_list|,
name|coder
operator|->
name|block
operator|->
name|uncompressed_size
argument_list|)
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
comment|// Copy the values into coder->block. The caller
comment|// may use this information to construct Index.
name|coder
operator|->
name|block
operator|->
name|compressed_size
operator|=
name|coder
operator|->
name|compressed_size
expr_stmt|;
name|coder
operator|->
name|block
operator|->
name|uncompressed_size
operator|=
name|coder
operator|->
name|uncompressed_size
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_PADDING
expr_stmt|;
block|}
comment|// Fall through
case|case
name|SEQ_PADDING
case|:
comment|// Compressed Data is padded to a multiple of four bytes.
while|while
condition|(
name|coder
operator|->
name|compressed_size
operator|&
literal|3
condition|)
block|{
if|if
condition|(
operator|*
name|in_pos
operator|>=
name|in_size
condition|)
return|return
name|LZMA_OK
return|;
comment|// We use compressed_size here just get the Padding
comment|// right. The actual Compressed Size was stored to
comment|// coder->block already, and won't be modified by
comment|// us anymore.
operator|++
name|coder
operator|->
name|compressed_size
expr_stmt|;
if|if
condition|(
name|in
index|[
operator|(
operator|*
name|in_pos
operator|)
operator|++
index|]
operator|!=
literal|0x00
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
block|}
if|if
condition|(
name|coder
operator|->
name|block
operator|->
name|check
operator|==
name|LZMA_CHECK_NONE
condition|)
return|return
name|LZMA_STREAM_END
return|;
if|if
condition|(
operator|!
name|coder
operator|->
name|ignore_check
condition|)
name|lzma_check_finish
argument_list|(
operator|&
name|coder
operator|->
name|check
argument_list|,
name|coder
operator|->
name|block
operator|->
name|check
argument_list|)
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_CHECK
expr_stmt|;
comment|// Fall through
case|case
name|SEQ_CHECK
case|:
block|{
specifier|const
name|size_t
name|check_size
init|=
name|lzma_check_size
argument_list|(
name|coder
operator|->
name|block
operator|->
name|check
argument_list|)
decl_stmt|;
name|lzma_bufcpy
argument_list|(
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|,
name|coder
operator|->
name|block
operator|->
name|raw_check
argument_list|,
operator|&
name|coder
operator|->
name|check_pos
argument_list|,
name|check_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|check_pos
operator|<
name|check_size
condition|)
return|return
name|LZMA_OK
return|;
comment|// Validate the Check only if we support it.
comment|// coder->check.buffer may be uninitialized
comment|// when the Check ID is not supported.
if|if
condition|(
operator|!
name|coder
operator|->
name|ignore_check
operator|&&
name|lzma_check_is_supported
argument_list|(
name|coder
operator|->
name|block
operator|->
name|check
argument_list|)
operator|&&
name|memcmp
argument_list|(
name|coder
operator|->
name|block
operator|->
name|raw_check
argument_list|,
name|coder
operator|->
name|check
operator|.
name|buffer
operator|.
name|u8
argument_list|,
name|check_size
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
return|return
name|LZMA_STREAM_END
return|;
block|}
block|}
return|return
name|LZMA_PROG_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|block_decoder_end
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|)
block|{
name|lzma_next_end
argument_list|(
operator|&
name|coder
operator|->
name|next
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|lzma_free
argument_list|(
name|coder
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|extern
name|lzma_ret
name|lzma_block_decoder_init
parameter_list|(
name|lzma_next_coder
modifier|*
name|next
parameter_list|,
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
name|lzma_block
modifier|*
name|block
parameter_list|)
block|{
name|lzma_next_coder_init
argument_list|(
operator|&
name|lzma_block_decoder_init
argument_list|,
name|next
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
comment|// Validate the options. lzma_block_unpadded_size() does that for us
comment|// except for Uncompressed Size and filters. Filters are validated
comment|// by the raw decoder.
if|if
condition|(
name|lzma_block_unpadded_size
argument_list|(
name|block
argument_list|)
operator|==
literal|0
operator|||
operator|!
name|lzma_vli_is_valid
argument_list|(
name|block
operator|->
name|uncompressed_size
argument_list|)
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
comment|// Allocate and initialize *next->coder if needed.
if|if
condition|(
name|next
operator|->
name|coder
operator|==
name|NULL
condition|)
block|{
name|next
operator|->
name|coder
operator|=
name|lzma_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lzma_coder
argument_list|)
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|coder
operator|==
name|NULL
condition|)
return|return
name|LZMA_MEM_ERROR
return|;
name|next
operator|->
name|code
operator|=
operator|&
name|block_decode
expr_stmt|;
name|next
operator|->
name|end
operator|=
operator|&
name|block_decoder_end
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|next
operator|=
name|LZMA_NEXT_CODER_INIT
expr_stmt|;
block|}
comment|// Basic initializations
name|next
operator|->
name|coder
operator|->
name|sequence
operator|=
name|SEQ_CODE
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|block
operator|=
name|block
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|compressed_size
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|uncompressed_size
operator|=
literal|0
expr_stmt|;
comment|// If Compressed Size is not known, we calculate the maximum allowed
comment|// value so that encoded size of the Block (including Block Padding)
comment|// is still a valid VLI and a multiple of four.
name|next
operator|->
name|coder
operator|->
name|compressed_limit
operator|=
name|block
operator|->
name|compressed_size
operator|==
name|LZMA_VLI_UNKNOWN
condition|?
operator|(
name|LZMA_VLI_MAX
operator|&
operator|~
name|LZMA_VLI_C
argument_list|(
literal|3
argument_list|)
operator|)
operator|-
name|block
operator|->
name|header_size
operator|-
name|lzma_check_size
argument_list|(
name|block
operator|->
name|check
argument_list|)
else|:
name|block
operator|->
name|compressed_size
expr_stmt|;
comment|// Initialize the check. It's caller's problem if the Check ID is not
comment|// supported, and the Block decoder cannot verify the Check field.
comment|// Caller can test lzma_check_is_supported(block->check).
name|next
operator|->
name|coder
operator|->
name|check_pos
operator|=
literal|0
expr_stmt|;
name|lzma_check_init
argument_list|(
operator|&
name|next
operator|->
name|coder
operator|->
name|check
argument_list|,
name|block
operator|->
name|check
argument_list|)
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|ignore_check
operator|=
name|block
operator|->
name|version
operator|>=
literal|1
condition|?
name|block
operator|->
name|ignore_check
else|:
name|false
expr_stmt|;
comment|// Initialize the filter chain.
return|return
name|lzma_raw_decoder_init
argument_list|(
operator|&
name|next
operator|->
name|coder
operator|->
name|next
argument_list|,
name|allocator
argument_list|,
name|block
operator|->
name|filters
argument_list|)
return|;
block|}
end_function

begin_extern
extern|extern LZMA_API(lzma_ret
end_extern

begin_macro
unit|)
name|lzma_block_decoder
argument_list|(
argument|lzma_stream *strm
argument_list|,
argument|lzma_block *block
argument_list|)
end_macro

begin_block
block|{
name|lzma_next_strm_init
argument_list|(
name|lzma_block_decoder_init
argument_list|,
name|strm
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|strm
operator|->
name|internal
operator|->
name|supported_actions
index|[
name|LZMA_RUN
index|]
operator|=
name|true
expr_stmt|;
name|strm
operator|->
name|internal
operator|->
name|supported_actions
index|[
name|LZMA_FINISH
index|]
operator|=
name|true
expr_stmt|;
return|return
name|LZMA_OK
return|;
block|}
end_block

end_unit

