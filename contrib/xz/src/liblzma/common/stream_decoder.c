begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       stream_decoder.c
end_comment

begin_comment
comment|/// \brief      Decodes .xz Streams
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Author:     Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"stream_decoder.h"
end_include

begin_include
include|#
directive|include
file|"block_decoder.h"
end_include

begin_struct
struct|struct
name|lzma_coder_s
block|{
enum|enum
block|{
name|SEQ_STREAM_HEADER
block|,
name|SEQ_BLOCK_HEADER
block|,
name|SEQ_BLOCK
block|,
name|SEQ_INDEX
block|,
name|SEQ_STREAM_FOOTER
block|,
name|SEQ_STREAM_PADDING
block|, 	}
name|sequence
enum|;
comment|/// Block or Metadata decoder. This takes little memory and the same
comment|/// data structure can be used to decode every Block Header, so it's
comment|/// a good idea to have a separate lzma_next_coder structure for it.
name|lzma_next_coder
name|block_decoder
decl_stmt|;
comment|/// Block options decoded by the Block Header decoder and used by
comment|/// the Block decoder.
name|lzma_block
name|block_options
decl_stmt|;
comment|/// Stream Flags from Stream Header
name|lzma_stream_flags
name|stream_flags
decl_stmt|;
comment|/// Index is hashed so that it can be compared to the sizes of Blocks
comment|/// with O(1) memory usage.
name|lzma_index_hash
modifier|*
name|index_hash
decl_stmt|;
comment|/// Memory usage limit
name|uint64_t
name|memlimit
decl_stmt|;
comment|/// Amount of memory actually needed (only an estimate)
name|uint64_t
name|memusage
decl_stmt|;
comment|/// If true, LZMA_NO_CHECK is returned if the Stream has
comment|/// no integrity check.
name|bool
name|tell_no_check
decl_stmt|;
comment|/// If true, LZMA_UNSUPPORTED_CHECK is returned if the Stream has
comment|/// an integrity check that isn't supported by this liblzma build.
name|bool
name|tell_unsupported_check
decl_stmt|;
comment|/// If true, LZMA_GET_CHECK is returned after decoding Stream Header.
name|bool
name|tell_any_check
decl_stmt|;
comment|/// If true, we will tell the Block decoder to skip calculating
comment|/// and verifying the integrity check.
name|bool
name|ignore_check
decl_stmt|;
comment|/// If true, we will decode concatenated Streams that possibly have
comment|/// Stream Padding between or after them. LZMA_STREAM_END is returned
comment|/// once the application isn't giving us any new input, and we aren't
comment|/// in the middle of a Stream, and possible Stream Padding is a
comment|/// multiple of four bytes.
name|bool
name|concatenated
decl_stmt|;
comment|/// When decoding concatenated Streams, this is true as long as we
comment|/// are decoding the first Stream. This is needed to avoid misleading
comment|/// LZMA_FORMAT_ERROR in case the later Streams don't have valid magic
comment|/// bytes.
name|bool
name|first_stream
decl_stmt|;
comment|/// Write position in buffer[] and position in Stream Padding
name|size_t
name|pos
decl_stmt|;
comment|/// Buffer to hold Stream Header, Block Header, and Stream Footer.
comment|/// Block Header has biggest maximum size.
name|uint8_t
name|buffer
index|[
name|LZMA_BLOCK_HEADER_SIZE_MAX
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|lzma_ret
name|stream_decoder_reset
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|)
block|{
comment|// Initialize the Index hash used to verify the Index.
name|coder
operator|->
name|index_hash
operator|=
name|lzma_index_hash_init
argument_list|(
name|coder
operator|->
name|index_hash
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|index_hash
operator|==
name|NULL
condition|)
return|return
name|LZMA_MEM_ERROR
return|;
comment|// Reset the rest of the variables.
name|coder
operator|->
name|sequence
operator|=
name|SEQ_STREAM_HEADER
expr_stmt|;
name|coder
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
return|return
name|LZMA_OK
return|;
block|}
end_function

begin_function
specifier|static
name|lzma_ret
name|stream_decode
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|uint8_t
modifier|*
specifier|restrict
name|in
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|in_pos
parameter_list|,
name|size_t
name|in_size
parameter_list|,
name|uint8_t
modifier|*
specifier|restrict
name|out
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|out_pos
parameter_list|,
name|size_t
name|out_size
parameter_list|,
name|lzma_action
name|action
parameter_list|)
block|{
comment|// When decoding the actual Block, it may be able to produce more
comment|// output even if we don't give it any new input.
while|while
condition|(
name|true
condition|)
switch|switch
condition|(
name|coder
operator|->
name|sequence
condition|)
block|{
case|case
name|SEQ_STREAM_HEADER
case|:
block|{
comment|// Copy the Stream Header to the internal buffer.
name|lzma_bufcpy
argument_list|(
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|,
name|coder
operator|->
name|buffer
argument_list|,
operator|&
name|coder
operator|->
name|pos
argument_list|,
name|LZMA_STREAM_HEADER_SIZE
argument_list|)
expr_stmt|;
comment|// Return if we didn't get the whole Stream Header yet.
if|if
condition|(
name|coder
operator|->
name|pos
operator|<
name|LZMA_STREAM_HEADER_SIZE
condition|)
return|return
name|LZMA_OK
return|;
name|coder
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
comment|// Decode the Stream Header.
specifier|const
name|lzma_ret
name|ret
init|=
name|lzma_stream_header_decode
argument_list|(
operator|&
name|coder
operator|->
name|stream_flags
argument_list|,
name|coder
operator|->
name|buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
return|return
name|ret
operator|==
name|LZMA_FORMAT_ERROR
operator|&&
operator|!
name|coder
operator|->
name|first_stream
condition|?
name|LZMA_DATA_ERROR
else|:
name|ret
return|;
comment|// If we are decoding concatenated Streams, and the later
comment|// Streams have invalid Header Magic Bytes, we give
comment|// LZMA_DATA_ERROR instead of LZMA_FORMAT_ERROR.
name|coder
operator|->
name|first_stream
operator|=
name|false
expr_stmt|;
comment|// Copy the type of the Check so that Block Header and Block
comment|// decoders see it.
name|coder
operator|->
name|block_options
operator|.
name|check
operator|=
name|coder
operator|->
name|stream_flags
operator|.
name|check
expr_stmt|;
comment|// Even if we return LZMA_*_CHECK below, we want
comment|// to continue from Block Header decoding.
name|coder
operator|->
name|sequence
operator|=
name|SEQ_BLOCK_HEADER
expr_stmt|;
comment|// Detect if there's no integrity check or if it is
comment|// unsupported if those were requested by the application.
if|if
condition|(
name|coder
operator|->
name|tell_no_check
operator|&&
name|coder
operator|->
name|stream_flags
operator|.
name|check
operator|==
name|LZMA_CHECK_NONE
condition|)
return|return
name|LZMA_NO_CHECK
return|;
if|if
condition|(
name|coder
operator|->
name|tell_unsupported_check
operator|&&
operator|!
name|lzma_check_is_supported
argument_list|(
name|coder
operator|->
name|stream_flags
operator|.
name|check
argument_list|)
condition|)
return|return
name|LZMA_UNSUPPORTED_CHECK
return|;
if|if
condition|(
name|coder
operator|->
name|tell_any_check
condition|)
return|return
name|LZMA_GET_CHECK
return|;
block|}
comment|// Fall through
case|case
name|SEQ_BLOCK_HEADER
case|:
block|{
if|if
condition|(
operator|*
name|in_pos
operator|>=
name|in_size
condition|)
return|return
name|LZMA_OK
return|;
if|if
condition|(
name|coder
operator|->
name|pos
operator|==
literal|0
condition|)
block|{
comment|// Detect if it's Index.
if|if
condition|(
name|in
index|[
operator|*
name|in_pos
index|]
operator|==
literal|0x00
condition|)
block|{
name|coder
operator|->
name|sequence
operator|=
name|SEQ_INDEX
expr_stmt|;
break|break;
block|}
comment|// Calculate the size of the Block Header. Note that
comment|// Block Header decoder wants to see this byte too
comment|// so don't advance *in_pos.
name|coder
operator|->
name|block_options
operator|.
name|header_size
operator|=
name|lzma_block_header_size_decode
argument_list|(
name|in
index|[
operator|*
name|in_pos
index|]
argument_list|)
expr_stmt|;
block|}
comment|// Copy the Block Header to the internal buffer.
name|lzma_bufcpy
argument_list|(
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|,
name|coder
operator|->
name|buffer
argument_list|,
operator|&
name|coder
operator|->
name|pos
argument_list|,
name|coder
operator|->
name|block_options
operator|.
name|header_size
argument_list|)
expr_stmt|;
comment|// Return if we didn't get the whole Block Header yet.
if|if
condition|(
name|coder
operator|->
name|pos
operator|<
name|coder
operator|->
name|block_options
operator|.
name|header_size
condition|)
return|return
name|LZMA_OK
return|;
name|coder
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
comment|// Version 1 is needed to support the .ignore_check option.
name|coder
operator|->
name|block_options
operator|.
name|version
operator|=
literal|1
expr_stmt|;
comment|// Set up a buffer to hold the filter chain. Block Header
comment|// decoder will initialize all members of this array so
comment|// we don't need to do it here.
name|lzma_filter
name|filters
index|[
name|LZMA_FILTERS_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|coder
operator|->
name|block_options
operator|.
name|filters
operator|=
name|filters
expr_stmt|;
comment|// Decode the Block Header.
name|return_if_error
argument_list|(
name|lzma_block_header_decode
argument_list|(
operator|&
name|coder
operator|->
name|block_options
argument_list|,
name|allocator
argument_list|,
name|coder
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|// If LZMA_IGNORE_CHECK was used, this flag needs to be set.
comment|// It has to be set after lzma_block_header_decode() because
comment|// it always resets this to false.
name|coder
operator|->
name|block_options
operator|.
name|ignore_check
operator|=
name|coder
operator|->
name|ignore_check
expr_stmt|;
comment|// Check the memory usage limit.
specifier|const
name|uint64_t
name|memusage
init|=
name|lzma_raw_decoder_memusage
argument_list|(
name|filters
argument_list|)
decl_stmt|;
name|lzma_ret
name|ret
decl_stmt|;
if|if
condition|(
name|memusage
operator|==
name|UINT64_MAX
condition|)
block|{
comment|// One or more unknown Filter IDs.
name|ret
operator|=
name|LZMA_OPTIONS_ERROR
expr_stmt|;
block|}
else|else
block|{
comment|// Now we can set coder->memusage since we know that
comment|// the filter chain is valid. We don't want
comment|// lzma_memusage() to return UINT64_MAX in case of
comment|// invalid filter chain.
name|coder
operator|->
name|memusage
operator|=
name|memusage
expr_stmt|;
if|if
condition|(
name|memusage
operator|>
name|coder
operator|->
name|memlimit
condition|)
block|{
comment|// The chain would need too much memory.
name|ret
operator|=
name|LZMA_MEMLIMIT_ERROR
expr_stmt|;
block|}
else|else
block|{
comment|// Memory usage is OK.
comment|// Initialize the Block decoder.
name|ret
operator|=
name|lzma_block_decoder_init
argument_list|(
operator|&
name|coder
operator|->
name|block_decoder
argument_list|,
name|allocator
argument_list|,
operator|&
name|coder
operator|->
name|block_options
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Free the allocated filter options since they are needed
comment|// only to initialize the Block decoder.
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|LZMA_FILTERS_MAX
condition|;
operator|++
name|i
control|)
name|lzma_free
argument_list|(
name|filters
index|[
name|i
index|]
operator|.
name|options
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|coder
operator|->
name|block_options
operator|.
name|filters
operator|=
name|NULL
expr_stmt|;
comment|// Check if memory usage calculation and Block enocoder
comment|// initialization succeeded.
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
return|return
name|ret
return|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_BLOCK
expr_stmt|;
block|}
comment|// Fall through
case|case
name|SEQ_BLOCK
case|:
block|{
specifier|const
name|lzma_ret
name|ret
init|=
name|coder
operator|->
name|block_decoder
operator|.
name|code
argument_list|(
name|coder
operator|->
name|block_decoder
operator|.
name|coder
argument_list|,
name|allocator
argument_list|,
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|,
name|action
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_STREAM_END
condition|)
return|return
name|ret
return|;
comment|// Block decoded successfully. Add the new size pair to
comment|// the Index hash.
name|return_if_error
argument_list|(
name|lzma_index_hash_append
argument_list|(
name|coder
operator|->
name|index_hash
argument_list|,
name|lzma_block_unpadded_size
argument_list|(
operator|&
name|coder
operator|->
name|block_options
argument_list|)
argument_list|,
name|coder
operator|->
name|block_options
operator|.
name|uncompressed_size
argument_list|)
argument_list|)
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_BLOCK_HEADER
expr_stmt|;
break|break;
block|}
case|case
name|SEQ_INDEX
case|:
block|{
comment|// If we don't have any input, don't call
comment|// lzma_index_hash_decode() since it would return
comment|// LZMA_BUF_ERROR, which we must not do here.
if|if
condition|(
operator|*
name|in_pos
operator|>=
name|in_size
condition|)
return|return
name|LZMA_OK
return|;
comment|// Decode the Index and compare it to the hash calculated
comment|// from the sizes of the Blocks (if any).
specifier|const
name|lzma_ret
name|ret
init|=
name|lzma_index_hash_decode
argument_list|(
name|coder
operator|->
name|index_hash
argument_list|,
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_STREAM_END
condition|)
return|return
name|ret
return|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_STREAM_FOOTER
expr_stmt|;
block|}
comment|// Fall through
case|case
name|SEQ_STREAM_FOOTER
case|:
block|{
comment|// Copy the Stream Footer to the internal buffer.
name|lzma_bufcpy
argument_list|(
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|,
name|coder
operator|->
name|buffer
argument_list|,
operator|&
name|coder
operator|->
name|pos
argument_list|,
name|LZMA_STREAM_HEADER_SIZE
argument_list|)
expr_stmt|;
comment|// Return if we didn't get the whole Stream Footer yet.
if|if
condition|(
name|coder
operator|->
name|pos
operator|<
name|LZMA_STREAM_HEADER_SIZE
condition|)
return|return
name|LZMA_OK
return|;
name|coder
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
comment|// Decode the Stream Footer. The decoder gives
comment|// LZMA_FORMAT_ERROR if the magic bytes don't match,
comment|// so convert that return code to LZMA_DATA_ERROR.
name|lzma_stream_flags
name|footer_flags
decl_stmt|;
specifier|const
name|lzma_ret
name|ret
init|=
name|lzma_stream_footer_decode
argument_list|(
operator|&
name|footer_flags
argument_list|,
name|coder
operator|->
name|buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
return|return
name|ret
operator|==
name|LZMA_FORMAT_ERROR
condition|?
name|LZMA_DATA_ERROR
else|:
name|ret
return|;
comment|// Check that Index Size stored in the Stream Footer matches
comment|// the real size of the Index field.
if|if
condition|(
name|lzma_index_hash_size
argument_list|(
name|coder
operator|->
name|index_hash
argument_list|)
operator|!=
name|footer_flags
operator|.
name|backward_size
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
comment|// Compare that the Stream Flags fields are identical in
comment|// both Stream Header and Stream Footer.
name|return_if_error
argument_list|(
name|lzma_stream_flags_compare
argument_list|(
operator|&
name|coder
operator|->
name|stream_flags
argument_list|,
operator|&
name|footer_flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|coder
operator|->
name|concatenated
condition|)
return|return
name|LZMA_STREAM_END
return|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_STREAM_PADDING
expr_stmt|;
block|}
comment|// Fall through
case|case
name|SEQ_STREAM_PADDING
case|:
name|assert
argument_list|(
name|coder
operator|->
name|concatenated
argument_list|)
expr_stmt|;
comment|// Skip over possible Stream Padding.
while|while
condition|(
name|true
condition|)
block|{
if|if
condition|(
operator|*
name|in_pos
operator|>=
name|in_size
condition|)
block|{
comment|// Unless LZMA_FINISH was used, we cannot
comment|// know if there's more input coming later.
if|if
condition|(
name|action
operator|!=
name|LZMA_FINISH
condition|)
return|return
name|LZMA_OK
return|;
comment|// Stream Padding must be a multiple of
comment|// four bytes.
return|return
name|coder
operator|->
name|pos
operator|==
literal|0
condition|?
name|LZMA_STREAM_END
else|:
name|LZMA_DATA_ERROR
return|;
block|}
comment|// If the byte is not zero, it probably indicates
comment|// beginning of a new Stream (or the file is corrupt).
if|if
condition|(
name|in
index|[
operator|*
name|in_pos
index|]
operator|!=
literal|0x00
condition|)
break|break;
operator|++
operator|*
name|in_pos
expr_stmt|;
name|coder
operator|->
name|pos
operator|=
operator|(
name|coder
operator|->
name|pos
operator|+
literal|1
operator|)
operator|&
literal|3
expr_stmt|;
block|}
comment|// Stream Padding must be a multiple of four bytes (empty
comment|// Stream Padding is OK).
if|if
condition|(
name|coder
operator|->
name|pos
operator|!=
literal|0
condition|)
block|{
operator|++
operator|*
name|in_pos
expr_stmt|;
return|return
name|LZMA_DATA_ERROR
return|;
block|}
comment|// Prepare to decode the next Stream.
name|return_if_error
argument_list|(
name|stream_decoder_reset
argument_list|(
name|coder
argument_list|,
name|allocator
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|LZMA_PROG_ERROR
return|;
block|}
comment|// Never reached
block|}
end_function

begin_function
specifier|static
name|void
name|stream_decoder_end
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|)
block|{
name|lzma_next_end
argument_list|(
operator|&
name|coder
operator|->
name|block_decoder
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|lzma_index_hash_end
argument_list|(
name|coder
operator|->
name|index_hash
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|lzma_free
argument_list|(
name|coder
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|lzma_check
name|stream_decoder_get_check
parameter_list|(
specifier|const
name|lzma_coder
modifier|*
name|coder
parameter_list|)
block|{
return|return
name|coder
operator|->
name|stream_flags
operator|.
name|check
return|;
block|}
end_function

begin_function
specifier|static
name|lzma_ret
name|stream_decoder_memconfig
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|uint64_t
modifier|*
name|memusage
parameter_list|,
name|uint64_t
modifier|*
name|old_memlimit
parameter_list|,
name|uint64_t
name|new_memlimit
parameter_list|)
block|{
operator|*
name|memusage
operator|=
name|coder
operator|->
name|memusage
expr_stmt|;
operator|*
name|old_memlimit
operator|=
name|coder
operator|->
name|memlimit
expr_stmt|;
if|if
condition|(
name|new_memlimit
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|new_memlimit
operator|<
name|coder
operator|->
name|memusage
condition|)
return|return
name|LZMA_MEMLIMIT_ERROR
return|;
name|coder
operator|->
name|memlimit
operator|=
name|new_memlimit
expr_stmt|;
block|}
return|return
name|LZMA_OK
return|;
block|}
end_function

begin_function
specifier|extern
name|lzma_ret
name|lzma_stream_decoder_init
parameter_list|(
name|lzma_next_coder
modifier|*
name|next
parameter_list|,
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
name|uint64_t
name|memlimit
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|lzma_next_coder_init
argument_list|(
operator|&
name|lzma_stream_decoder_init
argument_list|,
name|next
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|memlimit
operator|==
literal|0
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
if|if
condition|(
name|flags
operator|&
operator|~
name|LZMA_SUPPORTED_FLAGS
condition|)
return|return
name|LZMA_OPTIONS_ERROR
return|;
if|if
condition|(
name|next
operator|->
name|coder
operator|==
name|NULL
condition|)
block|{
name|next
operator|->
name|coder
operator|=
name|lzma_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lzma_coder
argument_list|)
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|coder
operator|==
name|NULL
condition|)
return|return
name|LZMA_MEM_ERROR
return|;
name|next
operator|->
name|code
operator|=
operator|&
name|stream_decode
expr_stmt|;
name|next
operator|->
name|end
operator|=
operator|&
name|stream_decoder_end
expr_stmt|;
name|next
operator|->
name|get_check
operator|=
operator|&
name|stream_decoder_get_check
expr_stmt|;
name|next
operator|->
name|memconfig
operator|=
operator|&
name|stream_decoder_memconfig
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|block_decoder
operator|=
name|LZMA_NEXT_CODER_INIT
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|index_hash
operator|=
name|NULL
expr_stmt|;
block|}
name|next
operator|->
name|coder
operator|->
name|memlimit
operator|=
name|memlimit
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|memusage
operator|=
name|LZMA_MEMUSAGE_BASE
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|tell_no_check
operator|=
operator|(
name|flags
operator|&
name|LZMA_TELL_NO_CHECK
operator|)
operator|!=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|tell_unsupported_check
operator|=
operator|(
name|flags
operator|&
name|LZMA_TELL_UNSUPPORTED_CHECK
operator|)
operator|!=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|tell_any_check
operator|=
operator|(
name|flags
operator|&
name|LZMA_TELL_ANY_CHECK
operator|)
operator|!=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|ignore_check
operator|=
operator|(
name|flags
operator|&
name|LZMA_IGNORE_CHECK
operator|)
operator|!=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|concatenated
operator|=
operator|(
name|flags
operator|&
name|LZMA_CONCATENATED
operator|)
operator|!=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|first_stream
operator|=
name|true
expr_stmt|;
return|return
name|stream_decoder_reset
argument_list|(
name|next
operator|->
name|coder
argument_list|,
name|allocator
argument_list|)
return|;
block|}
end_function

begin_extern
extern|extern LZMA_API(lzma_ret
end_extern

begin_macro
unit|)
name|lzma_stream_decoder
argument_list|(
argument|lzma_stream *strm
argument_list|,
argument|uint64_t memlimit
argument_list|,
argument|uint32_t flags
argument_list|)
end_macro

begin_block
block|{
name|lzma_next_strm_init
argument_list|(
name|lzma_stream_decoder_init
argument_list|,
name|strm
argument_list|,
name|memlimit
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|strm
operator|->
name|internal
operator|->
name|supported_actions
index|[
name|LZMA_RUN
index|]
operator|=
name|true
expr_stmt|;
name|strm
operator|->
name|internal
operator|->
name|supported_actions
index|[
name|LZMA_FINISH
index|]
operator|=
name|true
expr_stmt|;
return|return
name|LZMA_OK
return|;
block|}
end_block

end_unit

