begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       index_hash.c
end_comment

begin_comment
comment|/// \brief      Validates Index by using a hash function
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Author:     Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"index.h"
end_include

begin_include
include|#
directive|include
file|"check.h"
end_include

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/// Sum of the Block sizes (including Block Padding)
name|lzma_vli
name|blocks_size
decl_stmt|;
comment|/// Sum of the Uncompressed Size fields
name|lzma_vli
name|uncompressed_size
decl_stmt|;
comment|/// Number of Records
name|lzma_vli
name|count
decl_stmt|;
comment|/// Size of the List of Index Records as bytes
name|lzma_vli
name|index_list_size
decl_stmt|;
comment|/// Check calculated from Unpadded Sizes and Uncompressed Sizes.
name|lzma_check_state
name|check
decl_stmt|;
block|}
name|lzma_index_hash_info
typedef|;
end_typedef

begin_struct
struct|struct
name|lzma_index_hash_s
block|{
enum|enum
block|{
name|SEQ_BLOCK
block|,
name|SEQ_COUNT
block|,
name|SEQ_UNPADDED
block|,
name|SEQ_UNCOMPRESSED
block|,
name|SEQ_PADDING_INIT
block|,
name|SEQ_PADDING
block|,
name|SEQ_CRC32
block|, 	}
name|sequence
enum|;
comment|/// Information collected while decoding the actual Blocks.
name|lzma_index_hash_info
name|blocks
decl_stmt|;
comment|/// Information collected from the Index field.
name|lzma_index_hash_info
name|records
decl_stmt|;
comment|/// Number of Records not fully decoded
name|lzma_vli
name|remaining
decl_stmt|;
comment|/// Unpadded Size currently being read from an Index Record.
name|lzma_vli
name|unpadded_size
decl_stmt|;
comment|/// Uncompressed Size currently being read from an Index Record.
name|lzma_vli
name|uncompressed_size
decl_stmt|;
comment|/// Position in variable-length integers when decoding them from
comment|/// the List of Records.
name|size_t
name|pos
decl_stmt|;
comment|/// CRC32 of the Index
name|uint32_t
name|crc32
decl_stmt|;
block|}
struct|;
end_struct

begin_extern
extern|extern LZMA_API(lzma_index_hash *
end_extern

begin_macro
unit|)
name|lzma_index_hash_init
argument_list|(
argument|lzma_index_hash *index_hash
argument_list|,
argument|const lzma_allocator *allocator
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|index_hash
operator|==
name|NULL
condition|)
block|{
name|index_hash
operator|=
name|lzma_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lzma_index_hash
argument_list|)
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|index_hash
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
name|index_hash
operator|->
name|sequence
operator|=
name|SEQ_BLOCK
expr_stmt|;
name|index_hash
operator|->
name|blocks
operator|.
name|blocks_size
operator|=
literal|0
expr_stmt|;
name|index_hash
operator|->
name|blocks
operator|.
name|uncompressed_size
operator|=
literal|0
expr_stmt|;
name|index_hash
operator|->
name|blocks
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|index_hash
operator|->
name|blocks
operator|.
name|index_list_size
operator|=
literal|0
expr_stmt|;
name|index_hash
operator|->
name|records
operator|.
name|blocks_size
operator|=
literal|0
expr_stmt|;
name|index_hash
operator|->
name|records
operator|.
name|uncompressed_size
operator|=
literal|0
expr_stmt|;
name|index_hash
operator|->
name|records
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|index_hash
operator|->
name|records
operator|.
name|index_list_size
operator|=
literal|0
expr_stmt|;
name|index_hash
operator|->
name|unpadded_size
operator|=
literal|0
expr_stmt|;
name|index_hash
operator|->
name|uncompressed_size
operator|=
literal|0
expr_stmt|;
name|index_hash
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|index_hash
operator|->
name|crc32
operator|=
literal|0
expr_stmt|;
comment|// These cannot fail because LZMA_CHECK_BEST is known to be supported.
operator|(
name|void
operator|)
name|lzma_check_init
argument_list|(
operator|&
name|index_hash
operator|->
name|blocks
operator|.
name|check
argument_list|,
name|LZMA_CHECK_BEST
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lzma_check_init
argument_list|(
operator|&
name|index_hash
operator|->
name|records
operator|.
name|check
argument_list|,
name|LZMA_CHECK_BEST
argument_list|)
expr_stmt|;
return|return
name|index_hash
return|;
block|}
end_block

begin_extern
extern|extern LZMA_API(void
end_extern

begin_macro
unit|)
name|lzma_index_hash_end
argument_list|(
argument|lzma_index_hash *index_hash
argument_list|,
argument|const lzma_allocator *allocator
argument_list|)
end_macro

begin_block
block|{
name|lzma_free
argument_list|(
name|index_hash
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_extern
extern|extern LZMA_API(lzma_vli
end_extern

begin_macro
unit|)
name|lzma_index_hash_size
argument_list|(
argument|const lzma_index_hash *index_hash
argument_list|)
end_macro

begin_block
block|{
comment|// Get the size of the Index from ->blocks instead of ->records for
comment|// cases where application wants to know the Index Size before
comment|// decoding the Index.
return|return
name|index_size
argument_list|(
name|index_hash
operator|->
name|blocks
operator|.
name|count
argument_list|,
name|index_hash
operator|->
name|blocks
operator|.
name|index_list_size
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/// Updates the sizes and the hash without any validation.
end_comment

begin_function
specifier|static
name|lzma_ret
name|hash_append
parameter_list|(
name|lzma_index_hash_info
modifier|*
name|info
parameter_list|,
name|lzma_vli
name|unpadded_size
parameter_list|,
name|lzma_vli
name|uncompressed_size
parameter_list|)
block|{
name|info
operator|->
name|blocks_size
operator|+=
name|vli_ceil4
argument_list|(
name|unpadded_size
argument_list|)
expr_stmt|;
name|info
operator|->
name|uncompressed_size
operator|+=
name|uncompressed_size
expr_stmt|;
name|info
operator|->
name|index_list_size
operator|+=
name|lzma_vli_size
argument_list|(
name|unpadded_size
argument_list|)
operator|+
name|lzma_vli_size
argument_list|(
name|uncompressed_size
argument_list|)
expr_stmt|;
operator|++
name|info
operator|->
name|count
expr_stmt|;
specifier|const
name|lzma_vli
name|sizes
index|[
literal|2
index|]
init|=
block|{
name|unpadded_size
block|,
name|uncompressed_size
block|}
decl_stmt|;
name|lzma_check_update
argument_list|(
operator|&
name|info
operator|->
name|check
argument_list|,
name|LZMA_CHECK_BEST
argument_list|,
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
operator|(
name|sizes
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sizes
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|LZMA_OK
return|;
block|}
end_function

begin_extern
extern|extern LZMA_API(lzma_ret
end_extern

begin_macro
unit|)
name|lzma_index_hash_append
argument_list|(
argument|lzma_index_hash *index_hash
argument_list|,
argument|lzma_vli unpadded_size
argument_list|,
argument|lzma_vli uncompressed_size
argument_list|)
end_macro

begin_block
block|{
comment|// Validate the arguments.
if|if
condition|(
name|index_hash
operator|->
name|sequence
operator|!=
name|SEQ_BLOCK
operator|||
name|unpadded_size
operator|<
name|UNPADDED_SIZE_MIN
operator|||
name|unpadded_size
operator|>
name|UNPADDED_SIZE_MAX
operator|||
name|uncompressed_size
operator|>
name|LZMA_VLI_MAX
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
comment|// Update the hash.
name|return_if_error
argument_list|(
name|hash_append
argument_list|(
operator|&
name|index_hash
operator|->
name|blocks
argument_list|,
name|unpadded_size
argument_list|,
name|uncompressed_size
argument_list|)
argument_list|)
expr_stmt|;
comment|// Validate the properties of *info are still in allowed limits.
if|if
condition|(
name|index_hash
operator|->
name|blocks
operator|.
name|blocks_size
operator|>
name|LZMA_VLI_MAX
operator|||
name|index_hash
operator|->
name|blocks
operator|.
name|uncompressed_size
operator|>
name|LZMA_VLI_MAX
operator|||
name|index_size
argument_list|(
name|index_hash
operator|->
name|blocks
operator|.
name|count
argument_list|,
name|index_hash
operator|->
name|blocks
operator|.
name|index_list_size
argument_list|)
operator|>
name|LZMA_BACKWARD_SIZE_MAX
operator|||
name|index_stream_size
argument_list|(
name|index_hash
operator|->
name|blocks
operator|.
name|blocks_size
argument_list|,
name|index_hash
operator|->
name|blocks
operator|.
name|count
argument_list|,
name|index_hash
operator|->
name|blocks
operator|.
name|index_list_size
argument_list|)
operator|>
name|LZMA_VLI_MAX
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
return|return
name|LZMA_OK
return|;
block|}
end_block

begin_extern
extern|extern LZMA_API(lzma_ret
end_extern

begin_macro
unit|)
name|lzma_index_hash_decode
argument_list|(
argument|lzma_index_hash *index_hash
argument_list|,
argument|const uint8_t *in
argument_list|,
argument|size_t *in_pos
argument_list|,
argument|size_t in_size
argument_list|)
end_macro

begin_block
block|{
comment|// Catch zero input buffer here, because in contrast to Index encoder
comment|// and decoder functions, applications call this function directly
comment|// instead of via lzma_code(), which does the buffer checking.
if|if
condition|(
operator|*
name|in_pos
operator|>=
name|in_size
condition|)
return|return
name|LZMA_BUF_ERROR
return|;
comment|// NOTE: This function has many similarities to index_encode() and
comment|// index_decode() functions found from index_encoder.c and
comment|// index_decoder.c. See the comments especially in index_encoder.c.
specifier|const
name|size_t
name|in_start
init|=
operator|*
name|in_pos
decl_stmt|;
name|lzma_ret
name|ret
init|=
name|LZMA_OK
decl_stmt|;
while|while
condition|(
operator|*
name|in_pos
operator|<
name|in_size
condition|)
switch|switch
condition|(
name|index_hash
operator|->
name|sequence
condition|)
block|{
case|case
name|SEQ_BLOCK
case|:
comment|// Check the Index Indicator is present.
if|if
condition|(
name|in
index|[
operator|(
operator|*
name|in_pos
operator|)
operator|++
index|]
operator|!=
literal|0x00
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
name|index_hash
operator|->
name|sequence
operator|=
name|SEQ_COUNT
expr_stmt|;
break|break;
case|case
name|SEQ_COUNT
case|:
block|{
name|ret
operator|=
name|lzma_vli_decode
argument_list|(
operator|&
name|index_hash
operator|->
name|remaining
argument_list|,
operator|&
name|index_hash
operator|->
name|pos
argument_list|,
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_STREAM_END
condition|)
goto|goto
name|out
goto|;
comment|// The count must match the count of the Blocks decoded.
if|if
condition|(
name|index_hash
operator|->
name|remaining
operator|!=
name|index_hash
operator|->
name|blocks
operator|.
name|count
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
name|ret
operator|=
name|LZMA_OK
expr_stmt|;
name|index_hash
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
comment|// Handle the special case when there are no Blocks.
name|index_hash
operator|->
name|sequence
operator|=
name|index_hash
operator|->
name|remaining
operator|==
literal|0
condition|?
name|SEQ_PADDING_INIT
else|:
name|SEQ_UNPADDED
expr_stmt|;
break|break;
block|}
case|case
name|SEQ_UNPADDED
case|:
case|case
name|SEQ_UNCOMPRESSED
case|:
block|{
name|lzma_vli
modifier|*
name|size
init|=
name|index_hash
operator|->
name|sequence
operator|==
name|SEQ_UNPADDED
condition|?
operator|&
name|index_hash
operator|->
name|unpadded_size
else|:
operator|&
name|index_hash
operator|->
name|uncompressed_size
decl_stmt|;
name|ret
operator|=
name|lzma_vli_decode
argument_list|(
name|size
argument_list|,
operator|&
name|index_hash
operator|->
name|pos
argument_list|,
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_STREAM_END
condition|)
goto|goto
name|out
goto|;
name|ret
operator|=
name|LZMA_OK
expr_stmt|;
name|index_hash
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|index_hash
operator|->
name|sequence
operator|==
name|SEQ_UNPADDED
condition|)
block|{
if|if
condition|(
name|index_hash
operator|->
name|unpadded_size
operator|<
name|UNPADDED_SIZE_MIN
operator|||
name|index_hash
operator|->
name|unpadded_size
operator|>
name|UNPADDED_SIZE_MAX
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
name|index_hash
operator|->
name|sequence
operator|=
name|SEQ_UNCOMPRESSED
expr_stmt|;
block|}
else|else
block|{
comment|// Update the hash.
name|return_if_error
argument_list|(
name|hash_append
argument_list|(
operator|&
name|index_hash
operator|->
name|records
argument_list|,
name|index_hash
operator|->
name|unpadded_size
argument_list|,
name|index_hash
operator|->
name|uncompressed_size
argument_list|)
argument_list|)
expr_stmt|;
comment|// Verify that we don't go over the known sizes. Note
comment|// that this validation is simpler than the one used
comment|// in lzma_index_hash_append(), because here we know
comment|// that values in index_hash->blocks are already
comment|// validated and we are fine as long as we don't
comment|// exceed them in index_hash->records.
if|if
condition|(
name|index_hash
operator|->
name|blocks
operator|.
name|blocks_size
operator|<
name|index_hash
operator|->
name|records
operator|.
name|blocks_size
operator|||
name|index_hash
operator|->
name|blocks
operator|.
name|uncompressed_size
operator|<
name|index_hash
operator|->
name|records
operator|.
name|uncompressed_size
operator|||
name|index_hash
operator|->
name|blocks
operator|.
name|index_list_size
operator|<
name|index_hash
operator|->
name|records
operator|.
name|index_list_size
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
comment|// Check if this was the last Record.
name|index_hash
operator|->
name|sequence
operator|=
operator|--
name|index_hash
operator|->
name|remaining
operator|==
literal|0
condition|?
name|SEQ_PADDING_INIT
else|:
name|SEQ_UNPADDED
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SEQ_PADDING_INIT
case|:
name|index_hash
operator|->
name|pos
operator|=
operator|(
name|LZMA_VLI_C
argument_list|(
literal|4
argument_list|)
operator|-
name|index_size_unpadded
argument_list|(
name|index_hash
operator|->
name|records
operator|.
name|count
argument_list|,
name|index_hash
operator|->
name|records
operator|.
name|index_list_size
argument_list|)
operator|)
operator|&
literal|3
expr_stmt|;
name|index_hash
operator|->
name|sequence
operator|=
name|SEQ_PADDING
expr_stmt|;
comment|// Fall through
case|case
name|SEQ_PADDING
case|:
if|if
condition|(
name|index_hash
operator|->
name|pos
operator|>
literal|0
condition|)
block|{
operator|--
name|index_hash
operator|->
name|pos
expr_stmt|;
if|if
condition|(
name|in
index|[
operator|(
operator|*
name|in_pos
operator|)
operator|++
index|]
operator|!=
literal|0x00
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
break|break;
block|}
comment|// Compare the sizes.
if|if
condition|(
name|index_hash
operator|->
name|blocks
operator|.
name|blocks_size
operator|!=
name|index_hash
operator|->
name|records
operator|.
name|blocks_size
operator|||
name|index_hash
operator|->
name|blocks
operator|.
name|uncompressed_size
operator|!=
name|index_hash
operator|->
name|records
operator|.
name|uncompressed_size
operator|||
name|index_hash
operator|->
name|blocks
operator|.
name|index_list_size
operator|!=
name|index_hash
operator|->
name|records
operator|.
name|index_list_size
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
comment|// Finish the hashes and compare them.
name|lzma_check_finish
argument_list|(
operator|&
name|index_hash
operator|->
name|blocks
operator|.
name|check
argument_list|,
name|LZMA_CHECK_BEST
argument_list|)
expr_stmt|;
name|lzma_check_finish
argument_list|(
operator|&
name|index_hash
operator|->
name|records
operator|.
name|check
argument_list|,
name|LZMA_CHECK_BEST
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|index_hash
operator|->
name|blocks
operator|.
name|check
operator|.
name|buffer
operator|.
name|u8
argument_list|,
name|index_hash
operator|->
name|records
operator|.
name|check
operator|.
name|buffer
operator|.
name|u8
argument_list|,
name|lzma_check_size
argument_list|(
name|LZMA_CHECK_BEST
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
comment|// Finish the CRC32 calculation.
name|index_hash
operator|->
name|crc32
operator|=
name|lzma_crc32
argument_list|(
name|in
operator|+
name|in_start
argument_list|,
operator|*
name|in_pos
operator|-
name|in_start
argument_list|,
name|index_hash
operator|->
name|crc32
argument_list|)
expr_stmt|;
name|index_hash
operator|->
name|sequence
operator|=
name|SEQ_CRC32
expr_stmt|;
comment|// Fall through
case|case
name|SEQ_CRC32
case|:
do|do
block|{
if|if
condition|(
operator|*
name|in_pos
operator|==
name|in_size
condition|)
return|return
name|LZMA_OK
return|;
if|if
condition|(
operator|(
operator|(
name|index_hash
operator|->
name|crc32
operator|>>
operator|(
name|index_hash
operator|->
name|pos
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0xFF
operator|)
operator|!=
name|in
index|[
operator|(
operator|*
name|in_pos
operator|)
operator|++
index|]
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
block|}
do|while
condition|(
operator|++
name|index_hash
operator|->
name|pos
operator|<
literal|4
condition|)
do|;
return|return
name|LZMA_STREAM_END
return|;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|LZMA_PROG_ERROR
return|;
block|}
name|out
label|:
comment|// Update the CRC32,
name|index_hash
operator|->
name|crc32
operator|=
name|lzma_crc32
argument_list|(
name|in
operator|+
name|in_start
argument_list|,
operator|*
name|in_pos
operator|-
name|in_start
argument_list|,
name|index_hash
operator|->
name|crc32
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_block

end_unit

