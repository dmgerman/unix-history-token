begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       block_header_encoder.c
end_comment

begin_comment
comment|/// \brief      Encodes Block Header for .xz files
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Author:     Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"check.h"
end_include

begin_extern
extern|extern LZMA_API(lzma_ret
end_extern

begin_macro
unit|)
name|lzma_block_header_size
argument_list|(
argument|lzma_block *block
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|block
operator|->
name|version
operator|!=
literal|0
condition|)
return|return
name|LZMA_OPTIONS_ERROR
return|;
comment|// Block Header Size + Block Flags + CRC32.
name|uint32_t
name|size
init|=
literal|1
operator|+
literal|1
operator|+
literal|4
decl_stmt|;
comment|// Compressed Size
if|if
condition|(
name|block
operator|->
name|compressed_size
operator|!=
name|LZMA_VLI_UNKNOWN
condition|)
block|{
specifier|const
name|uint32_t
name|add
init|=
name|lzma_vli_size
argument_list|(
name|block
operator|->
name|compressed_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|add
operator|==
literal|0
operator|||
name|block
operator|->
name|compressed_size
operator|==
literal|0
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
name|size
operator|+=
name|add
expr_stmt|;
block|}
comment|// Uncompressed Size
if|if
condition|(
name|block
operator|->
name|uncompressed_size
operator|!=
name|LZMA_VLI_UNKNOWN
condition|)
block|{
specifier|const
name|uint32_t
name|add
init|=
name|lzma_vli_size
argument_list|(
name|block
operator|->
name|uncompressed_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|add
operator|==
literal|0
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
name|size
operator|+=
name|add
expr_stmt|;
block|}
comment|// List of Filter Flags
if|if
condition|(
name|block
operator|->
name|filters
operator|==
name|NULL
operator|||
name|block
operator|->
name|filters
index|[
literal|0
index|]
operator|.
name|id
operator|==
name|LZMA_VLI_UNKNOWN
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|block
operator|->
name|filters
index|[
name|i
index|]
operator|.
name|id
operator|!=
name|LZMA_VLI_UNKNOWN
condition|;
operator|++
name|i
control|)
block|{
comment|// Don't allow too many filters.
if|if
condition|(
name|i
operator|==
name|LZMA_FILTERS_MAX
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
name|uint32_t
name|add
decl_stmt|;
name|return_if_error
argument_list|(
name|lzma_filter_flags_size
argument_list|(
operator|&
name|add
argument_list|,
name|block
operator|->
name|filters
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|+=
name|add
expr_stmt|;
block|}
comment|// Pad to a multiple of four bytes.
name|block
operator|->
name|header_size
operator|=
operator|(
name|size
operator|+
literal|3
operator|)
operator|&
operator|~
name|UINT32_C
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|// NOTE: We don't verify that the encoded size of the Block stays
comment|// within limits. This is because it is possible that we are called
comment|// with exaggerated Compressed Size (e.g. LZMA_VLI_MAX) to reserve
comment|// space for Block Header, and later called again with lower,
comment|// real values.
return|return
name|LZMA_OK
return|;
block|}
end_block

begin_extern
extern|extern LZMA_API(lzma_ret
end_extern

begin_macro
unit|)
name|lzma_block_header_encode
argument_list|(
argument|const lzma_block *block
argument_list|,
argument|uint8_t *out
argument_list|)
end_macro

begin_block
block|{
comment|// Validate everything but filters.
if|if
condition|(
name|lzma_block_unpadded_size
argument_list|(
name|block
argument_list|)
operator|==
literal|0
operator|||
operator|!
name|lzma_vli_is_valid
argument_list|(
name|block
operator|->
name|uncompressed_size
argument_list|)
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
comment|// Indicate the size of the buffer _excluding_ the CRC32 field.
specifier|const
name|size_t
name|out_size
init|=
name|block
operator|->
name|header_size
operator|-
literal|4
decl_stmt|;
comment|// Store the Block Header Size.
name|out
index|[
literal|0
index|]
operator|=
name|out_size
operator|/
literal|4
expr_stmt|;
comment|// We write Block Flags in pieces.
name|out
index|[
literal|1
index|]
operator|=
literal|0x00
expr_stmt|;
name|size_t
name|out_pos
init|=
literal|2
decl_stmt|;
comment|// Compressed Size
if|if
condition|(
name|block
operator|->
name|compressed_size
operator|!=
name|LZMA_VLI_UNKNOWN
condition|)
block|{
name|return_if_error
argument_list|(
name|lzma_vli_encode
argument_list|(
name|block
operator|->
name|compressed_size
argument_list|,
name|NULL
argument_list|,
name|out
argument_list|,
operator|&
name|out_pos
argument_list|,
name|out_size
argument_list|)
argument_list|)
expr_stmt|;
name|out
index|[
literal|1
index|]
operator||=
literal|0x40
expr_stmt|;
block|}
comment|// Uncompressed Size
if|if
condition|(
name|block
operator|->
name|uncompressed_size
operator|!=
name|LZMA_VLI_UNKNOWN
condition|)
block|{
name|return_if_error
argument_list|(
name|lzma_vli_encode
argument_list|(
name|block
operator|->
name|uncompressed_size
argument_list|,
name|NULL
argument_list|,
name|out
argument_list|,
operator|&
name|out_pos
argument_list|,
name|out_size
argument_list|)
argument_list|)
expr_stmt|;
name|out
index|[
literal|1
index|]
operator||=
literal|0x80
expr_stmt|;
block|}
comment|// Filter Flags
if|if
condition|(
name|block
operator|->
name|filters
operator|==
name|NULL
operator|||
name|block
operator|->
name|filters
index|[
literal|0
index|]
operator|.
name|id
operator|==
name|LZMA_VLI_UNKNOWN
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
name|size_t
name|filter_count
init|=
literal|0
decl_stmt|;
do|do
block|{
comment|// There can be a maximum of four filters.
if|if
condition|(
name|filter_count
operator|==
name|LZMA_FILTERS_MAX
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
name|return_if_error
argument_list|(
name|lzma_filter_flags_encode
argument_list|(
name|block
operator|->
name|filters
operator|+
name|filter_count
argument_list|,
name|out
argument_list|,
operator|&
name|out_pos
argument_list|,
name|out_size
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|block
operator|->
name|filters
index|[
operator|++
name|filter_count
index|]
operator|.
name|id
operator|!=
name|LZMA_VLI_UNKNOWN
condition|)
do|;
name|out
index|[
literal|1
index|]
operator||=
name|filter_count
operator|-
literal|1
expr_stmt|;
comment|// Padding
name|memzero
argument_list|(
name|out
operator|+
name|out_pos
argument_list|,
name|out_size
operator|-
name|out_pos
argument_list|)
expr_stmt|;
comment|// CRC32
name|unaligned_write32le
argument_list|(
name|out
operator|+
name|out_size
argument_list|,
name|lzma_crc32
argument_list|(
name|out
argument_list|,
name|out_size
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|LZMA_OK
return|;
block|}
end_block

end_unit

