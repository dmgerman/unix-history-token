begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       filter_decoder.c
end_comment

begin_comment
comment|/// \brief      Filter ID mapping to filter-specific functions
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Author:     Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"filter_encoder.h"
end_include

begin_include
include|#
directive|include
file|"filter_common.h"
end_include

begin_include
include|#
directive|include
file|"lzma_encoder.h"
end_include

begin_include
include|#
directive|include
file|"lzma2_encoder.h"
end_include

begin_include
include|#
directive|include
file|"simple_encoder.h"
end_include

begin_include
include|#
directive|include
file|"delta_encoder.h"
end_include

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/// Filter ID
name|lzma_vli
name|id
decl_stmt|;
comment|/// Initializes the filter encoder and calls lzma_next_filter_init()
comment|/// for filters + 1.
name|lzma_init_function
name|init
decl_stmt|;
comment|/// Calculates memory usage of the encoder. If the options are
comment|/// invalid, UINT64_MAX is returned.
name|uint64_t
function_decl|(
modifier|*
name|memusage
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
name|options
parameter_list|)
function_decl|;
comment|/// Calculates the minimum sane size for Blocks (or other types of
comment|/// chunks) to which the input data can be split to make
comment|/// multithreaded encoding possible. If this is NULL, it is assumed
comment|/// that the encoder is fast enough with single thread.
name|lzma_vli
function_decl|(
modifier|*
name|chunk_size
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
name|options
parameter_list|)
function_decl|;
comment|/// Tells the size of the Filter Properties field. If options are
comment|/// invalid, UINT32_MAX is returned. If this is NULL, props_size_fixed
comment|/// is used.
name|lzma_ret
function_decl|(
modifier|*
name|props_size_get
function_decl|)
parameter_list|(
name|uint32_t
modifier|*
name|size
parameter_list|,
specifier|const
name|void
modifier|*
name|options
parameter_list|)
function_decl|;
name|uint32_t
name|props_size_fixed
decl_stmt|;
comment|/// Encodes Filter Properties.
comment|///
comment|/// \return     - LZMA_OK: Properties encoded successfully.
comment|///             - LZMA_OPTIONS_ERROR: Unsupported options
comment|///             - LZMA_PROG_ERROR: Invalid options or not enough
comment|///               output space
name|lzma_ret
function_decl|(
modifier|*
name|props_encode
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
name|options
parameter_list|,
name|uint8_t
modifier|*
name|out
parameter_list|)
function_decl|;
block|}
name|lzma_filter_encoder
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|lzma_filter_encoder
name|encoders
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|HAVE_ENCODER_LZMA1
block|{
operator|.
name|id
operator|=
name|LZMA_FILTER_LZMA1
block|,
operator|.
name|init
operator|=
operator|&
name|lzma_lzma_encoder_init
block|,
operator|.
name|memusage
operator|=
operator|&
name|lzma_lzma_encoder_memusage
block|,
operator|.
name|chunk_size
operator|=
name|NULL
block|,
comment|// FIXME
operator|.
name|props_size_get
operator|=
name|NULL
block|,
operator|.
name|props_size_fixed
operator|=
literal|5
block|,
operator|.
name|props_encode
operator|=
operator|&
name|lzma_lzma_props_encode
block|, 	}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ENCODER_LZMA2
block|{
operator|.
name|id
operator|=
name|LZMA_FILTER_LZMA2
block|,
operator|.
name|init
operator|=
operator|&
name|lzma_lzma2_encoder_init
block|,
operator|.
name|memusage
operator|=
operator|&
name|lzma_lzma2_encoder_memusage
block|,
operator|.
name|chunk_size
operator|=
name|NULL
block|,
comment|// FIXME
operator|.
name|props_size_get
operator|=
name|NULL
block|,
operator|.
name|props_size_fixed
operator|=
literal|1
block|,
operator|.
name|props_encode
operator|=
operator|&
name|lzma_lzma2_props_encode
block|, 	}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ENCODER_X86
block|{
operator|.
name|id
operator|=
name|LZMA_FILTER_X86
block|,
operator|.
name|init
operator|=
operator|&
name|lzma_simple_x86_encoder_init
block|,
operator|.
name|memusage
operator|=
name|NULL
block|,
operator|.
name|chunk_size
operator|=
name|NULL
block|,
operator|.
name|props_size_get
operator|=
operator|&
name|lzma_simple_props_size
block|,
operator|.
name|props_encode
operator|=
operator|&
name|lzma_simple_props_encode
block|, 	}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ENCODER_POWERPC
block|{
operator|.
name|id
operator|=
name|LZMA_FILTER_POWERPC
block|,
operator|.
name|init
operator|=
operator|&
name|lzma_simple_powerpc_encoder_init
block|,
operator|.
name|memusage
operator|=
name|NULL
block|,
operator|.
name|chunk_size
operator|=
name|NULL
block|,
operator|.
name|props_size_get
operator|=
operator|&
name|lzma_simple_props_size
block|,
operator|.
name|props_encode
operator|=
operator|&
name|lzma_simple_props_encode
block|, 	}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ENCODER_IA64
block|{
operator|.
name|id
operator|=
name|LZMA_FILTER_IA64
block|,
operator|.
name|init
operator|=
operator|&
name|lzma_simple_ia64_encoder_init
block|,
operator|.
name|memusage
operator|=
name|NULL
block|,
operator|.
name|chunk_size
operator|=
name|NULL
block|,
operator|.
name|props_size_get
operator|=
operator|&
name|lzma_simple_props_size
block|,
operator|.
name|props_encode
operator|=
operator|&
name|lzma_simple_props_encode
block|, 	}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ENCODER_ARM
block|{
operator|.
name|id
operator|=
name|LZMA_FILTER_ARM
block|,
operator|.
name|init
operator|=
operator|&
name|lzma_simple_arm_encoder_init
block|,
operator|.
name|memusage
operator|=
name|NULL
block|,
operator|.
name|chunk_size
operator|=
name|NULL
block|,
operator|.
name|props_size_get
operator|=
operator|&
name|lzma_simple_props_size
block|,
operator|.
name|props_encode
operator|=
operator|&
name|lzma_simple_props_encode
block|, 	}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ENCODER_ARMTHUMB
block|{
operator|.
name|id
operator|=
name|LZMA_FILTER_ARMTHUMB
block|,
operator|.
name|init
operator|=
operator|&
name|lzma_simple_armthumb_encoder_init
block|,
operator|.
name|memusage
operator|=
name|NULL
block|,
operator|.
name|chunk_size
operator|=
name|NULL
block|,
operator|.
name|props_size_get
operator|=
operator|&
name|lzma_simple_props_size
block|,
operator|.
name|props_encode
operator|=
operator|&
name|lzma_simple_props_encode
block|, 	}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ENCODER_SPARC
block|{
operator|.
name|id
operator|=
name|LZMA_FILTER_SPARC
block|,
operator|.
name|init
operator|=
operator|&
name|lzma_simple_sparc_encoder_init
block|,
operator|.
name|memusage
operator|=
name|NULL
block|,
operator|.
name|chunk_size
operator|=
name|NULL
block|,
operator|.
name|props_size_get
operator|=
operator|&
name|lzma_simple_props_size
block|,
operator|.
name|props_encode
operator|=
operator|&
name|lzma_simple_props_encode
block|, 	}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ENCODER_DELTA
block|{
operator|.
name|id
operator|=
name|LZMA_FILTER_DELTA
block|,
operator|.
name|init
operator|=
operator|&
name|lzma_delta_encoder_init
block|,
operator|.
name|memusage
operator|=
operator|&
name|lzma_delta_coder_memusage
block|,
operator|.
name|chunk_size
operator|=
name|NULL
block|,
operator|.
name|props_size_get
operator|=
name|NULL
block|,
operator|.
name|props_size_fixed
operator|=
literal|1
block|,
operator|.
name|props_encode
operator|=
operator|&
name|lzma_delta_props_encode
block|, 	}
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|lzma_filter_encoder
modifier|*
name|encoder_find
parameter_list|(
name|lzma_vli
name|id
parameter_list|)
block|{
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|encoders
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|encoders
index|[
name|i
index|]
operator|.
name|id
operator|==
name|id
condition|)
return|return
name|encoders
operator|+
name|i
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_extern
extern|extern LZMA_API(lzma_bool
end_extern

begin_macro
unit|)
name|lzma_filter_encoder_is_supported
argument_list|(
argument|lzma_vli id
argument_list|)
end_macro

begin_block
block|{
return|return
name|encoder_find
argument_list|(
name|id
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_block

begin_extern
extern|extern LZMA_API(lzma_ret
end_extern

begin_macro
unit|)
name|lzma_filters_update
argument_list|(
argument|lzma_stream *strm
argument_list|,
argument|const lzma_filter *filters
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|strm
operator|->
name|internal
operator|->
name|next
operator|.
name|update
operator|==
name|NULL
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
comment|// Validate the filter chain.
if|if
condition|(
name|lzma_raw_encoder_memusage
argument_list|(
name|filters
argument_list|)
operator|==
name|UINT64_MAX
condition|)
return|return
name|LZMA_OPTIONS_ERROR
return|;
comment|// The actual filter chain in the encoder is reversed. Some things
comment|// still want the normal order chain, so we provide both.
name|size_t
name|count
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|filters
index|[
name|count
index|]
operator|.
name|id
operator|!=
name|LZMA_VLI_UNKNOWN
condition|)
operator|++
name|count
expr_stmt|;
name|lzma_filter
name|reversed_filters
index|[
name|LZMA_FILTERS_MAX
operator|+
literal|1
index|]
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
name|reversed_filters
index|[
name|count
operator|-
name|i
operator|-
literal|1
index|]
operator|=
name|filters
index|[
name|i
index|]
expr_stmt|;
name|reversed_filters
index|[
name|count
index|]
operator|.
name|id
operator|=
name|LZMA_VLI_UNKNOWN
expr_stmt|;
return|return
name|strm
operator|->
name|internal
operator|->
name|next
operator|.
name|update
argument_list|(
name|strm
operator|->
name|internal
operator|->
name|next
operator|.
name|coder
argument_list|,
name|strm
operator|->
name|allocator
argument_list|,
name|filters
argument_list|,
name|reversed_filters
argument_list|)
return|;
block|}
end_block

begin_function
specifier|extern
name|lzma_ret
name|lzma_raw_encoder_init
parameter_list|(
name|lzma_next_coder
modifier|*
name|next
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|lzma_filter
modifier|*
name|options
parameter_list|)
block|{
return|return
name|lzma_raw_coder_init
argument_list|(
name|next
argument_list|,
name|allocator
argument_list|,
name|options
argument_list|,
call|(
name|lzma_filter_find
call|)
argument_list|(
operator|&
name|encoder_find
argument_list|)
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_extern
extern|extern LZMA_API(lzma_ret
end_extern

begin_macro
unit|)
name|lzma_raw_encoder
argument_list|(
argument|lzma_stream *strm
argument_list|,
argument|const lzma_filter *options
argument_list|)
end_macro

begin_block
block|{
name|lzma_next_strm_init
argument_list|(
name|lzma_raw_coder_init
argument_list|,
name|strm
argument_list|,
name|options
argument_list|,
call|(
name|lzma_filter_find
call|)
argument_list|(
operator|&
name|encoder_find
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|strm
operator|->
name|internal
operator|->
name|supported_actions
index|[
name|LZMA_RUN
index|]
operator|=
name|true
expr_stmt|;
name|strm
operator|->
name|internal
operator|->
name|supported_actions
index|[
name|LZMA_SYNC_FLUSH
index|]
operator|=
name|true
expr_stmt|;
name|strm
operator|->
name|internal
operator|->
name|supported_actions
index|[
name|LZMA_FINISH
index|]
operator|=
name|true
expr_stmt|;
return|return
name|LZMA_OK
return|;
block|}
end_block

begin_extern
extern|extern LZMA_API(uint64_t
end_extern

begin_macro
unit|)
name|lzma_raw_encoder_memusage
argument_list|(
argument|const lzma_filter *filters
argument_list|)
end_macro

begin_block
block|{
return|return
name|lzma_raw_coder_memusage
argument_list|(
call|(
name|lzma_filter_find
call|)
argument_list|(
operator|&
name|encoder_find
argument_list|)
argument_list|,
name|filters
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* extern LZMA_API(lzma_vli) lzma_chunk_size(const lzma_filter *filters) { 	lzma_vli max = 0;  	for (size_t i = 0; filters[i].id != LZMA_VLI_UNKNOWN; ++i) { 		const lzma_filter_encoder *const fe 				= encoder_find(filters[i].id); 		if (fe->chunk_size != NULL) { 			const lzma_vli size 					= fe->chunk_size(filters[i].options); 			if (size == LZMA_VLI_UNKNOWN) 				return LZMA_VLI_UNKNOWN;  			if (size> max) 				max = size; 		} 	}  	return max; } */
end_comment

begin_extern
extern|extern LZMA_API(lzma_ret
end_extern

begin_macro
unit|)
name|lzma_properties_size
argument_list|(
argument|uint32_t *size
argument_list|,
argument|const lzma_filter *filter
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|lzma_filter_encoder
modifier|*
specifier|const
name|fe
init|=
name|encoder_find
argument_list|(
name|filter
operator|->
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|fe
operator|==
name|NULL
condition|)
block|{
comment|// Unknown filter - if the Filter ID is a proper VLI,
comment|// return LZMA_OPTIONS_ERROR instead of LZMA_PROG_ERROR,
comment|// because it's possible that we just don't have support
comment|// compiled in for the requested filter.
return|return
name|filter
operator|->
name|id
operator|<=
name|LZMA_VLI_MAX
condition|?
name|LZMA_OPTIONS_ERROR
else|:
name|LZMA_PROG_ERROR
return|;
block|}
if|if
condition|(
name|fe
operator|->
name|props_size_get
operator|==
name|NULL
condition|)
block|{
comment|// No props_size_get() function, use props_size_fixed.
operator|*
name|size
operator|=
name|fe
operator|->
name|props_size_fixed
expr_stmt|;
return|return
name|LZMA_OK
return|;
block|}
return|return
name|fe
operator|->
name|props_size_get
argument_list|(
name|size
argument_list|,
name|filter
operator|->
name|options
argument_list|)
return|;
block|}
end_block

begin_extern
extern|extern LZMA_API(lzma_ret
end_extern

begin_macro
unit|)
name|lzma_properties_encode
argument_list|(
argument|const lzma_filter *filter
argument_list|,
argument|uint8_t *props
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|lzma_filter_encoder
modifier|*
specifier|const
name|fe
init|=
name|encoder_find
argument_list|(
name|filter
operator|->
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|fe
operator|==
name|NULL
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
if|if
condition|(
name|fe
operator|->
name|props_encode
operator|==
name|NULL
condition|)
return|return
name|LZMA_OK
return|;
return|return
name|fe
operator|->
name|props_encode
argument_list|(
name|filter
operator|->
name|options
argument_list|,
name|props
argument_list|)
return|;
block|}
end_block

end_unit

