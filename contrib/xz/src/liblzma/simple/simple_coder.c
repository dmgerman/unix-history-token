begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       simple_coder.c
end_comment

begin_comment
comment|/// \brief      Wrapper for simple filters
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Simple filters don't change the size of the data i.e. number of bytes
end_comment

begin_comment
comment|/// in equals the number of bytes out.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Author:     Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"simple_private.h"
end_include

begin_comment
comment|/// Copied or encodes/decodes more data to out[].
end_comment

begin_function
specifier|static
name|lzma_ret
name|copy_or_code
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|uint8_t
modifier|*
specifier|restrict
name|in
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|in_pos
parameter_list|,
name|size_t
name|in_size
parameter_list|,
name|uint8_t
modifier|*
specifier|restrict
name|out
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|out_pos
parameter_list|,
name|size_t
name|out_size
parameter_list|,
name|lzma_action
name|action
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|coder
operator|->
name|end_was_reached
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|next
operator|.
name|code
operator|==
name|NULL
condition|)
block|{
name|lzma_bufcpy
argument_list|(
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|)
expr_stmt|;
comment|// Check if end of stream was reached.
if|if
condition|(
name|coder
operator|->
name|is_encoder
operator|&&
name|action
operator|==
name|LZMA_FINISH
operator|&&
operator|*
name|in_pos
operator|==
name|in_size
condition|)
name|coder
operator|->
name|end_was_reached
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
comment|// Call the next coder in the chain to provide us some data.
comment|// We don't care about uncompressed_size here, because
comment|// the next filter in the chain will do it for us (since
comment|// we don't change the size of the data).
specifier|const
name|lzma_ret
name|ret
init|=
name|coder
operator|->
name|next
operator|.
name|code
argument_list|(
name|coder
operator|->
name|next
operator|.
name|coder
argument_list|,
name|allocator
argument_list|,
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|,
name|action
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
name|LZMA_STREAM_END
condition|)
block|{
name|assert
argument_list|(
operator|!
name|coder
operator|->
name|is_encoder
operator|||
name|action
operator|==
name|LZMA_FINISH
argument_list|)
expr_stmt|;
name|coder
operator|->
name|end_was_reached
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
return|return
name|ret
return|;
block|}
block|}
return|return
name|LZMA_OK
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|call_filter
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|uint8_t
modifier|*
name|buffer
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
specifier|const
name|size_t
name|filtered
init|=
name|coder
operator|->
name|filter
argument_list|(
name|coder
operator|->
name|simple
argument_list|,
name|coder
operator|->
name|now_pos
argument_list|,
name|coder
operator|->
name|is_encoder
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|coder
operator|->
name|now_pos
operator|+=
name|filtered
expr_stmt|;
return|return
name|filtered
return|;
block|}
end_function

begin_function
specifier|static
name|lzma_ret
name|simple_code
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|uint8_t
modifier|*
specifier|restrict
name|in
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|in_pos
parameter_list|,
name|size_t
name|in_size
parameter_list|,
name|uint8_t
modifier|*
specifier|restrict
name|out
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|out_pos
parameter_list|,
name|size_t
name|out_size
parameter_list|,
name|lzma_action
name|action
parameter_list|)
block|{
comment|// TODO: Add partial support for LZMA_SYNC_FLUSH. We can support it
comment|// in cases when the filter is able to filter everything. With most
comment|// simple filters it can be done at offset that is a multiple of 2,
comment|// 4, or 16. With x86 filter, it needs good luck, and thus cannot
comment|// be made to work predictably.
if|if
condition|(
name|action
operator|==
name|LZMA_SYNC_FLUSH
condition|)
return|return
name|LZMA_OPTIONS_ERROR
return|;
comment|// Flush already filtered data from coder->buffer[] to out[].
if|if
condition|(
name|coder
operator|->
name|pos
operator|<
name|coder
operator|->
name|filtered
condition|)
block|{
name|lzma_bufcpy
argument_list|(
name|coder
operator|->
name|buffer
argument_list|,
operator|&
name|coder
operator|->
name|pos
argument_list|,
name|coder
operator|->
name|filtered
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|)
expr_stmt|;
comment|// If we couldn't flush all the filtered data, return to
comment|// application immediately.
if|if
condition|(
name|coder
operator|->
name|pos
operator|<
name|coder
operator|->
name|filtered
condition|)
return|return
name|LZMA_OK
return|;
if|if
condition|(
name|coder
operator|->
name|end_was_reached
condition|)
block|{
name|assert
argument_list|(
name|coder
operator|->
name|filtered
operator|==
name|coder
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
name|LZMA_STREAM_END
return|;
block|}
block|}
comment|// If we get here, there is no filtered data left in the buffer.
name|coder
operator|->
name|filtered
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
operator|!
name|coder
operator|->
name|end_was_reached
argument_list|)
expr_stmt|;
comment|// If there is more output space left than there is unfiltered data
comment|// in coder->buffer[], flush coder->buffer[] to out[], and copy/code
comment|// more data to out[] hopefully filling it completely. Then filter
comment|// the data in out[]. This step is where most of the data gets
comment|// filtered if the buffer sizes used by the application are reasonable.
specifier|const
name|size_t
name|out_avail
init|=
name|out_size
operator|-
operator|*
name|out_pos
decl_stmt|;
specifier|const
name|size_t
name|buf_avail
init|=
name|coder
operator|->
name|size
operator|-
name|coder
operator|->
name|pos
decl_stmt|;
if|if
condition|(
name|out_avail
operator|>
name|buf_avail
condition|)
block|{
comment|// Store the old position so that we know from which byte
comment|// to start filtering.
specifier|const
name|size_t
name|out_start
init|=
operator|*
name|out_pos
decl_stmt|;
comment|// Flush data from coder->buffer[] to out[], but don't reset
comment|// coder->pos and coder->size yet. This way the coder can be
comment|// restarted if the next filter in the chain returns e.g.
comment|// LZMA_MEM_ERROR.
name|memcpy
argument_list|(
name|out
operator|+
operator|*
name|out_pos
argument_list|,
name|coder
operator|->
name|buffer
operator|+
name|coder
operator|->
name|pos
argument_list|,
name|buf_avail
argument_list|)
expr_stmt|;
operator|*
name|out_pos
operator|+=
name|buf_avail
expr_stmt|;
comment|// Copy/Encode/Decode more data to out[].
block|{
specifier|const
name|lzma_ret
name|ret
init|=
name|copy_or_code
argument_list|(
name|coder
argument_list|,
name|allocator
argument_list|,
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|,
name|action
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|ret
operator|!=
name|LZMA_STREAM_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
return|return
name|ret
return|;
block|}
comment|// Filter out[].
specifier|const
name|size_t
name|size
init|=
operator|*
name|out_pos
operator|-
name|out_start
decl_stmt|;
specifier|const
name|size_t
name|filtered
init|=
name|call_filter
argument_list|(
name|coder
argument_list|,
name|out
operator|+
name|out_start
argument_list|,
name|size
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|unfiltered
init|=
name|size
operator|-
name|filtered
decl_stmt|;
name|assert
argument_list|(
name|unfiltered
operator|<=
name|coder
operator|->
name|allocated
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|// Now we can update coder->pos and coder->size, because
comment|// the next coder in the chain (if any) was successful.
name|coder
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|size
operator|=
name|unfiltered
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|end_was_reached
condition|)
block|{
comment|// The last byte has been copied to out[] already.
comment|// They are left as is.
name|coder
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unfiltered
operator|>
literal|0
condition|)
block|{
comment|// There is unfiltered data left in out[]. Copy it to
comment|// coder->buffer[] and rewind *out_pos appropriately.
operator|*
name|out_pos
operator|-=
name|unfiltered
expr_stmt|;
name|memcpy
argument_list|(
name|coder
operator|->
name|buffer
argument_list|,
name|out
operator|+
operator|*
name|out_pos
argument_list|,
name|unfiltered
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|coder
operator|->
name|pos
operator|>
literal|0
condition|)
block|{
name|memmove
argument_list|(
name|coder
operator|->
name|buffer
argument_list|,
name|coder
operator|->
name|buffer
operator|+
name|coder
operator|->
name|pos
argument_list|,
name|buf_avail
argument_list|)
expr_stmt|;
name|coder
operator|->
name|size
operator|-=
name|coder
operator|->
name|pos
expr_stmt|;
name|coder
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
block|}
name|assert
argument_list|(
name|coder
operator|->
name|pos
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// If coder->buffer[] isn't empty, try to fill it by copying/decoding
comment|// more data. Then filter coder->buffer[] and copy the successfully
comment|// filtered data to out[]. It is probable, that some filtered and
comment|// unfiltered data will be left to coder->buffer[].
if|if
condition|(
name|coder
operator|->
name|size
operator|>
literal|0
condition|)
block|{
block|{
specifier|const
name|lzma_ret
name|ret
init|=
name|copy_or_code
argument_list|(
name|coder
argument_list|,
name|allocator
argument_list|,
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|,
name|coder
operator|->
name|buffer
argument_list|,
operator|&
name|coder
operator|->
name|size
argument_list|,
name|coder
operator|->
name|allocated
argument_list|,
name|action
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|ret
operator|!=
name|LZMA_STREAM_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
return|return
name|ret
return|;
block|}
name|coder
operator|->
name|filtered
operator|=
name|call_filter
argument_list|(
name|coder
argument_list|,
name|coder
operator|->
name|buffer
argument_list|,
name|coder
operator|->
name|size
argument_list|)
expr_stmt|;
comment|// Everything is considered to be filtered if coder->buffer[]
comment|// contains the last bytes of the data.
if|if
condition|(
name|coder
operator|->
name|end_was_reached
condition|)
name|coder
operator|->
name|filtered
operator|=
name|coder
operator|->
name|size
expr_stmt|;
comment|// Flush as much as possible.
name|lzma_bufcpy
argument_list|(
name|coder
operator|->
name|buffer
argument_list|,
operator|&
name|coder
operator|->
name|pos
argument_list|,
name|coder
operator|->
name|filtered
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|)
expr_stmt|;
block|}
comment|// Check if we got everything done.
if|if
condition|(
name|coder
operator|->
name|end_was_reached
operator|&&
name|coder
operator|->
name|pos
operator|==
name|coder
operator|->
name|size
condition|)
return|return
name|LZMA_STREAM_END
return|;
return|return
name|LZMA_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|simple_coder_end
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|)
block|{
name|lzma_next_end
argument_list|(
operator|&
name|coder
operator|->
name|next
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|lzma_free
argument_list|(
name|coder
operator|->
name|simple
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|lzma_free
argument_list|(
name|coder
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_decl_stmt
specifier|static
name|lzma_ret
name|simple_coder_update
argument_list|(
name|lzma_coder
operator|*
name|coder
argument_list|,
name|lzma_allocator
operator|*
name|allocator
argument_list|,
specifier|const
name|lzma_filter
operator|*
name|filters_null
name|lzma_attribute
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|,
specifier|const
name|lzma_filter
operator|*
name|reversed_filters
argument_list|)
block|{
comment|// No update support, just call the next filter in the chain.
return|return
name|lzma_next_filter_update
argument_list|(
operator|&
name|coder
operator|->
name|next
argument_list|,
name|allocator
argument_list|,
name|reversed_filters
operator|+
literal|1
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
specifier|extern
name|lzma_ret
name|lzma_simple_coder_init
parameter_list|(
name|lzma_next_coder
modifier|*
name|next
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|lzma_filter_info
modifier|*
name|filters
parameter_list|,
name|size_t
function_decl|(
modifier|*
name|filter
function_decl|)
parameter_list|(
name|lzma_simple
modifier|*
name|simple
parameter_list|,
name|uint32_t
name|now_pos
parameter_list|,
name|bool
name|is_encoder
parameter_list|,
name|uint8_t
modifier|*
name|buffer
parameter_list|,
name|size_t
name|size
parameter_list|)
parameter_list|,
name|size_t
name|simple_size
parameter_list|,
name|size_t
name|unfiltered_max
parameter_list|,
name|uint32_t
name|alignment
parameter_list|,
name|bool
name|is_encoder
parameter_list|)
block|{
comment|// Allocate memory for the lzma_coder structure if needed.
if|if
condition|(
name|next
operator|->
name|coder
operator|==
name|NULL
condition|)
block|{
comment|// Here we allocate space also for the temporary buffer. We
comment|// need twice the size of unfiltered_max, because then it
comment|// is always possible to filter at least unfiltered_max bytes
comment|// more data in coder->buffer[] if it can be filled completely.
name|next
operator|->
name|coder
operator|=
name|lzma_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lzma_coder
argument_list|)
operator|+
literal|2
operator|*
name|unfiltered_max
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|coder
operator|==
name|NULL
condition|)
return|return
name|LZMA_MEM_ERROR
return|;
name|next
operator|->
name|code
operator|=
operator|&
name|simple_code
expr_stmt|;
name|next
operator|->
name|end
operator|=
operator|&
name|simple_coder_end
expr_stmt|;
name|next
operator|->
name|update
operator|=
operator|&
name|simple_coder_update
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|next
operator|=
name|LZMA_NEXT_CODER_INIT
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|filter
operator|=
name|filter
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|allocated
operator|=
literal|2
operator|*
name|unfiltered_max
expr_stmt|;
comment|// Allocate memory for filter-specific data structure.
if|if
condition|(
name|simple_size
operator|>
literal|0
condition|)
block|{
name|next
operator|->
name|coder
operator|->
name|simple
operator|=
name|lzma_alloc
argument_list|(
name|simple_size
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|coder
operator|->
name|simple
operator|==
name|NULL
condition|)
return|return
name|LZMA_MEM_ERROR
return|;
block|}
else|else
block|{
name|next
operator|->
name|coder
operator|->
name|simple
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|filters
index|[
literal|0
index|]
operator|.
name|options
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|lzma_options_bcj
modifier|*
name|simple
init|=
name|filters
index|[
literal|0
index|]
operator|.
name|options
decl_stmt|;
name|next
operator|->
name|coder
operator|->
name|now_pos
operator|=
name|simple
operator|->
name|start_offset
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|coder
operator|->
name|now_pos
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
condition|)
return|return
name|LZMA_OPTIONS_ERROR
return|;
block|}
else|else
block|{
name|next
operator|->
name|coder
operator|->
name|now_pos
operator|=
literal|0
expr_stmt|;
block|}
comment|// Reset variables.
name|next
operator|->
name|coder
operator|->
name|is_encoder
operator|=
name|is_encoder
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|end_was_reached
operator|=
name|false
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|filtered
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|size
operator|=
literal|0
expr_stmt|;
return|return
name|lzma_next_filter_init
argument_list|(
operator|&
name|next
operator|->
name|coder
operator|->
name|next
argument_list|,
name|allocator
argument_list|,
name|filters
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

end_unit

