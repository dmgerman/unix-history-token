begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       lzma_encoder.c
end_comment

begin_comment
comment|/// \brief      LZMA encoder
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//  Authors:    Igor Pavlov
end_comment

begin_comment
comment|//              Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"lzma2_encoder.h"
end_include

begin_include
include|#
directive|include
file|"lzma_encoder_private.h"
end_include

begin_include
include|#
directive|include
file|"fastpos.h"
end_include

begin_comment
comment|/////////////
end_comment

begin_comment
comment|// Literal //
end_comment

begin_comment
comment|/////////////
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|literal_matched
parameter_list|(
name|lzma_range_encoder
modifier|*
name|rc
parameter_list|,
name|probability
modifier|*
name|subcoder
parameter_list|,
name|uint32_t
name|match_byte
parameter_list|,
name|uint32_t
name|symbol
parameter_list|)
block|{
name|uint32_t
name|offset
init|=
literal|0x100
decl_stmt|;
name|symbol
operator|+=
name|UINT32_C
argument_list|(
literal|1
argument_list|)
operator|<<
literal|8
expr_stmt|;
do|do
block|{
name|match_byte
operator|<<=
literal|1
expr_stmt|;
specifier|const
name|uint32_t
name|match_bit
init|=
name|match_byte
operator|&
name|offset
decl_stmt|;
specifier|const
name|uint32_t
name|subcoder_index
init|=
name|offset
operator|+
name|match_bit
operator|+
operator|(
name|symbol
operator|>>
literal|8
operator|)
decl_stmt|;
specifier|const
name|uint32_t
name|bit
init|=
operator|(
name|symbol
operator|>>
literal|7
operator|)
operator|&
literal|1
decl_stmt|;
name|rc_bit
argument_list|(
name|rc
argument_list|,
operator|&
name|subcoder
index|[
name|subcoder_index
index|]
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|symbol
operator|<<=
literal|1
expr_stmt|;
name|offset
operator|&=
operator|~
operator|(
name|match_byte
operator|^
name|symbol
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|symbol
operator|<
operator|(
name|UINT32_C
argument_list|(
literal|1
argument_list|)
operator|<<
literal|16
operator|)
condition|)
do|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|literal
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|lzma_mf
modifier|*
name|mf
parameter_list|,
name|uint32_t
name|position
parameter_list|)
block|{
comment|// Locate the literal byte to be encoded and the subcoder.
specifier|const
name|uint8_t
name|cur_byte
init|=
name|mf
operator|->
name|buffer
index|[
name|mf
operator|->
name|read_pos
operator|-
name|mf
operator|->
name|read_ahead
index|]
decl_stmt|;
name|probability
modifier|*
name|subcoder
init|=
name|literal_subcoder
argument_list|(
name|coder
operator|->
name|literal
argument_list|,
name|coder
operator|->
name|literal_context_bits
argument_list|,
name|coder
operator|->
name|literal_pos_mask
argument_list|,
name|position
argument_list|,
name|mf
operator|->
name|buffer
index|[
name|mf
operator|->
name|read_pos
operator|-
name|mf
operator|->
name|read_ahead
operator|-
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_literal_state
argument_list|(
name|coder
operator|->
name|state
argument_list|)
condition|)
block|{
comment|// Previous LZMA-symbol was a literal. Encode a normal
comment|// literal without a match byte.
name|rc_bittree
argument_list|(
operator|&
name|coder
operator|->
name|rc
argument_list|,
name|subcoder
argument_list|,
literal|8
argument_list|,
name|cur_byte
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Previous LZMA-symbol was a match. Use the last byte of
comment|// the match as a "match byte". That is, compare the bits
comment|// of the current literal and the match byte.
specifier|const
name|uint8_t
name|match_byte
init|=
name|mf
operator|->
name|buffer
index|[
name|mf
operator|->
name|read_pos
operator|-
name|coder
operator|->
name|reps
index|[
literal|0
index|]
operator|-
literal|1
operator|-
name|mf
operator|->
name|read_ahead
index|]
decl_stmt|;
name|literal_matched
argument_list|(
operator|&
name|coder
operator|->
name|rc
argument_list|,
name|subcoder
argument_list|,
name|match_byte
argument_list|,
name|cur_byte
argument_list|)
expr_stmt|;
block|}
name|update_literal
argument_list|(
name|coder
operator|->
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|//////////////////
end_comment

begin_comment
comment|// Match length //
end_comment

begin_comment
comment|//////////////////
end_comment

begin_function
specifier|static
name|void
name|length_update_prices
parameter_list|(
name|lzma_length_encoder
modifier|*
name|lc
parameter_list|,
specifier|const
name|uint32_t
name|pos_state
parameter_list|)
block|{
specifier|const
name|uint32_t
name|table_size
init|=
name|lc
operator|->
name|table_size
decl_stmt|;
name|lc
operator|->
name|counters
index|[
name|pos_state
index|]
operator|=
name|table_size
expr_stmt|;
specifier|const
name|uint32_t
name|a0
init|=
name|rc_bit_0_price
argument_list|(
name|lc
operator|->
name|choice
argument_list|)
decl_stmt|;
specifier|const
name|uint32_t
name|a1
init|=
name|rc_bit_1_price
argument_list|(
name|lc
operator|->
name|choice
argument_list|)
decl_stmt|;
specifier|const
name|uint32_t
name|b0
init|=
name|a1
operator|+
name|rc_bit_0_price
argument_list|(
name|lc
operator|->
name|choice2
argument_list|)
decl_stmt|;
specifier|const
name|uint32_t
name|b1
init|=
name|a1
operator|+
name|rc_bit_1_price
argument_list|(
name|lc
operator|->
name|choice2
argument_list|)
decl_stmt|;
name|uint32_t
modifier|*
specifier|const
name|prices
init|=
name|lc
operator|->
name|prices
index|[
name|pos_state
index|]
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table_size
operator|&&
name|i
operator|<
name|LEN_LOW_SYMBOLS
condition|;
operator|++
name|i
control|)
name|prices
index|[
name|i
index|]
operator|=
name|a0
operator|+
name|rc_bittree_price
argument_list|(
name|lc
operator|->
name|low
index|[
name|pos_state
index|]
argument_list|,
name|LEN_LOW_BITS
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|table_size
operator|&&
name|i
operator|<
name|LEN_LOW_SYMBOLS
operator|+
name|LEN_MID_SYMBOLS
condition|;
operator|++
name|i
control|)
name|prices
index|[
name|i
index|]
operator|=
name|b0
operator|+
name|rc_bittree_price
argument_list|(
name|lc
operator|->
name|mid
index|[
name|pos_state
index|]
argument_list|,
name|LEN_MID_BITS
argument_list|,
name|i
operator|-
name|LEN_LOW_SYMBOLS
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|table_size
condition|;
operator|++
name|i
control|)
name|prices
index|[
name|i
index|]
operator|=
name|b1
operator|+
name|rc_bittree_price
argument_list|(
name|lc
operator|->
name|high
argument_list|,
name|LEN_HIGH_BITS
argument_list|,
name|i
operator|-
name|LEN_LOW_SYMBOLS
operator|-
name|LEN_MID_SYMBOLS
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|length
parameter_list|(
name|lzma_range_encoder
modifier|*
name|rc
parameter_list|,
name|lzma_length_encoder
modifier|*
name|lc
parameter_list|,
specifier|const
name|uint32_t
name|pos_state
parameter_list|,
name|uint32_t
name|len
parameter_list|,
specifier|const
name|bool
name|fast_mode
parameter_list|)
block|{
name|assert
argument_list|(
name|len
operator|<=
name|MATCH_LEN_MAX
argument_list|)
expr_stmt|;
name|len
operator|-=
name|MATCH_LEN_MIN
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|LEN_LOW_SYMBOLS
condition|)
block|{
name|rc_bit
argument_list|(
name|rc
argument_list|,
operator|&
name|lc
operator|->
name|choice
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc_bittree
argument_list|(
name|rc
argument_list|,
name|lc
operator|->
name|low
index|[
name|pos_state
index|]
argument_list|,
name|LEN_LOW_BITS
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc_bit
argument_list|(
name|rc
argument_list|,
operator|&
name|lc
operator|->
name|choice
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|len
operator|-=
name|LEN_LOW_SYMBOLS
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|LEN_MID_SYMBOLS
condition|)
block|{
name|rc_bit
argument_list|(
name|rc
argument_list|,
operator|&
name|lc
operator|->
name|choice2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc_bittree
argument_list|(
name|rc
argument_list|,
name|lc
operator|->
name|mid
index|[
name|pos_state
index|]
argument_list|,
name|LEN_MID_BITS
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc_bit
argument_list|(
name|rc
argument_list|,
operator|&
name|lc
operator|->
name|choice2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|len
operator|-=
name|LEN_MID_SYMBOLS
expr_stmt|;
name|rc_bittree
argument_list|(
name|rc
argument_list|,
name|lc
operator|->
name|high
argument_list|,
name|LEN_HIGH_BITS
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Only getoptimum uses the prices so don't update the table when
comment|// in fast mode.
if|if
condition|(
operator|!
name|fast_mode
condition|)
if|if
condition|(
operator|--
name|lc
operator|->
name|counters
index|[
name|pos_state
index|]
operator|==
literal|0
condition|)
name|length_update_prices
argument_list|(
name|lc
argument_list|,
name|pos_state
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|///////////
end_comment

begin_comment
comment|// Match //
end_comment

begin_comment
comment|///////////
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|match
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
specifier|const
name|uint32_t
name|pos_state
parameter_list|,
specifier|const
name|uint32_t
name|distance
parameter_list|,
specifier|const
name|uint32_t
name|len
parameter_list|)
block|{
name|update_match
argument_list|(
name|coder
operator|->
name|state
argument_list|)
expr_stmt|;
name|length
argument_list|(
operator|&
name|coder
operator|->
name|rc
argument_list|,
operator|&
name|coder
operator|->
name|match_len_encoder
argument_list|,
name|pos_state
argument_list|,
name|len
argument_list|,
name|coder
operator|->
name|fast_mode
argument_list|)
expr_stmt|;
specifier|const
name|uint32_t
name|dist_slot
init|=
name|get_dist_slot
argument_list|(
name|distance
argument_list|)
decl_stmt|;
specifier|const
name|uint32_t
name|dist_state
init|=
name|get_dist_state
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|rc_bittree
argument_list|(
operator|&
name|coder
operator|->
name|rc
argument_list|,
name|coder
operator|->
name|dist_slot
index|[
name|dist_state
index|]
argument_list|,
name|DIST_SLOT_BITS
argument_list|,
name|dist_slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|dist_slot
operator|>=
name|DIST_MODEL_START
condition|)
block|{
specifier|const
name|uint32_t
name|footer_bits
init|=
operator|(
name|dist_slot
operator|>>
literal|1
operator|)
operator|-
literal|1
decl_stmt|;
specifier|const
name|uint32_t
name|base
init|=
operator|(
literal|2
operator||
operator|(
name|dist_slot
operator|&
literal|1
operator|)
operator|)
operator|<<
name|footer_bits
decl_stmt|;
specifier|const
name|uint32_t
name|dist_reduced
init|=
name|distance
operator|-
name|base
decl_stmt|;
if|if
condition|(
name|dist_slot
operator|<
name|DIST_MODEL_END
condition|)
block|{
comment|// Careful here: base - dist_slot - 1 can be -1, but
comment|// rc_bittree_reverse starts at probs[1], not probs[0].
name|rc_bittree_reverse
argument_list|(
operator|&
name|coder
operator|->
name|rc
argument_list|,
name|coder
operator|->
name|dist_special
operator|+
name|base
operator|-
name|dist_slot
operator|-
literal|1
argument_list|,
name|footer_bits
argument_list|,
name|dist_reduced
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc_direct
argument_list|(
operator|&
name|coder
operator|->
name|rc
argument_list|,
name|dist_reduced
operator|>>
name|ALIGN_BITS
argument_list|,
name|footer_bits
operator|-
name|ALIGN_BITS
argument_list|)
expr_stmt|;
name|rc_bittree_reverse
argument_list|(
operator|&
name|coder
operator|->
name|rc
argument_list|,
name|coder
operator|->
name|dist_align
argument_list|,
name|ALIGN_BITS
argument_list|,
name|dist_reduced
operator|&
name|ALIGN_MASK
argument_list|)
expr_stmt|;
operator|++
name|coder
operator|->
name|align_price_count
expr_stmt|;
block|}
block|}
name|coder
operator|->
name|reps
index|[
literal|3
index|]
operator|=
name|coder
operator|->
name|reps
index|[
literal|2
index|]
expr_stmt|;
name|coder
operator|->
name|reps
index|[
literal|2
index|]
operator|=
name|coder
operator|->
name|reps
index|[
literal|1
index|]
expr_stmt|;
name|coder
operator|->
name|reps
index|[
literal|1
index|]
operator|=
name|coder
operator|->
name|reps
index|[
literal|0
index|]
expr_stmt|;
name|coder
operator|->
name|reps
index|[
literal|0
index|]
operator|=
name|distance
expr_stmt|;
operator|++
name|coder
operator|->
name|match_price_count
expr_stmt|;
block|}
end_function

begin_comment
comment|////////////////////
end_comment

begin_comment
comment|// Repeated match //
end_comment

begin_comment
comment|////////////////////
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|rep_match
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
specifier|const
name|uint32_t
name|pos_state
parameter_list|,
specifier|const
name|uint32_t
name|rep
parameter_list|,
specifier|const
name|uint32_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|rep
operator|==
literal|0
condition|)
block|{
name|rc_bit
argument_list|(
operator|&
name|coder
operator|->
name|rc
argument_list|,
operator|&
name|coder
operator|->
name|is_rep0
index|[
name|coder
operator|->
name|state
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc_bit
argument_list|(
operator|&
name|coder
operator|->
name|rc
argument_list|,
operator|&
name|coder
operator|->
name|is_rep0_long
index|[
name|coder
operator|->
name|state
index|]
index|[
name|pos_state
index|]
argument_list|,
name|len
operator|!=
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|uint32_t
name|distance
init|=
name|coder
operator|->
name|reps
index|[
name|rep
index|]
decl_stmt|;
name|rc_bit
argument_list|(
operator|&
name|coder
operator|->
name|rc
argument_list|,
operator|&
name|coder
operator|->
name|is_rep0
index|[
name|coder
operator|->
name|state
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep
operator|==
literal|1
condition|)
block|{
name|rc_bit
argument_list|(
operator|&
name|coder
operator|->
name|rc
argument_list|,
operator|&
name|coder
operator|->
name|is_rep1
index|[
name|coder
operator|->
name|state
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc_bit
argument_list|(
operator|&
name|coder
operator|->
name|rc
argument_list|,
operator|&
name|coder
operator|->
name|is_rep1
index|[
name|coder
operator|->
name|state
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rc_bit
argument_list|(
operator|&
name|coder
operator|->
name|rc
argument_list|,
operator|&
name|coder
operator|->
name|is_rep2
index|[
name|coder
operator|->
name|state
index|]
argument_list|,
name|rep
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep
operator|==
literal|3
condition|)
name|coder
operator|->
name|reps
index|[
literal|3
index|]
operator|=
name|coder
operator|->
name|reps
index|[
literal|2
index|]
expr_stmt|;
name|coder
operator|->
name|reps
index|[
literal|2
index|]
operator|=
name|coder
operator|->
name|reps
index|[
literal|1
index|]
expr_stmt|;
block|}
name|coder
operator|->
name|reps
index|[
literal|1
index|]
operator|=
name|coder
operator|->
name|reps
index|[
literal|0
index|]
expr_stmt|;
name|coder
operator|->
name|reps
index|[
literal|0
index|]
operator|=
name|distance
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
name|update_short_rep
argument_list|(
name|coder
operator|->
name|state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|length
argument_list|(
operator|&
name|coder
operator|->
name|rc
argument_list|,
operator|&
name|coder
operator|->
name|rep_len_encoder
argument_list|,
name|pos_state
argument_list|,
name|len
argument_list|,
name|coder
operator|->
name|fast_mode
argument_list|)
expr_stmt|;
name|update_long_rep
argument_list|(
name|coder
operator|->
name|state
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|//////////
end_comment

begin_comment
comment|// Main //
end_comment

begin_comment
comment|//////////
end_comment

begin_function
specifier|static
name|void
name|encode_symbol
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|lzma_mf
modifier|*
name|mf
parameter_list|,
name|uint32_t
name|back
parameter_list|,
name|uint32_t
name|len
parameter_list|,
name|uint32_t
name|position
parameter_list|)
block|{
specifier|const
name|uint32_t
name|pos_state
init|=
name|position
operator|&
name|coder
operator|->
name|pos_mask
decl_stmt|;
if|if
condition|(
name|back
operator|==
name|UINT32_MAX
condition|)
block|{
comment|// Literal i.e. eight-bit byte
name|assert
argument_list|(
name|len
operator|==
literal|1
argument_list|)
expr_stmt|;
name|rc_bit
argument_list|(
operator|&
name|coder
operator|->
name|rc
argument_list|,
operator|&
name|coder
operator|->
name|is_match
index|[
name|coder
operator|->
name|state
index|]
index|[
name|pos_state
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|literal
argument_list|(
name|coder
argument_list|,
name|mf
argument_list|,
name|position
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Some type of match
name|rc_bit
argument_list|(
operator|&
name|coder
operator|->
name|rc
argument_list|,
operator|&
name|coder
operator|->
name|is_match
index|[
name|coder
operator|->
name|state
index|]
index|[
name|pos_state
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|back
operator|<
name|REPS
condition|)
block|{
comment|// It's a repeated match i.e. the same distance
comment|// has been used earlier.
name|rc_bit
argument_list|(
operator|&
name|coder
operator|->
name|rc
argument_list|,
operator|&
name|coder
operator|->
name|is_rep
index|[
name|coder
operator|->
name|state
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rep_match
argument_list|(
name|coder
argument_list|,
name|pos_state
argument_list|,
name|back
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Normal match
name|rc_bit
argument_list|(
operator|&
name|coder
operator|->
name|rc
argument_list|,
operator|&
name|coder
operator|->
name|is_rep
index|[
name|coder
operator|->
name|state
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|match
argument_list|(
name|coder
argument_list|,
name|pos_state
argument_list|,
name|back
operator|-
name|REPS
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
name|mf
operator|->
name|read_ahead
operator|>=
name|len
argument_list|)
expr_stmt|;
name|mf
operator|->
name|read_ahead
operator|-=
name|len
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|encode_init
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|lzma_mf
modifier|*
name|mf
parameter_list|)
block|{
name|assert
argument_list|(
name|mf_position
argument_list|(
name|mf
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mf
operator|->
name|read_pos
operator|==
name|mf
operator|->
name|read_limit
condition|)
block|{
if|if
condition|(
name|mf
operator|->
name|action
operator|==
name|LZMA_RUN
condition|)
return|return
name|false
return|;
comment|// We cannot do anything.
comment|// We are finishing (we cannot get here when flushing).
name|assert
argument_list|(
name|mf
operator|->
name|write_pos
operator|==
name|mf
operator|->
name|read_pos
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|mf
operator|->
name|action
operator|==
name|LZMA_FINISH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Do the actual initialization. The first LZMA symbol must
comment|// always be a literal.
name|mf_skip
argument_list|(
name|mf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mf
operator|->
name|read_ahead
operator|=
literal|0
expr_stmt|;
name|rc_bit
argument_list|(
operator|&
name|coder
operator|->
name|rc
argument_list|,
operator|&
name|coder
operator|->
name|is_match
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rc_bittree
argument_list|(
operator|&
name|coder
operator|->
name|rc
argument_list|,
name|coder
operator|->
name|literal
index|[
literal|0
index|]
argument_list|,
literal|8
argument_list|,
name|mf
operator|->
name|buffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|// Initialization is done (except if empty file).
name|coder
operator|->
name|is_initialized
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|encode_eopm
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|uint32_t
name|position
parameter_list|)
block|{
specifier|const
name|uint32_t
name|pos_state
init|=
name|position
operator|&
name|coder
operator|->
name|pos_mask
decl_stmt|;
name|rc_bit
argument_list|(
operator|&
name|coder
operator|->
name|rc
argument_list|,
operator|&
name|coder
operator|->
name|is_match
index|[
name|coder
operator|->
name|state
index|]
index|[
name|pos_state
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rc_bit
argument_list|(
operator|&
name|coder
operator|->
name|rc
argument_list|,
operator|&
name|coder
operator|->
name|is_rep
index|[
name|coder
operator|->
name|state
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|match
argument_list|(
name|coder
argument_list|,
name|pos_state
argument_list|,
name|UINT32_MAX
argument_list|,
name|MATCH_LEN_MIN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// Number of bytes that a single encoding loop in lzma_lzma_encode() can
end_comment

begin_comment
comment|/// consume from the dictionary. This limit comes from lzma_lzma_optimum()
end_comment

begin_comment
comment|/// and may need to be updated if that function is significantly modified.
end_comment

begin_define
define|#
directive|define
name|LOOP_INPUT_MAX
value|(OPTS + 1)
end_define

begin_function
specifier|extern
name|lzma_ret
name|lzma_lzma_encode
parameter_list|(
name|lzma_coder
modifier|*
specifier|restrict
name|coder
parameter_list|,
name|lzma_mf
modifier|*
specifier|restrict
name|mf
parameter_list|,
name|uint8_t
modifier|*
specifier|restrict
name|out
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|out_pos
parameter_list|,
name|size_t
name|out_size
parameter_list|,
name|uint32_t
name|limit
parameter_list|)
block|{
comment|// Initialize the stream if no data has been encoded yet.
if|if
condition|(
operator|!
name|coder
operator|->
name|is_initialized
operator|&&
operator|!
name|encode_init
argument_list|(
name|coder
argument_list|,
name|mf
argument_list|)
condition|)
return|return
name|LZMA_OK
return|;
comment|// Get the lowest bits of the uncompressed offset from the LZ layer.
name|uint32_t
name|position
init|=
name|mf_position
argument_list|(
name|mf
argument_list|)
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
comment|// Encode pending bits, if any. Calling this before encoding
comment|// the next symbol is needed only with plain LZMA, since
comment|// LZMA2 always provides big enough buffer to flush
comment|// everything out from the range encoder. For the same reason,
comment|// rc_encode() never returns true when this function is used
comment|// as part of LZMA2 encoder.
if|if
condition|(
name|rc_encode
argument_list|(
operator|&
name|coder
operator|->
name|rc
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|limit
operator|==
name|UINT32_MAX
argument_list|)
expr_stmt|;
return|return
name|LZMA_OK
return|;
block|}
comment|// With LZMA2 we need to take care that compressed size of
comment|// a chunk doesn't get too big.
comment|// FIXME? Check if this could be improved.
if|if
condition|(
name|limit
operator|!=
name|UINT32_MAX
operator|&&
operator|(
name|mf
operator|->
name|read_pos
operator|-
name|mf
operator|->
name|read_ahead
operator|>=
name|limit
operator|||
operator|*
name|out_pos
operator|+
name|rc_pending
argument_list|(
operator|&
name|coder
operator|->
name|rc
argument_list|)
operator|>=
name|LZMA2_CHUNK_MAX
operator|-
name|LOOP_INPUT_MAX
operator|)
condition|)
break|break;
comment|// Check that there is some input to process.
if|if
condition|(
name|mf
operator|->
name|read_pos
operator|>=
name|mf
operator|->
name|read_limit
condition|)
block|{
if|if
condition|(
name|mf
operator|->
name|action
operator|==
name|LZMA_RUN
condition|)
return|return
name|LZMA_OK
return|;
if|if
condition|(
name|mf
operator|->
name|read_ahead
operator|==
literal|0
condition|)
break|break;
block|}
comment|// Get optimal match (repeat position and length).
comment|// Value ranges for pos:
comment|//   - [0, REPS): repeated match
comment|//   - [REPS, UINT32_MAX):
comment|//     match at (pos - REPS)
comment|//   - UINT32_MAX: not a match but a literal
comment|// Value ranges for len:
comment|//   - [MATCH_LEN_MIN, MATCH_LEN_MAX]
name|uint32_t
name|len
decl_stmt|;
name|uint32_t
name|back
decl_stmt|;
if|if
condition|(
name|coder
operator|->
name|fast_mode
condition|)
name|lzma_lzma_optimum_fast
argument_list|(
name|coder
argument_list|,
name|mf
argument_list|,
operator|&
name|back
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
else|else
name|lzma_lzma_optimum_normal
argument_list|(
name|coder
argument_list|,
name|mf
argument_list|,
operator|&
name|back
argument_list|,
operator|&
name|len
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|encode_symbol
argument_list|(
name|coder
argument_list|,
name|mf
argument_list|,
name|back
argument_list|,
name|len
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|position
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|coder
operator|->
name|is_flushed
condition|)
block|{
name|coder
operator|->
name|is_flushed
operator|=
name|true
expr_stmt|;
comment|// We don't support encoding plain LZMA streams without EOPM,
comment|// and LZMA2 doesn't use EOPM at LZMA level.
if|if
condition|(
name|limit
operator|==
name|UINT32_MAX
condition|)
name|encode_eopm
argument_list|(
name|coder
argument_list|,
name|position
argument_list|)
expr_stmt|;
comment|// Flush the remaining bytes from the range encoder.
name|rc_flush
argument_list|(
operator|&
name|coder
operator|->
name|rc
argument_list|)
expr_stmt|;
comment|// Copy the remaining bytes to the output buffer. If there
comment|// isn't enough output space, we will copy out the remaining
comment|// bytes on the next call to this function by using
comment|// the rc_encode() call in the encoding loop above.
if|if
condition|(
name|rc_encode
argument_list|(
operator|&
name|coder
operator|->
name|rc
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|limit
operator|==
name|UINT32_MAX
argument_list|)
expr_stmt|;
return|return
name|LZMA_OK
return|;
block|}
block|}
comment|// Make it ready for the next LZMA2 chunk.
name|coder
operator|->
name|is_flushed
operator|=
name|false
expr_stmt|;
return|return
name|LZMA_STREAM_END
return|;
block|}
end_function

begin_function
specifier|static
name|lzma_ret
name|lzma_encode
parameter_list|(
name|lzma_coder
modifier|*
specifier|restrict
name|coder
parameter_list|,
name|lzma_mf
modifier|*
specifier|restrict
name|mf
parameter_list|,
name|uint8_t
modifier|*
specifier|restrict
name|out
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|out_pos
parameter_list|,
name|size_t
name|out_size
parameter_list|)
block|{
comment|// Plain LZMA has no support for sync-flushing.
if|if
condition|(
name|unlikely
argument_list|(
name|mf
operator|->
name|action
operator|==
name|LZMA_SYNC_FLUSH
argument_list|)
condition|)
return|return
name|LZMA_OPTIONS_ERROR
return|;
return|return
name|lzma_lzma_encode
argument_list|(
name|coder
argument_list|,
name|mf
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|,
name|UINT32_MAX
argument_list|)
return|;
block|}
end_function

begin_comment
comment|////////////////////
end_comment

begin_comment
comment|// Initialization //
end_comment

begin_comment
comment|////////////////////
end_comment

begin_function
specifier|static
name|bool
name|is_options_valid
parameter_list|(
specifier|const
name|lzma_options_lzma
modifier|*
name|options
parameter_list|)
block|{
comment|// Validate some of the options. LZ encoder validates nice_len too
comment|// but we need a valid value here earlier.
return|return
name|is_lclppb_valid
argument_list|(
name|options
argument_list|)
operator|&&
name|options
operator|->
name|nice_len
operator|>=
name|MATCH_LEN_MIN
operator|&&
name|options
operator|->
name|nice_len
operator|<=
name|MATCH_LEN_MAX
operator|&&
operator|(
name|options
operator|->
name|mode
operator|==
name|LZMA_MODE_FAST
operator|||
name|options
operator|->
name|mode
operator|==
name|LZMA_MODE_NORMAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_lz_options
parameter_list|(
name|lzma_lz_options
modifier|*
name|lz_options
parameter_list|,
specifier|const
name|lzma_options_lzma
modifier|*
name|options
parameter_list|)
block|{
comment|// LZ encoder initialization does the validation for these so we
comment|// don't need to validate here.
name|lz_options
operator|->
name|before_size
operator|=
name|OPTS
expr_stmt|;
name|lz_options
operator|->
name|dict_size
operator|=
name|options
operator|->
name|dict_size
expr_stmt|;
name|lz_options
operator|->
name|after_size
operator|=
name|LOOP_INPUT_MAX
expr_stmt|;
name|lz_options
operator|->
name|match_len_max
operator|=
name|MATCH_LEN_MAX
expr_stmt|;
name|lz_options
operator|->
name|nice_len
operator|=
name|options
operator|->
name|nice_len
expr_stmt|;
name|lz_options
operator|->
name|match_finder
operator|=
name|options
operator|->
name|mf
expr_stmt|;
name|lz_options
operator|->
name|depth
operator|=
name|options
operator|->
name|depth
expr_stmt|;
name|lz_options
operator|->
name|preset_dict
operator|=
name|options
operator|->
name|preset_dict
expr_stmt|;
name|lz_options
operator|->
name|preset_dict_size
operator|=
name|options
operator|->
name|preset_dict_size
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|length_encoder_reset
parameter_list|(
name|lzma_length_encoder
modifier|*
name|lencoder
parameter_list|,
specifier|const
name|uint32_t
name|num_pos_states
parameter_list|,
specifier|const
name|bool
name|fast_mode
parameter_list|)
block|{
name|bit_reset
argument_list|(
name|lencoder
operator|->
name|choice
argument_list|)
expr_stmt|;
name|bit_reset
argument_list|(
name|lencoder
operator|->
name|choice2
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|pos_state
init|=
literal|0
init|;
name|pos_state
operator|<
name|num_pos_states
condition|;
operator|++
name|pos_state
control|)
block|{
name|bittree_reset
argument_list|(
name|lencoder
operator|->
name|low
index|[
name|pos_state
index|]
argument_list|,
name|LEN_LOW_BITS
argument_list|)
expr_stmt|;
name|bittree_reset
argument_list|(
name|lencoder
operator|->
name|mid
index|[
name|pos_state
index|]
argument_list|,
name|LEN_MID_BITS
argument_list|)
expr_stmt|;
block|}
name|bittree_reset
argument_list|(
name|lencoder
operator|->
name|high
argument_list|,
name|LEN_HIGH_BITS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fast_mode
condition|)
for|for
control|(
name|size_t
name|pos_state
init|=
literal|0
init|;
name|pos_state
operator|<
name|num_pos_states
condition|;
operator|++
name|pos_state
control|)
name|length_update_prices
argument_list|(
name|lencoder
argument_list|,
name|pos_state
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|extern
name|lzma_ret
name|lzma_lzma_encoder_reset
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
specifier|const
name|lzma_options_lzma
modifier|*
name|options
parameter_list|)
block|{
if|if
condition|(
operator|!
name|is_options_valid
argument_list|(
name|options
argument_list|)
condition|)
return|return
name|LZMA_OPTIONS_ERROR
return|;
name|coder
operator|->
name|pos_mask
operator|=
operator|(
literal|1U
operator|<<
name|options
operator|->
name|pb
operator|)
operator|-
literal|1
expr_stmt|;
name|coder
operator|->
name|literal_context_bits
operator|=
name|options
operator|->
name|lc
expr_stmt|;
name|coder
operator|->
name|literal_pos_mask
operator|=
operator|(
literal|1U
operator|<<
name|options
operator|->
name|lp
operator|)
operator|-
literal|1
expr_stmt|;
comment|// Range coder
name|rc_reset
argument_list|(
operator|&
name|coder
operator|->
name|rc
argument_list|)
expr_stmt|;
comment|// State
name|coder
operator|->
name|state
operator|=
name|STATE_LIT_LIT
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|REPS
condition|;
operator|++
name|i
control|)
name|coder
operator|->
name|reps
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|literal_init
argument_list|(
name|coder
operator|->
name|literal
argument_list|,
name|options
operator|->
name|lc
argument_list|,
name|options
operator|->
name|lp
argument_list|)
expr_stmt|;
comment|// Bit encoders
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|STATES
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|size_t
name|j
init|=
literal|0
init|;
name|j
operator|<=
name|coder
operator|->
name|pos_mask
condition|;
operator|++
name|j
control|)
block|{
name|bit_reset
argument_list|(
name|coder
operator|->
name|is_match
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|bit_reset
argument_list|(
name|coder
operator|->
name|is_rep0_long
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|bit_reset
argument_list|(
name|coder
operator|->
name|is_rep
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bit_reset
argument_list|(
name|coder
operator|->
name|is_rep0
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bit_reset
argument_list|(
name|coder
operator|->
name|is_rep1
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bit_reset
argument_list|(
name|coder
operator|->
name|is_rep2
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|FULL_DISTANCES
operator|-
name|DIST_MODEL_END
condition|;
operator|++
name|i
control|)
name|bit_reset
argument_list|(
name|coder
operator|->
name|dist_special
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|// Bit tree encoders
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|DIST_STATES
condition|;
operator|++
name|i
control|)
name|bittree_reset
argument_list|(
name|coder
operator|->
name|dist_slot
index|[
name|i
index|]
argument_list|,
name|DIST_SLOT_BITS
argument_list|)
expr_stmt|;
name|bittree_reset
argument_list|(
name|coder
operator|->
name|dist_align
argument_list|,
name|ALIGN_BITS
argument_list|)
expr_stmt|;
comment|// Length encoders
name|length_encoder_reset
argument_list|(
operator|&
name|coder
operator|->
name|match_len_encoder
argument_list|,
literal|1U
operator|<<
name|options
operator|->
name|pb
argument_list|,
name|coder
operator|->
name|fast_mode
argument_list|)
expr_stmt|;
name|length_encoder_reset
argument_list|(
operator|&
name|coder
operator|->
name|rep_len_encoder
argument_list|,
literal|1U
operator|<<
name|options
operator|->
name|pb
argument_list|,
name|coder
operator|->
name|fast_mode
argument_list|)
expr_stmt|;
comment|// Price counts are incremented every time appropriate probabilities
comment|// are changed. price counts are set to zero when the price tables
comment|// are updated, which is done when the appropriate price counts have
comment|// big enough value, and lzma_mf.read_ahead == 0 which happens at
comment|// least every OPTS (a few thousand) possible price count increments.
comment|//
comment|// By resetting price counts to UINT32_MAX / 2, we make sure that the
comment|// price tables will be initialized before they will be used (since
comment|// the value is definitely big enough), and that it is OK to increment
comment|// price counts without risk of integer overflow (since UINT32_MAX / 2
comment|// is small enough). The current code doesn't increment price counts
comment|// before initializing price tables, but it maybe done in future if
comment|// we add support for saving the state between LZMA2 chunks.
name|coder
operator|->
name|match_price_count
operator|=
name|UINT32_MAX
operator|/
literal|2
expr_stmt|;
name|coder
operator|->
name|align_price_count
operator|=
name|UINT32_MAX
operator|/
literal|2
expr_stmt|;
name|coder
operator|->
name|opts_end_index
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|opts_current_index
operator|=
literal|0
expr_stmt|;
return|return
name|LZMA_OK
return|;
block|}
end_function

begin_function
specifier|extern
name|lzma_ret
name|lzma_lzma_encoder_create
parameter_list|(
name|lzma_coder
modifier|*
modifier|*
name|coder_ptr
parameter_list|,
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|lzma_options_lzma
modifier|*
name|options
parameter_list|,
name|lzma_lz_options
modifier|*
name|lz_options
parameter_list|)
block|{
comment|// Allocate lzma_coder if it wasn't already allocated.
if|if
condition|(
operator|*
name|coder_ptr
operator|==
name|NULL
condition|)
block|{
operator|*
name|coder_ptr
operator|=
name|lzma_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lzma_coder
argument_list|)
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|coder_ptr
operator|==
name|NULL
condition|)
return|return
name|LZMA_MEM_ERROR
return|;
block|}
name|lzma_coder
modifier|*
name|coder
init|=
operator|*
name|coder_ptr
decl_stmt|;
comment|// Set compression mode. We haven't validates the options yet,
comment|// but it's OK here, since nothing bad happens with invalid
comment|// options in the code below, and they will get rejected by
comment|// lzma_lzma_encoder_reset() call at the end of this function.
switch|switch
condition|(
name|options
operator|->
name|mode
condition|)
block|{
case|case
name|LZMA_MODE_FAST
case|:
name|coder
operator|->
name|fast_mode
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|LZMA_MODE_NORMAL
case|:
block|{
name|coder
operator|->
name|fast_mode
operator|=
name|false
expr_stmt|;
comment|// Set dist_table_size.
comment|// Round the dictionary size up to next 2^n.
name|uint32_t
name|log_size
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|UINT32_C
argument_list|(
literal|1
argument_list|)
operator|<<
name|log_size
operator|)
operator|<
name|options
operator|->
name|dict_size
condition|)
operator|++
name|log_size
expr_stmt|;
name|coder
operator|->
name|dist_table_size
operator|=
name|log_size
operator|*
literal|2
expr_stmt|;
comment|// Length encoders' price table size
name|coder
operator|->
name|match_len_encoder
operator|.
name|table_size
operator|=
name|options
operator|->
name|nice_len
operator|+
literal|1
operator|-
name|MATCH_LEN_MIN
expr_stmt|;
name|coder
operator|->
name|rep_len_encoder
operator|.
name|table_size
operator|=
name|options
operator|->
name|nice_len
operator|+
literal|1
operator|-
name|MATCH_LEN_MIN
expr_stmt|;
break|break;
block|}
default|default:
return|return
name|LZMA_OPTIONS_ERROR
return|;
block|}
comment|// We don't need to write the first byte as literal if there is
comment|// a non-empty preset dictionary. encode_init() wouldn't even work
comment|// if there is a non-empty preset dictionary, because encode_init()
comment|// assumes that position is zero and previous byte is also zero.
name|coder
operator|->
name|is_initialized
operator|=
name|options
operator|->
name|preset_dict
operator|!=
name|NULL
operator|&&
name|options
operator|->
name|preset_dict_size
operator|>
literal|0
expr_stmt|;
name|coder
operator|->
name|is_flushed
operator|=
name|false
expr_stmt|;
name|set_lz_options
argument_list|(
name|lz_options
argument_list|,
name|options
argument_list|)
expr_stmt|;
return|return
name|lzma_lzma_encoder_reset
argument_list|(
name|coder
argument_list|,
name|options
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|lzma_ret
name|lzma_encoder_init
parameter_list|(
name|lzma_lz_encoder
modifier|*
name|lz
parameter_list|,
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|void
modifier|*
name|options
parameter_list|,
name|lzma_lz_options
modifier|*
name|lz_options
parameter_list|)
block|{
name|lz
operator|->
name|code
operator|=
operator|&
name|lzma_encode
expr_stmt|;
return|return
name|lzma_lzma_encoder_create
argument_list|(
operator|&
name|lz
operator|->
name|coder
argument_list|,
name|allocator
argument_list|,
name|options
argument_list|,
name|lz_options
argument_list|)
return|;
block|}
end_function

begin_function
specifier|extern
name|lzma_ret
name|lzma_lzma_encoder_init
parameter_list|(
name|lzma_next_coder
modifier|*
name|next
parameter_list|,
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|lzma_filter_info
modifier|*
name|filters
parameter_list|)
block|{
return|return
name|lzma_lz_encoder_init
argument_list|(
name|next
argument_list|,
name|allocator
argument_list|,
name|filters
argument_list|,
operator|&
name|lzma_encoder_init
argument_list|)
return|;
block|}
end_function

begin_function
specifier|extern
name|uint64_t
name|lzma_lzma_encoder_memusage
parameter_list|(
specifier|const
name|void
modifier|*
name|options
parameter_list|)
block|{
if|if
condition|(
operator|!
name|is_options_valid
argument_list|(
name|options
argument_list|)
condition|)
return|return
name|UINT64_MAX
return|;
name|lzma_lz_options
name|lz_options
decl_stmt|;
name|set_lz_options
argument_list|(
operator|&
name|lz_options
argument_list|,
name|options
argument_list|)
expr_stmt|;
specifier|const
name|uint64_t
name|lz_memusage
init|=
name|lzma_lz_encoder_memusage
argument_list|(
operator|&
name|lz_options
argument_list|)
decl_stmt|;
if|if
condition|(
name|lz_memusage
operator|==
name|UINT64_MAX
condition|)
return|return
name|UINT64_MAX
return|;
return|return
call|(
name|uint64_t
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|lzma_coder
argument_list|)
argument_list|)
operator|+
name|lz_memusage
return|;
block|}
end_function

begin_function
specifier|extern
name|bool
name|lzma_lzma_lclppb_encode
parameter_list|(
specifier|const
name|lzma_options_lzma
modifier|*
name|options
parameter_list|,
name|uint8_t
modifier|*
name|byte
parameter_list|)
block|{
if|if
condition|(
operator|!
name|is_lclppb_valid
argument_list|(
name|options
argument_list|)
condition|)
return|return
name|true
return|;
operator|*
name|byte
operator|=
operator|(
name|options
operator|->
name|pb
operator|*
literal|5
operator|+
name|options
operator|->
name|lp
operator|)
operator|*
literal|9
operator|+
name|options
operator|->
name|lc
expr_stmt|;
name|assert
argument_list|(
operator|*
name|byte
operator|<=
operator|(
literal|4
operator|*
literal|5
operator|+
literal|4
operator|)
operator|*
literal|9
operator|+
literal|8
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ENCODER_LZMA1
end_ifdef

begin_function
specifier|extern
name|lzma_ret
name|lzma_lzma_props_encode
parameter_list|(
specifier|const
name|void
modifier|*
name|options
parameter_list|,
name|uint8_t
modifier|*
name|out
parameter_list|)
block|{
specifier|const
name|lzma_options_lzma
modifier|*
specifier|const
name|opt
init|=
name|options
decl_stmt|;
if|if
condition|(
name|lzma_lzma_lclppb_encode
argument_list|(
name|opt
argument_list|,
name|out
argument_list|)
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
name|unaligned_write32le
argument_list|(
name|out
operator|+
literal|1
argument_list|,
name|opt
operator|->
name|dict_size
argument_list|)
expr_stmt|;
return|return
name|LZMA_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_extern
extern|extern LZMA_API(lzma_bool
end_extern

begin_macro
unit|)
name|lzma_mode_is_supported
argument_list|(
argument|lzma_mode mode
argument_list|)
end_macro

begin_block
block|{
return|return
name|mode
operator|==
name|LZMA_MODE_FAST
operator|||
name|mode
operator|==
name|LZMA_MODE_NORMAL
return|;
block|}
end_block

end_unit

