begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       lzma_encoder_optimum_fast.c
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Author:     Igor Pavlov
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"lzma_encoder_private.h"
end_include

begin_define
define|#
directive|define
name|change_pair
parameter_list|(
name|small_dist
parameter_list|,
name|big_dist
parameter_list|)
define|\
value|(((big_dist)>> 7)> (small_dist))
end_define

begin_function
specifier|extern
name|void
name|lzma_lzma_optimum_fast
parameter_list|(
name|lzma_coder
modifier|*
specifier|restrict
name|coder
parameter_list|,
name|lzma_mf
modifier|*
specifier|restrict
name|mf
parameter_list|,
name|uint32_t
modifier|*
specifier|restrict
name|back_res
parameter_list|,
name|uint32_t
modifier|*
specifier|restrict
name|len_res
parameter_list|)
block|{
specifier|const
name|uint32_t
name|nice_len
init|=
name|mf
operator|->
name|nice_len
decl_stmt|;
name|uint32_t
name|len_main
decl_stmt|;
name|uint32_t
name|matches_count
decl_stmt|;
if|if
condition|(
name|mf
operator|->
name|read_ahead
operator|==
literal|0
condition|)
block|{
name|len_main
operator|=
name|mf_find
argument_list|(
name|mf
argument_list|,
operator|&
name|matches_count
argument_list|,
name|coder
operator|->
name|matches
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|mf
operator|->
name|read_ahead
operator|==
literal|1
argument_list|)
expr_stmt|;
name|len_main
operator|=
name|coder
operator|->
name|longest_match_length
expr_stmt|;
name|matches_count
operator|=
name|coder
operator|->
name|matches_count
expr_stmt|;
block|}
specifier|const
name|uint8_t
modifier|*
name|buf
init|=
name|mf_ptr
argument_list|(
name|mf
argument_list|)
operator|-
literal|1
decl_stmt|;
specifier|const
name|uint32_t
name|buf_avail
init|=
name|MIN
argument_list|(
name|mf_avail
argument_list|(
name|mf
argument_list|)
operator|+
literal|1
argument_list|,
name|MATCH_LEN_MAX
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf_avail
operator|<
literal|2
condition|)
block|{
comment|// There's not enough input left to encode a match.
operator|*
name|back_res
operator|=
name|UINT32_MAX
expr_stmt|;
operator|*
name|len_res
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|// Look for repeated matches; scan the previous four match distances
name|uint32_t
name|rep_len
init|=
literal|0
decl_stmt|;
name|uint32_t
name|rep_index
init|=
literal|0
decl_stmt|;
for|for
control|(
name|uint32_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|REP_DISTANCES
condition|;
operator|++
name|i
control|)
block|{
comment|// Pointer to the beginning of the match candidate
specifier|const
name|uint8_t
modifier|*
specifier|const
name|buf_back
init|=
name|buf
operator|-
name|coder
operator|->
name|reps
index|[
name|i
index|]
operator|-
literal|1
decl_stmt|;
comment|// If the first two bytes (2 == MATCH_LEN_MIN) do not match,
comment|// this rep is not useful.
if|if
condition|(
name|not_equal_16
argument_list|(
name|buf
argument_list|,
name|buf_back
argument_list|)
condition|)
continue|continue;
comment|// The first two bytes matched.
comment|// Calculate the length of the match.
name|uint32_t
name|len
decl_stmt|;
for|for
control|(
name|len
operator|=
literal|2
init|;
name|len
operator|<
name|buf_avail
operator|&&
name|buf
index|[
name|len
index|]
operator|==
name|buf_back
index|[
name|len
index|]
condition|;
operator|++
name|len
control|)
empty_stmt|;
comment|// If we have found a repeated match that is at least
comment|// nice_len long, return it immediately.
if|if
condition|(
name|len
operator|>=
name|nice_len
condition|)
block|{
operator|*
name|back_res
operator|=
name|i
expr_stmt|;
operator|*
name|len_res
operator|=
name|len
expr_stmt|;
name|mf_skip
argument_list|(
name|mf
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|len
operator|>
name|rep_len
condition|)
block|{
name|rep_index
operator|=
name|i
expr_stmt|;
name|rep_len
operator|=
name|len
expr_stmt|;
block|}
block|}
comment|// We didn't find a long enough repeated match. Encode it as a normal
comment|// match if the match length is at least nice_len.
if|if
condition|(
name|len_main
operator|>=
name|nice_len
condition|)
block|{
operator|*
name|back_res
operator|=
name|coder
operator|->
name|matches
index|[
name|matches_count
operator|-
literal|1
index|]
operator|.
name|dist
operator|+
name|REP_DISTANCES
expr_stmt|;
operator|*
name|len_res
operator|=
name|len_main
expr_stmt|;
name|mf_skip
argument_list|(
name|mf
argument_list|,
name|len_main
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|uint32_t
name|back_main
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|len_main
operator|>=
literal|2
condition|)
block|{
name|back_main
operator|=
name|coder
operator|->
name|matches
index|[
name|matches_count
operator|-
literal|1
index|]
operator|.
name|dist
expr_stmt|;
while|while
condition|(
name|matches_count
operator|>
literal|1
operator|&&
name|len_main
operator|==
name|coder
operator|->
name|matches
index|[
name|matches_count
operator|-
literal|2
index|]
operator|.
name|len
operator|+
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|change_pair
argument_list|(
name|coder
operator|->
name|matches
index|[
name|matches_count
operator|-
literal|2
index|]
operator|.
name|dist
argument_list|,
name|back_main
argument_list|)
condition|)
break|break;
operator|--
name|matches_count
expr_stmt|;
name|len_main
operator|=
name|coder
operator|->
name|matches
index|[
name|matches_count
operator|-
literal|1
index|]
operator|.
name|len
expr_stmt|;
name|back_main
operator|=
name|coder
operator|->
name|matches
index|[
name|matches_count
operator|-
literal|1
index|]
operator|.
name|dist
expr_stmt|;
block|}
if|if
condition|(
name|len_main
operator|==
literal|2
operator|&&
name|back_main
operator|>=
literal|0x80
condition|)
name|len_main
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|rep_len
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|rep_len
operator|+
literal|1
operator|>=
name|len_main
operator|||
operator|(
name|rep_len
operator|+
literal|2
operator|>=
name|len_main
operator|&&
name|back_main
operator|>
operator|(
name|UINT32_C
argument_list|(
literal|1
argument_list|)
operator|<<
literal|9
operator|)
operator|)
operator|||
operator|(
name|rep_len
operator|+
literal|3
operator|>=
name|len_main
operator|&&
name|back_main
operator|>
operator|(
name|UINT32_C
argument_list|(
literal|1
argument_list|)
operator|<<
literal|15
operator|)
operator|)
condition|)
block|{
operator|*
name|back_res
operator|=
name|rep_index
expr_stmt|;
operator|*
name|len_res
operator|=
name|rep_len
expr_stmt|;
name|mf_skip
argument_list|(
name|mf
argument_list|,
name|rep_len
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|len_main
operator|<
literal|2
operator|||
name|buf_avail
operator|<=
literal|2
condition|)
block|{
operator|*
name|back_res
operator|=
name|UINT32_MAX
expr_stmt|;
operator|*
name|len_res
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|// Get the matches for the next byte. If we find a better match,
comment|// the current byte is encoded as a literal.
name|coder
operator|->
name|longest_match_length
operator|=
name|mf_find
argument_list|(
name|mf
argument_list|,
operator|&
name|coder
operator|->
name|matches_count
argument_list|,
name|coder
operator|->
name|matches
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|longest_match_length
operator|>=
literal|2
condition|)
block|{
specifier|const
name|uint32_t
name|new_dist
init|=
name|coder
operator|->
name|matches
index|[
name|coder
operator|->
name|matches_count
operator|-
literal|1
index|]
operator|.
name|dist
decl_stmt|;
if|if
condition|(
operator|(
name|coder
operator|->
name|longest_match_length
operator|>=
name|len_main
operator|&&
name|new_dist
operator|<
name|back_main
operator|)
operator|||
operator|(
name|coder
operator|->
name|longest_match_length
operator|==
name|len_main
operator|+
literal|1
operator|&&
operator|!
name|change_pair
argument_list|(
name|back_main
argument_list|,
name|new_dist
argument_list|)
operator|)
operator|||
operator|(
name|coder
operator|->
name|longest_match_length
operator|>
name|len_main
operator|+
literal|1
operator|)
operator|||
operator|(
name|coder
operator|->
name|longest_match_length
operator|+
literal|1
operator|>=
name|len_main
operator|&&
name|len_main
operator|>=
literal|3
operator|&&
name|change_pair
argument_list|(
name|new_dist
argument_list|,
name|back_main
argument_list|)
operator|)
condition|)
block|{
operator|*
name|back_res
operator|=
name|UINT32_MAX
expr_stmt|;
operator|*
name|len_res
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
comment|// In contrast to LZMA SDK, dictionary could not have been moved
comment|// between mf_find() calls, thus it is safe to just increment
comment|// the old buf pointer instead of recalculating it with mf_ptr().
operator|++
name|buf
expr_stmt|;
specifier|const
name|uint32_t
name|limit
init|=
name|len_main
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|uint32_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|REP_DISTANCES
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|uint8_t
modifier|*
specifier|const
name|buf_back
init|=
name|buf
operator|-
name|coder
operator|->
name|reps
index|[
name|i
index|]
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|not_equal_16
argument_list|(
name|buf
argument_list|,
name|buf_back
argument_list|)
condition|)
continue|continue;
name|uint32_t
name|len
decl_stmt|;
for|for
control|(
name|len
operator|=
literal|2
init|;
name|len
operator|<
name|limit
operator|&&
name|buf
index|[
name|len
index|]
operator|==
name|buf_back
index|[
name|len
index|]
condition|;
operator|++
name|len
control|)
empty_stmt|;
if|if
condition|(
name|len
operator|>=
name|limit
condition|)
block|{
operator|*
name|back_res
operator|=
name|UINT32_MAX
expr_stmt|;
operator|*
name|len_res
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
operator|*
name|back_res
operator|=
name|back_main
operator|+
name|REP_DISTANCES
expr_stmt|;
operator|*
name|len_res
operator|=
name|len_main
expr_stmt|;
name|mf_skip
argument_list|(
name|mf
argument_list|,
name|len_main
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

