begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       lzma_encoder_optimum_normal.c
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Author:     Igor Pavlov
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"lzma_encoder_private.h"
end_include

begin_include
include|#
directive|include
file|"fastpos.h"
end_include

begin_comment
comment|////////////
end_comment

begin_comment
comment|// Prices //
end_comment

begin_comment
comment|////////////
end_comment

begin_function
specifier|static
name|uint32_t
name|get_literal_price
parameter_list|(
specifier|const
name|lzma_coder
modifier|*
specifier|const
name|coder
parameter_list|,
specifier|const
name|uint32_t
name|pos
parameter_list|,
specifier|const
name|uint32_t
name|prev_byte
parameter_list|,
specifier|const
name|bool
name|match_mode
parameter_list|,
name|uint32_t
name|match_byte
parameter_list|,
name|uint32_t
name|symbol
parameter_list|)
block|{
specifier|const
name|probability
modifier|*
specifier|const
name|subcoder
init|=
name|literal_subcoder
argument_list|(
name|coder
operator|->
name|literal
argument_list|,
name|coder
operator|->
name|literal_context_bits
argument_list|,
name|coder
operator|->
name|literal_pos_mask
argument_list|,
name|pos
argument_list|,
name|prev_byte
argument_list|)
decl_stmt|;
name|uint32_t
name|price
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|match_mode
condition|)
block|{
name|price
operator|=
name|rc_bittree_price
argument_list|(
name|subcoder
argument_list|,
literal|8
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint32_t
name|offset
init|=
literal|0x100
decl_stmt|;
name|symbol
operator|+=
name|UINT32_C
argument_list|(
literal|1
argument_list|)
operator|<<
literal|8
expr_stmt|;
do|do
block|{
name|match_byte
operator|<<=
literal|1
expr_stmt|;
specifier|const
name|uint32_t
name|match_bit
init|=
name|match_byte
operator|&
name|offset
decl_stmt|;
specifier|const
name|uint32_t
name|subcoder_index
init|=
name|offset
operator|+
name|match_bit
operator|+
operator|(
name|symbol
operator|>>
literal|8
operator|)
decl_stmt|;
specifier|const
name|uint32_t
name|bit
init|=
operator|(
name|symbol
operator|>>
literal|7
operator|)
operator|&
literal|1
decl_stmt|;
name|price
operator|+=
name|rc_bit_price
argument_list|(
name|subcoder
index|[
name|subcoder_index
index|]
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|symbol
operator|<<=
literal|1
expr_stmt|;
name|offset
operator|&=
operator|~
operator|(
name|match_byte
operator|^
name|symbol
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|symbol
operator|<
operator|(
name|UINT32_C
argument_list|(
literal|1
argument_list|)
operator|<<
literal|16
operator|)
condition|)
do|;
block|}
return|return
name|price
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|get_len_price
parameter_list|(
specifier|const
name|lzma_length_encoder
modifier|*
specifier|const
name|lencoder
parameter_list|,
specifier|const
name|uint32_t
name|len
parameter_list|,
specifier|const
name|uint32_t
name|pos_state
parameter_list|)
block|{
comment|// NOTE: Unlike the other price tables, length prices are updated
comment|// in lzma_encoder.c
return|return
name|lencoder
operator|->
name|prices
index|[
name|pos_state
index|]
index|[
name|len
operator|-
name|MATCH_LEN_MIN
index|]
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|get_short_rep_price
parameter_list|(
specifier|const
name|lzma_coder
modifier|*
specifier|const
name|coder
parameter_list|,
specifier|const
name|lzma_lzma_state
name|state
parameter_list|,
specifier|const
name|uint32_t
name|pos_state
parameter_list|)
block|{
return|return
name|rc_bit_0_price
argument_list|(
name|coder
operator|->
name|is_rep0
index|[
name|state
index|]
argument_list|)
operator|+
name|rc_bit_0_price
argument_list|(
name|coder
operator|->
name|is_rep0_long
index|[
name|state
index|]
index|[
name|pos_state
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|get_pure_rep_price
parameter_list|(
specifier|const
name|lzma_coder
modifier|*
specifier|const
name|coder
parameter_list|,
specifier|const
name|uint32_t
name|rep_index
parameter_list|,
specifier|const
name|lzma_lzma_state
name|state
parameter_list|,
name|uint32_t
name|pos_state
parameter_list|)
block|{
name|uint32_t
name|price
decl_stmt|;
if|if
condition|(
name|rep_index
operator|==
literal|0
condition|)
block|{
name|price
operator|=
name|rc_bit_0_price
argument_list|(
name|coder
operator|->
name|is_rep0
index|[
name|state
index|]
argument_list|)
expr_stmt|;
name|price
operator|+=
name|rc_bit_1_price
argument_list|(
name|coder
operator|->
name|is_rep0_long
index|[
name|state
index|]
index|[
name|pos_state
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|price
operator|=
name|rc_bit_1_price
argument_list|(
name|coder
operator|->
name|is_rep0
index|[
name|state
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep_index
operator|==
literal|1
condition|)
block|{
name|price
operator|+=
name|rc_bit_0_price
argument_list|(
name|coder
operator|->
name|is_rep1
index|[
name|state
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|price
operator|+=
name|rc_bit_1_price
argument_list|(
name|coder
operator|->
name|is_rep1
index|[
name|state
index|]
argument_list|)
expr_stmt|;
name|price
operator|+=
name|rc_bit_price
argument_list|(
name|coder
operator|->
name|is_rep2
index|[
name|state
index|]
argument_list|,
name|rep_index
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|price
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|get_rep_price
parameter_list|(
specifier|const
name|lzma_coder
modifier|*
specifier|const
name|coder
parameter_list|,
specifier|const
name|uint32_t
name|rep_index
parameter_list|,
specifier|const
name|uint32_t
name|len
parameter_list|,
specifier|const
name|lzma_lzma_state
name|state
parameter_list|,
specifier|const
name|uint32_t
name|pos_state
parameter_list|)
block|{
return|return
name|get_len_price
argument_list|(
operator|&
name|coder
operator|->
name|rep_len_encoder
argument_list|,
name|len
argument_list|,
name|pos_state
argument_list|)
operator|+
name|get_pure_rep_price
argument_list|(
name|coder
argument_list|,
name|rep_index
argument_list|,
name|state
argument_list|,
name|pos_state
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|get_pos_len_price
parameter_list|(
specifier|const
name|lzma_coder
modifier|*
specifier|const
name|coder
parameter_list|,
specifier|const
name|uint32_t
name|pos
parameter_list|,
specifier|const
name|uint32_t
name|len
parameter_list|,
specifier|const
name|uint32_t
name|pos_state
parameter_list|)
block|{
specifier|const
name|uint32_t
name|len_to_pos_state
init|=
name|get_len_to_pos_state
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|uint32_t
name|price
decl_stmt|;
if|if
condition|(
name|pos
operator|<
name|FULL_DISTANCES
condition|)
block|{
name|price
operator|=
name|coder
operator|->
name|distances_prices
index|[
name|len_to_pos_state
index|]
index|[
name|pos
index|]
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|uint32_t
name|pos_slot
init|=
name|get_pos_slot_2
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|price
operator|=
name|coder
operator|->
name|pos_slot_prices
index|[
name|len_to_pos_state
index|]
index|[
name|pos_slot
index|]
operator|+
name|coder
operator|->
name|align_prices
index|[
name|pos
operator|&
name|ALIGN_MASK
index|]
expr_stmt|;
block|}
name|price
operator|+=
name|get_len_price
argument_list|(
operator|&
name|coder
operator|->
name|match_len_encoder
argument_list|,
name|len
argument_list|,
name|pos_state
argument_list|)
expr_stmt|;
return|return
name|price
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fill_distances_prices
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|)
block|{
for|for
control|(
name|uint32_t
name|len_to_pos_state
init|=
literal|0
init|;
name|len_to_pos_state
operator|<
name|LEN_TO_POS_STATES
condition|;
operator|++
name|len_to_pos_state
control|)
block|{
name|uint32_t
modifier|*
specifier|const
name|pos_slot_prices
init|=
name|coder
operator|->
name|pos_slot_prices
index|[
name|len_to_pos_state
index|]
decl_stmt|;
comment|// Price to encode the pos_slot.
for|for
control|(
name|uint32_t
name|pos_slot
init|=
literal|0
init|;
name|pos_slot
operator|<
name|coder
operator|->
name|dist_table_size
condition|;
operator|++
name|pos_slot
control|)
name|pos_slot_prices
index|[
name|pos_slot
index|]
operator|=
name|rc_bittree_price
argument_list|(
name|coder
operator|->
name|pos_slot
index|[
name|len_to_pos_state
index|]
argument_list|,
name|POS_SLOT_BITS
argument_list|,
name|pos_slot
argument_list|)
expr_stmt|;
comment|// For matches with distance>= FULL_DISTANCES, add the price
comment|// of the direct bits part of the match distance. (Align bits
comment|// are handled by fill_align_prices()).
for|for
control|(
name|uint32_t
name|pos_slot
init|=
name|END_POS_MODEL_INDEX
init|;
name|pos_slot
operator|<
name|coder
operator|->
name|dist_table_size
condition|;
operator|++
name|pos_slot
control|)
name|pos_slot_prices
index|[
name|pos_slot
index|]
operator|+=
name|rc_direct_price
argument_list|(
operator|(
operator|(
name|pos_slot
operator|>>
literal|1
operator|)
operator|-
literal|1
operator|)
operator|-
name|ALIGN_BITS
argument_list|)
expr_stmt|;
comment|// Distances in the range [0, 3] are fully encoded with
comment|// pos_slot, so they are used for coder->distances_prices
comment|// as is.
for|for
control|(
name|uint32_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|START_POS_MODEL_INDEX
condition|;
operator|++
name|i
control|)
name|coder
operator|->
name|distances_prices
index|[
name|len_to_pos_state
index|]
index|[
name|i
index|]
operator|=
name|pos_slot_prices
index|[
name|i
index|]
expr_stmt|;
block|}
comment|// Distances in the range [4, 127] depend on pos_slot and pos_special.
comment|// We do this in a loop separate from the above loop to avoid
comment|// redundant calls to get_pos_slot().
for|for
control|(
name|uint32_t
name|i
init|=
name|START_POS_MODEL_INDEX
init|;
name|i
operator|<
name|FULL_DISTANCES
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|uint32_t
name|pos_slot
init|=
name|get_pos_slot
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|uint32_t
name|footer_bits
init|=
operator|(
operator|(
name|pos_slot
operator|>>
literal|1
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
specifier|const
name|uint32_t
name|base
init|=
operator|(
literal|2
operator||
operator|(
name|pos_slot
operator|&
literal|1
operator|)
operator|)
operator|<<
name|footer_bits
decl_stmt|;
specifier|const
name|uint32_t
name|price
init|=
name|rc_bittree_reverse_price
argument_list|(
name|coder
operator|->
name|pos_special
operator|+
name|base
operator|-
name|pos_slot
operator|-
literal|1
argument_list|,
name|footer_bits
argument_list|,
name|i
operator|-
name|base
argument_list|)
decl_stmt|;
for|for
control|(
name|uint32_t
name|len_to_pos_state
init|=
literal|0
init|;
name|len_to_pos_state
operator|<
name|LEN_TO_POS_STATES
condition|;
operator|++
name|len_to_pos_state
control|)
name|coder
operator|->
name|distances_prices
index|[
name|len_to_pos_state
index|]
index|[
name|i
index|]
operator|=
name|price
operator|+
name|coder
operator|->
name|pos_slot_prices
index|[
name|len_to_pos_state
index|]
index|[
name|pos_slot
index|]
expr_stmt|;
block|}
name|coder
operator|->
name|match_price_count
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|fill_align_prices
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|)
block|{
for|for
control|(
name|uint32_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ALIGN_TABLE_SIZE
condition|;
operator|++
name|i
control|)
name|coder
operator|->
name|align_prices
index|[
name|i
index|]
operator|=
name|rc_bittree_reverse_price
argument_list|(
name|coder
operator|->
name|pos_align
argument_list|,
name|ALIGN_BITS
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|coder
operator|->
name|align_price_count
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/////////////
end_comment

begin_comment
comment|// Optimal //
end_comment

begin_comment
comment|/////////////
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|make_literal
parameter_list|(
name|lzma_optimal
modifier|*
name|optimal
parameter_list|)
block|{
name|optimal
operator|->
name|back_prev
operator|=
name|UINT32_MAX
expr_stmt|;
name|optimal
operator|->
name|prev_1_is_literal
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|make_short_rep
parameter_list|(
name|lzma_optimal
modifier|*
name|optimal
parameter_list|)
block|{
name|optimal
operator|->
name|back_prev
operator|=
literal|0
expr_stmt|;
name|optimal
operator|->
name|prev_1_is_literal
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|is_short_rep
parameter_list|(
name|optimal
parameter_list|)
define|\
value|((optimal).back_prev == 0)
end_define

begin_function
specifier|static
name|void
name|backward
parameter_list|(
name|lzma_coder
modifier|*
specifier|restrict
name|coder
parameter_list|,
name|uint32_t
modifier|*
specifier|restrict
name|len_res
parameter_list|,
name|uint32_t
modifier|*
specifier|restrict
name|back_res
parameter_list|,
name|uint32_t
name|cur
parameter_list|)
block|{
name|coder
operator|->
name|opts_end_index
operator|=
name|cur
expr_stmt|;
name|uint32_t
name|pos_mem
init|=
name|coder
operator|->
name|opts
index|[
name|cur
index|]
operator|.
name|pos_prev
decl_stmt|;
name|uint32_t
name|back_mem
init|=
name|coder
operator|->
name|opts
index|[
name|cur
index|]
operator|.
name|back_prev
decl_stmt|;
do|do
block|{
if|if
condition|(
name|coder
operator|->
name|opts
index|[
name|cur
index|]
operator|.
name|prev_1_is_literal
condition|)
block|{
name|make_literal
argument_list|(
operator|&
name|coder
operator|->
name|opts
index|[
name|pos_mem
index|]
argument_list|)
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|pos_mem
index|]
operator|.
name|pos_prev
operator|=
name|pos_mem
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|opts
index|[
name|cur
index|]
operator|.
name|prev_2
condition|)
block|{
name|coder
operator|->
name|opts
index|[
name|pos_mem
operator|-
literal|1
index|]
operator|.
name|prev_1_is_literal
operator|=
name|false
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|pos_mem
operator|-
literal|1
index|]
operator|.
name|pos_prev
operator|=
name|coder
operator|->
name|opts
index|[
name|cur
index|]
operator|.
name|pos_prev_2
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|pos_mem
operator|-
literal|1
index|]
operator|.
name|back_prev
operator|=
name|coder
operator|->
name|opts
index|[
name|cur
index|]
operator|.
name|back_prev_2
expr_stmt|;
block|}
block|}
specifier|const
name|uint32_t
name|pos_prev
init|=
name|pos_mem
decl_stmt|;
specifier|const
name|uint32_t
name|back_cur
init|=
name|back_mem
decl_stmt|;
name|back_mem
operator|=
name|coder
operator|->
name|opts
index|[
name|pos_prev
index|]
operator|.
name|back_prev
expr_stmt|;
name|pos_mem
operator|=
name|coder
operator|->
name|opts
index|[
name|pos_prev
index|]
operator|.
name|pos_prev
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|pos_prev
index|]
operator|.
name|back_prev
operator|=
name|back_cur
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|pos_prev
index|]
operator|.
name|pos_prev
operator|=
name|cur
expr_stmt|;
name|cur
operator|=
name|pos_prev
expr_stmt|;
block|}
do|while
condition|(
name|cur
operator|!=
literal|0
condition|)
do|;
name|coder
operator|->
name|opts_current_index
operator|=
name|coder
operator|->
name|opts
index|[
literal|0
index|]
operator|.
name|pos_prev
expr_stmt|;
operator|*
name|len_res
operator|=
name|coder
operator|->
name|opts
index|[
literal|0
index|]
operator|.
name|pos_prev
expr_stmt|;
operator|*
name|back_res
operator|=
name|coder
operator|->
name|opts
index|[
literal|0
index|]
operator|.
name|back_prev
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|//////////
end_comment

begin_comment
comment|// Main //
end_comment

begin_comment
comment|//////////
end_comment

begin_function
specifier|static
specifier|inline
name|uint32_t
name|helper1
parameter_list|(
name|lzma_coder
modifier|*
specifier|restrict
name|coder
parameter_list|,
name|lzma_mf
modifier|*
specifier|restrict
name|mf
parameter_list|,
name|uint32_t
modifier|*
specifier|restrict
name|back_res
parameter_list|,
name|uint32_t
modifier|*
specifier|restrict
name|len_res
parameter_list|,
name|uint32_t
name|position
parameter_list|)
block|{
specifier|const
name|uint32_t
name|nice_len
init|=
name|mf
operator|->
name|nice_len
decl_stmt|;
name|uint32_t
name|len_main
decl_stmt|;
name|uint32_t
name|matches_count
decl_stmt|;
if|if
condition|(
name|mf
operator|->
name|read_ahead
operator|==
literal|0
condition|)
block|{
name|len_main
operator|=
name|mf_find
argument_list|(
name|mf
argument_list|,
operator|&
name|matches_count
argument_list|,
name|coder
operator|->
name|matches
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|mf
operator|->
name|read_ahead
operator|==
literal|1
argument_list|)
expr_stmt|;
name|len_main
operator|=
name|coder
operator|->
name|longest_match_length
expr_stmt|;
name|matches_count
operator|=
name|coder
operator|->
name|matches_count
expr_stmt|;
block|}
specifier|const
name|uint32_t
name|buf_avail
init|=
name|my_min
argument_list|(
name|mf_avail
argument_list|(
name|mf
argument_list|)
operator|+
literal|1
argument_list|,
name|MATCH_LEN_MAX
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf_avail
operator|<
literal|2
condition|)
block|{
operator|*
name|back_res
operator|=
name|UINT32_MAX
expr_stmt|;
operator|*
name|len_res
operator|=
literal|1
expr_stmt|;
return|return
name|UINT32_MAX
return|;
block|}
specifier|const
name|uint8_t
modifier|*
specifier|const
name|buf
init|=
name|mf_ptr
argument_list|(
name|mf
argument_list|)
operator|-
literal|1
decl_stmt|;
name|uint32_t
name|rep_lens
index|[
name|REP_DISTANCES
index|]
decl_stmt|;
name|uint32_t
name|rep_max_index
init|=
literal|0
decl_stmt|;
for|for
control|(
name|uint32_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|REP_DISTANCES
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|uint8_t
modifier|*
specifier|const
name|buf_back
init|=
name|buf
operator|-
name|coder
operator|->
name|reps
index|[
name|i
index|]
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|not_equal_16
argument_list|(
name|buf
argument_list|,
name|buf_back
argument_list|)
condition|)
block|{
name|rep_lens
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|uint32_t
name|len_test
decl_stmt|;
for|for
control|(
name|len_test
operator|=
literal|2
init|;
name|len_test
operator|<
name|buf_avail
operator|&&
name|buf
index|[
name|len_test
index|]
operator|==
name|buf_back
index|[
name|len_test
index|]
condition|;
operator|++
name|len_test
control|)
empty_stmt|;
name|rep_lens
index|[
name|i
index|]
operator|=
name|len_test
expr_stmt|;
if|if
condition|(
name|len_test
operator|>
name|rep_lens
index|[
name|rep_max_index
index|]
condition|)
name|rep_max_index
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|rep_lens
index|[
name|rep_max_index
index|]
operator|>=
name|nice_len
condition|)
block|{
operator|*
name|back_res
operator|=
name|rep_max_index
expr_stmt|;
operator|*
name|len_res
operator|=
name|rep_lens
index|[
name|rep_max_index
index|]
expr_stmt|;
name|mf_skip
argument_list|(
name|mf
argument_list|,
operator|*
name|len_res
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|UINT32_MAX
return|;
block|}
if|if
condition|(
name|len_main
operator|>=
name|nice_len
condition|)
block|{
operator|*
name|back_res
operator|=
name|coder
operator|->
name|matches
index|[
name|matches_count
operator|-
literal|1
index|]
operator|.
name|dist
operator|+
name|REP_DISTANCES
expr_stmt|;
operator|*
name|len_res
operator|=
name|len_main
expr_stmt|;
name|mf_skip
argument_list|(
name|mf
argument_list|,
name|len_main
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|UINT32_MAX
return|;
block|}
specifier|const
name|uint8_t
name|current_byte
init|=
operator|*
name|buf
decl_stmt|;
specifier|const
name|uint8_t
name|match_byte
init|=
operator|*
operator|(
name|buf
operator|-
name|coder
operator|->
name|reps
index|[
literal|0
index|]
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|len_main
operator|<
literal|2
operator|&&
name|current_byte
operator|!=
name|match_byte
operator|&&
name|rep_lens
index|[
name|rep_max_index
index|]
operator|<
literal|2
condition|)
block|{
operator|*
name|back_res
operator|=
name|UINT32_MAX
expr_stmt|;
operator|*
name|len_res
operator|=
literal|1
expr_stmt|;
return|return
name|UINT32_MAX
return|;
block|}
name|coder
operator|->
name|opts
index|[
literal|0
index|]
operator|.
name|state
operator|=
name|coder
operator|->
name|state
expr_stmt|;
specifier|const
name|uint32_t
name|pos_state
init|=
name|position
operator|&
name|coder
operator|->
name|pos_mask
decl_stmt|;
name|coder
operator|->
name|opts
index|[
literal|1
index|]
operator|.
name|price
operator|=
name|rc_bit_0_price
argument_list|(
name|coder
operator|->
name|is_match
index|[
name|coder
operator|->
name|state
index|]
index|[
name|pos_state
index|]
argument_list|)
operator|+
name|get_literal_price
argument_list|(
name|coder
argument_list|,
name|position
argument_list|,
name|buf
index|[
operator|-
literal|1
index|]
argument_list|,
operator|!
name|is_literal_state
argument_list|(
name|coder
operator|->
name|state
argument_list|)
argument_list|,
name|match_byte
argument_list|,
name|current_byte
argument_list|)
expr_stmt|;
name|make_literal
argument_list|(
operator|&
name|coder
operator|->
name|opts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
specifier|const
name|uint32_t
name|match_price
init|=
name|rc_bit_1_price
argument_list|(
name|coder
operator|->
name|is_match
index|[
name|coder
operator|->
name|state
index|]
index|[
name|pos_state
index|]
argument_list|)
decl_stmt|;
specifier|const
name|uint32_t
name|rep_match_price
init|=
name|match_price
operator|+
name|rc_bit_1_price
argument_list|(
name|coder
operator|->
name|is_rep
index|[
name|coder
operator|->
name|state
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|match_byte
operator|==
name|current_byte
condition|)
block|{
specifier|const
name|uint32_t
name|short_rep_price
init|=
name|rep_match_price
operator|+
name|get_short_rep_price
argument_list|(
name|coder
argument_list|,
name|coder
operator|->
name|state
argument_list|,
name|pos_state
argument_list|)
decl_stmt|;
if|if
condition|(
name|short_rep_price
operator|<
name|coder
operator|->
name|opts
index|[
literal|1
index|]
operator|.
name|price
condition|)
block|{
name|coder
operator|->
name|opts
index|[
literal|1
index|]
operator|.
name|price
operator|=
name|short_rep_price
expr_stmt|;
name|make_short_rep
argument_list|(
operator|&
name|coder
operator|->
name|opts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
specifier|const
name|uint32_t
name|len_end
init|=
name|my_max
argument_list|(
name|len_main
argument_list|,
name|rep_lens
index|[
name|rep_max_index
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|len_end
operator|<
literal|2
condition|)
block|{
operator|*
name|back_res
operator|=
name|coder
operator|->
name|opts
index|[
literal|1
index|]
operator|.
name|back_prev
expr_stmt|;
operator|*
name|len_res
operator|=
literal|1
expr_stmt|;
return|return
name|UINT32_MAX
return|;
block|}
name|coder
operator|->
name|opts
index|[
literal|1
index|]
operator|.
name|pos_prev
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|uint32_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|REP_DISTANCES
condition|;
operator|++
name|i
control|)
name|coder
operator|->
name|opts
index|[
literal|0
index|]
operator|.
name|backs
index|[
name|i
index|]
operator|=
name|coder
operator|->
name|reps
index|[
name|i
index|]
expr_stmt|;
name|uint32_t
name|len
init|=
name|len_end
decl_stmt|;
do|do
block|{
name|coder
operator|->
name|opts
index|[
name|len
index|]
operator|.
name|price
operator|=
name|RC_INFINITY_PRICE
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|len
operator|>=
literal|2
condition|)
do|;
for|for
control|(
name|uint32_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|REP_DISTANCES
condition|;
operator|++
name|i
control|)
block|{
name|uint32_t
name|rep_len
init|=
name|rep_lens
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|rep_len
operator|<
literal|2
condition|)
continue|continue;
specifier|const
name|uint32_t
name|price
init|=
name|rep_match_price
operator|+
name|get_pure_rep_price
argument_list|(
name|coder
argument_list|,
name|i
argument_list|,
name|coder
operator|->
name|state
argument_list|,
name|pos_state
argument_list|)
decl_stmt|;
do|do
block|{
specifier|const
name|uint32_t
name|cur_and_len_price
init|=
name|price
operator|+
name|get_len_price
argument_list|(
operator|&
name|coder
operator|->
name|rep_len_encoder
argument_list|,
name|rep_len
argument_list|,
name|pos_state
argument_list|)
decl_stmt|;
if|if
condition|(
name|cur_and_len_price
operator|<
name|coder
operator|->
name|opts
index|[
name|rep_len
index|]
operator|.
name|price
condition|)
block|{
name|coder
operator|->
name|opts
index|[
name|rep_len
index|]
operator|.
name|price
operator|=
name|cur_and_len_price
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|rep_len
index|]
operator|.
name|pos_prev
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|rep_len
index|]
operator|.
name|back_prev
operator|=
name|i
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|rep_len
index|]
operator|.
name|prev_1_is_literal
operator|=
name|false
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|--
name|rep_len
operator|>=
literal|2
condition|)
do|;
block|}
specifier|const
name|uint32_t
name|normal_match_price
init|=
name|match_price
operator|+
name|rc_bit_0_price
argument_list|(
name|coder
operator|->
name|is_rep
index|[
name|coder
operator|->
name|state
index|]
argument_list|)
decl_stmt|;
name|len
operator|=
name|rep_lens
index|[
literal|0
index|]
operator|>=
literal|2
condition|?
name|rep_lens
index|[
literal|0
index|]
operator|+
literal|1
else|:
literal|2
expr_stmt|;
if|if
condition|(
name|len
operator|<=
name|len_main
condition|)
block|{
name|uint32_t
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|>
name|coder
operator|->
name|matches
index|[
name|i
index|]
operator|.
name|len
condition|)
operator|++
name|i
expr_stmt|;
for|for
control|(
init|;
condition|;
operator|++
name|len
control|)
block|{
specifier|const
name|uint32_t
name|dist
init|=
name|coder
operator|->
name|matches
index|[
name|i
index|]
operator|.
name|dist
decl_stmt|;
specifier|const
name|uint32_t
name|cur_and_len_price
init|=
name|normal_match_price
operator|+
name|get_pos_len_price
argument_list|(
name|coder
argument_list|,
name|dist
argument_list|,
name|len
argument_list|,
name|pos_state
argument_list|)
decl_stmt|;
if|if
condition|(
name|cur_and_len_price
operator|<
name|coder
operator|->
name|opts
index|[
name|len
index|]
operator|.
name|price
condition|)
block|{
name|coder
operator|->
name|opts
index|[
name|len
index|]
operator|.
name|price
operator|=
name|cur_and_len_price
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|len
index|]
operator|.
name|pos_prev
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|len
index|]
operator|.
name|back_prev
operator|=
name|dist
operator|+
name|REP_DISTANCES
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|len
index|]
operator|.
name|prev_1_is_literal
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
name|coder
operator|->
name|matches
index|[
name|i
index|]
operator|.
name|len
condition|)
if|if
condition|(
operator|++
name|i
operator|==
name|matches_count
condition|)
break|break;
block|}
block|}
return|return
name|len_end
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|helper2
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|uint32_t
modifier|*
name|reps
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|uint32_t
name|len_end
parameter_list|,
name|uint32_t
name|position
parameter_list|,
specifier|const
name|uint32_t
name|cur
parameter_list|,
specifier|const
name|uint32_t
name|nice_len
parameter_list|,
specifier|const
name|uint32_t
name|buf_avail_full
parameter_list|)
block|{
name|uint32_t
name|matches_count
init|=
name|coder
operator|->
name|matches_count
decl_stmt|;
name|uint32_t
name|new_len
init|=
name|coder
operator|->
name|longest_match_length
decl_stmt|;
name|uint32_t
name|pos_prev
init|=
name|coder
operator|->
name|opts
index|[
name|cur
index|]
operator|.
name|pos_prev
decl_stmt|;
name|lzma_lzma_state
name|state
decl_stmt|;
if|if
condition|(
name|coder
operator|->
name|opts
index|[
name|cur
index|]
operator|.
name|prev_1_is_literal
condition|)
block|{
operator|--
name|pos_prev
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|opts
index|[
name|cur
index|]
operator|.
name|prev_2
condition|)
block|{
name|state
operator|=
name|coder
operator|->
name|opts
index|[
name|coder
operator|->
name|opts
index|[
name|cur
index|]
operator|.
name|pos_prev_2
index|]
operator|.
name|state
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|opts
index|[
name|cur
index|]
operator|.
name|back_prev_2
operator|<
name|REP_DISTANCES
condition|)
name|update_long_rep
argument_list|(
name|state
argument_list|)
expr_stmt|;
else|else
name|update_match
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|coder
operator|->
name|opts
index|[
name|pos_prev
index|]
operator|.
name|state
expr_stmt|;
block|}
name|update_literal
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|coder
operator|->
name|opts
index|[
name|pos_prev
index|]
operator|.
name|state
expr_stmt|;
block|}
if|if
condition|(
name|pos_prev
operator|==
name|cur
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|is_short_rep
argument_list|(
name|coder
operator|->
name|opts
index|[
name|cur
index|]
argument_list|)
condition|)
name|update_short_rep
argument_list|(
name|state
argument_list|)
expr_stmt|;
else|else
name|update_literal
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint32_t
name|pos
decl_stmt|;
if|if
condition|(
name|coder
operator|->
name|opts
index|[
name|cur
index|]
operator|.
name|prev_1_is_literal
operator|&&
name|coder
operator|->
name|opts
index|[
name|cur
index|]
operator|.
name|prev_2
condition|)
block|{
name|pos_prev
operator|=
name|coder
operator|->
name|opts
index|[
name|cur
index|]
operator|.
name|pos_prev_2
expr_stmt|;
name|pos
operator|=
name|coder
operator|->
name|opts
index|[
name|cur
index|]
operator|.
name|back_prev_2
expr_stmt|;
name|update_long_rep
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|=
name|coder
operator|->
name|opts
index|[
name|cur
index|]
operator|.
name|back_prev
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|REP_DISTANCES
condition|)
name|update_long_rep
argument_list|(
name|state
argument_list|)
expr_stmt|;
else|else
name|update_match
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|<
name|REP_DISTANCES
condition|)
block|{
name|reps
index|[
literal|0
index|]
operator|=
name|coder
operator|->
name|opts
index|[
name|pos_prev
index|]
operator|.
name|backs
index|[
name|pos
index|]
expr_stmt|;
name|uint32_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|pos
condition|;
operator|++
name|i
control|)
name|reps
index|[
name|i
index|]
operator|=
name|coder
operator|->
name|opts
index|[
name|pos_prev
index|]
operator|.
name|backs
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|REP_DISTANCES
condition|;
operator|++
name|i
control|)
name|reps
index|[
name|i
index|]
operator|=
name|coder
operator|->
name|opts
index|[
name|pos_prev
index|]
operator|.
name|backs
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|reps
index|[
literal|0
index|]
operator|=
name|pos
operator|-
name|REP_DISTANCES
expr_stmt|;
for|for
control|(
name|uint32_t
name|i
init|=
literal|1
init|;
name|i
operator|<
name|REP_DISTANCES
condition|;
operator|++
name|i
control|)
name|reps
index|[
name|i
index|]
operator|=
name|coder
operator|->
name|opts
index|[
name|pos_prev
index|]
operator|.
name|backs
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
name|coder
operator|->
name|opts
index|[
name|cur
index|]
operator|.
name|state
operator|=
name|state
expr_stmt|;
for|for
control|(
name|uint32_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|REP_DISTANCES
condition|;
operator|++
name|i
control|)
name|coder
operator|->
name|opts
index|[
name|cur
index|]
operator|.
name|backs
index|[
name|i
index|]
operator|=
name|reps
index|[
name|i
index|]
expr_stmt|;
specifier|const
name|uint32_t
name|cur_price
init|=
name|coder
operator|->
name|opts
index|[
name|cur
index|]
operator|.
name|price
decl_stmt|;
specifier|const
name|uint8_t
name|current_byte
init|=
operator|*
name|buf
decl_stmt|;
specifier|const
name|uint8_t
name|match_byte
init|=
operator|*
operator|(
name|buf
operator|-
name|reps
index|[
literal|0
index|]
operator|-
literal|1
operator|)
decl_stmt|;
specifier|const
name|uint32_t
name|pos_state
init|=
name|position
operator|&
name|coder
operator|->
name|pos_mask
decl_stmt|;
specifier|const
name|uint32_t
name|cur_and_1_price
init|=
name|cur_price
operator|+
name|rc_bit_0_price
argument_list|(
name|coder
operator|->
name|is_match
index|[
name|state
index|]
index|[
name|pos_state
index|]
argument_list|)
operator|+
name|get_literal_price
argument_list|(
name|coder
argument_list|,
name|position
argument_list|,
name|buf
index|[
operator|-
literal|1
index|]
argument_list|,
operator|!
name|is_literal_state
argument_list|(
name|state
argument_list|)
argument_list|,
name|match_byte
argument_list|,
name|current_byte
argument_list|)
decl_stmt|;
name|bool
name|next_is_literal
init|=
name|false
decl_stmt|;
if|if
condition|(
name|cur_and_1_price
operator|<
name|coder
operator|->
name|opts
index|[
name|cur
operator|+
literal|1
index|]
operator|.
name|price
condition|)
block|{
name|coder
operator|->
name|opts
index|[
name|cur
operator|+
literal|1
index|]
operator|.
name|price
operator|=
name|cur_and_1_price
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|cur
operator|+
literal|1
index|]
operator|.
name|pos_prev
operator|=
name|cur
expr_stmt|;
name|make_literal
argument_list|(
operator|&
name|coder
operator|->
name|opts
index|[
name|cur
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|next_is_literal
operator|=
name|true
expr_stmt|;
block|}
specifier|const
name|uint32_t
name|match_price
init|=
name|cur_price
operator|+
name|rc_bit_1_price
argument_list|(
name|coder
operator|->
name|is_match
index|[
name|state
index|]
index|[
name|pos_state
index|]
argument_list|)
decl_stmt|;
specifier|const
name|uint32_t
name|rep_match_price
init|=
name|match_price
operator|+
name|rc_bit_1_price
argument_list|(
name|coder
operator|->
name|is_rep
index|[
name|state
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|match_byte
operator|==
name|current_byte
operator|&&
operator|!
operator|(
name|coder
operator|->
name|opts
index|[
name|cur
operator|+
literal|1
index|]
operator|.
name|pos_prev
operator|<
name|cur
operator|&&
name|coder
operator|->
name|opts
index|[
name|cur
operator|+
literal|1
index|]
operator|.
name|back_prev
operator|==
literal|0
operator|)
condition|)
block|{
specifier|const
name|uint32_t
name|short_rep_price
init|=
name|rep_match_price
operator|+
name|get_short_rep_price
argument_list|(
name|coder
argument_list|,
name|state
argument_list|,
name|pos_state
argument_list|)
decl_stmt|;
if|if
condition|(
name|short_rep_price
operator|<=
name|coder
operator|->
name|opts
index|[
name|cur
operator|+
literal|1
index|]
operator|.
name|price
condition|)
block|{
name|coder
operator|->
name|opts
index|[
name|cur
operator|+
literal|1
index|]
operator|.
name|price
operator|=
name|short_rep_price
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|cur
operator|+
literal|1
index|]
operator|.
name|pos_prev
operator|=
name|cur
expr_stmt|;
name|make_short_rep
argument_list|(
operator|&
name|coder
operator|->
name|opts
index|[
name|cur
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|next_is_literal
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|buf_avail_full
operator|<
literal|2
condition|)
return|return
name|len_end
return|;
specifier|const
name|uint32_t
name|buf_avail
init|=
name|my_min
argument_list|(
name|buf_avail_full
argument_list|,
name|nice_len
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|next_is_literal
operator|&&
name|match_byte
operator|!=
name|current_byte
condition|)
block|{
comment|// speed optimization
comment|// try literal + rep0
specifier|const
name|uint8_t
modifier|*
specifier|const
name|buf_back
init|=
name|buf
operator|-
name|reps
index|[
literal|0
index|]
operator|-
literal|1
decl_stmt|;
specifier|const
name|uint32_t
name|limit
init|=
name|my_min
argument_list|(
name|buf_avail_full
argument_list|,
name|nice_len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|uint32_t
name|len_test
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|len_test
operator|<
name|limit
operator|&&
name|buf
index|[
name|len_test
index|]
operator|==
name|buf_back
index|[
name|len_test
index|]
condition|)
operator|++
name|len_test
expr_stmt|;
operator|--
name|len_test
expr_stmt|;
if|if
condition|(
name|len_test
operator|>=
literal|2
condition|)
block|{
name|lzma_lzma_state
name|state_2
init|=
name|state
decl_stmt|;
name|update_literal
argument_list|(
name|state_2
argument_list|)
expr_stmt|;
specifier|const
name|uint32_t
name|pos_state_next
init|=
operator|(
name|position
operator|+
literal|1
operator|)
operator|&
name|coder
operator|->
name|pos_mask
decl_stmt|;
specifier|const
name|uint32_t
name|next_rep_match_price
init|=
name|cur_and_1_price
operator|+
name|rc_bit_1_price
argument_list|(
name|coder
operator|->
name|is_match
index|[
name|state_2
index|]
index|[
name|pos_state_next
index|]
argument_list|)
operator|+
name|rc_bit_1_price
argument_list|(
name|coder
operator|->
name|is_rep
index|[
name|state_2
index|]
argument_list|)
decl_stmt|;
comment|//for (; len_test>= 2; --len_test) {
specifier|const
name|uint32_t
name|offset
init|=
name|cur
operator|+
literal|1
operator|+
name|len_test
decl_stmt|;
while|while
condition|(
name|len_end
operator|<
name|offset
condition|)
name|coder
operator|->
name|opts
index|[
operator|++
name|len_end
index|]
operator|.
name|price
operator|=
name|RC_INFINITY_PRICE
expr_stmt|;
specifier|const
name|uint32_t
name|cur_and_len_price
init|=
name|next_rep_match_price
operator|+
name|get_rep_price
argument_list|(
name|coder
argument_list|,
literal|0
argument_list|,
name|len_test
argument_list|,
name|state_2
argument_list|,
name|pos_state_next
argument_list|)
decl_stmt|;
if|if
condition|(
name|cur_and_len_price
operator|<
name|coder
operator|->
name|opts
index|[
name|offset
index|]
operator|.
name|price
condition|)
block|{
name|coder
operator|->
name|opts
index|[
name|offset
index|]
operator|.
name|price
operator|=
name|cur_and_len_price
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|offset
index|]
operator|.
name|pos_prev
operator|=
name|cur
operator|+
literal|1
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|offset
index|]
operator|.
name|back_prev
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|offset
index|]
operator|.
name|prev_1_is_literal
operator|=
name|true
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|offset
index|]
operator|.
name|prev_2
operator|=
name|false
expr_stmt|;
block|}
comment|//}
block|}
block|}
name|uint32_t
name|start_len
init|=
literal|2
decl_stmt|;
comment|// speed optimization
for|for
control|(
name|uint32_t
name|rep_index
init|=
literal|0
init|;
name|rep_index
operator|<
name|REP_DISTANCES
condition|;
operator|++
name|rep_index
control|)
block|{
specifier|const
name|uint8_t
modifier|*
specifier|const
name|buf_back
init|=
name|buf
operator|-
name|reps
index|[
name|rep_index
index|]
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|not_equal_16
argument_list|(
name|buf
argument_list|,
name|buf_back
argument_list|)
condition|)
continue|continue;
name|uint32_t
name|len_test
decl_stmt|;
for|for
control|(
name|len_test
operator|=
literal|2
init|;
name|len_test
operator|<
name|buf_avail
operator|&&
name|buf
index|[
name|len_test
index|]
operator|==
name|buf_back
index|[
name|len_test
index|]
condition|;
operator|++
name|len_test
control|)
empty_stmt|;
while|while
condition|(
name|len_end
operator|<
name|cur
operator|+
name|len_test
condition|)
name|coder
operator|->
name|opts
index|[
operator|++
name|len_end
index|]
operator|.
name|price
operator|=
name|RC_INFINITY_PRICE
expr_stmt|;
specifier|const
name|uint32_t
name|len_test_temp
init|=
name|len_test
decl_stmt|;
specifier|const
name|uint32_t
name|price
init|=
name|rep_match_price
operator|+
name|get_pure_rep_price
argument_list|(
name|coder
argument_list|,
name|rep_index
argument_list|,
name|state
argument_list|,
name|pos_state
argument_list|)
decl_stmt|;
do|do
block|{
specifier|const
name|uint32_t
name|cur_and_len_price
init|=
name|price
operator|+
name|get_len_price
argument_list|(
operator|&
name|coder
operator|->
name|rep_len_encoder
argument_list|,
name|len_test
argument_list|,
name|pos_state
argument_list|)
decl_stmt|;
if|if
condition|(
name|cur_and_len_price
operator|<
name|coder
operator|->
name|opts
index|[
name|cur
operator|+
name|len_test
index|]
operator|.
name|price
condition|)
block|{
name|coder
operator|->
name|opts
index|[
name|cur
operator|+
name|len_test
index|]
operator|.
name|price
operator|=
name|cur_and_len_price
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|cur
operator|+
name|len_test
index|]
operator|.
name|pos_prev
operator|=
name|cur
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|cur
operator|+
name|len_test
index|]
operator|.
name|back_prev
operator|=
name|rep_index
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|cur
operator|+
name|len_test
index|]
operator|.
name|prev_1_is_literal
operator|=
name|false
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|--
name|len_test
operator|>=
literal|2
condition|)
do|;
name|len_test
operator|=
name|len_test_temp
expr_stmt|;
if|if
condition|(
name|rep_index
operator|==
literal|0
condition|)
name|start_len
operator|=
name|len_test
operator|+
literal|1
expr_stmt|;
name|uint32_t
name|len_test_2
init|=
name|len_test
operator|+
literal|1
decl_stmt|;
specifier|const
name|uint32_t
name|limit
init|=
name|my_min
argument_list|(
name|buf_avail_full
argument_list|,
name|len_test_2
operator|+
name|nice_len
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|len_test_2
operator|<
name|limit
operator|&&
name|buf
index|[
name|len_test_2
index|]
operator|==
name|buf_back
index|[
name|len_test_2
index|]
condition|;
operator|++
name|len_test_2
control|)
empty_stmt|;
name|len_test_2
operator|-=
name|len_test
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len_test_2
operator|>=
literal|2
condition|)
block|{
name|lzma_lzma_state
name|state_2
init|=
name|state
decl_stmt|;
name|update_long_rep
argument_list|(
name|state_2
argument_list|)
expr_stmt|;
name|uint32_t
name|pos_state_next
init|=
operator|(
name|position
operator|+
name|len_test
operator|)
operator|&
name|coder
operator|->
name|pos_mask
decl_stmt|;
specifier|const
name|uint32_t
name|cur_and_len_literal_price
init|=
name|price
operator|+
name|get_len_price
argument_list|(
operator|&
name|coder
operator|->
name|rep_len_encoder
argument_list|,
name|len_test
argument_list|,
name|pos_state
argument_list|)
operator|+
name|rc_bit_0_price
argument_list|(
name|coder
operator|->
name|is_match
index|[
name|state_2
index|]
index|[
name|pos_state_next
index|]
argument_list|)
operator|+
name|get_literal_price
argument_list|(
name|coder
argument_list|,
name|position
operator|+
name|len_test
argument_list|,
name|buf
index|[
name|len_test
operator|-
literal|1
index|]
argument_list|,
name|true
argument_list|,
name|buf_back
index|[
name|len_test
index|]
argument_list|,
name|buf
index|[
name|len_test
index|]
argument_list|)
decl_stmt|;
name|update_literal
argument_list|(
name|state_2
argument_list|)
expr_stmt|;
name|pos_state_next
operator|=
operator|(
name|position
operator|+
name|len_test
operator|+
literal|1
operator|)
operator|&
name|coder
operator|->
name|pos_mask
expr_stmt|;
specifier|const
name|uint32_t
name|next_rep_match_price
init|=
name|cur_and_len_literal_price
operator|+
name|rc_bit_1_price
argument_list|(
name|coder
operator|->
name|is_match
index|[
name|state_2
index|]
index|[
name|pos_state_next
index|]
argument_list|)
operator|+
name|rc_bit_1_price
argument_list|(
name|coder
operator|->
name|is_rep
index|[
name|state_2
index|]
argument_list|)
decl_stmt|;
comment|//for(; len_test_2>= 2; len_test_2--) {
specifier|const
name|uint32_t
name|offset
init|=
name|cur
operator|+
name|len_test
operator|+
literal|1
operator|+
name|len_test_2
decl_stmt|;
while|while
condition|(
name|len_end
operator|<
name|offset
condition|)
name|coder
operator|->
name|opts
index|[
operator|++
name|len_end
index|]
operator|.
name|price
operator|=
name|RC_INFINITY_PRICE
expr_stmt|;
specifier|const
name|uint32_t
name|cur_and_len_price
init|=
name|next_rep_match_price
operator|+
name|get_rep_price
argument_list|(
name|coder
argument_list|,
literal|0
argument_list|,
name|len_test_2
argument_list|,
name|state_2
argument_list|,
name|pos_state_next
argument_list|)
decl_stmt|;
if|if
condition|(
name|cur_and_len_price
operator|<
name|coder
operator|->
name|opts
index|[
name|offset
index|]
operator|.
name|price
condition|)
block|{
name|coder
operator|->
name|opts
index|[
name|offset
index|]
operator|.
name|price
operator|=
name|cur_and_len_price
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|offset
index|]
operator|.
name|pos_prev
operator|=
name|cur
operator|+
name|len_test
operator|+
literal|1
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|offset
index|]
operator|.
name|back_prev
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|offset
index|]
operator|.
name|prev_1_is_literal
operator|=
name|true
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|offset
index|]
operator|.
name|prev_2
operator|=
name|true
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|offset
index|]
operator|.
name|pos_prev_2
operator|=
name|cur
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|offset
index|]
operator|.
name|back_prev_2
operator|=
name|rep_index
expr_stmt|;
block|}
comment|//}
block|}
block|}
comment|//for (uint32_t len_test = 2; len_test<= new_len; ++len_test)
if|if
condition|(
name|new_len
operator|>
name|buf_avail
condition|)
block|{
name|new_len
operator|=
name|buf_avail
expr_stmt|;
name|matches_count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|new_len
operator|>
name|coder
operator|->
name|matches
index|[
name|matches_count
index|]
operator|.
name|len
condition|)
operator|++
name|matches_count
expr_stmt|;
name|coder
operator|->
name|matches
index|[
name|matches_count
operator|++
index|]
operator|.
name|len
operator|=
name|new_len
expr_stmt|;
block|}
if|if
condition|(
name|new_len
operator|>=
name|start_len
condition|)
block|{
specifier|const
name|uint32_t
name|normal_match_price
init|=
name|match_price
operator|+
name|rc_bit_0_price
argument_list|(
name|coder
operator|->
name|is_rep
index|[
name|state
index|]
argument_list|)
decl_stmt|;
while|while
condition|(
name|len_end
operator|<
name|cur
operator|+
name|new_len
condition|)
name|coder
operator|->
name|opts
index|[
operator|++
name|len_end
index|]
operator|.
name|price
operator|=
name|RC_INFINITY_PRICE
expr_stmt|;
name|uint32_t
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|start_len
operator|>
name|coder
operator|->
name|matches
index|[
name|i
index|]
operator|.
name|len
condition|)
operator|++
name|i
expr_stmt|;
for|for
control|(
name|uint32_t
name|len_test
init|=
name|start_len
init|;
condition|;
operator|++
name|len_test
control|)
block|{
specifier|const
name|uint32_t
name|cur_back
init|=
name|coder
operator|->
name|matches
index|[
name|i
index|]
operator|.
name|dist
decl_stmt|;
name|uint32_t
name|cur_and_len_price
init|=
name|normal_match_price
operator|+
name|get_pos_len_price
argument_list|(
name|coder
argument_list|,
name|cur_back
argument_list|,
name|len_test
argument_list|,
name|pos_state
argument_list|)
decl_stmt|;
if|if
condition|(
name|cur_and_len_price
operator|<
name|coder
operator|->
name|opts
index|[
name|cur
operator|+
name|len_test
index|]
operator|.
name|price
condition|)
block|{
name|coder
operator|->
name|opts
index|[
name|cur
operator|+
name|len_test
index|]
operator|.
name|price
operator|=
name|cur_and_len_price
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|cur
operator|+
name|len_test
index|]
operator|.
name|pos_prev
operator|=
name|cur
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|cur
operator|+
name|len_test
index|]
operator|.
name|back_prev
operator|=
name|cur_back
operator|+
name|REP_DISTANCES
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|cur
operator|+
name|len_test
index|]
operator|.
name|prev_1_is_literal
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|len_test
operator|==
name|coder
operator|->
name|matches
index|[
name|i
index|]
operator|.
name|len
condition|)
block|{
comment|// Try Match + Literal + Rep0
specifier|const
name|uint8_t
modifier|*
specifier|const
name|buf_back
init|=
name|buf
operator|-
name|cur_back
operator|-
literal|1
decl_stmt|;
name|uint32_t
name|len_test_2
init|=
name|len_test
operator|+
literal|1
decl_stmt|;
specifier|const
name|uint32_t
name|limit
init|=
name|my_min
argument_list|(
name|buf_avail_full
argument_list|,
name|len_test_2
operator|+
name|nice_len
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|len_test_2
operator|<
name|limit
operator|&&
name|buf
index|[
name|len_test_2
index|]
operator|==
name|buf_back
index|[
name|len_test_2
index|]
condition|;
operator|++
name|len_test_2
control|)
empty_stmt|;
name|len_test_2
operator|-=
name|len_test
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len_test_2
operator|>=
literal|2
condition|)
block|{
name|lzma_lzma_state
name|state_2
init|=
name|state
decl_stmt|;
name|update_match
argument_list|(
name|state_2
argument_list|)
expr_stmt|;
name|uint32_t
name|pos_state_next
init|=
operator|(
name|position
operator|+
name|len_test
operator|)
operator|&
name|coder
operator|->
name|pos_mask
decl_stmt|;
specifier|const
name|uint32_t
name|cur_and_len_literal_price
init|=
name|cur_and_len_price
operator|+
name|rc_bit_0_price
argument_list|(
name|coder
operator|->
name|is_match
index|[
name|state_2
index|]
index|[
name|pos_state_next
index|]
argument_list|)
operator|+
name|get_literal_price
argument_list|(
name|coder
argument_list|,
name|position
operator|+
name|len_test
argument_list|,
name|buf
index|[
name|len_test
operator|-
literal|1
index|]
argument_list|,
name|true
argument_list|,
name|buf_back
index|[
name|len_test
index|]
argument_list|,
name|buf
index|[
name|len_test
index|]
argument_list|)
decl_stmt|;
name|update_literal
argument_list|(
name|state_2
argument_list|)
expr_stmt|;
name|pos_state_next
operator|=
operator|(
name|pos_state_next
operator|+
literal|1
operator|)
operator|&
name|coder
operator|->
name|pos_mask
expr_stmt|;
specifier|const
name|uint32_t
name|next_rep_match_price
init|=
name|cur_and_len_literal_price
operator|+
name|rc_bit_1_price
argument_list|(
name|coder
operator|->
name|is_match
index|[
name|state_2
index|]
index|[
name|pos_state_next
index|]
argument_list|)
operator|+
name|rc_bit_1_price
argument_list|(
name|coder
operator|->
name|is_rep
index|[
name|state_2
index|]
argument_list|)
decl_stmt|;
comment|// for(; len_test_2>= 2; --len_test_2) {
specifier|const
name|uint32_t
name|offset
init|=
name|cur
operator|+
name|len_test
operator|+
literal|1
operator|+
name|len_test_2
decl_stmt|;
while|while
condition|(
name|len_end
operator|<
name|offset
condition|)
name|coder
operator|->
name|opts
index|[
operator|++
name|len_end
index|]
operator|.
name|price
operator|=
name|RC_INFINITY_PRICE
expr_stmt|;
name|cur_and_len_price
operator|=
name|next_rep_match_price
operator|+
name|get_rep_price
argument_list|(
name|coder
argument_list|,
literal|0
argument_list|,
name|len_test_2
argument_list|,
name|state_2
argument_list|,
name|pos_state_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_and_len_price
operator|<
name|coder
operator|->
name|opts
index|[
name|offset
index|]
operator|.
name|price
condition|)
block|{
name|coder
operator|->
name|opts
index|[
name|offset
index|]
operator|.
name|price
operator|=
name|cur_and_len_price
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|offset
index|]
operator|.
name|pos_prev
operator|=
name|cur
operator|+
name|len_test
operator|+
literal|1
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|offset
index|]
operator|.
name|back_prev
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|offset
index|]
operator|.
name|prev_1_is_literal
operator|=
name|true
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|offset
index|]
operator|.
name|prev_2
operator|=
name|true
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|offset
index|]
operator|.
name|pos_prev_2
operator|=
name|cur
expr_stmt|;
name|coder
operator|->
name|opts
index|[
name|offset
index|]
operator|.
name|back_prev_2
operator|=
name|cur_back
operator|+
name|REP_DISTANCES
expr_stmt|;
block|}
comment|//}
block|}
if|if
condition|(
operator|++
name|i
operator|==
name|matches_count
condition|)
break|break;
block|}
block|}
block|}
return|return
name|len_end
return|;
block|}
end_function

begin_function
specifier|extern
name|void
name|lzma_lzma_optimum_normal
parameter_list|(
name|lzma_coder
modifier|*
specifier|restrict
name|coder
parameter_list|,
name|lzma_mf
modifier|*
specifier|restrict
name|mf
parameter_list|,
name|uint32_t
modifier|*
specifier|restrict
name|back_res
parameter_list|,
name|uint32_t
modifier|*
specifier|restrict
name|len_res
parameter_list|,
name|uint32_t
name|position
parameter_list|)
block|{
comment|// If we have symbols pending, return the next pending symbol.
if|if
condition|(
name|coder
operator|->
name|opts_end_index
operator|!=
name|coder
operator|->
name|opts_current_index
condition|)
block|{
name|assert
argument_list|(
name|mf
operator|->
name|read_ahead
operator|>
literal|0
argument_list|)
expr_stmt|;
operator|*
name|len_res
operator|=
name|coder
operator|->
name|opts
index|[
name|coder
operator|->
name|opts_current_index
index|]
operator|.
name|pos_prev
operator|-
name|coder
operator|->
name|opts_current_index
expr_stmt|;
operator|*
name|back_res
operator|=
name|coder
operator|->
name|opts
index|[
name|coder
operator|->
name|opts_current_index
index|]
operator|.
name|back_prev
expr_stmt|;
name|coder
operator|->
name|opts_current_index
operator|=
name|coder
operator|->
name|opts
index|[
name|coder
operator|->
name|opts_current_index
index|]
operator|.
name|pos_prev
expr_stmt|;
return|return;
block|}
comment|// Update the price tables. In LZMA SDK<= 4.60 (and possibly later)
comment|// this was done in both initialization function and in the main loop.
comment|// In liblzma they were moved into this single place.
if|if
condition|(
name|mf
operator|->
name|read_ahead
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|coder
operator|->
name|match_price_count
operator|>=
operator|(
literal|1
operator|<<
literal|7
operator|)
condition|)
name|fill_distances_prices
argument_list|(
name|coder
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|align_price_count
operator|>=
name|ALIGN_TABLE_SIZE
condition|)
name|fill_align_prices
argument_list|(
name|coder
argument_list|)
expr_stmt|;
block|}
comment|// TODO: This needs quite a bit of cleaning still. But splitting
comment|// the original function into two pieces makes it at least a little
comment|// more readable, since those two parts don't share many variables.
name|uint32_t
name|len_end
init|=
name|helper1
argument_list|(
name|coder
argument_list|,
name|mf
argument_list|,
name|back_res
argument_list|,
name|len_res
argument_list|,
name|position
argument_list|)
decl_stmt|;
if|if
condition|(
name|len_end
operator|==
name|UINT32_MAX
condition|)
return|return;
name|uint32_t
name|reps
index|[
name|REP_DISTANCES
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|reps
argument_list|,
name|coder
operator|->
name|reps
argument_list|,
sizeof|sizeof
argument_list|(
name|reps
argument_list|)
argument_list|)
expr_stmt|;
name|uint32_t
name|cur
decl_stmt|;
for|for
control|(
name|cur
operator|=
literal|1
init|;
name|cur
operator|<
name|len_end
condition|;
operator|++
name|cur
control|)
block|{
name|assert
argument_list|(
name|cur
operator|<
name|OPTS
argument_list|)
expr_stmt|;
name|coder
operator|->
name|longest_match_length
operator|=
name|mf_find
argument_list|(
name|mf
argument_list|,
operator|&
name|coder
operator|->
name|matches_count
argument_list|,
name|coder
operator|->
name|matches
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|longest_match_length
operator|>=
name|mf
operator|->
name|nice_len
condition|)
break|break;
name|len_end
operator|=
name|helper2
argument_list|(
name|coder
argument_list|,
name|reps
argument_list|,
name|mf_ptr
argument_list|(
name|mf
argument_list|)
operator|-
literal|1
argument_list|,
name|len_end
argument_list|,
name|position
operator|+
name|cur
argument_list|,
name|cur
argument_list|,
name|mf
operator|->
name|nice_len
argument_list|,
name|my_min
argument_list|(
name|mf_avail
argument_list|(
name|mf
argument_list|)
operator|+
literal|1
argument_list|,
name|OPTS
operator|-
literal|1
operator|-
name|cur
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|backward
argument_list|(
name|coder
argument_list|,
name|len_res
argument_list|,
name|back_res
argument_list|,
name|cur
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

