begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       lzma_decoder.c
end_comment

begin_comment
comment|/// \brief      LZMA decoder
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//  Authors:    Igor Pavlov
end_comment

begin_comment
comment|//              Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"lz_decoder.h"
end_include

begin_include
include|#
directive|include
file|"lzma_common.h"
end_include

begin_include
include|#
directive|include
file|"lzma_decoder.h"
end_include

begin_include
include|#
directive|include
file|"range_decoder.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SMALL
end_ifdef

begin_comment
comment|// Macros for (somewhat) size-optimized code.
end_comment

begin_define
define|#
directive|define
name|seq_4
parameter_list|(
name|seq
parameter_list|)
value|seq
end_define

begin_define
define|#
directive|define
name|seq_6
parameter_list|(
name|seq
parameter_list|)
value|seq
end_define

begin_define
define|#
directive|define
name|seq_8
parameter_list|(
name|seq
parameter_list|)
value|seq
end_define

begin_define
define|#
directive|define
name|seq_len
parameter_list|(
name|seq
parameter_list|)
define|\
value|seq ## _CHOICE, \ 	seq ## _CHOICE2, \ 	seq ## _BITTREE
end_define

begin_define
define|#
directive|define
name|len_decode
parameter_list|(
name|target
parameter_list|,
name|ld
parameter_list|,
name|pos_state
parameter_list|,
name|seq
parameter_list|)
define|\
value|do { \ case seq ## _CHOICE: \ 	rc_if_0(ld.choice, seq ## _CHOICE) { \ 		rc_update_0(ld.choice); \ 		probs = ld.low[pos_state];\ 		limit = LEN_LOW_SYMBOLS; \ 		target = MATCH_LEN_MIN; \ 	} else { \ 		rc_update_1(ld.choice); \ case seq ## _CHOICE2: \ 		rc_if_0(ld.choice2, seq ## _CHOICE2) { \ 			rc_update_0(ld.choice2); \ 			probs = ld.mid[pos_state]; \ 			limit = LEN_MID_SYMBOLS; \ 			target = MATCH_LEN_MIN + LEN_LOW_SYMBOLS; \ 		} else { \ 			rc_update_1(ld.choice2); \ 			probs = ld.high; \ 			limit = LEN_HIGH_SYMBOLS; \ 			target = MATCH_LEN_MIN + LEN_LOW_SYMBOLS \ 					+ LEN_MID_SYMBOLS; \ 		} \ 	} \ 	symbol = 1; \ case seq ## _BITTREE: \ 	do { \ 		rc_bit(probs[symbol], , , seq ## _BITTREE); \ 	} while (symbol< limit); \ 	target += symbol - limit; \ } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|// HAVE_SMALL
end_comment

begin_comment
comment|// Unrolled versions
end_comment

begin_define
define|#
directive|define
name|seq_4
parameter_list|(
name|seq
parameter_list|)
define|\
value|seq ## 0, \ 	seq ## 1, \ 	seq ## 2, \ 	seq ## 3
end_define

begin_define
define|#
directive|define
name|seq_6
parameter_list|(
name|seq
parameter_list|)
define|\
value|seq ## 0, \ 	seq ## 1, \ 	seq ## 2, \ 	seq ## 3, \ 	seq ## 4, \ 	seq ## 5
end_define

begin_define
define|#
directive|define
name|seq_8
parameter_list|(
name|seq
parameter_list|)
define|\
value|seq ## 0, \ 	seq ## 1, \ 	seq ## 2, \ 	seq ## 3, \ 	seq ## 4, \ 	seq ## 5, \ 	seq ## 6, \ 	seq ## 7
end_define

begin_define
define|#
directive|define
name|seq_len
parameter_list|(
name|seq
parameter_list|)
define|\
value|seq ## _CHOICE, \ 	seq ## _LOW0, \ 	seq ## _LOW1, \ 	seq ## _LOW2, \ 	seq ## _CHOICE2, \ 	seq ## _MID0, \ 	seq ## _MID1, \ 	seq ## _MID2, \ 	seq ## _HIGH0, \ 	seq ## _HIGH1, \ 	seq ## _HIGH2, \ 	seq ## _HIGH3, \ 	seq ## _HIGH4, \ 	seq ## _HIGH5, \ 	seq ## _HIGH6, \ 	seq ## _HIGH7
end_define

begin_define
define|#
directive|define
name|len_decode
parameter_list|(
name|target
parameter_list|,
name|ld
parameter_list|,
name|pos_state
parameter_list|,
name|seq
parameter_list|)
define|\
value|do { \ 	symbol = 1; \ case seq ## _CHOICE: \ 	rc_if_0(ld.choice, seq ## _CHOICE) { \ 		rc_update_0(ld.choice); \ 		rc_bit_case(ld.low[pos_state][symbol], , , seq ## _LOW0); \ 		rc_bit_case(ld.low[pos_state][symbol], , , seq ## _LOW1); \ 		rc_bit_case(ld.low[pos_state][symbol], , , seq ## _LOW2); \ 		target = symbol - LEN_LOW_SYMBOLS + MATCH_LEN_MIN; \ 	} else { \ 		rc_update_1(ld.choice); \ case seq ## _CHOICE2: \ 		rc_if_0(ld.choice2, seq ## _CHOICE2) { \ 			rc_update_0(ld.choice2); \ 			rc_bit_case(ld.mid[pos_state][symbol], , , \ 					seq ## _MID0); \ 			rc_bit_case(ld.mid[pos_state][symbol], , , \ 					seq ## _MID1); \ 			rc_bit_case(ld.mid[pos_state][symbol], , , \ 					seq ## _MID2); \ 			target = symbol - LEN_MID_SYMBOLS \ 					+ MATCH_LEN_MIN + LEN_LOW_SYMBOLS; \ 		} else { \ 			rc_update_1(ld.choice2); \ 			rc_bit_case(ld.high[symbol], , , seq ## _HIGH0); \ 			rc_bit_case(ld.high[symbol], , , seq ## _HIGH1); \ 			rc_bit_case(ld.high[symbol], , , seq ## _HIGH2); \ 			rc_bit_case(ld.high[symbol], , , seq ## _HIGH3); \ 			rc_bit_case(ld.high[symbol], , , seq ## _HIGH4); \ 			rc_bit_case(ld.high[symbol], , , seq ## _HIGH5); \ 			rc_bit_case(ld.high[symbol], , , seq ## _HIGH6); \ 			rc_bit_case(ld.high[symbol], , , seq ## _HIGH7); \ 			target = symbol - LEN_HIGH_SYMBOLS \ 					+ MATCH_LEN_MIN \ 					+ LEN_LOW_SYMBOLS + LEN_MID_SYMBOLS; \ 		} \ 	} \ } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// HAVE_SMALL
end_comment

begin_comment
comment|/// Length decoder probabilities; see comments in lzma_common.h.
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|probability
name|choice
decl_stmt|;
name|probability
name|choice2
decl_stmt|;
name|probability
name|low
index|[
name|POS_STATES_MAX
index|]
index|[
name|LEN_LOW_SYMBOLS
index|]
decl_stmt|;
name|probability
name|mid
index|[
name|POS_STATES_MAX
index|]
index|[
name|LEN_MID_SYMBOLS
index|]
decl_stmt|;
name|probability
name|high
index|[
name|LEN_HIGH_SYMBOLS
index|]
decl_stmt|;
block|}
name|lzma_length_decoder
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
comment|///////////////////
comment|// Probabilities //
comment|///////////////////
comment|/// Literals; see comments in lzma_common.h.
name|probability
name|literal
index|[
name|LITERAL_CODERS_MAX
index|]
index|[
name|LITERAL_CODER_SIZE
index|]
decl_stmt|;
comment|/// If 1, it's a match. Otherwise it's a single 8-bit literal.
name|probability
name|is_match
index|[
name|STATES
index|]
index|[
name|POS_STATES_MAX
index|]
decl_stmt|;
comment|/// If 1, it's a repeated match. The distance is one of rep0 .. rep3.
name|probability
name|is_rep
index|[
name|STATES
index|]
decl_stmt|;
comment|/// If 0, distance of a repeated match is rep0.
comment|/// Otherwise check is_rep1.
name|probability
name|is_rep0
index|[
name|STATES
index|]
decl_stmt|;
comment|/// If 0, distance of a repeated match is rep1.
comment|/// Otherwise check is_rep2.
name|probability
name|is_rep1
index|[
name|STATES
index|]
decl_stmt|;
comment|/// If 0, distance of a repeated match is rep2. Otherwise it is rep3.
name|probability
name|is_rep2
index|[
name|STATES
index|]
decl_stmt|;
comment|/// If 1, the repeated match has length of one byte. Otherwise
comment|/// the length is decoded from rep_len_decoder.
name|probability
name|is_rep0_long
index|[
name|STATES
index|]
index|[
name|POS_STATES_MAX
index|]
decl_stmt|;
comment|/// Probability tree for the highest two bits of the match distance.
comment|/// There is a separate probability tree for match lengths of
comment|/// 2 (i.e. MATCH_LEN_MIN), 3, 4, and [5, 273].
name|probability
name|dist_slot
index|[
name|DIST_STATES
index|]
index|[
name|DIST_SLOTS
index|]
decl_stmt|;
comment|/// Probability trees for additional bits for match distance when the
comment|/// distance is in the range [4, 127].
name|probability
name|pos_special
index|[
name|FULL_DISTANCES
operator|-
name|DIST_MODEL_END
index|]
decl_stmt|;
comment|/// Probability tree for the lowest four bits of a match distance
comment|/// that is equal to or greater than 128.
name|probability
name|pos_align
index|[
name|ALIGN_SIZE
index|]
decl_stmt|;
comment|/// Length of a normal match
name|lzma_length_decoder
name|match_len_decoder
decl_stmt|;
comment|/// Length of a repeated match
name|lzma_length_decoder
name|rep_len_decoder
decl_stmt|;
comment|///////////////////
comment|// Decoder state //
comment|///////////////////
comment|// Range coder
name|lzma_range_decoder
name|rc
decl_stmt|;
comment|// Types of the most recently seen LZMA symbols
name|lzma_lzma_state
name|state
decl_stmt|;
name|uint32_t
name|rep0
decl_stmt|;
comment|///< Distance of the latest match
name|uint32_t
name|rep1
decl_stmt|;
comment|///< Distance of second latest match
name|uint32_t
name|rep2
decl_stmt|;
comment|///< Distance of third latest match
name|uint32_t
name|rep3
decl_stmt|;
comment|///< Distance of fourth latest match
name|uint32_t
name|pos_mask
decl_stmt|;
comment|// (1U<< pb) - 1
name|uint32_t
name|literal_context_bits
decl_stmt|;
name|uint32_t
name|literal_pos_mask
decl_stmt|;
comment|/// Uncompressed size as bytes, or LZMA_VLI_UNKNOWN if end of
comment|/// payload marker is expected.
name|lzma_vli
name|uncompressed_size
decl_stmt|;
comment|////////////////////////////////
comment|// State of incomplete symbol //
comment|////////////////////////////////
comment|/// Position where to continue the decoder loop
enum|enum
block|{
name|SEQ_NORMALIZE
block|,
name|SEQ_IS_MATCH
block|,
name|seq_8
argument_list|(
name|SEQ_LITERAL
argument_list|)
block|,
name|seq_8
argument_list|(
name|SEQ_LITERAL_MATCHED
argument_list|)
block|,
name|SEQ_LITERAL_WRITE
block|,
name|SEQ_IS_REP
block|,
name|seq_len
argument_list|(
name|SEQ_MATCH_LEN
argument_list|)
block|,
name|seq_6
argument_list|(
name|SEQ_DIST_SLOT
argument_list|)
block|,
name|SEQ_DIST_MODEL
block|,
name|SEQ_DIRECT
block|,
name|seq_4
argument_list|(
name|SEQ_ALIGN
argument_list|)
block|,
name|SEQ_EOPM
block|,
name|SEQ_IS_REP0
block|,
name|SEQ_SHORTREP
block|,
name|SEQ_IS_REP0_LONG
block|,
name|SEQ_IS_REP1
block|,
name|SEQ_IS_REP2
block|,
name|seq_len
argument_list|(
name|SEQ_REP_LEN
argument_list|)
block|,
name|SEQ_COPY
block|, 	}
name|sequence
enum|;
comment|/// Base of the current probability tree
name|probability
modifier|*
name|probs
decl_stmt|;
comment|/// Symbol being decoded. This is also used as an index variable in
comment|/// bittree decoders: probs[symbol]
name|uint32_t
name|symbol
decl_stmt|;
comment|/// Used as a loop termination condition on bittree decoders and
comment|/// direct bits decoder.
name|uint32_t
name|limit
decl_stmt|;
comment|/// Matched literal decoder: 0x100 or 0 to help avoiding branches.
comment|/// Bittree reverse decoders: Offset of the next bit: 1<< offset
name|uint32_t
name|offset
decl_stmt|;
comment|/// If decoding a literal: match byte.
comment|/// If decoding a match: length of the match.
name|uint32_t
name|len
decl_stmt|;
block|}
name|lzma_lzma1_decoder
typedef|;
end_typedef

begin_function
specifier|static
name|lzma_ret
name|lzma_decode
parameter_list|(
name|void
modifier|*
name|coder_ptr
parameter_list|,
name|lzma_dict
modifier|*
specifier|restrict
name|dictptr
parameter_list|,
specifier|const
name|uint8_t
modifier|*
specifier|restrict
name|in
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|in_pos
parameter_list|,
name|size_t
name|in_size
parameter_list|)
block|{
name|lzma_lzma1_decoder
modifier|*
specifier|restrict
name|coder
init|=
name|coder_ptr
decl_stmt|;
comment|////////////////////
comment|// Initialization //
comment|////////////////////
block|{
specifier|const
name|lzma_ret
name|ret
init|=
name|rc_read_init
argument_list|(
operator|&
name|coder
operator|->
name|rc
argument_list|,
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_STREAM_END
condition|)
return|return
name|ret
return|;
block|}
comment|///////////////
comment|// Variables //
comment|///////////////
comment|// Making local copies of often-used variables improves both
comment|// speed and readability.
name|lzma_dict
name|dict
init|=
operator|*
name|dictptr
decl_stmt|;
specifier|const
name|size_t
name|dict_start
init|=
name|dict
operator|.
name|pos
decl_stmt|;
comment|// Range decoder
name|rc_to_local
argument_list|(
name|coder
operator|->
name|rc
argument_list|,
operator|*
name|in_pos
argument_list|)
expr_stmt|;
comment|// State
name|uint32_t
name|state
init|=
name|coder
operator|->
name|state
decl_stmt|;
name|uint32_t
name|rep0
init|=
name|coder
operator|->
name|rep0
decl_stmt|;
name|uint32_t
name|rep1
init|=
name|coder
operator|->
name|rep1
decl_stmt|;
name|uint32_t
name|rep2
init|=
name|coder
operator|->
name|rep2
decl_stmt|;
name|uint32_t
name|rep3
init|=
name|coder
operator|->
name|rep3
decl_stmt|;
specifier|const
name|uint32_t
name|pos_mask
init|=
name|coder
operator|->
name|pos_mask
decl_stmt|;
comment|// These variables are actually needed only if we last time ran
comment|// out of input in the middle of the decoder loop.
name|probability
modifier|*
name|probs
init|=
name|coder
operator|->
name|probs
decl_stmt|;
name|uint32_t
name|symbol
init|=
name|coder
operator|->
name|symbol
decl_stmt|;
name|uint32_t
name|limit
init|=
name|coder
operator|->
name|limit
decl_stmt|;
name|uint32_t
name|offset
init|=
name|coder
operator|->
name|offset
decl_stmt|;
name|uint32_t
name|len
init|=
name|coder
operator|->
name|len
decl_stmt|;
specifier|const
name|uint32_t
name|literal_pos_mask
init|=
name|coder
operator|->
name|literal_pos_mask
decl_stmt|;
specifier|const
name|uint32_t
name|literal_context_bits
init|=
name|coder
operator|->
name|literal_context_bits
decl_stmt|;
comment|// Temporary variables
name|uint32_t
name|pos_state
init|=
name|dict
operator|.
name|pos
operator|&
name|pos_mask
decl_stmt|;
name|lzma_ret
name|ret
init|=
name|LZMA_OK
decl_stmt|;
comment|// If uncompressed size is known, there must be no end of payload
comment|// marker.
specifier|const
name|bool
name|no_eopm
init|=
name|coder
operator|->
name|uncompressed_size
operator|!=
name|LZMA_VLI_UNKNOWN
decl_stmt|;
if|if
condition|(
name|no_eopm
operator|&&
name|coder
operator|->
name|uncompressed_size
operator|<
name|dict
operator|.
name|limit
operator|-
name|dict
operator|.
name|pos
condition|)
name|dict
operator|.
name|limit
operator|=
name|dict
operator|.
name|pos
operator|+
call|(
name|size_t
call|)
argument_list|(
name|coder
operator|->
name|uncompressed_size
argument_list|)
expr_stmt|;
comment|// The main decoder loop. The "switch" is used to restart the decoder at
comment|// correct location. Once restarted, the "switch" is no longer used.
switch|switch
condition|(
name|coder
operator|->
name|sequence
condition|)
while|while
condition|(
name|true
condition|)
block|{
comment|// Calculate new pos_state. This is skipped on the first loop
comment|// since we already calculated it when setting up the local
comment|// variables.
name|pos_state
operator|=
name|dict
operator|.
name|pos
operator|&
name|pos_mask
expr_stmt|;
case|case
name|SEQ_NORMALIZE
case|:
case|case
name|SEQ_IS_MATCH
case|:
if|if
condition|(
name|unlikely
argument_list|(
name|no_eopm
operator|&&
name|dict
operator|.
name|pos
operator|==
name|dict
operator|.
name|limit
argument_list|)
condition|)
break|break;
name|rc_if_0
argument_list|(
argument|coder->is_match[state][pos_state]
argument_list|,
argument|SEQ_IS_MATCH
argument_list|)
block|{
name|rc_update_0
argument_list|(
name|coder
operator|->
name|is_match
index|[
name|state
index|]
index|[
name|pos_state
index|]
argument_list|)
expr_stmt|;
comment|// It's a literal i.e. a single 8-bit byte.
name|probs
operator|=
name|literal_subcoder
argument_list|(
name|coder
operator|->
name|literal
argument_list|,
name|literal_context_bits
argument_list|,
name|literal_pos_mask
argument_list|,
name|dict
operator|.
name|pos
argument_list|,
name|dict_get
argument_list|(
operator|&
name|dict
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|symbol
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|is_literal_state
argument_list|(
name|state
argument_list|)
condition|)
block|{
comment|// Decode literal without match byte.
ifdef|#
directive|ifdef
name|HAVE_SMALL
case|case
name|SEQ_LITERAL
case|:
do|do
block|{
name|rc_bit
argument_list|(
name|probs
index|[
name|symbol
index|]
argument_list|, , ,
name|SEQ_LITERAL
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|symbol
operator|<
operator|(
literal|1
operator|<<
literal|8
operator|)
condition|)
do|;
else|#
directive|else
name|rc_bit_case
argument_list|(
name|probs
index|[
name|symbol
index|]
argument_list|, , ,
name|SEQ_LITERAL0
argument_list|)
expr_stmt|;
name|rc_bit_case
argument_list|(
name|probs
index|[
name|symbol
index|]
argument_list|, , ,
name|SEQ_LITERAL1
argument_list|)
expr_stmt|;
name|rc_bit_case
argument_list|(
name|probs
index|[
name|symbol
index|]
argument_list|, , ,
name|SEQ_LITERAL2
argument_list|)
expr_stmt|;
name|rc_bit_case
argument_list|(
name|probs
index|[
name|symbol
index|]
argument_list|, , ,
name|SEQ_LITERAL3
argument_list|)
expr_stmt|;
name|rc_bit_case
argument_list|(
name|probs
index|[
name|symbol
index|]
argument_list|, , ,
name|SEQ_LITERAL4
argument_list|)
expr_stmt|;
name|rc_bit_case
argument_list|(
name|probs
index|[
name|symbol
index|]
argument_list|, , ,
name|SEQ_LITERAL5
argument_list|)
expr_stmt|;
name|rc_bit_case
argument_list|(
name|probs
index|[
name|symbol
index|]
argument_list|, , ,
name|SEQ_LITERAL6
argument_list|)
expr_stmt|;
name|rc_bit_case
argument_list|(
name|probs
index|[
name|symbol
index|]
argument_list|, , ,
name|SEQ_LITERAL7
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|// Decode literal with match byte.
comment|//
comment|// We store the byte we compare against
comment|// ("match byte") to "len" to minimize the
comment|// number of variables we need to store
comment|// between decoder calls.
name|len
operator|=
name|dict_get
argument_list|(
operator|&
name|dict
argument_list|,
name|rep0
argument_list|)
operator|<<
literal|1
expr_stmt|;
comment|// The usage of "offset" allows omitting some
comment|// branches, which should give tiny speed
comment|// improvement on some CPUs. "offset" gets
comment|// set to zero if match_bit didn't match.
name|offset
operator|=
literal|0x100
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SMALL
case|case
name|SEQ_LITERAL_MATCHED
case|:
do|do
block|{
specifier|const
name|uint32_t
name|match_bit
init|=
name|len
operator|&
name|offset
decl_stmt|;
specifier|const
name|uint32_t
name|subcoder_index
init|=
name|offset
operator|+
name|match_bit
operator|+
name|symbol
decl_stmt|;
name|rc_bit
argument_list|(
name|probs
index|[
name|subcoder_index
index|]
argument_list|,
name|offset
operator|&=
operator|~
name|match_bit
argument_list|,
name|offset
operator|&=
name|match_bit
argument_list|,
name|SEQ_LITERAL_MATCHED
argument_list|)
expr_stmt|;
comment|// It seems to be faster to do this
comment|// here instead of putting it to the
comment|// beginning of the loop and then
comment|// putting the "case" in the middle
comment|// of the loop.
name|len
operator|<<=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|symbol
operator|<
operator|(
literal|1
operator|<<
literal|8
operator|)
condition|)
do|;
else|#
directive|else
comment|// Unroll the loop.
name|uint32_t
name|match_bit
decl_stmt|;
name|uint32_t
name|subcoder_index
decl_stmt|;
define|#
directive|define
name|d
parameter_list|(
name|seq
parameter_list|)
define|\
value|case seq: \ 			match_bit = len& offset; \ 			subcoder_index = offset + match_bit + symbol; \ 			rc_bit(probs[subcoder_index], \ 					offset&= ~match_bit, \ 					offset&= match_bit, \ 					seq)
name|d
argument_list|(
name|SEQ_LITERAL_MATCHED0
argument_list|)
expr_stmt|;
name|len
operator|<<=
literal|1
expr_stmt|;
name|d
argument_list|(
name|SEQ_LITERAL_MATCHED1
argument_list|)
expr_stmt|;
name|len
operator|<<=
literal|1
expr_stmt|;
name|d
argument_list|(
name|SEQ_LITERAL_MATCHED2
argument_list|)
expr_stmt|;
name|len
operator|<<=
literal|1
expr_stmt|;
name|d
argument_list|(
name|SEQ_LITERAL_MATCHED3
argument_list|)
expr_stmt|;
name|len
operator|<<=
literal|1
expr_stmt|;
name|d
argument_list|(
name|SEQ_LITERAL_MATCHED4
argument_list|)
expr_stmt|;
name|len
operator|<<=
literal|1
expr_stmt|;
name|d
argument_list|(
name|SEQ_LITERAL_MATCHED5
argument_list|)
expr_stmt|;
name|len
operator|<<=
literal|1
expr_stmt|;
name|d
argument_list|(
name|SEQ_LITERAL_MATCHED6
argument_list|)
expr_stmt|;
name|len
operator|<<=
literal|1
expr_stmt|;
name|d
argument_list|(
name|SEQ_LITERAL_MATCHED7
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|d
endif|#
directive|endif
block|}
comment|//update_literal(state);
comment|// Use a lookup table to update to literal state,
comment|// since compared to other state updates, this would
comment|// need two branches.
specifier|static
specifier|const
name|lzma_lzma_state
name|next_state
index|[]
init|=
block|{
name|STATE_LIT_LIT
block|,
name|STATE_LIT_LIT
block|,
name|STATE_LIT_LIT
block|,
name|STATE_LIT_LIT
block|,
name|STATE_MATCH_LIT_LIT
block|,
name|STATE_REP_LIT_LIT
block|,
name|STATE_SHORTREP_LIT_LIT
block|,
name|STATE_MATCH_LIT
block|,
name|STATE_REP_LIT
block|,
name|STATE_SHORTREP_LIT
block|,
name|STATE_MATCH_LIT
block|,
name|STATE_REP_LIT
block|}
decl_stmt|;
name|state
operator|=
name|next_state
index|[
name|state
index|]
expr_stmt|;
case|case
name|SEQ_LITERAL_WRITE
case|:
if|if
condition|(
name|unlikely
argument_list|(
name|dict_put
argument_list|(
operator|&
name|dict
argument_list|,
name|symbol
argument_list|)
argument_list|)
condition|)
block|{
name|coder
operator|->
name|sequence
operator|=
name|SEQ_LITERAL_WRITE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
continue|continue;
block|}
comment|// Instead of a new byte we are going to get a byte range
comment|// (distance and length) which will be repeated from our
comment|// output history.
name|rc_update_1
argument_list|(
name|coder
operator|->
name|is_match
index|[
name|state
index|]
index|[
name|pos_state
index|]
argument_list|)
expr_stmt|;
case|case
name|SEQ_IS_REP
case|:
name|rc_if_0
argument_list|(
argument|coder->is_rep[state]
argument_list|,
argument|SEQ_IS_REP
argument_list|)
block|{
comment|// Not a repeated match
name|rc_update_0
argument_list|(
name|coder
operator|->
name|is_rep
index|[
name|state
index|]
argument_list|)
expr_stmt|;
name|update_match
argument_list|(
name|state
argument_list|)
expr_stmt|;
comment|// The latest three match distances are kept in
comment|// memory in case there are repeated matches.
name|rep3
operator|=
name|rep2
expr_stmt|;
name|rep2
operator|=
name|rep1
expr_stmt|;
name|rep1
operator|=
name|rep0
expr_stmt|;
comment|// Decode the length of the match.
name|len_decode
argument_list|(
name|len
argument_list|,
name|coder
operator|->
name|match_len_decoder
argument_list|,
name|pos_state
argument_list|,
name|SEQ_MATCH_LEN
argument_list|)
expr_stmt|;
comment|// Prepare to decode the highest two bits of the
comment|// match distance.
name|probs
operator|=
name|coder
operator|->
name|dist_slot
index|[
name|get_dist_state
argument_list|(
name|len
argument_list|)
index|]
expr_stmt|;
name|symbol
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SMALL
case|case
name|SEQ_DIST_SLOT
case|:
do|do
block|{
name|rc_bit
argument_list|(
name|probs
index|[
name|symbol
index|]
argument_list|, , ,
name|SEQ_DIST_SLOT
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|symbol
operator|<
name|DIST_SLOTS
condition|)
do|;
else|#
directive|else
name|rc_bit_case
argument_list|(
name|probs
index|[
name|symbol
index|]
argument_list|, , ,
name|SEQ_DIST_SLOT0
argument_list|)
expr_stmt|;
name|rc_bit_case
argument_list|(
name|probs
index|[
name|symbol
index|]
argument_list|, , ,
name|SEQ_DIST_SLOT1
argument_list|)
expr_stmt|;
name|rc_bit_case
argument_list|(
name|probs
index|[
name|symbol
index|]
argument_list|, , ,
name|SEQ_DIST_SLOT2
argument_list|)
expr_stmt|;
name|rc_bit_case
argument_list|(
name|probs
index|[
name|symbol
index|]
argument_list|, , ,
name|SEQ_DIST_SLOT3
argument_list|)
expr_stmt|;
name|rc_bit_case
argument_list|(
name|probs
index|[
name|symbol
index|]
argument_list|, , ,
name|SEQ_DIST_SLOT4
argument_list|)
expr_stmt|;
name|rc_bit_case
argument_list|(
name|probs
index|[
name|symbol
index|]
argument_list|, , ,
name|SEQ_DIST_SLOT5
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Get rid of the highest bit that was needed for
comment|// indexing of the probability array.
name|symbol
operator|-=
name|DIST_SLOTS
expr_stmt|;
name|assert
argument_list|(
name|symbol
operator|<=
literal|63
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
operator|<
name|DIST_MODEL_START
condition|)
block|{
comment|// Match distances [0, 3] have only two bits.
name|rep0
operator|=
name|symbol
expr_stmt|;
block|}
else|else
block|{
comment|// Decode the lowest [1, 29] bits of
comment|// the match distance.
name|limit
operator|=
operator|(
name|symbol
operator|>>
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
name|assert
argument_list|(
name|limit
operator|>=
literal|1
operator|&&
name|limit
operator|<=
literal|30
argument_list|)
expr_stmt|;
name|rep0
operator|=
literal|2
operator|+
operator|(
name|symbol
operator|&
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|symbol
operator|<
name|DIST_MODEL_END
condition|)
block|{
comment|// Prepare to decode the low bits for
comment|// a distance of [4, 127].
name|assert
argument_list|(
name|limit
operator|<=
literal|5
argument_list|)
expr_stmt|;
name|rep0
operator|<<=
name|limit
expr_stmt|;
name|assert
argument_list|(
name|rep0
operator|<=
literal|96
argument_list|)
expr_stmt|;
comment|// -1 is fine, because we start
comment|// decoding at probs[1], not probs[0].
comment|// NOTE: This violates the C standard,
comment|// since we are doing pointer
comment|// arithmetic past the beginning of
comment|// the array.
name|assert
argument_list|(
call|(
name|int32_t
call|)
argument_list|(
name|rep0
operator|-
name|symbol
operator|-
literal|1
argument_list|)
operator|>=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
call|(
name|int32_t
call|)
argument_list|(
name|rep0
operator|-
name|symbol
operator|-
literal|1
argument_list|)
operator|<=
literal|82
argument_list|)
expr_stmt|;
name|probs
operator|=
name|coder
operator|->
name|pos_special
operator|+
name|rep0
operator|-
name|symbol
operator|-
literal|1
expr_stmt|;
name|symbol
operator|=
literal|1
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
case|case
name|SEQ_DIST_MODEL
case|:
ifdef|#
directive|ifdef
name|HAVE_SMALL
do|do
block|{
name|rc_bit
argument_list|(
name|probs
index|[
name|symbol
index|]
argument_list|, ,
name|rep0
operator|+=
literal|1
operator|<<
name|offset
argument_list|,
name|SEQ_DIST_MODEL
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|offset
operator|<
name|limit
condition|)
do|;
else|#
directive|else
switch|switch
condition|(
name|limit
condition|)
block|{
case|case
literal|5
case|:
name|assert
argument_list|(
name|offset
operator|==
literal|0
argument_list|)
expr_stmt|;
name|rc_bit
argument_list|(
name|probs
index|[
name|symbol
index|]
argument_list|, ,
name|rep0
operator|+=
literal|1
argument_list|,
name|SEQ_DIST_MODEL
argument_list|)
expr_stmt|;
operator|++
name|offset
expr_stmt|;
operator|--
name|limit
expr_stmt|;
case|case
literal|4
case|:
name|rc_bit
argument_list|(
name|probs
index|[
name|symbol
index|]
argument_list|, ,
name|rep0
operator|+=
literal|1
operator|<<
name|offset
argument_list|,
name|SEQ_DIST_MODEL
argument_list|)
expr_stmt|;
operator|++
name|offset
expr_stmt|;
operator|--
name|limit
expr_stmt|;
case|case
literal|3
case|:
name|rc_bit
argument_list|(
name|probs
index|[
name|symbol
index|]
argument_list|, ,
name|rep0
operator|+=
literal|1
operator|<<
name|offset
argument_list|,
name|SEQ_DIST_MODEL
argument_list|)
expr_stmt|;
operator|++
name|offset
expr_stmt|;
operator|--
name|limit
expr_stmt|;
case|case
literal|2
case|:
name|rc_bit
argument_list|(
name|probs
index|[
name|symbol
index|]
argument_list|, ,
name|rep0
operator|+=
literal|1
operator|<<
name|offset
argument_list|,
name|SEQ_DIST_MODEL
argument_list|)
expr_stmt|;
operator|++
name|offset
expr_stmt|;
operator|--
name|limit
expr_stmt|;
case|case
literal|1
case|:
comment|// We need "symbol" only for
comment|// indexing the probability
comment|// array, thus we can use
comment|// rc_bit_last() here to omit
comment|// the unneeded updating of
comment|// "symbol".
name|rc_bit_last
argument_list|(
name|probs
index|[
name|symbol
index|]
argument_list|, ,
name|rep0
operator|+=
literal|1
operator|<<
name|offset
argument_list|,
name|SEQ_DIST_MODEL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
comment|// The distance is>= 128. Decode the
comment|// lower bits without probabilities
comment|// except the lowest four bits.
name|assert
argument_list|(
name|symbol
operator|>=
literal|14
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|limit
operator|>=
literal|6
argument_list|)
expr_stmt|;
name|limit
operator|-=
name|ALIGN_BITS
expr_stmt|;
name|assert
argument_list|(
name|limit
operator|>=
literal|2
argument_list|)
expr_stmt|;
case|case
name|SEQ_DIRECT
case|:
comment|// Not worth manual unrolling
do|do
block|{
name|rc_direct
argument_list|(
name|rep0
argument_list|,
name|SEQ_DIRECT
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|limit
operator|>
literal|0
condition|)
do|;
comment|// Decode the lowest four bits using
comment|// probabilities.
name|rep0
operator|<<=
name|ALIGN_BITS
expr_stmt|;
name|symbol
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SMALL
name|offset
operator|=
literal|0
expr_stmt|;
case|case
name|SEQ_ALIGN
case|:
do|do
block|{
name|rc_bit
argument_list|(
name|coder
operator|->
name|pos_align
index|[
name|symbol
index|]
argument_list|, ,
name|rep0
operator|+=
literal|1
operator|<<
name|offset
argument_list|,
name|SEQ_ALIGN
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|offset
operator|<
name|ALIGN_BITS
condition|)
do|;
else|#
directive|else
case|case
name|SEQ_ALIGN0
case|:
name|rc_bit
argument_list|(
name|coder
operator|->
name|pos_align
index|[
name|symbol
index|]
argument_list|, ,
name|rep0
operator|+=
literal|1
argument_list|,
name|SEQ_ALIGN0
argument_list|)
expr_stmt|;
case|case
name|SEQ_ALIGN1
case|:
name|rc_bit
argument_list|(
name|coder
operator|->
name|pos_align
index|[
name|symbol
index|]
argument_list|, ,
name|rep0
operator|+=
literal|2
argument_list|,
name|SEQ_ALIGN1
argument_list|)
expr_stmt|;
case|case
name|SEQ_ALIGN2
case|:
name|rc_bit
argument_list|(
name|coder
operator|->
name|pos_align
index|[
name|symbol
index|]
argument_list|, ,
name|rep0
operator|+=
literal|4
argument_list|,
name|SEQ_ALIGN2
argument_list|)
expr_stmt|;
case|case
name|SEQ_ALIGN3
case|:
comment|// Like in SEQ_DIST_MODEL, we don't
comment|// need "symbol" for anything else
comment|// than indexing the probability array.
name|rc_bit_last
argument_list|(
name|coder
operator|->
name|pos_align
index|[
name|symbol
index|]
argument_list|, ,
name|rep0
operator|+=
literal|8
argument_list|,
name|SEQ_ALIGN3
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rep0
operator|==
name|UINT32_MAX
condition|)
block|{
comment|// End of payload marker was
comment|// found. It must not be
comment|// present if uncompressed
comment|// size is known.
if|if
condition|(
name|coder
operator|->
name|uncompressed_size
operator|!=
name|LZMA_VLI_UNKNOWN
condition|)
block|{
name|ret
operator|=
name|LZMA_DATA_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
case|case
name|SEQ_EOPM
case|:
comment|// LZMA1 stream with
comment|// end-of-payload marker.
name|rc_normalize
argument_list|(
name|SEQ_EOPM
argument_list|)
expr_stmt|;
name|ret
operator|=
name|LZMA_STREAM_END
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
comment|// Validate the distance we just decoded.
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|dict_is_distance_valid
argument_list|(
operator|&
name|dict
argument_list|,
name|rep0
argument_list|)
argument_list|)
condition|)
block|{
name|ret
operator|=
name|LZMA_DATA_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
name|rc_update_1
argument_list|(
name|coder
operator|->
name|is_rep
index|[
name|state
index|]
argument_list|)
expr_stmt|;
comment|// Repeated match
comment|//
comment|// The match distance is a value that we have had
comment|// earlier. The latest four match distances are
comment|// available as rep0, rep1, rep2 and rep3. We will
comment|// now decode which of them is the new distance.
comment|//
comment|// There cannot be a match if we haven't produced
comment|// any output, so check that first.
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|dict_is_distance_valid
argument_list|(
operator|&
name|dict
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|ret
operator|=
name|LZMA_DATA_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
case|case
name|SEQ_IS_REP0
case|:
name|rc_if_0
argument_list|(
argument|coder->is_rep0[state]
argument_list|,
argument|SEQ_IS_REP0
argument_list|)
block|{
name|rc_update_0
argument_list|(
name|coder
operator|->
name|is_rep0
index|[
name|state
index|]
argument_list|)
expr_stmt|;
comment|// The distance is rep0.
case|case
name|SEQ_IS_REP0_LONG
case|:
name|rc_if_0
argument_list|(
argument|coder->is_rep0_long[state][pos_state]
argument_list|,
argument|SEQ_IS_REP0_LONG
argument_list|)
block|{
name|rc_update_0
argument_list|(
name|coder
operator|->
name|is_rep0_long
index|[
name|state
index|]
index|[
name|pos_state
index|]
argument_list|)
expr_stmt|;
name|update_short_rep
argument_list|(
name|state
argument_list|)
expr_stmt|;
case|case
name|SEQ_SHORTREP
case|:
if|if
condition|(
name|unlikely
argument_list|(
name|dict_put
argument_list|(
operator|&
name|dict
argument_list|,
name|dict_get
argument_list|(
operator|&
name|dict
argument_list|,
name|rep0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|coder
operator|->
name|sequence
operator|=
name|SEQ_SHORTREP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
continue|continue;
block|}
comment|// Repeating more than one byte at
comment|// distance of rep0.
name|rc_update_1
argument_list|(
name|coder
operator|->
name|is_rep0_long
index|[
name|state
index|]
index|[
name|pos_state
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc_update_1
argument_list|(
name|coder
operator|->
name|is_rep0
index|[
name|state
index|]
argument_list|)
expr_stmt|;
case|case
name|SEQ_IS_REP1
case|:
comment|// The distance is rep1, rep2 or rep3. Once
comment|// we find out which one of these three, it
comment|// is stored to rep0 and rep1, rep2 and rep3
comment|// are updated accordingly.
name|rc_if_0
argument_list|(
argument|coder->is_rep1[state]
argument_list|,
argument|SEQ_IS_REP1
argument_list|)
block|{
name|rc_update_0
argument_list|(
name|coder
operator|->
name|is_rep1
index|[
name|state
index|]
argument_list|)
expr_stmt|;
specifier|const
name|uint32_t
name|distance
init|=
name|rep1
decl_stmt|;
name|rep1
operator|=
name|rep0
expr_stmt|;
name|rep0
operator|=
name|distance
expr_stmt|;
block|}
else|else
block|{
name|rc_update_1
argument_list|(
name|coder
operator|->
name|is_rep1
index|[
name|state
index|]
argument_list|)
expr_stmt|;
case|case
name|SEQ_IS_REP2
case|:
name|rc_if_0
argument_list|(
argument|coder->is_rep2[state]
argument_list|,
argument|SEQ_IS_REP2
argument_list|)
block|{
name|rc_update_0
argument_list|(
name|coder
operator|->
name|is_rep2
index|[
name|state
index|]
argument_list|)
expr_stmt|;
specifier|const
name|uint32_t
name|distance
init|=
name|rep2
decl_stmt|;
name|rep2
operator|=
name|rep1
expr_stmt|;
name|rep1
operator|=
name|rep0
expr_stmt|;
name|rep0
operator|=
name|distance
expr_stmt|;
block|}
else|else
block|{
name|rc_update_1
argument_list|(
name|coder
operator|->
name|is_rep2
index|[
name|state
index|]
argument_list|)
expr_stmt|;
specifier|const
name|uint32_t
name|distance
init|=
name|rep3
decl_stmt|;
name|rep3
operator|=
name|rep2
expr_stmt|;
name|rep2
operator|=
name|rep1
expr_stmt|;
name|rep1
operator|=
name|rep0
expr_stmt|;
name|rep0
operator|=
name|distance
expr_stmt|;
block|}
block|}
block|}
name|update_long_rep
argument_list|(
name|state
argument_list|)
expr_stmt|;
comment|// Decode the length of the repeated match.
name|len_decode
argument_list|(
name|len
argument_list|,
name|coder
operator|->
name|rep_len_decoder
argument_list|,
name|pos_state
argument_list|,
name|SEQ_REP_LEN
argument_list|)
expr_stmt|;
block|}
comment|/////////////////////////////////
comment|// Repeat from history buffer. //
comment|/////////////////////////////////
comment|// The length is always between these limits. There is no way
comment|// to trigger the algorithm to set len outside this range.
name|assert
argument_list|(
name|len
operator|>=
name|MATCH_LEN_MIN
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|len
operator|<=
name|MATCH_LEN_MAX
argument_list|)
expr_stmt|;
case|case
name|SEQ_COPY
case|:
comment|// Repeat len bytes from distance of rep0.
if|if
condition|(
name|unlikely
argument_list|(
name|dict_repeat
argument_list|(
operator|&
name|dict
argument_list|,
name|rep0
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
condition|)
block|{
name|coder
operator|->
name|sequence
operator|=
name|SEQ_COPY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|rc_normalize
argument_list|(
name|SEQ_NORMALIZE
argument_list|)
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_IS_MATCH
expr_stmt|;
name|out
label|:
comment|// Save state
comment|// NOTE: Must not copy dict.limit.
name|dictptr
operator|->
name|pos
operator|=
name|dict
operator|.
name|pos
expr_stmt|;
name|dictptr
operator|->
name|full
operator|=
name|dict
operator|.
name|full
expr_stmt|;
name|rc_from_local
argument_list|(
name|coder
operator|->
name|rc
argument_list|,
operator|*
name|in_pos
argument_list|)
expr_stmt|;
name|coder
operator|->
name|state
operator|=
name|state
expr_stmt|;
name|coder
operator|->
name|rep0
operator|=
name|rep0
expr_stmt|;
name|coder
operator|->
name|rep1
operator|=
name|rep1
expr_stmt|;
name|coder
operator|->
name|rep2
operator|=
name|rep2
expr_stmt|;
name|coder
operator|->
name|rep3
operator|=
name|rep3
expr_stmt|;
name|coder
operator|->
name|probs
operator|=
name|probs
expr_stmt|;
name|coder
operator|->
name|symbol
operator|=
name|symbol
expr_stmt|;
name|coder
operator|->
name|limit
operator|=
name|limit
expr_stmt|;
name|coder
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|coder
operator|->
name|len
operator|=
name|len
expr_stmt|;
comment|// Update the remaining amount of uncompressed data if uncompressed
comment|// size was known.
if|if
condition|(
name|coder
operator|->
name|uncompressed_size
operator|!=
name|LZMA_VLI_UNKNOWN
condition|)
block|{
name|coder
operator|->
name|uncompressed_size
operator|-=
name|dict
operator|.
name|pos
operator|-
name|dict_start
expr_stmt|;
comment|// Since there cannot be end of payload marker if the
comment|// uncompressed size was known, we check here if we
comment|// finished decoding.
if|if
condition|(
name|coder
operator|->
name|uncompressed_size
operator|==
literal|0
operator|&&
name|ret
operator|==
name|LZMA_OK
operator|&&
name|coder
operator|->
name|sequence
operator|!=
name|SEQ_NORMALIZE
condition|)
name|ret
operator|=
name|coder
operator|->
name|sequence
operator|==
name|SEQ_IS_MATCH
condition|?
name|LZMA_STREAM_END
else|:
name|LZMA_DATA_ERROR
expr_stmt|;
block|}
comment|// We can do an additional check in the range decoder to catch some
comment|// corrupted files.
if|if
condition|(
name|ret
operator|==
name|LZMA_STREAM_END
condition|)
block|{
if|if
condition|(
operator|!
name|rc_is_finished
argument_list|(
name|coder
operator|->
name|rc
argument_list|)
condition|)
name|ret
operator|=
name|LZMA_DATA_ERROR
expr_stmt|;
comment|// Reset the range decoder so that it is ready to reinitialize
comment|// for a new LZMA2 chunk.
name|rc_reset
argument_list|(
name|coder
operator|->
name|rc
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lzma_decoder_uncompressed
parameter_list|(
name|void
modifier|*
name|coder_ptr
parameter_list|,
name|lzma_vli
name|uncompressed_size
parameter_list|)
block|{
name|lzma_lzma1_decoder
modifier|*
name|coder
init|=
name|coder_ptr
decl_stmt|;
name|coder
operator|->
name|uncompressed_size
operator|=
name|uncompressed_size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lzma_decoder_reset
parameter_list|(
name|void
modifier|*
name|coder_ptr
parameter_list|,
specifier|const
name|void
modifier|*
name|opt
parameter_list|)
block|{
name|lzma_lzma1_decoder
modifier|*
name|coder
init|=
name|coder_ptr
decl_stmt|;
specifier|const
name|lzma_options_lzma
modifier|*
name|options
init|=
name|opt
decl_stmt|;
comment|// NOTE: We assume that lc/lp/pb are valid since they were
comment|// successfully decoded with lzma_lzma_decode_properties().
comment|// Calculate pos_mask. We don't need pos_bits as is for anything.
name|coder
operator|->
name|pos_mask
operator|=
operator|(
literal|1U
operator|<<
name|options
operator|->
name|pb
operator|)
operator|-
literal|1
expr_stmt|;
comment|// Initialize the literal decoder.
name|literal_init
argument_list|(
name|coder
operator|->
name|literal
argument_list|,
name|options
operator|->
name|lc
argument_list|,
name|options
operator|->
name|lp
argument_list|)
expr_stmt|;
name|coder
operator|->
name|literal_context_bits
operator|=
name|options
operator|->
name|lc
expr_stmt|;
name|coder
operator|->
name|literal_pos_mask
operator|=
operator|(
literal|1U
operator|<<
name|options
operator|->
name|lp
operator|)
operator|-
literal|1
expr_stmt|;
comment|// State
name|coder
operator|->
name|state
operator|=
name|STATE_LIT_LIT
expr_stmt|;
name|coder
operator|->
name|rep0
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|rep1
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|rep2
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|rep3
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|pos_mask
operator|=
operator|(
literal|1U
operator|<<
name|options
operator|->
name|pb
operator|)
operator|-
literal|1
expr_stmt|;
comment|// Range decoder
name|rc_reset
argument_list|(
name|coder
operator|->
name|rc
argument_list|)
expr_stmt|;
comment|// Bit and bittree decoders
for|for
control|(
name|uint32_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|STATES
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|uint32_t
name|j
init|=
literal|0
init|;
name|j
operator|<=
name|coder
operator|->
name|pos_mask
condition|;
operator|++
name|j
control|)
block|{
name|bit_reset
argument_list|(
name|coder
operator|->
name|is_match
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|bit_reset
argument_list|(
name|coder
operator|->
name|is_rep0_long
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|bit_reset
argument_list|(
name|coder
operator|->
name|is_rep
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bit_reset
argument_list|(
name|coder
operator|->
name|is_rep0
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bit_reset
argument_list|(
name|coder
operator|->
name|is_rep1
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bit_reset
argument_list|(
name|coder
operator|->
name|is_rep2
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|uint32_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|DIST_STATES
condition|;
operator|++
name|i
control|)
name|bittree_reset
argument_list|(
name|coder
operator|->
name|dist_slot
index|[
name|i
index|]
argument_list|,
name|DIST_SLOT_BITS
argument_list|)
expr_stmt|;
for|for
control|(
name|uint32_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|FULL_DISTANCES
operator|-
name|DIST_MODEL_END
condition|;
operator|++
name|i
control|)
name|bit_reset
argument_list|(
name|coder
operator|->
name|pos_special
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bittree_reset
argument_list|(
name|coder
operator|->
name|pos_align
argument_list|,
name|ALIGN_BITS
argument_list|)
expr_stmt|;
comment|// Len decoders (also bit/bittree)
specifier|const
name|uint32_t
name|num_pos_states
init|=
literal|1U
operator|<<
name|options
operator|->
name|pb
decl_stmt|;
name|bit_reset
argument_list|(
name|coder
operator|->
name|match_len_decoder
operator|.
name|choice
argument_list|)
expr_stmt|;
name|bit_reset
argument_list|(
name|coder
operator|->
name|match_len_decoder
operator|.
name|choice2
argument_list|)
expr_stmt|;
name|bit_reset
argument_list|(
name|coder
operator|->
name|rep_len_decoder
operator|.
name|choice
argument_list|)
expr_stmt|;
name|bit_reset
argument_list|(
name|coder
operator|->
name|rep_len_decoder
operator|.
name|choice2
argument_list|)
expr_stmt|;
for|for
control|(
name|uint32_t
name|pos_state
init|=
literal|0
init|;
name|pos_state
operator|<
name|num_pos_states
condition|;
operator|++
name|pos_state
control|)
block|{
name|bittree_reset
argument_list|(
name|coder
operator|->
name|match_len_decoder
operator|.
name|low
index|[
name|pos_state
index|]
argument_list|,
name|LEN_LOW_BITS
argument_list|)
expr_stmt|;
name|bittree_reset
argument_list|(
name|coder
operator|->
name|match_len_decoder
operator|.
name|mid
index|[
name|pos_state
index|]
argument_list|,
name|LEN_MID_BITS
argument_list|)
expr_stmt|;
name|bittree_reset
argument_list|(
name|coder
operator|->
name|rep_len_decoder
operator|.
name|low
index|[
name|pos_state
index|]
argument_list|,
name|LEN_LOW_BITS
argument_list|)
expr_stmt|;
name|bittree_reset
argument_list|(
name|coder
operator|->
name|rep_len_decoder
operator|.
name|mid
index|[
name|pos_state
index|]
argument_list|,
name|LEN_MID_BITS
argument_list|)
expr_stmt|;
block|}
name|bittree_reset
argument_list|(
name|coder
operator|->
name|match_len_decoder
operator|.
name|high
argument_list|,
name|LEN_HIGH_BITS
argument_list|)
expr_stmt|;
name|bittree_reset
argument_list|(
name|coder
operator|->
name|rep_len_decoder
operator|.
name|high
argument_list|,
name|LEN_HIGH_BITS
argument_list|)
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_IS_MATCH
expr_stmt|;
name|coder
operator|->
name|probs
operator|=
name|NULL
expr_stmt|;
name|coder
operator|->
name|symbol
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|limit
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|len
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|extern
name|lzma_ret
name|lzma_lzma_decoder_create
parameter_list|(
name|lzma_lz_decoder
modifier|*
name|lz
parameter_list|,
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|void
modifier|*
name|opt
parameter_list|,
name|lzma_lz_options
modifier|*
name|lz_options
parameter_list|)
block|{
if|if
condition|(
name|lz
operator|->
name|coder
operator|==
name|NULL
condition|)
block|{
name|lz
operator|->
name|coder
operator|=
name|lzma_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lzma_lzma1_decoder
argument_list|)
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|lz
operator|->
name|coder
operator|==
name|NULL
condition|)
return|return
name|LZMA_MEM_ERROR
return|;
name|lz
operator|->
name|code
operator|=
operator|&
name|lzma_decode
expr_stmt|;
name|lz
operator|->
name|reset
operator|=
operator|&
name|lzma_decoder_reset
expr_stmt|;
name|lz
operator|->
name|set_uncompressed
operator|=
operator|&
name|lzma_decoder_uncompressed
expr_stmt|;
block|}
comment|// All dictionary sizes are OK here. LZ decoder will take care of
comment|// the special cases.
specifier|const
name|lzma_options_lzma
modifier|*
name|options
init|=
name|opt
decl_stmt|;
name|lz_options
operator|->
name|dict_size
operator|=
name|options
operator|->
name|dict_size
expr_stmt|;
name|lz_options
operator|->
name|preset_dict
operator|=
name|options
operator|->
name|preset_dict
expr_stmt|;
name|lz_options
operator|->
name|preset_dict_size
operator|=
name|options
operator|->
name|preset_dict_size
expr_stmt|;
return|return
name|LZMA_OK
return|;
block|}
end_function

begin_comment
comment|/// Allocate and initialize LZMA decoder. This is used only via LZ
end_comment

begin_comment
comment|/// initialization (lzma_lzma_decoder_init() passes function pointer to
end_comment

begin_comment
comment|/// the LZ initialization).
end_comment

begin_function
specifier|static
name|lzma_ret
name|lzma_decoder_init
parameter_list|(
name|lzma_lz_decoder
modifier|*
name|lz
parameter_list|,
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|void
modifier|*
name|options
parameter_list|,
name|lzma_lz_options
modifier|*
name|lz_options
parameter_list|)
block|{
if|if
condition|(
operator|!
name|is_lclppb_valid
argument_list|(
name|options
argument_list|)
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
name|return_if_error
argument_list|(
name|lzma_lzma_decoder_create
argument_list|(
name|lz
argument_list|,
name|allocator
argument_list|,
name|options
argument_list|,
name|lz_options
argument_list|)
argument_list|)
expr_stmt|;
name|lzma_decoder_reset
argument_list|(
name|lz
operator|->
name|coder
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|lzma_decoder_uncompressed
argument_list|(
name|lz
operator|->
name|coder
argument_list|,
name|LZMA_VLI_UNKNOWN
argument_list|)
expr_stmt|;
return|return
name|LZMA_OK
return|;
block|}
end_function

begin_function
specifier|extern
name|lzma_ret
name|lzma_lzma_decoder_init
parameter_list|(
name|lzma_next_coder
modifier|*
name|next
parameter_list|,
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|lzma_filter_info
modifier|*
name|filters
parameter_list|)
block|{
comment|// LZMA can only be the last filter in the chain. This is enforced
comment|// by the raw_decoder initialization.
name|assert
argument_list|(
name|filters
index|[
literal|1
index|]
operator|.
name|init
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|lzma_lz_decoder_init
argument_list|(
name|next
argument_list|,
name|allocator
argument_list|,
name|filters
argument_list|,
operator|&
name|lzma_decoder_init
argument_list|)
return|;
block|}
end_function

begin_function
specifier|extern
name|bool
name|lzma_lzma_lclppb_decode
parameter_list|(
name|lzma_options_lzma
modifier|*
name|options
parameter_list|,
name|uint8_t
name|byte
parameter_list|)
block|{
if|if
condition|(
name|byte
operator|>
operator|(
literal|4
operator|*
literal|5
operator|+
literal|4
operator|)
operator|*
literal|9
operator|+
literal|8
condition|)
return|return
name|true
return|;
comment|// See the file format specification to understand this.
name|options
operator|->
name|pb
operator|=
name|byte
operator|/
operator|(
literal|9
operator|*
literal|5
operator|)
expr_stmt|;
name|byte
operator|-=
name|options
operator|->
name|pb
operator|*
literal|9
operator|*
literal|5
expr_stmt|;
name|options
operator|->
name|lp
operator|=
name|byte
operator|/
literal|9
expr_stmt|;
name|options
operator|->
name|lc
operator|=
name|byte
operator|-
name|options
operator|->
name|lp
operator|*
literal|9
expr_stmt|;
return|return
name|options
operator|->
name|lc
operator|+
name|options
operator|->
name|lp
operator|>
name|LZMA_LCLP_MAX
return|;
block|}
end_function

begin_function
specifier|extern
name|uint64_t
name|lzma_lzma_decoder_memusage_nocheck
parameter_list|(
specifier|const
name|void
modifier|*
name|options
parameter_list|)
block|{
specifier|const
name|lzma_options_lzma
modifier|*
specifier|const
name|opt
init|=
name|options
decl_stmt|;
return|return
sizeof|sizeof
argument_list|(
name|lzma_lzma1_decoder
argument_list|)
operator|+
name|lzma_lz_decoder_memusage
argument_list|(
name|opt
operator|->
name|dict_size
argument_list|)
return|;
block|}
end_function

begin_function
specifier|extern
name|uint64_t
name|lzma_lzma_decoder_memusage
parameter_list|(
specifier|const
name|void
modifier|*
name|options
parameter_list|)
block|{
if|if
condition|(
operator|!
name|is_lclppb_valid
argument_list|(
name|options
argument_list|)
condition|)
return|return
name|UINT64_MAX
return|;
return|return
name|lzma_lzma_decoder_memusage_nocheck
argument_list|(
name|options
argument_list|)
return|;
block|}
end_function

begin_function
specifier|extern
name|lzma_ret
name|lzma_lzma_props_decode
parameter_list|(
name|void
modifier|*
modifier|*
name|options
parameter_list|,
specifier|const
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|props
parameter_list|,
name|size_t
name|props_size
parameter_list|)
block|{
if|if
condition|(
name|props_size
operator|!=
literal|5
condition|)
return|return
name|LZMA_OPTIONS_ERROR
return|;
name|lzma_options_lzma
modifier|*
name|opt
init|=
name|lzma_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lzma_options_lzma
argument_list|)
argument_list|,
name|allocator
argument_list|)
decl_stmt|;
if|if
condition|(
name|opt
operator|==
name|NULL
condition|)
return|return
name|LZMA_MEM_ERROR
return|;
if|if
condition|(
name|lzma_lzma_lclppb_decode
argument_list|(
name|opt
argument_list|,
name|props
index|[
literal|0
index|]
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|// All dictionary sizes are accepted, including zero. LZ decoder
comment|// will automatically use a dictionary at least a few KiB even if
comment|// a smaller dictionary is requested.
name|opt
operator|->
name|dict_size
operator|=
name|unaligned_read32le
argument_list|(
name|props
operator|+
literal|1
argument_list|)
expr_stmt|;
name|opt
operator|->
name|preset_dict
operator|=
name|NULL
expr_stmt|;
name|opt
operator|->
name|preset_dict_size
operator|=
literal|0
expr_stmt|;
operator|*
name|options
operator|=
name|opt
expr_stmt|;
return|return
name|LZMA_OK
return|;
name|error
label|:
name|lzma_free
argument_list|(
name|opt
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
return|return
name|LZMA_OPTIONS_ERROR
return|;
block|}
end_function

end_unit

