begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       sha256.c
end_comment

begin_comment
comment|/// \brief      SHA-256
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \todo       Crypto++ has x86 ASM optimizations. They use SSE so if they
end_comment

begin_comment
comment|///             are imported to liblzma, SSE instructions need to be used
end_comment

begin_comment
comment|///             conditionally to keep the code working on older boxes.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This code is based on the code found from 7-Zip, which has a modified
end_comment

begin_comment
comment|//  version of the SHA-256 found from Crypto++<http://www.cryptopp.com/>.
end_comment

begin_comment
comment|//  The code was modified a little to fit into liblzma.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Authors:    Kevin Springle
end_comment

begin_comment
comment|//              Wei Dai
end_comment

begin_comment
comment|//              Igor Pavlov
end_comment

begin_comment
comment|//              Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|// Avoid bogus warnings in transform().
end_comment

begin_if
if|#
directive|if
operator|(
name|__GNUC__
operator|==
literal|4
operator|&&
name|__GNUC_MINOR__
operator|>=
literal|2
operator|)
operator|||
name|__GNUC__
operator|>
literal|4
end_if

begin_pragma
pragma|#
directive|pragma
name|GCC
name|diagnostic
name|ignored
literal|"-Wuninitialized"
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"check.h"
end_include

begin_comment
comment|// At least on x86, GCC is able to optimize this to a rotate instruction.
end_comment

begin_define
define|#
directive|define
name|rotr_32
parameter_list|(
name|num
parameter_list|,
name|amount
parameter_list|)
value|((num)>> (amount) | (num)<< (32 - (amount)))
end_define

begin_define
define|#
directive|define
name|blk0
parameter_list|(
name|i
parameter_list|)
value|(W[i] = data[i])
end_define

begin_define
define|#
directive|define
name|blk2
parameter_list|(
name|i
parameter_list|)
value|(W[i& 15] += s1(W[(i - 2)& 15]) + W[(i - 7)& 15] \ 		+ s0(W[(i - 15)& 15]))
end_define

begin_define
define|#
directive|define
name|Ch
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|(z ^ (x& (y ^ z)))
end_define

begin_define
define|#
directive|define
name|Maj
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|((x& y) | (z& (x | y)))
end_define

begin_define
define|#
directive|define
name|a
parameter_list|(
name|i
parameter_list|)
value|T[(0 - i)& 7]
end_define

begin_define
define|#
directive|define
name|b
parameter_list|(
name|i
parameter_list|)
value|T[(1 - i)& 7]
end_define

begin_define
define|#
directive|define
name|c
parameter_list|(
name|i
parameter_list|)
value|T[(2 - i)& 7]
end_define

begin_define
define|#
directive|define
name|d
parameter_list|(
name|i
parameter_list|)
value|T[(3 - i)& 7]
end_define

begin_define
define|#
directive|define
name|e
parameter_list|(
name|i
parameter_list|)
value|T[(4 - i)& 7]
end_define

begin_define
define|#
directive|define
name|f
parameter_list|(
name|i
parameter_list|)
value|T[(5 - i)& 7]
end_define

begin_define
define|#
directive|define
name|g
parameter_list|(
name|i
parameter_list|)
value|T[(6 - i)& 7]
end_define

begin_define
define|#
directive|define
name|h
parameter_list|(
name|i
parameter_list|)
value|T[(7 - i)& 7]
end_define

begin_define
define|#
directive|define
name|R
parameter_list|(
name|i
parameter_list|)
define|\
value|h(i) += S1(e(i)) + Ch(e(i), f(i), g(i)) + SHA256_K[i + j] \ 		+ (j ? blk2(i) : blk0(i)); \ 	d(i) += h(i); \ 	h(i) += S0(a(i)) + Maj(a(i), b(i), c(i))
end_define

begin_define
define|#
directive|define
name|S0
parameter_list|(
name|x
parameter_list|)
value|(rotr_32(x, 2) ^ rotr_32(x, 13) ^ rotr_32(x, 22))
end_define

begin_define
define|#
directive|define
name|S1
parameter_list|(
name|x
parameter_list|)
value|(rotr_32(x, 6) ^ rotr_32(x, 11) ^ rotr_32(x, 25))
end_define

begin_define
define|#
directive|define
name|s0
parameter_list|(
name|x
parameter_list|)
value|(rotr_32(x, 7) ^ rotr_32(x, 18) ^ (x>> 3))
end_define

begin_define
define|#
directive|define
name|s1
parameter_list|(
name|x
parameter_list|)
value|(rotr_32(x, 17) ^ rotr_32(x, 19) ^ (x>> 10))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|uint32_t
name|SHA256_K
index|[
literal|64
index|]
init|=
block|{
literal|0x428A2F98
block|,
literal|0x71374491
block|,
literal|0xB5C0FBCF
block|,
literal|0xE9B5DBA5
block|,
literal|0x3956C25B
block|,
literal|0x59F111F1
block|,
literal|0x923F82A4
block|,
literal|0xAB1C5ED5
block|,
literal|0xD807AA98
block|,
literal|0x12835B01
block|,
literal|0x243185BE
block|,
literal|0x550C7DC3
block|,
literal|0x72BE5D74
block|,
literal|0x80DEB1FE
block|,
literal|0x9BDC06A7
block|,
literal|0xC19BF174
block|,
literal|0xE49B69C1
block|,
literal|0xEFBE4786
block|,
literal|0x0FC19DC6
block|,
literal|0x240CA1CC
block|,
literal|0x2DE92C6F
block|,
literal|0x4A7484AA
block|,
literal|0x5CB0A9DC
block|,
literal|0x76F988DA
block|,
literal|0x983E5152
block|,
literal|0xA831C66D
block|,
literal|0xB00327C8
block|,
literal|0xBF597FC7
block|,
literal|0xC6E00BF3
block|,
literal|0xD5A79147
block|,
literal|0x06CA6351
block|,
literal|0x14292967
block|,
literal|0x27B70A85
block|,
literal|0x2E1B2138
block|,
literal|0x4D2C6DFC
block|,
literal|0x53380D13
block|,
literal|0x650A7354
block|,
literal|0x766A0ABB
block|,
literal|0x81C2C92E
block|,
literal|0x92722C85
block|,
literal|0xA2BFE8A1
block|,
literal|0xA81A664B
block|,
literal|0xC24B8B70
block|,
literal|0xC76C51A3
block|,
literal|0xD192E819
block|,
literal|0xD6990624
block|,
literal|0xF40E3585
block|,
literal|0x106AA070
block|,
literal|0x19A4C116
block|,
literal|0x1E376C08
block|,
literal|0x2748774C
block|,
literal|0x34B0BCB5
block|,
literal|0x391C0CB3
block|,
literal|0x4ED8AA4A
block|,
literal|0x5B9CCA4F
block|,
literal|0x682E6FF3
block|,
literal|0x748F82EE
block|,
literal|0x78A5636F
block|,
literal|0x84C87814
block|,
literal|0x8CC70208
block|,
literal|0x90BEFFFA
block|,
literal|0xA4506CEB
block|,
literal|0xBEF9A3F7
block|,
literal|0xC67178F2
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|transform
parameter_list|(
name|uint32_t
name|state
index|[
literal|8
index|]
parameter_list|,
specifier|const
name|uint32_t
name|data
index|[
literal|16
index|]
parameter_list|)
block|{
name|uint32_t
name|W
index|[
literal|16
index|]
decl_stmt|;
name|uint32_t
name|T
index|[
literal|8
index|]
decl_stmt|;
comment|// Copy state[] to working vars.
name|memcpy
argument_list|(
name|T
argument_list|,
name|state
argument_list|,
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
expr_stmt|;
comment|// 64 operations, partially loop unrolled
for|for
control|(
name|unsigned
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|64
condition|;
name|j
operator|+=
literal|16
control|)
block|{
name|R
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|R
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|R
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|R
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|R
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|R
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|R
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|R
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|R
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|R
argument_list|(
literal|9
argument_list|)
expr_stmt|;
name|R
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|R
argument_list|(
literal|11
argument_list|)
expr_stmt|;
name|R
argument_list|(
literal|12
argument_list|)
expr_stmt|;
name|R
argument_list|(
literal|13
argument_list|)
expr_stmt|;
name|R
argument_list|(
literal|14
argument_list|)
expr_stmt|;
name|R
argument_list|(
literal|15
argument_list|)
expr_stmt|;
block|}
comment|// Add the working vars back into state[].
name|state
index|[
literal|0
index|]
operator|+=
name|a
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|state
index|[
literal|1
index|]
operator|+=
name|b
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|state
index|[
literal|2
index|]
operator|+=
name|c
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|state
index|[
literal|3
index|]
operator|+=
name|d
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|state
index|[
literal|4
index|]
operator|+=
name|e
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|state
index|[
literal|5
index|]
operator|+=
name|f
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|state
index|[
literal|6
index|]
operator|+=
name|g
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|state
index|[
literal|7
index|]
operator|+=
name|h
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|process
parameter_list|(
name|lzma_check_state
modifier|*
name|check
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|WORDS_BIGENDIAN
name|transform
argument_list|(
name|check
operator|->
name|state
operator|.
name|sha256
operator|.
name|state
argument_list|,
name|check
operator|->
name|buffer
operator|.
name|u32
argument_list|)
expr_stmt|;
else|#
directive|else
name|uint32_t
name|data
index|[
literal|16
index|]
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
name|data
index|[
name|i
index|]
operator|=
name|bswap32
argument_list|(
name|check
operator|->
name|buffer
operator|.
name|u32
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|transform
argument_list|(
name|check
operator|->
name|state
operator|.
name|sha256
operator|.
name|state
argument_list|,
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_function
specifier|extern
name|void
name|lzma_sha256_init
parameter_list|(
name|lzma_check_state
modifier|*
name|check
parameter_list|)
block|{
specifier|static
specifier|const
name|uint32_t
name|s
index|[
literal|8
index|]
init|=
block|{
literal|0x6A09E667
block|,
literal|0xBB67AE85
block|,
literal|0x3C6EF372
block|,
literal|0xA54FF53A
block|,
literal|0x510E527F
block|,
literal|0x9B05688C
block|,
literal|0x1F83D9AB
block|,
literal|0x5BE0CD19
block|, 	}
decl_stmt|;
name|memcpy
argument_list|(
name|check
operator|->
name|state
operator|.
name|sha256
operator|.
name|state
argument_list|,
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|check
operator|->
name|state
operator|.
name|sha256
operator|.
name|size
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|extern
name|void
name|lzma_sha256_update
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|lzma_check_state
modifier|*
name|check
parameter_list|)
block|{
comment|// Copy the input data into a properly aligned temporary buffer.
comment|// This way we can be called with arbitrarily sized buffers
comment|// (no need to be multiple of 64 bytes), and the code works also
comment|// on architectures that don't allow unaligned memory access.
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
specifier|const
name|size_t
name|copy_start
init|=
name|check
operator|->
name|state
operator|.
name|sha256
operator|.
name|size
operator|&
literal|0x3F
decl_stmt|;
name|size_t
name|copy_size
init|=
literal|64
operator|-
name|copy_start
decl_stmt|;
if|if
condition|(
name|copy_size
operator|>
name|size
condition|)
name|copy_size
operator|=
name|size
expr_stmt|;
name|memcpy
argument_list|(
name|check
operator|->
name|buffer
operator|.
name|u8
operator|+
name|copy_start
argument_list|,
name|buf
argument_list|,
name|copy_size
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|copy_size
expr_stmt|;
name|size
operator|-=
name|copy_size
expr_stmt|;
name|check
operator|->
name|state
operator|.
name|sha256
operator|.
name|size
operator|+=
name|copy_size
expr_stmt|;
if|if
condition|(
operator|(
name|check
operator|->
name|state
operator|.
name|sha256
operator|.
name|size
operator|&
literal|0x3F
operator|)
operator|==
literal|0
condition|)
name|process
argument_list|(
name|check
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|extern
name|void
name|lzma_sha256_finish
parameter_list|(
name|lzma_check_state
modifier|*
name|check
parameter_list|)
block|{
comment|// Add padding as described in RFC 3174 (it describes SHA-1 but
comment|// the same padding style is used for SHA-256 too).
name|size_t
name|pos
init|=
name|check
operator|->
name|state
operator|.
name|sha256
operator|.
name|size
operator|&
literal|0x3F
decl_stmt|;
name|check
operator|->
name|buffer
operator|.
name|u8
index|[
name|pos
operator|++
index|]
operator|=
literal|0x80
expr_stmt|;
while|while
condition|(
name|pos
operator|!=
literal|64
operator|-
literal|8
condition|)
block|{
if|if
condition|(
name|pos
operator|==
literal|64
condition|)
block|{
name|process
argument_list|(
name|check
argument_list|)
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
block|}
name|check
operator|->
name|buffer
operator|.
name|u8
index|[
name|pos
operator|++
index|]
operator|=
literal|0x00
expr_stmt|;
block|}
comment|// Convert the message size from bytes to bits.
name|check
operator|->
name|state
operator|.
name|sha256
operator|.
name|size
operator|*=
literal|8
expr_stmt|;
name|check
operator|->
name|buffer
operator|.
name|u64
index|[
operator|(
literal|64
operator|-
literal|8
operator|)
operator|/
literal|8
index|]
operator|=
name|conv64be
argument_list|(
name|check
operator|->
name|state
operator|.
name|sha256
operator|.
name|size
argument_list|)
expr_stmt|;
name|process
argument_list|(
name|check
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
name|check
operator|->
name|buffer
operator|.
name|u32
index|[
name|i
index|]
operator|=
name|conv32be
argument_list|(
name|check
operator|->
name|state
operator|.
name|sha256
operator|.
name|state
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

