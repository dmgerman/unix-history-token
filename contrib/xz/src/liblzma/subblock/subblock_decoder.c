begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       subblock_decoder.c
end_comment

begin_comment
comment|/// \brief      Decoder of the Subblock filter
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Author:     Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"subblock_decoder.h"
end_include

begin_include
include|#
directive|include
file|"subblock_decoder_helper.h"
end_include

begin_include
include|#
directive|include
file|"filter_decoder.h"
end_include

begin_comment
comment|/// Maximum number of consecutive Subblocks with Subblock Type Padding
end_comment

begin_define
define|#
directive|define
name|PADDING_MAX
value|31
end_define

begin_struct
struct|struct
name|lzma_coder_s
block|{
name|lzma_next_coder
name|next
decl_stmt|;
enum|enum
block|{
comment|// These require that there is at least one input
comment|// byte available.
name|SEQ_FLAGS
block|,
name|SEQ_FILTER_FLAGS
block|,
name|SEQ_FILTER_END
block|,
name|SEQ_REPEAT_COUNT_1
block|,
name|SEQ_REPEAT_COUNT_2
block|,
name|SEQ_REPEAT_COUNT_3
block|,
name|SEQ_REPEAT_SIZE
block|,
name|SEQ_REPEAT_READ_DATA
block|,
name|SEQ_SIZE_1
block|,
name|SEQ_SIZE_2
block|,
name|SEQ_SIZE_3
block|,
comment|// This must be right before SEQ_DATA.
comment|// These don't require any input to be available.
name|SEQ_DATA
block|,
name|SEQ_REPEAT_FAST
block|,
name|SEQ_REPEAT_NORMAL
block|, 	}
name|sequence
enum|;
comment|/// Number of bytes left in the current Subblock Data field.
name|size_t
name|size
decl_stmt|;
comment|/// Number of consecutive Subblocks with Subblock Type Padding
name|uint32_t
name|padding
decl_stmt|;
comment|/// True when .next.code() has returned LZMA_STREAM_END.
name|bool
name|next_finished
decl_stmt|;
comment|/// True when the Subblock decoder has detected End of Payload Marker.
comment|/// This may become true before next_finished becomes true.
name|bool
name|this_finished
decl_stmt|;
comment|/// True if Subfilters are allowed.
name|bool
name|allow_subfilters
decl_stmt|;
comment|/// Indicates if at least one byte of decoded output has been
comment|/// produced after enabling Subfilter.
name|bool
name|got_output_with_subfilter
decl_stmt|;
comment|/// Possible subfilter
name|lzma_next_coder
name|subfilter
decl_stmt|;
comment|/// Filter Flags decoder is needed to parse the ID and Properties
comment|/// of the subfilter.
name|lzma_next_coder
name|filter_flags_decoder
decl_stmt|;
comment|/// The filter_flags_decoder stores its results here.
name|lzma_filter
name|filter_flags
decl_stmt|;
comment|/// Options for the Subblock decoder helper. This is used to tell
comment|/// the helper when it should return LZMA_STREAM_END to the subfilter.
name|lzma_options_subblock_helper
name|helper
decl_stmt|;
struct|struct
block|{
comment|/// How many times buffer should be repeated
name|size_t
name|count
decl_stmt|;
comment|/// Size of the buffer
name|size_t
name|size
decl_stmt|;
comment|/// Position in the buffer
name|size_t
name|pos
decl_stmt|;
comment|/// Buffer to hold the data to be repeated
name|uint8_t
name|buffer
index|[
name|LZMA_SUBBLOCK_RLE_MAX
index|]
decl_stmt|;
block|}
name|repeat
struct|;
comment|/// Temporary buffer needed when the Subblock filter is not the last
comment|/// filter in the chain. The output of the next filter is first
comment|/// decoded into buffer[], which is then used as input for the actual
comment|/// Subblock decoder.
struct|struct
block|{
name|size_t
name|pos
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|uint8_t
name|buffer
index|[
name|LZMA_BUFFER_SIZE
index|]
decl_stmt|;
block|}
name|temp
struct|;
block|}
struct|;
end_struct

begin_comment
comment|/// Values of valid Subblock Flags
end_comment

begin_enum
enum|enum
block|{
name|FLAG_PADDING
block|,
name|FLAG_EOPM
block|,
name|FLAG_DATA
block|,
name|FLAG_REPEAT
block|,
name|FLAG_SET_SUBFILTER
block|,
name|FLAG_END_SUBFILTER
block|, }
enum|;
end_enum

begin_comment
comment|/// Calls the subfilter and updates coder->uncompressed_size.
end_comment

begin_function
specifier|static
name|lzma_ret
name|subfilter_decode
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|in
parameter_list|,
name|size_t
modifier|*
name|in_pos
parameter_list|,
name|size_t
name|in_size
parameter_list|,
name|uint8_t
modifier|*
specifier|restrict
name|out
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|out_pos
parameter_list|,
name|size_t
name|out_size
parameter_list|,
name|lzma_action
name|action
parameter_list|)
block|{
name|assert
argument_list|(
name|coder
operator|->
name|subfilter
operator|.
name|code
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|// Call the subfilter.
specifier|const
name|lzma_ret
name|ret
init|=
name|coder
operator|->
name|subfilter
operator|.
name|code
argument_list|(
name|coder
operator|->
name|subfilter
operator|.
name|coder
argument_list|,
name|allocator
argument_list|,
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|,
name|action
argument_list|)
decl_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|lzma_ret
name|decode_buffer
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|in
parameter_list|,
name|size_t
modifier|*
name|in_pos
parameter_list|,
name|size_t
name|in_size
parameter_list|,
name|uint8_t
modifier|*
specifier|restrict
name|out
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|out_pos
parameter_list|,
name|size_t
name|out_size
parameter_list|,
name|lzma_action
name|action
parameter_list|)
block|{
while|while
condition|(
operator|*
name|out_pos
operator|<
name|out_size
operator|&&
operator|(
operator|*
name|in_pos
operator|<
name|in_size
operator|||
name|coder
operator|->
name|sequence
operator|>=
name|SEQ_DATA
operator|)
condition|)
switch|switch
condition|(
name|coder
operator|->
name|sequence
condition|)
block|{
case|case
name|SEQ_FLAGS
case|:
block|{
comment|// Do the correct action depending on the Subblock Type.
switch|switch
condition|(
name|in
index|[
operator|*
name|in_pos
index|]
operator|>>
literal|4
condition|)
block|{
case|case
name|FLAG_PADDING
case|:
comment|// Only check that reserved bits are zero.
if|if
condition|(
operator|++
name|coder
operator|->
name|padding
operator|>
name|PADDING_MAX
operator|||
name|in
index|[
operator|*
name|in_pos
index|]
operator|&
literal|0x0F
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
operator|++
operator|*
name|in_pos
expr_stmt|;
break|break;
case|case
name|FLAG_EOPM
case|:
comment|// There must be no Padding before EOPM.
if|if
condition|(
name|coder
operator|->
name|padding
operator|!=
literal|0
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
comment|// Check that reserved bits are zero.
if|if
condition|(
name|in
index|[
operator|*
name|in_pos
index|]
operator|&
literal|0x0F
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
comment|// There must be no Subfilter enabled.
if|if
condition|(
name|coder
operator|->
name|subfilter
operator|.
name|code
operator|!=
name|NULL
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
operator|++
operator|*
name|in_pos
expr_stmt|;
return|return
name|LZMA_STREAM_END
return|;
case|case
name|FLAG_DATA
case|:
comment|// First four bits of the Subblock Data size.
name|coder
operator|->
name|size
operator|=
name|in
index|[
operator|*
name|in_pos
index|]
operator|&
literal|0x0F
expr_stmt|;
operator|++
operator|*
name|in_pos
expr_stmt|;
name|coder
operator|->
name|got_output_with_subfilter
operator|=
name|true
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_SIZE_1
expr_stmt|;
break|break;
case|case
name|FLAG_REPEAT
case|:
comment|// First four bits of the Repeat Count. We use
comment|// coder->size as a temporary place for it.
name|coder
operator|->
name|size
operator|=
name|in
index|[
operator|*
name|in_pos
index|]
operator|&
literal|0x0F
expr_stmt|;
operator|++
operator|*
name|in_pos
expr_stmt|;
name|coder
operator|->
name|got_output_with_subfilter
operator|=
name|true
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_REPEAT_COUNT_1
expr_stmt|;
break|break;
case|case
name|FLAG_SET_SUBFILTER
case|:
block|{
if|if
condition|(
name|coder
operator|->
name|padding
operator|!=
literal|0
operator|||
operator|(
name|in
index|[
operator|*
name|in_pos
index|]
operator|&
literal|0x0F
operator|)
operator|||
name|coder
operator|->
name|subfilter
operator|.
name|code
operator|!=
name|NULL
operator|||
operator|!
name|coder
operator|->
name|allow_subfilters
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
name|assert
argument_list|(
name|coder
operator|->
name|filter_flags
operator|.
name|options
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
comment|// 			return_if_error(lzma_filter_flags_decoder_init(
comment|//&coder->filter_flags_decoder,
comment|// 					allocator,&coder->filter_flags));
name|coder
operator|->
name|got_output_with_subfilter
operator|=
name|false
expr_stmt|;
operator|++
operator|*
name|in_pos
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_FILTER_FLAGS
expr_stmt|;
break|break;
block|}
case|case
name|FLAG_END_SUBFILTER
case|:
block|{
if|if
condition|(
name|coder
operator|->
name|padding
operator|!=
literal|0
operator|||
operator|(
name|in
index|[
operator|*
name|in_pos
index|]
operator|&
literal|0x0F
operator|)
operator|||
name|coder
operator|->
name|subfilter
operator|.
name|code
operator|==
name|NULL
operator|||
operator|!
name|coder
operator|->
name|got_output_with_subfilter
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
comment|// Tell the helper filter to indicate End of Input
comment|// to our subfilter.
name|coder
operator|->
name|helper
operator|.
name|end_was_reached
operator|=
name|true
expr_stmt|;
name|size_t
name|dummy
init|=
literal|0
decl_stmt|;
specifier|const
name|lzma_ret
name|ret
init|=
name|subfilter_decode
argument_list|(
name|coder
argument_list|,
name|allocator
argument_list|,
name|NULL
argument_list|,
operator|&
name|dummy
argument_list|,
literal|0
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|,
name|action
argument_list|)
decl_stmt|;
comment|// If we didn't reach the end of the subfilter's output
comment|// yet, return to the application. On the next call we
comment|// will get to this same switch-case again, because we
comment|// haven't updated *in_pos yet.
if|if
condition|(
name|ret
operator|!=
name|LZMA_STREAM_END
condition|)
return|return
name|ret
return|;
comment|// Free Subfilter's memory. This is a bit debatable,
comment|// since we could avoid some malloc()/free() calls
comment|// if the same Subfilter gets used soon again. But
comment|// if Subfilter isn't used again, we could leave
comment|// a memory-hogging filter dangling until someone
comment|// frees Subblock filter itself.
name|lzma_next_end
argument_list|(
operator|&
name|coder
operator|->
name|subfilter
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
comment|// Free memory used for subfilter options. This is
comment|// safe, because we don't support any Subfilter that
comment|// would allow pointers in the options structure.
name|lzma_free
argument_list|(
name|coder
operator|->
name|filter_flags
operator|.
name|options
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|coder
operator|->
name|filter_flags
operator|.
name|options
operator|=
name|NULL
expr_stmt|;
operator|++
operator|*
name|in_pos
expr_stmt|;
break|break;
block|}
default|default:
return|return
name|LZMA_DATA_ERROR
return|;
block|}
break|break;
block|}
case|case
name|SEQ_FILTER_FLAGS
case|:
block|{
specifier|const
name|lzma_ret
name|ret
init|=
name|coder
operator|->
name|filter_flags_decoder
operator|.
name|code
argument_list|(
name|coder
operator|->
name|filter_flags_decoder
operator|.
name|coder
argument_list|,
name|allocator
argument_list|,
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|LZMA_RUN
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_STREAM_END
condition|)
return|return
name|ret
operator|==
name|LZMA_OPTIONS_ERROR
condition|?
name|LZMA_DATA_ERROR
else|:
name|ret
return|;
comment|// Don't free the filter_flags_decoder. It doesn't take much
comment|// memory and we may need it again.
comment|// Initialize the Subfilter. Subblock and Copy filters are
comment|// not allowed.
if|if
condition|(
name|coder
operator|->
name|filter_flags
operator|.
name|id
operator|==
name|LZMA_FILTER_SUBBLOCK
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
name|coder
operator|->
name|helper
operator|.
name|end_was_reached
operator|=
name|false
expr_stmt|;
name|lzma_filter
name|filters
index|[
literal|3
index|]
init|=
block|{
block|{
operator|.
name|id
operator|=
name|coder
operator|->
name|filter_flags
operator|.
name|id
block|,
operator|.
name|options
operator|=
name|coder
operator|->
name|filter_flags
operator|.
name|options
block|, 			}
block|,
block|{
operator|.
name|id
operator|=
name|LZMA_FILTER_SUBBLOCK_HELPER
block|,
operator|.
name|options
operator|=
operator|&
name|coder
operator|->
name|helper
block|, 			}
block|,
block|{
operator|.
name|id
operator|=
name|LZMA_VLI_UNKNOWN
block|,
operator|.
name|options
operator|=
name|NULL
block|, 			}
block|}
decl_stmt|;
comment|// Optimization: We know that LZMA uses End of Payload Marker
comment|// (not End of Input), so we can omit the helper filter.
if|if
condition|(
name|filters
index|[
literal|0
index|]
operator|.
name|id
operator|==
name|LZMA_FILTER_LZMA1
condition|)
name|filters
index|[
literal|1
index|]
operator|.
name|id
operator|=
name|LZMA_VLI_UNKNOWN
expr_stmt|;
name|return_if_error
argument_list|(
name|lzma_raw_decoder_init
argument_list|(
operator|&
name|coder
operator|->
name|subfilter
argument_list|,
name|allocator
argument_list|,
name|filters
argument_list|)
argument_list|)
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_FLAGS
expr_stmt|;
break|break;
block|}
case|case
name|SEQ_FILTER_END
case|:
comment|// We are in the beginning of a Subblock. The next Subblock
comment|// whose type is not Padding, must indicate end of Subfilter.
if|if
condition|(
name|in
index|[
operator|*
name|in_pos
index|]
operator|==
operator|(
name|FLAG_PADDING
operator|<<
literal|4
operator|)
condition|)
block|{
operator|++
operator|*
name|in_pos
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|in
index|[
operator|*
name|in_pos
index|]
operator|!=
operator|(
name|FLAG_END_SUBFILTER
operator|<<
literal|4
operator|)
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_FLAGS
expr_stmt|;
break|break;
case|case
name|SEQ_REPEAT_COUNT_1
case|:
case|case
name|SEQ_SIZE_1
case|:
comment|// We use the same code to parse
comment|//  - the Size (28 bits) in Subblocks of type Data; and
comment|//  - the Repeat count (28 bits) in Subblocks of type
comment|//    Repeating Data.
name|coder
operator|->
name|size
operator||=
call|(
name|size_t
call|)
argument_list|(
name|in
index|[
operator|*
name|in_pos
index|]
argument_list|)
operator|<<
literal|4
expr_stmt|;
operator|++
operator|*
name|in_pos
expr_stmt|;
operator|++
name|coder
operator|->
name|sequence
expr_stmt|;
break|break;
case|case
name|SEQ_REPEAT_COUNT_2
case|:
case|case
name|SEQ_SIZE_2
case|:
name|coder
operator|->
name|size
operator||=
call|(
name|size_t
call|)
argument_list|(
name|in
index|[
operator|*
name|in_pos
index|]
argument_list|)
operator|<<
literal|12
expr_stmt|;
operator|++
operator|*
name|in_pos
expr_stmt|;
operator|++
name|coder
operator|->
name|sequence
expr_stmt|;
break|break;
case|case
name|SEQ_REPEAT_COUNT_3
case|:
case|case
name|SEQ_SIZE_3
case|:
name|coder
operator|->
name|size
operator||=
call|(
name|size_t
call|)
argument_list|(
name|in
index|[
operator|*
name|in_pos
index|]
argument_list|)
operator|<<
literal|20
expr_stmt|;
operator|++
operator|*
name|in_pos
expr_stmt|;
comment|// The real value is the stored value plus one.
operator|++
name|coder
operator|->
name|size
expr_stmt|;
comment|// This moves to SEQ_REPEAT_SIZE or SEQ_DATA. That's why
comment|// SEQ_DATA must be right after SEQ_SIZE_3 in coder->sequence.
operator|++
name|coder
operator|->
name|sequence
expr_stmt|;
break|break;
case|case
name|SEQ_REPEAT_SIZE
case|:
comment|// Move the Repeat Count to the correct variable and parse
comment|// the Size of the Data to be repeated.
name|coder
operator|->
name|repeat
operator|.
name|count
operator|=
name|coder
operator|->
name|size
expr_stmt|;
name|coder
operator|->
name|repeat
operator|.
name|size
operator|=
call|(
name|size_t
call|)
argument_list|(
name|in
index|[
operator|*
name|in_pos
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|coder
operator|->
name|repeat
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
comment|// The size of the Data field must be bigger than the number
comment|// of Padding bytes before this Subblock.
if|if
condition|(
name|coder
operator|->
name|repeat
operator|.
name|size
operator|<=
name|coder
operator|->
name|padding
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
operator|++
operator|*
name|in_pos
expr_stmt|;
name|coder
operator|->
name|padding
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_REPEAT_READ_DATA
expr_stmt|;
break|break;
case|case
name|SEQ_REPEAT_READ_DATA
case|:
block|{
comment|// Fill coder->repeat.buffer[].
specifier|const
name|size_t
name|in_avail
init|=
name|in_size
operator|-
operator|*
name|in_pos
decl_stmt|;
specifier|const
name|size_t
name|out_avail
init|=
name|coder
operator|->
name|repeat
operator|.
name|size
operator|-
name|coder
operator|->
name|repeat
operator|.
name|pos
decl_stmt|;
specifier|const
name|size_t
name|copy_size
init|=
name|MIN
argument_list|(
name|in_avail
argument_list|,
name|out_avail
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|coder
operator|->
name|repeat
operator|.
name|buffer
operator|+
name|coder
operator|->
name|repeat
operator|.
name|pos
argument_list|,
name|in
operator|+
operator|*
name|in_pos
argument_list|,
name|copy_size
argument_list|)
expr_stmt|;
operator|*
name|in_pos
operator|+=
name|copy_size
expr_stmt|;
name|coder
operator|->
name|repeat
operator|.
name|pos
operator|+=
name|copy_size
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|repeat
operator|.
name|pos
operator|==
name|coder
operator|->
name|repeat
operator|.
name|size
condition|)
block|{
name|coder
operator|->
name|repeat
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|repeat
operator|.
name|size
operator|==
literal|1
operator|&&
name|coder
operator|->
name|subfilter
operator|.
name|code
operator|==
name|NULL
condition|)
name|coder
operator|->
name|sequence
operator|=
name|SEQ_REPEAT_FAST
expr_stmt|;
else|else
name|coder
operator|->
name|sequence
operator|=
name|SEQ_REPEAT_NORMAL
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SEQ_DATA
case|:
block|{
comment|// The size of the Data field must be bigger than the number
comment|// of Padding bytes before this Subblock.
name|assert
argument_list|(
name|coder
operator|->
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|size
operator|<=
name|coder
operator|->
name|padding
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
name|coder
operator|->
name|padding
operator|=
literal|0
expr_stmt|;
comment|// Limit the amount of input to match the available
comment|// Subblock Data size.
name|size_t
name|in_limit
decl_stmt|;
if|if
condition|(
name|in_size
operator|-
operator|*
name|in_pos
operator|>
name|coder
operator|->
name|size
condition|)
name|in_limit
operator|=
operator|*
name|in_pos
operator|+
name|coder
operator|->
name|size
expr_stmt|;
else|else
name|in_limit
operator|=
name|in_size
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|subfilter
operator|.
name|code
operator|==
name|NULL
condition|)
block|{
specifier|const
name|size_t
name|copy_size
init|=
name|lzma_bufcpy
argument_list|(
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_limit
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|)
decl_stmt|;
name|coder
operator|->
name|size
operator|-=
name|copy_size
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|size_t
name|in_start
init|=
operator|*
name|in_pos
decl_stmt|;
specifier|const
name|lzma_ret
name|ret
init|=
name|subfilter_decode
argument_list|(
name|coder
argument_list|,
name|allocator
argument_list|,
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_limit
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|,
name|action
argument_list|)
decl_stmt|;
comment|// Update the number of unprocessed bytes left in
comment|// this Subblock. This assert() is true because
comment|// in_limit prevents *in_pos getting too big.
name|assert
argument_list|(
operator|*
name|in_pos
operator|-
name|in_start
operator|<=
name|coder
operator|->
name|size
argument_list|)
expr_stmt|;
name|coder
operator|->
name|size
operator|-=
operator|*
name|in_pos
operator|-
name|in_start
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|LZMA_STREAM_END
condition|)
block|{
comment|// End of Subfilter can occur only at
comment|// a Subblock boundary.
if|if
condition|(
name|coder
operator|->
name|size
operator|!=
literal|0
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
comment|// We need a Subblock with Unset
comment|// Subfilter before more data.
name|coder
operator|->
name|sequence
operator|=
name|SEQ_FILTER_END
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
return|return
name|ret
return|;
block|}
comment|// If we couldn't process the whole Subblock Data yet, return.
if|if
condition|(
name|coder
operator|->
name|size
operator|>
literal|0
condition|)
return|return
name|LZMA_OK
return|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_FLAGS
expr_stmt|;
break|break;
block|}
case|case
name|SEQ_REPEAT_FAST
case|:
block|{
comment|// Optimization for cases when there is only one byte to
comment|// repeat and no Subfilter.
specifier|const
name|size_t
name|out_avail
init|=
name|out_size
operator|-
operator|*
name|out_pos
decl_stmt|;
specifier|const
name|size_t
name|copy_size
init|=
name|MIN
argument_list|(
name|coder
operator|->
name|repeat
operator|.
name|count
argument_list|,
name|out_avail
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|out
operator|+
operator|*
name|out_pos
argument_list|,
name|coder
operator|->
name|repeat
operator|.
name|buffer
index|[
literal|0
index|]
argument_list|,
name|copy_size
argument_list|)
expr_stmt|;
operator|*
name|out_pos
operator|+=
name|copy_size
expr_stmt|;
name|coder
operator|->
name|repeat
operator|.
name|count
operator|-=
name|copy_size
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|repeat
operator|.
name|count
operator|!=
literal|0
condition|)
return|return
name|LZMA_OK
return|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_FLAGS
expr_stmt|;
break|break;
block|}
case|case
name|SEQ_REPEAT_NORMAL
case|:
do|do
block|{
comment|// Cycle the repeat buffer if needed.
if|if
condition|(
name|coder
operator|->
name|repeat
operator|.
name|pos
operator|==
name|coder
operator|->
name|repeat
operator|.
name|size
condition|)
block|{
if|if
condition|(
operator|--
name|coder
operator|->
name|repeat
operator|.
name|count
operator|==
literal|0
condition|)
block|{
name|coder
operator|->
name|sequence
operator|=
name|SEQ_FLAGS
expr_stmt|;
break|break;
block|}
name|coder
operator|->
name|repeat
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|coder
operator|->
name|subfilter
operator|.
name|code
operator|==
name|NULL
condition|)
block|{
name|lzma_bufcpy
argument_list|(
name|coder
operator|->
name|repeat
operator|.
name|buffer
argument_list|,
operator|&
name|coder
operator|->
name|repeat
operator|.
name|pos
argument_list|,
name|coder
operator|->
name|repeat
operator|.
name|size
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|lzma_ret
name|ret
init|=
name|subfilter_decode
argument_list|(
name|coder
argument_list|,
name|allocator
argument_list|,
name|coder
operator|->
name|repeat
operator|.
name|buffer
argument_list|,
operator|&
name|coder
operator|->
name|repeat
operator|.
name|pos
argument_list|,
name|coder
operator|->
name|repeat
operator|.
name|size
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|,
name|action
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
name|LZMA_STREAM_END
condition|)
block|{
comment|// End of Subfilter can occur only at
comment|// a Subblock boundary.
if|if
condition|(
name|coder
operator|->
name|repeat
operator|.
name|pos
operator|!=
name|coder
operator|->
name|repeat
operator|.
name|size
operator|||
operator|--
name|coder
operator|->
name|repeat
operator|.
name|count
operator|!=
literal|0
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
comment|// We need a Subblock with Unset
comment|// Subfilter before more data.
name|coder
operator|->
name|sequence
operator|=
name|SEQ_FILTER_END
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
return|return
name|ret
return|;
block|}
block|}
block|}
do|while
condition|(
operator|*
name|out_pos
operator|<
name|out_size
condition|)
do|;
break|break;
default|default:
return|return
name|LZMA_PROG_ERROR
return|;
block|}
return|return
name|LZMA_OK
return|;
block|}
end_function

begin_function
specifier|static
name|lzma_ret
name|subblock_decode
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|uint8_t
modifier|*
specifier|restrict
name|in
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|in_pos
parameter_list|,
name|size_t
name|in_size
parameter_list|,
name|uint8_t
modifier|*
specifier|restrict
name|out
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|out_pos
parameter_list|,
name|size_t
name|out_size
parameter_list|,
name|lzma_action
name|action
parameter_list|)
block|{
if|if
condition|(
name|coder
operator|->
name|next
operator|.
name|code
operator|==
name|NULL
condition|)
return|return
name|decode_buffer
argument_list|(
name|coder
argument_list|,
name|allocator
argument_list|,
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|,
name|action
argument_list|)
return|;
while|while
condition|(
operator|*
name|out_pos
operator|<
name|out_size
condition|)
block|{
if|if
condition|(
operator|!
name|coder
operator|->
name|next_finished
operator|&&
name|coder
operator|->
name|temp
operator|.
name|pos
operator|==
name|coder
operator|->
name|temp
operator|.
name|size
condition|)
block|{
name|coder
operator|->
name|temp
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|temp
operator|.
name|size
operator|=
literal|0
expr_stmt|;
specifier|const
name|lzma_ret
name|ret
init|=
name|coder
operator|->
name|next
operator|.
name|code
argument_list|(
name|coder
operator|->
name|next
operator|.
name|coder
argument_list|,
name|allocator
argument_list|,
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|,
name|coder
operator|->
name|temp
operator|.
name|buffer
argument_list|,
operator|&
name|coder
operator|->
name|temp
operator|.
name|size
argument_list|,
name|LZMA_BUFFER_SIZE
argument_list|,
name|action
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
name|LZMA_STREAM_END
condition|)
name|coder
operator|->
name|next_finished
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|coder
operator|->
name|temp
operator|.
name|size
operator|==
literal|0
operator|||
name|ret
operator|!=
name|LZMA_OK
condition|)
return|return
name|ret
return|;
block|}
if|if
condition|(
name|coder
operator|->
name|this_finished
condition|)
block|{
if|if
condition|(
name|coder
operator|->
name|temp
operator|.
name|pos
operator|!=
name|coder
operator|->
name|temp
operator|.
name|size
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
if|if
condition|(
name|coder
operator|->
name|next_finished
condition|)
return|return
name|LZMA_STREAM_END
return|;
return|return
name|LZMA_OK
return|;
block|}
specifier|const
name|lzma_ret
name|ret
init|=
name|decode_buffer
argument_list|(
name|coder
argument_list|,
name|allocator
argument_list|,
name|coder
operator|->
name|temp
operator|.
name|buffer
argument_list|,
operator|&
name|coder
operator|->
name|temp
operator|.
name|pos
argument_list|,
name|coder
operator|->
name|temp
operator|.
name|size
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|,
name|action
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
name|LZMA_STREAM_END
condition|)
comment|// The next coder in the chain hasn't finished
comment|// yet. If the input data is valid, there
comment|// must be no more output coming, but the
comment|// next coder may still need a litle more
comment|// input to detect End of Payload Marker.
name|coder
operator|->
name|this_finished
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
return|return
name|ret
return|;
elseif|else
if|if
condition|(
name|coder
operator|->
name|next_finished
operator|&&
operator|*
name|out_pos
operator|<
name|out_size
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
block|}
return|return
name|LZMA_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|subblock_decoder_end
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|)
block|{
name|lzma_next_end
argument_list|(
operator|&
name|coder
operator|->
name|next
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|lzma_next_end
argument_list|(
operator|&
name|coder
operator|->
name|subfilter
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|lzma_next_end
argument_list|(
operator|&
name|coder
operator|->
name|filter_flags_decoder
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|lzma_free
argument_list|(
name|coder
operator|->
name|filter_flags
operator|.
name|options
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|lzma_free
argument_list|(
name|coder
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|extern
name|lzma_ret
name|lzma_subblock_decoder_init
parameter_list|(
name|lzma_next_coder
modifier|*
name|next
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|lzma_filter_info
modifier|*
name|filters
parameter_list|)
block|{
if|if
condition|(
name|next
operator|->
name|coder
operator|==
name|NULL
condition|)
block|{
name|next
operator|->
name|coder
operator|=
name|lzma_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lzma_coder
argument_list|)
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|coder
operator|==
name|NULL
condition|)
return|return
name|LZMA_MEM_ERROR
return|;
name|next
operator|->
name|code
operator|=
operator|&
name|subblock_decode
expr_stmt|;
name|next
operator|->
name|end
operator|=
operator|&
name|subblock_decoder_end
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|next
operator|=
name|LZMA_NEXT_CODER_INIT
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|subfilter
operator|=
name|LZMA_NEXT_CODER_INIT
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|filter_flags_decoder
operator|=
name|LZMA_NEXT_CODER_INIT
expr_stmt|;
block|}
else|else
block|{
name|lzma_next_end
argument_list|(
operator|&
name|next
operator|->
name|coder
operator|->
name|subfilter
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|lzma_free
argument_list|(
name|next
operator|->
name|coder
operator|->
name|filter_flags
operator|.
name|options
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
block|}
name|next
operator|->
name|coder
operator|->
name|filter_flags
operator|.
name|options
operator|=
name|NULL
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|sequence
operator|=
name|SEQ_FLAGS
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|padding
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|next_finished
operator|=
name|false
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|this_finished
operator|=
name|false
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|temp
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|temp
operator|.
name|size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|filters
index|[
literal|0
index|]
operator|.
name|options
operator|!=
name|NULL
condition|)
name|next
operator|->
name|coder
operator|->
name|allow_subfilters
operator|=
operator|(
operator|(
name|lzma_options_subblock
operator|*
operator|)
operator|(
name|filters
index|[
literal|0
index|]
operator|.
name|options
operator|)
operator|)
operator|->
name|allow_subfilters
expr_stmt|;
else|else
name|next
operator|->
name|coder
operator|->
name|allow_subfilters
operator|=
name|false
expr_stmt|;
return|return
name|lzma_next_filter_init
argument_list|(
operator|&
name|next
operator|->
name|coder
operator|->
name|next
argument_list|,
name|allocator
argument_list|,
name|filters
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

end_unit

