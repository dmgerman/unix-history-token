begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|JEMALLOC_INTERNAL_RTREE_H
end_ifndef

begin_define
define|#
directive|define
name|JEMALLOC_INTERNAL_RTREE_H
end_define

begin_include
include|#
directive|include
file|"jemalloc/internal/atomic.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/mutex.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/rtree_tsd.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/size_classes.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/tsd.h"
end_include

begin_comment
comment|/*  * This radix tree implementation is tailored to the singular purpose of  * associating metadata with extents that are currently owned by jemalloc.  *  *******************************************************************************  */
end_comment

begin_comment
comment|/* Number of high insignificant bits. */
end_comment

begin_define
define|#
directive|define
name|RTREE_NHIB
value|((1U<< (LG_SIZEOF_PTR+3)) - LG_VADDR)
end_define

begin_comment
comment|/* Number of low insigificant bits. */
end_comment

begin_define
define|#
directive|define
name|RTREE_NLIB
value|LG_PAGE
end_define

begin_comment
comment|/* Number of significant bits. */
end_comment

begin_define
define|#
directive|define
name|RTREE_NSB
value|(LG_VADDR - RTREE_NLIB)
end_define

begin_comment
comment|/* Number of levels in radix tree. */
end_comment

begin_if
if|#
directive|if
name|RTREE_NSB
operator|<=
literal|10
end_if

begin_define
define|#
directive|define
name|RTREE_HEIGHT
value|1
end_define

begin_elif
elif|#
directive|elif
name|RTREE_NSB
operator|<=
literal|36
end_elif

begin_define
define|#
directive|define
name|RTREE_HEIGHT
value|2
end_define

begin_elif
elif|#
directive|elif
name|RTREE_NSB
operator|<=
literal|52
end_elif

begin_define
define|#
directive|define
name|RTREE_HEIGHT
value|3
end_define

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
error|Unsupported number of significant virtual address bits
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Use compact leaf representation if virtual address encoding allows. */
end_comment

begin_if
if|#
directive|if
name|RTREE_NHIB
operator|>=
name|LG_CEIL_NSIZES
end_if

begin_define
define|#
directive|define
name|RTREE_LEAF_COMPACT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Needed for initialization only. */
end_comment

begin_define
define|#
directive|define
name|RTREE_LEAFKEY_INVALID
value|((uintptr_t)1)
end_define

begin_typedef
typedef|typedef
name|struct
name|rtree_node_elm_s
name|rtree_node_elm_t
typedef|;
end_typedef

begin_struct
struct|struct
name|rtree_node_elm_s
block|{
name|atomic_p_t
name|child
decl_stmt|;
comment|/* (rtree_{node,leaf}_elm_t *) */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|rtree_leaf_elm_s
block|{
ifdef|#
directive|ifdef
name|RTREE_LEAF_COMPACT
comment|/* 	 * Single pointer-width field containing all three leaf element fields. 	 * For example, on a 64-bit x64 system with 48 significant virtual 	 * memory address bits, the index, extent, and slab fields are packed as 	 * such: 	 * 	 * x: index 	 * e: extent 	 * b: slab 	 * 	 *   00000000 xxxxxxxx eeeeeeee [...] eeeeeeee eeee000b 	 */
name|atomic_p_t
name|le_bits
decl_stmt|;
else|#
directive|else
name|atomic_p_t
name|le_extent
decl_stmt|;
comment|/* (extent_t *) */
name|atomic_u_t
name|le_szind
decl_stmt|;
comment|/* (szind_t) */
name|atomic_b_t
name|le_slab
decl_stmt|;
comment|/* (bool) */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|rtree_level_s
name|rtree_level_t
typedef|;
end_typedef

begin_struct
struct|struct
name|rtree_level_s
block|{
comment|/* Number of key bits distinguished by this level. */
name|unsigned
name|bits
decl_stmt|;
comment|/* 	 * Cumulative number of key bits distinguished by traversing to 	 * corresponding tree level. 	 */
name|unsigned
name|cumbits
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|rtree_s
name|rtree_t
typedef|;
end_typedef

begin_struct
struct|struct
name|rtree_s
block|{
name|malloc_mutex_t
name|init_lock
decl_stmt|;
comment|/* Number of elements based on rtree_levels[0].bits. */
if|#
directive|if
name|RTREE_HEIGHT
operator|>
literal|1
name|rtree_node_elm_t
name|root
index|[
literal|1U
operator|<<
operator|(
name|RTREE_NSB
operator|/
name|RTREE_HEIGHT
operator|)
index|]
decl_stmt|;
else|#
directive|else
name|rtree_leaf_elm_t
name|root
index|[
literal|1U
operator|<<
operator|(
name|RTREE_NSB
operator|/
name|RTREE_HEIGHT
operator|)
index|]
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/*  * Split the bits into one to three partitions depending on number of  * significant bits.  It the number of bits does not divide evenly into the  * number of levels, place one remainder bit per level starting at the leaf  * level.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|rtree_level_t
name|rtree_levels
index|[]
init|=
block|{
if|#
directive|if
name|RTREE_HEIGHT
operator|==
literal|1
block|{
name|RTREE_NSB
block|,
name|RTREE_NHIB
operator|+
name|RTREE_NSB
block|}
elif|#
directive|elif
name|RTREE_HEIGHT
operator|==
literal|2
block|{
name|RTREE_NSB
operator|/
literal|2
block|,
name|RTREE_NHIB
operator|+
name|RTREE_NSB
operator|/
literal|2
block|}
block|,
block|{
name|RTREE_NSB
operator|/
literal|2
operator|+
name|RTREE_NSB
operator|%
literal|2
block|,
name|RTREE_NHIB
operator|+
name|RTREE_NSB
block|}
elif|#
directive|elif
name|RTREE_HEIGHT
operator|==
literal|3
block|{
name|RTREE_NSB
operator|/
literal|3
block|,
name|RTREE_NHIB
operator|+
name|RTREE_NSB
operator|/
literal|3
block|}
block|,
block|{
name|RTREE_NSB
operator|/
literal|3
operator|+
name|RTREE_NSB
operator|%
literal|3
operator|/
literal|2
block|,
name|RTREE_NHIB
operator|+
name|RTREE_NSB
operator|/
literal|3
operator|*
literal|2
operator|+
name|RTREE_NSB
operator|%
literal|3
operator|/
literal|2
block|}
block|,
block|{
name|RTREE_NSB
operator|/
literal|3
operator|+
name|RTREE_NSB
operator|%
literal|3
operator|-
name|RTREE_NSB
operator|%
literal|3
operator|/
literal|2
block|,
name|RTREE_NHIB
operator|+
name|RTREE_NSB
block|}
else|#
directive|else
error|#
directive|error
error|Unsupported rtree height
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|bool
name|rtree_new
parameter_list|(
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|bool
name|zeroed
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
name|rtree_node_elm_t
modifier|*
function_decl|(
name|rtree_node_alloc_t
function_decl|)
parameter_list|(
name|tsdn_t
modifier|*
parameter_list|,
name|rtree_t
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|extern
name|rtree_node_alloc_t
modifier|*
name|JET_MUTABLE
name|rtree_node_alloc
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|rtree_leaf_elm_t
modifier|*
function_decl|(
name|rtree_leaf_alloc_t
function_decl|)
parameter_list|(
name|tsdn_t
modifier|*
parameter_list|,
name|rtree_t
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|extern
name|rtree_leaf_alloc_t
modifier|*
name|JET_MUTABLE
name|rtree_leaf_alloc
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|void
function_decl|(
name|rtree_node_dalloc_t
function_decl|)
parameter_list|(
name|tsdn_t
modifier|*
parameter_list|,
name|rtree_t
modifier|*
parameter_list|,
name|rtree_node_elm_t
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|extern
name|rtree_node_dalloc_t
modifier|*
name|JET_MUTABLE
name|rtree_node_dalloc
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|void
function_decl|(
name|rtree_leaf_dalloc_t
function_decl|)
parameter_list|(
name|tsdn_t
modifier|*
parameter_list|,
name|rtree_t
modifier|*
parameter_list|,
name|rtree_leaf_elm_t
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|extern
name|rtree_leaf_dalloc_t
modifier|*
name|JET_MUTABLE
name|rtree_leaf_dalloc
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_JET
end_ifdef

begin_function_decl
name|void
name|rtree_delete
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|rtree_leaf_elm_t
modifier|*
name|rtree_leaf_elm_lookup_hard
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_ctx_t
modifier|*
name|rtree_ctx
parameter_list|,
name|uintptr_t
name|key
parameter_list|,
name|bool
name|dependent
parameter_list|,
name|bool
name|init_missing
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|uintptr_t
name|rtree_leafkey
parameter_list|(
name|uintptr_t
name|key
parameter_list|)
block|{
name|unsigned
name|ptrbits
init|=
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
operator|(
name|LG_SIZEOF_PTR
operator|+
literal|3
operator|)
decl_stmt|;
name|unsigned
name|cumbits
init|=
operator|(
name|rtree_levels
index|[
name|RTREE_HEIGHT
operator|-
literal|1
index|]
operator|.
name|cumbits
operator|-
name|rtree_levels
index|[
name|RTREE_HEIGHT
operator|-
literal|1
index|]
operator|.
name|bits
operator|)
decl_stmt|;
name|unsigned
name|maskbits
init|=
name|ptrbits
operator|-
name|cumbits
decl_stmt|;
name|uintptr_t
name|mask
init|=
operator|~
operator|(
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
name|maskbits
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
return|return
operator|(
name|key
operator|&
name|mask
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|size_t
name|rtree_cache_direct_map
parameter_list|(
name|uintptr_t
name|key
parameter_list|)
block|{
name|unsigned
name|ptrbits
init|=
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
operator|(
name|LG_SIZEOF_PTR
operator|+
literal|3
operator|)
decl_stmt|;
name|unsigned
name|cumbits
init|=
operator|(
name|rtree_levels
index|[
name|RTREE_HEIGHT
operator|-
literal|1
index|]
operator|.
name|cumbits
operator|-
name|rtree_levels
index|[
name|RTREE_HEIGHT
operator|-
literal|1
index|]
operator|.
name|bits
operator|)
decl_stmt|;
name|unsigned
name|maskbits
init|=
name|ptrbits
operator|-
name|cumbits
decl_stmt|;
return|return
call|(
name|size_t
call|)
argument_list|(
operator|(
name|key
operator|>>
name|maskbits
operator|)
operator|&
operator|(
name|RTREE_CTX_NCACHE
operator|-
literal|1
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|uintptr_t
name|rtree_subkey
parameter_list|(
name|uintptr_t
name|key
parameter_list|,
name|unsigned
name|level
parameter_list|)
block|{
name|unsigned
name|ptrbits
init|=
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
operator|(
name|LG_SIZEOF_PTR
operator|+
literal|3
operator|)
decl_stmt|;
name|unsigned
name|cumbits
init|=
name|rtree_levels
index|[
name|level
index|]
operator|.
name|cumbits
decl_stmt|;
name|unsigned
name|shiftbits
init|=
name|ptrbits
operator|-
name|cumbits
decl_stmt|;
name|unsigned
name|maskbits
init|=
name|rtree_levels
index|[
name|level
index|]
operator|.
name|bits
decl_stmt|;
name|uintptr_t
name|mask
init|=
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
name|maskbits
operator|)
operator|-
literal|1
decl_stmt|;
return|return
operator|(
operator|(
name|key
operator|>>
name|shiftbits
operator|)
operator|&
name|mask
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Atomic getters.  *  * dependent: Reading a value on behalf of a pointer to a valid allocation  *            is guaranteed to be a clean read even without synchronization,  *            because the rtree update became visible in memory before the  *            pointer came into existence.  * !dependent: An arbitrary read, e.g. on behalf of ivsalloc(), may not be  *             dependent on a previous rtree write, which means a stale read  *             could result if synchronization were omitted here.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RTREE_LEAF_COMPACT
end_ifdef

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|uintptr_t
name|rtree_leaf_elm_bits_read
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_leaf_elm_t
modifier|*
name|elm
parameter_list|,
name|bool
name|dependent
parameter_list|)
block|{
return|return
operator|(
name|uintptr_t
operator|)
name|atomic_load_p
argument_list|(
operator|&
name|elm
operator|->
name|le_bits
argument_list|,
name|dependent
condition|?
name|ATOMIC_RELAXED
else|:
name|ATOMIC_ACQUIRE
argument_list|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|extent_t
modifier|*
name|rtree_leaf_elm_bits_extent_get
parameter_list|(
name|uintptr_t
name|bits
parameter_list|)
block|{
comment|/* Restore sign-extended high bits, mask slab bit. */
return|return
operator|(
name|extent_t
operator|*
operator|)
operator|(
call|(
name|uintptr_t
call|)
argument_list|(
call|(
name|intptr_t
call|)
argument_list|(
name|bits
operator|<<
name|RTREE_NHIB
argument_list|)
operator|>>
name|RTREE_NHIB
argument_list|)
operator|&
operator|~
operator|(
operator|(
name|uintptr_t
operator|)
literal|0x1
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|szind_t
name|rtree_leaf_elm_bits_szind_get
parameter_list|(
name|uintptr_t
name|bits
parameter_list|)
block|{
return|return
call|(
name|szind_t
call|)
argument_list|(
name|bits
operator|>>
name|LG_VADDR
argument_list|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|bool
name|rtree_leaf_elm_bits_slab_get
parameter_list|(
name|uintptr_t
name|bits
parameter_list|)
block|{
return|return
call|(
name|bool
call|)
argument_list|(
name|bits
operator|&
operator|(
name|uintptr_t
operator|)
literal|0x1
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|extent_t
modifier|*
name|rtree_leaf_elm_extent_read
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_leaf_elm_t
modifier|*
name|elm
parameter_list|,
name|bool
name|dependent
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|RTREE_LEAF_COMPACT
name|uintptr_t
name|bits
init|=
name|rtree_leaf_elm_bits_read
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|elm
argument_list|,
name|dependent
argument_list|)
decl_stmt|;
return|return
name|rtree_leaf_elm_bits_extent_get
argument_list|(
name|bits
argument_list|)
return|;
else|#
directive|else
name|extent_t
modifier|*
name|extent
init|=
operator|(
name|extent_t
operator|*
operator|)
name|atomic_load_p
argument_list|(
operator|&
name|elm
operator|->
name|le_extent
argument_list|,
name|dependent
condition|?
name|ATOMIC_RELAXED
else|:
name|ATOMIC_ACQUIRE
argument_list|)
decl_stmt|;
return|return
name|extent
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|szind_t
name|rtree_leaf_elm_szind_read
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_leaf_elm_t
modifier|*
name|elm
parameter_list|,
name|bool
name|dependent
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|RTREE_LEAF_COMPACT
name|uintptr_t
name|bits
init|=
name|rtree_leaf_elm_bits_read
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|elm
argument_list|,
name|dependent
argument_list|)
decl_stmt|;
return|return
name|rtree_leaf_elm_bits_szind_get
argument_list|(
name|bits
argument_list|)
return|;
else|#
directive|else
return|return
operator|(
name|szind_t
operator|)
name|atomic_load_u
argument_list|(
operator|&
name|elm
operator|->
name|le_szind
argument_list|,
name|dependent
condition|?
name|ATOMIC_RELAXED
else|:
name|ATOMIC_ACQUIRE
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|bool
name|rtree_leaf_elm_slab_read
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_leaf_elm_t
modifier|*
name|elm
parameter_list|,
name|bool
name|dependent
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|RTREE_LEAF_COMPACT
name|uintptr_t
name|bits
init|=
name|rtree_leaf_elm_bits_read
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|elm
argument_list|,
name|dependent
argument_list|)
decl_stmt|;
return|return
name|rtree_leaf_elm_bits_slab_get
argument_list|(
name|bits
argument_list|)
return|;
else|#
directive|else
return|return
name|atomic_load_b
argument_list|(
operator|&
name|elm
operator|->
name|le_slab
argument_list|,
name|dependent
condition|?
name|ATOMIC_RELAXED
else|:
name|ATOMIC_ACQUIRE
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|rtree_leaf_elm_extent_write
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_leaf_elm_t
modifier|*
name|elm
parameter_list|,
name|extent_t
modifier|*
name|extent
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|RTREE_LEAF_COMPACT
name|uintptr_t
name|old_bits
init|=
name|rtree_leaf_elm_bits_read
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|elm
argument_list|,
name|true
argument_list|)
decl_stmt|;
name|uintptr_t
name|bits
init|=
operator|(
operator|(
name|uintptr_t
operator|)
name|rtree_leaf_elm_bits_szind_get
argument_list|(
name|old_bits
argument_list|)
operator|<<
name|LG_VADDR
operator|)
operator||
operator|(
operator|(
name|uintptr_t
operator|)
name|extent
operator|&
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
literal|0x1
operator|<<
name|LG_VADDR
operator|)
operator|-
literal|1
operator|)
operator|)
operator||
operator|(
operator|(
name|uintptr_t
operator|)
name|rtree_leaf_elm_bits_slab_get
argument_list|(
name|old_bits
argument_list|)
operator|)
decl_stmt|;
name|atomic_store_p
argument_list|(
operator|&
name|elm
operator|->
name|le_bits
argument_list|,
operator|(
name|void
operator|*
operator|)
name|bits
argument_list|,
name|ATOMIC_RELEASE
argument_list|)
expr_stmt|;
else|#
directive|else
name|atomic_store_p
argument_list|(
operator|&
name|elm
operator|->
name|le_extent
argument_list|,
name|extent
argument_list|,
name|ATOMIC_RELEASE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|rtree_leaf_elm_szind_write
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_leaf_elm_t
modifier|*
name|elm
parameter_list|,
name|szind_t
name|szind
parameter_list|)
block|{
name|assert
argument_list|(
name|szind
operator|<=
name|NSIZES
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RTREE_LEAF_COMPACT
name|uintptr_t
name|old_bits
init|=
name|rtree_leaf_elm_bits_read
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|elm
argument_list|,
name|true
argument_list|)
decl_stmt|;
name|uintptr_t
name|bits
init|=
operator|(
operator|(
name|uintptr_t
operator|)
name|szind
operator|<<
name|LG_VADDR
operator|)
operator||
operator|(
operator|(
name|uintptr_t
operator|)
name|rtree_leaf_elm_bits_extent_get
argument_list|(
name|old_bits
argument_list|)
operator|&
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
literal|0x1
operator|<<
name|LG_VADDR
operator|)
operator|-
literal|1
operator|)
operator|)
operator||
operator|(
operator|(
name|uintptr_t
operator|)
name|rtree_leaf_elm_bits_slab_get
argument_list|(
name|old_bits
argument_list|)
operator|)
decl_stmt|;
name|atomic_store_p
argument_list|(
operator|&
name|elm
operator|->
name|le_bits
argument_list|,
operator|(
name|void
operator|*
operator|)
name|bits
argument_list|,
name|ATOMIC_RELEASE
argument_list|)
expr_stmt|;
else|#
directive|else
name|atomic_store_u
argument_list|(
operator|&
name|elm
operator|->
name|le_szind
argument_list|,
name|szind
argument_list|,
name|ATOMIC_RELEASE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|rtree_leaf_elm_slab_write
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_leaf_elm_t
modifier|*
name|elm
parameter_list|,
name|bool
name|slab
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|RTREE_LEAF_COMPACT
name|uintptr_t
name|old_bits
init|=
name|rtree_leaf_elm_bits_read
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|elm
argument_list|,
name|true
argument_list|)
decl_stmt|;
name|uintptr_t
name|bits
init|=
operator|(
operator|(
name|uintptr_t
operator|)
name|rtree_leaf_elm_bits_szind_get
argument_list|(
name|old_bits
argument_list|)
operator|<<
name|LG_VADDR
operator|)
operator||
operator|(
operator|(
name|uintptr_t
operator|)
name|rtree_leaf_elm_bits_extent_get
argument_list|(
name|old_bits
argument_list|)
operator|&
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
literal|0x1
operator|<<
name|LG_VADDR
operator|)
operator|-
literal|1
operator|)
operator|)
operator||
operator|(
operator|(
name|uintptr_t
operator|)
name|slab
operator|)
decl_stmt|;
name|atomic_store_p
argument_list|(
operator|&
name|elm
operator|->
name|le_bits
argument_list|,
operator|(
name|void
operator|*
operator|)
name|bits
argument_list|,
name|ATOMIC_RELEASE
argument_list|)
expr_stmt|;
else|#
directive|else
name|atomic_store_b
argument_list|(
operator|&
name|elm
operator|->
name|le_slab
argument_list|,
name|slab
argument_list|,
name|ATOMIC_RELEASE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|rtree_leaf_elm_write
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_leaf_elm_t
modifier|*
name|elm
parameter_list|,
name|extent_t
modifier|*
name|extent
parameter_list|,
name|szind_t
name|szind
parameter_list|,
name|bool
name|slab
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|RTREE_LEAF_COMPACT
name|uintptr_t
name|bits
init|=
operator|(
operator|(
name|uintptr_t
operator|)
name|szind
operator|<<
name|LG_VADDR
operator|)
operator||
operator|(
operator|(
name|uintptr_t
operator|)
name|extent
operator|&
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
literal|0x1
operator|<<
name|LG_VADDR
operator|)
operator|-
literal|1
operator|)
operator|)
operator||
operator|(
operator|(
name|uintptr_t
operator|)
name|slab
operator|)
decl_stmt|;
name|atomic_store_p
argument_list|(
operator|&
name|elm
operator|->
name|le_bits
argument_list|,
operator|(
name|void
operator|*
operator|)
name|bits
argument_list|,
name|ATOMIC_RELEASE
argument_list|)
expr_stmt|;
else|#
directive|else
name|rtree_leaf_elm_slab_write
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|elm
argument_list|,
name|slab
argument_list|)
expr_stmt|;
name|rtree_leaf_elm_szind_write
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|elm
argument_list|,
name|szind
argument_list|)
expr_stmt|;
comment|/* 	 * Write extent last, since the element is atomically considered valid 	 * as soon as the extent field is non-NULL. 	 */
name|rtree_leaf_elm_extent_write
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|elm
argument_list|,
name|extent
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|rtree_leaf_elm_szind_slab_update
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_leaf_elm_t
modifier|*
name|elm
parameter_list|,
name|szind_t
name|szind
parameter_list|,
name|bool
name|slab
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|slab
operator|||
name|szind
operator|<
name|NBINS
argument_list|)
expr_stmt|;
comment|/* 	 * The caller implicitly assures that it is the only writer to the szind 	 * and slab fields, and that the extent field cannot currently change. 	 */
name|rtree_leaf_elm_slab_write
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|elm
argument_list|,
name|slab
argument_list|)
expr_stmt|;
name|rtree_leaf_elm_szind_write
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|elm
argument_list|,
name|szind
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|rtree_leaf_elm_t
modifier|*
name|rtree_leaf_elm_lookup
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_ctx_t
modifier|*
name|rtree_ctx
parameter_list|,
name|uintptr_t
name|key
parameter_list|,
name|bool
name|dependent
parameter_list|,
name|bool
name|init_missing
parameter_list|)
block|{
name|assert
argument_list|(
name|key
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|dependent
operator|||
operator|!
name|init_missing
argument_list|)
expr_stmt|;
name|size_t
name|slot
init|=
name|rtree_cache_direct_map
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|uintptr_t
name|leafkey
init|=
name|rtree_leafkey
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|leafkey
operator|!=
name|RTREE_LEAFKEY_INVALID
argument_list|)
expr_stmt|;
comment|/* Fast path: L1 direct mapped cache. */
if|if
condition|(
name|likely
argument_list|(
name|rtree_ctx
operator|->
name|cache
index|[
name|slot
index|]
operator|.
name|leafkey
operator|==
name|leafkey
argument_list|)
condition|)
block|{
name|rtree_leaf_elm_t
modifier|*
name|leaf
init|=
name|rtree_ctx
operator|->
name|cache
index|[
name|slot
index|]
operator|.
name|leaf
decl_stmt|;
name|assert
argument_list|(
name|leaf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|uintptr_t
name|subkey
init|=
name|rtree_subkey
argument_list|(
name|key
argument_list|,
name|RTREE_HEIGHT
operator|-
literal|1
argument_list|)
decl_stmt|;
return|return
operator|&
name|leaf
index|[
name|subkey
index|]
return|;
block|}
comment|/* 	 * Search the L2 LRU cache.  On hit, swap the matching element into the 	 * slot in L1 cache, and move the position in L2 up by 1. 	 */
define|#
directive|define
name|RTREE_CACHE_CHECK_L2
parameter_list|(
name|i
parameter_list|)
value|do {					\ 	if (likely(rtree_ctx->l2_cache[i].leafkey == leafkey)) {	\ 		rtree_leaf_elm_t *leaf = rtree_ctx->l2_cache[i].leaf;	\ 		assert(leaf != NULL);					\ 		if (i> 0) {						\
comment|/* Bubble up by one. */
value|\ 			rtree_ctx->l2_cache[i].leafkey =		\ 				rtree_ctx->l2_cache[i - 1].leafkey;	\ 			rtree_ctx->l2_cache[i].leaf =			\ 				rtree_ctx->l2_cache[i - 1].leaf;	\ 			rtree_ctx->l2_cache[i - 1].leafkey =		\ 			    rtree_ctx->cache[slot].leafkey;		\ 			rtree_ctx->l2_cache[i - 1].leaf =		\ 			    rtree_ctx->cache[slot].leaf;		\ 		} else {						\ 			rtree_ctx->l2_cache[0].leafkey =		\ 			    rtree_ctx->cache[slot].leafkey;		\ 			rtree_ctx->l2_cache[0].leaf =			\ 			    rtree_ctx->cache[slot].leaf;		\ 		}							\ 		rtree_ctx->cache[slot].leafkey = leafkey;		\ 		rtree_ctx->cache[slot].leaf = leaf;			\ 		uintptr_t subkey = rtree_subkey(key, RTREE_HEIGHT-1);	\ 		return&leaf[subkey];					\ 	}								\ } while (0)
comment|/* Check the first cache entry. */
name|RTREE_CACHE_CHECK_L2
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Search the remaining cache elements. */
for|for
control|(
name|unsigned
name|i
init|=
literal|1
init|;
name|i
operator|<
name|RTREE_CTX_NCACHE_L2
condition|;
name|i
operator|++
control|)
block|{
name|RTREE_CACHE_CHECK_L2
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|RTREE_CACHE_CHECK_L2
return|return
name|rtree_leaf_elm_lookup_hard
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|rtree_ctx
argument_list|,
name|key
argument_list|,
name|dependent
argument_list|,
name|init_missing
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|rtree_write
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_ctx_t
modifier|*
name|rtree_ctx
parameter_list|,
name|uintptr_t
name|key
parameter_list|,
name|extent_t
modifier|*
name|extent
parameter_list|,
name|szind_t
name|szind
parameter_list|,
name|bool
name|slab
parameter_list|)
block|{
comment|/* Use rtree_clear() to set the extent to NULL. */
name|assert
argument_list|(
name|extent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rtree_leaf_elm_t
modifier|*
name|elm
init|=
name|rtree_leaf_elm_lookup
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|rtree_ctx
argument_list|,
name|key
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|elm
operator|==
name|NULL
condition|)
block|{
return|return
name|true
return|;
block|}
name|assert
argument_list|(
name|rtree_leaf_elm_extent_read
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|elm
argument_list|,
name|false
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|rtree_leaf_elm_write
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|elm
argument_list|,
name|extent
argument_list|,
name|szind
argument_list|,
name|slab
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|rtree_leaf_elm_t
modifier|*
name|rtree_read
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_ctx_t
modifier|*
name|rtree_ctx
parameter_list|,
name|uintptr_t
name|key
parameter_list|,
name|bool
name|dependent
parameter_list|)
block|{
name|rtree_leaf_elm_t
modifier|*
name|elm
init|=
name|rtree_leaf_elm_lookup
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|rtree_ctx
argument_list|,
name|key
argument_list|,
name|dependent
argument_list|,
name|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dependent
operator|&&
name|elm
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|assert
argument_list|(
name|elm
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|elm
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|extent_t
modifier|*
name|rtree_extent_read
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_ctx_t
modifier|*
name|rtree_ctx
parameter_list|,
name|uintptr_t
name|key
parameter_list|,
name|bool
name|dependent
parameter_list|)
block|{
name|rtree_leaf_elm_t
modifier|*
name|elm
init|=
name|rtree_read
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|rtree_ctx
argument_list|,
name|key
argument_list|,
name|dependent
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dependent
operator|&&
name|elm
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|rtree_leaf_elm_extent_read
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|elm
argument_list|,
name|dependent
argument_list|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|szind_t
name|rtree_szind_read
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_ctx_t
modifier|*
name|rtree_ctx
parameter_list|,
name|uintptr_t
name|key
parameter_list|,
name|bool
name|dependent
parameter_list|)
block|{
name|rtree_leaf_elm_t
modifier|*
name|elm
init|=
name|rtree_read
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|rtree_ctx
argument_list|,
name|key
argument_list|,
name|dependent
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dependent
operator|&&
name|elm
operator|==
name|NULL
condition|)
block|{
return|return
name|NSIZES
return|;
block|}
return|return
name|rtree_leaf_elm_szind_read
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|elm
argument_list|,
name|dependent
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * rtree_slab_read() is intentionally omitted because slab is always read in  * conjunction with szind, which makes rtree_szind_slab_read() a better choice.  */
end_comment

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|bool
name|rtree_extent_szind_read
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_ctx_t
modifier|*
name|rtree_ctx
parameter_list|,
name|uintptr_t
name|key
parameter_list|,
name|bool
name|dependent
parameter_list|,
name|extent_t
modifier|*
modifier|*
name|r_extent
parameter_list|,
name|szind_t
modifier|*
name|r_szind
parameter_list|)
block|{
name|rtree_leaf_elm_t
modifier|*
name|elm
init|=
name|rtree_read
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|rtree_ctx
argument_list|,
name|key
argument_list|,
name|dependent
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dependent
operator|&&
name|elm
operator|==
name|NULL
condition|)
block|{
return|return
name|true
return|;
block|}
operator|*
name|r_extent
operator|=
name|rtree_leaf_elm_extent_read
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|elm
argument_list|,
name|dependent
argument_list|)
expr_stmt|;
operator|*
name|r_szind
operator|=
name|rtree_leaf_elm_szind_read
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|elm
argument_list|,
name|dependent
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|bool
name|rtree_szind_slab_read
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_ctx_t
modifier|*
name|rtree_ctx
parameter_list|,
name|uintptr_t
name|key
parameter_list|,
name|bool
name|dependent
parameter_list|,
name|szind_t
modifier|*
name|r_szind
parameter_list|,
name|bool
modifier|*
name|r_slab
parameter_list|)
block|{
name|rtree_leaf_elm_t
modifier|*
name|elm
init|=
name|rtree_read
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|rtree_ctx
argument_list|,
name|key
argument_list|,
name|dependent
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dependent
operator|&&
name|elm
operator|==
name|NULL
condition|)
block|{
return|return
name|true
return|;
block|}
operator|*
name|r_szind
operator|=
name|rtree_leaf_elm_szind_read
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|elm
argument_list|,
name|dependent
argument_list|)
expr_stmt|;
operator|*
name|r_slab
operator|=
name|rtree_leaf_elm_slab_read
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|elm
argument_list|,
name|dependent
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|rtree_szind_slab_update
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_ctx_t
modifier|*
name|rtree_ctx
parameter_list|,
name|uintptr_t
name|key
parameter_list|,
name|szind_t
name|szind
parameter_list|,
name|bool
name|slab
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|slab
operator|||
name|szind
operator|<
name|NBINS
argument_list|)
expr_stmt|;
name|rtree_leaf_elm_t
modifier|*
name|elm
init|=
name|rtree_read
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|rtree_ctx
argument_list|,
name|key
argument_list|,
name|true
argument_list|)
decl_stmt|;
name|rtree_leaf_elm_szind_slab_update
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|elm
argument_list|,
name|szind
argument_list|,
name|slab
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|rtree_clear
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_ctx_t
modifier|*
name|rtree_ctx
parameter_list|,
name|uintptr_t
name|key
parameter_list|)
block|{
name|rtree_leaf_elm_t
modifier|*
name|elm
init|=
name|rtree_read
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|rtree_ctx
argument_list|,
name|key
argument_list|,
name|true
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|rtree_leaf_elm_extent_read
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|elm
argument_list|,
name|false
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rtree_leaf_elm_write
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|elm
argument_list|,
name|NULL
argument_list|,
name|NSIZES
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JEMALLOC_INTERNAL_RTREE_H */
end_comment

end_unit

