begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This radix tree implementation is tailored to the singular purpose of  * associating metadata with chunks that are currently owned by jemalloc.  *  *******************************************************************************  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_H_TYPES
end_ifdef

begin_typedef
typedef|typedef
name|struct
name|rtree_node_elm_s
name|rtree_node_elm_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|rtree_level_s
name|rtree_level_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|rtree_s
name|rtree_t
typedef|;
end_typedef

begin_comment
comment|/*  * RTREE_BITS_PER_LEVEL must be a power of two that is no larger than the  * machine address width.  */
end_comment

begin_define
define|#
directive|define
name|LG_RTREE_BITS_PER_LEVEL
value|4
end_define

begin_define
define|#
directive|define
name|RTREE_BITS_PER_LEVEL
value|(ZU(1)<< LG_RTREE_BITS_PER_LEVEL)
end_define

begin_define
define|#
directive|define
name|RTREE_HEIGHT_MAX
define|\
value|((ZU(1)<< (LG_SIZEOF_PTR+3)) / RTREE_BITS_PER_LEVEL)
end_define

begin_comment
comment|/* Used for two-stage lock-free node initialization. */
end_comment

begin_define
define|#
directive|define
name|RTREE_NODE_INITIALIZING
value|((rtree_node_elm_t *)0x1)
end_define

begin_comment
comment|/*  * The node allocation callback function's argument is the number of contiguous  * rtree_node_elm_t structures to allocate, and the resulting memory must be  * zeroed.  */
end_comment

begin_typedef
typedef|typedef
name|rtree_node_elm_t
modifier|*
function_decl|(
name|rtree_node_alloc_t
function_decl|)
parameter_list|(
name|size_t
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|void
function_decl|(
name|rtree_node_dalloc_t
function_decl|)
parameter_list|(
name|rtree_node_elm_t
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JEMALLOC_H_TYPES */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_H_STRUCTS
end_ifdef

begin_struct
struct|struct
name|rtree_node_elm_s
block|{
union|union
block|{
name|void
modifier|*
name|pun
decl_stmt|;
name|rtree_node_elm_t
modifier|*
name|child
decl_stmt|;
name|extent_node_t
modifier|*
name|val
decl_stmt|;
block|}
union|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|rtree_level_s
block|{
comment|/* 	 * A non-NULL subtree points to a subtree rooted along the hypothetical 	 * path to the leaf node corresponding to key 0.  Depending on what keys 	 * have been used to store to the tree, an arbitrary combination of 	 * subtree pointers may remain NULL. 	 * 	 * Suppose keys comprise 48 bits, and LG_RTREE_BITS_PER_LEVEL is 4. 	 * This results in a 3-level tree, and the leftmost leaf can be directly 	 * accessed via subtrees[2], the subtree prefixed by 0x0000 (excluding 	 * 0x00000000) can be accessed via subtrees[1], and the remainder of the 	 * tree can be accessed via subtrees[0]. 	 * 	 *   levels[0] : [<unused> | 0x0001******** | 0x0002******** | ...] 	 * 	 *   levels[1] : [<unused> | 0x00000001**** | 0x00000002**** | ... ] 	 * 	 *   levels[2] : [val(0x000000000000) | val(0x000000000001) | ...] 	 * 	 * This has practical implications on x64, which currently uses only the 	 * lower 47 bits of virtual address space in userland, thus leaving 	 * subtrees[0] unused and avoiding a level of tree traversal. 	 */
union|union
block|{
name|void
modifier|*
name|subtree_pun
decl_stmt|;
name|rtree_node_elm_t
modifier|*
name|subtree
decl_stmt|;
block|}
union|;
comment|/* Number of key bits distinguished by this level. */
name|unsigned
name|bits
decl_stmt|;
comment|/* 	 * Cumulative number of key bits distinguished by traversing to 	 * corresponding tree level. 	 */
name|unsigned
name|cumbits
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|rtree_s
block|{
name|rtree_node_alloc_t
modifier|*
name|alloc
decl_stmt|;
name|rtree_node_dalloc_t
modifier|*
name|dalloc
decl_stmt|;
name|unsigned
name|height
decl_stmt|;
comment|/* 	 * Precomputed table used to convert from the number of leading 0 key 	 * bits to which subtree level to start at. 	 */
name|unsigned
name|start_level
index|[
name|RTREE_HEIGHT_MAX
index|]
decl_stmt|;
name|rtree_level_t
name|levels
index|[
name|RTREE_HEIGHT_MAX
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JEMALLOC_H_STRUCTS */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_H_EXTERNS
end_ifdef

begin_function_decl
name|bool
name|rtree_new
parameter_list|(
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|unsigned
name|bits
parameter_list|,
name|rtree_node_alloc_t
modifier|*
name|alloc
parameter_list|,
name|rtree_node_dalloc_t
modifier|*
name|dalloc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|rtree_delete
parameter_list|(
name|rtree_t
modifier|*
name|rtree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|rtree_node_elm_t
modifier|*
name|rtree_subtree_read_hard
parameter_list|(
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|unsigned
name|level
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|rtree_node_elm_t
modifier|*
name|rtree_child_read_hard
parameter_list|(
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_node_elm_t
modifier|*
name|elm
parameter_list|,
name|unsigned
name|level
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JEMALLOC_H_EXTERNS */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_H_INLINES
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|JEMALLOC_ENABLE_INLINE
end_ifndef

begin_function_decl
name|unsigned
name|rtree_start_level
parameter_list|(
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|uintptr_t
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|uintptr_t
name|rtree_subkey
parameter_list|(
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|uintptr_t
name|key
parameter_list|,
name|unsigned
name|level
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|rtree_node_valid
parameter_list|(
name|rtree_node_elm_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|rtree_node_elm_t
modifier|*
name|rtree_child_tryread
parameter_list|(
name|rtree_node_elm_t
modifier|*
name|elm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|rtree_node_elm_t
modifier|*
name|rtree_child_read
parameter_list|(
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_node_elm_t
modifier|*
name|elm
parameter_list|,
name|unsigned
name|level
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|extent_node_t
modifier|*
name|rtree_val_read
parameter_list|(
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_node_elm_t
modifier|*
name|elm
parameter_list|,
name|bool
name|dependent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|rtree_val_write
parameter_list|(
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_node_elm_t
modifier|*
name|elm
parameter_list|,
specifier|const
name|extent_node_t
modifier|*
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|rtree_node_elm_t
modifier|*
name|rtree_subtree_tryread
parameter_list|(
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|unsigned
name|level
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|rtree_node_elm_t
modifier|*
name|rtree_subtree_read
parameter_list|(
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|unsigned
name|level
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|extent_node_t
modifier|*
name|rtree_get
parameter_list|(
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|uintptr_t
name|key
parameter_list|,
name|bool
name|dependent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|rtree_set
parameter_list|(
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|uintptr_t
name|key
parameter_list|,
specifier|const
name|extent_node_t
modifier|*
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|JEMALLOC_ENABLE_INLINE
argument_list|)
operator|||
name|defined
argument_list|(
name|JEMALLOC_RTREE_C_
argument_list|)
operator|)
end_if

begin_function
name|JEMALLOC_INLINE
name|unsigned
name|rtree_start_level
parameter_list|(
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|uintptr_t
name|key
parameter_list|)
block|{
name|unsigned
name|start_level
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|key
operator|==
literal|0
argument_list|)
condition|)
return|return
operator|(
name|rtree
operator|->
name|height
operator|-
literal|1
operator|)
return|;
name|start_level
operator|=
name|rtree
operator|->
name|start_level
index|[
name|lg_floor
argument_list|(
name|key
argument_list|)
operator|>>
name|LG_RTREE_BITS_PER_LEVEL
index|]
expr_stmt|;
name|assert
argument_list|(
name|start_level
operator|<
name|rtree
operator|->
name|height
argument_list|)
expr_stmt|;
return|return
operator|(
name|start_level
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_INLINE
name|uintptr_t
name|rtree_subkey
parameter_list|(
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|uintptr_t
name|key
parameter_list|,
name|unsigned
name|level
parameter_list|)
block|{
return|return
operator|(
operator|(
name|key
operator|>>
operator|(
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
operator|(
name|LG_SIZEOF_PTR
operator|+
literal|3
operator|)
operator|)
operator|-
name|rtree
operator|->
name|levels
index|[
name|level
index|]
operator|.
name|cumbits
operator|)
operator|)
operator|&
operator|(
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
name|rtree
operator|->
name|levels
index|[
name|level
index|]
operator|.
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_INLINE
name|bool
name|rtree_node_valid
parameter_list|(
name|rtree_node_elm_t
modifier|*
name|node
parameter_list|)
block|{
return|return
operator|(
operator|(
name|uintptr_t
operator|)
name|node
operator|>
operator|(
name|uintptr_t
operator|)
name|RTREE_NODE_INITIALIZING
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_INLINE
name|rtree_node_elm_t
modifier|*
name|rtree_child_tryread
parameter_list|(
name|rtree_node_elm_t
modifier|*
name|elm
parameter_list|)
block|{
name|rtree_node_elm_t
modifier|*
name|child
decl_stmt|;
comment|/* Double-checked read (first read may be stale. */
name|child
operator|=
name|elm
operator|->
name|child
expr_stmt|;
if|if
condition|(
operator|!
name|rtree_node_valid
argument_list|(
name|child
argument_list|)
condition|)
name|child
operator|=
name|atomic_read_p
argument_list|(
operator|&
name|elm
operator|->
name|pun
argument_list|)
expr_stmt|;
return|return
operator|(
name|child
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_INLINE
name|rtree_node_elm_t
modifier|*
name|rtree_child_read
parameter_list|(
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_node_elm_t
modifier|*
name|elm
parameter_list|,
name|unsigned
name|level
parameter_list|)
block|{
name|rtree_node_elm_t
modifier|*
name|child
decl_stmt|;
name|child
operator|=
name|rtree_child_tryread
argument_list|(
name|elm
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|rtree_node_valid
argument_list|(
name|child
argument_list|)
argument_list|)
condition|)
name|child
operator|=
name|rtree_child_read_hard
argument_list|(
name|rtree
argument_list|,
name|elm
argument_list|,
name|level
argument_list|)
expr_stmt|;
return|return
operator|(
name|child
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_INLINE
name|extent_node_t
modifier|*
name|rtree_val_read
parameter_list|(
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_node_elm_t
modifier|*
name|elm
parameter_list|,
name|bool
name|dependent
parameter_list|)
block|{
if|if
condition|(
name|dependent
condition|)
block|{
comment|/* 		 * Reading a val on behalf of a pointer to a valid allocation is 		 * guaranteed to be a clean read even without synchronization, 		 * because the rtree update became visible in memory before the 		 * pointer came into existence. 		 */
return|return
operator|(
name|elm
operator|->
name|val
operator|)
return|;
block|}
else|else
block|{
comment|/* 		 * An arbitrary read, e.g. on behalf of ivsalloc(), may not be 		 * dependent on a previous rtree write, which means a stale read 		 * could result if synchronization were omitted here. 		 */
return|return
operator|(
name|atomic_read_p
argument_list|(
operator|&
name|elm
operator|->
name|pun
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
name|JEMALLOC_INLINE
name|void
name|rtree_val_write
parameter_list|(
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_node_elm_t
modifier|*
name|elm
parameter_list|,
specifier|const
name|extent_node_t
modifier|*
name|val
parameter_list|)
block|{
name|atomic_write_p
argument_list|(
operator|&
name|elm
operator|->
name|pun
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_INLINE
name|rtree_node_elm_t
modifier|*
name|rtree_subtree_tryread
parameter_list|(
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|unsigned
name|level
parameter_list|)
block|{
name|rtree_node_elm_t
modifier|*
name|subtree
decl_stmt|;
comment|/* Double-checked read (first read may be stale. */
name|subtree
operator|=
name|rtree
operator|->
name|levels
index|[
name|level
index|]
operator|.
name|subtree
expr_stmt|;
if|if
condition|(
operator|!
name|rtree_node_valid
argument_list|(
name|subtree
argument_list|)
condition|)
name|subtree
operator|=
name|atomic_read_p
argument_list|(
operator|&
name|rtree
operator|->
name|levels
index|[
name|level
index|]
operator|.
name|subtree_pun
argument_list|)
expr_stmt|;
return|return
operator|(
name|subtree
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_INLINE
name|rtree_node_elm_t
modifier|*
name|rtree_subtree_read
parameter_list|(
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|unsigned
name|level
parameter_list|)
block|{
name|rtree_node_elm_t
modifier|*
name|subtree
decl_stmt|;
name|subtree
operator|=
name|rtree_subtree_tryread
argument_list|(
name|rtree
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|rtree_node_valid
argument_list|(
name|subtree
argument_list|)
argument_list|)
condition|)
name|subtree
operator|=
name|rtree_subtree_read_hard
argument_list|(
name|rtree
argument_list|,
name|level
argument_list|)
expr_stmt|;
return|return
operator|(
name|subtree
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_INLINE
name|extent_node_t
modifier|*
name|rtree_get
parameter_list|(
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|uintptr_t
name|key
parameter_list|,
name|bool
name|dependent
parameter_list|)
block|{
name|uintptr_t
name|subkey
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|start_level
decl_stmt|;
name|rtree_node_elm_t
modifier|*
name|node
decl_stmt|,
modifier|*
name|child
decl_stmt|;
name|start_level
operator|=
name|rtree_start_level
argument_list|(
name|rtree
argument_list|,
name|key
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start_level
operator|,
name|node
operator|=
name|rtree_subtree_tryread
argument_list|(
name|rtree
argument_list|,
name|start_level
argument_list|)
init|;
comment|/**/
condition|;
name|i
operator|++
operator|,
name|node
operator|=
name|child
control|)
block|{
if|if
condition|(
operator|!
name|dependent
operator|&&
name|unlikely
argument_list|(
operator|!
name|rtree_node_valid
argument_list|(
name|node
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|subkey
operator|=
name|rtree_subkey
argument_list|(
name|rtree
argument_list|,
name|key
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|rtree
operator|->
name|height
operator|-
literal|1
condition|)
block|{
comment|/* 			 * node is a leaf, so it contains values rather than 			 * child pointers. 			 */
return|return
operator|(
name|rtree_val_read
argument_list|(
name|rtree
argument_list|,
operator|&
name|node
index|[
name|subkey
index|]
argument_list|,
name|dependent
argument_list|)
operator|)
return|;
block|}
name|assert
argument_list|(
name|i
operator|<
name|rtree
operator|->
name|height
operator|-
literal|1
argument_list|)
expr_stmt|;
name|child
operator|=
name|rtree_child_tryread
argument_list|(
operator|&
name|node
index|[
name|subkey
index|]
argument_list|)
expr_stmt|;
block|}
name|not_reached
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_INLINE
name|bool
name|rtree_set
parameter_list|(
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|uintptr_t
name|key
parameter_list|,
specifier|const
name|extent_node_t
modifier|*
name|val
parameter_list|)
block|{
name|uintptr_t
name|subkey
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|start_level
decl_stmt|;
name|rtree_node_elm_t
modifier|*
name|node
decl_stmt|,
modifier|*
name|child
decl_stmt|;
name|start_level
operator|=
name|rtree_start_level
argument_list|(
name|rtree
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|node
operator|=
name|rtree_subtree_read
argument_list|(
name|rtree
argument_list|,
name|start_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return
operator|(
name|true
operator|)
return|;
for|for
control|(
name|i
operator|=
name|start_level
init|;
comment|/**/
condition|;
name|i
operator|++
operator|,
name|node
operator|=
name|child
control|)
block|{
name|subkey
operator|=
name|rtree_subkey
argument_list|(
name|rtree
argument_list|,
name|key
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|rtree
operator|->
name|height
operator|-
literal|1
condition|)
block|{
comment|/* 			 * node is a leaf, so it contains values rather than 			 * child pointers. 			 */
name|rtree_val_write
argument_list|(
name|rtree
argument_list|,
operator|&
name|node
index|[
name|subkey
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
name|assert
argument_list|(
name|i
operator|+
literal|1
operator|<
name|rtree
operator|->
name|height
argument_list|)
expr_stmt|;
name|child
operator|=
name|rtree_child_read
argument_list|(
name|rtree
argument_list|,
operator|&
name|node
index|[
name|subkey
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
return|return
operator|(
name|true
operator|)
return|;
block|}
name|not_reached
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JEMALLOC_H_INLINES */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

end_unit

