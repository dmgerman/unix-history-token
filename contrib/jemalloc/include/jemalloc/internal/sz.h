begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|JEMALLOC_INTERNAL_SIZE_H
end_ifndef

begin_define
define|#
directive|define
name|JEMALLOC_INTERNAL_SIZE_H
end_define

begin_include
include|#
directive|include
file|"jemalloc/internal/bit_util.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/pages.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/size_classes.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/util.h"
end_include

begin_comment
comment|/*  * sz module: Size computations.  *  * Some abbreviations used here:  *   p: Page  *   ind: Index  *   s, sz: Size  *   u: Usable size  *   a: Aligned  *  * These are not always used completely consistently, but should be enough to  * interpret function names.  E.g. sz_psz2ind converts page size to page size  * index; sz_sa2u converts a (size, alignment) allocation request to the usable  * size that would result from such an allocation.  */
end_comment

begin_comment
comment|/*  * sz_pind2sz_tab encodes the same information as could be computed by  * sz_pind2sz_compute().  */
end_comment

begin_decl_stmt
specifier|extern
name|size_t
specifier|const
name|sz_pind2sz_tab
index|[
name|NPSIZES
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * sz_index2size_tab encodes the same information as could be computed (at  * unacceptable cost in some code paths) by sz_index2size_compute().  */
end_comment

begin_decl_stmt
specifier|extern
name|size_t
specifier|const
name|sz_index2size_tab
index|[
name|NSIZES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * sz_size2index_tab is a compact lookup table that rounds request sizes up to  * size classes.  In order to reduce cache footprint, the table is compressed,  * and all accesses are via sz_size2index().  */
end_comment

begin_decl_stmt
specifier|extern
name|uint8_t
specifier|const
name|sz_size2index_tab
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|size_t
name|sz_large_pad
init|=
ifdef|#
directive|ifdef
name|JEMALLOC_CACHE_OBLIVIOUS
name|PAGE
else|#
directive|else
literal|0
endif|#
directive|endif
decl_stmt|;
end_decl_stmt

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|pszind_t
name|sz_psz2ind
parameter_list|(
name|size_t
name|psz
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|psz
operator|>
name|LARGE_MAXCLASS
argument_list|)
condition|)
block|{
return|return
name|NPSIZES
return|;
block|}
block|{
name|pszind_t
name|x
init|=
name|lg_floor
argument_list|(
operator|(
name|psz
operator|<<
literal|1
operator|)
operator|-
literal|1
argument_list|)
decl_stmt|;
name|pszind_t
name|shift
init|=
operator|(
name|x
operator|<
name|LG_SIZE_CLASS_GROUP
operator|+
name|LG_PAGE
operator|)
condition|?
literal|0
else|:
name|x
operator|-
operator|(
name|LG_SIZE_CLASS_GROUP
operator|+
name|LG_PAGE
operator|)
decl_stmt|;
name|pszind_t
name|grp
init|=
name|shift
operator|<<
name|LG_SIZE_CLASS_GROUP
decl_stmt|;
name|pszind_t
name|lg_delta
init|=
operator|(
name|x
operator|<
name|LG_SIZE_CLASS_GROUP
operator|+
name|LG_PAGE
operator|+
literal|1
operator|)
condition|?
name|LG_PAGE
else|:
name|x
operator|-
name|LG_SIZE_CLASS_GROUP
operator|-
literal|1
decl_stmt|;
name|size_t
name|delta_inverse_mask
init|=
name|ZD
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|lg_delta
decl_stmt|;
name|pszind_t
name|mod
init|=
operator|(
operator|(
operator|(
operator|(
name|psz
operator|-
literal|1
operator|)
operator|&
name|delta_inverse_mask
operator|)
operator|>>
name|lg_delta
operator|)
operator|)
operator|&
operator|(
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
name|LG_SIZE_CLASS_GROUP
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|pszind_t
name|ind
init|=
name|grp
operator|+
name|mod
decl_stmt|;
return|return
name|ind
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|size_t
name|sz_pind2sz_compute
parameter_list|(
name|pszind_t
name|pind
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|pind
operator|==
name|NPSIZES
argument_list|)
condition|)
block|{
return|return
name|LARGE_MAXCLASS
operator|+
name|PAGE
return|;
block|}
block|{
name|size_t
name|grp
init|=
name|pind
operator|>>
name|LG_SIZE_CLASS_GROUP
decl_stmt|;
name|size_t
name|mod
init|=
name|pind
operator|&
operator|(
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
name|LG_SIZE_CLASS_GROUP
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|size_t
name|grp_size_mask
init|=
operator|~
operator|(
operator|(
operator|!
operator|!
name|grp
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|size_t
name|grp_size
init|=
operator|(
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
operator|(
name|LG_PAGE
operator|+
operator|(
name|LG_SIZE_CLASS_GROUP
operator|-
literal|1
operator|)
operator|)
operator|)
operator|<<
name|grp
operator|)
operator|&
name|grp_size_mask
decl_stmt|;
name|size_t
name|shift
init|=
operator|(
name|grp
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
name|grp
decl_stmt|;
name|size_t
name|lg_delta
init|=
name|shift
operator|+
operator|(
name|LG_PAGE
operator|-
literal|1
operator|)
decl_stmt|;
name|size_t
name|mod_size
init|=
operator|(
name|mod
operator|+
literal|1
operator|)
operator|<<
name|lg_delta
decl_stmt|;
name|size_t
name|sz
init|=
name|grp_size
operator|+
name|mod_size
decl_stmt|;
return|return
name|sz
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|size_t
name|sz_pind2sz_lookup
parameter_list|(
name|pszind_t
name|pind
parameter_list|)
block|{
name|size_t
name|ret
init|=
operator|(
name|size_t
operator|)
name|sz_pind2sz_tab
index|[
name|pind
index|]
decl_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|sz_pind2sz_compute
argument_list|(
name|pind
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|size_t
name|sz_pind2sz
parameter_list|(
name|pszind_t
name|pind
parameter_list|)
block|{
name|assert
argument_list|(
name|pind
operator|<
name|NPSIZES
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|sz_pind2sz_lookup
argument_list|(
name|pind
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|size_t
name|sz_psz2u
parameter_list|(
name|size_t
name|psz
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|psz
operator|>
name|LARGE_MAXCLASS
argument_list|)
condition|)
block|{
return|return
name|LARGE_MAXCLASS
operator|+
name|PAGE
return|;
block|}
block|{
name|size_t
name|x
init|=
name|lg_floor
argument_list|(
operator|(
name|psz
operator|<<
literal|1
operator|)
operator|-
literal|1
argument_list|)
decl_stmt|;
name|size_t
name|lg_delta
init|=
operator|(
name|x
operator|<
name|LG_SIZE_CLASS_GROUP
operator|+
name|LG_PAGE
operator|+
literal|1
operator|)
condition|?
name|LG_PAGE
else|:
name|x
operator|-
name|LG_SIZE_CLASS_GROUP
operator|-
literal|1
decl_stmt|;
name|size_t
name|delta
init|=
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
name|lg_delta
decl_stmt|;
name|size_t
name|delta_mask
init|=
name|delta
operator|-
literal|1
decl_stmt|;
name|size_t
name|usize
init|=
operator|(
name|psz
operator|+
name|delta_mask
operator|)
operator|&
operator|~
name|delta_mask
decl_stmt|;
return|return
name|usize
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|szind_t
name|sz_size2index_compute
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|size
operator|>
name|LARGE_MAXCLASS
argument_list|)
condition|)
block|{
return|return
name|NSIZES
return|;
block|}
if|#
directive|if
operator|(
name|NTBINS
operator|!=
literal|0
operator|)
if|if
condition|(
name|size
operator|<=
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
name|LG_TINY_MAXCLASS
operator|)
condition|)
block|{
name|szind_t
name|lg_tmin
init|=
name|LG_TINY_MAXCLASS
operator|-
name|NTBINS
operator|+
literal|1
decl_stmt|;
name|szind_t
name|lg_ceil
init|=
name|lg_floor
argument_list|(
name|pow2_ceil_zu
argument_list|(
name|size
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|(
name|lg_ceil
operator|<
name|lg_tmin
condition|?
literal|0
else|:
name|lg_ceil
operator|-
name|lg_tmin
operator|)
return|;
block|}
endif|#
directive|endif
block|{
name|szind_t
name|x
init|=
name|lg_floor
argument_list|(
operator|(
name|size
operator|<<
literal|1
operator|)
operator|-
literal|1
argument_list|)
decl_stmt|;
name|szind_t
name|shift
init|=
operator|(
name|x
operator|<
name|LG_SIZE_CLASS_GROUP
operator|+
name|LG_QUANTUM
operator|)
condition|?
literal|0
else|:
name|x
operator|-
operator|(
name|LG_SIZE_CLASS_GROUP
operator|+
name|LG_QUANTUM
operator|)
decl_stmt|;
name|szind_t
name|grp
init|=
name|shift
operator|<<
name|LG_SIZE_CLASS_GROUP
decl_stmt|;
name|szind_t
name|lg_delta
init|=
operator|(
name|x
operator|<
name|LG_SIZE_CLASS_GROUP
operator|+
name|LG_QUANTUM
operator|+
literal|1
operator|)
condition|?
name|LG_QUANTUM
else|:
name|x
operator|-
name|LG_SIZE_CLASS_GROUP
operator|-
literal|1
decl_stmt|;
name|size_t
name|delta_inverse_mask
init|=
name|ZD
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|lg_delta
decl_stmt|;
name|szind_t
name|mod
init|=
operator|(
operator|(
operator|(
operator|(
name|size
operator|-
literal|1
operator|)
operator|&
name|delta_inverse_mask
operator|)
operator|>>
name|lg_delta
operator|)
operator|)
operator|&
operator|(
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
name|LG_SIZE_CLASS_GROUP
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|szind_t
name|index
init|=
name|NTBINS
operator|+
name|grp
operator|+
name|mod
decl_stmt|;
return|return
name|index
return|;
block|}
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|szind_t
name|sz_size2index_lookup
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|assert
argument_list|(
name|size
operator|<=
name|LOOKUP_MAXCLASS
argument_list|)
expr_stmt|;
block|{
name|szind_t
name|ret
init|=
operator|(
name|sz_size2index_tab
index|[
operator|(
name|size
operator|-
literal|1
operator|)
operator|>>
name|LG_TINY_MIN
index|]
operator|)
decl_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|sz_size2index_compute
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|szind_t
name|sz_size2index
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|assert
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|size
operator|<=
name|LOOKUP_MAXCLASS
argument_list|)
condition|)
block|{
return|return
name|sz_size2index_lookup
argument_list|(
name|size
argument_list|)
return|;
block|}
return|return
name|sz_size2index_compute
argument_list|(
name|size
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|size_t
name|sz_index2size_compute
parameter_list|(
name|szind_t
name|index
parameter_list|)
block|{
if|#
directive|if
operator|(
name|NTBINS
operator|>
literal|0
operator|)
if|if
condition|(
name|index
operator|<
name|NTBINS
condition|)
block|{
return|return
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
operator|(
name|LG_TINY_MAXCLASS
operator|-
name|NTBINS
operator|+
literal|1
operator|+
name|index
operator|)
operator|)
return|;
block|}
endif|#
directive|endif
block|{
name|size_t
name|reduced_index
init|=
name|index
operator|-
name|NTBINS
decl_stmt|;
name|size_t
name|grp
init|=
name|reduced_index
operator|>>
name|LG_SIZE_CLASS_GROUP
decl_stmt|;
name|size_t
name|mod
init|=
name|reduced_index
operator|&
operator|(
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
name|LG_SIZE_CLASS_GROUP
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|size_t
name|grp_size_mask
init|=
operator|~
operator|(
operator|(
operator|!
operator|!
name|grp
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|size_t
name|grp_size
init|=
operator|(
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
operator|(
name|LG_QUANTUM
operator|+
operator|(
name|LG_SIZE_CLASS_GROUP
operator|-
literal|1
operator|)
operator|)
operator|)
operator|<<
name|grp
operator|)
operator|&
name|grp_size_mask
decl_stmt|;
name|size_t
name|shift
init|=
operator|(
name|grp
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
name|grp
decl_stmt|;
name|size_t
name|lg_delta
init|=
name|shift
operator|+
operator|(
name|LG_QUANTUM
operator|-
literal|1
operator|)
decl_stmt|;
name|size_t
name|mod_size
init|=
operator|(
name|mod
operator|+
literal|1
operator|)
operator|<<
name|lg_delta
decl_stmt|;
name|size_t
name|usize
init|=
name|grp_size
operator|+
name|mod_size
decl_stmt|;
return|return
name|usize
return|;
block|}
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|size_t
name|sz_index2size_lookup
parameter_list|(
name|szind_t
name|index
parameter_list|)
block|{
name|size_t
name|ret
init|=
operator|(
name|size_t
operator|)
name|sz_index2size_tab
index|[
name|index
index|]
decl_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|sz_index2size_compute
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|size_t
name|sz_index2size
parameter_list|(
name|szind_t
name|index
parameter_list|)
block|{
name|assert
argument_list|(
name|index
operator|<
name|NSIZES
argument_list|)
expr_stmt|;
return|return
name|sz_index2size_lookup
argument_list|(
name|index
argument_list|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|size_t
name|sz_s2u_compute
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|size
operator|>
name|LARGE_MAXCLASS
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|#
directive|if
operator|(
name|NTBINS
operator|>
literal|0
operator|)
if|if
condition|(
name|size
operator|<=
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
name|LG_TINY_MAXCLASS
operator|)
condition|)
block|{
name|size_t
name|lg_tmin
init|=
name|LG_TINY_MAXCLASS
operator|-
name|NTBINS
operator|+
literal|1
decl_stmt|;
name|size_t
name|lg_ceil
init|=
name|lg_floor
argument_list|(
name|pow2_ceil_zu
argument_list|(
name|size
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|(
name|lg_ceil
operator|<
name|lg_tmin
condition|?
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
name|lg_tmin
operator|)
else|:
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
name|lg_ceil
operator|)
operator|)
return|;
block|}
endif|#
directive|endif
block|{
name|size_t
name|x
init|=
name|lg_floor
argument_list|(
operator|(
name|size
operator|<<
literal|1
operator|)
operator|-
literal|1
argument_list|)
decl_stmt|;
name|size_t
name|lg_delta
init|=
operator|(
name|x
operator|<
name|LG_SIZE_CLASS_GROUP
operator|+
name|LG_QUANTUM
operator|+
literal|1
operator|)
condition|?
name|LG_QUANTUM
else|:
name|x
operator|-
name|LG_SIZE_CLASS_GROUP
operator|-
literal|1
decl_stmt|;
name|size_t
name|delta
init|=
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
name|lg_delta
decl_stmt|;
name|size_t
name|delta_mask
init|=
name|delta
operator|-
literal|1
decl_stmt|;
name|size_t
name|usize
init|=
operator|(
name|size
operator|+
name|delta_mask
operator|)
operator|&
operator|~
name|delta_mask
decl_stmt|;
return|return
name|usize
return|;
block|}
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|size_t
name|sz_s2u_lookup
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|ret
init|=
name|sz_index2size_lookup
argument_list|(
name|sz_size2index_lookup
argument_list|(
name|size
argument_list|)
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|sz_s2u_compute
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Compute usable size that would result from allocating an object with the  * specified size.  */
end_comment

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|size_t
name|sz_s2u
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|assert
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|size
operator|<=
name|LOOKUP_MAXCLASS
argument_list|)
condition|)
block|{
return|return
name|sz_s2u_lookup
argument_list|(
name|size
argument_list|)
return|;
block|}
return|return
name|sz_s2u_compute
argument_list|(
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compute usable size that would result from allocating an object with the  * specified size and alignment.  */
end_comment

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|size_t
name|sz_sa2u
parameter_list|(
name|size_t
name|size
parameter_list|,
name|size_t
name|alignment
parameter_list|)
block|{
name|size_t
name|usize
decl_stmt|;
name|assert
argument_list|(
name|alignment
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|&
name|alignment
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Try for a small size class. */
if|if
condition|(
name|size
operator|<=
name|SMALL_MAXCLASS
operator|&&
name|alignment
operator|<
name|PAGE
condition|)
block|{
comment|/* 		 * Round size up to the nearest multiple of alignment. 		 * 		 * This done, we can take advantage of the fact that for each 		 * small size class, every object is aligned at the smallest 		 * power of two that is non-zero in the base two representation 		 * of the size.  For example: 		 * 		 *   Size |   Base 2 | Minimum alignment 		 *   -----+----------+------------------ 		 *     96 |  1100000 |  32 		 *    144 | 10100000 |  32 		 *    192 | 11000000 |  64 		 */
name|usize
operator|=
name|sz_s2u
argument_list|(
name|ALIGNMENT_CEILING
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|usize
operator|<
name|LARGE_MINCLASS
condition|)
block|{
return|return
name|usize
return|;
block|}
block|}
comment|/* Large size class.  Beware of overflow. */
if|if
condition|(
name|unlikely
argument_list|(
name|alignment
operator|>
name|LARGE_MAXCLASS
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* Make sure result is a large size class. */
if|if
condition|(
name|size
operator|<=
name|LARGE_MINCLASS
condition|)
block|{
name|usize
operator|=
name|LARGE_MINCLASS
expr_stmt|;
block|}
else|else
block|{
name|usize
operator|=
name|sz_s2u
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|usize
operator|<
name|size
condition|)
block|{
comment|/* size_t overflow. */
return|return
literal|0
return|;
block|}
block|}
comment|/* 	 * Calculate the multi-page mapping that large_palloc() would need in 	 * order to guarantee the alignment. 	 */
if|if
condition|(
name|usize
operator|+
name|sz_large_pad
operator|+
name|PAGE_CEILING
argument_list|(
name|alignment
argument_list|)
operator|-
name|PAGE
operator|<
name|usize
condition|)
block|{
comment|/* size_t overflow. */
return|return
literal|0
return|;
block|}
return|return
name|usize
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JEMALLOC_INTERNAL_SIZE_H */
end_comment

end_unit

