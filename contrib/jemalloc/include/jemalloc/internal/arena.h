begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_H_TYPES
end_ifdef

begin_comment
comment|/*  * RUN_MAX_OVRHD indicates maximum desired run header overhead.  Runs are sized  * as small as possible such that this setting is still honored, without  * violating other constraints.  The goal is to make runs as small as possible  * without exceeding a per run external fragmentation threshold.  *  * We use binary fixed point math for overhead computations, where the binary  * point is implicitly RUN_BFP bits to the left.  *  * Note that it is possible to set RUN_MAX_OVRHD low enough that it cannot be  * honored for some/all object sizes, since when heap profiling is enabled  * there is one pointer of header overhead per object (plus a constant).  This  * constraint is relaxed (ignored) for runs that are so small that the  * per-region overhead is greater than:  *  *   (RUN_MAX_OVRHD / (reg_interval<< (3+RUN_BFP))  */
end_comment

begin_define
define|#
directive|define
name|RUN_BFP
value|12
end_define

begin_comment
comment|/*                                    \/   Implicit binary fixed point. */
end_comment

begin_define
define|#
directive|define
name|RUN_MAX_OVRHD
value|0x0000003dU
end_define

begin_define
define|#
directive|define
name|RUN_MAX_OVRHD_RELAX
value|0x00001800U
end_define

begin_comment
comment|/* Maximum number of regions in one run. */
end_comment

begin_define
define|#
directive|define
name|LG_RUN_MAXREGS
value|11
end_define

begin_define
define|#
directive|define
name|RUN_MAXREGS
value|(1U<< LG_RUN_MAXREGS)
end_define

begin_comment
comment|/*  * Minimum redzone size.  Redzones may be larger than this if necessary to  * preserve region alignment.  */
end_comment

begin_define
define|#
directive|define
name|REDZONE_MINSIZE
value|16
end_define

begin_comment
comment|/*  * The minimum ratio of active:dirty pages per arena is computed as:  *  *   (nactive>> opt_lg_dirty_mult)>= ndirty  *  * So, supposing that opt_lg_dirty_mult is 3, there can be no less than 8 times  * as many active pages as dirty pages.  */
end_comment

begin_define
define|#
directive|define
name|LG_DIRTY_MULT_DEFAULT
value|3
end_define

begin_typedef
typedef|typedef
name|struct
name|arena_chunk_map_s
name|arena_chunk_map_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|arena_chunk_s
name|arena_chunk_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|arena_run_s
name|arena_run_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|arena_bin_info_s
name|arena_bin_info_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|arena_bin_s
name|arena_bin_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|arena_s
name|arena_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JEMALLOC_H_TYPES */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_H_STRUCTS
end_ifdef

begin_comment
comment|/* Each element of the chunk map corresponds to one page within the chunk. */
end_comment

begin_struct
struct|struct
name|arena_chunk_map_s
block|{
ifndef|#
directive|ifndef
name|JEMALLOC_PROF
comment|/* 	 * Overlay prof_ctx in order to allow it to be referenced by dead code. 	 * Such antics aren't warranted for per arena data structures, but 	 * chunk map overhead accounts for a percentage of memory, rather than 	 * being just a fixed cost. 	 */
union|union
block|{
endif|#
directive|endif
union|union
block|{
comment|/* 		 * Linkage for run trees.  There are two disjoint uses: 		 * 		 * 1) arena_t's runs_avail tree. 		 * 2) arena_run_t conceptually uses this linkage for in-use 		 *    non-full runs, rather than directly embedding linkage. 		 */
name|rb_node
argument_list|(
argument|arena_chunk_map_t
argument_list|)
name|rb_link
expr_stmt|;
comment|/* 		 * List of runs currently in purgatory.  arena_chunk_purge() 		 * temporarily allocates runs that contain dirty pages while 		 * purging, so that other threads cannot use the runs while the 		 * purging thread is operating without the arena lock held. 		 */
name|ql_elm
argument_list|(
argument|arena_chunk_map_t
argument_list|)
name|ql_link
expr_stmt|;
block|}
name|u
union|;
comment|/* Profile counters, used for large object runs. */
name|prof_ctx_t
modifier|*
name|prof_ctx
decl_stmt|;
ifndef|#
directive|ifndef
name|JEMALLOC_PROF
block|}
union|;
comment|/* union { ... }; */
endif|#
directive|endif
comment|/* 	 * Run address (or size) and various flags are stored together.  The bit 	 * layout looks like (assuming 32-bit system): 	 * 	 *   ???????? ???????? ????nnnn nnnndula 	 * 	 * ? : Unallocated: Run address for first/last pages, unset for internal 	 *                  pages. 	 *     Small: Run page offset. 	 *     Large: Run size for first page, unset for trailing pages. 	 * n : binind for small size class, BININD_INVALID for large size class. 	 * d : dirty? 	 * u : unzeroed? 	 * l : large? 	 * a : allocated? 	 * 	 * Following are example bit patterns for the three types of runs. 	 * 	 * p : run page offset 	 * s : run size 	 * n : binind for size class; large objects set these to BININD_INVALID 	 *     except for promoted allocations (see prof_promote) 	 * x : don't care 	 * - : 0 	 * + : 1 	 * [DULA] : bit set 	 * [dula] : bit unset 	 * 	 *   Unallocated (clean): 	 *     ssssssss ssssssss ssss++++ ++++du-a 	 *     xxxxxxxx xxxxxxxx xxxxxxxx xxxx-Uxx 	 *     ssssssss ssssssss ssss++++ ++++dU-a 	 * 	 *   Unallocated (dirty): 	 *     ssssssss ssssssss ssss++++ ++++D--a 	 *     xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx 	 *     ssssssss ssssssss ssss++++ ++++D--a 	 * 	 *   Small: 	 *     pppppppp pppppppp ppppnnnn nnnnd--A 	 *     pppppppp pppppppp ppppnnnn nnnn---A 	 *     pppppppp pppppppp ppppnnnn nnnnd--A 	 * 	 *   Large: 	 *     ssssssss ssssssss ssss++++ ++++D-LA 	 *     xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx 	 *     -------- -------- ----++++ ++++D-LA 	 * 	 *   Large (sampled, size<= PAGE): 	 *     ssssssss ssssssss ssssnnnn nnnnD-LA 	 * 	 *   Large (not sampled, size == PAGE): 	 *     ssssssss ssssssss ssss++++ ++++D-LA 	 */
name|size_t
name|bits
decl_stmt|;
define|#
directive|define
name|CHUNK_MAP_BININD_SHIFT
value|4
define|#
directive|define
name|BININD_INVALID
value|((size_t)0xffU)
comment|/*     CHUNK_MAP_BININD_MASK == (BININD_INVALID<< CHUNK_MAP_BININD_SHIFT) */
define|#
directive|define
name|CHUNK_MAP_BININD_MASK
value|((size_t)0xff0U)
define|#
directive|define
name|CHUNK_MAP_BININD_INVALID
value|CHUNK_MAP_BININD_MASK
define|#
directive|define
name|CHUNK_MAP_FLAGS_MASK
value|((size_t)0xcU)
define|#
directive|define
name|CHUNK_MAP_DIRTY
value|((size_t)0x8U)
define|#
directive|define
name|CHUNK_MAP_UNZEROED
value|((size_t)0x4U)
define|#
directive|define
name|CHUNK_MAP_LARGE
value|((size_t)0x2U)
define|#
directive|define
name|CHUNK_MAP_ALLOCATED
value|((size_t)0x1U)
define|#
directive|define
name|CHUNK_MAP_KEY
value|CHUNK_MAP_ALLOCATED
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|rb_tree
argument_list|(
argument|arena_chunk_map_t
argument_list|)
name|arena_avail_tree_t
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|rb_tree
argument_list|(
argument|arena_chunk_map_t
argument_list|)
name|arena_run_tree_t
expr_stmt|;
end_typedef

begin_comment
comment|/* Arena chunk header. */
end_comment

begin_struct
struct|struct
name|arena_chunk_s
block|{
comment|/* Arena that owns the chunk. */
name|arena_t
modifier|*
name|arena
decl_stmt|;
comment|/* Linkage for tree of arena chunks that contain dirty runs. */
name|rb_node
argument_list|(
argument|arena_chunk_t
argument_list|)
name|dirty_link
expr_stmt|;
comment|/* Number of dirty pages. */
name|size_t
name|ndirty
decl_stmt|;
comment|/* Number of available runs. */
name|size_t
name|nruns_avail
decl_stmt|;
comment|/* 	 * Number of available run adjacencies.  Clean and dirty available runs 	 * are not coalesced, which causes virtual memory fragmentation.  The 	 * ratio of (nruns_avail-nruns_adjac):nruns_adjac is used for tracking 	 * this fragmentation. 	 * */
name|size_t
name|nruns_adjac
decl_stmt|;
comment|/* 	 * Map of pages within chunk that keeps track of free/large/small.  The 	 * first map_bias entries are omitted, since the chunk header does not 	 * need to be tracked in the map.  This omission saves a header page 	 * for common chunk sizes (e.g. 4 MiB). 	 */
name|arena_chunk_map_t
name|map
index|[
literal|1
index|]
decl_stmt|;
comment|/* Dynamically sized. */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|rb_tree
argument_list|(
argument|arena_chunk_t
argument_list|)
name|arena_chunk_tree_t
expr_stmt|;
end_typedef

begin_struct
struct|struct
name|arena_run_s
block|{
comment|/* Bin this run is associated with. */
name|arena_bin_t
modifier|*
name|bin
decl_stmt|;
comment|/* Index of next region that has never been allocated, or nregs. */
name|uint32_t
name|nextind
decl_stmt|;
comment|/* Number of free regions in run. */
name|unsigned
name|nfree
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Read-only information associated with each element of arena_t's bins array  * is stored separately, partly to reduce memory usage (only one copy, rather  * than one per arena), but mainly to avoid false cacheline sharing.  *  * Each run has the following layout:  *  *               /--------------------\  *               | arena_run_t header |  *               | ...                |  * bitmap_offset | bitmap             |  *               | ...                |  *   ctx0_offset | ctx map            |  *               | ...                |  *               |--------------------|  *               | redzone            |  *   reg0_offset | region 0           |  *               | redzone            |  *               |--------------------| \  *               | redzone            | |  *               | region 1           |> reg_interval  *               | redzone            | /  *               |--------------------|  *               | ...                |  *               | ...                |  *               | ...                |  *               |--------------------|  *               | redzone            |  *               | region nregs-1     |  *               | redzone            |  *               |--------------------|  *               | alignment pad?     |  *               \--------------------/  *  * reg_interval has at least the same minimum alignment as reg_size; this  * preserves the alignment constraint that sa2u() depends on.  Alignment pad is  * either 0 or redzone_size; it is present only if needed to align reg0_offset.  */
end_comment

begin_struct
struct|struct
name|arena_bin_info_s
block|{
comment|/* Size of regions in a run for this bin's size class. */
name|size_t
name|reg_size
decl_stmt|;
comment|/* Redzone size. */
name|size_t
name|redzone_size
decl_stmt|;
comment|/* Interval between regions (reg_size + (redzone_size<< 1)). */
name|size_t
name|reg_interval
decl_stmt|;
comment|/* Total size of a run for this bin's size class. */
name|size_t
name|run_size
decl_stmt|;
comment|/* Total number of regions in a run for this bin's size class. */
name|uint32_t
name|nregs
decl_stmt|;
comment|/* 	 * Offset of first bitmap_t element in a run header for this bin's size 	 * class. 	 */
name|uint32_t
name|bitmap_offset
decl_stmt|;
comment|/* 	 * Metadata used to manipulate bitmaps for runs associated with this 	 * bin. 	 */
name|bitmap_info_t
name|bitmap_info
decl_stmt|;
comment|/* 	 * Offset of first (prof_ctx_t *) in a run header for this bin's size 	 * class, or 0 if (config_prof == false || opt_prof == false). 	 */
name|uint32_t
name|ctx0_offset
decl_stmt|;
comment|/* Offset of first region in a run for this bin's size class. */
name|uint32_t
name|reg0_offset
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|arena_bin_s
block|{
comment|/* 	 * All operations on runcur, runs, and stats require that lock be 	 * locked.  Run allocation/deallocation are protected by the arena lock, 	 * which may be acquired while holding one or more bin locks, but not 	 * vise versa. 	 */
name|malloc_mutex_t
name|lock
decl_stmt|;
comment|/* 	 * Current run being used to service allocations of this bin's size 	 * class. 	 */
name|arena_run_t
modifier|*
name|runcur
decl_stmt|;
comment|/* 	 * Tree of non-full runs.  This tree is used when looking for an 	 * existing run when runcur is no longer usable.  We choose the 	 * non-full run that is lowest in memory; this policy tends to keep 	 * objects packed well, and it can also help reduce the number of 	 * almost-empty chunks. 	 */
name|arena_run_tree_t
name|runs
decl_stmt|;
comment|/* Bin statistics. */
name|malloc_bin_stats_t
name|stats
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|arena_s
block|{
comment|/* This arena's index within the arenas array. */
name|unsigned
name|ind
decl_stmt|;
comment|/* 	 * Number of threads currently assigned to this arena.  This field is 	 * protected by arenas_lock. 	 */
name|unsigned
name|nthreads
decl_stmt|;
comment|/* 	 * There are three classes of arena operations from a locking 	 * perspective: 	 * 1) Thread asssignment (modifies nthreads) is protected by 	 *    arenas_lock. 	 * 2) Bin-related operations are protected by bin locks. 	 * 3) Chunk- and run-related operations are protected by this mutex. 	 */
name|malloc_mutex_t
name|lock
decl_stmt|;
name|arena_stats_t
name|stats
decl_stmt|;
comment|/* 	 * List of tcaches for extant threads associated with this arena. 	 * Stats from these are merged incrementally, and at exit. 	 */
name|ql_head
argument_list|(
argument|tcache_t
argument_list|)
name|tcache_ql
expr_stmt|;
name|uint64_t
name|prof_accumbytes
decl_stmt|;
name|dss_prec_t
name|dss_prec
decl_stmt|;
comment|/* Tree of dirty-page-containing chunks this arena manages. */
name|arena_chunk_tree_t
name|chunks_dirty
decl_stmt|;
comment|/* 	 * In order to avoid rapid chunk allocation/deallocation when an arena 	 * oscillates right on the cusp of needing a new chunk, cache the most 	 * recently freed chunk.  The spare is left in the arena's chunk trees 	 * until it is deleted. 	 * 	 * There is one spare chunk per arena, rather than one spare total, in 	 * order to avoid interactions between multiple threads that could make 	 * a single spare inadequate. 	 */
name|arena_chunk_t
modifier|*
name|spare
decl_stmt|;
comment|/* Number of pages in active runs. */
name|size_t
name|nactive
decl_stmt|;
comment|/* 	 * Current count of pages within unused runs that are potentially 	 * dirty, and for which madvise(... MADV_DONTNEED) has not been called. 	 * By tracking this, we can institute a limit on how much dirty unused 	 * memory is mapped for each arena. 	 */
name|size_t
name|ndirty
decl_stmt|;
comment|/* 	 * Approximate number of pages being purged.  It is possible for 	 * multiple threads to purge dirty pages concurrently, and they use 	 * npurgatory to indicate the total number of pages all threads are 	 * attempting to purge. 	 */
name|size_t
name|npurgatory
decl_stmt|;
comment|/* 	 * Size/address-ordered trees of this arena's available runs.  The trees 	 * are used for first-best-fit run allocation. 	 */
name|arena_avail_tree_t
name|runs_avail
decl_stmt|;
comment|/* bins is used to store trees of free regions. */
name|arena_bin_t
name|bins
index|[
name|NBINS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JEMALLOC_H_STRUCTS */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_H_EXTERNS
end_ifdef

begin_decl_stmt
specifier|extern
name|ssize_t
name|opt_lg_dirty_mult
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * small_size2bin is a compact lookup table that rounds request sizes up to  * size classes.  In order to reduce cache footprint, the table is compressed,  * and all accesses are via the SMALL_SIZE2BIN macro.  */
end_comment

begin_decl_stmt
specifier|extern
name|uint8_t
specifier|const
name|small_size2bin
index|[]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SMALL_SIZE2BIN
parameter_list|(
name|s
parameter_list|)
value|(small_size2bin[(s-1)>> LG_TINY_MIN])
end_define

begin_decl_stmt
specifier|extern
name|arena_bin_info_t
name|arena_bin_info
index|[
name|NBINS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of large size classes. */
end_comment

begin_define
define|#
directive|define
name|nlclasses
value|(chunk_npages - map_bias)
end_define

begin_function_decl
name|void
name|arena_purge_all
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|arena_tcache_fill_small
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|tcache_bin_t
modifier|*
name|tbin
parameter_list|,
name|size_t
name|binind
parameter_list|,
name|uint64_t
name|prof_accumbytes
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|arena_alloc_junk_small
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|arena_bin_info_t
modifier|*
name|bin_info
parameter_list|,
name|bool
name|zero
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|arena_dalloc_junk_small
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|arena_bin_info_t
modifier|*
name|bin_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|arena_malloc_small
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|zero
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|arena_malloc_large
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|zero
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|arena_palloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
name|zero
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|arena_prof_promoted
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|arena_dalloc_bin_locked
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|arena_chunk_map_t
modifier|*
name|mapelm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|arena_dalloc_bin
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|pageind
parameter_list|,
name|arena_chunk_map_t
modifier|*
name|mapelm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|arena_dalloc_small
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|pageind
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|arena_dalloc_large_locked
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|arena_dalloc_large
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|arena_ralloc_no_move
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|extra
parameter_list|,
name|bool
name|zero
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|arena_ralloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|extra
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
name|zero
parameter_list|,
name|bool
name|try_tcache_alloc
parameter_list|,
name|bool
name|try_tcache_dalloc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|dss_prec_t
name|arena_dss_prec_get
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|arena_dss_prec_set
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|dss_prec_t
name|dss_prec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|arena_stats_merge
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|dss
parameter_list|,
name|size_t
modifier|*
name|nactive
parameter_list|,
name|size_t
modifier|*
name|ndirty
parameter_list|,
name|arena_stats_t
modifier|*
name|astats
parameter_list|,
name|malloc_bin_stats_t
modifier|*
name|bstats
parameter_list|,
name|malloc_large_stats_t
modifier|*
name|lstats
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|arena_new
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|unsigned
name|ind
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|arena_boot
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|arena_prefork
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|arena_postfork_parent
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|arena_postfork_child
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JEMALLOC_H_EXTERNS */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_H_INLINES
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|JEMALLOC_ENABLE_INLINE
end_ifndef

begin_function_decl
name|arena_chunk_map_t
modifier|*
name|arena_mapp_get
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_t
modifier|*
name|arena_mapbitsp_get
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_t
name|arena_mapbits_get
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_t
name|arena_mapbits_unallocated_size_get
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_t
name|arena_mapbits_large_size_get
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_t
name|arena_mapbits_small_runind_get
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_t
name|arena_mapbits_binind_get
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_t
name|arena_mapbits_dirty_get
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_t
name|arena_mapbits_unzeroed_get
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_t
name|arena_mapbits_large_get
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_t
name|arena_mapbits_allocated_get
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|arena_mapbits_unallocated_set
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|arena_mapbits_unallocated_size_set
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|arena_mapbits_large_set
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|arena_mapbits_large_binind_set
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|,
name|size_t
name|binind
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|arena_mapbits_small_set
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|,
name|size_t
name|runind
parameter_list|,
name|size_t
name|binind
parameter_list|,
name|size_t
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|arena_mapbits_unzeroed_set
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|,
name|size_t
name|unzeroed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|arena_prof_accum_impl
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|uint64_t
name|accumbytes
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|arena_prof_accum_locked
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|uint64_t
name|accumbytes
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|arena_prof_accum
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|uint64_t
name|accumbytes
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_t
name|arena_ptr_small_binind_get
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|mapbits
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_t
name|arena_bin_index
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|unsigned
name|arena_run_regind
parameter_list|(
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|arena_bin_info_t
modifier|*
name|bin_info
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|prof_ctx_t
modifier|*
name|arena_prof_ctx_get
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|arena_prof_ctx_set
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|prof_ctx_t
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|arena_malloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|zero
parameter_list|,
name|bool
name|try_tcache
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_t
name|arena_salloc
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|bool
name|demote
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|arena_dalloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|bool
name|try_tcache
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|JEMALLOC_ENABLE_INLINE
argument_list|)
operator|||
name|defined
argument_list|(
name|JEMALLOC_ARENA_C_
argument_list|)
operator|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_ARENA_INLINE_A
end_ifdef

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|arena_chunk_map_t
modifier|*
name|arena_mapp_get
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|)
block|{
name|assert
argument_list|(
name|pageind
operator|>=
name|map_bias
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pageind
operator|<
name|chunk_npages
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|chunk
operator|->
name|map
index|[
name|pageind
operator|-
name|map_bias
index|]
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|size_t
modifier|*
name|arena_mapbitsp_get
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|)
block|{
return|return
operator|(
operator|&
name|arena_mapp_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|->
name|bits
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|size_t
name|arena_mapbits_get
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|)
block|{
return|return
operator|(
operator|*
name|arena_mapbitsp_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|size_t
name|arena_mapbits_unallocated_size_get
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|)
block|{
name|size_t
name|mapbits
decl_stmt|;
name|mapbits
operator|=
name|arena_mapbits_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|mapbits
operator|&
operator|(
name|CHUNK_MAP_LARGE
operator||
name|CHUNK_MAP_ALLOCATED
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|mapbits
operator|&
operator|~
name|PAGE_MASK
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|size_t
name|arena_mapbits_large_size_get
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|)
block|{
name|size_t
name|mapbits
decl_stmt|;
name|mapbits
operator|=
name|arena_mapbits_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|mapbits
operator|&
operator|(
name|CHUNK_MAP_LARGE
operator||
name|CHUNK_MAP_ALLOCATED
operator|)
operator|)
operator|==
operator|(
name|CHUNK_MAP_LARGE
operator||
name|CHUNK_MAP_ALLOCATED
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|mapbits
operator|&
operator|~
name|PAGE_MASK
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|size_t
name|arena_mapbits_small_runind_get
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|)
block|{
name|size_t
name|mapbits
decl_stmt|;
name|mapbits
operator|=
name|arena_mapbits_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|mapbits
operator|&
operator|(
name|CHUNK_MAP_LARGE
operator||
name|CHUNK_MAP_ALLOCATED
operator|)
operator|)
operator|==
name|CHUNK_MAP_ALLOCATED
argument_list|)
expr_stmt|;
return|return
operator|(
name|mapbits
operator|>>
name|LG_PAGE
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|size_t
name|arena_mapbits_binind_get
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|)
block|{
name|size_t
name|mapbits
decl_stmt|;
name|size_t
name|binind
decl_stmt|;
name|mapbits
operator|=
name|arena_mapbits_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
expr_stmt|;
name|binind
operator|=
operator|(
name|mapbits
operator|&
name|CHUNK_MAP_BININD_MASK
operator|)
operator|>>
name|CHUNK_MAP_BININD_SHIFT
expr_stmt|;
name|assert
argument_list|(
name|binind
operator|<
name|NBINS
operator|||
name|binind
operator|==
name|BININD_INVALID
argument_list|)
expr_stmt|;
return|return
operator|(
name|binind
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|size_t
name|arena_mapbits_dirty_get
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|)
block|{
name|size_t
name|mapbits
decl_stmt|;
name|mapbits
operator|=
name|arena_mapbits_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
expr_stmt|;
return|return
operator|(
name|mapbits
operator|&
name|CHUNK_MAP_DIRTY
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|size_t
name|arena_mapbits_unzeroed_get
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|)
block|{
name|size_t
name|mapbits
decl_stmt|;
name|mapbits
operator|=
name|arena_mapbits_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
expr_stmt|;
return|return
operator|(
name|mapbits
operator|&
name|CHUNK_MAP_UNZEROED
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|size_t
name|arena_mapbits_large_get
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|)
block|{
name|size_t
name|mapbits
decl_stmt|;
name|mapbits
operator|=
name|arena_mapbits_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
expr_stmt|;
return|return
operator|(
name|mapbits
operator|&
name|CHUNK_MAP_LARGE
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|size_t
name|arena_mapbits_allocated_get
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|)
block|{
name|size_t
name|mapbits
decl_stmt|;
name|mapbits
operator|=
name|arena_mapbits_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
expr_stmt|;
return|return
operator|(
name|mapbits
operator|&
name|CHUNK_MAP_ALLOCATED
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|void
name|arena_mapbits_unallocated_set
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|flags
parameter_list|)
block|{
name|size_t
modifier|*
name|mapbitsp
decl_stmt|;
name|mapbitsp
operator|=
name|arena_mapbitsp_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|size
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|flags
operator|&
operator|~
name|CHUNK_MAP_FLAGS_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|flags
operator|&
operator|(
name|CHUNK_MAP_DIRTY
operator||
name|CHUNK_MAP_UNZEROED
operator|)
operator|)
operator|==
name|flags
argument_list|)
expr_stmt|;
operator|*
name|mapbitsp
operator|=
name|size
operator||
name|CHUNK_MAP_BININD_INVALID
operator||
name|flags
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|void
name|arena_mapbits_unallocated_size_set
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
modifier|*
name|mapbitsp
decl_stmt|;
name|mapbitsp
operator|=
name|arena_mapbitsp_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|size
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
operator|*
name|mapbitsp
operator|&
operator|(
name|CHUNK_MAP_LARGE
operator||
name|CHUNK_MAP_ALLOCATED
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|*
name|mapbitsp
operator|=
name|size
operator||
operator|(
operator|*
name|mapbitsp
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|void
name|arena_mapbits_large_set
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|flags
parameter_list|)
block|{
name|size_t
modifier|*
name|mapbitsp
decl_stmt|;
name|size_t
name|unzeroed
decl_stmt|;
name|mapbitsp
operator|=
name|arena_mapbitsp_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|size
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|flags
operator|&
name|CHUNK_MAP_DIRTY
operator|)
operator|==
name|flags
argument_list|)
expr_stmt|;
name|unzeroed
operator|=
operator|*
name|mapbitsp
operator|&
name|CHUNK_MAP_UNZEROED
expr_stmt|;
comment|/* Preserve unzeroed. */
operator|*
name|mapbitsp
operator|=
name|size
operator||
name|CHUNK_MAP_BININD_INVALID
operator||
name|flags
operator||
name|unzeroed
operator||
name|CHUNK_MAP_LARGE
operator||
name|CHUNK_MAP_ALLOCATED
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|void
name|arena_mapbits_large_binind_set
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|,
name|size_t
name|binind
parameter_list|)
block|{
name|size_t
modifier|*
name|mapbitsp
decl_stmt|;
name|assert
argument_list|(
name|binind
operator|<=
name|BININD_INVALID
argument_list|)
expr_stmt|;
name|mapbitsp
operator|=
name|arena_mapbitsp_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_large_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|==
name|PAGE
argument_list|)
expr_stmt|;
operator|*
name|mapbitsp
operator|=
operator|(
operator|*
name|mapbitsp
operator|&
operator|~
name|CHUNK_MAP_BININD_MASK
operator|)
operator||
operator|(
name|binind
operator|<<
name|CHUNK_MAP_BININD_SHIFT
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|void
name|arena_mapbits_small_set
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|,
name|size_t
name|runind
parameter_list|,
name|size_t
name|binind
parameter_list|,
name|size_t
name|flags
parameter_list|)
block|{
name|size_t
modifier|*
name|mapbitsp
decl_stmt|;
name|size_t
name|unzeroed
decl_stmt|;
name|assert
argument_list|(
name|binind
operator|<
name|BININD_INVALID
argument_list|)
expr_stmt|;
name|mapbitsp
operator|=
name|arena_mapbitsp_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pageind
operator|-
name|runind
operator|>=
name|map_bias
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|flags
operator|&
name|CHUNK_MAP_DIRTY
operator|)
operator|==
name|flags
argument_list|)
expr_stmt|;
name|unzeroed
operator|=
operator|*
name|mapbitsp
operator|&
name|CHUNK_MAP_UNZEROED
expr_stmt|;
comment|/* Preserve unzeroed. */
operator|*
name|mapbitsp
operator|=
operator|(
name|runind
operator|<<
name|LG_PAGE
operator|)
operator||
operator|(
name|binind
operator|<<
name|CHUNK_MAP_BININD_SHIFT
operator|)
operator||
name|flags
operator||
name|unzeroed
operator||
name|CHUNK_MAP_ALLOCATED
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|void
name|arena_mapbits_unzeroed_set
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|,
name|size_t
name|unzeroed
parameter_list|)
block|{
name|size_t
modifier|*
name|mapbitsp
decl_stmt|;
name|mapbitsp
operator|=
name|arena_mapbitsp_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
expr_stmt|;
operator|*
name|mapbitsp
operator|=
operator|(
operator|*
name|mapbitsp
operator|&
operator|~
name|CHUNK_MAP_UNZEROED
operator|)
operator||
name|unzeroed
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_INLINE
name|bool
name|arena_prof_accum_impl
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|uint64_t
name|accumbytes
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|prof_interval
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|arena
operator|->
name|prof_accumbytes
operator|+=
name|accumbytes
expr_stmt|;
if|if
condition|(
name|arena
operator|->
name|prof_accumbytes
operator|>=
name|prof_interval
condition|)
block|{
name|arena
operator|->
name|prof_accumbytes
operator|-=
name|prof_interval
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_INLINE
name|bool
name|arena_prof_accum_locked
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|uint64_t
name|accumbytes
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
if|if
condition|(
name|prof_interval
operator|==
literal|0
condition|)
return|return
operator|(
name|false
operator|)
return|;
return|return
operator|(
name|arena_prof_accum_impl
argument_list|(
name|arena
argument_list|,
name|accumbytes
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_INLINE
name|bool
name|arena_prof_accum
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|uint64_t
name|accumbytes
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
if|if
condition|(
name|prof_interval
operator|==
literal|0
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|{
name|bool
name|ret
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|arena_prof_accum_impl
argument_list|(
name|arena
argument_list|,
name|accumbytes
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|size_t
name|arena_ptr_small_binind_get
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|mapbits
parameter_list|)
block|{
name|size_t
name|binind
decl_stmt|;
name|binind
operator|=
operator|(
name|mapbits
operator|&
name|CHUNK_MAP_BININD_MASK
operator|)
operator|>>
name|CHUNK_MAP_BININD_SHIFT
expr_stmt|;
if|if
condition|(
name|config_debug
condition|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|arena_t
modifier|*
name|arena
decl_stmt|;
name|size_t
name|pageind
decl_stmt|;
name|size_t
name|actual_mapbits
decl_stmt|;
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|arena_bin_t
modifier|*
name|bin
decl_stmt|;
name|size_t
name|actual_binind
decl_stmt|;
name|arena_bin_info_t
modifier|*
name|bin_info
decl_stmt|;
name|assert
argument_list|(
name|binind
operator|!=
name|BININD_INVALID
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|binind
operator|<
name|NBINS
argument_list|)
expr_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|arena
operator|=
name|chunk
operator|->
name|arena
expr_stmt|;
name|pageind
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|LG_PAGE
expr_stmt|;
name|actual_mapbits
operator|=
name|arena_mapbits_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|mapbits
operator|==
name|actual_mapbits
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_large_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_allocated_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|run
operator|=
operator|(
name|arena_run_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
call|(
name|uintptr_t
call|)
argument_list|(
operator|(
name|pageind
operator|-
operator|(
name|actual_mapbits
operator|>>
name|LG_PAGE
operator|)
operator|)
operator|<<
name|LG_PAGE
argument_list|)
operator|)
expr_stmt|;
name|bin
operator|=
name|run
operator|->
name|bin
expr_stmt|;
name|actual_binind
operator|=
name|bin
operator|-
name|arena
operator|->
name|bins
expr_stmt|;
name|assert
argument_list|(
name|binind
operator|==
name|actual_binind
argument_list|)
expr_stmt|;
name|bin_info
operator|=
operator|&
name|arena_bin_info
index|[
name|actual_binind
index|]
expr_stmt|;
name|assert
argument_list|(
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|+
operator|(
name|uintptr_t
operator|)
name|bin_info
operator|->
name|reg0_offset
operator|)
operator|)
operator|%
name|bin_info
operator|->
name|reg_interval
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|binind
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JEMALLOC_ARENA_INLINE_A */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_ARENA_INLINE_B
end_ifdef

begin_function
name|JEMALLOC_INLINE
name|size_t
name|arena_bin_index
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
block|{
name|size_t
name|binind
init|=
name|bin
operator|-
name|arena
operator|->
name|bins
decl_stmt|;
name|assert
argument_list|(
name|binind
operator|<
name|NBINS
argument_list|)
expr_stmt|;
return|return
operator|(
name|binind
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_INLINE
name|unsigned
name|arena_run_regind
parameter_list|(
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|arena_bin_info_t
modifier|*
name|bin_info
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|unsigned
name|shift
decl_stmt|,
name|diff
decl_stmt|,
name|regind
decl_stmt|;
name|size_t
name|interval
decl_stmt|;
comment|/* 	 * Freeing a pointer lower than region zero can cause assertion 	 * failure. 	 */
name|assert
argument_list|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|>=
operator|(
name|uintptr_t
operator|)
name|run
operator|+
operator|(
name|uintptr_t
operator|)
name|bin_info
operator|->
name|reg0_offset
argument_list|)
expr_stmt|;
comment|/* 	 * Avoid doing division with a variable divisor if possible.  Using 	 * actual division here can reduce allocator throughput by over 20%! 	 */
name|diff
operator|=
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|run
operator|-
name|bin_info
operator|->
name|reg0_offset
argument_list|)
expr_stmt|;
comment|/* Rescale (factor powers of 2 out of the numerator and denominator). */
name|interval
operator|=
name|bin_info
operator|->
name|reg_interval
expr_stmt|;
name|shift
operator|=
name|ffs
argument_list|(
name|interval
argument_list|)
operator|-
literal|1
expr_stmt|;
name|diff
operator|>>=
name|shift
expr_stmt|;
name|interval
operator|>>=
name|shift
expr_stmt|;
if|if
condition|(
name|interval
operator|==
literal|1
condition|)
block|{
comment|/* The divisor was a power of 2. */
name|regind
operator|=
name|diff
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * To divide by a number D that is not a power of two we 		 * multiply by (2^21 / D) and then right shift by 21 positions. 		 * 		 *   X / D 		 * 		 * becomes 		 * 		 *   (X * interval_invs[D - 3])>> SIZE_INV_SHIFT 		 * 		 * We can omit the first three elements, because we never 		 * divide by 0, and 1 and 2 are both powers of two, which are 		 * handled above. 		 */
define|#
directive|define
name|SIZE_INV_SHIFT
value|((sizeof(unsigned)<< 3) - LG_RUN_MAXREGS)
define|#
directive|define
name|SIZE_INV
parameter_list|(
name|s
parameter_list|)
value|(((1U<< SIZE_INV_SHIFT) / (s)) + 1)
specifier|static
specifier|const
name|unsigned
name|interval_invs
index|[]
init|=
block|{
name|SIZE_INV
argument_list|(
literal|3
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|4
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|5
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|6
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|7
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|8
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|9
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|10
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|11
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|12
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|13
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|14
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|15
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|16
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|17
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|18
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|19
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|20
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|21
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|22
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|23
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|24
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|25
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|26
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|27
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|28
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|29
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|30
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|31
argument_list|)
block|}
decl_stmt|;
if|if
condition|(
name|interval
operator|<=
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|interval_invs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|)
operator|+
literal|2
operator|)
condition|)
block|{
name|regind
operator|=
operator|(
name|diff
operator|*
name|interval_invs
index|[
name|interval
operator|-
literal|3
index|]
operator|)
operator|>>
name|SIZE_INV_SHIFT
expr_stmt|;
block|}
else|else
name|regind
operator|=
name|diff
operator|/
name|interval
expr_stmt|;
undef|#
directive|undef
name|SIZE_INV
undef|#
directive|undef
name|SIZE_INV_SHIFT
block|}
name|assert
argument_list|(
name|diff
operator|==
name|regind
operator|*
name|interval
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|regind
operator|<
name|bin_info
operator|->
name|nregs
argument_list|)
expr_stmt|;
return|return
operator|(
name|regind
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_INLINE
name|prof_ctx_t
modifier|*
name|arena_prof_ctx_get
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|prof_ctx_t
modifier|*
name|ret
decl_stmt|;
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|size_t
name|pageind
decl_stmt|,
name|mapbits
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
operator|!=
name|ptr
argument_list|)
expr_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|pageind
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|LG_PAGE
expr_stmt|;
name|mapbits
operator|=
name|arena_mapbits_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|mapbits
operator|&
name|CHUNK_MAP_ALLOCATED
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mapbits
operator|&
name|CHUNK_MAP_LARGE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prof_promote
condition|)
name|ret
operator|=
operator|(
name|prof_ctx_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
literal|1U
expr_stmt|;
else|else
block|{
name|arena_run_t
modifier|*
name|run
init|=
operator|(
name|arena_run_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
call|(
name|uintptr_t
call|)
argument_list|(
operator|(
name|pageind
operator|-
operator|(
name|mapbits
operator|>>
name|LG_PAGE
operator|)
operator|)
operator|<<
name|LG_PAGE
argument_list|)
operator|)
decl_stmt|;
name|size_t
name|binind
init|=
name|arena_ptr_small_binind_get
argument_list|(
name|ptr
argument_list|,
name|mapbits
argument_list|)
decl_stmt|;
name|arena_bin_info_t
modifier|*
name|bin_info
init|=
operator|&
name|arena_bin_info
index|[
name|binind
index|]
decl_stmt|;
name|unsigned
name|regind
decl_stmt|;
name|regind
operator|=
name|arena_run_regind
argument_list|(
name|run
argument_list|,
name|bin_info
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|*
operator|(
name|prof_ctx_t
operator|*
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|+
name|bin_info
operator|->
name|ctx0_offset
operator|+
operator|(
name|regind
operator|*
sizeof|sizeof
argument_list|(
name|prof_ctx_t
operator|*
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
block|}
else|else
name|ret
operator|=
name|arena_mapp_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|->
name|prof_ctx
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_INLINE
name|void
name|arena_prof_ctx_set
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|prof_ctx_t
modifier|*
name|ctx
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|size_t
name|pageind
decl_stmt|,
name|mapbits
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
operator|!=
name|ptr
argument_list|)
expr_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|pageind
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|LG_PAGE
expr_stmt|;
name|mapbits
operator|=
name|arena_mapbits_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|mapbits
operator|&
name|CHUNK_MAP_ALLOCATED
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mapbits
operator|&
name|CHUNK_MAP_LARGE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prof_promote
operator|==
name|false
condition|)
block|{
name|arena_run_t
modifier|*
name|run
init|=
operator|(
name|arena_run_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
call|(
name|uintptr_t
call|)
argument_list|(
operator|(
name|pageind
operator|-
operator|(
name|mapbits
operator|>>
name|LG_PAGE
operator|)
operator|)
operator|<<
name|LG_PAGE
argument_list|)
operator|)
decl_stmt|;
name|size_t
name|binind
decl_stmt|;
name|arena_bin_info_t
modifier|*
name|bin_info
decl_stmt|;
name|unsigned
name|regind
decl_stmt|;
name|binind
operator|=
name|arena_ptr_small_binind_get
argument_list|(
name|ptr
argument_list|,
name|mapbits
argument_list|)
expr_stmt|;
name|bin_info
operator|=
operator|&
name|arena_bin_info
index|[
name|binind
index|]
expr_stmt|;
name|regind
operator|=
name|arena_run_regind
argument_list|(
name|run
argument_list|,
name|bin_info
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|prof_ctx_t
operator|*
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|+
name|bin_info
operator|->
name|ctx0_offset
operator|+
operator|(
name|regind
operator|*
sizeof|sizeof
argument_list|(
name|prof_ctx_t
operator|*
argument_list|)
operator|)
operator|)
operator|)
operator|=
name|ctx
expr_stmt|;
block|}
else|else
name|assert
argument_list|(
operator|(
name|uintptr_t
operator|)
name|ctx
operator|==
operator|(
name|uintptr_t
operator|)
literal|1U
argument_list|)
expr_stmt|;
block|}
else|else
name|arena_mapp_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|->
name|prof_ctx
operator|=
name|ctx
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|void
modifier|*
name|arena_malloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|zero
parameter_list|,
name|bool
name|try_tcache
parameter_list|)
block|{
name|tcache_t
modifier|*
name|tcache
decl_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|<=
name|arena_maxclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|SMALL_MAXCLASS
condition|)
block|{
if|if
condition|(
name|try_tcache
operator|&&
operator|(
name|tcache
operator|=
name|tcache_get
argument_list|(
name|true
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|tcache_alloc_small
argument_list|(
name|tcache
argument_list|,
name|size
argument_list|,
name|zero
argument_list|)
operator|)
return|;
else|else
block|{
return|return
operator|(
name|arena_malloc_small
argument_list|(
name|choose_arena
argument_list|(
name|arena
argument_list|)
argument_list|,
name|size
argument_list|,
name|zero
argument_list|)
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 * Initialize tcache after checking size in order to avoid 		 * infinite recursion during tcache initialization. 		 */
if|if
condition|(
name|try_tcache
operator|&&
name|size
operator|<=
name|tcache_maxclass
operator|&&
operator|(
name|tcache
operator|=
name|tcache_get
argument_list|(
name|true
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|tcache_alloc_large
argument_list|(
name|tcache
argument_list|,
name|size
argument_list|,
name|zero
argument_list|)
operator|)
return|;
else|else
block|{
return|return
operator|(
name|arena_malloc_large
argument_list|(
name|choose_arena
argument_list|(
name|arena
argument_list|)
argument_list|,
name|size
argument_list|,
name|zero
argument_list|)
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return the size of the allocation pointed to by ptr. */
end_comment

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|size_t
name|arena_salloc
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|bool
name|demote
parameter_list|)
block|{
name|size_t
name|ret
decl_stmt|;
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|size_t
name|pageind
decl_stmt|,
name|binind
decl_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
operator|!=
name|ptr
argument_list|)
expr_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|pageind
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|LG_PAGE
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_allocated_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|binind
operator|=
name|arena_mapbits_binind_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
expr_stmt|;
if|if
condition|(
name|binind
operator|==
name|BININD_INVALID
operator|||
operator|(
name|config_prof
operator|&&
name|demote
operator|==
name|false
operator|&&
name|prof_promote
operator|&&
name|arena_mapbits_large_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Large allocation.  In the common case (demote == true), and 		 * as this is an inline function, most callers will only end up 		 * looking at binind to determine that ptr is a small 		 * allocation. 		 */
name|assert
argument_list|(
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|arena_mapbits_large_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pageind
operator|+
operator|(
name|ret
operator|>>
name|LG_PAGE
operator|)
operator|<=
name|chunk_npages
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|PAGE
operator|||
name|arena_mapbits_large_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
operator|(
name|ret
operator|>>
name|LG_PAGE
operator|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|binind
operator|==
name|arena_mapbits_binind_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
operator|(
name|ret
operator|>>
name|LG_PAGE
operator|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|==
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
operator|(
name|ret
operator|>>
name|LG_PAGE
operator|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Small allocation (possibly promoted to a large object due to 		 * prof_promote). 		 */
name|assert
argument_list|(
name|arena_mapbits_large_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|!=
literal|0
operator|||
name|arena_ptr_small_binind_get
argument_list|(
name|ptr
argument_list|,
name|arena_mapbits_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
argument_list|)
operator|==
name|binind
argument_list|)
expr_stmt|;
name|ret
operator|=
name|arena_bin_info
index|[
name|binind
index|]
operator|.
name|reg_size
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|void
name|arena_dalloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|bool
name|try_tcache
parameter_list|)
block|{
name|size_t
name|pageind
decl_stmt|,
name|mapbits
decl_stmt|;
name|tcache_t
modifier|*
name|tcache
decl_stmt|;
name|assert
argument_list|(
name|arena
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|chunk
operator|->
name|arena
operator|==
name|arena
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
operator|!=
name|ptr
argument_list|)
expr_stmt|;
name|pageind
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|LG_PAGE
expr_stmt|;
name|mapbits
operator|=
name|arena_mapbits_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_allocated_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mapbits
operator|&
name|CHUNK_MAP_LARGE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Small allocation. */
if|if
condition|(
name|try_tcache
operator|&&
operator|(
name|tcache
operator|=
name|tcache_get
argument_list|(
name|false
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|binind
decl_stmt|;
name|binind
operator|=
name|arena_ptr_small_binind_get
argument_list|(
name|ptr
argument_list|,
name|mapbits
argument_list|)
expr_stmt|;
name|tcache_dalloc_small
argument_list|(
name|tcache
argument_list|,
name|ptr
argument_list|,
name|binind
argument_list|)
expr_stmt|;
block|}
else|else
name|arena_dalloc_small
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|ptr
argument_list|,
name|pageind
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|size
init|=
name|arena_mapbits_large_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
decl_stmt|;
name|assert
argument_list|(
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|try_tcache
operator|&&
name|size
operator|<=
name|tcache_maxclass
operator|&&
operator|(
name|tcache
operator|=
name|tcache_get
argument_list|(
name|false
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|tcache_dalloc_large
argument_list|(
name|tcache
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
name|arena_dalloc_large
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JEMALLOC_ARENA_INLINE_B */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JEMALLOC_H_INLINES */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

end_unit

