begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|JEMALLOC_INTERNAL_PROF_INLINES_B_H
end_ifndef

begin_define
define|#
directive|define
name|JEMALLOC_INTERNAL_PROF_INLINES_B_H
end_define

begin_include
include|#
directive|include
file|"jemalloc/internal/sz.h"
end_include

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|bool
name|prof_active_get_unlocked
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Even if opt_prof is true, sampling can be temporarily disabled by 	 * setting prof_active to false.  No locking is used when reading 	 * prof_active in the fast path, so there are no guarantees regarding 	 * how long it will take for all threads to notice state changes. 	 */
return|return
name|prof_active
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|bool
name|prof_gdump_get_unlocked
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * No locking is used when reading prof_gdump_val in the fast path, so 	 * there are no guarantees regarding how long it will take for all 	 * threads to notice state changes. 	 */
return|return
name|prof_gdump_val
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|prof_tdata_t
modifier|*
name|prof_tdata_get
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|bool
name|create
parameter_list|)
block|{
name|prof_tdata_t
modifier|*
name|tdata
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|tdata
operator|=
name|tsd_prof_tdata_get
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
if|if
condition|(
name|create
condition|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|tdata
operator|==
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
name|tsd_nominal
argument_list|(
name|tsd
argument_list|)
condition|)
block|{
name|tdata
operator|=
name|prof_tdata_init
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
name|tsd_prof_tdata_set
argument_list|(
name|tsd
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|unlikely
argument_list|(
name|tdata
operator|->
name|expired
argument_list|)
condition|)
block|{
name|tdata
operator|=
name|prof_tdata_reinit
argument_list|(
name|tsd
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
name|tsd_prof_tdata_set
argument_list|(
name|tsd
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|tdata
operator|==
name|NULL
operator|||
name|tdata
operator|->
name|attached
argument_list|)
expr_stmt|;
block|}
return|return
name|tdata
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|prof_tctx_t
modifier|*
name|prof_tctx_get
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|alloc_ctx_t
modifier|*
name|alloc_ctx
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|arena_prof_tctx_get
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|,
name|alloc_ctx
argument_list|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|void
name|prof_tctx_set
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|alloc_ctx_t
modifier|*
name|alloc_ctx
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|arena_prof_tctx_set
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|,
name|alloc_ctx
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|void
name|prof_tctx_reset
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|arena_prof_tctx_reset
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|bool
name|prof_sample_accum_update
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|bool
name|update
parameter_list|,
name|prof_tdata_t
modifier|*
modifier|*
name|tdata_out
parameter_list|)
block|{
name|prof_tdata_t
modifier|*
name|tdata
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|tdata
operator|=
name|prof_tdata_get
argument_list|(
name|tsd
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|uintptr_t
operator|)
name|tdata
operator|<=
operator|(
name|uintptr_t
operator|)
name|PROF_TDATA_STATE_MAX
argument_list|)
condition|)
block|{
name|tdata
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|tdata_out
operator|!=
name|NULL
condition|)
block|{
operator|*
name|tdata_out
operator|=
name|tdata
expr_stmt|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|tdata
operator|==
name|NULL
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
if|if
condition|(
name|likely
argument_list|(
name|tdata
operator|->
name|bytes_until_sample
operator|>=
name|usize
argument_list|)
condition|)
block|{
if|if
condition|(
name|update
condition|)
block|{
name|tdata
operator|->
name|bytes_until_sample
operator|-=
name|usize
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
else|else
block|{
if|if
condition|(
name|tsd_reentrancy_level_get
argument_list|(
name|tsd
argument_list|)
operator|>
literal|0
condition|)
block|{
return|return
name|true
return|;
block|}
comment|/* Compute new sample threshold. */
if|if
condition|(
name|update
condition|)
block|{
name|prof_sample_threshold_update
argument_list|(
name|tdata
argument_list|)
expr_stmt|;
block|}
return|return
operator|!
name|tdata
operator|->
name|active
return|;
block|}
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|prof_tctx_t
modifier|*
name|prof_alloc_prep
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|bool
name|prof_active
parameter_list|,
name|bool
name|update
parameter_list|)
block|{
name|prof_tctx_t
modifier|*
name|ret
decl_stmt|;
name|prof_tdata_t
modifier|*
name|tdata
decl_stmt|;
name|prof_bt_t
name|bt
decl_stmt|;
name|assert
argument_list|(
name|usize
operator|==
name|sz_s2u
argument_list|(
name|usize
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prof_active
operator|||
name|likely
argument_list|(
name|prof_sample_accum_update
argument_list|(
name|tsd
argument_list|,
name|usize
argument_list|,
name|update
argument_list|,
operator|&
name|tdata
argument_list|)
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|(
name|prof_tctx_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
literal|1U
expr_stmt|;
block|}
else|else
block|{
name|bt_init
argument_list|(
operator|&
name|bt
argument_list|,
name|tdata
operator|->
name|vec
argument_list|)
expr_stmt|;
name|prof_backtrace
argument_list|(
operator|&
name|bt
argument_list|)
expr_stmt|;
name|ret
operator|=
name|prof_lookup
argument_list|(
name|tsd
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|void
name|prof_malloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|alloc_ctx_t
modifier|*
name|alloc_ctx
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|usize
operator|==
name|isalloc
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|uintptr_t
operator|)
name|tctx
operator|>
operator|(
name|uintptr_t
operator|)
literal|1U
argument_list|)
condition|)
block|{
name|prof_malloc_sample_object
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prof_tctx_set
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|,
name|alloc_ctx
argument_list|,
operator|(
name|prof_tctx_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
literal|1U
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|void
name|prof_realloc
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|,
name|bool
name|prof_active
parameter_list|,
name|bool
name|updated
parameter_list|,
specifier|const
name|void
modifier|*
name|old_ptr
parameter_list|,
name|size_t
name|old_usize
parameter_list|,
name|prof_tctx_t
modifier|*
name|old_tctx
parameter_list|)
block|{
name|bool
name|sampled
decl_stmt|,
name|old_sampled
decl_stmt|,
name|moved
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
operator|||
operator|(
name|uintptr_t
operator|)
name|tctx
operator|<=
operator|(
name|uintptr_t
operator|)
literal|1U
argument_list|)
expr_stmt|;
if|if
condition|(
name|prof_active
operator|&&
operator|!
name|updated
operator|&&
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|usize
operator|==
name|isalloc
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prof_sample_accum_update
argument_list|(
name|tsd
argument_list|,
name|usize
argument_list|,
name|true
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
comment|/* 			 * Don't sample.  The usize passed to prof_alloc_prep() 			 * was larger than what actually got allocated, so a 			 * backtrace was captured for this allocation, even 			 * though its actual usize was insufficient to cross the 			 * sample threshold. 			 */
name|prof_alloc_rollback
argument_list|(
name|tsd
argument_list|,
name|tctx
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|tctx
operator|=
operator|(
name|prof_tctx_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
literal|1U
expr_stmt|;
block|}
block|}
name|sampled
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|tctx
operator|>
operator|(
name|uintptr_t
operator|)
literal|1U
operator|)
expr_stmt|;
name|old_sampled
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|old_tctx
operator|>
operator|(
name|uintptr_t
operator|)
literal|1U
operator|)
expr_stmt|;
name|moved
operator|=
operator|(
name|ptr
operator|!=
name|old_ptr
operator|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|sampled
argument_list|)
condition|)
block|{
name|prof_malloc_sample_object
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|moved
condition|)
block|{
name|prof_tctx_set
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|,
name|NULL
argument_list|,
operator|(
name|prof_tctx_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
literal|1U
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unlikely
argument_list|(
name|old_sampled
argument_list|)
condition|)
block|{
comment|/* 		 * prof_tctx_set() would work for the !moved case as well, but 		 * prof_tctx_reset() is slightly cheaper, and the proper thing 		 * to do here in the presence of explicit knowledge re: moved 		 * state. 		 */
name|prof_tctx_reset
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
operator|(
name|uintptr_t
operator|)
name|prof_tctx_get
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|NULL
argument_list|)
operator|==
operator|(
name|uintptr_t
operator|)
literal|1U
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The prof_free_sampled_object() call must come after the 	 * prof_malloc_sample_object() call, because tctx and old_tctx may be 	 * the same, in which case reversing the call order could cause the tctx 	 * to be prematurely destroyed as a side effect of momentarily zeroed 	 * counters. 	 */
if|if
condition|(
name|unlikely
argument_list|(
name|old_sampled
argument_list|)
condition|)
block|{
name|prof_free_sampled_object
argument_list|(
name|tsd
argument_list|,
name|old_usize
argument_list|,
name|old_tctx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|void
name|prof_free
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|alloc_ctx_t
modifier|*
name|alloc_ctx
parameter_list|)
block|{
name|prof_tctx_t
modifier|*
name|tctx
init|=
name|prof_tctx_get
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|alloc_ctx
argument_list|)
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|usize
operator|==
name|isalloc
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|uintptr_t
operator|)
name|tctx
operator|>
operator|(
name|uintptr_t
operator|)
literal|1U
argument_list|)
condition|)
block|{
name|prof_free_sampled_object
argument_list|(
name|tsd
argument_list|,
name|usize
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JEMALLOC_INTERNAL_PROF_INLINES_B_H */
end_comment

end_unit

