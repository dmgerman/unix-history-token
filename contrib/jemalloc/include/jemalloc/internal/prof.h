begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_H_TYPES
end_ifdef

begin_typedef
typedef|typedef
name|struct
name|prof_bt_s
name|prof_bt_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|prof_cnt_s
name|prof_cnt_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|prof_thr_cnt_s
name|prof_thr_cnt_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|prof_ctx_s
name|prof_ctx_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|prof_tdata_s
name|prof_tdata_t
typedef|;
end_typedef

begin_comment
comment|/* Option defaults. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_PROF
end_ifdef

begin_define
define|#
directive|define
name|PROF_PREFIX_DEFAULT
value|"jeprof"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PROF_PREFIX_DEFAULT
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|LG_PROF_SAMPLE_DEFAULT
value|19
end_define

begin_define
define|#
directive|define
name|LG_PROF_INTERVAL_DEFAULT
value|-1
end_define

begin_comment
comment|/*  * Hard limit on stack backtrace depth.  The version of prof_backtrace() that  * is based on __builtin_return_address() necessarily has a hard-coded number  * of backtrace frame handlers, and should be kept in sync with this setting.  */
end_comment

begin_define
define|#
directive|define
name|PROF_BT_MAX
value|128
end_define

begin_comment
comment|/* Maximum number of backtraces to store in each per thread LRU cache. */
end_comment

begin_define
define|#
directive|define
name|PROF_TCMAX
value|1024
end_define

begin_comment
comment|/* Initial hash table size. */
end_comment

begin_define
define|#
directive|define
name|PROF_CKH_MINITEMS
value|64
end_define

begin_comment
comment|/* Size of memory buffer to use when writing dump files. */
end_comment

begin_define
define|#
directive|define
name|PROF_DUMP_BUFSIZE
value|65536
end_define

begin_comment
comment|/* Size of stack-allocated buffer used by prof_printf(). */
end_comment

begin_define
define|#
directive|define
name|PROF_PRINTF_BUFSIZE
value|128
end_define

begin_comment
comment|/*  * Number of mutexes shared among all ctx's.  No space is allocated for these  * unless profiling is enabled, so it's okay to over-provision.  */
end_comment

begin_define
define|#
directive|define
name|PROF_NCTX_LOCKS
value|1024
end_define

begin_comment
comment|/*  * prof_tdata pointers close to NULL are used to encode state information that  * is used for cleaning up during thread shutdown.  */
end_comment

begin_define
define|#
directive|define
name|PROF_TDATA_STATE_REINCARNATED
value|((prof_tdata_t *)(uintptr_t)1)
end_define

begin_define
define|#
directive|define
name|PROF_TDATA_STATE_PURGATORY
value|((prof_tdata_t *)(uintptr_t)2)
end_define

begin_define
define|#
directive|define
name|PROF_TDATA_STATE_MAX
value|PROF_TDATA_STATE_PURGATORY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JEMALLOC_H_TYPES */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_H_STRUCTS
end_ifdef

begin_struct
struct|struct
name|prof_bt_s
block|{
comment|/* Backtrace, stored as len program counters. */
name|void
modifier|*
modifier|*
name|vec
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_PROF_LIBGCC
end_ifdef

begin_comment
comment|/* Data structure passed to libgcc _Unwind_Backtrace() callback functions. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|prof_bt_t
modifier|*
name|bt
decl_stmt|;
name|unsigned
name|nignore
decl_stmt|;
name|unsigned
name|max
decl_stmt|;
block|}
name|prof_unwind_data_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|prof_cnt_s
block|{
comment|/* 	 * Profiling counters.  An allocation/deallocation pair can operate on 	 * different prof_thr_cnt_t objects that are linked into the same 	 * prof_ctx_t cnts_ql, so it is possible for the cur* counters to go 	 * negative.  In principle it is possible for the *bytes counters to 	 * overflow/underflow, but a general solution would require something 	 * like 128-bit counters; this implementation doesn't bother to solve 	 * that problem. 	 */
name|int64_t
name|curobjs
decl_stmt|;
name|int64_t
name|curbytes
decl_stmt|;
name|uint64_t
name|accumobjs
decl_stmt|;
name|uint64_t
name|accumbytes
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|prof_thr_cnt_s
block|{
comment|/* Linkage into prof_ctx_t's cnts_ql. */
name|ql_elm
argument_list|(
argument|prof_thr_cnt_t
argument_list|)
name|cnts_link
expr_stmt|;
comment|/* Linkage into thread's LRU. */
name|ql_elm
argument_list|(
argument|prof_thr_cnt_t
argument_list|)
name|lru_link
expr_stmt|;
comment|/* 	 * Associated context.  If a thread frees an object that it did not 	 * allocate, it is possible that the context is not cached in the 	 * thread's hash table, in which case it must be able to look up the 	 * context, insert a new prof_thr_cnt_t into the thread's hash table, 	 * and link it into the prof_ctx_t's cnts_ql. 	 */
name|prof_ctx_t
modifier|*
name|ctx
decl_stmt|;
comment|/* 	 * Threads use memory barriers to update the counters.  Since there is 	 * only ever one writer, the only challenge is for the reader to get a 	 * consistent read of the counters. 	 * 	 * The writer uses this series of operations: 	 * 	 * 1) Increment epoch to an odd number. 	 * 2) Update counters. 	 * 3) Increment epoch to an even number. 	 * 	 * The reader must assure 1) that the epoch is even while it reads the 	 * counters, and 2) that the epoch doesn't change between the time it 	 * starts and finishes reading the counters. 	 */
name|unsigned
name|epoch
decl_stmt|;
comment|/* Profiling counters. */
name|prof_cnt_t
name|cnts
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|prof_ctx_s
block|{
comment|/* Associated backtrace. */
name|prof_bt_t
modifier|*
name|bt
decl_stmt|;
comment|/* Protects nlimbo, cnt_merged, and cnts_ql. */
name|malloc_mutex_t
modifier|*
name|lock
decl_stmt|;
comment|/* 	 * Number of threads that currently cause this ctx to be in a state of 	 * limbo due to one of: 	 *   - Initializing per thread counters associated with this ctx. 	 *   - Preparing to destroy this ctx. 	 *   - Dumping a heap profile that includes this ctx. 	 * nlimbo must be 1 (single destroyer) in order to safely destroy the 	 * ctx. 	 */
name|unsigned
name|nlimbo
decl_stmt|;
comment|/* Temporary storage for summation during dump. */
name|prof_cnt_t
name|cnt_summed
decl_stmt|;
comment|/* When threads exit, they merge their stats into cnt_merged. */
name|prof_cnt_t
name|cnt_merged
decl_stmt|;
comment|/* 	 * List of profile counters, one for each thread that has allocated in 	 * this context. 	 */
name|ql_head
argument_list|(
argument|prof_thr_cnt_t
argument_list|)
name|cnts_ql
expr_stmt|;
comment|/* Linkage for list of contexts to be dumped. */
name|ql_elm
argument_list|(
argument|prof_ctx_t
argument_list|)
name|dump_link
expr_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|ql_head
argument_list|(
argument|prof_ctx_t
argument_list|)
name|prof_ctx_list_t
expr_stmt|;
end_typedef

begin_struct
struct|struct
name|prof_tdata_s
block|{
comment|/* 	 * Hash of (prof_bt_t *)-->(prof_thr_cnt_t *).  Each thread keeps a 	 * cache of backtraces, with associated thread-specific prof_thr_cnt_t 	 * objects.  Other threads may read the prof_thr_cnt_t contents, but no 	 * others will ever write them. 	 * 	 * Upon thread exit, the thread must merge all the prof_thr_cnt_t 	 * counter data into the associated prof_ctx_t objects, and unlink/free 	 * the prof_thr_cnt_t objects. 	 */
name|ckh_t
name|bt2cnt
decl_stmt|;
comment|/* LRU for contents of bt2cnt. */
name|ql_head
argument_list|(
argument|prof_thr_cnt_t
argument_list|)
name|lru_ql
expr_stmt|;
comment|/* Backtrace vector, used for calls to prof_backtrace(). */
name|void
modifier|*
modifier|*
name|vec
decl_stmt|;
comment|/* Sampling state. */
name|uint64_t
name|prng_state
decl_stmt|;
name|uint64_t
name|threshold
decl_stmt|;
name|uint64_t
name|accum
decl_stmt|;
comment|/* State used to avoid dumping while operating on prof internals. */
name|bool
name|enq
decl_stmt|;
name|bool
name|enq_idump
decl_stmt|;
name|bool
name|enq_gdump
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JEMALLOC_H_STRUCTS */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_H_EXTERNS
end_ifdef

begin_decl_stmt
specifier|extern
name|bool
name|opt_prof
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Even if opt_prof is true, sampling can be temporarily disabled by setting  * opt_prof_active to false.  No locking is used when updating opt_prof_active,  * so there are no guarantees regarding how long it will take for all threads  * to notice state changes.  */
end_comment

begin_decl_stmt
specifier|extern
name|bool
name|opt_prof_active
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|size_t
name|opt_lg_prof_sample
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mean bytes between samples. */
end_comment

begin_decl_stmt
specifier|extern
name|ssize_t
name|opt_lg_prof_interval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lg(prof_interval). */
end_comment

begin_decl_stmt
specifier|extern
name|bool
name|opt_prof_gdump
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* High-water memory dumping. */
end_comment

begin_decl_stmt
specifier|extern
name|bool
name|opt_prof_final
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Final profile dumping. */
end_comment

begin_decl_stmt
specifier|extern
name|bool
name|opt_prof_leak
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dump leak summary at exit. */
end_comment

begin_decl_stmt
specifier|extern
name|bool
name|opt_prof_accum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Report cumulative bytes. */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|opt_prof_prefix
index|[
comment|/* Minimize memory bloat for non-prof builds. */
ifdef|#
directive|ifdef
name|JEMALLOC_PROF
name|PATH_MAX
operator|+
endif|#
directive|endif
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Profile dump interval, measured in bytes allocated.  Each arena triggers a  * profile dump when it reaches this threshold.  The effect is that the  * interval between profile dumps averages prof_interval, though the actual  * interval between dumps will tend to be sporadic, and the interval will be a  * maximum of approximately (prof_interval * narenas).  */
end_comment

begin_decl_stmt
specifier|extern
name|uint64_t
name|prof_interval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * If true, promote small sampled objects to large objects, since small run  * headers do not have embedded profile context pointers.  */
end_comment

begin_decl_stmt
specifier|extern
name|bool
name|prof_promote
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|bt_init
parameter_list|(
name|prof_bt_t
modifier|*
name|bt
parameter_list|,
name|void
modifier|*
modifier|*
name|vec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_backtrace
parameter_list|(
name|prof_bt_t
modifier|*
name|bt
parameter_list|,
name|unsigned
name|nignore
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|prof_thr_cnt_t
modifier|*
name|prof_lookup
parameter_list|(
name|prof_bt_t
modifier|*
name|bt
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_JET
end_ifdef

begin_function_decl
name|size_t
name|prof_bt_count
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
name|int
function_decl|(
name|prof_dump_open_t
function_decl|)
parameter_list|(
name|bool
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|extern
name|prof_dump_open_t
modifier|*
name|prof_dump_open
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|prof_idump
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|prof_mdump
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_gdump
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|prof_tdata_t
modifier|*
name|prof_tdata_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_tdata_cleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_boot0
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_boot1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|prof_boot2
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_prefork
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_postfork_parent
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_postfork_child
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JEMALLOC_H_EXTERNS */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_H_INLINES
end_ifdef

begin_define
define|#
directive|define
name|PROF_ALLOC_PREP
parameter_list|(
name|nignore
parameter_list|,
name|size
parameter_list|,
name|ret
parameter_list|)
value|do {			\ 	prof_tdata_t *prof_tdata;					\ 	prof_bt_t bt;							\ 									\ 	assert(size == s2u(size));					\ 									\ 	prof_tdata = prof_tdata_get(true);				\ 	if ((uintptr_t)prof_tdata<= (uintptr_t)PROF_TDATA_STATE_MAX) {	\ 		if (prof_tdata != NULL)					\ 			ret = (prof_thr_cnt_t *)(uintptr_t)1U;		\ 		else							\ 			ret = NULL;					\ 		break;							\ 	}								\ 									\ 	if (opt_prof_active == false) {					\
comment|/* Sampling is currently inactive, so avoid sampling. */
value|\ 		ret = (prof_thr_cnt_t *)(uintptr_t)1U;			\ 	} else if (opt_lg_prof_sample == 0) {				\
comment|/* Don't bother with sampling logic, since sampling   */
value|\
comment|/* interval is 1.                                     */
value|\ 		bt_init(&bt, prof_tdata->vec);				\ 		prof_backtrace(&bt, nignore);				\ 		ret = prof_lookup(&bt);					\ 	} else {							\ 		if (prof_tdata->threshold == 0) {			\
comment|/* Initialize.  Seed the prng differently for */
value|\
comment|/* each thread.                               */
value|\ 			prof_tdata->prng_state =			\ 			    (uint64_t)(uintptr_t)&size;			\ 			prof_sample_threshold_update(prof_tdata);	\ 		}							\ 									\
comment|/* Determine whether to capture a backtrace based on  */
value|\
comment|/* whether size is enough for prof_accum to reach     */
value|\
comment|/* prof_tdata->threshold.  However, delay updating    */
value|\
comment|/* these variables until prof_{m,re}alloc(), because  */
value|\
comment|/* we don't know for sure that the allocation will    */
value|\
comment|/* succeed.                                           */
value|\
comment|/*                                                    */
value|\
comment|/* Use subtraction rather than addition to avoid      */
value|\
comment|/* potential integer overflow.                        */
value|\ 		if (size>= prof_tdata->threshold -			\ 		    prof_tdata->accum) {				\ 			bt_init(&bt, prof_tdata->vec);			\ 			prof_backtrace(&bt, nignore);			\ 			ret = prof_lookup(&bt);				\ 		} else							\ 			ret = (prof_thr_cnt_t *)(uintptr_t)1U;		\ 	}								\ } while (0)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|JEMALLOC_ENABLE_INLINE
end_ifndef

begin_macro
name|malloc_tsd_protos
argument_list|(
argument|JEMALLOC_ATTR(unused)
argument_list|,
argument|prof_tdata
argument_list|,
argument|prof_tdata_t *
argument_list|)
end_macro

begin_function_decl
name|prof_tdata_t
modifier|*
name|prof_tdata_get
parameter_list|(
name|bool
name|create
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_sample_threshold_update
parameter_list|(
name|prof_tdata_t
modifier|*
name|prof_tdata
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|prof_ctx_t
modifier|*
name|prof_ctx_get
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_ctx_set
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|prof_ctx_t
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|prof_sample_accum_update
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_malloc
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|prof_thr_cnt_t
modifier|*
name|cnt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_realloc
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|prof_thr_cnt_t
modifier|*
name|cnt
parameter_list|,
name|size_t
name|old_usize
parameter_list|,
name|prof_ctx_t
modifier|*
name|old_ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_free
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|JEMALLOC_ENABLE_INLINE
argument_list|)
operator|||
name|defined
argument_list|(
name|JEMALLOC_PROF_C_
argument_list|)
operator|)
end_if

begin_comment
comment|/* Thread-specific backtrace cache, used to reduce bt2ctx contention. */
end_comment

begin_macro
name|malloc_tsd_externs
argument_list|(
argument|prof_tdata
argument_list|,
argument|prof_tdata_t *
argument_list|)
end_macro

begin_macro
name|malloc_tsd_funcs
argument_list|(
argument|JEMALLOC_INLINE
argument_list|,
argument|prof_tdata
argument_list|,
argument|prof_tdata_t *
argument_list|,
argument|NULL
argument_list|,
argument|prof_tdata_cleanup
argument_list|)
end_macro

begin_function
name|JEMALLOC_INLINE
name|prof_tdata_t
modifier|*
name|prof_tdata_get
parameter_list|(
name|bool
name|create
parameter_list|)
block|{
name|prof_tdata_t
modifier|*
name|prof_tdata
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|prof_tdata
operator|=
operator|*
name|prof_tdata_tsd_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|create
operator|&&
name|prof_tdata
operator|==
name|NULL
condition|)
name|prof_tdata
operator|=
name|prof_tdata_init
argument_list|()
expr_stmt|;
return|return
operator|(
name|prof_tdata
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_INLINE
name|void
name|prof_sample_threshold_update
parameter_list|(
name|prof_tdata_t
modifier|*
name|prof_tdata
parameter_list|)
block|{
comment|/* 	 * The body of this function is compiled out unless heap profiling is 	 * enabled, so that it is possible to compile jemalloc with floating 	 * point support completely disabled.  Avoiding floating point code is 	 * important on memory-constrained systems, but it also enables a 	 * workaround for versions of glibc that don't properly save/restore 	 * floating point registers during dynamic lazy symbol loading (which 	 * internally calls into whatever malloc implementation happens to be 	 * integrated into the application).  Note that some compilers (e.g. 	 * gcc 4.8) may use floating point registers for fast memory moves, so 	 * jemalloc must be compiled with such optimizations disabled (e.g. 	 * -mno-sse) in order for the workaround to be complete. 	 */
ifdef|#
directive|ifdef
name|JEMALLOC_PROF
name|uint64_t
name|r
decl_stmt|;
name|double
name|u
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
comment|/* 	 * Compute sample threshold as a geometrically distributed random 	 * variable with mean (2^opt_lg_prof_sample). 	 * 	 *                         __        __ 	 *                         |  log(u)  |                     1 	 * prof_tdata->threshold = | -------- |, where p = ------------------- 	 *                         | log(1-p) |             opt_lg_prof_sample 	 *                                                 2 	 * 	 * For more information on the math, see: 	 * 	 *   Non-Uniform Random Variate Generation 	 *   Luc Devroye 	 *   Springer-Verlag, New York, 1986 	 *   pp 500 	 *   (http://luc.devroye.org/rnbookindex.html) 	 */
name|prng64
argument_list|(
name|r
argument_list|,
literal|53
argument_list|,
name|prof_tdata
operator|->
name|prng_state
argument_list|,
name|UINT64_C
argument_list|(
literal|6364136223846793005
argument_list|)
argument_list|,
name|UINT64_C
argument_list|(
literal|1442695040888963407
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|=
operator|(
name|double
operator|)
name|r
operator|*
operator|(
literal|1.0
operator|/
literal|9007199254740992.0L
operator|)
expr_stmt|;
name|prof_tdata
operator|->
name|threshold
operator|=
call|(
name|uint64_t
call|)
argument_list|(
name|log
argument_list|(
name|u
argument_list|)
operator|/
name|log
argument_list|(
literal|1.0
operator|-
operator|(
literal|1.0
operator|/
call|(
name|double
call|)
argument_list|(
operator|(
name|uint64_t
operator|)
literal|1U
operator|<<
name|opt_lg_prof_sample
argument_list|)
operator|)
argument_list|)
argument_list|)
operator|+
operator|(
name|uint64_t
operator|)
literal|1U
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|JEMALLOC_INLINE
name|prof_ctx_t
modifier|*
name|prof_ctx_get
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|prof_ctx_t
modifier|*
name|ret
decl_stmt|;
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|!=
name|ptr
condition|)
block|{
comment|/* Region. */
name|ret
operator|=
name|arena_prof_ctx_get
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|huge_prof_ctx_get
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_INLINE
name|void
name|prof_ctx_set
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|prof_ctx_t
modifier|*
name|ctx
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|!=
name|ptr
condition|)
block|{
comment|/* Region. */
name|arena_prof_ctx_set
argument_list|(
name|ptr
argument_list|,
name|usize
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
else|else
name|huge_prof_ctx_set
argument_list|(
name|ptr
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_INLINE
name|bool
name|prof_sample_accum_update
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|prof_tdata_t
modifier|*
name|prof_tdata
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
comment|/* Sampling logic is unnecessary if the interval is 1. */
name|assert
argument_list|(
name|opt_lg_prof_sample
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|prof_tdata
operator|=
name|prof_tdata_get
argument_list|(
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|prof_tdata
operator|<=
operator|(
name|uintptr_t
operator|)
name|PROF_TDATA_STATE_MAX
condition|)
return|return
operator|(
name|true
operator|)
return|;
comment|/* Take care to avoid integer overflow. */
if|if
condition|(
name|size
operator|>=
name|prof_tdata
operator|->
name|threshold
operator|-
name|prof_tdata
operator|->
name|accum
condition|)
block|{
name|prof_tdata
operator|->
name|accum
operator|-=
operator|(
name|prof_tdata
operator|->
name|threshold
operator|-
name|size
operator|)
expr_stmt|;
comment|/* Compute new sample threshold. */
name|prof_sample_threshold_update
argument_list|(
name|prof_tdata
argument_list|)
expr_stmt|;
while|while
condition|(
name|prof_tdata
operator|->
name|accum
operator|>=
name|prof_tdata
operator|->
name|threshold
condition|)
block|{
name|prof_tdata
operator|->
name|accum
operator|-=
name|prof_tdata
operator|->
name|threshold
expr_stmt|;
name|prof_sample_threshold_update
argument_list|(
name|prof_tdata
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
else|else
block|{
name|prof_tdata
operator|->
name|accum
operator|+=
name|size
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
block|}
end_function

begin_function
name|JEMALLOC_INLINE
name|void
name|prof_malloc
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|prof_thr_cnt_t
modifier|*
name|cnt
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|usize
operator|==
name|isalloc
argument_list|(
name|ptr
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_lg_prof_sample
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|prof_sample_accum_update
argument_list|(
name|usize
argument_list|)
condition|)
block|{
comment|/* 			 * Don't sample.  For malloc()-like allocation, it is 			 * always possible to tell in advance how large an 			 * object's usable size will be, so there should never 			 * be a difference between the usize passed to 			 * PROF_ALLOC_PREP() and prof_malloc(). 			 */
name|assert
argument_list|(
operator|(
name|uintptr_t
operator|)
name|cnt
operator|==
operator|(
name|uintptr_t
operator|)
literal|1U
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|cnt
operator|>
operator|(
name|uintptr_t
operator|)
literal|1U
condition|)
block|{
name|prof_ctx_set
argument_list|(
name|ptr
argument_list|,
name|usize
argument_list|,
name|cnt
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|cnt
operator|->
name|epoch
operator|++
expr_stmt|;
comment|/*********/
name|mb_write
argument_list|()
expr_stmt|;
comment|/*********/
name|cnt
operator|->
name|cnts
operator|.
name|curobjs
operator|++
expr_stmt|;
name|cnt
operator|->
name|cnts
operator|.
name|curbytes
operator|+=
name|usize
expr_stmt|;
if|if
condition|(
name|opt_prof_accum
condition|)
block|{
name|cnt
operator|->
name|cnts
operator|.
name|accumobjs
operator|++
expr_stmt|;
name|cnt
operator|->
name|cnts
operator|.
name|accumbytes
operator|+=
name|usize
expr_stmt|;
block|}
comment|/*********/
name|mb_write
argument_list|()
expr_stmt|;
comment|/*********/
name|cnt
operator|->
name|epoch
operator|++
expr_stmt|;
comment|/*********/
name|mb_write
argument_list|()
expr_stmt|;
comment|/*********/
block|}
else|else
name|prof_ctx_set
argument_list|(
name|ptr
argument_list|,
name|usize
argument_list|,
operator|(
name|prof_ctx_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
literal|1U
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_INLINE
name|void
name|prof_realloc
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|prof_thr_cnt_t
modifier|*
name|cnt
parameter_list|,
name|size_t
name|old_usize
parameter_list|,
name|prof_ctx_t
modifier|*
name|old_ctx
parameter_list|)
block|{
name|prof_thr_cnt_t
modifier|*
name|told_cnt
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
operator|||
operator|(
name|uintptr_t
operator|)
name|cnt
operator|<=
operator|(
name|uintptr_t
operator|)
literal|1U
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|usize
operator|==
name|isalloc
argument_list|(
name|ptr
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_lg_prof_sample
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|prof_sample_accum_update
argument_list|(
name|usize
argument_list|)
condition|)
block|{
comment|/* 				 * Don't sample.  The usize passed to 				 * PROF_ALLOC_PREP() was larger than what 				 * actually got allocated, so a backtrace was 				 * captured for this allocation, even though 				 * its actual usize was insufficient to cross 				 * the sample threshold. 				 */
name|cnt
operator|=
operator|(
name|prof_thr_cnt_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
literal|1U
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|old_ctx
operator|>
operator|(
name|uintptr_t
operator|)
literal|1U
condition|)
block|{
name|told_cnt
operator|=
name|prof_lookup
argument_list|(
name|old_ctx
operator|->
name|bt
argument_list|)
expr_stmt|;
if|if
condition|(
name|told_cnt
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * It's too late to propagate OOM for this realloc(), 			 * so operate directly on old_cnt->ctx->cnt_merged. 			 */
name|malloc_mutex_lock
argument_list|(
name|old_ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|old_ctx
operator|->
name|cnt_merged
operator|.
name|curobjs
operator|--
expr_stmt|;
name|old_ctx
operator|->
name|cnt_merged
operator|.
name|curbytes
operator|-=
name|old_usize
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|old_ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|told_cnt
operator|=
operator|(
name|prof_thr_cnt_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
literal|1U
expr_stmt|;
block|}
block|}
else|else
name|told_cnt
operator|=
operator|(
name|prof_thr_cnt_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
literal|1U
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|told_cnt
operator|>
operator|(
name|uintptr_t
operator|)
literal|1U
condition|)
name|told_cnt
operator|->
name|epoch
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|cnt
operator|>
operator|(
name|uintptr_t
operator|)
literal|1U
condition|)
block|{
name|prof_ctx_set
argument_list|(
name|ptr
argument_list|,
name|usize
argument_list|,
name|cnt
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|cnt
operator|->
name|epoch
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
name|prof_ctx_set
argument_list|(
name|ptr
argument_list|,
name|usize
argument_list|,
operator|(
name|prof_ctx_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
literal|1U
argument_list|)
expr_stmt|;
comment|/*********/
name|mb_write
argument_list|()
expr_stmt|;
comment|/*********/
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|told_cnt
operator|>
operator|(
name|uintptr_t
operator|)
literal|1U
condition|)
block|{
name|told_cnt
operator|->
name|cnts
operator|.
name|curobjs
operator|--
expr_stmt|;
name|told_cnt
operator|->
name|cnts
operator|.
name|curbytes
operator|-=
name|old_usize
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|cnt
operator|>
operator|(
name|uintptr_t
operator|)
literal|1U
condition|)
block|{
name|cnt
operator|->
name|cnts
operator|.
name|curobjs
operator|++
expr_stmt|;
name|cnt
operator|->
name|cnts
operator|.
name|curbytes
operator|+=
name|usize
expr_stmt|;
if|if
condition|(
name|opt_prof_accum
condition|)
block|{
name|cnt
operator|->
name|cnts
operator|.
name|accumobjs
operator|++
expr_stmt|;
name|cnt
operator|->
name|cnts
operator|.
name|accumbytes
operator|+=
name|usize
expr_stmt|;
block|}
block|}
comment|/*********/
name|mb_write
argument_list|()
expr_stmt|;
comment|/*********/
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|told_cnt
operator|>
operator|(
name|uintptr_t
operator|)
literal|1U
condition|)
name|told_cnt
operator|->
name|epoch
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|cnt
operator|>
operator|(
name|uintptr_t
operator|)
literal|1U
condition|)
name|cnt
operator|->
name|epoch
operator|++
expr_stmt|;
comment|/*********/
name|mb_write
argument_list|()
expr_stmt|;
comment|/* Not strictly necessary. */
block|}
end_function

begin_function
name|JEMALLOC_INLINE
name|void
name|prof_free
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|prof_ctx_t
modifier|*
name|ctx
init|=
name|prof_ctx_get
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|ctx
operator|>
operator|(
name|uintptr_t
operator|)
literal|1
condition|)
block|{
name|prof_thr_cnt_t
modifier|*
name|tcnt
decl_stmt|;
name|assert
argument_list|(
name|size
operator|==
name|isalloc
argument_list|(
name|ptr
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
name|tcnt
operator|=
name|prof_lookup
argument_list|(
name|ctx
operator|->
name|bt
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcnt
operator|!=
name|NULL
condition|)
block|{
name|tcnt
operator|->
name|epoch
operator|++
expr_stmt|;
comment|/*********/
name|mb_write
argument_list|()
expr_stmt|;
comment|/*********/
name|tcnt
operator|->
name|cnts
operator|.
name|curobjs
operator|--
expr_stmt|;
name|tcnt
operator|->
name|cnts
operator|.
name|curbytes
operator|-=
name|size
expr_stmt|;
comment|/*********/
name|mb_write
argument_list|()
expr_stmt|;
comment|/*********/
name|tcnt
operator|->
name|epoch
operator|++
expr_stmt|;
comment|/*********/
name|mb_write
argument_list|()
expr_stmt|;
comment|/*********/
block|}
else|else
block|{
comment|/* 			 * OOM during free() cannot be propagated, so operate 			 * directly on cnt->ctx->cnt_merged. 			 */
name|malloc_mutex_lock
argument_list|(
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|cnt_merged
operator|.
name|curobjs
operator|--
expr_stmt|;
name|ctx
operator|->
name|cnt_merged
operator|.
name|curbytes
operator|-=
name|size
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JEMALLOC_H_INLINES */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

end_unit

