begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_H_TYPES
end_ifdef

begin_typedef
typedef|typedef
name|struct
name|prof_bt_s
name|prof_bt_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|prof_cnt_s
name|prof_cnt_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|prof_tctx_s
name|prof_tctx_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|prof_gctx_s
name|prof_gctx_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|prof_tdata_s
name|prof_tdata_t
typedef|;
end_typedef

begin_comment
comment|/* Option defaults. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_PROF
end_ifdef

begin_define
define|#
directive|define
name|PROF_PREFIX_DEFAULT
value|"jeprof"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PROF_PREFIX_DEFAULT
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|LG_PROF_SAMPLE_DEFAULT
value|19
end_define

begin_define
define|#
directive|define
name|LG_PROF_INTERVAL_DEFAULT
value|-1
end_define

begin_comment
comment|/*  * Hard limit on stack backtrace depth.  The version of prof_backtrace() that  * is based on __builtin_return_address() necessarily has a hard-coded number  * of backtrace frame handlers, and should be kept in sync with this setting.  */
end_comment

begin_define
define|#
directive|define
name|PROF_BT_MAX
value|128
end_define

begin_comment
comment|/* Initial hash table size. */
end_comment

begin_define
define|#
directive|define
name|PROF_CKH_MINITEMS
value|64
end_define

begin_comment
comment|/* Size of memory buffer to use when writing dump files. */
end_comment

begin_define
define|#
directive|define
name|PROF_DUMP_BUFSIZE
value|65536
end_define

begin_comment
comment|/* Size of stack-allocated buffer used by prof_printf(). */
end_comment

begin_define
define|#
directive|define
name|PROF_PRINTF_BUFSIZE
value|128
end_define

begin_comment
comment|/*  * Number of mutexes shared among all gctx's.  No space is allocated for these  * unless profiling is enabled, so it's okay to over-provision.  */
end_comment

begin_define
define|#
directive|define
name|PROF_NCTX_LOCKS
value|1024
end_define

begin_comment
comment|/*  * Number of mutexes shared among all tdata's.  No space is allocated for these  * unless profiling is enabled, so it's okay to over-provision.  */
end_comment

begin_define
define|#
directive|define
name|PROF_NTDATA_LOCKS
value|256
end_define

begin_comment
comment|/*  * prof_tdata pointers close to NULL are used to encode state information that  * is used for cleaning up during thread shutdown.  */
end_comment

begin_define
define|#
directive|define
name|PROF_TDATA_STATE_REINCARNATED
value|((prof_tdata_t *)(uintptr_t)1)
end_define

begin_define
define|#
directive|define
name|PROF_TDATA_STATE_PURGATORY
value|((prof_tdata_t *)(uintptr_t)2)
end_define

begin_define
define|#
directive|define
name|PROF_TDATA_STATE_MAX
value|PROF_TDATA_STATE_PURGATORY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JEMALLOC_H_TYPES */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_H_STRUCTS
end_ifdef

begin_struct
struct|struct
name|prof_bt_s
block|{
comment|/* Backtrace, stored as len program counters. */
name|void
modifier|*
modifier|*
name|vec
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_PROF_LIBGCC
end_ifdef

begin_comment
comment|/* Data structure passed to libgcc _Unwind_Backtrace() callback functions. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|prof_bt_t
modifier|*
name|bt
decl_stmt|;
name|unsigned
name|max
decl_stmt|;
block|}
name|prof_unwind_data_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|prof_cnt_s
block|{
comment|/* Profiling counters. */
name|uint64_t
name|curobjs
decl_stmt|;
name|uint64_t
name|curbytes
decl_stmt|;
name|uint64_t
name|accumobjs
decl_stmt|;
name|uint64_t
name|accumbytes
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
enum|enum
block|{
name|prof_tctx_state_initializing
block|,
name|prof_tctx_state_nominal
block|,
name|prof_tctx_state_dumping
block|,
name|prof_tctx_state_purgatory
comment|/* Dumper must finish destroying. */
block|}
name|prof_tctx_state_t
typedef|;
end_typedef

begin_struct
struct|struct
name|prof_tctx_s
block|{
comment|/* Thread data for thread that performed the allocation. */
name|prof_tdata_t
modifier|*
name|tdata
decl_stmt|;
comment|/* 	 * Copy of tdata->thr_{uid,discrim}, necessary because tdata may be 	 * defunct during teardown. 	 */
name|uint64_t
name|thr_uid
decl_stmt|;
name|uint64_t
name|thr_discrim
decl_stmt|;
comment|/* Profiling counters, protected by tdata->lock. */
name|prof_cnt_t
name|cnts
decl_stmt|;
comment|/* Associated global context. */
name|prof_gctx_t
modifier|*
name|gctx
decl_stmt|;
comment|/* 	 * UID that distinguishes multiple tctx's created by the same thread, 	 * but coexisting in gctx->tctxs.  There are two ways that such 	 * coexistence can occur: 	 * - A dumper thread can cause a tctx to be retained in the purgatory 	 *   state. 	 * - Although a single "producer" thread must create all tctx's which 	 *   share the same thr_uid, multiple "consumers" can each concurrently 	 *   execute portions of prof_tctx_destroy().  prof_tctx_destroy() only 	 *   gets called once each time cnts.cur{objs,bytes} drop to 0, but this 	 *   threshold can be hit again before the first consumer finishes 	 *   executing prof_tctx_destroy(). 	 */
name|uint64_t
name|tctx_uid
decl_stmt|;
comment|/* Linkage into gctx's tctxs. */
name|rb_node
argument_list|(
argument|prof_tctx_t
argument_list|)
name|tctx_link
expr_stmt|;
comment|/* 	 * True during prof_alloc_prep()..prof_malloc_sample_object(), prevents 	 * sample vs destroy race. 	 */
name|bool
name|prepared
decl_stmt|;
comment|/* Current dump-related state, protected by gctx->lock. */
name|prof_tctx_state_t
name|state
decl_stmt|;
comment|/* 	 * Copy of cnts snapshotted during early dump phase, protected by 	 * dump_mtx. 	 */
name|prof_cnt_t
name|dump_cnts
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|rb_tree
argument_list|(
argument|prof_tctx_t
argument_list|)
name|prof_tctx_tree_t
expr_stmt|;
end_typedef

begin_struct
struct|struct
name|prof_gctx_s
block|{
comment|/* Protects nlimbo, cnt_summed, and tctxs. */
name|malloc_mutex_t
modifier|*
name|lock
decl_stmt|;
comment|/* 	 * Number of threads that currently cause this gctx to be in a state of 	 * limbo due to one of: 	 *   - Initializing this gctx. 	 *   - Initializing per thread counters associated with this gctx. 	 *   - Preparing to destroy this gctx. 	 *   - Dumping a heap profile that includes this gctx. 	 * nlimbo must be 1 (single destroyer) in order to safely destroy the 	 * gctx. 	 */
name|unsigned
name|nlimbo
decl_stmt|;
comment|/* 	 * Tree of profile counters, one for each thread that has allocated in 	 * this context. 	 */
name|prof_tctx_tree_t
name|tctxs
decl_stmt|;
comment|/* Linkage for tree of contexts to be dumped. */
name|rb_node
argument_list|(
argument|prof_gctx_t
argument_list|)
name|dump_link
expr_stmt|;
comment|/* Temporary storage for summation during dump. */
name|prof_cnt_t
name|cnt_summed
decl_stmt|;
comment|/* Associated backtrace. */
name|prof_bt_t
name|bt
decl_stmt|;
comment|/* Backtrace vector, variable size, referred to by bt. */
name|void
modifier|*
name|vec
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|rb_tree
argument_list|(
argument|prof_gctx_t
argument_list|)
name|prof_gctx_tree_t
expr_stmt|;
end_typedef

begin_struct
struct|struct
name|prof_tdata_s
block|{
name|malloc_mutex_t
modifier|*
name|lock
decl_stmt|;
comment|/* Monotonically increasing unique thread identifier. */
name|uint64_t
name|thr_uid
decl_stmt|;
comment|/* 	 * Monotonically increasing discriminator among tdata structures 	 * associated with the same thr_uid. 	 */
name|uint64_t
name|thr_discrim
decl_stmt|;
comment|/* Included in heap profile dumps if non-NULL. */
name|char
modifier|*
name|thread_name
decl_stmt|;
name|bool
name|attached
decl_stmt|;
name|bool
name|expired
decl_stmt|;
name|rb_node
argument_list|(
argument|prof_tdata_t
argument_list|)
name|tdata_link
expr_stmt|;
comment|/* 	 * Counter used to initialize prof_tctx_t's tctx_uid.  No locking is 	 * necessary when incrementing this field, because only one thread ever 	 * does so. 	 */
name|uint64_t
name|tctx_uid_next
decl_stmt|;
comment|/* 	 * Hash of (prof_bt_t *)-->(prof_tctx_t *).  Each thread tracks 	 * backtraces for which it has non-zero allocation/deallocation counters 	 * associated with thread-specific prof_tctx_t objects.  Other threads 	 * may write to prof_tctx_t contents when freeing associated objects. 	 */
name|ckh_t
name|bt2tctx
decl_stmt|;
comment|/* Sampling state. */
name|uint64_t
name|prng_state
decl_stmt|;
name|uint64_t
name|bytes_until_sample
decl_stmt|;
comment|/* State used to avoid dumping while operating on prof internals. */
name|bool
name|enq
decl_stmt|;
name|bool
name|enq_idump
decl_stmt|;
name|bool
name|enq_gdump
decl_stmt|;
comment|/* 	 * Set to true during an early dump phase for tdata's which are 	 * currently being dumped.  New threads' tdata's have this initialized 	 * to false so that they aren't accidentally included in later dump 	 * phases. 	 */
name|bool
name|dumping
decl_stmt|;
comment|/* 	 * True if profiling is active for this tdata's thread 	 * (thread.prof.active mallctl). 	 */
name|bool
name|active
decl_stmt|;
comment|/* Temporary storage for summation during dump. */
name|prof_cnt_t
name|cnt_summed
decl_stmt|;
comment|/* Backtrace vector, used for calls to prof_backtrace(). */
name|void
modifier|*
name|vec
index|[
name|PROF_BT_MAX
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|rb_tree
argument_list|(
argument|prof_tdata_t
argument_list|)
name|prof_tdata_tree_t
expr_stmt|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JEMALLOC_H_STRUCTS */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_H_EXTERNS
end_ifdef

begin_decl_stmt
specifier|extern
name|bool
name|opt_prof
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bool
name|opt_prof_active
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bool
name|opt_prof_thread_active_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|size_t
name|opt_lg_prof_sample
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mean bytes between samples. */
end_comment

begin_decl_stmt
specifier|extern
name|ssize_t
name|opt_lg_prof_interval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lg(prof_interval). */
end_comment

begin_decl_stmt
specifier|extern
name|bool
name|opt_prof_gdump
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* High-water memory dumping. */
end_comment

begin_decl_stmt
specifier|extern
name|bool
name|opt_prof_final
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Final profile dumping. */
end_comment

begin_decl_stmt
specifier|extern
name|bool
name|opt_prof_leak
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dump leak summary at exit. */
end_comment

begin_decl_stmt
specifier|extern
name|bool
name|opt_prof_accum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Report cumulative bytes. */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|opt_prof_prefix
index|[
comment|/* Minimize memory bloat for non-prof builds. */
ifdef|#
directive|ifdef
name|JEMALLOC_PROF
name|PATH_MAX
operator|+
endif|#
directive|endif
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Accessed via prof_active_[gs]et{_unlocked,}(). */
end_comment

begin_decl_stmt
specifier|extern
name|bool
name|prof_active
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Accessed via prof_gdump_[gs]et{_unlocked,}(). */
end_comment

begin_decl_stmt
specifier|extern
name|bool
name|prof_gdump_val
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Profile dump interval, measured in bytes allocated.  Each arena triggers a  * profile dump when it reaches this threshold.  The effect is that the  * interval between profile dumps averages prof_interval, though the actual  * interval between dumps will tend to be sporadic, and the interval will be a  * maximum of approximately (prof_interval * narenas).  */
end_comment

begin_decl_stmt
specifier|extern
name|uint64_t
name|prof_interval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialized as opt_lg_prof_sample, and potentially modified during profiling  * resets.  */
end_comment

begin_decl_stmt
specifier|extern
name|size_t
name|lg_prof_sample
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|prof_alloc_rollback
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|,
name|bool
name|updated
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_malloc_sample_object
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_free_sampled_object
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|bt_init
parameter_list|(
name|prof_bt_t
modifier|*
name|bt
parameter_list|,
name|void
modifier|*
modifier|*
name|vec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_backtrace
parameter_list|(
name|prof_bt_t
modifier|*
name|bt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|prof_tctx_t
modifier|*
name|prof_lookup
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|prof_bt_t
modifier|*
name|bt
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_JET
end_ifdef

begin_function_decl
name|size_t
name|prof_tdata_count
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_t
name|prof_bt_count
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|const
name|prof_cnt_t
modifier|*
name|prof_cnt_all
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
name|int
function_decl|(
name|prof_dump_open_t
function_decl|)
parameter_list|(
name|bool
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|extern
name|prof_dump_open_t
modifier|*
name|prof_dump_open
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|bool
function_decl|(
name|prof_dump_header_t
function_decl|)
parameter_list|(
name|tsdn_t
modifier|*
parameter_list|,
name|bool
parameter_list|,
specifier|const
name|prof_cnt_t
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|extern
name|prof_dump_header_t
modifier|*
name|prof_dump_header
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|prof_idump
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|prof_mdump
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_gdump
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|prof_tdata_t
modifier|*
name|prof_tdata_init
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|prof_tdata_t
modifier|*
name|prof_tdata_reinit
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|prof_tdata_t
modifier|*
name|tdata
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_reset
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|size_t
name|lg_sample
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_tdata_cleanup
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|prof_active_get
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|prof_active_set
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|bool
name|active
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|const
name|char
modifier|*
name|prof_thread_name_get
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|prof_thread_name_set
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
specifier|const
name|char
modifier|*
name|thread_name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|prof_thread_active_get
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|prof_thread_active_set
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|bool
name|active
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|prof_thread_active_init_get
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|prof_thread_active_init_set
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|bool
name|active_init
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|prof_gdump_get
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|prof_gdump_set
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|bool
name|active
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_boot0
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_boot1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|prof_boot2
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_prefork0
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_prefork1
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_postfork_parent
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_postfork_child
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_sample_threshold_update
parameter_list|(
name|prof_tdata_t
modifier|*
name|tdata
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JEMALLOC_H_EXTERNS */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_H_INLINES
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|JEMALLOC_ENABLE_INLINE
end_ifndef

begin_function_decl
name|bool
name|prof_active_get_unlocked
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|prof_gdump_get_unlocked
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|prof_tdata_t
modifier|*
name|prof_tdata_get
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|bool
name|create
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|prof_tctx_t
modifier|*
name|prof_tctx_get
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_tctx_set
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_tctx_reset
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|usize
parameter_list|,
specifier|const
name|void
modifier|*
name|old_ptr
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|prof_sample_accum_update
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|bool
name|commit
parameter_list|,
name|prof_tdata_t
modifier|*
modifier|*
name|tdata_out
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|prof_tctx_t
modifier|*
name|prof_alloc_prep
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|bool
name|prof_active
parameter_list|,
name|bool
name|update
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_malloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_realloc
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|,
name|bool
name|prof_active
parameter_list|,
name|bool
name|updated
parameter_list|,
specifier|const
name|void
modifier|*
name|old_ptr
parameter_list|,
name|size_t
name|old_usize
parameter_list|,
name|prof_tctx_t
modifier|*
name|old_tctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|prof_free
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|usize
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|JEMALLOC_ENABLE_INLINE
argument_list|)
operator|||
name|defined
argument_list|(
name|JEMALLOC_PROF_C_
argument_list|)
operator|)
end_if

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|bool
name|prof_active_get_unlocked
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Even if opt_prof is true, sampling can be temporarily disabled by 	 * setting prof_active to false.  No locking is used when reading 	 * prof_active in the fast path, so there are no guarantees regarding 	 * how long it will take for all threads to notice state changes. 	 */
return|return
operator|(
name|prof_active
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|bool
name|prof_gdump_get_unlocked
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * No locking is used when reading prof_gdump_val in the fast path, so 	 * there are no guarantees regarding how long it will take for all 	 * threads to notice state changes. 	 */
return|return
operator|(
name|prof_gdump_val
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|prof_tdata_t
modifier|*
name|prof_tdata_get
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|bool
name|create
parameter_list|)
block|{
name|prof_tdata_t
modifier|*
name|tdata
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|tdata
operator|=
name|tsd_prof_tdata_get
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
if|if
condition|(
name|create
condition|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|tdata
operator|==
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
name|tsd_nominal
argument_list|(
name|tsd
argument_list|)
condition|)
block|{
name|tdata
operator|=
name|prof_tdata_init
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
name|tsd_prof_tdata_set
argument_list|(
name|tsd
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|unlikely
argument_list|(
name|tdata
operator|->
name|expired
argument_list|)
condition|)
block|{
name|tdata
operator|=
name|prof_tdata_reinit
argument_list|(
name|tsd
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
name|tsd_prof_tdata_set
argument_list|(
name|tsd
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|tdata
operator|==
name|NULL
operator|||
name|tdata
operator|->
name|attached
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|tdata
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|prof_tctx_t
modifier|*
name|prof_tctx_get
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|arena_prof_tctx_get
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|void
name|prof_tctx_set
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|arena_prof_tctx_set
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|void
name|prof_tctx_reset
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|usize
parameter_list|,
specifier|const
name|void
modifier|*
name|old_ptr
parameter_list|,
name|prof_tctx_t
modifier|*
name|old_tctx
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|arena_prof_tctx_reset
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|,
name|old_ptr
argument_list|,
name|old_tctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|bool
name|prof_sample_accum_update
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|bool
name|update
parameter_list|,
name|prof_tdata_t
modifier|*
modifier|*
name|tdata_out
parameter_list|)
block|{
name|prof_tdata_t
modifier|*
name|tdata
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|tdata
operator|=
name|prof_tdata_get
argument_list|(
name|tsd
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|uintptr_t
operator|)
name|tdata
operator|<=
operator|(
name|uintptr_t
operator|)
name|PROF_TDATA_STATE_MAX
argument_list|)
condition|)
name|tdata
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tdata_out
operator|!=
name|NULL
condition|)
operator|*
name|tdata_out
operator|=
name|tdata
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|tdata
operator|==
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
if|if
condition|(
name|likely
argument_list|(
name|tdata
operator|->
name|bytes_until_sample
operator|>=
name|usize
argument_list|)
condition|)
block|{
if|if
condition|(
name|update
condition|)
name|tdata
operator|->
name|bytes_until_sample
operator|-=
name|usize
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
else|else
block|{
comment|/* Compute new sample threshold. */
if|if
condition|(
name|update
condition|)
name|prof_sample_threshold_update
argument_list|(
name|tdata
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
name|tdata
operator|->
name|active
operator|)
return|;
block|}
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|prof_tctx_t
modifier|*
name|prof_alloc_prep
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|bool
name|prof_active
parameter_list|,
name|bool
name|update
parameter_list|)
block|{
name|prof_tctx_t
modifier|*
name|ret
decl_stmt|;
name|prof_tdata_t
modifier|*
name|tdata
decl_stmt|;
name|prof_bt_t
name|bt
decl_stmt|;
name|assert
argument_list|(
name|usize
operator|==
name|s2u
argument_list|(
name|usize
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prof_active
operator|||
name|likely
argument_list|(
name|prof_sample_accum_update
argument_list|(
name|tsd
argument_list|,
name|usize
argument_list|,
name|update
argument_list|,
operator|&
name|tdata
argument_list|)
argument_list|)
condition|)
name|ret
operator|=
operator|(
name|prof_tctx_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
literal|1U
expr_stmt|;
else|else
block|{
name|bt_init
argument_list|(
operator|&
name|bt
argument_list|,
name|tdata
operator|->
name|vec
argument_list|)
expr_stmt|;
name|prof_backtrace
argument_list|(
operator|&
name|bt
argument_list|)
expr_stmt|;
name|ret
operator|=
name|prof_lookup
argument_list|(
name|tsd
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|void
name|prof_malloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|usize
operator|==
name|isalloc
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|uintptr_t
operator|)
name|tctx
operator|>
operator|(
name|uintptr_t
operator|)
literal|1U
argument_list|)
condition|)
name|prof_malloc_sample_object
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
else|else
name|prof_tctx_set
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|,
operator|(
name|prof_tctx_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
literal|1U
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|void
name|prof_realloc
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|,
name|bool
name|prof_active
parameter_list|,
name|bool
name|updated
parameter_list|,
specifier|const
name|void
modifier|*
name|old_ptr
parameter_list|,
name|size_t
name|old_usize
parameter_list|,
name|prof_tctx_t
modifier|*
name|old_tctx
parameter_list|)
block|{
name|bool
name|sampled
decl_stmt|,
name|old_sampled
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
operator|||
operator|(
name|uintptr_t
operator|)
name|tctx
operator|<=
operator|(
name|uintptr_t
operator|)
literal|1U
argument_list|)
expr_stmt|;
if|if
condition|(
name|prof_active
operator|&&
operator|!
name|updated
operator|&&
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|usize
operator|==
name|isalloc
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prof_sample_accum_update
argument_list|(
name|tsd
argument_list|,
name|usize
argument_list|,
name|true
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
comment|/* 			 * Don't sample.  The usize passed to prof_alloc_prep() 			 * was larger than what actually got allocated, so a 			 * backtrace was captured for this allocation, even 			 * though its actual usize was insufficient to cross the 			 * sample threshold. 			 */
name|tctx
operator|=
operator|(
name|prof_tctx_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
literal|1U
expr_stmt|;
block|}
block|}
name|sampled
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|tctx
operator|>
operator|(
name|uintptr_t
operator|)
literal|1U
operator|)
expr_stmt|;
name|old_sampled
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|old_tctx
operator|>
operator|(
name|uintptr_t
operator|)
literal|1U
operator|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|sampled
argument_list|)
condition|)
name|prof_malloc_sample_object
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
else|else
name|prof_tctx_reset
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|,
name|old_ptr
argument_list|,
name|old_tctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|old_sampled
argument_list|)
condition|)
name|prof_free_sampled_object
argument_list|(
name|tsd
argument_list|,
name|old_usize
argument_list|,
name|old_tctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|void
name|prof_free
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|usize
parameter_list|)
block|{
name|prof_tctx_t
modifier|*
name|tctx
init|=
name|prof_tctx_get
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|)
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|usize
operator|==
name|isalloc
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|uintptr_t
operator|)
name|tctx
operator|>
operator|(
name|uintptr_t
operator|)
literal|1U
argument_list|)
condition|)
name|prof_free_sampled_object
argument_list|(
name|tsd
argument_list|,
name|usize
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JEMALLOC_H_INLINES */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

end_unit

