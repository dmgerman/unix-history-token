begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|JEMALLOC_INTERNAL_PRNG_H
end_ifndef

begin_define
define|#
directive|define
name|JEMALLOC_INTERNAL_PRNG_H
end_define

begin_include
include|#
directive|include
file|"jemalloc/internal/atomic.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/bit_util.h"
end_include

begin_comment
comment|/*  * Simple linear congruential pseudo-random number generator:  *  *   prng(y) = (a*x + c) % m  *  * where the following constants ensure maximal period:  *  *   a == Odd number (relatively prime to 2^n), and (a-1) is a multiple of 4.  *   c == Odd number (relatively prime to 2^n).  *   m == 2^32  *  * See Knuth's TAOCP 3rd Ed., Vol. 2, pg. 17 for details on these constraints.  *  * This choice of m has the disadvantage that the quality of the bits is  * proportional to bit position.  For example, the lowest bit has a cycle of 2,  * the next has a cycle of 4, etc.  For this reason, we prefer to use the upper  * bits.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/* INTERNAL DEFINITIONS -- IGNORE */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_define
define|#
directive|define
name|PRNG_A_32
value|UINT32_C(1103515241)
end_define

begin_define
define|#
directive|define
name|PRNG_C_32
value|UINT32_C(12347)
end_define

begin_define
define|#
directive|define
name|PRNG_A_64
value|UINT64_C(6364136223846793005)
end_define

begin_define
define|#
directive|define
name|PRNG_C_64
value|UINT64_C(1442695040888963407)
end_define

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|uint32_t
name|prng_state_next_u32
parameter_list|(
name|uint32_t
name|state
parameter_list|)
block|{
return|return
operator|(
name|state
operator|*
name|PRNG_A_32
operator|)
operator|+
name|PRNG_C_32
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|uint64_t
name|prng_state_next_u64
parameter_list|(
name|uint64_t
name|state
parameter_list|)
block|{
return|return
operator|(
name|state
operator|*
name|PRNG_A_64
operator|)
operator|+
name|PRNG_C_64
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|size_t
name|prng_state_next_zu
parameter_list|(
name|size_t
name|state
parameter_list|)
block|{
if|#
directive|if
name|LG_SIZEOF_PTR
operator|==
literal|2
return|return
operator|(
name|state
operator|*
name|PRNG_A_32
operator|)
operator|+
name|PRNG_C_32
return|;
elif|#
directive|elif
name|LG_SIZEOF_PTR
operator|==
literal|3
return|return
operator|(
name|state
operator|*
name|PRNG_A_64
operator|)
operator|+
name|PRNG_C_64
return|;
else|#
directive|else
error|#
directive|error
error|Unsupported pointer size
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/* BEGIN PUBLIC API */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * The prng_lg_range functions give a uniform int in the half-open range [0,  * 2**lg_range).  If atomic is true, they do so safely from multiple threads.  * Multithreaded 64-bit prngs aren't supported.  */
end_comment

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|uint32_t
name|prng_lg_range_u32
parameter_list|(
name|atomic_u32_t
modifier|*
name|state
parameter_list|,
name|unsigned
name|lg_range
parameter_list|,
name|bool
name|atomic
parameter_list|)
block|{
name|uint32_t
name|ret
decl_stmt|,
name|state0
decl_stmt|,
name|state1
decl_stmt|;
name|assert
argument_list|(
name|lg_range
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|lg_range
operator|<=
literal|32
argument_list|)
expr_stmt|;
name|state0
operator|=
name|atomic_load_u32
argument_list|(
name|state
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic
condition|)
block|{
do|do
block|{
name|state1
operator|=
name|prng_state_next_u32
argument_list|(
name|state0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|atomic_compare_exchange_weak_u32
argument_list|(
name|state
argument_list|,
operator|&
name|state0
argument_list|,
name|state1
argument_list|,
name|ATOMIC_RELAXED
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
condition|)
do|;
block|}
else|else
block|{
name|state1
operator|=
name|prng_state_next_u32
argument_list|(
name|state0
argument_list|)
expr_stmt|;
name|atomic_store_u32
argument_list|(
name|state
argument_list|,
name|state1
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|state1
operator|>>
operator|(
literal|32
operator|-
name|lg_range
operator|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|uint64_t
name|prng_lg_range_u64
parameter_list|(
name|uint64_t
modifier|*
name|state
parameter_list|,
name|unsigned
name|lg_range
parameter_list|)
block|{
name|uint64_t
name|ret
decl_stmt|,
name|state1
decl_stmt|;
name|assert
argument_list|(
name|lg_range
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|lg_range
operator|<=
literal|64
argument_list|)
expr_stmt|;
name|state1
operator|=
name|prng_state_next_u64
argument_list|(
operator|*
name|state
argument_list|)
expr_stmt|;
operator|*
name|state
operator|=
name|state1
expr_stmt|;
name|ret
operator|=
name|state1
operator|>>
operator|(
literal|64
operator|-
name|lg_range
operator|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|size_t
name|prng_lg_range_zu
parameter_list|(
name|atomic_zu_t
modifier|*
name|state
parameter_list|,
name|unsigned
name|lg_range
parameter_list|,
name|bool
name|atomic
parameter_list|)
block|{
name|size_t
name|ret
decl_stmt|,
name|state0
decl_stmt|,
name|state1
decl_stmt|;
name|assert
argument_list|(
name|lg_range
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|lg_range
operator|<=
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
operator|(
literal|3
operator|+
name|LG_SIZEOF_PTR
operator|)
argument_list|)
expr_stmt|;
name|state0
operator|=
name|atomic_load_zu
argument_list|(
name|state
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic
condition|)
block|{
do|do
block|{
name|state1
operator|=
name|prng_state_next_zu
argument_list|(
name|state0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|atomic_compare_exchange_weak_zu
argument_list|(
name|state
argument_list|,
operator|&
name|state0
argument_list|,
name|state1
argument_list|,
name|ATOMIC_RELAXED
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
condition|)
do|;
block|}
else|else
block|{
name|state1
operator|=
name|prng_state_next_zu
argument_list|(
name|state0
argument_list|)
expr_stmt|;
name|atomic_store_zu
argument_list|(
name|state
argument_list|,
name|state1
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|state1
operator|>>
operator|(
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
operator|(
literal|3
operator|+
name|LG_SIZEOF_PTR
operator|)
operator|)
operator|-
name|lg_range
operator|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * The prng_range functions behave like the prng_lg_range, but return a result  * in [0, range) instead of [0, 2**lg_range).  */
end_comment

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|uint32_t
name|prng_range_u32
parameter_list|(
name|atomic_u32_t
modifier|*
name|state
parameter_list|,
name|uint32_t
name|range
parameter_list|,
name|bool
name|atomic
parameter_list|)
block|{
name|uint32_t
name|ret
decl_stmt|;
name|unsigned
name|lg_range
decl_stmt|;
name|assert
argument_list|(
name|range
operator|>
literal|1
argument_list|)
expr_stmt|;
comment|/* Compute the ceiling of lg(range). */
name|lg_range
operator|=
name|ffs_u32
argument_list|(
name|pow2_ceil_u32
argument_list|(
name|range
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Generate a result in [0..range) via repeated trial. */
do|do
block|{
name|ret
operator|=
name|prng_lg_range_u32
argument_list|(
name|state
argument_list|,
name|lg_range
argument_list|,
name|atomic
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|>=
name|range
condition|)
do|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|uint64_t
name|prng_range_u64
parameter_list|(
name|uint64_t
modifier|*
name|state
parameter_list|,
name|uint64_t
name|range
parameter_list|)
block|{
name|uint64_t
name|ret
decl_stmt|;
name|unsigned
name|lg_range
decl_stmt|;
name|assert
argument_list|(
name|range
operator|>
literal|1
argument_list|)
expr_stmt|;
comment|/* Compute the ceiling of lg(range). */
name|lg_range
operator|=
name|ffs_u64
argument_list|(
name|pow2_ceil_u64
argument_list|(
name|range
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Generate a result in [0..range) via repeated trial. */
do|do
block|{
name|ret
operator|=
name|prng_lg_range_u64
argument_list|(
name|state
argument_list|,
name|lg_range
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|>=
name|range
condition|)
do|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|size_t
name|prng_range_zu
parameter_list|(
name|atomic_zu_t
modifier|*
name|state
parameter_list|,
name|size_t
name|range
parameter_list|,
name|bool
name|atomic
parameter_list|)
block|{
name|size_t
name|ret
decl_stmt|;
name|unsigned
name|lg_range
decl_stmt|;
name|assert
argument_list|(
name|range
operator|>
literal|1
argument_list|)
expr_stmt|;
comment|/* Compute the ceiling of lg(range). */
name|lg_range
operator|=
name|ffs_u64
argument_list|(
name|pow2_ceil_u64
argument_list|(
name|range
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Generate a result in [0..range) via repeated trial. */
do|do
block|{
name|ret
operator|=
name|prng_lg_range_zu
argument_list|(
name|state
argument_list|,
name|lg_range
argument_list|,
name|atomic
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|>=
name|range
condition|)
do|;
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JEMALLOC_INTERNAL_PRNG_H */
end_comment

end_unit

