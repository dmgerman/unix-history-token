begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_H_TYPES
end_ifdef

begin_comment
comment|/*  * Simple linear congruential pseudo-random number generator:  *  *   prng(y) = (a*x + c) % m  *  * where the following constants ensure maximal period:  *  *   a == Odd number (relatively prime to 2^n), and (a-1) is a multiple of 4.  *   c == Odd number (relatively prime to 2^n).  *   m == 2^32  *  * See Knuth's TAOCP 3rd Ed., Vol. 2, pg. 17 for details on these constraints.  *  * This choice of m has the disadvantage that the quality of the bits is  * proportional to bit position.  For example, the lowest bit has a cycle of 2,  * the next has a cycle of 4, etc.  For this reason, we prefer to use the upper  * bits.  */
end_comment

begin_define
define|#
directive|define
name|PRNG_A_32
value|UINT32_C(1103515241)
end_define

begin_define
define|#
directive|define
name|PRNG_C_32
value|UINT32_C(12347)
end_define

begin_define
define|#
directive|define
name|PRNG_A_64
value|UINT64_C(6364136223846793005)
end_define

begin_define
define|#
directive|define
name|PRNG_C_64
value|UINT64_C(1442695040888963407)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JEMALLOC_H_TYPES */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_H_STRUCTS
end_ifdef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JEMALLOC_H_STRUCTS */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_H_EXTERNS
end_ifdef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JEMALLOC_H_EXTERNS */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_H_INLINES
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|JEMALLOC_ENABLE_INLINE
end_ifndef

begin_function_decl
name|uint32_t
name|prng_state_next_u32
parameter_list|(
name|uint32_t
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|uint64_t
name|prng_state_next_u64
parameter_list|(
name|uint64_t
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_t
name|prng_state_next_zu
parameter_list|(
name|size_t
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|uint32_t
name|prng_lg_range_u32
parameter_list|(
name|uint32_t
modifier|*
name|state
parameter_list|,
name|unsigned
name|lg_range
parameter_list|,
name|bool
name|atomic
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|uint64_t
name|prng_lg_range_u64
parameter_list|(
name|uint64_t
modifier|*
name|state
parameter_list|,
name|unsigned
name|lg_range
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_t
name|prng_lg_range_zu
parameter_list|(
name|size_t
modifier|*
name|state
parameter_list|,
name|unsigned
name|lg_range
parameter_list|,
name|bool
name|atomic
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|uint32_t
name|prng_range_u32
parameter_list|(
name|uint32_t
modifier|*
name|state
parameter_list|,
name|uint32_t
name|range
parameter_list|,
name|bool
name|atomic
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|uint64_t
name|prng_range_u64
parameter_list|(
name|uint64_t
modifier|*
name|state
parameter_list|,
name|uint64_t
name|range
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_t
name|prng_range_zu
parameter_list|(
name|size_t
modifier|*
name|state
parameter_list|,
name|size_t
name|range
parameter_list|,
name|bool
name|atomic
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|JEMALLOC_ENABLE_INLINE
argument_list|)
operator|||
name|defined
argument_list|(
name|JEMALLOC_PRNG_C_
argument_list|)
operator|)
end_if

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|uint32_t
name|prng_state_next_u32
parameter_list|(
name|uint32_t
name|state
parameter_list|)
block|{
return|return
operator|(
operator|(
name|state
operator|*
name|PRNG_A_32
operator|)
operator|+
name|PRNG_C_32
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|uint64_t
name|prng_state_next_u64
parameter_list|(
name|uint64_t
name|state
parameter_list|)
block|{
return|return
operator|(
operator|(
name|state
operator|*
name|PRNG_A_64
operator|)
operator|+
name|PRNG_C_64
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|size_t
name|prng_state_next_zu
parameter_list|(
name|size_t
name|state
parameter_list|)
block|{
if|#
directive|if
name|LG_SIZEOF_PTR
operator|==
literal|2
return|return
operator|(
operator|(
name|state
operator|*
name|PRNG_A_32
operator|)
operator|+
name|PRNG_C_32
operator|)
return|;
elif|#
directive|elif
name|LG_SIZEOF_PTR
operator|==
literal|3
return|return
operator|(
operator|(
name|state
operator|*
name|PRNG_A_64
operator|)
operator|+
name|PRNG_C_64
operator|)
return|;
else|#
directive|else
error|#
directive|error
error|Unsupported pointer size
endif|#
directive|endif
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|uint32_t
name|prng_lg_range_u32
parameter_list|(
name|uint32_t
modifier|*
name|state
parameter_list|,
name|unsigned
name|lg_range
parameter_list|,
name|bool
name|atomic
parameter_list|)
block|{
name|uint32_t
name|ret
decl_stmt|,
name|state1
decl_stmt|;
name|assert
argument_list|(
name|lg_range
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|lg_range
operator|<=
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic
condition|)
block|{
name|uint32_t
name|state0
decl_stmt|;
do|do
block|{
name|state0
operator|=
name|atomic_read_uint32
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|state1
operator|=
name|prng_state_next_u32
argument_list|(
name|state0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|atomic_cas_uint32
argument_list|(
name|state
argument_list|,
name|state0
argument_list|,
name|state1
argument_list|)
condition|)
do|;
block|}
else|else
block|{
name|state1
operator|=
name|prng_state_next_u32
argument_list|(
operator|*
name|state
argument_list|)
expr_stmt|;
operator|*
name|state
operator|=
name|state1
expr_stmt|;
block|}
name|ret
operator|=
name|state1
operator|>>
operator|(
literal|32
operator|-
name|lg_range
operator|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* 64-bit atomic operations cannot be supported on all relevant platforms. */
end_comment

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|uint64_t
name|prng_lg_range_u64
parameter_list|(
name|uint64_t
modifier|*
name|state
parameter_list|,
name|unsigned
name|lg_range
parameter_list|)
block|{
name|uint64_t
name|ret
decl_stmt|,
name|state1
decl_stmt|;
name|assert
argument_list|(
name|lg_range
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|lg_range
operator|<=
literal|64
argument_list|)
expr_stmt|;
name|state1
operator|=
name|prng_state_next_u64
argument_list|(
operator|*
name|state
argument_list|)
expr_stmt|;
operator|*
name|state
operator|=
name|state1
expr_stmt|;
name|ret
operator|=
name|state1
operator|>>
operator|(
literal|64
operator|-
name|lg_range
operator|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|size_t
name|prng_lg_range_zu
parameter_list|(
name|size_t
modifier|*
name|state
parameter_list|,
name|unsigned
name|lg_range
parameter_list|,
name|bool
name|atomic
parameter_list|)
block|{
name|size_t
name|ret
decl_stmt|,
name|state1
decl_stmt|;
name|assert
argument_list|(
name|lg_range
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|lg_range
operator|<=
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
operator|(
literal|3
operator|+
name|LG_SIZEOF_PTR
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic
condition|)
block|{
name|size_t
name|state0
decl_stmt|;
do|do
block|{
name|state0
operator|=
name|atomic_read_z
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|state1
operator|=
name|prng_state_next_zu
argument_list|(
name|state0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|atomic_cas_z
argument_list|(
name|state
argument_list|,
name|state0
argument_list|,
name|state1
argument_list|)
condition|)
do|;
block|}
else|else
block|{
name|state1
operator|=
name|prng_state_next_zu
argument_list|(
operator|*
name|state
argument_list|)
expr_stmt|;
operator|*
name|state
operator|=
name|state1
expr_stmt|;
block|}
name|ret
operator|=
name|state1
operator|>>
operator|(
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
operator|(
literal|3
operator|+
name|LG_SIZEOF_PTR
operator|)
operator|)
operator|-
name|lg_range
operator|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|uint32_t
name|prng_range_u32
parameter_list|(
name|uint32_t
modifier|*
name|state
parameter_list|,
name|uint32_t
name|range
parameter_list|,
name|bool
name|atomic
parameter_list|)
block|{
name|uint32_t
name|ret
decl_stmt|;
name|unsigned
name|lg_range
decl_stmt|;
name|assert
argument_list|(
name|range
operator|>
literal|1
argument_list|)
expr_stmt|;
comment|/* Compute the ceiling of lg(range). */
name|lg_range
operator|=
name|ffs_u32
argument_list|(
name|pow2_ceil_u32
argument_list|(
name|range
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Generate a result in [0..range) via repeated trial. */
do|do
block|{
name|ret
operator|=
name|prng_lg_range_u32
argument_list|(
name|state
argument_list|,
name|lg_range
argument_list|,
name|atomic
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|>=
name|range
condition|)
do|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|uint64_t
name|prng_range_u64
parameter_list|(
name|uint64_t
modifier|*
name|state
parameter_list|,
name|uint64_t
name|range
parameter_list|)
block|{
name|uint64_t
name|ret
decl_stmt|;
name|unsigned
name|lg_range
decl_stmt|;
name|assert
argument_list|(
name|range
operator|>
literal|1
argument_list|)
expr_stmt|;
comment|/* Compute the ceiling of lg(range). */
name|lg_range
operator|=
name|ffs_u64
argument_list|(
name|pow2_ceil_u64
argument_list|(
name|range
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Generate a result in [0..range) via repeated trial. */
do|do
block|{
name|ret
operator|=
name|prng_lg_range_u64
argument_list|(
name|state
argument_list|,
name|lg_range
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|>=
name|range
condition|)
do|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|size_t
name|prng_range_zu
parameter_list|(
name|size_t
modifier|*
name|state
parameter_list|,
name|size_t
name|range
parameter_list|,
name|bool
name|atomic
parameter_list|)
block|{
name|size_t
name|ret
decl_stmt|;
name|unsigned
name|lg_range
decl_stmt|;
name|assert
argument_list|(
name|range
operator|>
literal|1
argument_list|)
expr_stmt|;
comment|/* Compute the ceiling of lg(range). */
name|lg_range
operator|=
name|ffs_u64
argument_list|(
name|pow2_ceil_u64
argument_list|(
name|range
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Generate a result in [0..range) via repeated trial. */
do|do
block|{
name|ret
operator|=
name|prng_lg_range_zu
argument_list|(
name|state
argument_list|,
name|lg_range
argument_list|,
name|atomic
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|>=
name|range
condition|)
do|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JEMALLOC_H_INLINES */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

end_unit

