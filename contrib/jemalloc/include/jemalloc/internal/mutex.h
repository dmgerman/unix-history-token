begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|JEMALLOC_INTERNAL_MUTEX_H
end_ifndef

begin_define
define|#
directive|define
name|JEMALLOC_INTERNAL_MUTEX_H
end_define

begin_include
include|#
directive|include
file|"jemalloc/internal/atomic.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/mutex_prof.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/tsd.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/witness.h"
end_include

begin_typedef
typedef|typedef
enum|enum
block|{
comment|/* Can only acquire one mutex of a given witness rank at a time. */
name|malloc_mutex_rank_exclusive
block|,
comment|/* 	 * Can acquire multiple mutexes of the same witness rank, but in 	 * address-ascending order only. 	 */
name|malloc_mutex_address_ordered
block|}
name|malloc_mutex_lock_order_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|malloc_mutex_s
name|malloc_mutex_t
typedef|;
end_typedef

begin_struct
struct|struct
name|malloc_mutex_s
block|{
union|union
block|{
struct|struct
block|{
comment|/* 			 * prof_data is defined first to reduce cacheline 			 * bouncing: the data is not touched by the mutex holder 			 * during unlocking, while might be modified by 			 * contenders.  Having it before the mutex itself could 			 * avoid prefetching a modified cacheline (for the 			 * unlocking thread). 			 */
name|mutex_prof_data_t
name|prof_data
decl_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
if|#
directive|if
name|_WIN32_WINNT
operator|>=
literal|0x0600
name|SRWLOCK
name|lock
decl_stmt|;
else|#
directive|else
name|CRITICAL_SECTION
name|lock
decl_stmt|;
endif|#
directive|endif
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|JEMALLOC_OS_UNFAIR_LOCK
argument_list|)
operator|)
name|os_unfair_lock
name|lock
decl_stmt|;
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|JEMALLOC_OSSPIN
argument_list|)
operator|)
name|OSSpinLock
name|lock
decl_stmt|;
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|JEMALLOC_MUTEX_INIT_CB
argument_list|)
operator|)
name|pthread_mutex_t
name|lock
decl_stmt|;
name|malloc_mutex_t
modifier|*
name|postponed_next
decl_stmt|;
else|#
directive|else
name|pthread_mutex_t
name|lock
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
comment|/* 		 * We only touch witness when configured w/ debug.  However we 		 * keep the field in a union when !debug so that we don't have 		 * to pollute the code base with #ifdefs, while avoid paying the 		 * memory cost. 		 */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|JEMALLOC_DEBUG
argument_list|)
name|witness_t
name|witness
decl_stmt|;
name|malloc_mutex_lock_order_t
name|lock_order
decl_stmt|;
endif|#
directive|endif
block|}
union|;
if|#
directive|if
name|defined
argument_list|(
name|JEMALLOC_DEBUG
argument_list|)
name|witness_t
name|witness
decl_stmt|;
name|malloc_mutex_lock_order_t
name|lock_order
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/*  * Based on benchmark results, a fixed spin with this amount of retries works  * well for our critical sections.  */
end_comment

begin_define
define|#
directive|define
name|MALLOC_MUTEX_MAX_SPIN
value|250
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_if
if|#
directive|if
name|_WIN32_WINNT
operator|>=
literal|0x0600
end_if

begin_define
define|#
directive|define
name|MALLOC_MUTEX_LOCK
parameter_list|(
name|m
parameter_list|)
value|AcquireSRWLockExclusive(&(m)->lock)
end_define

begin_define
define|#
directive|define
name|MALLOC_MUTEX_UNLOCK
parameter_list|(
name|m
parameter_list|)
value|ReleaseSRWLockExclusive(&(m)->lock)
end_define

begin_define
define|#
directive|define
name|MALLOC_MUTEX_TRYLOCK
parameter_list|(
name|m
parameter_list|)
value|(!TryAcquireSRWLockExclusive(&(m)->lock))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MALLOC_MUTEX_LOCK
parameter_list|(
name|m
parameter_list|)
value|EnterCriticalSection(&(m)->lock)
end_define

begin_define
define|#
directive|define
name|MALLOC_MUTEX_UNLOCK
parameter_list|(
name|m
parameter_list|)
value|LeaveCriticalSection(&(m)->lock)
end_define

begin_define
define|#
directive|define
name|MALLOC_MUTEX_TRYLOCK
parameter_list|(
name|m
parameter_list|)
value|(!TryEnterCriticalSection(&(m)->lock))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_elif
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|JEMALLOC_OS_UNFAIR_LOCK
argument_list|)
operator|)
end_elif

begin_define
define|#
directive|define
name|MALLOC_MUTEX_LOCK
parameter_list|(
name|m
parameter_list|)
value|os_unfair_lock_lock(&(m)->lock)
end_define

begin_define
define|#
directive|define
name|MALLOC_MUTEX_UNLOCK
parameter_list|(
name|m
parameter_list|)
value|os_unfair_lock_unlock(&(m)->lock)
end_define

begin_define
define|#
directive|define
name|MALLOC_MUTEX_TRYLOCK
parameter_list|(
name|m
parameter_list|)
value|(!os_unfair_lock_trylock(&(m)->lock))
end_define

begin_elif
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|JEMALLOC_OSSPIN
argument_list|)
operator|)
end_elif

begin_define
define|#
directive|define
name|MALLOC_MUTEX_LOCK
parameter_list|(
name|m
parameter_list|)
value|OSSpinLockLock(&(m)->lock)
end_define

begin_define
define|#
directive|define
name|MALLOC_MUTEX_UNLOCK
parameter_list|(
name|m
parameter_list|)
value|OSSpinLockUnlock(&(m)->lock)
end_define

begin_define
define|#
directive|define
name|MALLOC_MUTEX_TRYLOCK
parameter_list|(
name|m
parameter_list|)
value|(!OSSpinLockTry(&(m)->lock))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MALLOC_MUTEX_LOCK
parameter_list|(
name|m
parameter_list|)
value|pthread_mutex_lock(&(m)->lock)
end_define

begin_define
define|#
directive|define
name|MALLOC_MUTEX_UNLOCK
parameter_list|(
name|m
parameter_list|)
value|pthread_mutex_unlock(&(m)->lock)
end_define

begin_define
define|#
directive|define
name|MALLOC_MUTEX_TRYLOCK
parameter_list|(
name|m
parameter_list|)
value|(pthread_mutex_trylock(&(m)->lock) != 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|LOCK_PROF_DATA_INITIALIZER
define|\
value|{NSTIME_ZERO_INITIALIZER, NSTIME_ZERO_INITIALIZER, 0, 0, 0,		\ 	    ATOMIC_INIT(0), 0, NULL, 0}
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_define
define|#
directive|define
name|MALLOC_MUTEX_INITIALIZER
end_define

begin_elif
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|JEMALLOC_OS_UNFAIR_LOCK
argument_list|)
operator|)
end_elif

begin_define
define|#
directive|define
name|MALLOC_MUTEX_INITIALIZER
define|\
value|{{{LOCK_PROF_DATA_INITIALIZER, OS_UNFAIR_LOCK_INIT}},		\       WITNESS_INITIALIZER("mutex", WITNESS_RANK_OMIT)}
end_define

begin_elif
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|JEMALLOC_OSSPIN
argument_list|)
operator|)
end_elif

begin_define
define|#
directive|define
name|MALLOC_MUTEX_INITIALIZER
define|\
value|{{{LOCK_PROF_DATA_INITIALIZER, 0}},				\       WITNESS_INITIALIZER("mutex", WITNESS_RANK_OMIT)}
end_define

begin_elif
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|JEMALLOC_MUTEX_INIT_CB
argument_list|)
operator|)
end_elif

begin_define
define|#
directive|define
name|MALLOC_MUTEX_INITIALIZER
define|\
value|{{{LOCK_PROF_DATA_INITIALIZER, PTHREAD_MUTEX_INITIALIZER, NULL}},	\       WITNESS_INITIALIZER("mutex", WITNESS_RANK_OMIT)}
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MALLOC_MUTEX_TYPE
value|PTHREAD_MUTEX_DEFAULT
end_define

begin_define
define|#
directive|define
name|MALLOC_MUTEX_INITIALIZER
define|\
value|{{{LOCK_PROF_DATA_INITIALIZER, PTHREAD_MUTEX_INITIALIZER}},	\         WITNESS_INITIALIZER("mutex", WITNESS_RANK_OMIT)}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_LAZY_LOCK
end_ifdef

begin_decl_stmt
specifier|extern
name|bool
name|isthreaded
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|bool
name|malloc_mutex_init
parameter_list|(
name|malloc_mutex_t
modifier|*
name|mutex
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|witness_rank_t
name|rank
parameter_list|,
name|malloc_mutex_lock_order_t
name|lock_order
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|malloc_mutex_prefork
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|malloc_mutex_t
modifier|*
name|mutex
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|malloc_mutex_postfork_parent
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|malloc_mutex_t
modifier|*
name|mutex
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|malloc_mutex_postfork_child
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|malloc_mutex_t
modifier|*
name|mutex
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|malloc_mutex_first_thread
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|malloc_mutex_boot
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|malloc_mutex_prof_data_reset
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|malloc_mutex_t
modifier|*
name|mutex
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|malloc_mutex_lock_slow
parameter_list|(
name|malloc_mutex_t
modifier|*
name|mutex
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|void
name|malloc_mutex_lock_final
parameter_list|(
name|malloc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|MALLOC_MUTEX_LOCK
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|malloc_mutex_trylock_final
parameter_list|(
name|malloc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
return|return
name|MALLOC_MUTEX_TRYLOCK
argument_list|(
name|mutex
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|mutex_owner_stats_update
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|malloc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
if|if
condition|(
name|config_stats
condition|)
block|{
name|mutex_prof_data_t
modifier|*
name|data
init|=
operator|&
name|mutex
operator|->
name|prof_data
decl_stmt|;
name|data
operator|->
name|n_lock_ops
operator|++
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|prev_owner
operator|!=
name|tsdn
condition|)
block|{
name|data
operator|->
name|prev_owner
operator|=
name|tsdn
expr_stmt|;
name|data
operator|->
name|n_owner_switches
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Trylock: return false if the lock is successfully acquired. */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|malloc_mutex_trylock
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|malloc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|witness_assert_not_owner
argument_list|(
name|tsdn_witness_tsdp_get
argument_list|(
name|tsdn
argument_list|)
argument_list|,
operator|&
name|mutex
operator|->
name|witness
argument_list|)
expr_stmt|;
if|if
condition|(
name|isthreaded
condition|)
block|{
if|if
condition|(
name|malloc_mutex_trylock_final
argument_list|(
name|mutex
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|mutex_owner_stats_update
argument_list|(
name|tsdn
argument_list|,
name|mutex
argument_list|)
expr_stmt|;
block|}
name|witness_lock
argument_list|(
name|tsdn_witness_tsdp_get
argument_list|(
name|tsdn
argument_list|)
argument_list|,
operator|&
name|mutex
operator|->
name|witness
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Aggregate lock prof data. */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|malloc_mutex_prof_merge
parameter_list|(
name|mutex_prof_data_t
modifier|*
name|sum
parameter_list|,
name|mutex_prof_data_t
modifier|*
name|data
parameter_list|)
block|{
name|nstime_add
argument_list|(
operator|&
name|sum
operator|->
name|tot_wait_time
argument_list|,
operator|&
name|data
operator|->
name|tot_wait_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|nstime_compare
argument_list|(
operator|&
name|sum
operator|->
name|max_wait_time
argument_list|,
operator|&
name|data
operator|->
name|max_wait_time
argument_list|)
operator|<
literal|0
condition|)
block|{
name|nstime_copy
argument_list|(
operator|&
name|sum
operator|->
name|max_wait_time
argument_list|,
operator|&
name|data
operator|->
name|max_wait_time
argument_list|)
expr_stmt|;
block|}
name|sum
operator|->
name|n_wait_times
operator|+=
name|data
operator|->
name|n_wait_times
expr_stmt|;
name|sum
operator|->
name|n_spin_acquired
operator|+=
name|data
operator|->
name|n_spin_acquired
expr_stmt|;
if|if
condition|(
name|sum
operator|->
name|max_n_thds
operator|<
name|data
operator|->
name|max_n_thds
condition|)
block|{
name|sum
operator|->
name|max_n_thds
operator|=
name|data
operator|->
name|max_n_thds
expr_stmt|;
block|}
name|uint32_t
name|cur_n_waiting_thds
init|=
name|atomic_load_u32
argument_list|(
operator|&
name|sum
operator|->
name|n_waiting_thds
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
decl_stmt|;
name|uint32_t
name|new_n_waiting_thds
init|=
name|cur_n_waiting_thds
operator|+
name|atomic_load_u32
argument_list|(
operator|&
name|data
operator|->
name|n_waiting_thds
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
decl_stmt|;
name|atomic_store_u32
argument_list|(
operator|&
name|sum
operator|->
name|n_waiting_thds
argument_list|,
name|new_n_waiting_thds
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
name|sum
operator|->
name|n_owner_switches
operator|+=
name|data
operator|->
name|n_owner_switches
expr_stmt|;
name|sum
operator|->
name|n_lock_ops
operator|+=
name|data
operator|->
name|n_lock_ops
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|malloc_mutex_lock
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|malloc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|witness_assert_not_owner
argument_list|(
name|tsdn_witness_tsdp_get
argument_list|(
name|tsdn
argument_list|)
argument_list|,
operator|&
name|mutex
operator|->
name|witness
argument_list|)
expr_stmt|;
if|if
condition|(
name|isthreaded
condition|)
block|{
if|if
condition|(
name|malloc_mutex_trylock_final
argument_list|(
name|mutex
argument_list|)
condition|)
block|{
name|malloc_mutex_lock_slow
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
block|}
name|mutex_owner_stats_update
argument_list|(
name|tsdn
argument_list|,
name|mutex
argument_list|)
expr_stmt|;
block|}
name|witness_lock
argument_list|(
name|tsdn_witness_tsdp_get
argument_list|(
name|tsdn
argument_list|)
argument_list|,
operator|&
name|mutex
operator|->
name|witness
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|malloc_mutex_unlock
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|malloc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|witness_unlock
argument_list|(
name|tsdn_witness_tsdp_get
argument_list|(
name|tsdn
argument_list|)
argument_list|,
operator|&
name|mutex
operator|->
name|witness
argument_list|)
expr_stmt|;
if|if
condition|(
name|isthreaded
condition|)
block|{
name|MALLOC_MUTEX_UNLOCK
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|malloc_mutex_assert_owner
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|malloc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|witness_assert_owner
argument_list|(
name|tsdn_witness_tsdp_get
argument_list|(
name|tsdn
argument_list|)
argument_list|,
operator|&
name|mutex
operator|->
name|witness
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|malloc_mutex_assert_not_owner
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|malloc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|witness_assert_not_owner
argument_list|(
name|tsdn_witness_tsdp_get
argument_list|(
name|tsdn
argument_list|)
argument_list|,
operator|&
name|mutex
operator|->
name|witness
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the prof data from mutex for processing. */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|malloc_mutex_prof_read
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|mutex_prof_data_t
modifier|*
name|data
parameter_list|,
name|malloc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|mutex_prof_data_t
modifier|*
name|source
init|=
operator|&
name|mutex
operator|->
name|prof_data
decl_stmt|;
comment|/* Can only read holding the mutex. */
name|malloc_mutex_assert_owner
argument_list|(
name|tsdn
argument_list|,
name|mutex
argument_list|)
expr_stmt|;
comment|/* 	 * Not *really* allowed (we shouldn't be doing non-atomic loads of 	 * atomic data), but the mutex protection makes this safe, and writing 	 * a member-for-member copy is tedious for this situation. 	 */
operator|*
name|data
operator|=
operator|*
name|source
expr_stmt|;
comment|/* n_wait_thds is not reported (modified w/o locking). */
name|atomic_store_u32
argument_list|(
operator|&
name|data
operator|->
name|n_waiting_thds
argument_list|,
literal|0
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JEMALLOC_INTERNAL_MUTEX_H */
end_comment

end_unit

