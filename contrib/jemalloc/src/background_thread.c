begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|JEMALLOC_BACKGROUND_THREAD_C_
end_define

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_preamble.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_internal_includes.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/assert.h"
end_include

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/* Data. */
end_comment

begin_comment
comment|/* This option should be opt-in only. */
end_comment

begin_define
define|#
directive|define
name|BACKGROUND_THREAD_DEFAULT
value|false
end_define

begin_comment
comment|/* Read-only after initialization. */
end_comment

begin_decl_stmt
name|bool
name|opt_background_thread
init|=
name|BACKGROUND_THREAD_DEFAULT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used for thread creation, termination and stats. */
end_comment

begin_decl_stmt
name|malloc_mutex_t
name|background_thread_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates global state.  Atomic because decay reads this w/o locking. */
end_comment

begin_decl_stmt
name|atomic_b_t
name|background_thread_enabled_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|n_background_threads
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Thread info per-index. */
end_comment

begin_decl_stmt
name|background_thread_info_t
modifier|*
name|background_thread_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* False if no necessary runtime support. */
end_comment

begin_decl_stmt
name|bool
name|can_enable_background_thread
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_PTHREAD_CREATE_WRAPPER
end_ifdef

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|pthread_create_fptr
function_decl|)
parameter_list|(
name|pthread_t
modifier|*
name|__restrict
parameter_list|,
specifier|const
name|pthread_attr_t
modifier|*
parameter_list|,
name|void
modifier|*
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|__restrict
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|pthread_once_t
name|once_control
init|=
name|PTHREAD_ONCE_INIT
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|pthread_create_wrapper_once
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|JEMALLOC_LAZY_LOCK
name|isthreaded
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|pthread_create_wrapper
parameter_list|(
name|pthread_t
modifier|*
name|__restrict
name|thread
parameter_list|,
specifier|const
name|pthread_attr_t
modifier|*
name|attr
parameter_list|,
name|void
modifier|*
function_decl|(
modifier|*
name|start_routine
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|__restrict
name|arg
parameter_list|)
block|{
name|pthread_once
argument_list|(
operator|&
name|once_control
argument_list|,
name|pthread_create_wrapper_once
argument_list|)
expr_stmt|;
return|return
name|pthread_create_fptr
argument_list|(
name|thread
argument_list|,
name|attr
argument_list|,
name|start_routine
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JEMALLOC_PTHREAD_CREATE_WRAPPER */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|JEMALLOC_BACKGROUND_THREAD
end_ifndef

begin_define
define|#
directive|define
name|NOT_REACHED
value|{ not_reached(); }
end_define

begin_decl_stmt
name|bool
name|background_thread_create
argument_list|(
name|tsd_t
operator|*
name|tsd
argument_list|,
name|unsigned
name|arena_ind
argument_list|)
name|NOT_REACHED
name|bool
name|background_threads_enable
argument_list|(
name|tsd_t
operator|*
name|tsd
argument_list|)
name|NOT_REACHED
name|bool
name|background_threads_disable
argument_list|(
name|tsd_t
operator|*
name|tsd
argument_list|)
name|NOT_REACHED
name|void
name|background_thread_interval_check
argument_list|(
name|tsdn_t
operator|*
name|tsdn
argument_list|,
name|arena_t
operator|*
name|arena
argument_list|,
name|arena_decay_t
operator|*
name|decay
argument_list|,
name|size_t
name|npages_new
argument_list|)
name|NOT_REACHED
name|void
name|background_thread_prefork0
argument_list|(
name|tsdn_t
operator|*
name|tsdn
argument_list|)
name|NOT_REACHED
name|void
name|background_thread_prefork1
argument_list|(
name|tsdn_t
operator|*
name|tsdn
argument_list|)
name|NOT_REACHED
name|void
name|background_thread_postfork_parent
argument_list|(
name|tsdn_t
operator|*
name|tsdn
argument_list|)
name|NOT_REACHED
name|void
name|background_thread_postfork_child
argument_list|(
name|tsdn_t
operator|*
name|tsdn
argument_list|)
name|NOT_REACHED
name|bool
name|background_thread_stats_read
argument_list|(
name|tsdn_t
operator|*
name|tsdn
argument_list|,
name|background_thread_stats_t
operator|*
name|stats
argument_list|)
name|NOT_REACHED
name|void
name|background_thread_ctl_init
argument_list|(
name|tsdn_t
operator|*
name|tsdn
argument_list|)
name|NOT_REACHED
undef|#
directive|undef
name|NOT_REACHED
else|#
directive|else
decl|static
name|bool
name|background_thread_enabled_at_fork
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|background_thread_info_init
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|background_thread_info_t
modifier|*
name|info
parameter_list|)
block|{
name|background_thread_wakeup_time_set
argument_list|(
name|tsdn
argument_list|,
name|info
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|info
operator|->
name|npages_to_purge_new
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|info
operator|->
name|tot_n_runs
operator|=
literal|0
expr_stmt|;
name|nstime_init
argument_list|(
operator|&
name|info
operator|->
name|tot_sleep_time
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|set_current_thread_affinity
parameter_list|(
name|UNUSED
name|int
name|cpu
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|JEMALLOC_HAVE_SCHED_SETAFFINITY
argument_list|)
name|cpu_set_t
name|cpuset
decl_stmt|;
name|CPU_ZERO
argument_list|(
operator|&
name|cpuset
argument_list|)
expr_stmt|;
name|CPU_SET
argument_list|(
name|cpu
argument_list|,
operator|&
name|cpuset
argument_list|)
expr_stmt|;
name|int
name|ret
init|=
name|sched_setaffinity
argument_list|(
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cpu_set_t
argument_list|)
argument_list|,
operator|&
name|cpuset
argument_list|)
decl_stmt|;
return|return
operator|(
name|ret
operator|!=
literal|0
operator|)
return|;
else|#
directive|else
return|return
name|false
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Threshold for determining when to wake up the background thread. */
end_comment

begin_define
define|#
directive|define
name|BACKGROUND_THREAD_NPAGES_THRESHOLD
value|UINT64_C(1024)
end_define

begin_define
define|#
directive|define
name|BILLION
value|UINT64_C(1000000000)
end_define

begin_comment
comment|/* Minimal sleep interval 100 ms. */
end_comment

begin_define
define|#
directive|define
name|BACKGROUND_THREAD_MIN_INTERVAL_NS
value|(BILLION / 10)
end_define

begin_function
specifier|static
specifier|inline
name|size_t
name|decay_npurge_after_interval
parameter_list|(
name|arena_decay_t
modifier|*
name|decay
parameter_list|,
name|size_t
name|interval
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|uint64_t
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|interval
condition|;
name|i
operator|++
control|)
block|{
name|sum
operator|+=
name|decay
operator|->
name|backlog
index|[
name|i
index|]
operator|*
name|h_steps
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|SMOOTHSTEP_NSTEPS
condition|;
name|i
operator|++
control|)
block|{
name|sum
operator|+=
name|decay
operator|->
name|backlog
index|[
name|i
index|]
operator|*
operator|(
name|h_steps
index|[
name|i
index|]
operator|-
name|h_steps
index|[
name|i
operator|-
name|interval
index|]
operator|)
expr_stmt|;
block|}
return|return
call|(
name|size_t
call|)
argument_list|(
name|sum
operator|>>
name|SMOOTHSTEP_BFP
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|arena_decay_compute_purge_interval_impl
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_decay_t
modifier|*
name|decay
parameter_list|,
name|extents_t
modifier|*
name|extents
parameter_list|)
block|{
if|if
condition|(
name|malloc_mutex_trylock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|decay
operator|->
name|mtx
argument_list|)
condition|)
block|{
comment|/* Use minimal interval if decay is contended. */
return|return
name|BACKGROUND_THREAD_MIN_INTERVAL_NS
return|;
block|}
name|uint64_t
name|interval
decl_stmt|;
name|ssize_t
name|decay_time
init|=
name|atomic_load_zd
argument_list|(
operator|&
name|decay
operator|->
name|time_ms
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
decl_stmt|;
if|if
condition|(
name|decay_time
operator|<=
literal|0
condition|)
block|{
comment|/* Purging is eagerly done or disabled currently. */
name|interval
operator|=
name|BACKGROUND_THREAD_INDEFINITE_SLEEP
expr_stmt|;
goto|goto
name|label_done
goto|;
block|}
name|uint64_t
name|decay_interval_ns
init|=
name|nstime_ns
argument_list|(
operator|&
name|decay
operator|->
name|interval
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|decay_interval_ns
operator|>
literal|0
argument_list|)
expr_stmt|;
name|size_t
name|npages
init|=
name|extents_npages_get
argument_list|(
name|extents
argument_list|)
decl_stmt|;
if|if
condition|(
name|npages
operator|==
literal|0
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SMOOTHSTEP_NSTEPS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|decay
operator|->
name|backlog
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|SMOOTHSTEP_NSTEPS
condition|)
block|{
comment|/* No dirty pages recorded.  Sleep indefinitely. */
name|interval
operator|=
name|BACKGROUND_THREAD_INDEFINITE_SLEEP
expr_stmt|;
goto|goto
name|label_done
goto|;
block|}
block|}
if|if
condition|(
name|npages
operator|<=
name|BACKGROUND_THREAD_NPAGES_THRESHOLD
condition|)
block|{
comment|/* Use max interval. */
name|interval
operator|=
name|decay_interval_ns
operator|*
name|SMOOTHSTEP_NSTEPS
expr_stmt|;
goto|goto
name|label_done
goto|;
block|}
name|size_t
name|lb
init|=
name|BACKGROUND_THREAD_MIN_INTERVAL_NS
operator|/
name|decay_interval_ns
decl_stmt|;
name|size_t
name|ub
init|=
name|SMOOTHSTEP_NSTEPS
decl_stmt|;
comment|/* Minimal 2 intervals to ensure reaching next epoch deadline. */
name|lb
operator|=
operator|(
name|lb
operator|<
literal|2
operator|)
condition|?
literal|2
else|:
name|lb
expr_stmt|;
if|if
condition|(
operator|(
name|decay_interval_ns
operator|*
name|ub
operator|<=
name|BACKGROUND_THREAD_MIN_INTERVAL_NS
operator|)
operator|||
operator|(
name|lb
operator|+
literal|2
operator|>
name|ub
operator|)
condition|)
block|{
name|interval
operator|=
name|BACKGROUND_THREAD_MIN_INTERVAL_NS
expr_stmt|;
goto|goto
name|label_done
goto|;
block|}
name|assert
argument_list|(
name|lb
operator|+
literal|2
operator|<=
name|ub
argument_list|)
expr_stmt|;
name|size_t
name|npurge_lb
decl_stmt|,
name|npurge_ub
decl_stmt|;
name|npurge_lb
operator|=
name|decay_npurge_after_interval
argument_list|(
name|decay
argument_list|,
name|lb
argument_list|)
expr_stmt|;
if|if
condition|(
name|npurge_lb
operator|>
name|BACKGROUND_THREAD_NPAGES_THRESHOLD
condition|)
block|{
name|interval
operator|=
name|decay_interval_ns
operator|*
name|lb
expr_stmt|;
goto|goto
name|label_done
goto|;
block|}
name|npurge_ub
operator|=
name|decay_npurge_after_interval
argument_list|(
name|decay
argument_list|,
name|ub
argument_list|)
expr_stmt|;
if|if
condition|(
name|npurge_ub
operator|<
name|BACKGROUND_THREAD_NPAGES_THRESHOLD
condition|)
block|{
name|interval
operator|=
name|decay_interval_ns
operator|*
name|ub
expr_stmt|;
goto|goto
name|label_done
goto|;
block|}
name|unsigned
name|n_search
init|=
literal|0
decl_stmt|;
name|size_t
name|target
decl_stmt|,
name|npurge
decl_stmt|;
while|while
condition|(
operator|(
name|npurge_lb
operator|+
name|BACKGROUND_THREAD_NPAGES_THRESHOLD
operator|<
name|npurge_ub
operator|)
operator|&&
operator|(
name|lb
operator|+
literal|2
operator|<
name|ub
operator|)
condition|)
block|{
name|target
operator|=
operator|(
name|lb
operator|+
name|ub
operator|)
operator|/
literal|2
expr_stmt|;
name|npurge
operator|=
name|decay_npurge_after_interval
argument_list|(
name|decay
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|npurge
operator|>
name|BACKGROUND_THREAD_NPAGES_THRESHOLD
condition|)
block|{
name|ub
operator|=
name|target
expr_stmt|;
name|npurge_ub
operator|=
name|npurge
expr_stmt|;
block|}
else|else
block|{
name|lb
operator|=
name|target
expr_stmt|;
name|npurge_lb
operator|=
name|npurge
expr_stmt|;
block|}
name|assert
argument_list|(
name|n_search
operator|++
operator|<
name|lg_floor
argument_list|(
name|SMOOTHSTEP_NSTEPS
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|interval
operator|=
name|decay_interval_ns
operator|*
operator|(
name|ub
operator|+
name|lb
operator|)
operator|/
literal|2
expr_stmt|;
name|label_done
label|:
name|interval
operator|=
operator|(
name|interval
operator|<
name|BACKGROUND_THREAD_MIN_INTERVAL_NS
operator|)
condition|?
name|BACKGROUND_THREAD_MIN_INTERVAL_NS
else|:
name|interval
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|decay
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
name|interval
return|;
block|}
end_function

begin_comment
comment|/* Compute purge interval for background threads. */
end_comment

begin_function
specifier|static
name|uint64_t
name|arena_decay_compute_purge_interval
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|uint64_t
name|i1
decl_stmt|,
name|i2
decl_stmt|;
name|i1
operator|=
name|arena_decay_compute_purge_interval_impl
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|decay_dirty
argument_list|,
operator|&
name|arena
operator|->
name|extents_dirty
argument_list|)
expr_stmt|;
if|if
condition|(
name|i1
operator|==
name|BACKGROUND_THREAD_MIN_INTERVAL_NS
condition|)
block|{
return|return
name|i1
return|;
block|}
name|i2
operator|=
name|arena_decay_compute_purge_interval_impl
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|decay_muzzy
argument_list|,
operator|&
name|arena
operator|->
name|extents_muzzy
argument_list|)
expr_stmt|;
return|return
name|i1
operator|<
name|i2
condition|?
name|i1
else|:
name|i2
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|background_thread_sleep
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|background_thread_info_t
modifier|*
name|info
parameter_list|,
name|uint64_t
name|interval
parameter_list|)
block|{
if|if
condition|(
name|config_stats
condition|)
block|{
name|info
operator|->
name|tot_n_runs
operator|++
expr_stmt|;
block|}
name|info
operator|->
name|npages_to_purge_new
operator|=
literal|0
expr_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
comment|/* Specific clock required by timedwait. */
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nstime_t
name|before_sleep
decl_stmt|;
name|nstime_init2
argument_list|(
operator|&
name|before_sleep
argument_list|,
name|tv
operator|.
name|tv_sec
argument_list|,
name|tv
operator|.
name|tv_usec
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|interval
operator|==
name|BACKGROUND_THREAD_INDEFINITE_SLEEP
condition|)
block|{
name|assert
argument_list|(
name|background_thread_indefinite_sleep
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|pthread_cond_wait
argument_list|(
operator|&
name|info
operator|->
name|cond
argument_list|,
operator|&
name|info
operator|->
name|mtx
operator|.
name|lock
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|interval
operator|>=
name|BACKGROUND_THREAD_MIN_INTERVAL_NS
operator|&&
name|interval
operator|<=
name|BACKGROUND_THREAD_INDEFINITE_SLEEP
argument_list|)
expr_stmt|;
comment|/* We need malloc clock (can be different from tv). */
name|nstime_t
name|next_wakeup
decl_stmt|;
name|nstime_init
argument_list|(
operator|&
name|next_wakeup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nstime_update
argument_list|(
operator|&
name|next_wakeup
argument_list|)
expr_stmt|;
name|nstime_iadd
argument_list|(
operator|&
name|next_wakeup
argument_list|,
name|interval
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|nstime_ns
argument_list|(
operator|&
name|next_wakeup
argument_list|)
operator|<
name|BACKGROUND_THREAD_INDEFINITE_SLEEP
argument_list|)
expr_stmt|;
name|background_thread_wakeup_time_set
argument_list|(
name|tsdn
argument_list|,
name|info
argument_list|,
name|nstime_ns
argument_list|(
operator|&
name|next_wakeup
argument_list|)
argument_list|)
expr_stmt|;
name|nstime_t
name|ts_wakeup
decl_stmt|;
name|nstime_copy
argument_list|(
operator|&
name|ts_wakeup
argument_list|,
operator|&
name|before_sleep
argument_list|)
expr_stmt|;
name|nstime_iadd
argument_list|(
operator|&
name|ts_wakeup
argument_list|,
name|interval
argument_list|)
expr_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|ts
operator|.
name|tv_sec
operator|=
operator|(
name|size_t
operator|)
name|nstime_sec
argument_list|(
operator|&
name|ts_wakeup
argument_list|)
expr_stmt|;
name|ts
operator|.
name|tv_nsec
operator|=
operator|(
name|size_t
operator|)
name|nstime_nsec
argument_list|(
operator|&
name|ts_wakeup
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|background_thread_indefinite_sleep
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|pthread_cond_timedwait
argument_list|(
operator|&
name|info
operator|->
name|cond
argument_list|,
operator|&
name|info
operator|->
name|mtx
operator|.
name|lock
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|ETIMEDOUT
operator|||
name|ret
operator|==
literal|0
argument_list|)
expr_stmt|;
name|background_thread_wakeup_time_set
argument_list|(
name|tsdn
argument_list|,
name|info
argument_list|,
name|BACKGROUND_THREAD_INDEFINITE_SLEEP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config_stats
condition|)
block|{
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nstime_t
name|after_sleep
decl_stmt|;
name|nstime_init2
argument_list|(
operator|&
name|after_sleep
argument_list|,
name|tv
operator|.
name|tv_sec
argument_list|,
name|tv
operator|.
name|tv_usec
operator|*
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|nstime_compare
argument_list|(
operator|&
name|after_sleep
argument_list|,
operator|&
name|before_sleep
argument_list|)
operator|>
literal|0
condition|)
block|{
name|nstime_subtract
argument_list|(
operator|&
name|after_sleep
argument_list|,
operator|&
name|before_sleep
argument_list|)
expr_stmt|;
name|nstime_add
argument_list|(
operator|&
name|info
operator|->
name|tot_sleep_time
argument_list|,
operator|&
name|after_sleep
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|background_thread_pause_check
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|background_thread_info_t
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|info
operator|->
name|state
operator|==
name|background_thread_paused
argument_list|)
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|info
operator|->
name|mtx
argument_list|)
expr_stmt|;
comment|/* Wait on global lock to update status. */
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|background_thread_lock
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|background_thread_lock
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|info
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|background_work_sleep_once
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|background_thread_info_t
modifier|*
name|info
parameter_list|,
name|unsigned
name|ind
parameter_list|)
block|{
name|uint64_t
name|min_interval
init|=
name|BACKGROUND_THREAD_INDEFINITE_SLEEP
decl_stmt|;
name|unsigned
name|narenas
init|=
name|narenas_total_get
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
name|ind
init|;
name|i
operator|<
name|narenas
condition|;
name|i
operator|+=
name|ncpus
control|)
block|{
name|arena_t
modifier|*
name|arena
init|=
name|arena_get
argument_list|(
name|tsdn
argument_list|,
name|i
argument_list|,
name|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|arena
condition|)
block|{
continue|continue;
block|}
name|arena_decay
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|min_interval
operator|==
name|BACKGROUND_THREAD_MIN_INTERVAL_NS
condition|)
block|{
comment|/* Min interval will be used. */
continue|continue;
block|}
name|uint64_t
name|interval
init|=
name|arena_decay_compute_purge_interval
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|interval
operator|>=
name|BACKGROUND_THREAD_MIN_INTERVAL_NS
argument_list|)
expr_stmt|;
if|if
condition|(
name|min_interval
operator|>
name|interval
condition|)
block|{
name|min_interval
operator|=
name|interval
expr_stmt|;
block|}
block|}
name|background_thread_sleep
argument_list|(
name|tsdn
argument_list|,
name|info
argument_list|,
name|min_interval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|background_threads_disable_single
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|background_thread_info_t
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|info
operator|==
operator|&
name|background_thread_info
index|[
literal|0
index|]
condition|)
block|{
name|malloc_mutex_assert_owner
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|background_thread_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|malloc_mutex_assert_not_owner
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|background_thread_lock
argument_list|)
expr_stmt|;
block|}
name|pre_reentrancy
argument_list|(
name|tsd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|info
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|bool
name|has_thread
decl_stmt|;
name|assert
argument_list|(
name|info
operator|->
name|state
operator|!=
name|background_thread_paused
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|state
operator|==
name|background_thread_started
condition|)
block|{
name|has_thread
operator|=
name|true
expr_stmt|;
name|info
operator|->
name|state
operator|=
name|background_thread_stopped
expr_stmt|;
name|pthread_cond_signal
argument_list|(
operator|&
name|info
operator|->
name|cond
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|has_thread
operator|=
name|false
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|info
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|has_thread
condition|)
block|{
name|post_reentrancy
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|void
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|pthread_join
argument_list|(
name|info
operator|->
name|thread
argument_list|,
operator|&
name|ret
argument_list|)
condition|)
block|{
name|post_reentrancy
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|assert
argument_list|(
name|ret
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|n_background_threads
operator|--
expr_stmt|;
name|post_reentrancy
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
modifier|*
name|background_thread_entry
parameter_list|(
name|void
modifier|*
name|ind_arg
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|background_thread_create_signals_masked
parameter_list|(
name|pthread_t
modifier|*
name|thread
parameter_list|,
specifier|const
name|pthread_attr_t
modifier|*
name|attr
parameter_list|,
name|void
modifier|*
function_decl|(
modifier|*
name|start_routine
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* 	 * Mask signals during thread creation so that the thread inherits 	 * an empty signal set. 	 */
name|sigset_t
name|set
decl_stmt|;
name|sigfillset
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
name|sigset_t
name|oldset
decl_stmt|;
name|int
name|mask_err
init|=
name|pthread_sigmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|set
argument_list|,
operator|&
name|oldset
argument_list|)
decl_stmt|;
if|if
condition|(
name|mask_err
operator|!=
literal|0
condition|)
block|{
return|return
name|mask_err
return|;
block|}
name|int
name|create_err
init|=
name|pthread_create_wrapper
argument_list|(
name|thread
argument_list|,
name|attr
argument_list|,
name|start_routine
argument_list|,
name|arg
argument_list|)
decl_stmt|;
comment|/* 	 * Restore the signal mask.  Failure to restore the signal mask here 	 * changes program behavior. 	 */
name|int
name|restore_err
init|=
name|pthread_sigmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|oldset
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|restore_err
operator|!=
literal|0
condition|)
block|{
name|malloc_printf
argument_list|(
literal|"<jemalloc>: background thread creation "
literal|"failed (%d), and signal mask restoration failed "
literal|"(%d)\n"
argument_list|,
name|create_err
argument_list|,
name|restore_err
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|create_err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_background_thread_creation
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|unsigned
modifier|*
name|n_created
parameter_list|,
name|bool
modifier|*
name|created_threads
parameter_list|)
block|{
if|if
condition|(
name|likely
argument_list|(
operator|*
name|n_created
operator|==
name|n_background_threads
argument_list|)
condition|)
block|{
return|return;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|background_thread_info
index|[
literal|0
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|label_restart
label|:
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|background_thread_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|1
init|;
name|i
operator|<
name|ncpus
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|created_threads
index|[
name|i
index|]
condition|)
block|{
continue|continue;
block|}
name|background_thread_info_t
modifier|*
name|info
init|=
operator|&
name|background_thread_info
index|[
name|i
index|]
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|info
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|info
operator|->
name|state
operator|!=
name|background_thread_paused
argument_list|)
expr_stmt|;
name|bool
name|create
init|=
operator|(
name|info
operator|->
name|state
operator|==
name|background_thread_started
operator|)
decl_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|info
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|create
condition|)
block|{
continue|continue;
block|}
comment|/* 		 * To avoid deadlock with prefork handlers (which waits for the 		 * mutex held here), unlock before calling pthread_create(). 		 */
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|background_thread_lock
argument_list|)
expr_stmt|;
name|pre_reentrancy
argument_list|(
name|tsd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|int
name|err
init|=
name|background_thread_create_signals_masked
argument_list|(
operator|&
name|info
operator|->
name|thread
argument_list|,
name|NULL
argument_list|,
name|background_thread_entry
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|i
argument_list|)
decl_stmt|;
name|post_reentrancy
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
operator|(
operator|*
name|n_created
operator|)
operator|++
expr_stmt|;
name|created_threads
index|[
name|i
index|]
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|malloc_printf
argument_list|(
literal|"<jemalloc>: background thread "
literal|"creation failed (%d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Restart since we unlocked. */
goto|goto
name|label_restart
goto|;
block|}
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|background_thread_info
index|[
literal|0
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|background_thread_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|background_thread0_work
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|)
block|{
comment|/* Thread0 is also responsible for launching / terminating threads. */
name|VARIABLE_ARRAY
argument_list|(
name|bool
argument_list|,
name|created_threads
argument_list|,
name|ncpus
argument_list|)
expr_stmt|;
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ncpus
condition|;
name|i
operator|++
control|)
block|{
name|created_threads
index|[
name|i
index|]
operator|=
name|false
expr_stmt|;
block|}
comment|/* Start working, and create more threads when asked. */
name|unsigned
name|n_created
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|background_thread_info
index|[
literal|0
index|]
operator|.
name|state
operator|!=
name|background_thread_stopped
condition|)
block|{
if|if
condition|(
name|background_thread_pause_check
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|background_thread_info
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|check_background_thread_creation
argument_list|(
name|tsd
argument_list|,
operator|&
name|n_created
argument_list|,
operator|(
name|bool
operator|*
operator|)
operator|&
name|created_threads
argument_list|)
expr_stmt|;
name|background_work_sleep_once
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|background_thread_info
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Shut down other threads at exit.  Note that the ctl thread is holding 	 * the global background_thread mutex (and is waiting) for us. 	 */
name|assert
argument_list|(
operator|!
name|background_thread_enabled
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ncpus
condition|;
name|i
operator|++
control|)
block|{
name|background_thread_info_t
modifier|*
name|info
init|=
operator|&
name|background_thread_info
index|[
name|i
index|]
decl_stmt|;
name|assert
argument_list|(
name|info
operator|->
name|state
operator|!=
name|background_thread_paused
argument_list|)
expr_stmt|;
if|if
condition|(
name|created_threads
index|[
name|i
index|]
condition|)
block|{
name|background_threads_disable_single
argument_list|(
name|tsd
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|info
operator|->
name|mtx
argument_list|)
expr_stmt|;
comment|/* Clear in case the thread wasn't created. */
name|info
operator|->
name|state
operator|=
name|background_thread_stopped
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|info
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
block|}
name|background_thread_info
index|[
literal|0
index|]
operator|.
name|state
operator|=
name|background_thread_stopped
expr_stmt|;
name|assert
argument_list|(
name|n_background_threads
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|background_work
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|unsigned
name|ind
parameter_list|)
block|{
name|background_thread_info_t
modifier|*
name|info
init|=
operator|&
name|background_thread_info
index|[
name|ind
index|]
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|info
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|background_thread_wakeup_time_set
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|info
argument_list|,
name|BACKGROUND_THREAD_INDEFINITE_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind
operator|==
literal|0
condition|)
block|{
name|background_thread0_work
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|info
operator|->
name|state
operator|!=
name|background_thread_stopped
condition|)
block|{
if|if
condition|(
name|background_thread_pause_check
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|info
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|background_work_sleep_once
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|info
argument_list|,
name|ind
argument_list|)
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
name|info
operator|->
name|state
operator|==
name|background_thread_stopped
argument_list|)
expr_stmt|;
name|background_thread_wakeup_time_set
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|info
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|info
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|background_thread_entry
parameter_list|(
name|void
modifier|*
name|ind_arg
parameter_list|)
block|{
name|unsigned
name|thread_ind
init|=
operator|(
name|unsigned
operator|)
operator|(
name|uintptr_t
operator|)
name|ind_arg
decl_stmt|;
name|assert
argument_list|(
name|thread_ind
operator|<
name|ncpus
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|JEMALLOC_HAVE_PTHREAD_SETNAME_NP
name|pthread_setname_np
argument_list|(
name|pthread_self
argument_list|()
argument_list|,
literal|"jemalloc_bg_thd"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|opt_percpu_arena
operator|!=
name|percpu_arena_disabled
condition|)
block|{
name|set_current_thread_affinity
argument_list|(
operator|(
name|int
operator|)
name|thread_ind
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Start periodic background work.  We use internal tsd which avoids 	 * side effects, for example triggering new arena creation (which in 	 * turn triggers another background thread creation). 	 */
name|background_work
argument_list|(
name|tsd_internal_fetch
argument_list|()
argument_list|,
name|thread_ind
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_equal
argument_list|(
name|pthread_self
argument_list|()
argument_list|,
name|background_thread_info
index|[
name|thread_ind
index|]
operator|.
name|thread
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|background_thread_init
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|background_thread_info_t
modifier|*
name|info
parameter_list|)
block|{
name|malloc_mutex_assert_owner
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|background_thread_lock
argument_list|)
expr_stmt|;
name|info
operator|->
name|state
operator|=
name|background_thread_started
expr_stmt|;
name|background_thread_info_init
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|n_background_threads
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a new background thread if needed. */
end_comment

begin_function
name|bool
name|background_thread_create
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|unsigned
name|arena_ind
parameter_list|)
block|{
name|assert
argument_list|(
name|have_background_thread
argument_list|)
expr_stmt|;
name|malloc_mutex_assert_owner
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|background_thread_lock
argument_list|)
expr_stmt|;
comment|/* We create at most NCPUs threads. */
name|size_t
name|thread_ind
init|=
name|arena_ind
operator|%
name|ncpus
decl_stmt|;
name|background_thread_info_t
modifier|*
name|info
init|=
operator|&
name|background_thread_info
index|[
name|thread_ind
index|]
decl_stmt|;
name|bool
name|need_new_thread
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|info
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|need_new_thread
operator|=
name|background_thread_enabled
argument_list|()
operator|&&
operator|(
name|info
operator|->
name|state
operator|==
name|background_thread_stopped
operator|)
expr_stmt|;
if|if
condition|(
name|need_new_thread
condition|)
block|{
name|background_thread_init
argument_list|(
name|tsd
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|info
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|need_new_thread
condition|)
block|{
return|return
name|false
return|;
block|}
if|if
condition|(
name|arena_ind
operator|!=
literal|0
condition|)
block|{
comment|/* Threads are created asynchronously by Thread 0. */
name|background_thread_info_t
modifier|*
name|t0
init|=
operator|&
name|background_thread_info
index|[
literal|0
index|]
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|t0
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|t0
operator|->
name|state
operator|==
name|background_thread_started
argument_list|)
expr_stmt|;
name|pthread_cond_signal
argument_list|(
operator|&
name|t0
operator|->
name|cond
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|t0
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|pre_reentrancy
argument_list|(
name|tsd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * To avoid complications (besides reentrancy), create internal 	 * background threads with the underlying pthread_create. 	 */
name|int
name|err
init|=
name|background_thread_create_signals_masked
argument_list|(
operator|&
name|info
operator|->
name|thread
argument_list|,
name|NULL
argument_list|,
name|background_thread_entry
argument_list|,
operator|(
name|void
operator|*
operator|)
name|thread_ind
argument_list|)
decl_stmt|;
name|post_reentrancy
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|malloc_printf
argument_list|(
literal|"<jemalloc>: arena 0 background thread creation "
literal|"failed (%d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|info
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|info
operator|->
name|state
operator|=
name|background_thread_stopped
expr_stmt|;
name|n_background_threads
operator|--
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|info
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
name|bool
name|background_threads_enable
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|)
block|{
name|assert
argument_list|(
name|n_background_threads
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|background_thread_enabled
argument_list|()
argument_list|)
expr_stmt|;
name|malloc_mutex_assert_owner
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|background_thread_lock
argument_list|)
expr_stmt|;
name|VARIABLE_ARRAY
argument_list|(
name|bool
argument_list|,
name|marked
argument_list|,
name|ncpus
argument_list|)
expr_stmt|;
name|unsigned
name|i
decl_stmt|,
name|nmarked
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncpus
condition|;
name|i
operator|++
control|)
block|{
name|marked
index|[
name|i
index|]
operator|=
name|false
expr_stmt|;
block|}
name|nmarked
operator|=
literal|0
expr_stmt|;
comment|/* Mark the threads we need to create for thread 0. */
name|unsigned
name|n
init|=
name|narenas_total_get
argument_list|()
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|marked
index|[
name|i
operator|%
name|ncpus
index|]
operator|||
name|arena_get
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|i
argument_list|,
name|false
argument_list|)
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
name|background_thread_info_t
modifier|*
name|info
init|=
operator|&
name|background_thread_info
index|[
name|i
index|]
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|info
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|info
operator|->
name|state
operator|==
name|background_thread_stopped
argument_list|)
expr_stmt|;
name|background_thread_init
argument_list|(
name|tsd
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|info
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|marked
index|[
name|i
operator|%
name|ncpus
index|]
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|++
name|nmarked
operator|==
name|ncpus
condition|)
block|{
break|break;
block|}
block|}
return|return
name|background_thread_create
argument_list|(
name|tsd
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|background_threads_disable
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|background_thread_enabled
argument_list|()
argument_list|)
expr_stmt|;
name|malloc_mutex_assert_owner
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|background_thread_lock
argument_list|)
expr_stmt|;
comment|/* Thread 0 will be responsible for terminating other threads. */
if|if
condition|(
name|background_threads_disable_single
argument_list|(
name|tsd
argument_list|,
operator|&
name|background_thread_info
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|assert
argument_list|(
name|n_background_threads
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Check if we need to signal the background thread early. */
end_comment

begin_function
name|void
name|background_thread_interval_check
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_decay_t
modifier|*
name|decay
parameter_list|,
name|size_t
name|npages_new
parameter_list|)
block|{
name|background_thread_info_t
modifier|*
name|info
init|=
name|arena_background_thread_info_get
argument_list|(
name|arena
argument_list|)
decl_stmt|;
if|if
condition|(
name|malloc_mutex_trylock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|info
operator|->
name|mtx
argument_list|)
condition|)
block|{
comment|/* 		 * Background thread may hold the mutex for a long period of 		 * time.  We'd like to avoid the variance on application 		 * threads.  So keep this non-blocking, and leave the work to a 		 * future epoch. 		 */
return|return;
block|}
if|if
condition|(
name|info
operator|->
name|state
operator|!=
name|background_thread_started
condition|)
block|{
goto|goto
name|label_done
goto|;
block|}
if|if
condition|(
name|malloc_mutex_trylock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|decay
operator|->
name|mtx
argument_list|)
condition|)
block|{
goto|goto
name|label_done
goto|;
block|}
name|ssize_t
name|decay_time
init|=
name|atomic_load_zd
argument_list|(
operator|&
name|decay
operator|->
name|time_ms
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
decl_stmt|;
if|if
condition|(
name|decay_time
operator|<=
literal|0
condition|)
block|{
comment|/* Purging is eagerly done or disabled currently. */
goto|goto
name|label_done_unlock2
goto|;
block|}
name|uint64_t
name|decay_interval_ns
init|=
name|nstime_ns
argument_list|(
operator|&
name|decay
operator|->
name|interval
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|decay_interval_ns
operator|>
literal|0
argument_list|)
expr_stmt|;
name|nstime_t
name|diff
decl_stmt|;
name|nstime_init
argument_list|(
operator|&
name|diff
argument_list|,
name|background_thread_wakeup_time_get
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nstime_compare
argument_list|(
operator|&
name|diff
argument_list|,
operator|&
name|decay
operator|->
name|epoch
argument_list|)
operator|<=
literal|0
condition|)
block|{
goto|goto
name|label_done_unlock2
goto|;
block|}
name|nstime_subtract
argument_list|(
operator|&
name|diff
argument_list|,
operator|&
name|decay
operator|->
name|epoch
argument_list|)
expr_stmt|;
if|if
condition|(
name|nstime_ns
argument_list|(
operator|&
name|diff
argument_list|)
operator|<
name|BACKGROUND_THREAD_MIN_INTERVAL_NS
condition|)
block|{
goto|goto
name|label_done_unlock2
goto|;
block|}
if|if
condition|(
name|npages_new
operator|>
literal|0
condition|)
block|{
name|size_t
name|n_epoch
init|=
call|(
name|size_t
call|)
argument_list|(
name|nstime_ns
argument_list|(
operator|&
name|diff
argument_list|)
operator|/
name|decay_interval_ns
argument_list|)
decl_stmt|;
comment|/* 		 * Compute how many new pages we would need to purge by the next 		 * wakeup, which is used to determine if we should signal the 		 * background thread. 		 */
name|uint64_t
name|npurge_new
decl_stmt|;
if|if
condition|(
name|n_epoch
operator|>=
name|SMOOTHSTEP_NSTEPS
condition|)
block|{
name|npurge_new
operator|=
name|npages_new
expr_stmt|;
block|}
else|else
block|{
name|uint64_t
name|h_steps_max
init|=
name|h_steps
index|[
name|SMOOTHSTEP_NSTEPS
operator|-
literal|1
index|]
decl_stmt|;
name|assert
argument_list|(
name|h_steps_max
operator|>=
name|h_steps
index|[
name|SMOOTHSTEP_NSTEPS
operator|-
literal|1
operator|-
name|n_epoch
index|]
argument_list|)
expr_stmt|;
name|npurge_new
operator|=
name|npages_new
operator|*
operator|(
name|h_steps_max
operator|-
name|h_steps
index|[
name|SMOOTHSTEP_NSTEPS
operator|-
literal|1
operator|-
name|n_epoch
index|]
operator|)
expr_stmt|;
name|npurge_new
operator|>>=
name|SMOOTHSTEP_BFP
expr_stmt|;
block|}
name|info
operator|->
name|npages_to_purge_new
operator|+=
name|npurge_new
expr_stmt|;
block|}
name|bool
name|should_signal
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|npages_to_purge_new
operator|>
name|BACKGROUND_THREAD_NPAGES_THRESHOLD
condition|)
block|{
name|should_signal
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unlikely
argument_list|(
name|background_thread_indefinite_sleep
argument_list|(
name|info
argument_list|)
argument_list|)
operator|&&
operator|(
name|extents_npages_get
argument_list|(
operator|&
name|arena
operator|->
name|extents_dirty
argument_list|)
operator|>
literal|0
operator|||
name|extents_npages_get
argument_list|(
operator|&
name|arena
operator|->
name|extents_muzzy
argument_list|)
operator|>
literal|0
operator|||
name|info
operator|->
name|npages_to_purge_new
operator|>
literal|0
operator|)
condition|)
block|{
name|should_signal
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|should_signal
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|should_signal
condition|)
block|{
name|info
operator|->
name|npages_to_purge_new
operator|=
literal|0
expr_stmt|;
name|pthread_cond_signal
argument_list|(
operator|&
name|info
operator|->
name|cond
argument_list|)
expr_stmt|;
block|}
name|label_done_unlock2
label|:
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|decay
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|label_done
label|:
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|info
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|background_thread_prefork0
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
block|{
name|malloc_mutex_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|background_thread_lock
argument_list|)
expr_stmt|;
name|background_thread_enabled_at_fork
operator|=
name|background_thread_enabled
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|background_thread_prefork1
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ncpus
condition|;
name|i
operator|++
control|)
block|{
name|malloc_mutex_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|background_thread_info
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|background_thread_postfork_parent
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ncpus
condition|;
name|i
operator|++
control|)
block|{
name|malloc_mutex_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|background_thread_info
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|background_thread_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|background_thread_postfork_child
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ncpus
condition|;
name|i
operator|++
control|)
block|{
name|malloc_mutex_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|background_thread_info
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|background_thread_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|background_thread_enabled_at_fork
condition|)
block|{
return|return;
block|}
comment|/* Clear background_thread state (reset to disabled for child). */
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|background_thread_lock
argument_list|)
expr_stmt|;
name|n_background_threads
operator|=
literal|0
expr_stmt|;
name|background_thread_enabled_set
argument_list|(
name|tsdn
argument_list|,
name|false
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ncpus
condition|;
name|i
operator|++
control|)
block|{
name|background_thread_info_t
modifier|*
name|info
init|=
operator|&
name|background_thread_info
index|[
name|i
index|]
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|info
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|info
operator|->
name|state
operator|=
name|background_thread_stopped
expr_stmt|;
name|int
name|ret
init|=
name|pthread_cond_init
argument_list|(
operator|&
name|info
operator|->
name|cond
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|ret
operator|==
literal|0
argument_list|)
expr_stmt|;
name|background_thread_info_init
argument_list|(
name|tsdn
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|info
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|background_thread_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|background_thread_stats_read
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|background_thread_stats_t
modifier|*
name|stats
parameter_list|)
block|{
name|assert
argument_list|(
name|config_stats
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|background_thread_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|background_thread_enabled
argument_list|()
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|background_thread_lock
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|stats
operator|->
name|num_threads
operator|=
name|n_background_threads
expr_stmt|;
name|uint64_t
name|num_runs
init|=
literal|0
decl_stmt|;
name|nstime_init
argument_list|(
operator|&
name|stats
operator|->
name|run_interval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ncpus
condition|;
name|i
operator|++
control|)
block|{
name|background_thread_info_t
modifier|*
name|info
init|=
operator|&
name|background_thread_info
index|[
name|i
index|]
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|info
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|state
operator|!=
name|background_thread_stopped
condition|)
block|{
name|num_runs
operator|+=
name|info
operator|->
name|tot_n_runs
expr_stmt|;
name|nstime_add
argument_list|(
operator|&
name|stats
operator|->
name|run_interval
argument_list|,
operator|&
name|info
operator|->
name|tot_sleep_time
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|info
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
name|stats
operator|->
name|num_runs
operator|=
name|num_runs
expr_stmt|;
if|if
condition|(
name|num_runs
operator|>
literal|0
condition|)
block|{
name|nstime_idivide
argument_list|(
operator|&
name|stats
operator|->
name|run_interval
argument_list|,
name|num_runs
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|background_thread_lock
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|BACKGROUND_THREAD_NPAGES_THRESHOLD
end_undef

begin_undef
undef|#
directive|undef
name|BILLION
end_undef

begin_undef
undef|#
directive|undef
name|BACKGROUND_THREAD_MIN_INTERVAL_NS
end_undef

begin_comment
comment|/*  * When lazy lock is enabled, we need to make sure setting isthreaded before  * taking any background_thread locks.  This is called early in ctl (instead of  * wait for the pthread_create calls to trigger) because the mutex is required  * before creating background threads.  */
end_comment

begin_function
name|void
name|background_thread_ctl_init
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
block|{
name|malloc_mutex_assert_not_owner
argument_list|(
name|tsdn
argument_list|,
operator|&
name|background_thread_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|JEMALLOC_PTHREAD_CREATE_WRAPPER
name|pthread_once
argument_list|(
operator|&
name|once_control
argument_list|,
name|pthread_create_wrapper_once
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(JEMALLOC_BACKGROUND_THREAD) */
end_comment

begin_function
name|bool
name|background_thread_boot0
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|have_background_thread
operator|&&
name|opt_background_thread
condition|)
block|{
name|malloc_printf
argument_list|(
literal|"<jemalloc>: option background_thread currently "
literal|"supports pthread only\n"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
ifdef|#
directive|ifdef
name|JEMALLOC_PTHREAD_CREATE_WRAPPER
name|pthread_create_fptr
operator|=
name|dlsym
argument_list|(
name|RTLD_NEXT
argument_list|,
literal|"pthread_create"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pthread_create_fptr
operator|==
name|NULL
condition|)
block|{
name|can_enable_background_thread
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|config_lazy_lock
operator|||
name|opt_background_thread
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Error in dlsym(RTLD_NEXT, "
literal|"\"pthread_create\")\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|can_enable_background_thread
operator|=
name|true
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|false
return|;
block|}
end_function

begin_function
name|bool
name|background_thread_boot1
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|JEMALLOC_BACKGROUND_THREAD
name|assert
argument_list|(
name|have_background_thread
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|narenas_total_get
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
name|background_thread_enabled_set
argument_list|(
name|tsdn
argument_list|,
name|opt_background_thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|background_thread_lock
argument_list|,
literal|"background_thread_global"
argument_list|,
name|WITNESS_RANK_BACKGROUND_THREAD_GLOBAL
argument_list|,
name|malloc_mutex_rank_exclusive
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
if|if
condition|(
name|opt_background_thread
condition|)
block|{
name|background_thread_ctl_init
argument_list|(
name|tsdn
argument_list|)
expr_stmt|;
block|}
name|background_thread_info
operator|=
operator|(
name|background_thread_info_t
operator|*
operator|)
name|base_alloc
argument_list|(
name|tsdn
argument_list|,
name|b0get
argument_list|()
argument_list|,
name|ncpus
operator|*
sizeof|sizeof
argument_list|(
name|background_thread_info_t
argument_list|)
argument_list|,
name|CACHELINE
argument_list|)
expr_stmt|;
if|if
condition|(
name|background_thread_info
operator|==
name|NULL
condition|)
block|{
return|return
name|true
return|;
block|}
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ncpus
condition|;
name|i
operator|++
control|)
block|{
name|background_thread_info_t
modifier|*
name|info
init|=
operator|&
name|background_thread_info
index|[
name|i
index|]
decl_stmt|;
comment|/* Thread mutex is rank_inclusive because of thread0. */
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|info
operator|->
name|mtx
argument_list|,
literal|"background_thread"
argument_list|,
name|WITNESS_RANK_BACKGROUND_THREAD
argument_list|,
name|malloc_mutex_address_ordered
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
if|if
condition|(
name|pthread_cond_init
argument_list|(
operator|&
name|info
operator|->
name|cond
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|info
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|info
operator|->
name|state
operator|=
name|background_thread_stopped
expr_stmt|;
name|background_thread_info_init
argument_list|(
name|tsdn
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|info
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|false
return|;
block|}
end_function

end_unit

