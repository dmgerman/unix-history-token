begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|JEMALLOC_ARENA_C_
end_define

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_internal.h"
end_include

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/* Data. */
end_comment

begin_decl_stmt
name|ssize_t
name|opt_lg_dirty_mult
init|=
name|LG_DIRTY_MULT_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|arena_bin_info_t
name|arena_bin_info
index|[
name|NBINS
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|JEMALLOC_ALIGNED
argument_list|(
argument|CACHELINE
argument_list|)
end_macro

begin_decl_stmt
specifier|const
name|uint8_t
name|small_size2bin
index|[]
init|=
block|{
define|#
directive|define
name|S2B_8
parameter_list|(
name|i
parameter_list|)
value|i,
define|#
directive|define
name|S2B_16
parameter_list|(
name|i
parameter_list|)
value|S2B_8(i) S2B_8(i)
define|#
directive|define
name|S2B_32
parameter_list|(
name|i
parameter_list|)
value|S2B_16(i) S2B_16(i)
define|#
directive|define
name|S2B_64
parameter_list|(
name|i
parameter_list|)
value|S2B_32(i) S2B_32(i)
define|#
directive|define
name|S2B_128
parameter_list|(
name|i
parameter_list|)
value|S2B_64(i) S2B_64(i)
define|#
directive|define
name|S2B_256
parameter_list|(
name|i
parameter_list|)
value|S2B_128(i) S2B_128(i)
define|#
directive|define
name|S2B_512
parameter_list|(
name|i
parameter_list|)
value|S2B_256(i) S2B_256(i)
define|#
directive|define
name|S2B_1024
parameter_list|(
name|i
parameter_list|)
value|S2B_512(i) S2B_512(i)
define|#
directive|define
name|S2B_2048
parameter_list|(
name|i
parameter_list|)
value|S2B_1024(i) S2B_1024(i)
define|#
directive|define
name|S2B_4096
parameter_list|(
name|i
parameter_list|)
value|S2B_2048(i) S2B_2048(i)
define|#
directive|define
name|S2B_8192
parameter_list|(
name|i
parameter_list|)
value|S2B_4096(i) S2B_4096(i)
define|#
directive|define
name|SIZE_CLASS
parameter_list|(
name|bin
parameter_list|,
name|delta
parameter_list|,
name|size
parameter_list|)
define|\
value|S2B_##delta(bin)
name|SIZE_CLASSES
undef|#
directive|undef
name|S2B_8
undef|#
directive|undef
name|S2B_16
undef|#
directive|undef
name|S2B_32
undef|#
directive|undef
name|S2B_64
undef|#
directive|undef
name|S2B_128
undef|#
directive|undef
name|S2B_256
undef|#
directive|undef
name|S2B_512
undef|#
directive|undef
name|S2B_1024
undef|#
directive|undef
name|S2B_2048
undef|#
directive|undef
name|S2B_4096
undef|#
directive|undef
name|S2B_8192
undef|#
directive|undef
name|SIZE_CLASS
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/* Function prototypes for non-inline static functions. */
end_comment

begin_function_decl
specifier|static
name|void
name|arena_run_split
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|large
parameter_list|,
name|size_t
name|binind
parameter_list|,
name|bool
name|zero
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|arena_chunk_t
modifier|*
name|arena_chunk_alloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_chunk_dealloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|arena_run_t
modifier|*
name|arena_run_alloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|large
parameter_list|,
name|size_t
name|binind
parameter_list|,
name|bool
name|zero
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_purge
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|bool
name|all
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_run_dalloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|bool
name|dirty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_run_trim_head
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|newsize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_run_trim_tail
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|newsize
parameter_list|,
name|bool
name|dirty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|arena_run_t
modifier|*
name|arena_bin_runs_first
parameter_list|(
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_bin_runs_insert
parameter_list|(
name|arena_bin_t
modifier|*
name|bin
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_bin_runs_remove
parameter_list|(
name|arena_bin_t
modifier|*
name|bin
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|arena_run_t
modifier|*
name|arena_bin_nonfull_run_tryget
parameter_list|(
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|arena_run_t
modifier|*
name|arena_bin_nonfull_run_get
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|arena_bin_malloc_hard
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_dissociate_bin_run
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_dalloc_bin_run
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_bin_lower_run
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_ralloc_large_shrink
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arena_ralloc_large_grow
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|extra
parameter_list|,
name|bool
name|zero
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arena_ralloc_large
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|extra
parameter_list|,
name|bool
name|zero
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|bin_info_run_size_calc
parameter_list|(
name|arena_bin_info_t
modifier|*
name|bin_info
parameter_list|,
name|size_t
name|min_run_size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bin_info_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/******************************************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|arena_run_comp
parameter_list|(
name|arena_chunk_map_t
modifier|*
name|a
parameter_list|,
name|arena_chunk_map_t
modifier|*
name|b
parameter_list|)
block|{
name|uintptr_t
name|a_mapelm
init|=
operator|(
name|uintptr_t
operator|)
name|a
decl_stmt|;
name|uintptr_t
name|b_mapelm
init|=
operator|(
name|uintptr_t
operator|)
name|b
decl_stmt|;
name|assert
argument_list|(
name|a
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|b
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|a_mapelm
operator|>
name|b_mapelm
operator|)
operator|-
operator|(
name|a_mapelm
operator|<
name|b_mapelm
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Generate red-black tree functions. */
end_comment

begin_macro
name|rb_gen
argument_list|(
argument|static UNUSED
argument_list|,
argument|arena_run_tree_
argument_list|,
argument|arena_run_tree_t
argument_list|,
argument|arena_chunk_map_t
argument_list|,
argument|u.rb_link
argument_list|,
argument|arena_run_comp
argument_list|)
end_macro

begin_function
specifier|static
specifier|inline
name|int
name|arena_avail_comp
parameter_list|(
name|arena_chunk_map_t
modifier|*
name|a
parameter_list|,
name|arena_chunk_map_t
modifier|*
name|b
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|size_t
name|a_size
init|=
name|a
operator|->
name|bits
operator|&
operator|~
name|PAGE_MASK
decl_stmt|;
name|size_t
name|b_size
init|=
name|b
operator|->
name|bits
operator|&
operator|~
name|PAGE_MASK
decl_stmt|;
name|assert
argument_list|(
operator|(
name|a
operator|->
name|bits
operator|&
name|CHUNK_MAP_KEY
operator|)
operator|==
name|CHUNK_MAP_KEY
operator|||
operator|(
name|a
operator|->
name|bits
operator|&
name|CHUNK_MAP_DIRTY
operator|)
operator|==
operator|(
name|b
operator|->
name|bits
operator|&
name|CHUNK_MAP_DIRTY
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|a_size
operator|>
name|b_size
operator|)
operator|-
operator|(
name|a_size
operator|<
name|b_size
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|uintptr_t
name|a_mapelm
decl_stmt|,
name|b_mapelm
decl_stmt|;
if|if
condition|(
operator|(
name|a
operator|->
name|bits
operator|&
name|CHUNK_MAP_KEY
operator|)
operator|!=
name|CHUNK_MAP_KEY
condition|)
name|a_mapelm
operator|=
operator|(
name|uintptr_t
operator|)
name|a
expr_stmt|;
else|else
block|{
comment|/* 			 * Treat keys as though they are lower than anything 			 * else. 			 */
name|a_mapelm
operator|=
literal|0
expr_stmt|;
block|}
name|b_mapelm
operator|=
operator|(
name|uintptr_t
operator|)
name|b
expr_stmt|;
name|ret
operator|=
operator|(
name|a_mapelm
operator|>
name|b_mapelm
operator|)
operator|-
operator|(
name|a_mapelm
operator|<
name|b_mapelm
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Generate red-black tree functions. */
end_comment

begin_macro
name|rb_gen
argument_list|(
argument|static UNUSED
argument_list|,
argument|arena_avail_tree_
argument_list|,
argument|arena_avail_tree_t
argument_list|,
argument|arena_chunk_map_t
argument_list|,
argument|u.rb_link
argument_list|,
argument|arena_avail_comp
argument_list|)
end_macro

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|arena_run_reg_alloc
parameter_list|(
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|arena_bin_info_t
modifier|*
name|bin_info
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|unsigned
name|regind
decl_stmt|;
name|bitmap_t
modifier|*
name|bitmap
init|=
operator|(
name|bitmap_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|+
operator|(
name|uintptr_t
operator|)
name|bin_info
operator|->
name|bitmap_offset
operator|)
decl_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|nfree
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|bitmap_full
argument_list|(
name|bitmap
argument_list|,
operator|&
name|bin_info
operator|->
name|bitmap_info
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
name|regind
operator|=
name|bitmap_sfu
argument_list|(
name|bitmap
argument_list|,
operator|&
name|bin_info
operator|->
name|bitmap_info
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|+
operator|(
name|uintptr_t
operator|)
name|bin_info
operator|->
name|reg0_offset
operator|+
call|(
name|uintptr_t
call|)
argument_list|(
name|bin_info
operator|->
name|reg_interval
operator|*
name|regind
argument_list|)
operator|)
expr_stmt|;
name|run
operator|->
name|nfree
operator|--
expr_stmt|;
if|if
condition|(
name|regind
operator|==
name|run
operator|->
name|nextind
condition|)
name|run
operator|->
name|nextind
operator|++
expr_stmt|;
name|assert
argument_list|(
name|regind
operator|<
name|run
operator|->
name|nextind
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|arena_run_reg_dalloc
parameter_list|(
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
init|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|run
argument_list|)
decl_stmt|;
name|size_t
name|pageind
init|=
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|LG_PAGE
decl_stmt|;
name|size_t
name|mapbits
init|=
name|arena_mapbits_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
decl_stmt|;
name|size_t
name|binind
init|=
name|arena_ptr_small_binind_get
argument_list|(
name|ptr
argument_list|,
name|mapbits
argument_list|)
decl_stmt|;
name|arena_bin_info_t
modifier|*
name|bin_info
init|=
operator|&
name|arena_bin_info
index|[
name|binind
index|]
decl_stmt|;
name|unsigned
name|regind
init|=
name|arena_run_regind
argument_list|(
name|run
argument_list|,
name|bin_info
argument_list|,
name|ptr
argument_list|)
decl_stmt|;
name|bitmap_t
modifier|*
name|bitmap
init|=
operator|(
name|bitmap_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|+
operator|(
name|uintptr_t
operator|)
name|bin_info
operator|->
name|bitmap_offset
operator|)
decl_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|nfree
operator|<
name|bin_info
operator|->
name|nregs
argument_list|)
expr_stmt|;
comment|/* Freeing an interior pointer can cause assertion failure. */
name|assert
argument_list|(
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|+
operator|(
name|uintptr_t
operator|)
name|bin_info
operator|->
name|reg0_offset
operator|)
operator|)
operator|%
operator|(
name|uintptr_t
operator|)
name|bin_info
operator|->
name|reg_interval
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|>=
operator|(
name|uintptr_t
operator|)
name|run
operator|+
operator|(
name|uintptr_t
operator|)
name|bin_info
operator|->
name|reg0_offset
argument_list|)
expr_stmt|;
comment|/* Freeing an unallocated pointer can cause assertion failure. */
name|assert
argument_list|(
name|bitmap_get
argument_list|(
name|bitmap
argument_list|,
operator|&
name|bin_info
operator|->
name|bitmap_info
argument_list|,
name|regind
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_unset
argument_list|(
name|bitmap
argument_list|,
operator|&
name|bin_info
operator|->
name|bitmap_info
argument_list|,
name|regind
argument_list|)
expr_stmt|;
name|run
operator|->
name|nfree
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|arena_chunk_validate_zeroed
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|run_ind
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|UNUSED
name|size_t
modifier|*
name|p
init|=
operator|(
name|size_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
operator|(
name|run_ind
operator|<<
name|LG_PAGE
operator|)
operator|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PAGE
operator|/
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
condition|;
name|i
operator|++
control|)
name|assert
argument_list|(
name|p
index|[
name|i
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_run_split
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|large
parameter_list|,
name|size_t
name|binind
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|size_t
name|run_ind
decl_stmt|,
name|total_pages
decl_stmt|,
name|need_pages
decl_stmt|,
name|rem_pages
decl_stmt|,
name|i
decl_stmt|;
name|size_t
name|flag_dirty
decl_stmt|;
name|arena_avail_tree_t
modifier|*
name|runs_avail
decl_stmt|;
name|assert
argument_list|(
operator|(
name|large
operator|&&
name|binind
operator|==
name|BININD_INVALID
operator|)
operator|||
operator|(
name|large
operator|==
name|false
operator|&&
name|binind
operator|!=
name|BININD_INVALID
operator|)
argument_list|)
expr_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|run
argument_list|)
expr_stmt|;
name|run_ind
operator|=
call|(
name|unsigned
call|)
argument_list|(
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|LG_PAGE
argument_list|)
expr_stmt|;
name|flag_dirty
operator|=
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
expr_stmt|;
name|runs_avail
operator|=
operator|(
name|flag_dirty
operator|!=
literal|0
operator|)
condition|?
operator|&
name|arena
operator|->
name|runs_avail_dirty
else|:
operator|&
name|arena
operator|->
name|runs_avail_clean
expr_stmt|;
name|total_pages
operator|=
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
operator|>>
name|LG_PAGE
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|total_pages
operator|-
literal|1
argument_list|)
operator|==
name|flag_dirty
argument_list|)
expr_stmt|;
name|need_pages
operator|=
operator|(
name|size
operator|>>
name|LG_PAGE
operator|)
expr_stmt|;
name|assert
argument_list|(
name|need_pages
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|need_pages
operator|<=
name|total_pages
argument_list|)
expr_stmt|;
name|rem_pages
operator|=
name|total_pages
operator|-
name|need_pages
expr_stmt|;
name|arena_avail_tree_remove
argument_list|(
name|runs_avail
argument_list|,
name|arena_mapp_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
comment|/* 		 * Update stats_cactive if nactive is crossing a chunk 		 * multiple. 		 */
name|size_t
name|cactive_diff
init|=
name|CHUNK_CEILING
argument_list|(
operator|(
name|arena
operator|->
name|nactive
operator|+
name|need_pages
operator|)
operator|<<
name|LG_PAGE
argument_list|)
operator|-
name|CHUNK_CEILING
argument_list|(
name|arena
operator|->
name|nactive
operator|<<
name|LG_PAGE
argument_list|)
decl_stmt|;
if|if
condition|(
name|cactive_diff
operator|!=
literal|0
condition|)
name|stats_cactive_add
argument_list|(
name|cactive_diff
argument_list|)
expr_stmt|;
block|}
name|arena
operator|->
name|nactive
operator|+=
name|need_pages
expr_stmt|;
comment|/* Keep track of trailing unused pages for later use. */
if|if
condition|(
name|rem_pages
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|flag_dirty
operator|!=
literal|0
condition|)
block|{
name|arena_mapbits_unallocated_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|need_pages
argument_list|,
operator|(
name|rem_pages
operator|<<
name|LG_PAGE
operator|)
argument_list|,
name|CHUNK_MAP_DIRTY
argument_list|)
expr_stmt|;
name|arena_mapbits_unallocated_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|total_pages
operator|-
literal|1
argument_list|,
operator|(
name|rem_pages
operator|<<
name|LG_PAGE
operator|)
argument_list|,
name|CHUNK_MAP_DIRTY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arena_mapbits_unallocated_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|need_pages
argument_list|,
operator|(
name|rem_pages
operator|<<
name|LG_PAGE
operator|)
argument_list|,
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|need_pages
argument_list|)
argument_list|)
expr_stmt|;
name|arena_mapbits_unallocated_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|total_pages
operator|-
literal|1
argument_list|,
operator|(
name|rem_pages
operator|<<
name|LG_PAGE
operator|)
argument_list|,
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|total_pages
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|arena_avail_tree_insert
argument_list|(
name|runs_avail
argument_list|,
name|arena_mapp_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|need_pages
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Update dirty page accounting. */
if|if
condition|(
name|flag_dirty
operator|!=
literal|0
condition|)
block|{
name|chunk
operator|->
name|ndirty
operator|-=
name|need_pages
expr_stmt|;
name|arena
operator|->
name|ndirty
operator|-=
name|need_pages
expr_stmt|;
block|}
comment|/* 	 * Update the page map separately for large vs. small runs, since it is 	 * possible to avoid iteration for large mallocs. 	 */
if|if
condition|(
name|large
condition|)
block|{
if|if
condition|(
name|zero
condition|)
block|{
if|if
condition|(
name|flag_dirty
operator|==
literal|0
condition|)
block|{
comment|/* 				 * The run is clean, so some pages may be 				 * zeroed (i.e. never before touched). 				 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|need_pages
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|VALGRIND_MAKE_MEM_UNDEFINED
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
operator|(
operator|(
name|run_ind
operator|+
name|i
operator|)
operator|<<
name|LG_PAGE
operator|)
operator|)
argument_list|,
name|PAGE
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
operator|(
operator|(
name|run_ind
operator|+
name|i
operator|)
operator|<<
name|LG_PAGE
operator|)
operator|)
argument_list|,
literal|0
argument_list|,
name|PAGE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|config_debug
condition|)
block|{
name|VALGRIND_MAKE_MEM_DEFINED
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
operator|(
operator|(
name|run_ind
operator|+
name|i
operator|)
operator|<<
name|LG_PAGE
operator|)
operator|)
argument_list|,
name|PAGE
argument_list|)
expr_stmt|;
name|arena_chunk_validate_zeroed
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 				 * The run is dirty, so all pages must be 				 * zeroed. 				 */
name|VALGRIND_MAKE_MEM_UNDEFINED
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
operator|(
name|run_ind
operator|<<
name|LG_PAGE
operator|)
operator|)
argument_list|,
operator|(
name|need_pages
operator|<<
name|LG_PAGE
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
operator|(
name|run_ind
operator|<<
name|LG_PAGE
operator|)
operator|)
argument_list|,
literal|0
argument_list|,
operator|(
name|need_pages
operator|<<
name|LG_PAGE
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Set the last element first, in case the run only contains one 		 * page (i.e. both statements set the same element). 		 */
name|arena_mapbits_large_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|need_pages
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|flag_dirty
argument_list|)
expr_stmt|;
name|arena_mapbits_large_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|,
name|size
argument_list|,
name|flag_dirty
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|zero
operator|==
name|false
argument_list|)
expr_stmt|;
comment|/* 		 * Propagate the dirty and unzeroed flags to the allocated 		 * small run, so that arena_dalloc_bin_run() has the ability to 		 * conditionally trim clean pages. 		 */
name|arena_mapbits_small_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|,
literal|0
argument_list|,
name|binind
argument_list|,
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
operator||
name|flag_dirty
argument_list|)
expr_stmt|;
comment|/* 		 * The first page will always be dirtied during small run 		 * initialization, so a validation failure here would not 		 * actually cause an observable failure. 		 */
if|if
condition|(
name|config_debug
operator|&&
name|flag_dirty
operator|==
literal|0
operator|&&
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
operator|==
literal|0
condition|)
name|arena_chunk_validate_zeroed
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|need_pages
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|arena_mapbits_small_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|i
argument_list|,
name|i
argument_list|,
name|binind
argument_list|,
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_debug
operator|&&
name|flag_dirty
operator|==
literal|0
operator|&&
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|i
argument_list|)
operator|==
literal|0
condition|)
name|arena_chunk_validate_zeroed
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|arena_mapbits_small_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|need_pages
operator|-
literal|1
argument_list|,
name|need_pages
operator|-
literal|1
argument_list|,
name|binind
argument_list|,
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|need_pages
operator|-
literal|1
argument_list|)
operator||
name|flag_dirty
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_debug
operator|&&
name|flag_dirty
operator|==
literal|0
operator|&&
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|need_pages
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|arena_chunk_validate_zeroed
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|need_pages
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|arena_chunk_t
modifier|*
name|arena_chunk_alloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|arena
operator|->
name|spare
operator|!=
name|NULL
condition|)
block|{
name|arena_avail_tree_t
modifier|*
name|runs_avail
decl_stmt|;
name|chunk
operator|=
name|arena
operator|->
name|spare
expr_stmt|;
name|arena
operator|->
name|spare
operator|=
name|NULL
expr_stmt|;
comment|/* Insert the run into the appropriate runs_avail_* tree. */
if|if
condition|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|map_bias
argument_list|)
operator|==
literal|0
condition|)
name|runs_avail
operator|=
operator|&
name|arena
operator|->
name|runs_avail_clean
expr_stmt|;
else|else
name|runs_avail
operator|=
operator|&
name|arena
operator|->
name|runs_avail_dirty
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|map_bias
argument_list|)
operator|==
name|arena_maxclass
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|chunk_npages
operator|-
literal|1
argument_list|)
operator|==
name|arena_maxclass
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|map_bias
argument_list|)
operator|==
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|chunk_npages
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|arena_avail_tree_insert
argument_list|(
name|runs_avail
argument_list|,
name|arena_mapp_get
argument_list|(
name|chunk
argument_list|,
name|map_bias
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bool
name|zero
decl_stmt|;
name|size_t
name|unzeroed
decl_stmt|;
name|zero
operator|=
name|false
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|chunk_alloc
argument_list|(
name|chunksize
argument_list|,
name|chunksize
argument_list|,
name|false
argument_list|,
operator|&
name|zero
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|config_stats
condition|)
name|arena
operator|->
name|stats
operator|.
name|mapped
operator|+=
name|chunksize
expr_stmt|;
name|chunk
operator|->
name|arena
operator|=
name|arena
expr_stmt|;
name|ql_elm_new
argument_list|(
name|chunk
argument_list|,
name|link_dirty
argument_list|)
expr_stmt|;
name|chunk
operator|->
name|dirtied
operator|=
name|false
expr_stmt|;
comment|/* 		 * Claim that no pages are in use, since the header is merely 		 * overhead. 		 */
name|chunk
operator|->
name|ndirty
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Initialize the map to contain one maximal free untouched run. 		 * Mark the pages as zeroed iff chunk_alloc() returned a zeroed 		 * chunk. 		 */
name|unzeroed
operator|=
name|zero
condition|?
literal|0
else|:
name|CHUNK_MAP_UNZEROED
expr_stmt|;
name|arena_mapbits_unallocated_set
argument_list|(
name|chunk
argument_list|,
name|map_bias
argument_list|,
name|arena_maxclass
argument_list|,
name|unzeroed
argument_list|)
expr_stmt|;
comment|/* 		 * There is no need to initialize the internal page map entries 		 * unless the chunk is not zeroed. 		 */
if|if
condition|(
name|zero
operator|==
name|false
condition|)
block|{
for|for
control|(
name|i
operator|=
name|map_bias
operator|+
literal|1
init|;
name|i
operator|<
name|chunk_npages
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|arena_mapbits_unzeroed_set
argument_list|(
name|chunk
argument_list|,
name|i
argument_list|,
name|unzeroed
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|config_debug
condition|)
block|{
for|for
control|(
name|i
operator|=
name|map_bias
operator|+
literal|1
init|;
name|i
operator|<
name|chunk_npages
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|assert
argument_list|(
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|i
argument_list|)
operator|==
name|unzeroed
argument_list|)
expr_stmt|;
block|}
block|}
name|arena_mapbits_unallocated_set
argument_list|(
name|chunk
argument_list|,
name|chunk_npages
operator|-
literal|1
argument_list|,
name|arena_maxclass
argument_list|,
name|unzeroed
argument_list|)
expr_stmt|;
comment|/* Insert the run into the runs_avail_clean tree. */
name|arena_avail_tree_insert
argument_list|(
operator|&
name|arena
operator|->
name|runs_avail_clean
argument_list|,
name|arena_mapp_get
argument_list|(
name|chunk
argument_list|,
name|map_bias
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|chunk
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_chunk_dealloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|)
block|{
name|arena_avail_tree_t
modifier|*
name|runs_avail
decl_stmt|;
comment|/* 	 * Remove run from the appropriate runs_avail_* tree, so that the arena 	 * does not use it. 	 */
if|if
condition|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|map_bias
argument_list|)
operator|==
literal|0
condition|)
name|runs_avail
operator|=
operator|&
name|arena
operator|->
name|runs_avail_clean
expr_stmt|;
else|else
name|runs_avail
operator|=
operator|&
name|arena
operator|->
name|runs_avail_dirty
expr_stmt|;
name|arena_avail_tree_remove
argument_list|(
name|runs_avail
argument_list|,
name|arena_mapp_get
argument_list|(
name|chunk
argument_list|,
name|map_bias
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arena
operator|->
name|spare
operator|!=
name|NULL
condition|)
block|{
name|arena_chunk_t
modifier|*
name|spare
init|=
name|arena
operator|->
name|spare
decl_stmt|;
name|arena
operator|->
name|spare
operator|=
name|chunk
expr_stmt|;
if|if
condition|(
name|spare
operator|->
name|dirtied
condition|)
block|{
name|ql_remove
argument_list|(
operator|&
name|chunk
operator|->
name|arena
operator|->
name|chunks_dirty
argument_list|,
name|spare
argument_list|,
name|link_dirty
argument_list|)
expr_stmt|;
name|arena
operator|->
name|ndirty
operator|-=
name|spare
operator|->
name|ndirty
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|chunk_dealloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|spare
argument_list|,
name|chunksize
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
name|arena
operator|->
name|stats
operator|.
name|mapped
operator|-=
name|chunksize
expr_stmt|;
block|}
else|else
name|arena
operator|->
name|spare
operator|=
name|chunk
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|arena_run_t
modifier|*
name|arena_run_alloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|large
parameter_list|,
name|size_t
name|binind
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|arena_chunk_map_t
modifier|*
name|mapelm
decl_stmt|,
name|key
decl_stmt|;
name|assert
argument_list|(
name|size
operator|<=
name|arena_maxclass
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|size
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|large
operator|&&
name|binind
operator|==
name|BININD_INVALID
operator|)
operator|||
operator|(
name|large
operator|==
name|false
operator|&&
name|binind
operator|!=
name|BININD_INVALID
operator|)
argument_list|)
expr_stmt|;
comment|/* Search the arena's chunks for the lowest best fit. */
name|key
operator|.
name|bits
operator|=
name|size
operator||
name|CHUNK_MAP_KEY
expr_stmt|;
name|mapelm
operator|=
name|arena_avail_tree_nsearch
argument_list|(
operator|&
name|arena
operator|->
name|runs_avail_dirty
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapelm
operator|!=
name|NULL
condition|)
block|{
name|arena_chunk_t
modifier|*
name|run_chunk
init|=
name|CHUNK_ADDR2BASE
argument_list|(
name|mapelm
argument_list|)
decl_stmt|;
name|size_t
name|pageind
init|=
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|mapelm
operator|-
operator|(
name|uintptr_t
operator|)
name|run_chunk
operator|->
name|map
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|arena_chunk_map_t
argument_list|)
operator|)
operator|+
name|map_bias
decl_stmt|;
name|run
operator|=
operator|(
name|arena_run_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|run_chunk
operator|+
operator|(
name|pageind
operator|<<
name|LG_PAGE
operator|)
operator|)
expr_stmt|;
name|arena_run_split
argument_list|(
name|arena
argument_list|,
name|run
argument_list|,
name|size
argument_list|,
name|large
argument_list|,
name|binind
argument_list|,
name|zero
argument_list|)
expr_stmt|;
return|return
operator|(
name|run
operator|)
return|;
block|}
name|mapelm
operator|=
name|arena_avail_tree_nsearch
argument_list|(
operator|&
name|arena
operator|->
name|runs_avail_clean
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapelm
operator|!=
name|NULL
condition|)
block|{
name|arena_chunk_t
modifier|*
name|run_chunk
init|=
name|CHUNK_ADDR2BASE
argument_list|(
name|mapelm
argument_list|)
decl_stmt|;
name|size_t
name|pageind
init|=
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|mapelm
operator|-
operator|(
name|uintptr_t
operator|)
name|run_chunk
operator|->
name|map
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|arena_chunk_map_t
argument_list|)
operator|)
operator|+
name|map_bias
decl_stmt|;
name|run
operator|=
operator|(
name|arena_run_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|run_chunk
operator|+
operator|(
name|pageind
operator|<<
name|LG_PAGE
operator|)
operator|)
expr_stmt|;
name|arena_run_split
argument_list|(
name|arena
argument_list|,
name|run
argument_list|,
name|size
argument_list|,
name|large
argument_list|,
name|binind
argument_list|,
name|zero
argument_list|)
expr_stmt|;
return|return
operator|(
name|run
operator|)
return|;
block|}
comment|/* 	 * No usable runs.  Create a new chunk from which to allocate the run. 	 */
name|chunk
operator|=
name|arena_chunk_alloc
argument_list|(
name|arena
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|!=
name|NULL
condition|)
block|{
name|run
operator|=
operator|(
name|arena_run_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
operator|(
name|map_bias
operator|<<
name|LG_PAGE
operator|)
operator|)
expr_stmt|;
name|arena_run_split
argument_list|(
name|arena
argument_list|,
name|run
argument_list|,
name|size
argument_list|,
name|large
argument_list|,
name|binind
argument_list|,
name|zero
argument_list|)
expr_stmt|;
return|return
operator|(
name|run
operator|)
return|;
block|}
comment|/* 	 * arena_chunk_alloc() failed, but another thread may have made 	 * sufficient memory available while this one dropped arena->lock in 	 * arena_chunk_alloc(), so search one more time. 	 */
name|mapelm
operator|=
name|arena_avail_tree_nsearch
argument_list|(
operator|&
name|arena
operator|->
name|runs_avail_dirty
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapelm
operator|!=
name|NULL
condition|)
block|{
name|arena_chunk_t
modifier|*
name|run_chunk
init|=
name|CHUNK_ADDR2BASE
argument_list|(
name|mapelm
argument_list|)
decl_stmt|;
name|size_t
name|pageind
init|=
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|mapelm
operator|-
operator|(
name|uintptr_t
operator|)
name|run_chunk
operator|->
name|map
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|arena_chunk_map_t
argument_list|)
operator|)
operator|+
name|map_bias
decl_stmt|;
name|run
operator|=
operator|(
name|arena_run_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|run_chunk
operator|+
operator|(
name|pageind
operator|<<
name|LG_PAGE
operator|)
operator|)
expr_stmt|;
name|arena_run_split
argument_list|(
name|arena
argument_list|,
name|run
argument_list|,
name|size
argument_list|,
name|large
argument_list|,
name|binind
argument_list|,
name|zero
argument_list|)
expr_stmt|;
return|return
operator|(
name|run
operator|)
return|;
block|}
name|mapelm
operator|=
name|arena_avail_tree_nsearch
argument_list|(
operator|&
name|arena
operator|->
name|runs_avail_clean
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapelm
operator|!=
name|NULL
condition|)
block|{
name|arena_chunk_t
modifier|*
name|run_chunk
init|=
name|CHUNK_ADDR2BASE
argument_list|(
name|mapelm
argument_list|)
decl_stmt|;
name|size_t
name|pageind
init|=
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|mapelm
operator|-
operator|(
name|uintptr_t
operator|)
name|run_chunk
operator|->
name|map
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|arena_chunk_map_t
argument_list|)
operator|)
operator|+
name|map_bias
decl_stmt|;
name|run
operator|=
operator|(
name|arena_run_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|run_chunk
operator|+
operator|(
name|pageind
operator|<<
name|LG_PAGE
operator|)
operator|)
expr_stmt|;
name|arena_run_split
argument_list|(
name|arena
argument_list|,
name|run
argument_list|,
name|size
argument_list|,
name|large
argument_list|,
name|binind
argument_list|,
name|zero
argument_list|)
expr_stmt|;
return|return
operator|(
name|run
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|arena_maybe_purge
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
comment|/* Enforce opt_lg_dirty_mult. */
if|if
condition|(
name|opt_lg_dirty_mult
operator|>=
literal|0
operator|&&
name|arena
operator|->
name|ndirty
operator|>
name|arena
operator|->
name|npurgatory
operator|&&
operator|(
name|arena
operator|->
name|ndirty
operator|-
name|arena
operator|->
name|npurgatory
operator|)
operator|>
name|chunk_npages
operator|&&
operator|(
name|arena
operator|->
name|nactive
operator|>>
name|opt_lg_dirty_mult
operator|)
operator|<
operator|(
name|arena
operator|->
name|ndirty
operator|-
name|arena
operator|->
name|npurgatory
operator|)
condition|)
name|arena_purge
argument_list|(
name|arena
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|arena_chunk_purge
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|)
block|{
name|ql_head
argument_list|(
argument|arena_chunk_map_t
argument_list|)
name|mapelms
expr_stmt|;
name|arena_chunk_map_t
modifier|*
name|mapelm
decl_stmt|;
name|size_t
name|pageind
decl_stmt|,
name|flag_unzeroed
decl_stmt|;
name|size_t
name|ndirty
decl_stmt|;
name|size_t
name|nmadvise
decl_stmt|;
name|ql_new
argument_list|(
operator|&
name|mapelms
argument_list|)
expr_stmt|;
name|flag_unzeroed
operator|=
ifdef|#
directive|ifdef
name|JEMALLOC_PURGE_MADVISE_DONTNEED
comment|/*     * madvise(..., MADV_DONTNEED) results in zero-filled pages for anonymous     * mappings, but not for file-backed mappings.     */
literal|0
else|#
directive|else
name|CHUNK_MAP_UNZEROED
endif|#
directive|endif
expr_stmt|;
comment|/* 	 * If chunk is the spare, temporarily re-allocate it, 1) so that its 	 * run is reinserted into runs_avail_dirty, and 2) so that it cannot be 	 * completely discarded by another thread while arena->lock is dropped 	 * by this thread.  Note that the arena_run_dalloc() call will 	 * implicitly deallocate the chunk, so no explicit action is required 	 * in this function to deallocate the chunk. 	 * 	 * Note that once a chunk contains dirty pages, it cannot again contain 	 * a single run unless 1) it is a dirty run, or 2) this function purges 	 * dirty pages and causes the transition to a single clean run.  Thus 	 * (chunk == arena->spare) is possible, but it is not possible for 	 * this function to be called on the spare unless it contains a dirty 	 * run. 	 */
if|if
condition|(
name|chunk
operator|==
name|arena
operator|->
name|spare
condition|)
block|{
name|assert
argument_list|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|map_bias
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|arena_chunk_alloc
argument_list|(
name|arena
argument_list|)
expr_stmt|;
block|}
comment|/* Temporarily allocate all free dirty runs within chunk. */
for|for
control|(
name|pageind
operator|=
name|map_bias
init|;
name|pageind
operator|<
name|chunk_npages
condition|;
control|)
block|{
name|mapelm
operator|=
name|arena_mapp_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
expr_stmt|;
if|if
condition|(
name|arena_mapbits_allocated_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|==
literal|0
condition|)
block|{
name|size_t
name|npages
decl_stmt|;
name|npages
operator|=
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|>>
name|LG_PAGE
expr_stmt|;
name|assert
argument_list|(
name|pageind
operator|+
name|npages
operator|<=
name|chunk_npages
argument_list|)
expr_stmt|;
if|if
condition|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
condition|)
block|{
name|size_t
name|i
decl_stmt|;
name|arena_avail_tree_remove
argument_list|(
operator|&
name|arena
operator|->
name|runs_avail_dirty
argument_list|,
name|mapelm
argument_list|)
expr_stmt|;
name|arena_mapbits_large_set
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|,
operator|(
name|npages
operator|<<
name|LG_PAGE
operator|)
argument_list|,
name|flag_unzeroed
argument_list|)
expr_stmt|;
comment|/* 				 * Update internal elements in the page map, so 				 * that CHUNK_MAP_UNZEROED is properly set. 				 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npages
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|arena_mapbits_unzeroed_set
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|i
argument_list|,
name|flag_unzeroed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|npages
operator|>
literal|1
condition|)
block|{
name|arena_mapbits_large_set
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|npages
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|flag_unzeroed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config_stats
condition|)
block|{
comment|/* 					 * Update stats_cactive if nactive is 					 * crossing a chunk multiple. 					 */
name|size_t
name|cactive_diff
init|=
name|CHUNK_CEILING
argument_list|(
operator|(
name|arena
operator|->
name|nactive
operator|+
name|npages
operator|)
operator|<<
name|LG_PAGE
argument_list|)
operator|-
name|CHUNK_CEILING
argument_list|(
name|arena
operator|->
name|nactive
operator|<<
name|LG_PAGE
argument_list|)
decl_stmt|;
if|if
condition|(
name|cactive_diff
operator|!=
literal|0
condition|)
name|stats_cactive_add
argument_list|(
name|cactive_diff
argument_list|)
expr_stmt|;
block|}
name|arena
operator|->
name|nactive
operator|+=
name|npages
expr_stmt|;
comment|/* Append to list for later processing. */
name|ql_elm_new
argument_list|(
name|mapelm
argument_list|,
name|u
operator|.
name|ql_link
argument_list|)
expr_stmt|;
name|ql_tail_insert
argument_list|(
operator|&
name|mapelms
argument_list|,
name|mapelm
argument_list|,
name|u
operator|.
name|ql_link
argument_list|)
expr_stmt|;
block|}
name|pageind
operator|+=
name|npages
expr_stmt|;
block|}
else|else
block|{
comment|/* Skip allocated run. */
if|if
condition|(
name|arena_mapbits_large_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
condition|)
name|pageind
operator|+=
name|arena_mapbits_large_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|>>
name|LG_PAGE
expr_stmt|;
else|else
block|{
name|size_t
name|binind
decl_stmt|;
name|arena_bin_info_t
modifier|*
name|bin_info
decl_stmt|;
name|arena_run_t
modifier|*
name|run
init|=
operator|(
name|arena_run_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
call|(
name|uintptr_t
call|)
argument_list|(
name|pageind
operator|<<
name|LG_PAGE
argument_list|)
operator|)
decl_stmt|;
name|assert
argument_list|(
name|arena_mapbits_small_runind_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|binind
operator|=
name|arena_bin_index
argument_list|(
name|arena
argument_list|,
name|run
operator|->
name|bin
argument_list|)
expr_stmt|;
name|bin_info
operator|=
operator|&
name|arena_bin_info
index|[
name|binind
index|]
expr_stmt|;
name|pageind
operator|+=
name|bin_info
operator|->
name|run_size
operator|>>
name|LG_PAGE
expr_stmt|;
block|}
block|}
block|}
name|assert
argument_list|(
name|pageind
operator|==
name|chunk_npages
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_debug
condition|)
name|ndirty
operator|=
name|chunk
operator|->
name|ndirty
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
name|arena
operator|->
name|stats
operator|.
name|purged
operator|+=
name|chunk
operator|->
name|ndirty
expr_stmt|;
name|arena
operator|->
name|ndirty
operator|-=
name|chunk
operator|->
name|ndirty
expr_stmt|;
name|chunk
operator|->
name|ndirty
operator|=
literal|0
expr_stmt|;
name|ql_remove
argument_list|(
operator|&
name|arena
operator|->
name|chunks_dirty
argument_list|,
name|chunk
argument_list|,
name|link_dirty
argument_list|)
expr_stmt|;
name|chunk
operator|->
name|dirtied
operator|=
name|false
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
name|nmadvise
operator|=
literal|0
expr_stmt|;
name|ql_foreach
argument_list|(
argument|mapelm
argument_list|,
argument|&mapelms
argument_list|,
argument|u.ql_link
argument_list|)
block|{
name|size_t
name|pageind
init|=
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|mapelm
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|->
name|map
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|arena_chunk_map_t
argument_list|)
operator|)
operator|+
name|map_bias
decl_stmt|;
name|size_t
name|npages
init|=
name|arena_mapbits_large_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|>>
name|LG_PAGE
decl_stmt|;
name|assert
argument_list|(
name|pageind
operator|+
name|npages
operator|<=
name|chunk_npages
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ndirty
operator|>=
name|npages
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_debug
condition|)
name|ndirty
operator|-=
name|npages
expr_stmt|;
name|pages_purge
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
operator|(
name|pageind
operator|<<
name|LG_PAGE
operator|)
operator|)
argument_list|,
operator|(
name|npages
operator|<<
name|LG_PAGE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
name|nmadvise
operator|++
expr_stmt|;
block|}
name|assert
argument_list|(
name|ndirty
operator|==
literal|0
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
name|arena
operator|->
name|stats
operator|.
name|nmadvise
operator|+=
name|nmadvise
expr_stmt|;
comment|/* Deallocate runs. */
for|for
control|(
name|mapelm
operator|=
name|ql_first
argument_list|(
operator|&
name|mapelms
argument_list|)
init|;
name|mapelm
operator|!=
name|NULL
condition|;
name|mapelm
operator|=
name|ql_first
argument_list|(
operator|&
name|mapelms
argument_list|)
control|)
block|{
name|size_t
name|pageind
init|=
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|mapelm
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|->
name|map
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|arena_chunk_map_t
argument_list|)
operator|)
operator|+
name|map_bias
decl_stmt|;
name|arena_run_t
modifier|*
name|run
init|=
operator|(
name|arena_run_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
call|(
name|uintptr_t
call|)
argument_list|(
name|pageind
operator|<<
name|LG_PAGE
argument_list|)
operator|)
decl_stmt|;
name|ql_remove
argument_list|(
operator|&
name|mapelms
argument_list|,
name|mapelm
argument_list|,
name|u
operator|.
name|ql_link
argument_list|)
expr_stmt|;
name|arena_run_dalloc
argument_list|(
name|arena
argument_list|,
name|run
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arena_purge
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|bool
name|all
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|size_t
name|npurgatory
decl_stmt|;
if|if
condition|(
name|config_debug
condition|)
block|{
name|size_t
name|ndirty
init|=
literal|0
decl_stmt|;
name|ql_foreach
argument_list|(
argument|chunk
argument_list|,
argument|&arena->chunks_dirty
argument_list|,
argument|link_dirty
argument_list|)
block|{
name|assert
argument_list|(
name|chunk
operator|->
name|dirtied
argument_list|)
expr_stmt|;
name|ndirty
operator|+=
name|chunk
operator|->
name|ndirty
expr_stmt|;
block|}
name|assert
argument_list|(
name|ndirty
operator|==
name|arena
operator|->
name|ndirty
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|arena
operator|->
name|ndirty
operator|>
name|arena
operator|->
name|npurgatory
operator|||
name|all
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena
operator|->
name|ndirty
operator|-
name|arena
operator|->
name|npurgatory
operator|>
name|chunk_npages
operator|||
name|all
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|arena
operator|->
name|nactive
operator|>>
name|opt_lg_dirty_mult
operator|)
operator|<
operator|(
name|arena
operator|->
name|ndirty
operator|-
name|arena
operator|->
name|npurgatory
operator|)
operator|||
name|all
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
name|arena
operator|->
name|stats
operator|.
name|npurge
operator|++
expr_stmt|;
comment|/* 	 * Compute the minimum number of pages that this thread should try to 	 * purge, and add the result to arena->npurgatory.  This will keep 	 * multiple threads from racing to reduce ndirty below the threshold. 	 */
name|npurgatory
operator|=
name|arena
operator|->
name|ndirty
operator|-
name|arena
operator|->
name|npurgatory
expr_stmt|;
if|if
condition|(
name|all
operator|==
name|false
condition|)
block|{
name|assert
argument_list|(
name|npurgatory
operator|>=
name|arena
operator|->
name|nactive
operator|>>
name|opt_lg_dirty_mult
argument_list|)
expr_stmt|;
name|npurgatory
operator|-=
name|arena
operator|->
name|nactive
operator|>>
name|opt_lg_dirty_mult
expr_stmt|;
block|}
name|arena
operator|->
name|npurgatory
operator|+=
name|npurgatory
expr_stmt|;
while|while
condition|(
name|npurgatory
operator|>
literal|0
condition|)
block|{
comment|/* Get next chunk with dirty pages. */
name|chunk
operator|=
name|ql_first
argument_list|(
operator|&
name|arena
operator|->
name|chunks_dirty
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * This thread was unable to purge as many pages as 			 * originally intended, due to races with other threads 			 * that either did some of the purging work, or re-used 			 * dirty pages. 			 */
name|arena
operator|->
name|npurgatory
operator|-=
name|npurgatory
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|chunk
operator|->
name|ndirty
operator|==
literal|0
condition|)
block|{
name|ql_remove
argument_list|(
operator|&
name|arena
operator|->
name|chunks_dirty
argument_list|,
name|chunk
argument_list|,
name|link_dirty
argument_list|)
expr_stmt|;
name|chunk
operator|->
name|dirtied
operator|=
name|false
expr_stmt|;
name|chunk
operator|=
name|ql_first
argument_list|(
operator|&
name|arena
operator|->
name|chunks_dirty
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|==
name|NULL
condition|)
block|{
comment|/* Same logic as for above. */
name|arena
operator|->
name|npurgatory
operator|-=
name|npurgatory
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|chunk
operator|->
name|ndirty
operator|>
name|npurgatory
condition|)
block|{
comment|/* 			 * This thread will, at a minimum, purge all the dirty 			 * pages in chunk, so set npurgatory to reflect this 			 * thread's commitment to purge the pages.  This tends 			 * to reduce the chances of the following scenario: 			 * 			 * 1) This thread sets arena->npurgatory such that 			 *    (arena->ndirty - arena->npurgatory) is at the 			 *    threshold. 			 * 2) This thread drops arena->lock. 			 * 3) Another thread causes one or more pages to be 			 *    dirtied, and immediately determines that it must 			 *    purge dirty pages. 			 * 			 * If this scenario *does* play out, that's okay, 			 * because all of the purging work being done really 			 * needs to happen. 			 */
name|arena
operator|->
name|npurgatory
operator|+=
name|chunk
operator|->
name|ndirty
operator|-
name|npurgatory
expr_stmt|;
name|npurgatory
operator|=
name|chunk
operator|->
name|ndirty
expr_stmt|;
block|}
name|arena
operator|->
name|npurgatory
operator|-=
name|chunk
operator|->
name|ndirty
expr_stmt|;
name|npurgatory
operator|-=
name|chunk
operator|->
name|ndirty
expr_stmt|;
name|arena_chunk_purge
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|arena_purge_all
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arena_purge
argument_list|(
name|arena
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_run_dalloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|bool
name|dirty
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|run_ind
decl_stmt|,
name|run_pages
decl_stmt|,
name|flag_dirty
decl_stmt|;
name|arena_avail_tree_t
modifier|*
name|runs_avail
decl_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|run
argument_list|)
expr_stmt|;
name|run_ind
operator|=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|LG_PAGE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|run_ind
operator|>=
name|map_bias
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|run_ind
operator|<
name|chunk_npages
argument_list|)
expr_stmt|;
if|if
condition|(
name|arena_mapbits_large_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|size
operator|=
name|arena_mapbits_large_size_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|==
name|PAGE
operator|||
name|arena_mapbits_large_size_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
operator|(
name|size
operator|>>
name|LG_PAGE
operator|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|binind
init|=
name|arena_bin_index
argument_list|(
name|arena
argument_list|,
name|run
operator|->
name|bin
argument_list|)
decl_stmt|;
name|arena_bin_info_t
modifier|*
name|bin_info
init|=
operator|&
name|arena_bin_info
index|[
name|binind
index|]
decl_stmt|;
name|size
operator|=
name|bin_info
operator|->
name|run_size
expr_stmt|;
block|}
name|run_pages
operator|=
operator|(
name|size
operator|>>
name|LG_PAGE
operator|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
comment|/* 		 * Update stats_cactive if nactive is crossing a chunk 		 * multiple. 		 */
name|size_t
name|cactive_diff
init|=
name|CHUNK_CEILING
argument_list|(
name|arena
operator|->
name|nactive
operator|<<
name|LG_PAGE
argument_list|)
operator|-
name|CHUNK_CEILING
argument_list|(
operator|(
name|arena
operator|->
name|nactive
operator|-
name|run_pages
operator|)
operator|<<
name|LG_PAGE
argument_list|)
decl_stmt|;
if|if
condition|(
name|cactive_diff
operator|!=
literal|0
condition|)
name|stats_cactive_sub
argument_list|(
name|cactive_diff
argument_list|)
expr_stmt|;
block|}
name|arena
operator|->
name|nactive
operator|-=
name|run_pages
expr_stmt|;
comment|/* 	 * The run is dirty if the caller claims to have dirtied it, as well as 	 * if it was already dirty before being allocated. 	 */
if|if
condition|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
operator|!=
literal|0
condition|)
name|dirty
operator|=
name|true
expr_stmt|;
name|flag_dirty
operator|=
name|dirty
condition|?
name|CHUNK_MAP_DIRTY
else|:
literal|0
expr_stmt|;
name|runs_avail
operator|=
name|dirty
condition|?
operator|&
name|arena
operator|->
name|runs_avail_dirty
else|:
operator|&
name|arena
operator|->
name|runs_avail_clean
expr_stmt|;
comment|/* Mark pages as unallocated in the chunk map. */
if|if
condition|(
name|dirty
condition|)
block|{
name|arena_mapbits_unallocated_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|,
name|size
argument_list|,
name|CHUNK_MAP_DIRTY
argument_list|)
expr_stmt|;
name|arena_mapbits_unallocated_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
argument_list|,
name|size
argument_list|,
name|CHUNK_MAP_DIRTY
argument_list|)
expr_stmt|;
name|chunk
operator|->
name|ndirty
operator|+=
name|run_pages
expr_stmt|;
name|arena
operator|->
name|ndirty
operator|+=
name|run_pages
expr_stmt|;
block|}
else|else
block|{
name|arena_mapbits_unallocated_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|,
name|size
argument_list|,
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
argument_list|)
expr_stmt|;
name|arena_mapbits_unallocated_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
argument_list|,
name|size
argument_list|,
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Try to coalesce forward. */
if|if
condition|(
name|run_ind
operator|+
name|run_pages
operator|<
name|chunk_npages
operator|&&
name|arena_mapbits_allocated_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
argument_list|)
operator|==
literal|0
operator|&&
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
argument_list|)
operator|==
name|flag_dirty
condition|)
block|{
name|size_t
name|nrun_size
init|=
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
argument_list|)
decl_stmt|;
name|size_t
name|nrun_pages
init|=
name|nrun_size
operator|>>
name|LG_PAGE
decl_stmt|;
comment|/* 		 * Remove successor from runs_avail; the coalesced run is 		 * inserted later. 		 */
name|assert
argument_list|(
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
operator|+
name|nrun_pages
operator|-
literal|1
argument_list|)
operator|==
name|nrun_size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
operator|+
name|nrun_pages
operator|-
literal|1
argument_list|)
operator|==
name|flag_dirty
argument_list|)
expr_stmt|;
name|arena_avail_tree_remove
argument_list|(
name|runs_avail
argument_list|,
name|arena_mapp_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|+=
name|nrun_size
expr_stmt|;
name|run_pages
operator|+=
name|nrun_pages
expr_stmt|;
name|arena_mapbits_unallocated_size_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|arena_mapbits_unallocated_size_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* Try to coalesce backward. */
if|if
condition|(
name|run_ind
operator|>
name|map_bias
operator|&&
name|arena_mapbits_allocated_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|-
literal|1
argument_list|)
operator|==
name|flag_dirty
condition|)
block|{
name|size_t
name|prun_size
init|=
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|-
literal|1
argument_list|)
decl_stmt|;
name|size_t
name|prun_pages
init|=
name|prun_size
operator|>>
name|LG_PAGE
decl_stmt|;
name|run_ind
operator|-=
name|prun_pages
expr_stmt|;
comment|/* 		 * Remove predecessor from runs_avail; the coalesced run is 		 * inserted later. 		 */
name|assert
argument_list|(
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
operator|==
name|prun_size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
operator|==
name|flag_dirty
argument_list|)
expr_stmt|;
name|arena_avail_tree_remove
argument_list|(
name|runs_avail
argument_list|,
name|arena_mapp_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|+=
name|prun_size
expr_stmt|;
name|run_pages
operator|+=
name|prun_pages
expr_stmt|;
name|arena_mapbits_unallocated_size_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|arena_mapbits_unallocated_size_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* Insert into runs_avail, now that coalescing is complete. */
name|assert
argument_list|(
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
operator|==
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
operator|==
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|arena_avail_tree_insert
argument_list|(
name|runs_avail
argument_list|,
name|arena_mapp_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirty
condition|)
block|{
comment|/* 		 * Insert into chunks_dirty before potentially calling 		 * arena_chunk_dealloc(), so that chunks_dirty and 		 * arena->ndirty are consistent. 		 */
if|if
condition|(
name|chunk
operator|->
name|dirtied
operator|==
name|false
condition|)
block|{
name|ql_tail_insert
argument_list|(
operator|&
name|arena
operator|->
name|chunks_dirty
argument_list|,
name|chunk
argument_list|,
name|link_dirty
argument_list|)
expr_stmt|;
name|chunk
operator|->
name|dirtied
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* Deallocate chunk if it is now completely unused. */
if|if
condition|(
name|size
operator|==
name|arena_maxclass
condition|)
block|{
name|assert
argument_list|(
name|run_ind
operator|==
name|map_bias
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|run_pages
operator|==
operator|(
name|arena_maxclass
operator|>>
name|LG_PAGE
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_allocated_get
argument_list|(
name|chunk
argument_list|,
name|map_bias
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|map_bias
argument_list|)
operator|==
name|arena_maxclass
argument_list|)
expr_stmt|;
name|arena_chunk_dealloc
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * It is okay to do dirty page processing here even if the chunk was 	 * deallocated above, since in that case it is the spare.  Waiting 	 * until after possible chunk deallocation to do dirty processing 	 * allows for an old spare to be fully deallocated, thus decreasing the 	 * chances of spuriously crossing the dirty page purging threshold. 	 */
if|if
condition|(
name|dirty
condition|)
name|arena_maybe_purge
argument_list|(
name|arena
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_run_trim_head
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|newsize
parameter_list|)
block|{
name|size_t
name|pageind
init|=
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|LG_PAGE
decl_stmt|;
name|size_t
name|head_npages
init|=
operator|(
name|oldsize
operator|-
name|newsize
operator|)
operator|>>
name|LG_PAGE
decl_stmt|;
name|size_t
name|flag_dirty
init|=
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|oldsize
operator|>
name|newsize
argument_list|)
expr_stmt|;
comment|/* 	 * Update the chunk map so that arena_run_dalloc() can treat the 	 * leading run as separately allocated.  Set the last element of each 	 * run first, in case of single-page runs. 	 */
name|assert
argument_list|(
name|arena_mapbits_large_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|==
name|oldsize
argument_list|)
expr_stmt|;
name|arena_mapbits_large_set
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|head_npages
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|flag_dirty
operator||
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|head_npages
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|arena_mapbits_large_set
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|,
name|oldsize
operator|-
name|newsize
argument_list|,
name|flag_dirty
operator||
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_debug
condition|)
block|{
name|UNUSED
name|size_t
name|tail_npages
init|=
name|newsize
operator|>>
name|LG_PAGE
decl_stmt|;
name|assert
argument_list|(
name|arena_mapbits_large_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|head_npages
operator|+
name|tail_npages
operator|-
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|head_npages
operator|+
name|tail_npages
operator|-
literal|1
argument_list|)
operator|==
name|flag_dirty
argument_list|)
expr_stmt|;
block|}
name|arena_mapbits_large_set
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|head_npages
argument_list|,
name|newsize
argument_list|,
name|flag_dirty
operator||
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|head_npages
argument_list|)
argument_list|)
expr_stmt|;
name|arena_run_dalloc
argument_list|(
name|arena
argument_list|,
name|run
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_run_trim_tail
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|newsize
parameter_list|,
name|bool
name|dirty
parameter_list|)
block|{
name|size_t
name|pageind
init|=
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|LG_PAGE
decl_stmt|;
name|size_t
name|head_npages
init|=
name|newsize
operator|>>
name|LG_PAGE
decl_stmt|;
name|size_t
name|flag_dirty
init|=
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|oldsize
operator|>
name|newsize
argument_list|)
expr_stmt|;
comment|/* 	 * Update the chunk map so that arena_run_dalloc() can treat the 	 * trailing run as separately allocated.  Set the last element of each 	 * run first, in case of single-page runs. 	 */
name|assert
argument_list|(
name|arena_mapbits_large_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|==
name|oldsize
argument_list|)
expr_stmt|;
name|arena_mapbits_large_set
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|head_npages
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|flag_dirty
operator||
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|head_npages
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|arena_mapbits_large_set
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|,
name|newsize
argument_list|,
name|flag_dirty
operator||
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_debug
condition|)
block|{
name|UNUSED
name|size_t
name|tail_npages
init|=
operator|(
name|oldsize
operator|-
name|newsize
operator|)
operator|>>
name|LG_PAGE
decl_stmt|;
name|assert
argument_list|(
name|arena_mapbits_large_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|head_npages
operator|+
name|tail_npages
operator|-
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|head_npages
operator|+
name|tail_npages
operator|-
literal|1
argument_list|)
operator|==
name|flag_dirty
argument_list|)
expr_stmt|;
block|}
name|arena_mapbits_large_set
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|head_npages
argument_list|,
name|oldsize
operator|-
name|newsize
argument_list|,
name|flag_dirty
operator||
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|head_npages
argument_list|)
argument_list|)
expr_stmt|;
name|arena_run_dalloc
argument_list|(
name|arena
argument_list|,
operator|(
name|arena_run_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|+
name|newsize
operator|)
argument_list|,
name|dirty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|arena_run_t
modifier|*
name|arena_bin_runs_first
parameter_list|(
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
block|{
name|arena_chunk_map_t
modifier|*
name|mapelm
init|=
name|arena_run_tree_first
argument_list|(
operator|&
name|bin
operator|->
name|runs
argument_list|)
decl_stmt|;
if|if
condition|(
name|mapelm
operator|!=
name|NULL
condition|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|size_t
name|pageind
decl_stmt|;
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|mapelm
argument_list|)
expr_stmt|;
name|pageind
operator|=
operator|(
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|mapelm
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|->
name|map
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|arena_chunk_map_t
argument_list|)
operator|)
operator|)
operator|+
name|map_bias
expr_stmt|;
name|run
operator|=
operator|(
name|arena_run_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
call|(
name|uintptr_t
call|)
argument_list|(
operator|(
name|pageind
operator|-
name|arena_mapbits_small_runind_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|)
operator|<<
name|LG_PAGE
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|run
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_bin_runs_insert
parameter_list|(
name|arena_bin_t
modifier|*
name|bin
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
init|=
name|CHUNK_ADDR2BASE
argument_list|(
name|run
argument_list|)
decl_stmt|;
name|size_t
name|pageind
init|=
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|LG_PAGE
decl_stmt|;
name|arena_chunk_map_t
modifier|*
name|mapelm
init|=
name|arena_mapp_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|arena_run_tree_search
argument_list|(
operator|&
name|bin
operator|->
name|runs
argument_list|,
name|mapelm
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|arena_run_tree_insert
argument_list|(
operator|&
name|bin
operator|->
name|runs
argument_list|,
name|mapelm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_bin_runs_remove
parameter_list|(
name|arena_bin_t
modifier|*
name|bin
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
init|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|run
argument_list|)
decl_stmt|;
name|size_t
name|pageind
init|=
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|LG_PAGE
decl_stmt|;
name|arena_chunk_map_t
modifier|*
name|mapelm
init|=
name|arena_mapp_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|arena_run_tree_search
argument_list|(
operator|&
name|bin
operator|->
name|runs
argument_list|,
name|mapelm
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|arena_run_tree_remove
argument_list|(
operator|&
name|bin
operator|->
name|runs
argument_list|,
name|mapelm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|arena_run_t
modifier|*
name|arena_bin_nonfull_run_tryget
parameter_list|(
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
block|{
name|arena_run_t
modifier|*
name|run
init|=
name|arena_bin_runs_first
argument_list|(
name|bin
argument_list|)
decl_stmt|;
if|if
condition|(
name|run
operator|!=
name|NULL
condition|)
block|{
name|arena_bin_runs_remove
argument_list|(
name|bin
argument_list|,
name|run
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
name|bin
operator|->
name|stats
operator|.
name|reruns
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|run
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|arena_run_t
modifier|*
name|arena_bin_nonfull_run_get
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
block|{
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|size_t
name|binind
decl_stmt|;
name|arena_bin_info_t
modifier|*
name|bin_info
decl_stmt|;
comment|/* Look for a usable run. */
name|run
operator|=
name|arena_bin_nonfull_run_tryget
argument_list|(
name|bin
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
operator|!=
name|NULL
condition|)
return|return
operator|(
name|run
operator|)
return|;
comment|/* No existing runs have any space available. */
name|binind
operator|=
name|arena_bin_index
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|)
expr_stmt|;
name|bin_info
operator|=
operator|&
name|arena_bin_info
index|[
name|binind
index|]
expr_stmt|;
comment|/* Allocate a new run. */
name|malloc_mutex_unlock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/******************************/
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|run
operator|=
name|arena_run_alloc
argument_list|(
name|arena
argument_list|,
name|bin_info
operator|->
name|run_size
argument_list|,
name|false
argument_list|,
name|binind
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
operator|!=
name|NULL
condition|)
block|{
name|bitmap_t
modifier|*
name|bitmap
init|=
operator|(
name|bitmap_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|+
operator|(
name|uintptr_t
operator|)
name|bin_info
operator|->
name|bitmap_offset
operator|)
decl_stmt|;
comment|/* Initialize run internals. */
name|VALGRIND_MAKE_MEM_UNDEFINED
argument_list|(
name|run
argument_list|,
name|bin_info
operator|->
name|reg0_offset
operator|-
name|bin_info
operator|->
name|redzone_size
argument_list|)
expr_stmt|;
name|run
operator|->
name|bin
operator|=
name|bin
expr_stmt|;
name|run
operator|->
name|nextind
operator|=
literal|0
expr_stmt|;
name|run
operator|->
name|nfree
operator|=
name|bin_info
operator|->
name|nregs
expr_stmt|;
name|bitmap_init
argument_list|(
name|bitmap
argument_list|,
operator|&
name|bin_info
operator|->
name|bitmap_info
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/********************************/
name|malloc_mutex_lock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|config_stats
condition|)
block|{
name|bin
operator|->
name|stats
operator|.
name|nruns
operator|++
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|curruns
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|run
operator|)
return|;
block|}
comment|/* 	 * arena_run_alloc() failed, but another thread may have made 	 * sufficient memory available while this one dropped bin->lock above, 	 * so search one more time. 	 */
name|run
operator|=
name|arena_bin_nonfull_run_tryget
argument_list|(
name|bin
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
operator|!=
name|NULL
condition|)
return|return
operator|(
name|run
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Re-fill bin->runcur, then call arena_run_reg_alloc(). */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|arena_bin_malloc_hard
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|binind
decl_stmt|;
name|arena_bin_info_t
modifier|*
name|bin_info
decl_stmt|;
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|binind
operator|=
name|arena_bin_index
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|)
expr_stmt|;
name|bin_info
operator|=
operator|&
name|arena_bin_info
index|[
name|binind
index|]
expr_stmt|;
name|bin
operator|->
name|runcur
operator|=
name|NULL
expr_stmt|;
name|run
operator|=
name|arena_bin_nonfull_run_get
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|)
expr_stmt|;
if|if
condition|(
name|bin
operator|->
name|runcur
operator|!=
name|NULL
operator|&&
name|bin
operator|->
name|runcur
operator|->
name|nfree
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Another thread updated runcur while this one ran without the 		 * bin lock in arena_bin_nonfull_run_get(). 		 */
name|assert
argument_list|(
name|bin
operator|->
name|runcur
operator|->
name|nfree
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|arena_run_reg_alloc
argument_list|(
name|bin
operator|->
name|runcur
argument_list|,
name|bin_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
operator|!=
name|NULL
condition|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
comment|/* 			 * arena_run_alloc() may have allocated run, or it may 			 * have pulled run from the bin's run tree.  Therefore 			 * it is unsafe to make any assumptions about how run 			 * has previously been used, and arena_bin_lower_run() 			 * must be called, as if a region were just deallocated 			 * from the run. 			 */
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|run
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
operator|->
name|nfree
operator|==
name|bin_info
operator|->
name|nregs
condition|)
name|arena_dalloc_bin_run
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|run
argument_list|,
name|bin
argument_list|)
expr_stmt|;
else|else
name|arena_bin_lower_run
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|run
argument_list|,
name|bin
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
if|if
condition|(
name|run
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bin
operator|->
name|runcur
operator|=
name|run
expr_stmt|;
name|assert
argument_list|(
name|bin
operator|->
name|runcur
operator|->
name|nfree
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|arena_run_reg_alloc
argument_list|(
name|bin
operator|->
name|runcur
argument_list|,
name|bin_info
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|arena_prof_accum
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|uint64_t
name|accumbytes
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_prof
operator|&&
name|prof_interval
operator|!=
literal|0
condition|)
block|{
name|arena
operator|->
name|prof_accumbytes
operator|+=
name|accumbytes
expr_stmt|;
if|if
condition|(
name|arena
operator|->
name|prof_accumbytes
operator|>=
name|prof_interval
condition|)
block|{
name|prof_idump
argument_list|()
expr_stmt|;
name|arena
operator|->
name|prof_accumbytes
operator|-=
name|prof_interval
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|arena_tcache_fill_small
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|tcache_bin_t
modifier|*
name|tbin
parameter_list|,
name|size_t
name|binind
parameter_list|,
name|uint64_t
name|prof_accumbytes
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|nfill
decl_stmt|;
name|arena_bin_t
modifier|*
name|bin
decl_stmt|;
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|assert
argument_list|(
name|tbin
operator|->
name|ncached
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_prof
condition|)
block|{
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arena_prof_accum
argument_list|(
name|arena
argument_list|,
name|prof_accumbytes
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|bin
operator|=
operator|&
name|arena
operator|->
name|bins
index|[
name|binind
index|]
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|nfill
operator|=
operator|(
name|tcache_bin_info
index|[
name|binind
index|]
operator|.
name|ncached_max
operator|>>
name|tbin
operator|->
name|lg_fill_div
operator|)
init|;
name|i
operator|<
name|nfill
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|run
operator|=
name|bin
operator|->
name|runcur
operator|)
operator|!=
name|NULL
operator|&&
name|run
operator|->
name|nfree
operator|>
literal|0
condition|)
name|ptr
operator|=
name|arena_run_reg_alloc
argument_list|(
name|run
argument_list|,
operator|&
name|arena_bin_info
index|[
name|binind
index|]
argument_list|)
expr_stmt|;
else|else
name|ptr
operator|=
name|arena_bin_malloc_hard
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|config_fill
operator|&&
name|opt_junk
condition|)
block|{
name|arena_alloc_junk_small
argument_list|(
name|ptr
argument_list|,
operator|&
name|arena_bin_info
index|[
name|binind
index|]
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
comment|/* Insert such that low regions get used first. */
name|tbin
operator|->
name|avail
index|[
name|nfill
operator|-
literal|1
operator|-
name|i
index|]
operator|=
name|ptr
expr_stmt|;
block|}
if|if
condition|(
name|config_stats
condition|)
block|{
name|bin
operator|->
name|stats
operator|.
name|allocated
operator|+=
name|i
operator|*
name|arena_bin_info
index|[
name|binind
index|]
operator|.
name|reg_size
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|nmalloc
operator|+=
name|i
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|nrequests
operator|+=
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|nfills
operator|++
expr_stmt|;
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
operator|=
literal|0
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
name|tbin
operator|->
name|ncached
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_alloc_junk_small
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|arena_bin_info_t
modifier|*
name|bin_info
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
if|if
condition|(
name|zero
condition|)
block|{
name|size_t
name|redzone_size
init|=
name|bin_info
operator|->
name|redzone_size
decl_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
name|redzone_size
operator|)
argument_list|,
literal|0xa5
argument_list|,
name|redzone_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|+
name|bin_info
operator|->
name|reg_size
operator|)
argument_list|,
literal|0xa5
argument_list|,
name|redzone_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
name|bin_info
operator|->
name|redzone_size
operator|)
argument_list|,
literal|0xa5
argument_list|,
name|bin_info
operator|->
name|reg_interval
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|arena_dalloc_junk_small
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|arena_bin_info_t
modifier|*
name|bin_info
parameter_list|)
block|{
name|size_t
name|size
init|=
name|bin_info
operator|->
name|reg_size
decl_stmt|;
name|size_t
name|redzone_size
init|=
name|bin_info
operator|->
name|redzone_size
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|bool
name|error
init|=
name|false
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|redzone_size
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|byte
decl_stmt|;
if|if
condition|(
operator|(
name|byte
operator|=
operator|*
operator|(
name|uint8_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
name|i
operator|)
operator|)
operator|!=
literal|0xa5
condition|)
block|{
name|error
operator|=
name|true
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"<jemalloc>: Corrupt redzone "
literal|"%zu byte%s before %p (size %zu), byte=%#x\n"
argument_list|,
name|i
argument_list|,
operator|(
name|i
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|redzone_size
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|byte
decl_stmt|;
if|if
condition|(
operator|(
name|byte
operator|=
operator|*
operator|(
name|uint8_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|+
name|size
operator|+
name|i
operator|)
operator|)
operator|!=
literal|0xa5
condition|)
block|{
name|error
operator|=
name|true
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"<jemalloc>: Corrupt redzone "
literal|"%zu byte%s after end of %p (size %zu), byte=%#x\n"
argument_list|,
name|i
argument_list|,
operator|(
name|i
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|opt_abort
operator|&&
name|error
condition|)
name|abort
argument_list|()
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
name|redzone_size
operator|)
argument_list|,
literal|0x5a
argument_list|,
name|bin_info
operator|->
name|reg_interval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|arena_malloc_small
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|arena_bin_t
modifier|*
name|bin
decl_stmt|;
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|size_t
name|binind
decl_stmt|;
name|binind
operator|=
name|SMALL_SIZE2BIN
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|binind
operator|<
name|NBINS
argument_list|)
expr_stmt|;
name|bin
operator|=
operator|&
name|arena
operator|->
name|bins
index|[
name|binind
index|]
expr_stmt|;
name|size
operator|=
name|arena_bin_info
index|[
name|binind
index|]
operator|.
name|reg_size
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|run
operator|=
name|bin
operator|->
name|runcur
operator|)
operator|!=
name|NULL
operator|&&
name|run
operator|->
name|nfree
operator|>
literal|0
condition|)
name|ret
operator|=
name|arena_run_reg_alloc
argument_list|(
name|run
argument_list|,
operator|&
name|arena_bin_info
index|[
name|binind
index|]
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|arena_bin_malloc_hard
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|config_stats
condition|)
block|{
name|bin
operator|->
name|stats
operator|.
name|allocated
operator|+=
name|size
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|nmalloc
operator|++
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|nrequests
operator|++
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_prof
operator|&&
name|isthreaded
operator|==
name|false
condition|)
block|{
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arena_prof_accum
argument_list|(
name|arena
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zero
operator|==
name|false
condition|)
block|{
if|if
condition|(
name|config_fill
condition|)
block|{
if|if
condition|(
name|opt_junk
condition|)
block|{
name|arena_alloc_junk_small
argument_list|(
name|ret
argument_list|,
operator|&
name|arena_bin_info
index|[
name|binind
index|]
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt_zero
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|config_fill
operator|&&
name|opt_junk
condition|)
block|{
name|arena_alloc_junk_small
argument_list|(
name|ret
argument_list|,
operator|&
name|arena_bin_info
index|[
name|binind
index|]
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|VALGRIND_MAKE_MEM_UNDEFINED
argument_list|(
name|ret
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|arena_malloc_large
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
comment|/* Large allocation. */
name|size
operator|=
name|PAGE_CEILING
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
name|arena_run_alloc
argument_list|(
name|arena
argument_list|,
name|size
argument_list|,
name|true
argument_list|,
name|BININD_INVALID
argument_list|,
name|zero
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|config_stats
condition|)
block|{
name|arena
operator|->
name|stats
operator|.
name|nmalloc_large
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|nrequests_large
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|allocated_large
operator|+=
name|size
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
operator|(
name|size
operator|>>
name|LG_PAGE
operator|)
operator|-
literal|1
index|]
operator|.
name|nmalloc
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
operator|(
name|size
operator|>>
name|LG_PAGE
operator|)
operator|-
literal|1
index|]
operator|.
name|nrequests
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
operator|(
name|size
operator|>>
name|LG_PAGE
operator|)
operator|-
literal|1
index|]
operator|.
name|curruns
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|config_prof
condition|)
name|arena_prof_accum
argument_list|(
name|arena
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|zero
operator|==
name|false
condition|)
block|{
if|if
condition|(
name|config_fill
condition|)
block|{
if|if
condition|(
name|opt_junk
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0xa5
argument_list|,
name|size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opt_zero
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Only handles large allocations that require more than page alignment. */
end_comment

begin_function
name|void
modifier|*
name|arena_palloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|alloc_size
decl_stmt|,
name|leadsize
decl_stmt|,
name|trailsize
decl_stmt|;
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|assert
argument_list|(
operator|(
name|size
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|alignment
operator|=
name|PAGE_CEILING
argument_list|(
name|alignment
argument_list|)
expr_stmt|;
name|alloc_size
operator|=
name|size
operator|+
name|alignment
operator|-
name|PAGE
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|run
operator|=
name|arena_run_alloc
argument_list|(
name|arena
argument_list|,
name|alloc_size
argument_list|,
name|true
argument_list|,
name|BININD_INVALID
argument_list|,
name|zero
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
operator|==
name|NULL
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|run
argument_list|)
expr_stmt|;
name|leadsize
operator|=
name|ALIGNMENT_CEILING
argument_list|(
operator|(
name|uintptr_t
operator|)
name|run
argument_list|,
name|alignment
argument_list|)
operator|-
operator|(
name|uintptr_t
operator|)
name|run
expr_stmt|;
name|assert
argument_list|(
name|alloc_size
operator|>=
name|leadsize
operator|+
name|size
argument_list|)
expr_stmt|;
name|trailsize
operator|=
name|alloc_size
operator|-
name|leadsize
operator|-
name|size
expr_stmt|;
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|+
name|leadsize
operator|)
expr_stmt|;
if|if
condition|(
name|leadsize
operator|!=
literal|0
condition|)
block|{
name|arena_run_trim_head
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|run
argument_list|,
name|alloc_size
argument_list|,
name|alloc_size
operator|-
name|leadsize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trailsize
operator|!=
literal|0
condition|)
block|{
name|arena_run_trim_tail
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|ret
argument_list|,
name|size
operator|+
name|trailsize
argument_list|,
name|size
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config_stats
condition|)
block|{
name|arena
operator|->
name|stats
operator|.
name|nmalloc_large
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|nrequests_large
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|allocated_large
operator|+=
name|size
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
operator|(
name|size
operator|>>
name|LG_PAGE
operator|)
operator|-
literal|1
index|]
operator|.
name|nmalloc
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
operator|(
name|size
operator|>>
name|LG_PAGE
operator|)
operator|-
literal|1
index|]
operator|.
name|nrequests
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
operator|(
name|size
operator|>>
name|LG_PAGE
operator|)
operator|-
literal|1
index|]
operator|.
name|curruns
operator|++
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_fill
operator|&&
name|zero
operator|==
name|false
condition|)
block|{
if|if
condition|(
name|opt_junk
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0xa5
argument_list|,
name|size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opt_zero
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|arena_prof_promoted
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|size_t
name|pageind
decl_stmt|,
name|binind
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
operator|!=
name|ptr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|isalloc
argument_list|(
name|ptr
argument_list|,
name|false
argument_list|)
operator|==
name|PAGE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|isalloc
argument_list|(
name|ptr
argument_list|,
name|true
argument_list|)
operator|==
name|PAGE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|<=
name|SMALL_MAXCLASS
argument_list|)
expr_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|pageind
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|LG_PAGE
expr_stmt|;
name|binind
operator|=
name|SMALL_SIZE2BIN
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|binind
operator|<
name|NBINS
argument_list|)
expr_stmt|;
name|arena_mapbits_large_binind_set
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|,
name|binind
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|isalloc
argument_list|(
name|ptr
argument_list|,
name|false
argument_list|)
operator|==
name|PAGE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|isalloc
argument_list|(
name|ptr
argument_list|,
name|true
argument_list|)
operator|==
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_dissociate_bin_run
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
block|{
comment|/* Dissociate run from bin. */
if|if
condition|(
name|run
operator|==
name|bin
operator|->
name|runcur
condition|)
name|bin
operator|->
name|runcur
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|size_t
name|binind
init|=
name|arena_bin_index
argument_list|(
name|chunk
operator|->
name|arena
argument_list|,
name|bin
argument_list|)
decl_stmt|;
name|arena_bin_info_t
modifier|*
name|bin_info
init|=
operator|&
name|arena_bin_info
index|[
name|binind
index|]
decl_stmt|;
if|if
condition|(
name|bin_info
operator|->
name|nregs
operator|!=
literal|1
condition|)
block|{
comment|/* 			 * This block's conditional is necessary because if the 			 * run only contains one region, then it never gets 			 * inserted into the non-full runs tree. 			 */
name|arena_bin_runs_remove
argument_list|(
name|bin
argument_list|,
name|run
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arena_dalloc_bin_run
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
block|{
name|size_t
name|binind
decl_stmt|;
name|arena_bin_info_t
modifier|*
name|bin_info
decl_stmt|;
name|size_t
name|npages
decl_stmt|,
name|run_ind
decl_stmt|,
name|past
decl_stmt|;
name|assert
argument_list|(
name|run
operator|!=
name|bin
operator|->
name|runcur
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_run_tree_search
argument_list|(
operator|&
name|bin
operator|->
name|runs
argument_list|,
name|arena_mapp_get
argument_list|(
name|chunk
argument_list|,
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|LG_PAGE
argument_list|)
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|binind
operator|=
name|arena_bin_index
argument_list|(
name|chunk
operator|->
name|arena
argument_list|,
name|run
operator|->
name|bin
argument_list|)
expr_stmt|;
name|bin_info
operator|=
operator|&
name|arena_bin_info
index|[
name|binind
index|]
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/******************************/
name|npages
operator|=
name|bin_info
operator|->
name|run_size
operator|>>
name|LG_PAGE
expr_stmt|;
name|run_ind
operator|=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|LG_PAGE
argument_list|)
expr_stmt|;
name|past
operator|=
call|(
name|size_t
call|)
argument_list|(
name|PAGE_CEILING
argument_list|(
operator|(
name|uintptr_t
operator|)
name|run
operator|+
operator|(
name|uintptr_t
operator|)
name|bin_info
operator|->
name|reg0_offset
operator|+
call|(
name|uintptr_t
call|)
argument_list|(
name|run
operator|->
name|nextind
operator|*
name|bin_info
operator|->
name|reg_interval
operator|-
name|bin_info
operator|->
name|redzone_size
argument_list|)
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
argument_list|)
operator|>>
name|LG_PAGE
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * If the run was originally clean, and some pages were never touched, 	 * trim the clean pages before deallocating the dirty portion of the 	 * run. 	 */
if|if
condition|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
operator|==
literal|0
operator|&&
name|past
operator|-
name|run_ind
operator|<
name|npages
condition|)
block|{
comment|/* 		 * Trim clean pages.  Convert to large run beforehand.  Set the 		 * last map element first, in case this is a one-page run. 		 */
name|arena_mapbits_large_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|npages
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|npages
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|arena_mapbits_large_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|,
name|bin_info
operator|->
name|run_size
argument_list|,
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
argument_list|)
expr_stmt|;
name|arena_run_trim_tail
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|run
argument_list|,
operator|(
name|npages
operator|<<
name|LG_PAGE
operator|)
argument_list|,
operator|(
operator|(
name|past
operator|-
name|run_ind
operator|)
operator|<<
name|LG_PAGE
operator|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* npages = past - run_ind; */
block|}
name|arena_run_dalloc
argument_list|(
name|arena
argument_list|,
name|run
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/****************************/
name|malloc_mutex_lock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
name|bin
operator|->
name|stats
operator|.
name|curruns
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_bin_lower_run
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
block|{
comment|/* 	 * Make sure that if bin->runcur is non-NULL, it refers to the lowest 	 * non-full run.  It is okay to NULL runcur out rather than proactively 	 * keeping it pointing at the lowest non-full run. 	 */
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|run
operator|<
operator|(
name|uintptr_t
operator|)
name|bin
operator|->
name|runcur
condition|)
block|{
comment|/* Switch runcur. */
if|if
condition|(
name|bin
operator|->
name|runcur
operator|->
name|nfree
operator|>
literal|0
condition|)
name|arena_bin_runs_insert
argument_list|(
name|bin
argument_list|,
name|bin
operator|->
name|runcur
argument_list|)
expr_stmt|;
name|bin
operator|->
name|runcur
operator|=
name|run
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
name|bin
operator|->
name|stats
operator|.
name|reruns
operator|++
expr_stmt|;
block|}
else|else
name|arena_bin_runs_insert
argument_list|(
name|bin
argument_list|,
name|run
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_dalloc_bin_locked
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|arena_chunk_map_t
modifier|*
name|mapelm
parameter_list|)
block|{
name|size_t
name|pageind
decl_stmt|;
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|arena_bin_t
modifier|*
name|bin
decl_stmt|;
name|arena_bin_info_t
modifier|*
name|bin_info
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|binind
decl_stmt|;
name|pageind
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|LG_PAGE
expr_stmt|;
name|run
operator|=
operator|(
name|arena_run_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
call|(
name|uintptr_t
call|)
argument_list|(
operator|(
name|pageind
operator|-
name|arena_mapbits_small_runind_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|)
operator|<<
name|LG_PAGE
argument_list|)
operator|)
expr_stmt|;
name|bin
operator|=
name|run
operator|->
name|bin
expr_stmt|;
name|binind
operator|=
name|arena_ptr_small_binind_get
argument_list|(
name|ptr
argument_list|,
name|mapelm
operator|->
name|bits
argument_list|)
expr_stmt|;
name|bin_info
operator|=
operator|&
name|arena_bin_info
index|[
name|binind
index|]
expr_stmt|;
if|if
condition|(
name|config_fill
operator|||
name|config_stats
condition|)
name|size
operator|=
name|bin_info
operator|->
name|reg_size
expr_stmt|;
if|if
condition|(
name|config_fill
operator|&&
name|opt_junk
condition|)
name|arena_dalloc_junk_small
argument_list|(
name|ptr
argument_list|,
name|bin_info
argument_list|)
expr_stmt|;
name|arena_run_reg_dalloc
argument_list|(
name|run
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
operator|->
name|nfree
operator|==
name|bin_info
operator|->
name|nregs
condition|)
block|{
name|arena_dissociate_bin_run
argument_list|(
name|chunk
argument_list|,
name|run
argument_list|,
name|bin
argument_list|)
expr_stmt|;
name|arena_dalloc_bin_run
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|run
argument_list|,
name|bin
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|run
operator|->
name|nfree
operator|==
literal|1
operator|&&
name|run
operator|!=
name|bin
operator|->
name|runcur
condition|)
name|arena_bin_lower_run
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|run
argument_list|,
name|bin
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|bin
operator|->
name|stats
operator|.
name|allocated
operator|-=
name|size
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|ndalloc
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|arena_dalloc_bin
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|pageind
parameter_list|,
name|arena_chunk_map_t
modifier|*
name|mapelm
parameter_list|)
block|{
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|arena_bin_t
modifier|*
name|bin
decl_stmt|;
name|run
operator|=
operator|(
name|arena_run_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
call|(
name|uintptr_t
call|)
argument_list|(
operator|(
name|pageind
operator|-
name|arena_mapbits_small_runind_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|)
operator|<<
name|LG_PAGE
argument_list|)
operator|)
expr_stmt|;
name|bin
operator|=
name|run
operator|->
name|bin
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arena_dalloc_bin_locked
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|ptr
argument_list|,
name|mapelm
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_dalloc_small
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|pageind
parameter_list|)
block|{
name|arena_chunk_map_t
modifier|*
name|mapelm
decl_stmt|;
if|if
condition|(
name|config_debug
condition|)
block|{
comment|/* arena_ptr_small_binind_get() does extra sanity checking. */
name|assert
argument_list|(
name|arena_ptr_small_binind_get
argument_list|(
name|ptr
argument_list|,
name|arena_mapbits_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
argument_list|)
operator|!=
name|BININD_INVALID
argument_list|)
expr_stmt|;
block|}
name|mapelm
operator|=
name|arena_mapp_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
expr_stmt|;
name|arena_dalloc_bin
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|ptr
argument_list|,
name|pageind
argument_list|,
name|mapelm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_stats_merge
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
modifier|*
name|nactive
parameter_list|,
name|size_t
modifier|*
name|ndirty
parameter_list|,
name|arena_stats_t
modifier|*
name|astats
parameter_list|,
name|malloc_bin_stats_t
modifier|*
name|bstats
parameter_list|,
name|malloc_large_stats_t
modifier|*
name|lstats
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|nactive
operator|+=
name|arena
operator|->
name|nactive
expr_stmt|;
operator|*
name|ndirty
operator|+=
name|arena
operator|->
name|ndirty
expr_stmt|;
name|astats
operator|->
name|mapped
operator|+=
name|arena
operator|->
name|stats
operator|.
name|mapped
expr_stmt|;
name|astats
operator|->
name|npurge
operator|+=
name|arena
operator|->
name|stats
operator|.
name|npurge
expr_stmt|;
name|astats
operator|->
name|nmadvise
operator|+=
name|arena
operator|->
name|stats
operator|.
name|nmadvise
expr_stmt|;
name|astats
operator|->
name|purged
operator|+=
name|arena
operator|->
name|stats
operator|.
name|purged
expr_stmt|;
name|astats
operator|->
name|allocated_large
operator|+=
name|arena
operator|->
name|stats
operator|.
name|allocated_large
expr_stmt|;
name|astats
operator|->
name|nmalloc_large
operator|+=
name|arena
operator|->
name|stats
operator|.
name|nmalloc_large
expr_stmt|;
name|astats
operator|->
name|ndalloc_large
operator|+=
name|arena
operator|->
name|stats
operator|.
name|ndalloc_large
expr_stmt|;
name|astats
operator|->
name|nrequests_large
operator|+=
name|arena
operator|->
name|stats
operator|.
name|nrequests_large
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlclasses
condition|;
name|i
operator|++
control|)
block|{
name|lstats
index|[
name|i
index|]
operator|.
name|nmalloc
operator|+=
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|i
index|]
operator|.
name|nmalloc
expr_stmt|;
name|lstats
index|[
name|i
index|]
operator|.
name|ndalloc
operator|+=
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|i
index|]
operator|.
name|ndalloc
expr_stmt|;
name|lstats
index|[
name|i
index|]
operator|.
name|nrequests
operator|+=
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|i
index|]
operator|.
name|nrequests
expr_stmt|;
name|lstats
index|[
name|i
index|]
operator|.
name|curruns
operator|+=
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|i
index|]
operator|.
name|curruns
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
name|arena_bin_t
modifier|*
name|bin
init|=
operator|&
name|arena
operator|->
name|bins
index|[
name|i
index|]
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
name|bstats
index|[
name|i
index|]
operator|.
name|allocated
operator|+=
name|bin
operator|->
name|stats
operator|.
name|allocated
expr_stmt|;
name|bstats
index|[
name|i
index|]
operator|.
name|nmalloc
operator|+=
name|bin
operator|->
name|stats
operator|.
name|nmalloc
expr_stmt|;
name|bstats
index|[
name|i
index|]
operator|.
name|ndalloc
operator|+=
name|bin
operator|->
name|stats
operator|.
name|ndalloc
expr_stmt|;
name|bstats
index|[
name|i
index|]
operator|.
name|nrequests
operator|+=
name|bin
operator|->
name|stats
operator|.
name|nrequests
expr_stmt|;
if|if
condition|(
name|config_tcache
condition|)
block|{
name|bstats
index|[
name|i
index|]
operator|.
name|nfills
operator|+=
name|bin
operator|->
name|stats
operator|.
name|nfills
expr_stmt|;
name|bstats
index|[
name|i
index|]
operator|.
name|nflushes
operator|+=
name|bin
operator|->
name|stats
operator|.
name|nflushes
expr_stmt|;
block|}
name|bstats
index|[
name|i
index|]
operator|.
name|nruns
operator|+=
name|bin
operator|->
name|stats
operator|.
name|nruns
expr_stmt|;
name|bstats
index|[
name|i
index|]
operator|.
name|reruns
operator|+=
name|bin
operator|->
name|stats
operator|.
name|reruns
expr_stmt|;
name|bstats
index|[
name|i
index|]
operator|.
name|curruns
operator|+=
name|bin
operator|->
name|stats
operator|.
name|curruns
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|arena_dalloc_large_locked
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
if|if
condition|(
name|config_fill
operator|||
name|config_stats
condition|)
block|{
name|size_t
name|pageind
init|=
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|LG_PAGE
decl_stmt|;
name|size_t
name|size
init|=
name|arena_mapbits_large_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
decl_stmt|;
if|if
condition|(
name|config_fill
operator|&&
name|config_stats
operator|&&
name|opt_junk
condition|)
name|memset
argument_list|(
name|ptr
argument_list|,
literal|0x5a
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|arena
operator|->
name|stats
operator|.
name|ndalloc_large
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|allocated_large
operator|-=
name|size
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
operator|(
name|size
operator|>>
name|LG_PAGE
operator|)
operator|-
literal|1
index|]
operator|.
name|ndalloc
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
operator|(
name|size
operator|>>
name|LG_PAGE
operator|)
operator|-
literal|1
index|]
operator|.
name|curruns
operator|--
expr_stmt|;
block|}
block|}
name|arena_run_dalloc
argument_list|(
name|arena
argument_list|,
operator|(
name|arena_run_t
operator|*
operator|)
name|ptr
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_dalloc_large
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arena_dalloc_large_locked
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_ralloc_large_shrink
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|assert
argument_list|(
name|size
operator|<
name|oldsize
argument_list|)
expr_stmt|;
comment|/* 	 * Shrink the run, and make trailing pages available for other 	 * allocations. 	 */
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arena_run_trim_tail
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
operator|(
name|arena_run_t
operator|*
operator|)
name|ptr
argument_list|,
name|oldsize
argument_list|,
name|size
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|arena
operator|->
name|stats
operator|.
name|ndalloc_large
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|allocated_large
operator|-=
name|oldsize
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
operator|(
name|oldsize
operator|>>
name|LG_PAGE
operator|)
operator|-
literal|1
index|]
operator|.
name|ndalloc
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
operator|(
name|oldsize
operator|>>
name|LG_PAGE
operator|)
operator|-
literal|1
index|]
operator|.
name|curruns
operator|--
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|nmalloc_large
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|nrequests_large
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|allocated_large
operator|+=
name|size
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
operator|(
name|size
operator|>>
name|LG_PAGE
operator|)
operator|-
literal|1
index|]
operator|.
name|nmalloc
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
operator|(
name|size
operator|>>
name|LG_PAGE
operator|)
operator|-
literal|1
index|]
operator|.
name|nrequests
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
operator|(
name|size
operator|>>
name|LG_PAGE
operator|)
operator|-
literal|1
index|]
operator|.
name|curruns
operator|++
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|arena_ralloc_large_grow
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|extra
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|size_t
name|pageind
init|=
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|LG_PAGE
decl_stmt|;
name|size_t
name|npages
init|=
name|oldsize
operator|>>
name|LG_PAGE
decl_stmt|;
name|size_t
name|followsize
decl_stmt|;
name|assert
argument_list|(
name|oldsize
operator|==
name|arena_mapbits_large_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Try to extend the run. */
name|assert
argument_list|(
name|size
operator|+
name|extra
operator|>
name|oldsize
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pageind
operator|+
name|npages
operator|<
name|chunk_npages
operator|&&
name|arena_mapbits_allocated_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|npages
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|followsize
operator|=
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|npages
argument_list|)
operator|)
operator|>=
name|size
operator|-
name|oldsize
condition|)
block|{
comment|/* 		 * The next run is available and sufficiently large.  Split the 		 * following run, then merge the first part with the existing 		 * allocation. 		 */
name|size_t
name|flag_dirty
decl_stmt|;
name|size_t
name|splitsize
init|=
operator|(
name|oldsize
operator|+
name|followsize
operator|<=
name|size
operator|+
name|extra
operator|)
condition|?
name|followsize
else|:
name|size
operator|+
name|extra
operator|-
name|oldsize
decl_stmt|;
name|arena_run_split
argument_list|(
name|arena
argument_list|,
operator|(
name|arena_run_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
operator|(
operator|(
name|pageind
operator|+
name|npages
operator|)
operator|<<
name|LG_PAGE
operator|)
operator|)
argument_list|,
name|splitsize
argument_list|,
name|true
argument_list|,
name|BININD_INVALID
argument_list|,
name|zero
argument_list|)
expr_stmt|;
name|size
operator|=
name|oldsize
operator|+
name|splitsize
expr_stmt|;
name|npages
operator|=
name|size
operator|>>
name|LG_PAGE
expr_stmt|;
comment|/* 		 * Mark the extended run as dirty if either portion of the run 		 * was dirty before allocation.  This is rather pedantic, 		 * because there's not actually any sequence of events that 		 * could cause the resulting run to be passed to 		 * arena_run_dalloc() with the dirty argument set to false 		 * (which is when dirty flag consistency would really matter). 		 */
name|flag_dirty
operator|=
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator||
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|npages
operator|-
literal|1
argument_list|)
expr_stmt|;
name|arena_mapbits_large_set
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|,
name|size
argument_list|,
name|flag_dirty
argument_list|)
expr_stmt|;
name|arena_mapbits_large_set
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|npages
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|flag_dirty
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|arena
operator|->
name|stats
operator|.
name|ndalloc_large
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|allocated_large
operator|-=
name|oldsize
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
operator|(
name|oldsize
operator|>>
name|LG_PAGE
operator|)
operator|-
literal|1
index|]
operator|.
name|ndalloc
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
operator|(
name|oldsize
operator|>>
name|LG_PAGE
operator|)
operator|-
literal|1
index|]
operator|.
name|curruns
operator|--
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|nmalloc_large
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|nrequests_large
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|allocated_large
operator|+=
name|size
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
operator|(
name|size
operator|>>
name|LG_PAGE
operator|)
operator|-
literal|1
index|]
operator|.
name|nmalloc
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
operator|(
name|size
operator|>>
name|LG_PAGE
operator|)
operator|-
literal|1
index|]
operator|.
name|nrequests
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
operator|(
name|size
operator|>>
name|LG_PAGE
operator|)
operator|-
literal|1
index|]
operator|.
name|curruns
operator|++
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try to resize a large allocation, in order to avoid copying.  This will  * always fail if growing an object, and the following run is already in use.  */
end_comment

begin_function
specifier|static
name|bool
name|arena_ralloc_large
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|extra
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|size_t
name|psize
decl_stmt|;
name|psize
operator|=
name|PAGE_CEILING
argument_list|(
name|size
operator|+
name|extra
argument_list|)
expr_stmt|;
if|if
condition|(
name|psize
operator|==
name|oldsize
condition|)
block|{
comment|/* Same size class. */
if|if
condition|(
name|config_fill
operator|&&
name|opt_junk
operator|&&
name|size
operator|<
name|oldsize
condition|)
block|{
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|+
name|size
operator|)
argument_list|,
literal|0x5a
argument_list|,
name|oldsize
operator|-
name|size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
else|else
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|arena_t
modifier|*
name|arena
decl_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|arena
operator|=
name|chunk
operator|->
name|arena
expr_stmt|;
if|if
condition|(
name|psize
operator|<
name|oldsize
condition|)
block|{
comment|/* Fill before shrinking in order avoid a race. */
if|if
condition|(
name|config_fill
operator|&&
name|opt_junk
condition|)
block|{
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|+
name|size
operator|)
argument_list|,
literal|0x5a
argument_list|,
name|oldsize
operator|-
name|size
argument_list|)
expr_stmt|;
block|}
name|arena_ralloc_large_shrink
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|ptr
argument_list|,
name|oldsize
argument_list|,
name|psize
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
else|else
block|{
name|bool
name|ret
init|=
name|arena_ralloc_large_grow
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|ptr
argument_list|,
name|oldsize
argument_list|,
name|PAGE_CEILING
argument_list|(
name|size
argument_list|)
argument_list|,
name|psize
operator|-
name|PAGE_CEILING
argument_list|(
name|size
argument_list|)
argument_list|,
name|zero
argument_list|)
decl_stmt|;
if|if
condition|(
name|config_fill
operator|&&
name|ret
operator|==
name|false
operator|&&
name|zero
operator|==
name|false
operator|&&
name|opt_zero
condition|)
block|{
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|+
name|oldsize
operator|)
argument_list|,
literal|0
argument_list|,
name|size
operator|-
name|oldsize
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
name|void
modifier|*
name|arena_ralloc_no_move
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|extra
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
comment|/* 	 * Avoid moving the allocation if the size class can be left the same. 	 */
if|if
condition|(
name|oldsize
operator|<=
name|arena_maxclass
condition|)
block|{
if|if
condition|(
name|oldsize
operator|<=
name|SMALL_MAXCLASS
condition|)
block|{
name|assert
argument_list|(
name|arena_bin_info
index|[
name|SMALL_SIZE2BIN
argument_list|(
name|oldsize
argument_list|)
index|]
operator|.
name|reg_size
operator|==
name|oldsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|+
name|extra
operator|<=
name|SMALL_MAXCLASS
operator|&&
name|SMALL_SIZE2BIN
argument_list|(
name|size
operator|+
name|extra
argument_list|)
operator|==
name|SMALL_SIZE2BIN
argument_list|(
name|oldsize
argument_list|)
operator|)
operator|||
operator|(
name|size
operator|<=
name|oldsize
operator|&&
name|size
operator|+
name|extra
operator|>=
name|oldsize
operator|)
condition|)
block|{
if|if
condition|(
name|config_fill
operator|&&
name|opt_junk
operator|&&
name|size
operator|<
name|oldsize
condition|)
block|{
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|+
name|size
operator|)
argument_list|,
literal|0x5a
argument_list|,
name|oldsize
operator|-
name|size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ptr
operator|)
return|;
block|}
block|}
else|else
block|{
name|assert
argument_list|(
name|size
operator|<=
name|arena_maxclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|+
name|extra
operator|>
name|SMALL_MAXCLASS
condition|)
block|{
if|if
condition|(
name|arena_ralloc_large
argument_list|(
name|ptr
argument_list|,
name|oldsize
argument_list|,
name|size
argument_list|,
name|extra
argument_list|,
name|zero
argument_list|)
operator|==
name|false
condition|)
return|return
operator|(
name|ptr
operator|)
return|;
block|}
block|}
block|}
comment|/* Reallocation would require a move. */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|arena_ralloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|extra
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
name|zero
parameter_list|,
name|bool
name|try_tcache
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|copysize
decl_stmt|;
comment|/* Try to avoid moving the allocation. */
name|ret
operator|=
name|arena_ralloc_no_move
argument_list|(
name|ptr
argument_list|,
name|oldsize
argument_list|,
name|size
argument_list|,
name|extra
argument_list|,
name|zero
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ret
operator|)
return|;
comment|/* 	 * size and oldsize are different enough that we need to move the 	 * object.  In that case, fall back to allocating new space and 	 * copying. 	 */
if|if
condition|(
name|alignment
operator|!=
literal|0
condition|)
block|{
name|size_t
name|usize
init|=
name|sa2u
argument_list|(
name|size
operator|+
name|extra
argument_list|,
name|alignment
argument_list|)
decl_stmt|;
if|if
condition|(
name|usize
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ret
operator|=
name|ipalloc
argument_list|(
name|usize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|arena_malloc
argument_list|(
name|NULL
argument_list|,
name|size
operator|+
name|extra
argument_list|,
name|zero
argument_list|,
name|try_tcache
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|extra
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Try again, this time without extra. */
if|if
condition|(
name|alignment
operator|!=
literal|0
condition|)
block|{
name|size_t
name|usize
init|=
name|sa2u
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
decl_stmt|;
if|if
condition|(
name|usize
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ret
operator|=
name|ipalloc
argument_list|(
name|usize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|arena_malloc
argument_list|(
name|NULL
argument_list|,
name|size
argument_list|,
name|zero
argument_list|,
name|try_tcache
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Junk/zero-filling were already done by ipalloc()/arena_malloc(). */
comment|/* 	 * Copy at most size bytes (not size+extra), since the caller has no 	 * expectation that the extra bytes will be reliably preserved. 	 */
name|copysize
operator|=
operator|(
name|size
operator|<
name|oldsize
operator|)
condition|?
name|size
else|:
name|oldsize
expr_stmt|;
name|VALGRIND_MAKE_MEM_UNDEFINED
argument_list|(
name|ret
argument_list|,
name|copysize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|ptr
argument_list|,
name|copysize
argument_list|)
expr_stmt|;
name|iqalloc
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|arena_new
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|unsigned
name|ind
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|arena_bin_t
modifier|*
name|bin
decl_stmt|;
name|arena
operator|->
name|ind
operator|=
name|ind
expr_stmt|;
name|arena
operator|->
name|nthreads
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|memset
argument_list|(
operator|&
name|arena
operator|->
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|arena_stats_t
argument_list|)
argument_list|)
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
operator|=
operator|(
name|malloc_large_stats_t
operator|*
operator|)
name|base_alloc
argument_list|(
name|nlclasses
operator|*
sizeof|sizeof
argument_list|(
name|malloc_large_stats_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arena
operator|->
name|stats
operator|.
name|lstats
operator|==
name|NULL
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|memset
argument_list|(
name|arena
operator|->
name|stats
operator|.
name|lstats
argument_list|,
literal|0
argument_list|,
name|nlclasses
operator|*
sizeof|sizeof
argument_list|(
name|malloc_large_stats_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_tcache
condition|)
name|ql_new
argument_list|(
operator|&
name|arena
operator|->
name|tcache_ql
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config_prof
condition|)
name|arena
operator|->
name|prof_accumbytes
operator|=
literal|0
expr_stmt|;
comment|/* Initialize chunks. */
name|ql_new
argument_list|(
operator|&
name|arena
operator|->
name|chunks_dirty
argument_list|)
expr_stmt|;
name|arena
operator|->
name|spare
operator|=
name|NULL
expr_stmt|;
name|arena
operator|->
name|nactive
operator|=
literal|0
expr_stmt|;
name|arena
operator|->
name|ndirty
operator|=
literal|0
expr_stmt|;
name|arena
operator|->
name|npurgatory
operator|=
literal|0
expr_stmt|;
name|arena_avail_tree_new
argument_list|(
operator|&
name|arena
operator|->
name|runs_avail_clean
argument_list|)
expr_stmt|;
name|arena_avail_tree_new
argument_list|(
operator|&
name|arena
operator|->
name|runs_avail_dirty
argument_list|)
expr_stmt|;
comment|/* Initialize bins. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
name|bin
operator|=
operator|&
name|arena
operator|->
name|bins
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|bin
operator|->
name|runcur
operator|=
name|NULL
expr_stmt|;
name|arena_run_tree_new
argument_list|(
operator|&
name|bin
operator|->
name|runs
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
name|memset
argument_list|(
operator|&
name|bin
operator|->
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|malloc_bin_stats_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate bin_info->run_size such that it meets the following constraints:  *  *   *) bin_info->run_size>= min_run_size  *   *) bin_info->run_size<= arena_maxclass  *   *) run header overhead<= RUN_MAX_OVRHD (or header overhead relaxed).  *   *) bin_info->nregs<= RUN_MAXREGS  *  * bin_info->nregs, bin_info->bitmap_offset, and bin_info->reg0_offset are also  * calculated here, since these settings are all interdependent.  */
end_comment

begin_function
specifier|static
name|size_t
name|bin_info_run_size_calc
parameter_list|(
name|arena_bin_info_t
modifier|*
name|bin_info
parameter_list|,
name|size_t
name|min_run_size
parameter_list|)
block|{
name|size_t
name|pad_size
decl_stmt|;
name|size_t
name|try_run_size
decl_stmt|,
name|good_run_size
decl_stmt|;
name|uint32_t
name|try_nregs
decl_stmt|,
name|good_nregs
decl_stmt|;
name|uint32_t
name|try_hdr_size
decl_stmt|,
name|good_hdr_size
decl_stmt|;
name|uint32_t
name|try_bitmap_offset
decl_stmt|,
name|good_bitmap_offset
decl_stmt|;
name|uint32_t
name|try_ctx0_offset
decl_stmt|,
name|good_ctx0_offset
decl_stmt|;
name|uint32_t
name|try_redzone0_offset
decl_stmt|,
name|good_redzone0_offset
decl_stmt|;
name|assert
argument_list|(
name|min_run_size
operator|>=
name|PAGE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|min_run_size
operator|<=
name|arena_maxclass
argument_list|)
expr_stmt|;
comment|/* 	 * Determine redzone size based on minimum alignment and minimum 	 * redzone size.  Add padding to the end of the run if it is needed to 	 * align the regions.  The padding allows each redzone to be half the 	 * minimum alignment; without the padding, each redzone would have to 	 * be twice as large in order to maintain alignment. 	 */
if|if
condition|(
name|config_fill
operator|&&
name|opt_redzone
condition|)
block|{
name|size_t
name|align_min
init|=
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
operator|(
name|ffs
argument_list|(
name|bin_info
operator|->
name|reg_size
argument_list|)
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|align_min
operator|<=
name|REDZONE_MINSIZE
condition|)
block|{
name|bin_info
operator|->
name|redzone_size
operator|=
name|REDZONE_MINSIZE
expr_stmt|;
name|pad_size
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bin_info
operator|->
name|redzone_size
operator|=
name|align_min
operator|>>
literal|1
expr_stmt|;
name|pad_size
operator|=
name|bin_info
operator|->
name|redzone_size
expr_stmt|;
block|}
block|}
else|else
block|{
name|bin_info
operator|->
name|redzone_size
operator|=
literal|0
expr_stmt|;
name|pad_size
operator|=
literal|0
expr_stmt|;
block|}
name|bin_info
operator|->
name|reg_interval
operator|=
name|bin_info
operator|->
name|reg_size
operator|+
operator|(
name|bin_info
operator|->
name|redzone_size
operator|<<
literal|1
operator|)
expr_stmt|;
comment|/* 	 * Calculate known-valid settings before entering the run_size 	 * expansion loop, so that the first part of the loop always copies 	 * valid settings. 	 * 	 * The do..while loop iteratively reduces the number of regions until 	 * the run header and the regions no longer overlap.  A closed formula 	 * would be quite messy, since there is an interdependency between the 	 * header's mask length and the number of regions. 	 */
name|try_run_size
operator|=
name|min_run_size
expr_stmt|;
name|try_nregs
operator|=
operator|(
operator|(
name|try_run_size
operator|-
sizeof|sizeof
argument_list|(
name|arena_run_t
argument_list|)
operator|)
operator|/
name|bin_info
operator|->
name|reg_interval
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* Counter-act try_nregs-- in loop. */
if|if
condition|(
name|try_nregs
operator|>
name|RUN_MAXREGS
condition|)
block|{
name|try_nregs
operator|=
name|RUN_MAXREGS
operator|+
literal|1
expr_stmt|;
comment|/* Counter-act try_nregs-- in loop. */
block|}
do|do
block|{
name|try_nregs
operator|--
expr_stmt|;
name|try_hdr_size
operator|=
sizeof|sizeof
argument_list|(
name|arena_run_t
argument_list|)
expr_stmt|;
comment|/* Pad to a long boundary. */
name|try_hdr_size
operator|=
name|LONG_CEILING
argument_list|(
name|try_hdr_size
argument_list|)
expr_stmt|;
name|try_bitmap_offset
operator|=
name|try_hdr_size
expr_stmt|;
comment|/* Add space for bitmap. */
name|try_hdr_size
operator|+=
name|bitmap_size
argument_list|(
name|try_nregs
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
operator|&&
name|prof_promote
operator|==
name|false
condition|)
block|{
comment|/* Pad to a quantum boundary. */
name|try_hdr_size
operator|=
name|QUANTUM_CEILING
argument_list|(
name|try_hdr_size
argument_list|)
expr_stmt|;
name|try_ctx0_offset
operator|=
name|try_hdr_size
expr_stmt|;
comment|/* Add space for one (prof_ctx_t *) per region. */
name|try_hdr_size
operator|+=
name|try_nregs
operator|*
sizeof|sizeof
argument_list|(
name|prof_ctx_t
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
name|try_ctx0_offset
operator|=
literal|0
expr_stmt|;
name|try_redzone0_offset
operator|=
name|try_run_size
operator|-
operator|(
name|try_nregs
operator|*
name|bin_info
operator|->
name|reg_interval
operator|)
operator|-
name|pad_size
expr_stmt|;
block|}
do|while
condition|(
name|try_hdr_size
operator|>
name|try_redzone0_offset
condition|)
do|;
comment|/* run_size expansion loop. */
do|do
block|{
comment|/* 		 * Copy valid settings before trying more aggressive settings. 		 */
name|good_run_size
operator|=
name|try_run_size
expr_stmt|;
name|good_nregs
operator|=
name|try_nregs
expr_stmt|;
name|good_hdr_size
operator|=
name|try_hdr_size
expr_stmt|;
name|good_bitmap_offset
operator|=
name|try_bitmap_offset
expr_stmt|;
name|good_ctx0_offset
operator|=
name|try_ctx0_offset
expr_stmt|;
name|good_redzone0_offset
operator|=
name|try_redzone0_offset
expr_stmt|;
comment|/* Try more aggressive settings. */
name|try_run_size
operator|+=
name|PAGE
expr_stmt|;
name|try_nregs
operator|=
operator|(
operator|(
name|try_run_size
operator|-
sizeof|sizeof
argument_list|(
name|arena_run_t
argument_list|)
operator|-
name|pad_size
operator|)
operator|/
name|bin_info
operator|->
name|reg_interval
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* Counter-act try_nregs-- in loop. */
if|if
condition|(
name|try_nregs
operator|>
name|RUN_MAXREGS
condition|)
block|{
name|try_nregs
operator|=
name|RUN_MAXREGS
operator|+
literal|1
expr_stmt|;
comment|/* Counter-act try_nregs-- in loop. */
block|}
do|do
block|{
name|try_nregs
operator|--
expr_stmt|;
name|try_hdr_size
operator|=
sizeof|sizeof
argument_list|(
name|arena_run_t
argument_list|)
expr_stmt|;
comment|/* Pad to a long boundary. */
name|try_hdr_size
operator|=
name|LONG_CEILING
argument_list|(
name|try_hdr_size
argument_list|)
expr_stmt|;
name|try_bitmap_offset
operator|=
name|try_hdr_size
expr_stmt|;
comment|/* Add space for bitmap. */
name|try_hdr_size
operator|+=
name|bitmap_size
argument_list|(
name|try_nregs
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
operator|&&
name|prof_promote
operator|==
name|false
condition|)
block|{
comment|/* Pad to a quantum boundary. */
name|try_hdr_size
operator|=
name|QUANTUM_CEILING
argument_list|(
name|try_hdr_size
argument_list|)
expr_stmt|;
name|try_ctx0_offset
operator|=
name|try_hdr_size
expr_stmt|;
comment|/* 				 * Add space for one (prof_ctx_t *) per region. 				 */
name|try_hdr_size
operator|+=
name|try_nregs
operator|*
sizeof|sizeof
argument_list|(
name|prof_ctx_t
operator|*
argument_list|)
expr_stmt|;
block|}
name|try_redzone0_offset
operator|=
name|try_run_size
operator|-
operator|(
name|try_nregs
operator|*
name|bin_info
operator|->
name|reg_interval
operator|)
operator|-
name|pad_size
expr_stmt|;
block|}
do|while
condition|(
name|try_hdr_size
operator|>
name|try_redzone0_offset
condition|)
do|;
block|}
do|while
condition|(
name|try_run_size
operator|<=
name|arena_maxclass
operator|&&
name|try_run_size
operator|<=
name|arena_maxclass
operator|&&
name|RUN_MAX_OVRHD
operator|*
operator|(
name|bin_info
operator|->
name|reg_interval
operator|<<
literal|3
operator|)
operator|>
name|RUN_MAX_OVRHD_RELAX
operator|&&
operator|(
name|try_redzone0_offset
operator|<<
name|RUN_BFP
operator|)
operator|>
name|RUN_MAX_OVRHD
operator|*
name|try_run_size
operator|&&
name|try_nregs
operator|<
name|RUN_MAXREGS
condition|)
do|;
name|assert
argument_list|(
name|good_hdr_size
operator|<=
name|good_redzone0_offset
argument_list|)
expr_stmt|;
comment|/* Copy final settings. */
name|bin_info
operator|->
name|run_size
operator|=
name|good_run_size
expr_stmt|;
name|bin_info
operator|->
name|nregs
operator|=
name|good_nregs
expr_stmt|;
name|bin_info
operator|->
name|bitmap_offset
operator|=
name|good_bitmap_offset
expr_stmt|;
name|bin_info
operator|->
name|ctx0_offset
operator|=
name|good_ctx0_offset
expr_stmt|;
name|bin_info
operator|->
name|reg0_offset
operator|=
name|good_redzone0_offset
operator|+
name|bin_info
operator|->
name|redzone_size
expr_stmt|;
name|assert
argument_list|(
name|bin_info
operator|->
name|reg0_offset
operator|-
name|bin_info
operator|->
name|redzone_size
operator|+
operator|(
name|bin_info
operator|->
name|nregs
operator|*
name|bin_info
operator|->
name|reg_interval
operator|)
operator|+
name|pad_size
operator|==
name|bin_info
operator|->
name|run_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|good_run_size
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bin_info_init
parameter_list|(
name|void
parameter_list|)
block|{
name|arena_bin_info_t
modifier|*
name|bin_info
decl_stmt|;
name|size_t
name|prev_run_size
init|=
name|PAGE
decl_stmt|;
define|#
directive|define
name|SIZE_CLASS
parameter_list|(
name|bin
parameter_list|,
name|delta
parameter_list|,
name|size
parameter_list|)
define|\
value|bin_info =&arena_bin_info[bin];				\ 	bin_info->reg_size = size;					\ 	prev_run_size = bin_info_run_size_calc(bin_info, prev_run_size);\ 	bitmap_info_init(&bin_info->bitmap_info, bin_info->nregs);
name|SIZE_CLASSES
undef|#
directive|undef
name|SIZE_CLASS
block|}
end_function

begin_function
name|void
name|arena_boot
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|header_size
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
comment|/* 	 * Compute the header size such that it is large enough to contain the 	 * page map.  The page map is biased to omit entries for the header 	 * itself, so some iteration is necessary to compute the map bias. 	 * 	 * 1) Compute safe header_size and map_bias values that include enough 	 *    space for an unbiased page map. 	 * 2) Refine map_bias based on (1) to omit the header pages in the page 	 *    map.  The resulting map_bias may be one too small. 	 * 3) Refine map_bias based on (2).  The result will be>= the result 	 *    from (2), and will always be correct. 	 */
name|map_bias
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|header_size
operator|=
name|offsetof
argument_list|(
name|arena_chunk_t
argument_list|,
name|map
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|arena_chunk_map_t
argument_list|)
operator|*
operator|(
name|chunk_npages
operator|-
name|map_bias
operator|)
operator|)
expr_stmt|;
name|map_bias
operator|=
operator|(
name|header_size
operator|>>
name|LG_PAGE
operator|)
operator|+
operator|(
operator|(
name|header_size
operator|&
name|PAGE_MASK
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|map_bias
operator|>
literal|0
argument_list|)
expr_stmt|;
name|arena_maxclass
operator|=
name|chunksize
operator|-
operator|(
name|map_bias
operator|<<
name|LG_PAGE
operator|)
expr_stmt|;
name|bin_info_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_prefork
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|malloc_mutex_prefork
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
name|malloc_mutex_prefork
argument_list|(
operator|&
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_postfork_parent
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
name|malloc_mutex_postfork_parent
argument_list|(
operator|&
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_parent
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_postfork_child
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
name|malloc_mutex_postfork_child
argument_list|(
operator|&
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_child
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

