begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|JEMALLOC_ARENA_C_
end_define

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_internal.h"
end_include

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/* Data. */
end_comment

begin_decl_stmt
name|purge_mode_t
name|opt_purge
init|=
name|PURGE_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|purge_mode_names
index|[]
init|=
block|{
literal|"ratio"
block|,
literal|"decay"
block|,
literal|"N/A"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ssize_t
name|opt_lg_dirty_mult
init|=
name|LG_DIRTY_MULT_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ssize_t
name|lg_dirty_mult_default
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ssize_t
name|opt_decay_time
init|=
name|DECAY_TIME_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ssize_t
name|decay_time_default
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|arena_bin_info_t
name|arena_bin_info
index|[
name|NBINS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|map_bias
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|map_misc_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|arena_maxrun
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Max run size for arenas. */
end_comment

begin_decl_stmt
name|size_t
name|large_maxclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Max large size class. */
end_comment

begin_decl_stmt
name|size_t
name|run_quantize_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Max run_quantize_*() input. */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|small_maxrun
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Max run size for small size classes. */
end_comment

begin_decl_stmt
specifier|static
name|bool
modifier|*
name|small_run_tab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Valid small run page multiples. */
end_comment

begin_decl_stmt
specifier|static
name|size_t
modifier|*
name|run_quantize_floor_tab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* run_quantize_floor() memoization. */
end_comment

begin_decl_stmt
specifier|static
name|size_t
modifier|*
name|run_quantize_ceil_tab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* run_quantize_ceil() memoization. */
end_comment

begin_decl_stmt
name|unsigned
name|nlclasses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of large size classes. */
end_comment

begin_decl_stmt
name|unsigned
name|nhclasses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of huge size classes. */
end_comment

begin_decl_stmt
specifier|static
name|szind_t
name|runs_avail_bias
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size index for first runs_avail tree. */
end_comment

begin_decl_stmt
specifier|static
name|szind_t
name|runs_avail_nclasses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of runs_avail trees. */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Function prototypes for static functions that are referenced prior to  * definition.  */
end_comment

begin_function_decl
specifier|static
name|void
name|arena_purge_to_limit
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|ndirty_limit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_run_dalloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|bool
name|dirty
parameter_list|,
name|bool
name|cleaned
parameter_list|,
name|bool
name|decommitted
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_dalloc_bin_run
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_bin_lower_run
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/******************************************************************************/
end_comment

begin_function
name|JEMALLOC_INLINE_C
name|size_t
name|arena_miscelm_size_get
parameter_list|(
specifier|const
name|arena_chunk_map_misc_t
modifier|*
name|miscelm
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|size_t
name|pageind
decl_stmt|,
name|mapbits
decl_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|miscelm
argument_list|)
expr_stmt|;
name|pageind
operator|=
name|arena_miscelm_to_pageind
argument_list|(
name|miscelm
argument_list|)
expr_stmt|;
name|mapbits
operator|=
name|arena_mapbits_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
expr_stmt|;
return|return
operator|(
name|arena_mapbits_size_decode
argument_list|(
name|mapbits
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_INLINE_C
name|int
name|arena_run_addr_comp
parameter_list|(
specifier|const
name|arena_chunk_map_misc_t
modifier|*
name|a
parameter_list|,
specifier|const
name|arena_chunk_map_misc_t
modifier|*
name|b
parameter_list|)
block|{
name|uintptr_t
name|a_miscelm
init|=
operator|(
name|uintptr_t
operator|)
name|a
decl_stmt|;
name|uintptr_t
name|b_miscelm
init|=
operator|(
name|uintptr_t
operator|)
name|b
decl_stmt|;
name|assert
argument_list|(
name|a
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|b
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|a_miscelm
operator|>
name|b_miscelm
operator|)
operator|-
operator|(
name|a_miscelm
operator|<
name|b_miscelm
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Generate pairing heap functions. */
end_comment

begin_macro
name|ph_gen
argument_list|(
argument|static UNUSED
argument_list|,
argument|arena_run_heap_
argument_list|,
argument|arena_run_heap_t
argument_list|,
argument|arena_chunk_map_misc_t
argument_list|,
argument|ph_link
argument_list|,
argument|arena_run_addr_comp
argument_list|)
end_macro

begin_function
specifier|static
name|size_t
name|run_quantize_floor_compute
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|qsize
decl_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|==
name|PAGE_CEILING
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't change sizes that are valid small run sizes. */
if|if
condition|(
name|size
operator|<=
name|small_maxrun
operator|&&
name|small_run_tab
index|[
name|size
operator|>>
name|LG_PAGE
index|]
condition|)
return|return
operator|(
name|size
operator|)
return|;
comment|/* 	 * Round down to the nearest run size that can actually be requested 	 * during normal large allocation.  Add large_pad so that cache index 	 * randomization can offset the allocation from the page boundary. 	 */
name|qsize
operator|=
name|index2size
argument_list|(
name|size2index
argument_list|(
name|size
operator|-
name|large_pad
operator|+
literal|1
argument_list|)
operator|-
literal|1
argument_list|)
operator|+
name|large_pad
expr_stmt|;
if|if
condition|(
name|qsize
operator|<=
name|SMALL_MAXCLASS
operator|+
name|large_pad
condition|)
return|return
operator|(
name|run_quantize_floor_compute
argument_list|(
name|size
operator|-
name|large_pad
argument_list|)
operator|)
return|;
name|assert
argument_list|(
name|qsize
operator|<=
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|qsize
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|run_quantize_ceil_compute_hard
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|large_run_size_next
decl_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|==
name|PAGE_CEILING
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Return the next quantized size greater than the input size. 	 * Quantized sizes comprise the union of run sizes that back small 	 * region runs, and run sizes that back large regions with no explicit 	 * alignment constraints. 	 */
if|if
condition|(
name|size
operator|>
name|SMALL_MAXCLASS
condition|)
block|{
name|large_run_size_next
operator|=
name|PAGE_CEILING
argument_list|(
name|index2size
argument_list|(
name|size2index
argument_list|(
name|size
operator|-
name|large_pad
argument_list|)
operator|+
literal|1
argument_list|)
operator|+
name|large_pad
argument_list|)
expr_stmt|;
block|}
else|else
name|large_run_size_next
operator|=
name|SIZE_T_MAX
expr_stmt|;
if|if
condition|(
name|size
operator|>=
name|small_maxrun
condition|)
return|return
operator|(
name|large_run_size_next
operator|)
return|;
while|while
condition|(
name|true
condition|)
block|{
name|size
operator|+=
name|PAGE
expr_stmt|;
name|assert
argument_list|(
name|size
operator|<=
name|small_maxrun
argument_list|)
expr_stmt|;
if|if
condition|(
name|small_run_tab
index|[
name|size
operator|>>
name|LG_PAGE
index|]
condition|)
block|{
if|if
condition|(
name|large_run_size_next
operator|<
name|size
condition|)
return|return
operator|(
name|large_run_size_next
operator|)
return|;
return|return
operator|(
name|size
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|size_t
name|run_quantize_ceil_compute
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|qsize
init|=
name|run_quantize_floor_compute
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|qsize
operator|<
name|size
condition|)
block|{
comment|/* 		 * Skip a quantization that may have an adequately large run, 		 * because under-sized runs may be mixed in.  This only happens 		 * when an unusual size is requested, i.e. for aligned 		 * allocation, and is just one of several places where linear 		 * search would potentially find sufficiently aligned available 		 * memory somewhere lower. 		 */
name|qsize
operator|=
name|run_quantize_ceil_compute_hard
argument_list|(
name|qsize
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|qsize
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_JET
end_ifdef

begin_undef
undef|#
directive|undef
name|run_quantize_floor
end_undef

begin_define
define|#
directive|define
name|run_quantize_floor
value|JEMALLOC_N(n_run_quantize_floor)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|size_t
name|run_quantize_floor
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|ret
decl_stmt|;
name|assert
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|<=
name|run_quantize_max
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|size
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|run_quantize_floor_tab
index|[
operator|(
name|size
operator|>>
name|LG_PAGE
operator|)
operator|-
literal|1
index|]
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|run_quantize_floor_compute
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_JET
end_ifdef

begin_undef
undef|#
directive|undef
name|run_quantize_floor
end_undef

begin_define
define|#
directive|define
name|run_quantize_floor
value|JEMALLOC_N(run_quantize_floor)
end_define

begin_decl_stmt
name|run_quantize_t
modifier|*
name|run_quantize_floor
init|=
name|JEMALLOC_N
argument_list|(
name|n_run_quantize_floor
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_JET
end_ifdef

begin_undef
undef|#
directive|undef
name|run_quantize_ceil
end_undef

begin_define
define|#
directive|define
name|run_quantize_ceil
value|JEMALLOC_N(n_run_quantize_ceil)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|size_t
name|run_quantize_ceil
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|ret
decl_stmt|;
name|assert
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|<=
name|run_quantize_max
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|size
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|run_quantize_ceil_tab
index|[
operator|(
name|size
operator|>>
name|LG_PAGE
operator|)
operator|-
literal|1
index|]
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|run_quantize_ceil_compute
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_JET
end_ifdef

begin_undef
undef|#
directive|undef
name|run_quantize_ceil
end_undef

begin_define
define|#
directive|define
name|run_quantize_ceil
value|JEMALLOC_N(run_quantize_ceil)
end_define

begin_decl_stmt
name|run_quantize_t
modifier|*
name|run_quantize_ceil
init|=
name|JEMALLOC_N
argument_list|(
name|n_run_quantize_ceil
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|arena_run_heap_t
modifier|*
name|arena_runs_avail_get
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|szind_t
name|ind
parameter_list|)
block|{
name|assert
argument_list|(
name|ind
operator|>=
name|runs_avail_bias
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ind
operator|-
name|runs_avail_bias
operator|<
name|runs_avail_nclasses
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|arena
operator|->
name|runs_avail
index|[
name|ind
operator|-
name|runs_avail_bias
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_avail_insert
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|,
name|size_t
name|npages
parameter_list|)
block|{
name|szind_t
name|ind
init|=
name|size2index
argument_list|(
name|run_quantize_floor
argument_list|(
name|arena_miscelm_size_get
argument_list|(
name|arena_miscelm_get_const
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|npages
operator|==
operator|(
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|>>
name|LG_PAGE
operator|)
argument_list|)
expr_stmt|;
name|arena_run_heap_insert
argument_list|(
name|arena_runs_avail_get
argument_list|(
name|arena
argument_list|,
name|ind
argument_list|)
argument_list|,
name|arena_miscelm_get_mutable
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_avail_remove
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|,
name|size_t
name|npages
parameter_list|)
block|{
name|szind_t
name|ind
init|=
name|size2index
argument_list|(
name|run_quantize_floor
argument_list|(
name|arena_miscelm_size_get
argument_list|(
name|arena_miscelm_get_const
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|npages
operator|==
operator|(
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|>>
name|LG_PAGE
operator|)
argument_list|)
expr_stmt|;
name|arena_run_heap_remove
argument_list|(
name|arena_runs_avail_get
argument_list|(
name|arena
argument_list|,
name|ind
argument_list|)
argument_list|,
name|arena_miscelm_get_mutable
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_run_dirty_insert
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|,
name|size_t
name|npages
parameter_list|)
block|{
name|arena_chunk_map_misc_t
modifier|*
name|miscelm
init|=
name|arena_miscelm_get_mutable
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|npages
operator|==
operator|(
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|>>
name|LG_PAGE
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|==
name|CHUNK_MAP_DIRTY
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|npages
operator|-
literal|1
argument_list|)
operator|==
name|CHUNK_MAP_DIRTY
argument_list|)
expr_stmt|;
name|qr_new
argument_list|(
operator|&
name|miscelm
operator|->
name|rd
argument_list|,
name|rd_link
argument_list|)
expr_stmt|;
name|qr_meld
argument_list|(
operator|&
name|arena
operator|->
name|runs_dirty
argument_list|,
operator|&
name|miscelm
operator|->
name|rd
argument_list|,
name|rd_link
argument_list|)
expr_stmt|;
name|arena
operator|->
name|ndirty
operator|+=
name|npages
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_run_dirty_remove
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|pageind
parameter_list|,
name|size_t
name|npages
parameter_list|)
block|{
name|arena_chunk_map_misc_t
modifier|*
name|miscelm
init|=
name|arena_miscelm_get_mutable
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|npages
operator|==
operator|(
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|>>
name|LG_PAGE
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|==
name|CHUNK_MAP_DIRTY
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|npages
operator|-
literal|1
argument_list|)
operator|==
name|CHUNK_MAP_DIRTY
argument_list|)
expr_stmt|;
name|qr_remove
argument_list|(
operator|&
name|miscelm
operator|->
name|rd
argument_list|,
name|rd_link
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena
operator|->
name|ndirty
operator|>=
name|npages
argument_list|)
expr_stmt|;
name|arena
operator|->
name|ndirty
operator|-=
name|npages
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|arena_chunk_dirty_npages
parameter_list|(
specifier|const
name|extent_node_t
modifier|*
name|node
parameter_list|)
block|{
return|return
operator|(
name|extent_node_size_get
argument_list|(
name|node
argument_list|)
operator|>>
name|LG_PAGE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|arena_chunk_cache_maybe_insert
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|extent_node_t
modifier|*
name|node
parameter_list|,
name|bool
name|cache
parameter_list|)
block|{
if|if
condition|(
name|cache
condition|)
block|{
name|extent_node_dirty_linkage_init
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|extent_node_dirty_insert
argument_list|(
name|node
argument_list|,
operator|&
name|arena
operator|->
name|runs_dirty
argument_list|,
operator|&
name|arena
operator|->
name|chunks_cache
argument_list|)
expr_stmt|;
name|arena
operator|->
name|ndirty
operator|+=
name|arena_chunk_dirty_npages
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|arena_chunk_cache_maybe_remove
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|extent_node_t
modifier|*
name|node
parameter_list|,
name|bool
name|dirty
parameter_list|)
block|{
if|if
condition|(
name|dirty
condition|)
block|{
name|extent_node_dirty_remove
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena
operator|->
name|ndirty
operator|>=
name|arena_chunk_dirty_npages
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|arena
operator|->
name|ndirty
operator|-=
name|arena_chunk_dirty_npages
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|JEMALLOC_INLINE_C
name|void
modifier|*
name|arena_run_reg_alloc
parameter_list|(
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|arena_bin_info_t
modifier|*
name|bin_info
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|regind
decl_stmt|;
name|arena_chunk_map_misc_t
modifier|*
name|miscelm
decl_stmt|;
name|void
modifier|*
name|rpages
decl_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|nfree
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|bitmap_full
argument_list|(
name|run
operator|->
name|bitmap
argument_list|,
operator|&
name|bin_info
operator|->
name|bitmap_info
argument_list|)
argument_list|)
expr_stmt|;
name|regind
operator|=
operator|(
name|unsigned
operator|)
name|bitmap_sfu
argument_list|(
name|run
operator|->
name|bitmap
argument_list|,
operator|&
name|bin_info
operator|->
name|bitmap_info
argument_list|)
expr_stmt|;
name|miscelm
operator|=
name|arena_run_to_miscelm
argument_list|(
name|run
argument_list|)
expr_stmt|;
name|rpages
operator|=
name|arena_miscelm_to_rpages
argument_list|(
name|miscelm
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|rpages
operator|+
operator|(
name|uintptr_t
operator|)
name|bin_info
operator|->
name|reg0_offset
operator|+
call|(
name|uintptr_t
call|)
argument_list|(
name|bin_info
operator|->
name|reg_interval
operator|*
name|regind
argument_list|)
operator|)
expr_stmt|;
name|run
operator|->
name|nfree
operator|--
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_INLINE_C
name|void
name|arena_run_reg_dalloc
parameter_list|(
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
init|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|run
argument_list|)
decl_stmt|;
name|size_t
name|pageind
init|=
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|LG_PAGE
decl_stmt|;
name|size_t
name|mapbits
init|=
name|arena_mapbits_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
decl_stmt|;
name|szind_t
name|binind
init|=
name|arena_ptr_small_binind_get
argument_list|(
name|ptr
argument_list|,
name|mapbits
argument_list|)
decl_stmt|;
name|arena_bin_info_t
modifier|*
name|bin_info
init|=
operator|&
name|arena_bin_info
index|[
name|binind
index|]
decl_stmt|;
name|size_t
name|regind
init|=
name|arena_run_regind
argument_list|(
name|run
argument_list|,
name|bin_info
argument_list|,
name|ptr
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|nfree
operator|<
name|bin_info
operator|->
name|nregs
argument_list|)
expr_stmt|;
comment|/* Freeing an interior pointer can cause assertion failure. */
name|assert
argument_list|(
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
operator|(
name|uintptr_t
operator|)
name|arena_miscelm_to_rpages
argument_list|(
name|arena_run_to_miscelm
argument_list|(
name|run
argument_list|)
argument_list|)
operator|+
operator|(
name|uintptr_t
operator|)
name|bin_info
operator|->
name|reg0_offset
operator|)
operator|)
operator|%
operator|(
name|uintptr_t
operator|)
name|bin_info
operator|->
name|reg_interval
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|>=
operator|(
name|uintptr_t
operator|)
name|arena_miscelm_to_rpages
argument_list|(
name|arena_run_to_miscelm
argument_list|(
name|run
argument_list|)
argument_list|)
operator|+
operator|(
name|uintptr_t
operator|)
name|bin_info
operator|->
name|reg0_offset
argument_list|)
expr_stmt|;
comment|/* Freeing an unallocated pointer can cause assertion failure. */
name|assert
argument_list|(
name|bitmap_get
argument_list|(
name|run
operator|->
name|bitmap
argument_list|,
operator|&
name|bin_info
operator|->
name|bitmap_info
argument_list|,
name|regind
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_unset
argument_list|(
name|run
operator|->
name|bitmap
argument_list|,
operator|&
name|bin_info
operator|->
name|bitmap_info
argument_list|,
name|regind
argument_list|)
expr_stmt|;
name|run
operator|->
name|nfree
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_INLINE_C
name|void
name|arena_run_zero
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|run_ind
parameter_list|,
name|size_t
name|npages
parameter_list|)
block|{
name|JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
operator|(
name|run_ind
operator|<<
name|LG_PAGE
operator|)
operator|)
argument_list|,
operator|(
name|npages
operator|<<
name|LG_PAGE
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
operator|(
name|run_ind
operator|<<
name|LG_PAGE
operator|)
operator|)
argument_list|,
literal|0
argument_list|,
operator|(
name|npages
operator|<<
name|LG_PAGE
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_INLINE_C
name|void
name|arena_run_page_mark_zeroed
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|run_ind
parameter_list|)
block|{
name|JEMALLOC_VALGRIND_MAKE_MEM_DEFINED
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
operator|(
name|run_ind
operator|<<
name|LG_PAGE
operator|)
operator|)
argument_list|,
name|PAGE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_INLINE_C
name|void
name|arena_run_page_validate_zeroed
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|run_ind
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|UNUSED
name|size_t
modifier|*
name|p
init|=
operator|(
name|size_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
operator|(
name|run_ind
operator|<<
name|LG_PAGE
operator|)
operator|)
decl_stmt|;
name|arena_run_page_mark_zeroed
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PAGE
operator|/
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
condition|;
name|i
operator|++
control|)
name|assert
argument_list|(
name|p
index|[
name|i
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_nactive_add
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|add_pages
parameter_list|)
block|{
if|if
condition|(
name|config_stats
condition|)
block|{
name|size_t
name|cactive_add
init|=
name|CHUNK_CEILING
argument_list|(
operator|(
name|arena
operator|->
name|nactive
operator|+
name|add_pages
operator|)
operator|<<
name|LG_PAGE
argument_list|)
operator|-
name|CHUNK_CEILING
argument_list|(
name|arena
operator|->
name|nactive
operator|<<
name|LG_PAGE
argument_list|)
decl_stmt|;
if|if
condition|(
name|cactive_add
operator|!=
literal|0
condition|)
name|stats_cactive_add
argument_list|(
name|cactive_add
argument_list|)
expr_stmt|;
block|}
name|arena
operator|->
name|nactive
operator|+=
name|add_pages
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_nactive_sub
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|sub_pages
parameter_list|)
block|{
if|if
condition|(
name|config_stats
condition|)
block|{
name|size_t
name|cactive_sub
init|=
name|CHUNK_CEILING
argument_list|(
name|arena
operator|->
name|nactive
operator|<<
name|LG_PAGE
argument_list|)
operator|-
name|CHUNK_CEILING
argument_list|(
operator|(
name|arena
operator|->
name|nactive
operator|-
name|sub_pages
operator|)
operator|<<
name|LG_PAGE
argument_list|)
decl_stmt|;
if|if
condition|(
name|cactive_sub
operator|!=
literal|0
condition|)
name|stats_cactive_sub
argument_list|(
name|cactive_sub
argument_list|)
expr_stmt|;
block|}
name|arena
operator|->
name|nactive
operator|-=
name|sub_pages
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_run_split_remove
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
name|run_ind
parameter_list|,
name|size_t
name|flag_dirty
parameter_list|,
name|size_t
name|flag_decommitted
parameter_list|,
name|size_t
name|need_pages
parameter_list|)
block|{
name|size_t
name|total_pages
decl_stmt|,
name|rem_pages
decl_stmt|;
name|assert
argument_list|(
name|flag_dirty
operator|==
literal|0
operator|||
name|flag_decommitted
operator|==
literal|0
argument_list|)
expr_stmt|;
name|total_pages
operator|=
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
operator|>>
name|LG_PAGE
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|total_pages
operator|-
literal|1
argument_list|)
operator|==
name|flag_dirty
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|need_pages
operator|<=
name|total_pages
argument_list|)
expr_stmt|;
name|rem_pages
operator|=
name|total_pages
operator|-
name|need_pages
expr_stmt|;
name|arena_avail_remove
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|run_ind
argument_list|,
name|total_pages
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_dirty
operator|!=
literal|0
condition|)
name|arena_run_dirty_remove
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|run_ind
argument_list|,
name|total_pages
argument_list|)
expr_stmt|;
name|arena_nactive_add
argument_list|(
name|arena
argument_list|,
name|need_pages
argument_list|)
expr_stmt|;
comment|/* Keep track of trailing unused pages for later use. */
if|if
condition|(
name|rem_pages
operator|>
literal|0
condition|)
block|{
name|size_t
name|flags
init|=
name|flag_dirty
operator||
name|flag_decommitted
decl_stmt|;
name|size_t
name|flag_unzeroed_mask
init|=
operator|(
name|flags
operator|==
literal|0
operator|)
condition|?
name|CHUNK_MAP_UNZEROED
else|:
literal|0
decl_stmt|;
name|arena_mapbits_unallocated_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|need_pages
argument_list|,
operator|(
name|rem_pages
operator|<<
name|LG_PAGE
operator|)
argument_list|,
name|flags
operator||
operator|(
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|need_pages
argument_list|)
operator|&
name|flag_unzeroed_mask
operator|)
argument_list|)
expr_stmt|;
name|arena_mapbits_unallocated_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|total_pages
operator|-
literal|1
argument_list|,
operator|(
name|rem_pages
operator|<<
name|LG_PAGE
operator|)
argument_list|,
name|flags
operator||
operator|(
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|total_pages
operator|-
literal|1
argument_list|)
operator|&
name|flag_unzeroed_mask
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_dirty
operator|!=
literal|0
condition|)
block|{
name|arena_run_dirty_insert
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|run_ind
operator|+
name|need_pages
argument_list|,
name|rem_pages
argument_list|)
expr_stmt|;
block|}
name|arena_avail_insert
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|run_ind
operator|+
name|need_pages
argument_list|,
name|rem_pages
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|arena_run_split_large_helper
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|remove
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|arena_chunk_map_misc_t
modifier|*
name|miscelm
decl_stmt|;
name|size_t
name|flag_dirty
decl_stmt|,
name|flag_decommitted
decl_stmt|,
name|run_ind
decl_stmt|,
name|need_pages
decl_stmt|;
name|size_t
name|flag_unzeroed_mask
decl_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|run
argument_list|)
expr_stmt|;
name|miscelm
operator|=
name|arena_run_to_miscelm
argument_list|(
name|run
argument_list|)
expr_stmt|;
name|run_ind
operator|=
name|arena_miscelm_to_pageind
argument_list|(
name|miscelm
argument_list|)
expr_stmt|;
name|flag_dirty
operator|=
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
expr_stmt|;
name|flag_decommitted
operator|=
name|arena_mapbits_decommitted_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
expr_stmt|;
name|need_pages
operator|=
operator|(
name|size
operator|>>
name|LG_PAGE
operator|)
expr_stmt|;
name|assert
argument_list|(
name|need_pages
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_decommitted
operator|!=
literal|0
operator|&&
name|arena
operator|->
name|chunk_hooks
operator|.
name|commit
argument_list|(
name|chunk
argument_list|,
name|chunksize
argument_list|,
name|run_ind
operator|<<
name|LG_PAGE
argument_list|,
name|size
argument_list|,
name|arena
operator|->
name|ind
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
if|if
condition|(
name|remove
condition|)
block|{
name|arena_run_split_remove
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|run_ind
argument_list|,
name|flag_dirty
argument_list|,
name|flag_decommitted
argument_list|,
name|need_pages
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zero
condition|)
block|{
if|if
condition|(
name|flag_decommitted
operator|!=
literal|0
condition|)
block|{
comment|/* The run is untouched, and therefore zeroed. */
name|JEMALLOC_VALGRIND_MAKE_MEM_DEFINED
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
operator|(
name|run_ind
operator|<<
name|LG_PAGE
operator|)
operator|)
argument_list|,
operator|(
name|need_pages
operator|<<
name|LG_PAGE
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_dirty
operator|!=
literal|0
condition|)
block|{
comment|/* The run is dirty, so all pages must be zeroed. */
name|arena_run_zero
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|,
name|need_pages
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * The run is clean, so some pages may be zeroed (i.e. 			 * never before touched). 			 */
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|need_pages
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|i
argument_list|)
operator|!=
literal|0
condition|)
name|arena_run_zero
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|config_debug
condition|)
block|{
name|arena_run_page_validate_zeroed
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arena_run_page_mark_zeroed
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
operator|(
name|run_ind
operator|<<
name|LG_PAGE
operator|)
operator|)
argument_list|,
operator|(
name|need_pages
operator|<<
name|LG_PAGE
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set the last element first, in case the run only contains one page 	 * (i.e. both statements set the same element). 	 */
name|flag_unzeroed_mask
operator|=
operator|(
name|flag_dirty
operator||
name|flag_decommitted
operator|)
operator|==
literal|0
condition|?
name|CHUNK_MAP_UNZEROED
else|:
literal|0
expr_stmt|;
name|arena_mapbits_large_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|need_pages
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|flag_dirty
operator||
operator|(
name|flag_unzeroed_mask
operator|&
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|need_pages
operator|-
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|arena_mapbits_large_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|,
name|size
argument_list|,
name|flag_dirty
operator||
operator|(
name|flag_unzeroed_mask
operator|&
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|arena_run_split_large
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
return|return
operator|(
name|arena_run_split_large_helper
argument_list|(
name|arena
argument_list|,
name|run
argument_list|,
name|size
argument_list|,
name|true
argument_list|,
name|zero
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|arena_run_init_large
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
return|return
operator|(
name|arena_run_split_large_helper
argument_list|(
name|arena
argument_list|,
name|run
argument_list|,
name|size
argument_list|,
name|false
argument_list|,
name|zero
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|arena_run_split_small
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|size_t
name|size
parameter_list|,
name|szind_t
name|binind
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|arena_chunk_map_misc_t
modifier|*
name|miscelm
decl_stmt|;
name|size_t
name|flag_dirty
decl_stmt|,
name|flag_decommitted
decl_stmt|,
name|run_ind
decl_stmt|,
name|need_pages
decl_stmt|,
name|i
decl_stmt|;
name|assert
argument_list|(
name|binind
operator|!=
name|BININD_INVALID
argument_list|)
expr_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|run
argument_list|)
expr_stmt|;
name|miscelm
operator|=
name|arena_run_to_miscelm
argument_list|(
name|run
argument_list|)
expr_stmt|;
name|run_ind
operator|=
name|arena_miscelm_to_pageind
argument_list|(
name|miscelm
argument_list|)
expr_stmt|;
name|flag_dirty
operator|=
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
expr_stmt|;
name|flag_decommitted
operator|=
name|arena_mapbits_decommitted_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
expr_stmt|;
name|need_pages
operator|=
operator|(
name|size
operator|>>
name|LG_PAGE
operator|)
expr_stmt|;
name|assert
argument_list|(
name|need_pages
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_decommitted
operator|!=
literal|0
operator|&&
name|arena
operator|->
name|chunk_hooks
operator|.
name|commit
argument_list|(
name|chunk
argument_list|,
name|chunksize
argument_list|,
name|run_ind
operator|<<
name|LG_PAGE
argument_list|,
name|size
argument_list|,
name|arena
operator|->
name|ind
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|arena_run_split_remove
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|run_ind
argument_list|,
name|flag_dirty
argument_list|,
name|flag_decommitted
argument_list|,
name|need_pages
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|need_pages
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|flag_unzeroed
init|=
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|i
argument_list|)
decl_stmt|;
name|arena_mapbits_small_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|i
argument_list|,
name|i
argument_list|,
name|binind
argument_list|,
name|flag_unzeroed
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_debug
operator|&&
name|flag_dirty
operator|==
literal|0
operator|&&
name|flag_unzeroed
operator|==
literal|0
condition|)
name|arena_run_page_validate_zeroed
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
operator|(
name|run_ind
operator|<<
name|LG_PAGE
operator|)
operator|)
argument_list|,
operator|(
name|need_pages
operator|<<
name|LG_PAGE
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|arena_chunk_t
modifier|*
name|arena_chunk_init_spare
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|assert
argument_list|(
name|arena
operator|->
name|spare
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|chunk
operator|=
name|arena
operator|->
name|spare
expr_stmt|;
name|arena
operator|->
name|spare
operator|=
name|NULL
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_allocated_get
argument_list|(
name|chunk
argument_list|,
name|map_bias
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_allocated_get
argument_list|(
name|chunk
argument_list|,
name|chunk_npages
operator|-
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|map_bias
argument_list|)
operator|==
name|arena_maxrun
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|chunk_npages
operator|-
literal|1
argument_list|)
operator|==
name|arena_maxrun
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|map_bias
argument_list|)
operator|==
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|chunk_npages
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|chunk
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|arena_chunk_register
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
comment|/* 	 * The extent node notion of "committed" doesn't directly apply to 	 * arena chunks.  Arbitrarily mark them as committed.  The commit state 	 * of runs is tracked individually, and upon chunk deallocation the 	 * entire chunk is in a consistent commit state. 	 */
name|extent_node_init
argument_list|(
operator|&
name|chunk
operator|->
name|node
argument_list|,
name|arena
argument_list|,
name|chunk
argument_list|,
name|chunksize
argument_list|,
name|zero
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|extent_node_achunk_set
argument_list|(
operator|&
name|chunk
operator|->
name|node
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
operator|(
name|chunk_register
argument_list|(
name|tsdn
argument_list|,
name|chunk
argument_list|,
operator|&
name|chunk
operator|->
name|node
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|arena_chunk_t
modifier|*
name|arena_chunk_alloc_internal_hard
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|chunk_hooks_t
modifier|*
name|chunk_hooks
parameter_list|,
name|bool
modifier|*
name|zero
parameter_list|,
name|bool
modifier|*
name|commit
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|chunk_alloc_wrapper
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|chunk_hooks
argument_list|,
name|NULL
argument_list|,
name|chunksize
argument_list|,
name|chunksize
argument_list|,
name|zero
argument_list|,
name|commit
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|!=
name|NULL
operator|&&
operator|!
operator|*
name|commit
condition|)
block|{
comment|/* Commit header. */
if|if
condition|(
name|chunk_hooks
operator|->
name|commit
argument_list|(
name|chunk
argument_list|,
name|chunksize
argument_list|,
literal|0
argument_list|,
name|map_bias
operator|<<
name|LG_PAGE
argument_list|,
name|arena
operator|->
name|ind
argument_list|)
condition|)
block|{
name|chunk_dalloc_wrapper
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|chunk_hooks
argument_list|,
operator|(
name|void
operator|*
operator|)
name|chunk
argument_list|,
name|chunksize
argument_list|,
operator|*
name|zero
argument_list|,
operator|*
name|commit
argument_list|)
expr_stmt|;
name|chunk
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|chunk
operator|!=
name|NULL
operator|&&
name|arena_chunk_register
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|chunk
argument_list|,
operator|*
name|zero
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|commit
condition|)
block|{
comment|/* Undo commit of header. */
name|chunk_hooks
operator|->
name|decommit
argument_list|(
name|chunk
argument_list|,
name|chunksize
argument_list|,
literal|0
argument_list|,
name|map_bias
operator|<<
name|LG_PAGE
argument_list|,
name|arena
operator|->
name|ind
argument_list|)
expr_stmt|;
block|}
name|chunk_dalloc_wrapper
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|chunk_hooks
argument_list|,
operator|(
name|void
operator|*
operator|)
name|chunk
argument_list|,
name|chunksize
argument_list|,
operator|*
name|zero
argument_list|,
operator|*
name|commit
argument_list|)
expr_stmt|;
name|chunk
operator|=
name|NULL
expr_stmt|;
block|}
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|chunk
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|arena_chunk_t
modifier|*
name|arena_chunk_alloc_internal
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|bool
modifier|*
name|zero
parameter_list|,
name|bool
modifier|*
name|commit
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|chunk_hooks_t
name|chunk_hooks
init|=
name|CHUNK_HOOKS_INITIALIZER
decl_stmt|;
name|chunk
operator|=
name|chunk_alloc_cache
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|chunk_hooks
argument_list|,
name|NULL
argument_list|,
name|chunksize
argument_list|,
name|chunksize
argument_list|,
name|zero
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|arena_chunk_register
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|chunk
argument_list|,
operator|*
name|zero
argument_list|)
condition|)
block|{
name|chunk_dalloc_cache
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|chunk_hooks
argument_list|,
name|chunk
argument_list|,
name|chunksize
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|commit
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|chunk
operator|==
name|NULL
condition|)
block|{
name|chunk
operator|=
name|arena_chunk_alloc_internal_hard
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|chunk_hooks
argument_list|,
name|zero
argument_list|,
name|commit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config_stats
operator|&&
name|chunk
operator|!=
name|NULL
condition|)
block|{
name|arena
operator|->
name|stats
operator|.
name|mapped
operator|+=
name|chunksize
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|metadata_mapped
operator|+=
operator|(
name|map_bias
operator|<<
name|LG_PAGE
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|chunk
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|arena_chunk_t
modifier|*
name|arena_chunk_init_hard
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|bool
name|zero
decl_stmt|,
name|commit
decl_stmt|;
name|size_t
name|flag_unzeroed
decl_stmt|,
name|flag_decommitted
decl_stmt|,
name|i
decl_stmt|;
name|assert
argument_list|(
name|arena
operator|->
name|spare
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|zero
operator|=
name|false
expr_stmt|;
name|commit
operator|=
name|false
expr_stmt|;
name|chunk
operator|=
name|arena_chunk_alloc_internal
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|zero
argument_list|,
operator|&
name|commit
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Initialize the map to contain one maximal free untouched run.  Mark 	 * the pages as zeroed if arena_chunk_alloc_internal() returned a zeroed 	 * or decommitted chunk. 	 */
name|flag_unzeroed
operator|=
operator|(
name|zero
operator|||
operator|!
name|commit
operator|)
condition|?
literal|0
else|:
name|CHUNK_MAP_UNZEROED
expr_stmt|;
name|flag_decommitted
operator|=
name|commit
condition|?
literal|0
else|:
name|CHUNK_MAP_DECOMMITTED
expr_stmt|;
name|arena_mapbits_unallocated_set
argument_list|(
name|chunk
argument_list|,
name|map_bias
argument_list|,
name|arena_maxrun
argument_list|,
name|flag_unzeroed
operator||
name|flag_decommitted
argument_list|)
expr_stmt|;
comment|/* 	 * There is no need to initialize the internal page map entries unless 	 * the chunk is not zeroed. 	 */
if|if
condition|(
operator|!
name|zero
condition|)
block|{
name|JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED
argument_list|(
operator|(
name|void
operator|*
operator|)
name|arena_bitselm_get_const
argument_list|(
name|chunk
argument_list|,
name|map_bias
operator|+
literal|1
argument_list|)
argument_list|,
call|(
name|size_t
call|)
argument_list|(
operator|(
name|uintptr_t
operator|)
name|arena_bitselm_get_const
argument_list|(
name|chunk
argument_list|,
name|chunk_npages
operator|-
literal|1
argument_list|)
operator|-
operator|(
name|uintptr_t
operator|)
name|arena_bitselm_get_const
argument_list|(
name|chunk
argument_list|,
name|map_bias
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|map_bias
operator|+
literal|1
init|;
name|i
operator|<
name|chunk_npages
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|arena_mapbits_internal_set
argument_list|(
name|chunk
argument_list|,
name|i
argument_list|,
name|flag_unzeroed
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|JEMALLOC_VALGRIND_MAKE_MEM_DEFINED
argument_list|(
operator|(
name|void
operator|*
operator|)
name|arena_bitselm_get_const
argument_list|(
name|chunk
argument_list|,
name|map_bias
operator|+
literal|1
argument_list|)
argument_list|,
call|(
name|size_t
call|)
argument_list|(
operator|(
name|uintptr_t
operator|)
name|arena_bitselm_get_const
argument_list|(
name|chunk
argument_list|,
name|chunk_npages
operator|-
literal|1
argument_list|)
operator|-
operator|(
name|uintptr_t
operator|)
name|arena_bitselm_get_const
argument_list|(
name|chunk
argument_list|,
name|map_bias
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_debug
condition|)
block|{
for|for
control|(
name|i
operator|=
name|map_bias
operator|+
literal|1
init|;
name|i
operator|<
name|chunk_npages
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|assert
argument_list|(
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|i
argument_list|)
operator|==
name|flag_unzeroed
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|arena_mapbits_unallocated_set
argument_list|(
name|chunk
argument_list|,
name|chunk_npages
operator|-
literal|1
argument_list|,
name|arena_maxrun
argument_list|,
name|flag_unzeroed
argument_list|)
expr_stmt|;
return|return
operator|(
name|chunk
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|arena_chunk_t
modifier|*
name|arena_chunk_alloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
if|if
condition|(
name|arena
operator|->
name|spare
operator|!=
name|NULL
condition|)
name|chunk
operator|=
name|arena_chunk_init_spare
argument_list|(
name|arena
argument_list|)
expr_stmt|;
else|else
block|{
name|chunk
operator|=
name|arena_chunk_init_hard
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ql_elm_new
argument_list|(
operator|&
name|chunk
operator|->
name|node
argument_list|,
name|ql_link
argument_list|)
expr_stmt|;
name|ql_tail_insert
argument_list|(
operator|&
name|arena
operator|->
name|achunks
argument_list|,
operator|&
name|chunk
operator|->
name|node
argument_list|,
name|ql_link
argument_list|)
expr_stmt|;
name|arena_avail_insert
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|map_bias
argument_list|,
name|chunk_npages
operator|-
name|map_bias
argument_list|)
expr_stmt|;
return|return
operator|(
name|chunk
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_chunk_discard
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|)
block|{
name|bool
name|committed
decl_stmt|;
name|chunk_hooks_t
name|chunk_hooks
init|=
name|CHUNK_HOOKS_INITIALIZER
decl_stmt|;
name|chunk_deregister
argument_list|(
name|chunk
argument_list|,
operator|&
name|chunk
operator|->
name|node
argument_list|)
expr_stmt|;
name|committed
operator|=
operator|(
name|arena_mapbits_decommitted_get
argument_list|(
name|chunk
argument_list|,
name|map_bias
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|committed
condition|)
block|{
comment|/* 		 * Decommit the header.  Mark the chunk as decommitted even if 		 * header decommit fails, since treating a partially committed 		 * chunk as committed has a high potential for causing later 		 * access of decommitted memory. 		 */
name|chunk_hooks
operator|=
name|chunk_hooks_get
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|)
expr_stmt|;
name|chunk_hooks
operator|.
name|decommit
argument_list|(
name|chunk
argument_list|,
name|chunksize
argument_list|,
literal|0
argument_list|,
name|map_bias
operator|<<
name|LG_PAGE
argument_list|,
name|arena
operator|->
name|ind
argument_list|)
expr_stmt|;
block|}
name|chunk_dalloc_cache
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|chunk_hooks
argument_list|,
operator|(
name|void
operator|*
operator|)
name|chunk
argument_list|,
name|chunksize
argument_list|,
name|committed
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|arena
operator|->
name|stats
operator|.
name|mapped
operator|-=
name|chunksize
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|metadata_mapped
operator|-=
operator|(
name|map_bias
operator|<<
name|LG_PAGE
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arena_spare_discard
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|spare
parameter_list|)
block|{
name|assert
argument_list|(
name|arena
operator|->
name|spare
operator|!=
name|spare
argument_list|)
expr_stmt|;
if|if
condition|(
name|arena_mapbits_dirty_get
argument_list|(
name|spare
argument_list|,
name|map_bias
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|arena_run_dirty_remove
argument_list|(
name|arena
argument_list|,
name|spare
argument_list|,
name|map_bias
argument_list|,
name|chunk_npages
operator|-
name|map_bias
argument_list|)
expr_stmt|;
block|}
name|arena_chunk_discard
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|spare
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_chunk_dalloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|spare
decl_stmt|;
name|assert
argument_list|(
name|arena_mapbits_allocated_get
argument_list|(
name|chunk
argument_list|,
name|map_bias
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_allocated_get
argument_list|(
name|chunk
argument_list|,
name|chunk_npages
operator|-
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|map_bias
argument_list|)
operator|==
name|arena_maxrun
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|chunk_npages
operator|-
literal|1
argument_list|)
operator|==
name|arena_maxrun
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|map_bias
argument_list|)
operator|==
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|chunk_npages
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_decommitted_get
argument_list|(
name|chunk
argument_list|,
name|map_bias
argument_list|)
operator|==
name|arena_mapbits_decommitted_get
argument_list|(
name|chunk
argument_list|,
name|chunk_npages
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove run from runs_avail, so that the arena does not use it. */
name|arena_avail_remove
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|map_bias
argument_list|,
name|chunk_npages
operator|-
name|map_bias
argument_list|)
expr_stmt|;
name|ql_remove
argument_list|(
operator|&
name|arena
operator|->
name|achunks
argument_list|,
operator|&
name|chunk
operator|->
name|node
argument_list|,
name|ql_link
argument_list|)
expr_stmt|;
name|spare
operator|=
name|arena
operator|->
name|spare
expr_stmt|;
name|arena
operator|->
name|spare
operator|=
name|chunk
expr_stmt|;
if|if
condition|(
name|spare
operator|!=
name|NULL
condition|)
name|arena_spare_discard
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|spare
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_huge_malloc_stats_update
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|usize
parameter_list|)
block|{
name|szind_t
name|index
init|=
name|size2index
argument_list|(
name|usize
argument_list|)
operator|-
name|nlclasses
operator|-
name|NBINS
decl_stmt|;
name|cassert
argument_list|(
name|config_stats
argument_list|)
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|nmalloc_huge
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|allocated_huge
operator|+=
name|usize
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|hstats
index|[
name|index
index|]
operator|.
name|nmalloc
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|hstats
index|[
name|index
index|]
operator|.
name|curhchunks
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_huge_malloc_stats_update_undo
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|usize
parameter_list|)
block|{
name|szind_t
name|index
init|=
name|size2index
argument_list|(
name|usize
argument_list|)
operator|-
name|nlclasses
operator|-
name|NBINS
decl_stmt|;
name|cassert
argument_list|(
name|config_stats
argument_list|)
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|nmalloc_huge
operator|--
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|allocated_huge
operator|-=
name|usize
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|hstats
index|[
name|index
index|]
operator|.
name|nmalloc
operator|--
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|hstats
index|[
name|index
index|]
operator|.
name|curhchunks
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_huge_dalloc_stats_update
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|usize
parameter_list|)
block|{
name|szind_t
name|index
init|=
name|size2index
argument_list|(
name|usize
argument_list|)
operator|-
name|nlclasses
operator|-
name|NBINS
decl_stmt|;
name|cassert
argument_list|(
name|config_stats
argument_list|)
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|ndalloc_huge
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|allocated_huge
operator|-=
name|usize
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|hstats
index|[
name|index
index|]
operator|.
name|ndalloc
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|hstats
index|[
name|index
index|]
operator|.
name|curhchunks
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_huge_reset_stats_cancel
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|usize
parameter_list|)
block|{
name|szind_t
name|index
init|=
name|size2index
argument_list|(
name|usize
argument_list|)
operator|-
name|nlclasses
operator|-
name|NBINS
decl_stmt|;
name|cassert
argument_list|(
name|config_stats
argument_list|)
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|ndalloc_huge
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|hstats
index|[
name|index
index|]
operator|.
name|ndalloc
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_huge_dalloc_stats_update_undo
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|usize
parameter_list|)
block|{
name|szind_t
name|index
init|=
name|size2index
argument_list|(
name|usize
argument_list|)
operator|-
name|nlclasses
operator|-
name|NBINS
decl_stmt|;
name|cassert
argument_list|(
name|config_stats
argument_list|)
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|ndalloc_huge
operator|--
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|allocated_huge
operator|+=
name|usize
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|hstats
index|[
name|index
index|]
operator|.
name|ndalloc
operator|--
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|hstats
index|[
name|index
index|]
operator|.
name|curhchunks
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_huge_ralloc_stats_update
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|usize
parameter_list|)
block|{
name|arena_huge_dalloc_stats_update
argument_list|(
name|arena
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
name|arena_huge_malloc_stats_update
argument_list|(
name|arena
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_huge_ralloc_stats_update_undo
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|usize
parameter_list|)
block|{
name|arena_huge_dalloc_stats_update_undo
argument_list|(
name|arena
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
name|arena_huge_malloc_stats_update_undo
argument_list|(
name|arena
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|extent_node_t
modifier|*
name|arena_node_alloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|extent_node_t
modifier|*
name|node
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|node_cache_mtx
argument_list|)
expr_stmt|;
name|node
operator|=
name|ql_last
argument_list|(
operator|&
name|arena
operator|->
name|node_cache
argument_list|,
name|ql_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|node_cache_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|base_alloc
argument_list|(
name|tsdn
argument_list|,
sizeof|sizeof
argument_list|(
name|extent_node_t
argument_list|)
argument_list|)
operator|)
return|;
block|}
name|ql_tail_remove
argument_list|(
operator|&
name|arena
operator|->
name|node_cache
argument_list|,
name|extent_node_t
argument_list|,
name|ql_link
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|node_cache_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|node
operator|)
return|;
block|}
end_function

begin_function
name|void
name|arena_node_dalloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|extent_node_t
modifier|*
name|node
parameter_list|)
block|{
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|node_cache_mtx
argument_list|)
expr_stmt|;
name|ql_elm_new
argument_list|(
name|node
argument_list|,
name|ql_link
argument_list|)
expr_stmt|;
name|ql_tail_insert
argument_list|(
operator|&
name|arena
operator|->
name|node_cache
argument_list|,
name|node
argument_list|,
name|ql_link
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|node_cache_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|arena_chunk_alloc_huge_hard
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|chunk_hooks_t
modifier|*
name|chunk_hooks
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
modifier|*
name|zero
parameter_list|,
name|size_t
name|csize
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|bool
name|commit
init|=
name|true
decl_stmt|;
name|ret
operator|=
name|chunk_alloc_wrapper
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|chunk_hooks
argument_list|,
name|NULL
argument_list|,
name|csize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
operator|&
name|commit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
comment|/* Revert optimistic stats updates. */
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|arena_huge_malloc_stats_update_undo
argument_list|(
name|arena
argument_list|,
name|usize
argument_list|)
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|mapped
operator|-=
name|usize
expr_stmt|;
block|}
name|arena_nactive_sub
argument_list|(
name|arena
argument_list|,
name|usize
operator|>>
name|LG_PAGE
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|arena_chunk_alloc_huge
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
modifier|*
name|zero
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|chunk_hooks_t
name|chunk_hooks
init|=
name|CHUNK_HOOKS_INITIALIZER
decl_stmt|;
name|size_t
name|csize
init|=
name|CHUNK_CEILING
argument_list|(
name|usize
argument_list|)
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* Optimistically update stats. */
if|if
condition|(
name|config_stats
condition|)
block|{
name|arena_huge_malloc_stats_update
argument_list|(
name|arena
argument_list|,
name|usize
argument_list|)
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|mapped
operator|+=
name|usize
expr_stmt|;
block|}
name|arena_nactive_add
argument_list|(
name|arena
argument_list|,
name|usize
operator|>>
name|LG_PAGE
argument_list|)
expr_stmt|;
name|ret
operator|=
name|chunk_alloc_cache
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|chunk_hooks
argument_list|,
name|NULL
argument_list|,
name|csize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|arena_chunk_alloc_huge_hard
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|chunk_hooks
argument_list|,
name|usize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|csize
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|arena_chunk_dalloc_huge
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|void
modifier|*
name|chunk
parameter_list|,
name|size_t
name|usize
parameter_list|)
block|{
name|chunk_hooks_t
name|chunk_hooks
init|=
name|CHUNK_HOOKS_INITIALIZER
decl_stmt|;
name|size_t
name|csize
decl_stmt|;
name|csize
operator|=
name|CHUNK_CEILING
argument_list|(
name|usize
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|arena_huge_dalloc_stats_update
argument_list|(
name|arena
argument_list|,
name|usize
argument_list|)
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|mapped
operator|-=
name|usize
expr_stmt|;
block|}
name|arena_nactive_sub
argument_list|(
name|arena
argument_list|,
name|usize
operator|>>
name|LG_PAGE
argument_list|)
expr_stmt|;
name|chunk_dalloc_cache
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|chunk_hooks
argument_list|,
name|chunk
argument_list|,
name|csize
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_chunk_ralloc_huge_similar
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|void
modifier|*
name|chunk
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|usize
parameter_list|)
block|{
name|assert
argument_list|(
name|CHUNK_CEILING
argument_list|(
name|oldsize
argument_list|)
operator|==
name|CHUNK_CEILING
argument_list|(
name|usize
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|oldsize
operator|!=
name|usize
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
name|arena_huge_ralloc_stats_update
argument_list|(
name|arena
argument_list|,
name|oldsize
argument_list|,
name|usize
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldsize
operator|<
name|usize
condition|)
name|arena_nactive_add
argument_list|(
name|arena
argument_list|,
operator|(
name|usize
operator|-
name|oldsize
operator|)
operator|>>
name|LG_PAGE
argument_list|)
expr_stmt|;
else|else
name|arena_nactive_sub
argument_list|(
name|arena
argument_list|,
operator|(
name|oldsize
operator|-
name|usize
operator|)
operator|>>
name|LG_PAGE
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_chunk_ralloc_huge_shrink
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|void
modifier|*
name|chunk
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|usize
parameter_list|)
block|{
name|size_t
name|udiff
init|=
name|oldsize
operator|-
name|usize
decl_stmt|;
name|size_t
name|cdiff
init|=
name|CHUNK_CEILING
argument_list|(
name|oldsize
argument_list|)
operator|-
name|CHUNK_CEILING
argument_list|(
name|usize
argument_list|)
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|arena_huge_ralloc_stats_update
argument_list|(
name|arena
argument_list|,
name|oldsize
argument_list|,
name|usize
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdiff
operator|!=
literal|0
condition|)
name|arena
operator|->
name|stats
operator|.
name|mapped
operator|-=
name|cdiff
expr_stmt|;
block|}
name|arena_nactive_sub
argument_list|(
name|arena
argument_list|,
name|udiff
operator|>>
name|LG_PAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdiff
operator|!=
literal|0
condition|)
block|{
name|chunk_hooks_t
name|chunk_hooks
init|=
name|CHUNK_HOOKS_INITIALIZER
decl_stmt|;
name|void
modifier|*
name|nchunk
init|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
name|CHUNK_CEILING
argument_list|(
name|usize
argument_list|)
operator|)
decl_stmt|;
name|chunk_dalloc_cache
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|chunk_hooks
argument_list|,
name|nchunk
argument_list|,
name|cdiff
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|arena_chunk_ralloc_huge_expand_hard
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|chunk_hooks_t
modifier|*
name|chunk_hooks
parameter_list|,
name|void
modifier|*
name|chunk
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|bool
modifier|*
name|zero
parameter_list|,
name|void
modifier|*
name|nchunk
parameter_list|,
name|size_t
name|udiff
parameter_list|,
name|size_t
name|cdiff
parameter_list|)
block|{
name|bool
name|err
decl_stmt|;
name|bool
name|commit
init|=
name|true
decl_stmt|;
name|err
operator|=
operator|(
name|chunk_alloc_wrapper
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|chunk_hooks
argument_list|,
name|nchunk
argument_list|,
name|cdiff
argument_list|,
name|chunksize
argument_list|,
name|zero
argument_list|,
operator|&
name|commit
argument_list|)
operator|==
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* Revert optimistic stats updates. */
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|arena_huge_ralloc_stats_update_undo
argument_list|(
name|arena
argument_list|,
name|oldsize
argument_list|,
name|usize
argument_list|)
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|mapped
operator|-=
name|cdiff
expr_stmt|;
block|}
name|arena_nactive_sub
argument_list|(
name|arena
argument_list|,
name|udiff
operator|>>
name|LG_PAGE
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chunk_hooks
operator|->
name|merge
argument_list|(
name|chunk
argument_list|,
name|CHUNK_CEILING
argument_list|(
name|oldsize
argument_list|)
argument_list|,
name|nchunk
argument_list|,
name|cdiff
argument_list|,
name|true
argument_list|,
name|arena
operator|->
name|ind
argument_list|)
condition|)
block|{
name|chunk_dalloc_wrapper
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|chunk_hooks
argument_list|,
name|nchunk
argument_list|,
name|cdiff
argument_list|,
operator|*
name|zero
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|err
operator|=
name|true
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|arena_chunk_ralloc_huge_expand
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|void
modifier|*
name|chunk
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|bool
modifier|*
name|zero
parameter_list|)
block|{
name|bool
name|err
decl_stmt|;
name|chunk_hooks_t
name|chunk_hooks
init|=
name|chunk_hooks_get
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|)
decl_stmt|;
name|void
modifier|*
name|nchunk
init|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
name|CHUNK_CEILING
argument_list|(
name|oldsize
argument_list|)
operator|)
decl_stmt|;
name|size_t
name|udiff
init|=
name|usize
operator|-
name|oldsize
decl_stmt|;
name|size_t
name|cdiff
init|=
name|CHUNK_CEILING
argument_list|(
name|usize
argument_list|)
operator|-
name|CHUNK_CEILING
argument_list|(
name|oldsize
argument_list|)
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* Optimistically update stats. */
if|if
condition|(
name|config_stats
condition|)
block|{
name|arena_huge_ralloc_stats_update
argument_list|(
name|arena
argument_list|,
name|oldsize
argument_list|,
name|usize
argument_list|)
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|mapped
operator|+=
name|cdiff
expr_stmt|;
block|}
name|arena_nactive_add
argument_list|(
name|arena
argument_list|,
name|udiff
operator|>>
name|LG_PAGE
argument_list|)
expr_stmt|;
name|err
operator|=
operator|(
name|chunk_alloc_cache
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|chunk_hooks
argument_list|,
name|nchunk
argument_list|,
name|cdiff
argument_list|,
name|chunksize
argument_list|,
name|zero
argument_list|,
name|true
argument_list|)
operator|==
name|NULL
operator|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|err
operator|=
name|arena_chunk_ralloc_huge_expand_hard
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|chunk_hooks
argument_list|,
name|chunk
argument_list|,
name|oldsize
argument_list|,
name|usize
argument_list|,
name|zero
argument_list|,
name|nchunk
argument_list|,
name|udiff
argument_list|,
name|cdiff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chunk_hooks
operator|.
name|merge
argument_list|(
name|chunk
argument_list|,
name|CHUNK_CEILING
argument_list|(
name|oldsize
argument_list|)
argument_list|,
name|nchunk
argument_list|,
name|cdiff
argument_list|,
name|true
argument_list|,
name|arena
operator|->
name|ind
argument_list|)
condition|)
block|{
name|chunk_dalloc_wrapper
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|chunk_hooks
argument_list|,
name|nchunk
argument_list|,
name|cdiff
argument_list|,
operator|*
name|zero
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|err
operator|=
name|true
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do first-best-fit run selection, i.e. select the lowest run that best fits.  * Run sizes are indexed, so not all candidate runs are necessarily exactly the  * same size.  */
end_comment

begin_function
specifier|static
name|arena_run_t
modifier|*
name|arena_run_first_best_fit
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|szind_t
name|ind
decl_stmt|,
name|i
decl_stmt|;
name|ind
operator|=
name|size2index
argument_list|(
name|run_quantize_ceil
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ind
init|;
name|i
operator|<
name|runs_avail_nclasses
operator|+
name|runs_avail_bias
condition|;
name|i
operator|++
control|)
block|{
name|arena_chunk_map_misc_t
modifier|*
name|miscelm
init|=
name|arena_run_heap_first
argument_list|(
name|arena_runs_avail_get
argument_list|(
name|arena
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|miscelm
operator|!=
name|NULL
condition|)
return|return
operator|(
operator|&
name|miscelm
operator|->
name|run
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|arena_run_t
modifier|*
name|arena_run_alloc_large_helper
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|arena_run_t
modifier|*
name|run
init|=
name|arena_run_first_best_fit
argument_list|(
name|arena
argument_list|,
name|s2u
argument_list|(
name|size
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|run
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|arena_run_split_large
argument_list|(
name|arena
argument_list|,
name|run
argument_list|,
name|size
argument_list|,
name|zero
argument_list|)
condition|)
name|run
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|run
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|arena_run_t
modifier|*
name|arena_run_alloc_large
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|assert
argument_list|(
name|size
operator|<=
name|arena_maxrun
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|==
name|PAGE_CEILING
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Search the arena's chunks for the lowest best fit. */
name|run
operator|=
name|arena_run_alloc_large_helper
argument_list|(
name|arena
argument_list|,
name|size
argument_list|,
name|zero
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
operator|!=
name|NULL
condition|)
return|return
operator|(
name|run
operator|)
return|;
comment|/* 	 * No usable runs.  Create a new chunk from which to allocate the run. 	 */
name|chunk
operator|=
name|arena_chunk_alloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|!=
name|NULL
condition|)
block|{
name|run
operator|=
operator|&
name|arena_miscelm_get_mutable
argument_list|(
name|chunk
argument_list|,
name|map_bias
argument_list|)
operator|->
name|run
expr_stmt|;
if|if
condition|(
name|arena_run_split_large
argument_list|(
name|arena
argument_list|,
name|run
argument_list|,
name|size
argument_list|,
name|zero
argument_list|)
condition|)
name|run
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|run
operator|)
return|;
block|}
comment|/* 	 * arena_chunk_alloc() failed, but another thread may have made 	 * sufficient memory available while this one dropped arena->lock in 	 * arena_chunk_alloc(), so search one more time. 	 */
return|return
operator|(
name|arena_run_alloc_large_helper
argument_list|(
name|arena
argument_list|,
name|size
argument_list|,
name|zero
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|arena_run_t
modifier|*
name|arena_run_alloc_small_helper
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|szind_t
name|binind
parameter_list|)
block|{
name|arena_run_t
modifier|*
name|run
init|=
name|arena_run_first_best_fit
argument_list|(
name|arena
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|run
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|arena_run_split_small
argument_list|(
name|arena
argument_list|,
name|run
argument_list|,
name|size
argument_list|,
name|binind
argument_list|)
condition|)
name|run
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|run
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|arena_run_t
modifier|*
name|arena_run_alloc_small
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|szind_t
name|binind
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|assert
argument_list|(
name|size
operator|<=
name|arena_maxrun
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|==
name|PAGE_CEILING
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|binind
operator|!=
name|BININD_INVALID
argument_list|)
expr_stmt|;
comment|/* Search the arena's chunks for the lowest best fit. */
name|run
operator|=
name|arena_run_alloc_small_helper
argument_list|(
name|arena
argument_list|,
name|size
argument_list|,
name|binind
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
operator|!=
name|NULL
condition|)
return|return
operator|(
name|run
operator|)
return|;
comment|/* 	 * No usable runs.  Create a new chunk from which to allocate the run. 	 */
name|chunk
operator|=
name|arena_chunk_alloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|!=
name|NULL
condition|)
block|{
name|run
operator|=
operator|&
name|arena_miscelm_get_mutable
argument_list|(
name|chunk
argument_list|,
name|map_bias
argument_list|)
operator|->
name|run
expr_stmt|;
if|if
condition|(
name|arena_run_split_small
argument_list|(
name|arena
argument_list|,
name|run
argument_list|,
name|size
argument_list|,
name|binind
argument_list|)
condition|)
name|run
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|run
operator|)
return|;
block|}
comment|/* 	 * arena_chunk_alloc() failed, but another thread may have made 	 * sufficient memory available while this one dropped arena->lock in 	 * arena_chunk_alloc(), so search one more time. 	 */
return|return
operator|(
name|arena_run_alloc_small_helper
argument_list|(
name|arena
argument_list|,
name|size
argument_list|,
name|binind
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|arena_lg_dirty_mult_valid
parameter_list|(
name|ssize_t
name|lg_dirty_mult
parameter_list|)
block|{
return|return
operator|(
name|lg_dirty_mult
operator|>=
operator|-
literal|1
operator|&&
name|lg_dirty_mult
operator|<
call|(
name|ssize_t
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|<<
literal|3
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|ssize_t
name|arena_lg_dirty_mult_get
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|ssize_t
name|lg_dirty_mult
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lg_dirty_mult
operator|=
name|arena
operator|->
name|lg_dirty_mult
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|lg_dirty_mult
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|arena_lg_dirty_mult_set
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|ssize_t
name|lg_dirty_mult
parameter_list|)
block|{
if|if
condition|(
operator|!
name|arena_lg_dirty_mult_valid
argument_list|(
name|lg_dirty_mult
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arena
operator|->
name|lg_dirty_mult
operator|=
name|lg_dirty_mult
expr_stmt|;
name|arena_maybe_purge
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_decay_deadline_init
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|assert
argument_list|(
name|opt_purge
operator|==
name|purge_mode_decay
argument_list|)
expr_stmt|;
comment|/* 	 * Generate a new deadline that is uniformly random within the next 	 * epoch after the current one. 	 */
name|nstime_copy
argument_list|(
operator|&
name|arena
operator|->
name|decay_deadline
argument_list|,
operator|&
name|arena
operator|->
name|decay_epoch
argument_list|)
expr_stmt|;
name|nstime_add
argument_list|(
operator|&
name|arena
operator|->
name|decay_deadline
argument_list|,
operator|&
name|arena
operator|->
name|decay_interval
argument_list|)
expr_stmt|;
if|if
condition|(
name|arena
operator|->
name|decay_time
operator|>
literal|0
condition|)
block|{
name|nstime_t
name|jitter
decl_stmt|;
name|nstime_init
argument_list|(
operator|&
name|jitter
argument_list|,
name|prng_range
argument_list|(
operator|&
name|arena
operator|->
name|decay_jitter_state
argument_list|,
name|nstime_ns
argument_list|(
operator|&
name|arena
operator|->
name|decay_interval
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|nstime_add
argument_list|(
operator|&
name|arena
operator|->
name|decay_deadline
argument_list|,
operator|&
name|jitter
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|arena_decay_deadline_reached
parameter_list|(
specifier|const
name|arena_t
modifier|*
name|arena
parameter_list|,
specifier|const
name|nstime_t
modifier|*
name|time
parameter_list|)
block|{
name|assert
argument_list|(
name|opt_purge
operator|==
name|purge_mode_decay
argument_list|)
expr_stmt|;
return|return
operator|(
name|nstime_compare
argument_list|(
operator|&
name|arena
operator|->
name|decay_deadline
argument_list|,
name|time
argument_list|)
operator|<=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|arena_decay_backlog_npages_limit
parameter_list|(
specifier|const
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
specifier|static
specifier|const
name|uint64_t
name|h_steps
index|[]
init|=
block|{
define|#
directive|define
name|STEP
parameter_list|(
name|step
parameter_list|,
name|h
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|h,
name|SMOOTHSTEP
undef|#
directive|undef
name|STEP
block|}
decl_stmt|;
name|uint64_t
name|sum
decl_stmt|;
name|size_t
name|npages_limit_backlog
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|assert
argument_list|(
name|opt_purge
operator|==
name|purge_mode_decay
argument_list|)
expr_stmt|;
comment|/* 	 * For each element of decay_backlog, multiply by the corresponding 	 * fixed-point smoothstep decay factor.  Sum the products, then divide 	 * to round down to the nearest whole number of pages. 	 */
name|sum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SMOOTHSTEP_NSTEPS
condition|;
name|i
operator|++
control|)
name|sum
operator|+=
name|arena
operator|->
name|decay_backlog
index|[
name|i
index|]
operator|*
name|h_steps
index|[
name|i
index|]
expr_stmt|;
name|npages_limit_backlog
operator|=
call|(
name|size_t
call|)
argument_list|(
name|sum
operator|>>
name|SMOOTHSTEP_BFP
argument_list|)
expr_stmt|;
return|return
operator|(
name|npages_limit_backlog
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_decay_epoch_advance
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
specifier|const
name|nstime_t
modifier|*
name|time
parameter_list|)
block|{
name|uint64_t
name|nadvance_u64
decl_stmt|;
name|nstime_t
name|delta
decl_stmt|;
name|size_t
name|ndirty_delta
decl_stmt|;
name|assert
argument_list|(
name|opt_purge
operator|==
name|purge_mode_decay
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_decay_deadline_reached
argument_list|(
name|arena
argument_list|,
name|time
argument_list|)
argument_list|)
expr_stmt|;
name|nstime_copy
argument_list|(
operator|&
name|delta
argument_list|,
name|time
argument_list|)
expr_stmt|;
name|nstime_subtract
argument_list|(
operator|&
name|delta
argument_list|,
operator|&
name|arena
operator|->
name|decay_epoch
argument_list|)
expr_stmt|;
name|nadvance_u64
operator|=
name|nstime_divide
argument_list|(
operator|&
name|delta
argument_list|,
operator|&
name|arena
operator|->
name|decay_interval
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|nadvance_u64
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* Add nadvance_u64 decay intervals to epoch. */
name|nstime_copy
argument_list|(
operator|&
name|delta
argument_list|,
operator|&
name|arena
operator|->
name|decay_interval
argument_list|)
expr_stmt|;
name|nstime_imultiply
argument_list|(
operator|&
name|delta
argument_list|,
name|nadvance_u64
argument_list|)
expr_stmt|;
name|nstime_add
argument_list|(
operator|&
name|arena
operator|->
name|decay_epoch
argument_list|,
operator|&
name|delta
argument_list|)
expr_stmt|;
comment|/* Set a new deadline. */
name|arena_decay_deadline_init
argument_list|(
name|arena
argument_list|)
expr_stmt|;
comment|/* Update the backlog. */
if|if
condition|(
name|nadvance_u64
operator|>=
name|SMOOTHSTEP_NSTEPS
condition|)
block|{
name|memset
argument_list|(
name|arena
operator|->
name|decay_backlog
argument_list|,
literal|0
argument_list|,
operator|(
name|SMOOTHSTEP_NSTEPS
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|nadvance_z
init|=
operator|(
name|size_t
operator|)
name|nadvance_u64
decl_stmt|;
name|assert
argument_list|(
operator|(
name|uint64_t
operator|)
name|nadvance_z
operator|==
name|nadvance_u64
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|arena
operator|->
name|decay_backlog
argument_list|,
operator|&
name|arena
operator|->
name|decay_backlog
index|[
name|nadvance_z
index|]
argument_list|,
operator|(
name|SMOOTHSTEP_NSTEPS
operator|-
name|nadvance_z
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nadvance_z
operator|>
literal|1
condition|)
block|{
name|memset
argument_list|(
operator|&
name|arena
operator|->
name|decay_backlog
index|[
name|SMOOTHSTEP_NSTEPS
operator|-
name|nadvance_z
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|nadvance_z
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ndirty_delta
operator|=
operator|(
name|arena
operator|->
name|ndirty
operator|>
name|arena
operator|->
name|decay_ndirty
operator|)
condition|?
name|arena
operator|->
name|ndirty
operator|-
name|arena
operator|->
name|decay_ndirty
else|:
literal|0
expr_stmt|;
name|arena
operator|->
name|decay_ndirty
operator|=
name|arena
operator|->
name|ndirty
expr_stmt|;
name|arena
operator|->
name|decay_backlog
index|[
name|SMOOTHSTEP_NSTEPS
operator|-
literal|1
index|]
operator|=
name|ndirty_delta
expr_stmt|;
name|arena
operator|->
name|decay_backlog_npages_limit
operator|=
name|arena_decay_backlog_npages_limit
argument_list|(
name|arena
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|arena_decay_npages_limit
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|size_t
name|npages_limit
decl_stmt|;
name|assert
argument_list|(
name|opt_purge
operator|==
name|purge_mode_decay
argument_list|)
expr_stmt|;
name|npages_limit
operator|=
name|arena
operator|->
name|decay_backlog_npages_limit
expr_stmt|;
comment|/* Add in any dirty pages created during the current epoch. */
if|if
condition|(
name|arena
operator|->
name|ndirty
operator|>
name|arena
operator|->
name|decay_ndirty
condition|)
name|npages_limit
operator|+=
name|arena
operator|->
name|ndirty
operator|-
name|arena
operator|->
name|decay_ndirty
expr_stmt|;
return|return
operator|(
name|npages_limit
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_decay_init
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|ssize_t
name|decay_time
parameter_list|)
block|{
name|arena
operator|->
name|decay_time
operator|=
name|decay_time
expr_stmt|;
if|if
condition|(
name|decay_time
operator|>
literal|0
condition|)
block|{
name|nstime_init2
argument_list|(
operator|&
name|arena
operator|->
name|decay_interval
argument_list|,
name|decay_time
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nstime_idivide
argument_list|(
operator|&
name|arena
operator|->
name|decay_interval
argument_list|,
name|SMOOTHSTEP_NSTEPS
argument_list|)
expr_stmt|;
block|}
name|nstime_init
argument_list|(
operator|&
name|arena
operator|->
name|decay_epoch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nstime_update
argument_list|(
operator|&
name|arena
operator|->
name|decay_epoch
argument_list|)
expr_stmt|;
name|arena
operator|->
name|decay_jitter_state
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|arena
expr_stmt|;
name|arena_decay_deadline_init
argument_list|(
name|arena
argument_list|)
expr_stmt|;
name|arena
operator|->
name|decay_ndirty
operator|=
name|arena
operator|->
name|ndirty
expr_stmt|;
name|arena
operator|->
name|decay_backlog_npages_limit
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|arena
operator|->
name|decay_backlog
argument_list|,
literal|0
argument_list|,
name|SMOOTHSTEP_NSTEPS
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|arena_decay_time_valid
parameter_list|(
name|ssize_t
name|decay_time
parameter_list|)
block|{
if|if
condition|(
name|decay_time
operator|<
operator|-
literal|1
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|decay_time
operator|==
operator|-
literal|1
operator|||
operator|(
name|uint64_t
operator|)
name|decay_time
operator|<=
name|NSTIME_SEC_MAX
condition|)
return|return
operator|(
name|true
operator|)
return|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
name|ssize_t
name|arena_decay_time_get
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|ssize_t
name|decay_time
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|decay_time
operator|=
name|arena
operator|->
name|decay_time
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|decay_time
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|arena_decay_time_set
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|ssize_t
name|decay_time
parameter_list|)
block|{
if|if
condition|(
operator|!
name|arena_decay_time_valid
argument_list|(
name|decay_time
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Restart decay backlog from scratch, which may cause many dirty pages 	 * to be immediately purged.  It would conceptually be possible to map 	 * the old backlog onto the new backlog, but there is no justification 	 * for such complexity since decay_time changes are intended to be 	 * infrequent, either between the {-1, 0,>0} states, or a one-time 	 * arbitrary change during initial arena configuration. 	 */
name|arena_decay_init
argument_list|(
name|arena
argument_list|,
name|decay_time
argument_list|)
expr_stmt|;
name|arena_maybe_purge
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_maybe_purge_ratio
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|assert
argument_list|(
name|opt_purge
operator|==
name|purge_mode_ratio
argument_list|)
expr_stmt|;
comment|/* Don't purge if the option is disabled. */
if|if
condition|(
name|arena
operator|->
name|lg_dirty_mult
operator|<
literal|0
condition|)
return|return;
comment|/* 	 * Iterate, since preventing recursive purging could otherwise leave too 	 * many dirty pages. 	 */
while|while
condition|(
name|true
condition|)
block|{
name|size_t
name|threshold
init|=
operator|(
name|arena
operator|->
name|nactive
operator|>>
name|arena
operator|->
name|lg_dirty_mult
operator|)
decl_stmt|;
if|if
condition|(
name|threshold
operator|<
name|chunk_npages
condition|)
name|threshold
operator|=
name|chunk_npages
expr_stmt|;
comment|/* 		 * Don't purge unless the number of purgeable pages exceeds the 		 * threshold. 		 */
if|if
condition|(
name|arena
operator|->
name|ndirty
operator|<=
name|threshold
condition|)
return|return;
name|arena_purge_to_limit
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|threshold
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arena_maybe_purge_decay
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|nstime_t
name|time
decl_stmt|;
name|size_t
name|ndirty_limit
decl_stmt|;
name|assert
argument_list|(
name|opt_purge
operator|==
name|purge_mode_decay
argument_list|)
expr_stmt|;
comment|/* Purge all or nothing if the option is disabled. */
if|if
condition|(
name|arena
operator|->
name|decay_time
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|arena
operator|->
name|decay_time
operator|==
literal|0
condition|)
name|arena_purge_to_limit
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|nstime_copy
argument_list|(
operator|&
name|time
argument_list|,
operator|&
name|arena
operator|->
name|decay_epoch
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|nstime_update
argument_list|(
operator|&
name|time
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Time went backwards.  Force an epoch advance. */
name|nstime_copy
argument_list|(
operator|&
name|time
argument_list|,
operator|&
name|arena
operator|->
name|decay_deadline
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arena_decay_deadline_reached
argument_list|(
name|arena
argument_list|,
operator|&
name|time
argument_list|)
condition|)
name|arena_decay_epoch_advance
argument_list|(
name|arena
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
name|ndirty_limit
operator|=
name|arena_decay_npages_limit
argument_list|(
name|arena
argument_list|)
expr_stmt|;
comment|/* 	 * Don't try to purge unless the number of purgeable pages exceeds the 	 * current limit. 	 */
if|if
condition|(
name|arena
operator|->
name|ndirty
operator|<=
name|ndirty_limit
condition|)
return|return;
name|arena_purge_to_limit
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|ndirty_limit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_maybe_purge
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
comment|/* Don't recursively purge. */
if|if
condition|(
name|arena
operator|->
name|purging
condition|)
return|return;
if|if
condition|(
name|opt_purge
operator|==
name|purge_mode_ratio
condition|)
name|arena_maybe_purge_ratio
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|)
expr_stmt|;
else|else
name|arena_maybe_purge_decay
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|arena_dirty_count
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|size_t
name|ndirty
init|=
literal|0
decl_stmt|;
name|arena_runs_dirty_link_t
modifier|*
name|rdelm
decl_stmt|;
name|extent_node_t
modifier|*
name|chunkselm
decl_stmt|;
for|for
control|(
name|rdelm
operator|=
name|qr_next
argument_list|(
operator|&
name|arena
operator|->
name|runs_dirty
argument_list|,
name|rd_link
argument_list|)
operator|,
name|chunkselm
operator|=
name|qr_next
argument_list|(
operator|&
name|arena
operator|->
name|chunks_cache
argument_list|,
name|cc_link
argument_list|)
init|;
name|rdelm
operator|!=
operator|&
name|arena
operator|->
name|runs_dirty
condition|;
name|rdelm
operator|=
name|qr_next
argument_list|(
name|rdelm
argument_list|,
name|rd_link
argument_list|)
control|)
block|{
name|size_t
name|npages
decl_stmt|;
if|if
condition|(
name|rdelm
operator|==
operator|&
name|chunkselm
operator|->
name|rd
condition|)
block|{
name|npages
operator|=
name|extent_node_size_get
argument_list|(
name|chunkselm
argument_list|)
operator|>>
name|LG_PAGE
expr_stmt|;
name|chunkselm
operator|=
name|qr_next
argument_list|(
name|chunkselm
argument_list|,
name|cc_link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arena_chunk_t
modifier|*
name|chunk
init|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|rdelm
argument_list|)
decl_stmt|;
name|arena_chunk_map_misc_t
modifier|*
name|miscelm
init|=
name|arena_rd_to_miscelm
argument_list|(
name|rdelm
argument_list|)
decl_stmt|;
name|size_t
name|pageind
init|=
name|arena_miscelm_to_pageind
argument_list|(
name|miscelm
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|arena_mapbits_allocated_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_large_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|npages
operator|=
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|>>
name|LG_PAGE
expr_stmt|;
block|}
name|ndirty
operator|+=
name|npages
expr_stmt|;
block|}
return|return
operator|(
name|ndirty
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|arena_stash_dirty
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|chunk_hooks_t
modifier|*
name|chunk_hooks
parameter_list|,
name|size_t
name|ndirty_limit
parameter_list|,
name|arena_runs_dirty_link_t
modifier|*
name|purge_runs_sentinel
parameter_list|,
name|extent_node_t
modifier|*
name|purge_chunks_sentinel
parameter_list|)
block|{
name|arena_runs_dirty_link_t
modifier|*
name|rdelm
decl_stmt|,
modifier|*
name|rdelm_next
decl_stmt|;
name|extent_node_t
modifier|*
name|chunkselm
decl_stmt|;
name|size_t
name|nstashed
init|=
literal|0
decl_stmt|;
comment|/* Stash runs/chunks according to ndirty_limit. */
for|for
control|(
name|rdelm
operator|=
name|qr_next
argument_list|(
operator|&
name|arena
operator|->
name|runs_dirty
argument_list|,
name|rd_link
argument_list|)
operator|,
name|chunkselm
operator|=
name|qr_next
argument_list|(
operator|&
name|arena
operator|->
name|chunks_cache
argument_list|,
name|cc_link
argument_list|)
init|;
name|rdelm
operator|!=
operator|&
name|arena
operator|->
name|runs_dirty
condition|;
name|rdelm
operator|=
name|rdelm_next
control|)
block|{
name|size_t
name|npages
decl_stmt|;
name|rdelm_next
operator|=
name|qr_next
argument_list|(
name|rdelm
argument_list|,
name|rd_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdelm
operator|==
operator|&
name|chunkselm
operator|->
name|rd
condition|)
block|{
name|extent_node_t
modifier|*
name|chunkselm_next
decl_stmt|;
name|bool
name|zero
decl_stmt|;
name|UNUSED
name|void
modifier|*
name|chunk
decl_stmt|;
name|npages
operator|=
name|extent_node_size_get
argument_list|(
name|chunkselm
argument_list|)
operator|>>
name|LG_PAGE
expr_stmt|;
if|if
condition|(
name|opt_purge
operator|==
name|purge_mode_decay
operator|&&
name|arena
operator|->
name|ndirty
operator|-
operator|(
name|nstashed
operator|+
name|npages
operator|)
operator|<
name|ndirty_limit
condition|)
break|break;
name|chunkselm_next
operator|=
name|qr_next
argument_list|(
name|chunkselm
argument_list|,
name|cc_link
argument_list|)
expr_stmt|;
comment|/* 			 * Allocate.  chunkselm remains valid due to the 			 * dalloc_node=false argument to chunk_alloc_cache(). 			 */
name|zero
operator|=
name|false
expr_stmt|;
name|chunk
operator|=
name|chunk_alloc_cache
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|chunk_hooks
argument_list|,
name|extent_node_addr_get
argument_list|(
name|chunkselm
argument_list|)
argument_list|,
name|extent_node_size_get
argument_list|(
name|chunkselm
argument_list|)
argument_list|,
name|chunksize
argument_list|,
operator|&
name|zero
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|chunk
operator|==
name|extent_node_addr_get
argument_list|(
name|chunkselm
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|zero
operator|==
name|extent_node_zeroed_get
argument_list|(
name|chunkselm
argument_list|)
argument_list|)
expr_stmt|;
name|extent_node_dirty_insert
argument_list|(
name|chunkselm
argument_list|,
name|purge_runs_sentinel
argument_list|,
name|purge_chunks_sentinel
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|npages
operator|==
operator|(
name|extent_node_size_get
argument_list|(
name|chunkselm
argument_list|)
operator|>>
name|LG_PAGE
operator|)
argument_list|)
expr_stmt|;
name|chunkselm
operator|=
name|chunkselm_next
expr_stmt|;
block|}
else|else
block|{
name|arena_chunk_t
modifier|*
name|chunk
init|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|rdelm
argument_list|)
decl_stmt|;
name|arena_chunk_map_misc_t
modifier|*
name|miscelm
init|=
name|arena_rd_to_miscelm
argument_list|(
name|rdelm
argument_list|)
decl_stmt|;
name|size_t
name|pageind
init|=
name|arena_miscelm_to_pageind
argument_list|(
name|miscelm
argument_list|)
decl_stmt|;
name|arena_run_t
modifier|*
name|run
init|=
operator|&
name|miscelm
operator|->
name|run
decl_stmt|;
name|size_t
name|run_size
init|=
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
decl_stmt|;
name|npages
operator|=
name|run_size
operator|>>
name|LG_PAGE
expr_stmt|;
if|if
condition|(
name|opt_purge
operator|==
name|purge_mode_decay
operator|&&
name|arena
operator|->
name|ndirty
operator|-
operator|(
name|nstashed
operator|+
name|npages
operator|)
operator|<
name|ndirty_limit
condition|)
break|break;
name|assert
argument_list|(
name|pageind
operator|+
name|npages
operator|<=
name|chunk_npages
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|==
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|npages
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * If purging the spare chunk's run, make it available 			 * prior to allocation. 			 */
if|if
condition|(
name|chunk
operator|==
name|arena
operator|->
name|spare
condition|)
name|arena_chunk_alloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|)
expr_stmt|;
comment|/* Temporarily allocate the free dirty run. */
name|arena_run_split_large
argument_list|(
name|arena
argument_list|,
name|run
argument_list|,
name|run_size
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Stash. */
if|if
condition|(
name|false
condition|)
name|qr_new
argument_list|(
name|rdelm
argument_list|,
name|rd_link
argument_list|)
expr_stmt|;
comment|/* Redundant. */
else|else
block|{
name|assert
argument_list|(
name|qr_next
argument_list|(
name|rdelm
argument_list|,
name|rd_link
argument_list|)
operator|==
name|rdelm
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|qr_prev
argument_list|(
name|rdelm
argument_list|,
name|rd_link
argument_list|)
operator|==
name|rdelm
argument_list|)
expr_stmt|;
block|}
name|qr_meld
argument_list|(
name|purge_runs_sentinel
argument_list|,
name|rdelm
argument_list|,
name|rd_link
argument_list|)
expr_stmt|;
block|}
name|nstashed
operator|+=
name|npages
expr_stmt|;
if|if
condition|(
name|opt_purge
operator|==
name|purge_mode_ratio
operator|&&
name|arena
operator|->
name|ndirty
operator|-
name|nstashed
operator|<=
name|ndirty_limit
condition|)
break|break;
block|}
return|return
operator|(
name|nstashed
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|arena_purge_stashed
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|chunk_hooks_t
modifier|*
name|chunk_hooks
parameter_list|,
name|arena_runs_dirty_link_t
modifier|*
name|purge_runs_sentinel
parameter_list|,
name|extent_node_t
modifier|*
name|purge_chunks_sentinel
parameter_list|)
block|{
name|size_t
name|npurged
decl_stmt|,
name|nmadvise
decl_stmt|;
name|arena_runs_dirty_link_t
modifier|*
name|rdelm
decl_stmt|;
name|extent_node_t
modifier|*
name|chunkselm
decl_stmt|;
if|if
condition|(
name|config_stats
condition|)
name|nmadvise
operator|=
literal|0
expr_stmt|;
name|npurged
operator|=
literal|0
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|rdelm
operator|=
name|qr_next
argument_list|(
name|purge_runs_sentinel
argument_list|,
name|rd_link
argument_list|)
operator|,
name|chunkselm
operator|=
name|qr_next
argument_list|(
name|purge_chunks_sentinel
argument_list|,
name|cc_link
argument_list|)
init|;
name|rdelm
operator|!=
name|purge_runs_sentinel
condition|;
name|rdelm
operator|=
name|qr_next
argument_list|(
name|rdelm
argument_list|,
name|rd_link
argument_list|)
control|)
block|{
name|size_t
name|npages
decl_stmt|;
if|if
condition|(
name|rdelm
operator|==
operator|&
name|chunkselm
operator|->
name|rd
condition|)
block|{
comment|/* 			 * Don't actually purge the chunk here because 1) 			 * chunkselm is embedded in the chunk and must remain 			 * valid, and 2) we deallocate the chunk in 			 * arena_unstash_purged(), where it is destroyed, 			 * decommitted, or purged, depending on chunk 			 * deallocation policy. 			 */
name|size_t
name|size
init|=
name|extent_node_size_get
argument_list|(
name|chunkselm
argument_list|)
decl_stmt|;
name|npages
operator|=
name|size
operator|>>
name|LG_PAGE
expr_stmt|;
name|chunkselm
operator|=
name|qr_next
argument_list|(
name|chunkselm
argument_list|,
name|cc_link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|pageind
decl_stmt|,
name|run_size
decl_stmt|,
name|flag_unzeroed
decl_stmt|,
name|flags
decl_stmt|,
name|i
decl_stmt|;
name|bool
name|decommitted
decl_stmt|;
name|arena_chunk_t
modifier|*
name|chunk
init|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|rdelm
argument_list|)
decl_stmt|;
name|arena_chunk_map_misc_t
modifier|*
name|miscelm
init|=
name|arena_rd_to_miscelm
argument_list|(
name|rdelm
argument_list|)
decl_stmt|;
name|pageind
operator|=
name|arena_miscelm_to_pageind
argument_list|(
name|miscelm
argument_list|)
expr_stmt|;
name|run_size
operator|=
name|arena_mapbits_large_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
expr_stmt|;
name|npages
operator|=
name|run_size
operator|>>
name|LG_PAGE
expr_stmt|;
name|assert
argument_list|(
name|pageind
operator|+
name|npages
operator|<=
name|chunk_npages
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|arena_mapbits_decommitted_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|arena_mapbits_decommitted_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|npages
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|decommitted
operator|=
operator|!
name|chunk_hooks
operator|->
name|decommit
argument_list|(
name|chunk
argument_list|,
name|chunksize
argument_list|,
name|pageind
operator|<<
name|LG_PAGE
argument_list|,
name|npages
operator|<<
name|LG_PAGE
argument_list|,
name|arena
operator|->
name|ind
argument_list|)
expr_stmt|;
if|if
condition|(
name|decommitted
condition|)
block|{
name|flag_unzeroed
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
name|CHUNK_MAP_DECOMMITTED
expr_stmt|;
block|}
else|else
block|{
name|flag_unzeroed
operator|=
name|chunk_purge_wrapper
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|chunk_hooks
argument_list|,
name|chunk
argument_list|,
name|chunksize
argument_list|,
name|pageind
operator|<<
name|LG_PAGE
argument_list|,
name|run_size
argument_list|)
condition|?
name|CHUNK_MAP_UNZEROED
else|:
literal|0
expr_stmt|;
name|flags
operator|=
name|flag_unzeroed
expr_stmt|;
block|}
name|arena_mapbits_large_set
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|npages
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|arena_mapbits_large_set
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|,
name|run_size
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 			 * Set the unzeroed flag for internal pages, now that 			 * chunk_purge_wrapper() has returned whether the pages 			 * were zeroed as a side effect of purging.  This chunk 			 * map modification is safe even though the arena mutex 			 * isn't currently owned by this thread, because the run 			 * is marked as allocated, thus protecting it from being 			 * modified by any other thread.  As long as these 			 * writes don't perturb the first and last elements' 			 * CHUNK_MAP_ALLOCATED bits, behavior is well defined. 			 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npages
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|arena_mapbits_internal_set
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|i
argument_list|,
name|flag_unzeroed
argument_list|)
expr_stmt|;
block|}
block|}
name|npurged
operator|+=
name|npages
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
name|nmadvise
operator|++
expr_stmt|;
block|}
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|arena
operator|->
name|stats
operator|.
name|nmadvise
operator|+=
name|nmadvise
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|purged
operator|+=
name|npurged
expr_stmt|;
block|}
return|return
operator|(
name|npurged
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_unstash_purged
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|chunk_hooks_t
modifier|*
name|chunk_hooks
parameter_list|,
name|arena_runs_dirty_link_t
modifier|*
name|purge_runs_sentinel
parameter_list|,
name|extent_node_t
modifier|*
name|purge_chunks_sentinel
parameter_list|)
block|{
name|arena_runs_dirty_link_t
modifier|*
name|rdelm
decl_stmt|,
modifier|*
name|rdelm_next
decl_stmt|;
name|extent_node_t
modifier|*
name|chunkselm
decl_stmt|;
comment|/* Deallocate chunks/runs. */
for|for
control|(
name|rdelm
operator|=
name|qr_next
argument_list|(
name|purge_runs_sentinel
argument_list|,
name|rd_link
argument_list|)
operator|,
name|chunkselm
operator|=
name|qr_next
argument_list|(
name|purge_chunks_sentinel
argument_list|,
name|cc_link
argument_list|)
init|;
name|rdelm
operator|!=
name|purge_runs_sentinel
condition|;
name|rdelm
operator|=
name|rdelm_next
control|)
block|{
name|rdelm_next
operator|=
name|qr_next
argument_list|(
name|rdelm
argument_list|,
name|rd_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdelm
operator|==
operator|&
name|chunkselm
operator|->
name|rd
condition|)
block|{
name|extent_node_t
modifier|*
name|chunkselm_next
init|=
name|qr_next
argument_list|(
name|chunkselm
argument_list|,
name|cc_link
argument_list|)
decl_stmt|;
name|void
modifier|*
name|addr
init|=
name|extent_node_addr_get
argument_list|(
name|chunkselm
argument_list|)
decl_stmt|;
name|size_t
name|size
init|=
name|extent_node_size_get
argument_list|(
name|chunkselm
argument_list|)
decl_stmt|;
name|bool
name|zeroed
init|=
name|extent_node_zeroed_get
argument_list|(
name|chunkselm
argument_list|)
decl_stmt|;
name|bool
name|committed
init|=
name|extent_node_committed_get
argument_list|(
name|chunkselm
argument_list|)
decl_stmt|;
name|extent_node_dirty_remove
argument_list|(
name|chunkselm
argument_list|)
expr_stmt|;
name|arena_node_dalloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|chunkselm
argument_list|)
expr_stmt|;
name|chunkselm
operator|=
name|chunkselm_next
expr_stmt|;
name|chunk_dalloc_wrapper
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|chunk_hooks
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|zeroed
argument_list|,
name|committed
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arena_chunk_t
modifier|*
name|chunk
init|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|rdelm
argument_list|)
decl_stmt|;
name|arena_chunk_map_misc_t
modifier|*
name|miscelm
init|=
name|arena_rd_to_miscelm
argument_list|(
name|rdelm
argument_list|)
decl_stmt|;
name|size_t
name|pageind
init|=
name|arena_miscelm_to_pageind
argument_list|(
name|miscelm
argument_list|)
decl_stmt|;
name|bool
name|decommitted
init|=
operator|(
name|arena_mapbits_decommitted_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|!=
literal|0
operator|)
decl_stmt|;
name|arena_run_t
modifier|*
name|run
init|=
operator|&
name|miscelm
operator|->
name|run
decl_stmt|;
name|qr_remove
argument_list|(
name|rdelm
argument_list|,
name|rd_link
argument_list|)
expr_stmt|;
name|arena_run_dalloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|run
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
name|decommitted
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * NB: ndirty_limit is interpreted differently depending on opt_purge:  *   - purge_mode_ratio: Purge as few dirty run/chunks as possible to reach the  *                       desired state:  *                       (arena->ndirty<= ndirty_limit)  *   - purge_mode_decay: Purge as many dirty runs/chunks as possible without  *                       violating the invariant:  *                       (arena->ndirty>= ndirty_limit)  */
end_comment

begin_function
specifier|static
name|void
name|arena_purge_to_limit
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|ndirty_limit
parameter_list|)
block|{
name|chunk_hooks_t
name|chunk_hooks
init|=
name|chunk_hooks_get
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|)
decl_stmt|;
name|size_t
name|npurge
decl_stmt|,
name|npurged
decl_stmt|;
name|arena_runs_dirty_link_t
name|purge_runs_sentinel
decl_stmt|;
name|extent_node_t
name|purge_chunks_sentinel
decl_stmt|;
name|arena
operator|->
name|purging
operator|=
name|true
expr_stmt|;
comment|/* 	 * Calls to arena_dirty_count() are disabled even for debug builds 	 * because overhead grows nonlinearly as memory usage increases. 	 */
if|if
condition|(
name|false
operator|&&
name|config_debug
condition|)
block|{
name|size_t
name|ndirty
init|=
name|arena_dirty_count
argument_list|(
name|arena
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|ndirty
operator|==
name|arena
operator|->
name|ndirty
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|opt_purge
operator|!=
name|purge_mode_ratio
operator|||
operator|(
name|arena
operator|->
name|nactive
operator|>>
name|arena
operator|->
name|lg_dirty_mult
operator|)
operator|<
name|arena
operator|->
name|ndirty
operator|||
name|ndirty_limit
operator|==
literal|0
argument_list|)
expr_stmt|;
name|qr_new
argument_list|(
operator|&
name|purge_runs_sentinel
argument_list|,
name|rd_link
argument_list|)
expr_stmt|;
name|extent_node_dirty_linkage_init
argument_list|(
operator|&
name|purge_chunks_sentinel
argument_list|)
expr_stmt|;
name|npurge
operator|=
name|arena_stash_dirty
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|chunk_hooks
argument_list|,
name|ndirty_limit
argument_list|,
operator|&
name|purge_runs_sentinel
argument_list|,
operator|&
name|purge_chunks_sentinel
argument_list|)
expr_stmt|;
if|if
condition|(
name|npurge
operator|==
literal|0
condition|)
goto|goto
name|label_return
goto|;
name|npurged
operator|=
name|arena_purge_stashed
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|chunk_hooks
argument_list|,
operator|&
name|purge_runs_sentinel
argument_list|,
operator|&
name|purge_chunks_sentinel
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|npurged
operator|==
name|npurge
argument_list|)
expr_stmt|;
name|arena_unstash_purged
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|chunk_hooks
argument_list|,
operator|&
name|purge_runs_sentinel
argument_list|,
operator|&
name|purge_chunks_sentinel
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
name|arena
operator|->
name|stats
operator|.
name|npurge
operator|++
expr_stmt|;
name|label_return
label|:
name|arena
operator|->
name|purging
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_purge
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|bool
name|all
parameter_list|)
block|{
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|all
condition|)
name|arena_purge_to_limit
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|arena_maybe_purge
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_achunk_prof_reset
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|)
block|{
name|size_t
name|pageind
decl_stmt|,
name|npages
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|opt_prof
argument_list|)
expr_stmt|;
comment|/* 	 * Iterate over the allocated runs and remove profiled allocations from 	 * the sample set. 	 */
for|for
control|(
name|pageind
operator|=
name|map_bias
init|;
name|pageind
operator|<
name|chunk_npages
condition|;
name|pageind
operator|+=
name|npages
control|)
block|{
if|if
condition|(
name|arena_mapbits_allocated_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|arena_mapbits_large_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|void
modifier|*
name|ptr
init|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
operator|(
name|pageind
operator|<<
name|LG_PAGE
operator|)
operator|)
decl_stmt|;
name|size_t
name|usize
init|=
name|isalloc
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|config_prof
argument_list|)
decl_stmt|;
name|prof_free
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|)
expr_stmt|;
name|npages
operator|=
name|arena_mapbits_large_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|>>
name|LG_PAGE
expr_stmt|;
block|}
else|else
block|{
comment|/* Skip small run. */
name|size_t
name|binind
init|=
name|arena_mapbits_binind_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
decl_stmt|;
name|arena_bin_info_t
modifier|*
name|bin_info
init|=
operator|&
name|arena_bin_info
index|[
name|binind
index|]
decl_stmt|;
name|npages
operator|=
name|bin_info
operator|->
name|run_size
operator|>>
name|LG_PAGE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Skip unallocated run. */
name|npages
operator|=
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|>>
name|LG_PAGE
expr_stmt|;
block|}
name|assert
argument_list|(
name|pageind
operator|+
name|npages
operator|<=
name|chunk_npages
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|arena_reset
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|extent_node_t
modifier|*
name|node
decl_stmt|;
comment|/* 	 * Locking in this function is unintuitive.  The caller guarantees that 	 * no concurrent operations are happening in this arena, but there are 	 * still reasons that some locking is necessary: 	 * 	 * - Some of the functions in the transitive closure of calls assume 	 *   appropriate locks are held, and in some cases these locks are 	 *   temporarily dropped to avoid lock order reversal or deadlock due to 	 *   reentry. 	 * - mallctl("epoch", ...) may concurrently refresh stats.  While 	 *   strictly speaking this is a "concurrent operation", disallowing 	 *   stats refreshes would impose an inconvenient burden. 	 */
comment|/* Remove large allocations from prof sample set. */
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
block|{
name|ql_foreach
argument_list|(
argument|node
argument_list|,
argument|&arena->achunks
argument_list|,
argument|ql_link
argument_list|)
block|{
name|arena_achunk_prof_reset
argument_list|(
name|tsd
argument_list|,
name|arena
argument_list|,
name|extent_node_addr_get
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Reset curruns for large size classes. */
if|if
condition|(
name|config_stats
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlclasses
condition|;
name|i
operator|++
control|)
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|i
index|]
operator|.
name|curruns
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Huge allocations. */
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|arena
operator|->
name|huge_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|ql_last
argument_list|(
operator|&
name|arena
operator|->
name|huge
argument_list|,
name|ql_link
argument_list|)
init|;
name|node
operator|!=
name|NULL
condition|;
name|node
operator|=
name|ql_last
argument_list|(
operator|&
name|arena
operator|->
name|huge
argument_list|,
name|ql_link
argument_list|)
control|)
block|{
name|void
modifier|*
name|ptr
init|=
name|extent_node_addr_get
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|size_t
name|usize
decl_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|arena
operator|->
name|huge_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
operator|||
operator|(
name|config_prof
operator|&&
name|opt_prof
operator|)
condition|)
name|usize
operator|=
name|isalloc
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
comment|/* Remove huge allocation from prof sample set. */
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
name|prof_free
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|)
expr_stmt|;
name|huge_dalloc
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|arena
operator|->
name|huge_mtx
argument_list|)
expr_stmt|;
comment|/* Cancel out unwanted effects on stats. */
if|if
condition|(
name|config_stats
condition|)
name|arena_huge_reset_stats_cancel
argument_list|(
name|arena
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|arena
operator|->
name|huge_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* Bins. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
name|arena_bin_t
modifier|*
name|bin
init|=
operator|&
name|arena
operator|->
name|bins
index|[
name|i
index|]
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
name|bin
operator|->
name|runcur
operator|=
name|NULL
expr_stmt|;
name|arena_run_heap_new
argument_list|(
operator|&
name|bin
operator|->
name|runs
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|bin
operator|->
name|stats
operator|.
name|curregs
operator|=
literal|0
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|curruns
operator|=
literal|0
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Re-initialize runs_dirty such that the chunks_cache and runs_dirty 	 * chains directly correspond. 	 */
name|qr_new
argument_list|(
operator|&
name|arena
operator|->
name|runs_dirty
argument_list|,
name|rd_link
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|qr_next
argument_list|(
operator|&
name|arena
operator|->
name|chunks_cache
argument_list|,
name|cc_link
argument_list|)
init|;
name|node
operator|!=
operator|&
name|arena
operator|->
name|chunks_cache
condition|;
name|node
operator|=
name|qr_next
argument_list|(
name|node
argument_list|,
name|cc_link
argument_list|)
control|)
block|{
name|qr_new
argument_list|(
operator|&
name|node
operator|->
name|rd
argument_list|,
name|rd_link
argument_list|)
expr_stmt|;
name|qr_meld
argument_list|(
operator|&
name|arena
operator|->
name|runs_dirty
argument_list|,
operator|&
name|node
operator|->
name|rd
argument_list|,
name|rd_link
argument_list|)
expr_stmt|;
block|}
comment|/* Arena chunks. */
for|for
control|(
name|node
operator|=
name|ql_last
argument_list|(
operator|&
name|arena
operator|->
name|achunks
argument_list|,
name|ql_link
argument_list|)
init|;
name|node
operator|!=
name|NULL
condition|;
name|node
operator|=
name|ql_last
argument_list|(
operator|&
name|arena
operator|->
name|achunks
argument_list|,
name|ql_link
argument_list|)
control|)
block|{
name|ql_remove
argument_list|(
operator|&
name|arena
operator|->
name|achunks
argument_list|,
name|node
argument_list|,
name|ql_link
argument_list|)
expr_stmt|;
name|arena_chunk_discard
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|arena
argument_list|,
name|extent_node_addr_get
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Spare. */
if|if
condition|(
name|arena
operator|->
name|spare
operator|!=
name|NULL
condition|)
block|{
name|arena_chunk_discard
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|arena
argument_list|,
name|arena
operator|->
name|spare
argument_list|)
expr_stmt|;
name|arena
operator|->
name|spare
operator|=
name|NULL
expr_stmt|;
block|}
name|assert
argument_list|(
operator|!
name|arena
operator|->
name|purging
argument_list|)
expr_stmt|;
name|arena
operator|->
name|nactive
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|runs_avail_nclasses
condition|;
name|i
operator|++
control|)
name|arena_run_heap_new
argument_list|(
operator|&
name|arena
operator|->
name|runs_avail
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_run_coalesce
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|size_t
modifier|*
name|p_size
parameter_list|,
name|size_t
modifier|*
name|p_run_ind
parameter_list|,
name|size_t
modifier|*
name|p_run_pages
parameter_list|,
name|size_t
name|flag_dirty
parameter_list|,
name|size_t
name|flag_decommitted
parameter_list|)
block|{
name|size_t
name|size
init|=
operator|*
name|p_size
decl_stmt|;
name|size_t
name|run_ind
init|=
operator|*
name|p_run_ind
decl_stmt|;
name|size_t
name|run_pages
init|=
operator|*
name|p_run_pages
decl_stmt|;
comment|/* Try to coalesce forward. */
if|if
condition|(
name|run_ind
operator|+
name|run_pages
operator|<
name|chunk_npages
operator|&&
name|arena_mapbits_allocated_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
argument_list|)
operator|==
literal|0
operator|&&
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
argument_list|)
operator|==
name|flag_dirty
operator|&&
name|arena_mapbits_decommitted_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
argument_list|)
operator|==
name|flag_decommitted
condition|)
block|{
name|size_t
name|nrun_size
init|=
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
argument_list|)
decl_stmt|;
name|size_t
name|nrun_pages
init|=
name|nrun_size
operator|>>
name|LG_PAGE
decl_stmt|;
comment|/* 		 * Remove successor from runs_avail; the coalesced run is 		 * inserted later. 		 */
name|assert
argument_list|(
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
operator|+
name|nrun_pages
operator|-
literal|1
argument_list|)
operator|==
name|nrun_size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
operator|+
name|nrun_pages
operator|-
literal|1
argument_list|)
operator|==
name|flag_dirty
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_decommitted_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
operator|+
name|nrun_pages
operator|-
literal|1
argument_list|)
operator|==
name|flag_decommitted
argument_list|)
expr_stmt|;
name|arena_avail_remove
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
argument_list|,
name|nrun_pages
argument_list|)
expr_stmt|;
comment|/* 		 * If the successor is dirty, remove it from the set of dirty 		 * pages. 		 */
if|if
condition|(
name|flag_dirty
operator|!=
literal|0
condition|)
block|{
name|arena_run_dirty_remove
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
argument_list|,
name|nrun_pages
argument_list|)
expr_stmt|;
block|}
name|size
operator|+=
name|nrun_size
expr_stmt|;
name|run_pages
operator|+=
name|nrun_pages
expr_stmt|;
name|arena_mapbits_unallocated_size_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|arena_mapbits_unallocated_size_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* Try to coalesce backward. */
if|if
condition|(
name|run_ind
operator|>
name|map_bias
operator|&&
name|arena_mapbits_allocated_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|-
literal|1
argument_list|)
operator|==
name|flag_dirty
operator|&&
name|arena_mapbits_decommitted_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|-
literal|1
argument_list|)
operator|==
name|flag_decommitted
condition|)
block|{
name|size_t
name|prun_size
init|=
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|-
literal|1
argument_list|)
decl_stmt|;
name|size_t
name|prun_pages
init|=
name|prun_size
operator|>>
name|LG_PAGE
decl_stmt|;
name|run_ind
operator|-=
name|prun_pages
expr_stmt|;
comment|/* 		 * Remove predecessor from runs_avail; the coalesced run is 		 * inserted later. 		 */
name|assert
argument_list|(
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
operator|==
name|prun_size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
operator|==
name|flag_dirty
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_decommitted_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
operator|==
name|flag_decommitted
argument_list|)
expr_stmt|;
name|arena_avail_remove
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|run_ind
argument_list|,
name|prun_pages
argument_list|)
expr_stmt|;
comment|/* 		 * If the predecessor is dirty, remove it from the set of dirty 		 * pages. 		 */
if|if
condition|(
name|flag_dirty
operator|!=
literal|0
condition|)
block|{
name|arena_run_dirty_remove
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|run_ind
argument_list|,
name|prun_pages
argument_list|)
expr_stmt|;
block|}
name|size
operator|+=
name|prun_size
expr_stmt|;
name|run_pages
operator|+=
name|prun_pages
expr_stmt|;
name|arena_mapbits_unallocated_size_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|arena_mapbits_unallocated_size_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
operator|*
name|p_size
operator|=
name|size
expr_stmt|;
operator|*
name|p_run_ind
operator|=
name|run_ind
expr_stmt|;
operator|*
name|p_run_pages
operator|=
name|run_pages
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|arena_run_size_get
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|size_t
name|run_ind
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|assert
argument_list|(
name|run_ind
operator|>=
name|map_bias
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|run_ind
operator|<
name|chunk_npages
argument_list|)
expr_stmt|;
if|if
condition|(
name|arena_mapbits_large_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|size
operator|=
name|arena_mapbits_large_size_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|==
name|PAGE
operator|||
name|arena_mapbits_large_size_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
operator|(
name|size
operator|>>
name|LG_PAGE
operator|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arena_bin_info_t
modifier|*
name|bin_info
init|=
operator|&
name|arena_bin_info
index|[
name|run
operator|->
name|binind
index|]
decl_stmt|;
name|size
operator|=
name|bin_info
operator|->
name|run_size
expr_stmt|;
block|}
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_run_dalloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|bool
name|dirty
parameter_list|,
name|bool
name|cleaned
parameter_list|,
name|bool
name|decommitted
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|arena_chunk_map_misc_t
modifier|*
name|miscelm
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|run_ind
decl_stmt|,
name|run_pages
decl_stmt|,
name|flag_dirty
decl_stmt|,
name|flag_decommitted
decl_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|run
argument_list|)
expr_stmt|;
name|miscelm
operator|=
name|arena_run_to_miscelm
argument_list|(
name|run
argument_list|)
expr_stmt|;
name|run_ind
operator|=
name|arena_miscelm_to_pageind
argument_list|(
name|miscelm
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|run_ind
operator|>=
name|map_bias
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|run_ind
operator|<
name|chunk_npages
argument_list|)
expr_stmt|;
name|size
operator|=
name|arena_run_size_get
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|run
argument_list|,
name|run_ind
argument_list|)
expr_stmt|;
name|run_pages
operator|=
operator|(
name|size
operator|>>
name|LG_PAGE
operator|)
expr_stmt|;
name|arena_nactive_sub
argument_list|(
name|arena
argument_list|,
name|run_pages
argument_list|)
expr_stmt|;
comment|/* 	 * The run is dirty if the caller claims to have dirtied it, as well as 	 * if it was already dirty before being allocated and the caller 	 * doesn't claim to have cleaned it. 	 */
name|assert
argument_list|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
operator|==
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cleaned
operator|&&
operator|!
name|decommitted
operator|&&
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
operator|!=
literal|0
condition|)
name|dirty
operator|=
name|true
expr_stmt|;
name|flag_dirty
operator|=
name|dirty
condition|?
name|CHUNK_MAP_DIRTY
else|:
literal|0
expr_stmt|;
name|flag_decommitted
operator|=
name|decommitted
condition|?
name|CHUNK_MAP_DECOMMITTED
else|:
literal|0
expr_stmt|;
comment|/* Mark pages as unallocated in the chunk map. */
if|if
condition|(
name|dirty
operator|||
name|decommitted
condition|)
block|{
name|size_t
name|flags
init|=
name|flag_dirty
operator||
name|flag_decommitted
decl_stmt|;
name|arena_mapbits_unallocated_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|,
name|size
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|arena_mapbits_unallocated_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
argument_list|,
name|size
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arena_mapbits_unallocated_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|,
name|size
argument_list|,
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
argument_list|)
expr_stmt|;
name|arena_mapbits_unallocated_set
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
argument_list|,
name|size
argument_list|,
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|arena_run_coalesce
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|run_ind
argument_list|,
operator|&
name|run_pages
argument_list|,
name|flag_dirty
argument_list|,
name|flag_decommitted
argument_list|)
expr_stmt|;
comment|/* Insert into runs_avail, now that coalescing is complete. */
name|assert
argument_list|(
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
operator|==
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
operator|==
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_decommitted_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
operator|==
name|arena_mapbits_decommitted_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|arena_avail_insert
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|run_ind
argument_list|,
name|run_pages
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirty
condition|)
name|arena_run_dirty_insert
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|run_ind
argument_list|,
name|run_pages
argument_list|)
expr_stmt|;
comment|/* Deallocate chunk if it is now completely unused. */
if|if
condition|(
name|size
operator|==
name|arena_maxrun
condition|)
block|{
name|assert
argument_list|(
name|run_ind
operator|==
name|map_bias
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|run_pages
operator|==
operator|(
name|arena_maxrun
operator|>>
name|LG_PAGE
operator|)
argument_list|)
expr_stmt|;
name|arena_chunk_dalloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * It is okay to do dirty page processing here even if the chunk was 	 * deallocated above, since in that case it is the spare.  Waiting 	 * until after possible chunk deallocation to do dirty processing 	 * allows for an old spare to be fully deallocated, thus decreasing the 	 * chances of spuriously crossing the dirty page purging threshold. 	 */
if|if
condition|(
name|dirty
condition|)
name|arena_maybe_purge
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_run_trim_head
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|newsize
parameter_list|)
block|{
name|arena_chunk_map_misc_t
modifier|*
name|miscelm
init|=
name|arena_run_to_miscelm
argument_list|(
name|run
argument_list|)
decl_stmt|;
name|size_t
name|pageind
init|=
name|arena_miscelm_to_pageind
argument_list|(
name|miscelm
argument_list|)
decl_stmt|;
name|size_t
name|head_npages
init|=
operator|(
name|oldsize
operator|-
name|newsize
operator|)
operator|>>
name|LG_PAGE
decl_stmt|;
name|size_t
name|flag_dirty
init|=
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
decl_stmt|;
name|size_t
name|flag_decommitted
init|=
name|arena_mapbits_decommitted_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
decl_stmt|;
name|size_t
name|flag_unzeroed_mask
init|=
operator|(
name|flag_dirty
operator||
name|flag_decommitted
operator|)
operator|==
literal|0
condition|?
name|CHUNK_MAP_UNZEROED
else|:
literal|0
decl_stmt|;
name|assert
argument_list|(
name|oldsize
operator|>
name|newsize
argument_list|)
expr_stmt|;
comment|/* 	 * Update the chunk map so that arena_run_dalloc() can treat the 	 * leading run as separately allocated.  Set the last element of each 	 * run first, in case of single-page runs. 	 */
name|assert
argument_list|(
name|arena_mapbits_large_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|==
name|oldsize
argument_list|)
expr_stmt|;
name|arena_mapbits_large_set
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|head_npages
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|flag_dirty
operator||
operator|(
name|flag_unzeroed_mask
operator|&
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|head_npages
operator|-
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|arena_mapbits_large_set
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|,
name|oldsize
operator|-
name|newsize
argument_list|,
name|flag_dirty
operator||
operator|(
name|flag_unzeroed_mask
operator|&
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_debug
condition|)
block|{
name|UNUSED
name|size_t
name|tail_npages
init|=
name|newsize
operator|>>
name|LG_PAGE
decl_stmt|;
name|assert
argument_list|(
name|arena_mapbits_large_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|head_npages
operator|+
name|tail_npages
operator|-
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|head_npages
operator|+
name|tail_npages
operator|-
literal|1
argument_list|)
operator|==
name|flag_dirty
argument_list|)
expr_stmt|;
block|}
name|arena_mapbits_large_set
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|head_npages
argument_list|,
name|newsize
argument_list|,
name|flag_dirty
operator||
operator|(
name|flag_unzeroed_mask
operator|&
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|head_npages
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|arena_run_dalloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|run
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
operator|(
name|flag_decommitted
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_run_trim_tail
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|newsize
parameter_list|,
name|bool
name|dirty
parameter_list|)
block|{
name|arena_chunk_map_misc_t
modifier|*
name|miscelm
init|=
name|arena_run_to_miscelm
argument_list|(
name|run
argument_list|)
decl_stmt|;
name|size_t
name|pageind
init|=
name|arena_miscelm_to_pageind
argument_list|(
name|miscelm
argument_list|)
decl_stmt|;
name|size_t
name|head_npages
init|=
name|newsize
operator|>>
name|LG_PAGE
decl_stmt|;
name|size_t
name|flag_dirty
init|=
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
decl_stmt|;
name|size_t
name|flag_decommitted
init|=
name|arena_mapbits_decommitted_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
decl_stmt|;
name|size_t
name|flag_unzeroed_mask
init|=
operator|(
name|flag_dirty
operator||
name|flag_decommitted
operator|)
operator|==
literal|0
condition|?
name|CHUNK_MAP_UNZEROED
else|:
literal|0
decl_stmt|;
name|arena_chunk_map_misc_t
modifier|*
name|tail_miscelm
decl_stmt|;
name|arena_run_t
modifier|*
name|tail_run
decl_stmt|;
name|assert
argument_list|(
name|oldsize
operator|>
name|newsize
argument_list|)
expr_stmt|;
comment|/* 	 * Update the chunk map so that arena_run_dalloc() can treat the 	 * trailing run as separately allocated.  Set the last element of each 	 * run first, in case of single-page runs. 	 */
name|assert
argument_list|(
name|arena_mapbits_large_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|==
name|oldsize
argument_list|)
expr_stmt|;
name|arena_mapbits_large_set
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|head_npages
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|flag_dirty
operator||
operator|(
name|flag_unzeroed_mask
operator|&
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|head_npages
operator|-
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|arena_mapbits_large_set
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|,
name|newsize
argument_list|,
name|flag_dirty
operator||
operator|(
name|flag_unzeroed_mask
operator|&
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_debug
condition|)
block|{
name|UNUSED
name|size_t
name|tail_npages
init|=
operator|(
name|oldsize
operator|-
name|newsize
operator|)
operator|>>
name|LG_PAGE
decl_stmt|;
name|assert
argument_list|(
name|arena_mapbits_large_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|head_npages
operator|+
name|tail_npages
operator|-
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|head_npages
operator|+
name|tail_npages
operator|-
literal|1
argument_list|)
operator|==
name|flag_dirty
argument_list|)
expr_stmt|;
block|}
name|arena_mapbits_large_set
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|head_npages
argument_list|,
name|oldsize
operator|-
name|newsize
argument_list|,
name|flag_dirty
operator||
operator|(
name|flag_unzeroed_mask
operator|&
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|head_npages
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|tail_miscelm
operator|=
name|arena_miscelm_get_mutable
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|head_npages
argument_list|)
expr_stmt|;
name|tail_run
operator|=
operator|&
name|tail_miscelm
operator|->
name|run
expr_stmt|;
name|arena_run_dalloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|tail_run
argument_list|,
name|dirty
argument_list|,
name|false
argument_list|,
operator|(
name|flag_decommitted
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_bin_runs_insert
parameter_list|(
name|arena_bin_t
modifier|*
name|bin
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|)
block|{
name|arena_chunk_map_misc_t
modifier|*
name|miscelm
init|=
name|arena_run_to_miscelm
argument_list|(
name|run
argument_list|)
decl_stmt|;
name|arena_run_heap_insert
argument_list|(
operator|&
name|bin
operator|->
name|runs
argument_list|,
name|miscelm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|arena_run_t
modifier|*
name|arena_bin_nonfull_run_tryget
parameter_list|(
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
block|{
name|arena_chunk_map_misc_t
modifier|*
name|miscelm
decl_stmt|;
name|miscelm
operator|=
name|arena_run_heap_remove_first
argument_list|(
operator|&
name|bin
operator|->
name|runs
argument_list|)
expr_stmt|;
if|if
condition|(
name|miscelm
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|config_stats
condition|)
name|bin
operator|->
name|stats
operator|.
name|reruns
operator|++
expr_stmt|;
return|return
operator|(
operator|&
name|miscelm
operator|->
name|run
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|arena_run_t
modifier|*
name|arena_bin_nonfull_run_get
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
block|{
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|szind_t
name|binind
decl_stmt|;
name|arena_bin_info_t
modifier|*
name|bin_info
decl_stmt|;
comment|/* Look for a usable run. */
name|run
operator|=
name|arena_bin_nonfull_run_tryget
argument_list|(
name|bin
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
operator|!=
name|NULL
condition|)
return|return
operator|(
name|run
operator|)
return|;
comment|/* No existing runs have any space available. */
name|binind
operator|=
name|arena_bin_index
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|)
expr_stmt|;
name|bin_info
operator|=
operator|&
name|arena_bin_info
index|[
name|binind
index|]
expr_stmt|;
comment|/* Allocate a new run. */
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/******************************/
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|run
operator|=
name|arena_run_alloc_small
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|bin_info
operator|->
name|run_size
argument_list|,
name|binind
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
operator|!=
name|NULL
condition|)
block|{
comment|/* Initialize run internals. */
name|run
operator|->
name|binind
operator|=
name|binind
expr_stmt|;
name|run
operator|->
name|nfree
operator|=
name|bin_info
operator|->
name|nregs
expr_stmt|;
name|bitmap_init
argument_list|(
name|run
operator|->
name|bitmap
argument_list|,
operator|&
name|bin_info
operator|->
name|bitmap_info
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/********************************/
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|config_stats
condition|)
block|{
name|bin
operator|->
name|stats
operator|.
name|nruns
operator|++
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|curruns
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|run
operator|)
return|;
block|}
comment|/* 	 * arena_run_alloc_small() failed, but another thread may have made 	 * sufficient memory available while this one dropped bin->lock above, 	 * so search one more time. 	 */
name|run
operator|=
name|arena_bin_nonfull_run_tryget
argument_list|(
name|bin
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
operator|!=
name|NULL
condition|)
return|return
operator|(
name|run
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Re-fill bin->runcur, then call arena_run_reg_alloc(). */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|arena_bin_malloc_hard
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
block|{
name|szind_t
name|binind
decl_stmt|;
name|arena_bin_info_t
modifier|*
name|bin_info
decl_stmt|;
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|binind
operator|=
name|arena_bin_index
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|)
expr_stmt|;
name|bin_info
operator|=
operator|&
name|arena_bin_info
index|[
name|binind
index|]
expr_stmt|;
name|bin
operator|->
name|runcur
operator|=
name|NULL
expr_stmt|;
name|run
operator|=
name|arena_bin_nonfull_run_get
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|bin
argument_list|)
expr_stmt|;
if|if
condition|(
name|bin
operator|->
name|runcur
operator|!=
name|NULL
operator|&&
name|bin
operator|->
name|runcur
operator|->
name|nfree
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Another thread updated runcur while this one ran without the 		 * bin lock in arena_bin_nonfull_run_get(). 		 */
name|void
modifier|*
name|ret
decl_stmt|;
name|assert
argument_list|(
name|bin
operator|->
name|runcur
operator|->
name|nfree
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|arena_run_reg_alloc
argument_list|(
name|bin
operator|->
name|runcur
argument_list|,
name|bin_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
operator|!=
name|NULL
condition|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
comment|/* 			 * arena_run_alloc_small() may have allocated run, or 			 * it may have pulled run from the bin's run tree. 			 * Therefore it is unsafe to make any assumptions about 			 * how run has previously been used, and 			 * arena_bin_lower_run() must be called, as if a region 			 * were just deallocated from the run. 			 */
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|run
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
operator|->
name|nfree
operator|==
name|bin_info
operator|->
name|nregs
condition|)
block|{
name|arena_dalloc_bin_run
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|chunk
argument_list|,
name|run
argument_list|,
name|bin
argument_list|)
expr_stmt|;
block|}
else|else
name|arena_bin_lower_run
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|run
argument_list|,
name|bin
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
if|if
condition|(
name|run
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bin
operator|->
name|runcur
operator|=
name|run
expr_stmt|;
name|assert
argument_list|(
name|bin
operator|->
name|runcur
operator|->
name|nfree
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|arena_run_reg_alloc
argument_list|(
name|bin
operator|->
name|runcur
argument_list|,
name|bin_info
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|arena_tcache_fill_small
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|tcache_bin_t
modifier|*
name|tbin
parameter_list|,
name|szind_t
name|binind
parameter_list|,
name|uint64_t
name|prof_accumbytes
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|nfill
decl_stmt|;
name|arena_bin_t
modifier|*
name|bin
decl_stmt|;
name|assert
argument_list|(
name|tbin
operator|->
name|ncached
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_prof
operator|&&
name|arena_prof_accum
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|prof_accumbytes
argument_list|)
condition|)
name|prof_idump
argument_list|(
name|tsdn
argument_list|)
expr_stmt|;
name|bin
operator|=
operator|&
name|arena
operator|->
name|bins
index|[
name|binind
index|]
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|nfill
operator|=
operator|(
name|tcache_bin_info
index|[
name|binind
index|]
operator|.
name|ncached_max
operator|>>
name|tbin
operator|->
name|lg_fill_div
operator|)
init|;
name|i
operator|<
name|nfill
condition|;
name|i
operator|++
control|)
block|{
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
name|run
operator|=
name|bin
operator|->
name|runcur
operator|)
operator|!=
name|NULL
operator|&&
name|run
operator|->
name|nfree
operator|>
literal|0
condition|)
name|ptr
operator|=
name|arena_run_reg_alloc
argument_list|(
name|run
argument_list|,
operator|&
name|arena_bin_info
index|[
name|binind
index|]
argument_list|)
expr_stmt|;
else|else
name|ptr
operator|=
name|arena_bin_malloc_hard
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|bin
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * OOM.  tbin->avail isn't yet filled down to its first 			 * element, so the successful allocations (if any) must 			 * be moved just before tbin->avail before bailing out. 			 */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|memmove
argument_list|(
name|tbin
operator|->
name|avail
operator|-
name|i
argument_list|,
name|tbin
operator|->
name|avail
operator|-
name|nfill
argument_list|,
name|i
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|config_fill
operator|&&
name|unlikely
argument_list|(
name|opt_junk_alloc
argument_list|)
condition|)
block|{
name|arena_alloc_junk_small
argument_list|(
name|ptr
argument_list|,
operator|&
name|arena_bin_info
index|[
name|binind
index|]
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
comment|/* Insert such that low regions get used first. */
operator|*
operator|(
name|tbin
operator|->
name|avail
operator|-
name|nfill
operator|+
name|i
operator|)
operator|=
name|ptr
expr_stmt|;
block|}
if|if
condition|(
name|config_stats
condition|)
block|{
name|bin
operator|->
name|stats
operator|.
name|nmalloc
operator|+=
name|i
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|nrequests
operator|+=
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|curregs
operator|+=
name|i
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|nfills
operator|++
expr_stmt|;
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
operator|=
literal|0
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
name|tbin
operator|->
name|ncached
operator|=
name|i
expr_stmt|;
name|arena_decay_tick
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_alloc_junk_small
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|arena_bin_info_t
modifier|*
name|bin_info
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|size_t
name|redzone_size
init|=
name|bin_info
operator|->
name|redzone_size
decl_stmt|;
if|if
condition|(
name|zero
condition|)
block|{
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
name|redzone_size
operator|)
argument_list|,
name|JEMALLOC_ALLOC_JUNK
argument_list|,
name|redzone_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|+
name|bin_info
operator|->
name|reg_size
operator|)
argument_list|,
name|JEMALLOC_ALLOC_JUNK
argument_list|,
name|redzone_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
name|redzone_size
operator|)
argument_list|,
name|JEMALLOC_ALLOC_JUNK
argument_list|,
name|bin_info
operator|->
name|reg_interval
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_JET
end_ifdef

begin_undef
undef|#
directive|undef
name|arena_redzone_corruption
end_undef

begin_define
define|#
directive|define
name|arena_redzone_corruption
value|JEMALLOC_N(n_arena_redzone_corruption)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|arena_redzone_corruption
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|bool
name|after
parameter_list|,
name|size_t
name|offset
parameter_list|,
name|uint8_t
name|byte
parameter_list|)
block|{
name|malloc_printf
argument_list|(
literal|"<jemalloc>: Corrupt redzone %zu byte%s %s %p "
literal|"(size %zu), byte=%#x\n"
argument_list|,
name|offset
argument_list|,
operator|(
name|offset
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|after
condition|?
literal|"after"
else|:
literal|"before"
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_JET
end_ifdef

begin_undef
undef|#
directive|undef
name|arena_redzone_corruption
end_undef

begin_define
define|#
directive|define
name|arena_redzone_corruption
value|JEMALLOC_N(arena_redzone_corruption)
end_define

begin_decl_stmt
name|arena_redzone_corruption_t
modifier|*
name|arena_redzone_corruption
init|=
name|JEMALLOC_N
argument_list|(
name|n_arena_redzone_corruption
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|arena_redzones_validate
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|arena_bin_info_t
modifier|*
name|bin_info
parameter_list|,
name|bool
name|reset
parameter_list|)
block|{
name|bool
name|error
init|=
name|false
decl_stmt|;
if|if
condition|(
name|opt_junk_alloc
condition|)
block|{
name|size_t
name|size
init|=
name|bin_info
operator|->
name|reg_size
decl_stmt|;
name|size_t
name|redzone_size
init|=
name|bin_info
operator|->
name|redzone_size
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|redzone_size
condition|;
name|i
operator|++
control|)
block|{
name|uint8_t
modifier|*
name|byte
init|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
name|i
operator|)
decl_stmt|;
if|if
condition|(
operator|*
name|byte
operator|!=
name|JEMALLOC_ALLOC_JUNK
condition|)
block|{
name|error
operator|=
name|true
expr_stmt|;
name|arena_redzone_corruption
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|false
argument_list|,
name|i
argument_list|,
operator|*
name|byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|reset
condition|)
operator|*
name|byte
operator|=
name|JEMALLOC_ALLOC_JUNK
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|redzone_size
condition|;
name|i
operator|++
control|)
block|{
name|uint8_t
modifier|*
name|byte
init|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|+
name|size
operator|+
name|i
operator|)
decl_stmt|;
if|if
condition|(
operator|*
name|byte
operator|!=
name|JEMALLOC_ALLOC_JUNK
condition|)
block|{
name|error
operator|=
name|true
expr_stmt|;
name|arena_redzone_corruption
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|true
argument_list|,
name|i
argument_list|,
operator|*
name|byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|reset
condition|)
operator|*
name|byte
operator|=
name|JEMALLOC_ALLOC_JUNK
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|opt_abort
operator|&&
name|error
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_JET
end_ifdef

begin_undef
undef|#
directive|undef
name|arena_dalloc_junk_small
end_undef

begin_define
define|#
directive|define
name|arena_dalloc_junk_small
value|JEMALLOC_N(n_arena_dalloc_junk_small)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|arena_dalloc_junk_small
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|arena_bin_info_t
modifier|*
name|bin_info
parameter_list|)
block|{
name|size_t
name|redzone_size
init|=
name|bin_info
operator|->
name|redzone_size
decl_stmt|;
name|arena_redzones_validate
argument_list|(
name|ptr
argument_list|,
name|bin_info
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
name|redzone_size
operator|)
argument_list|,
name|JEMALLOC_FREE_JUNK
argument_list|,
name|bin_info
operator|->
name|reg_interval
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_JET
end_ifdef

begin_undef
undef|#
directive|undef
name|arena_dalloc_junk_small
end_undef

begin_define
define|#
directive|define
name|arena_dalloc_junk_small
value|JEMALLOC_N(arena_dalloc_junk_small)
end_define

begin_decl_stmt
name|arena_dalloc_junk_small_t
modifier|*
name|arena_dalloc_junk_small
init|=
name|JEMALLOC_N
argument_list|(
name|n_arena_dalloc_junk_small
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|arena_quarantine_junk_small
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|usize
parameter_list|)
block|{
name|szind_t
name|binind
decl_stmt|;
name|arena_bin_info_t
modifier|*
name|bin_info
decl_stmt|;
name|cassert
argument_list|(
name|config_fill
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|opt_junk_free
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|opt_quarantine
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|usize
operator|<=
name|SMALL_MAXCLASS
argument_list|)
expr_stmt|;
name|binind
operator|=
name|size2index
argument_list|(
name|usize
argument_list|)
expr_stmt|;
name|bin_info
operator|=
operator|&
name|arena_bin_info
index|[
name|binind
index|]
expr_stmt|;
name|arena_redzones_validate
argument_list|(
name|ptr
argument_list|,
name|bin_info
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|arena_malloc_small
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|szind_t
name|binind
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|arena_bin_t
modifier|*
name|bin
decl_stmt|;
name|size_t
name|usize
decl_stmt|;
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|assert
argument_list|(
name|binind
operator|<
name|NBINS
argument_list|)
expr_stmt|;
name|bin
operator|=
operator|&
name|arena
operator|->
name|bins
index|[
name|binind
index|]
expr_stmt|;
name|usize
operator|=
name|index2size
argument_list|(
name|binind
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|run
operator|=
name|bin
operator|->
name|runcur
operator|)
operator|!=
name|NULL
operator|&&
name|run
operator|->
name|nfree
operator|>
literal|0
condition|)
name|ret
operator|=
name|arena_run_reg_alloc
argument_list|(
name|run
argument_list|,
operator|&
name|arena_bin_info
index|[
name|binind
index|]
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|arena_bin_malloc_hard
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|bin
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|config_stats
condition|)
block|{
name|bin
operator|->
name|stats
operator|.
name|nmalloc
operator|++
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|nrequests
operator|++
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|curregs
operator|++
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_prof
operator|&&
operator|!
name|isthreaded
operator|&&
name|arena_prof_accum
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|usize
argument_list|)
condition|)
name|prof_idump
argument_list|(
name|tsdn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zero
condition|)
block|{
if|if
condition|(
name|config_fill
condition|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|opt_junk_alloc
argument_list|)
condition|)
block|{
name|arena_alloc_junk_small
argument_list|(
name|ret
argument_list|,
operator|&
name|arena_bin_info
index|[
name|binind
index|]
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unlikely
argument_list|(
name|opt_zero
argument_list|)
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
name|JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED
argument_list|(
name|ret
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|config_fill
operator|&&
name|unlikely
argument_list|(
name|opt_junk_alloc
argument_list|)
condition|)
block|{
name|arena_alloc_junk_small
argument_list|(
name|ret
argument_list|,
operator|&
name|arena_bin_info
index|[
name|binind
index|]
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED
argument_list|(
name|ret
argument_list|,
name|usize
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
name|arena_decay_tick
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|arena_malloc_large
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|szind_t
name|binind
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|usize
decl_stmt|;
name|uintptr_t
name|random_offset
decl_stmt|;
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|arena_chunk_map_misc_t
modifier|*
name|miscelm
decl_stmt|;
name|UNUSED
name|bool
name|idump
name|JEMALLOC_CC_SILENCE_INIT
argument_list|(
name|false
argument_list|)
decl_stmt|;
comment|/* Large allocation. */
name|usize
operator|=
name|index2size
argument_list|(
name|binind
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_cache_oblivious
condition|)
block|{
name|uint64_t
name|r
decl_stmt|;
comment|/* 		 * Compute a uniformly distributed offset within the first page 		 * that is a multiple of the cacheline size, e.g. [0 .. 63) * 64 		 * for 4 KiB pages and 64-byte cachelines. 		 */
name|r
operator|=
name|prng_lg_range
argument_list|(
operator|&
name|arena
operator|->
name|offset_state
argument_list|,
name|LG_PAGE
operator|-
name|LG_CACHELINE
argument_list|)
expr_stmt|;
name|random_offset
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|r
operator|)
operator|<<
name|LG_CACHELINE
expr_stmt|;
block|}
else|else
name|random_offset
operator|=
literal|0
expr_stmt|;
name|run
operator|=
name|arena_run_alloc_large
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|usize
operator|+
name|large_pad
argument_list|,
name|zero
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
operator|==
name|NULL
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|miscelm
operator|=
name|arena_run_to_miscelm
argument_list|(
name|run
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|arena_miscelm_to_rpages
argument_list|(
name|miscelm
argument_list|)
operator|+
name|random_offset
operator|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|szind_t
name|index
init|=
name|binind
operator|-
name|NBINS
decl_stmt|;
name|arena
operator|->
name|stats
operator|.
name|nmalloc_large
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|nrequests_large
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|allocated_large
operator|+=
name|usize
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|index
index|]
operator|.
name|nmalloc
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|index
index|]
operator|.
name|nrequests
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|index
index|]
operator|.
name|curruns
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|config_prof
condition|)
name|idump
operator|=
name|arena_prof_accum_locked
argument_list|(
name|arena
argument_list|,
name|usize
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_prof
operator|&&
name|idump
condition|)
name|prof_idump
argument_list|(
name|tsdn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zero
condition|)
block|{
if|if
condition|(
name|config_fill
condition|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|opt_junk_alloc
argument_list|)
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
name|JEMALLOC_ALLOC_JUNK
argument_list|,
name|usize
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|unlikely
argument_list|(
name|opt_zero
argument_list|)
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
block|}
name|arena_decay_tick
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|arena_malloc_hard
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|szind_t
name|ind
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|tsdn_null
argument_list|(
name|tsdn
argument_list|)
operator|||
name|arena
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
operator|!
name|tsdn_null
argument_list|(
name|tsdn
argument_list|)
argument_list|)
condition|)
name|arena
operator|=
name|arena_choose
argument_list|(
name|tsdn_tsd
argument_list|(
name|tsdn
argument_list|)
argument_list|,
name|arena
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|arena
operator|==
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|likely
argument_list|(
name|size
operator|<=
name|SMALL_MAXCLASS
argument_list|)
condition|)
return|return
operator|(
name|arena_malloc_small
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|ind
argument_list|,
name|zero
argument_list|)
operator|)
return|;
if|if
condition|(
name|likely
argument_list|(
name|size
operator|<=
name|large_maxclass
argument_list|)
condition|)
return|return
operator|(
name|arena_malloc_large
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|ind
argument_list|,
name|zero
argument_list|)
operator|)
return|;
return|return
operator|(
name|huge_malloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|index2size
argument_list|(
name|ind
argument_list|)
argument_list|,
name|zero
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Only handles large allocations that require more than page alignment. */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|arena_palloc_large
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|alloc_size
decl_stmt|,
name|leadsize
decl_stmt|,
name|trailsize
decl_stmt|;
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|arena_chunk_map_misc_t
modifier|*
name|miscelm
decl_stmt|;
name|void
modifier|*
name|rpages
decl_stmt|;
name|assert
argument_list|(
operator|!
name|tsdn_null
argument_list|(
name|tsdn
argument_list|)
operator|||
name|arena
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|usize
operator|==
name|PAGE_CEILING
argument_list|(
name|usize
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
operator|!
name|tsdn_null
argument_list|(
name|tsdn
argument_list|)
argument_list|)
condition|)
name|arena
operator|=
name|arena_choose
argument_list|(
name|tsdn_tsd
argument_list|(
name|tsdn
argument_list|)
argument_list|,
name|arena
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|arena
operator|==
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|alignment
operator|=
name|PAGE_CEILING
argument_list|(
name|alignment
argument_list|)
expr_stmt|;
name|alloc_size
operator|=
name|usize
operator|+
name|large_pad
operator|+
name|alignment
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|run
operator|=
name|arena_run_alloc_large
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|alloc_size
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
operator|==
name|NULL
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|run
argument_list|)
expr_stmt|;
name|miscelm
operator|=
name|arena_run_to_miscelm
argument_list|(
name|run
argument_list|)
expr_stmt|;
name|rpages
operator|=
name|arena_miscelm_to_rpages
argument_list|(
name|miscelm
argument_list|)
expr_stmt|;
name|leadsize
operator|=
name|ALIGNMENT_CEILING
argument_list|(
operator|(
name|uintptr_t
operator|)
name|rpages
argument_list|,
name|alignment
argument_list|)
operator|-
operator|(
name|uintptr_t
operator|)
name|rpages
expr_stmt|;
name|assert
argument_list|(
name|alloc_size
operator|>=
name|leadsize
operator|+
name|usize
argument_list|)
expr_stmt|;
name|trailsize
operator|=
name|alloc_size
operator|-
name|leadsize
operator|-
name|usize
operator|-
name|large_pad
expr_stmt|;
if|if
condition|(
name|leadsize
operator|!=
literal|0
condition|)
block|{
name|arena_chunk_map_misc_t
modifier|*
name|head_miscelm
init|=
name|miscelm
decl_stmt|;
name|arena_run_t
modifier|*
name|head_run
init|=
name|run
decl_stmt|;
name|miscelm
operator|=
name|arena_miscelm_get_mutable
argument_list|(
name|chunk
argument_list|,
name|arena_miscelm_to_pageind
argument_list|(
name|head_miscelm
argument_list|)
operator|+
operator|(
name|leadsize
operator|>>
name|LG_PAGE
operator|)
argument_list|)
expr_stmt|;
name|run
operator|=
operator|&
name|miscelm
operator|->
name|run
expr_stmt|;
name|arena_run_trim_head
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|chunk
argument_list|,
name|head_run
argument_list|,
name|alloc_size
argument_list|,
name|alloc_size
operator|-
name|leadsize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trailsize
operator|!=
literal|0
condition|)
block|{
name|arena_run_trim_tail
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|chunk
argument_list|,
name|run
argument_list|,
name|usize
operator|+
name|large_pad
operator|+
name|trailsize
argument_list|,
name|usize
operator|+
name|large_pad
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arena_run_init_large
argument_list|(
name|arena
argument_list|,
name|run
argument_list|,
name|usize
operator|+
name|large_pad
argument_list|,
name|zero
argument_list|)
condition|)
block|{
name|size_t
name|run_ind
init|=
name|arena_miscelm_to_pageind
argument_list|(
name|arena_run_to_miscelm
argument_list|(
name|run
argument_list|)
argument_list|)
decl_stmt|;
name|bool
name|dirty
init|=
operator|(
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
operator|!=
literal|0
operator|)
decl_stmt|;
name|bool
name|decommitted
init|=
operator|(
name|arena_mapbits_decommitted_get
argument_list|(
name|chunk
argument_list|,
name|run_ind
argument_list|)
operator|!=
literal|0
operator|)
decl_stmt|;
name|assert
argument_list|(
name|decommitted
argument_list|)
expr_stmt|;
comment|/* Cause of OOM. */
name|arena_run_dalloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|run
argument_list|,
name|dirty
argument_list|,
name|false
argument_list|,
name|decommitted
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ret
operator|=
name|arena_miscelm_to_rpages
argument_list|(
name|miscelm
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|szind_t
name|index
init|=
name|size2index
argument_list|(
name|usize
argument_list|)
operator|-
name|NBINS
decl_stmt|;
name|arena
operator|->
name|stats
operator|.
name|nmalloc_large
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|nrequests_large
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|allocated_large
operator|+=
name|usize
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|index
index|]
operator|.
name|nmalloc
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|index
index|]
operator|.
name|nrequests
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|index
index|]
operator|.
name|curruns
operator|++
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_fill
operator|&&
operator|!
name|zero
condition|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|opt_junk_alloc
argument_list|)
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
name|JEMALLOC_ALLOC_JUNK
argument_list|,
name|usize
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|unlikely
argument_list|(
name|opt_zero
argument_list|)
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
name|arena_decay_tick
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|arena_palloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
name|zero
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|usize
operator|<=
name|SMALL_MAXCLASS
operator|&&
operator|(
name|alignment
operator|<
name|PAGE
operator|||
operator|(
name|alignment
operator|==
name|PAGE
operator|&&
operator|(
name|usize
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* Small; alignment doesn't require special run placement. */
name|ret
operator|=
name|arena_malloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|usize
argument_list|,
name|size2index
argument_list|(
name|usize
argument_list|)
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|usize
operator|<=
name|large_maxclass
operator|&&
name|alignment
operator|<=
name|PAGE
condition|)
block|{
comment|/* 		 * Large; alignment doesn't require special run placement. 		 * However, the cached pointer may be at a random offset from 		 * the base of the run, so do some bit manipulation to retrieve 		 * the base. 		 */
name|ret
operator|=
name|arena_malloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|usize
argument_list|,
name|size2index
argument_list|(
name|usize
argument_list|)
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_cache_oblivious
condition|)
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|&
operator|~
name|PAGE_MASK
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|likely
argument_list|(
name|usize
operator|<=
name|large_maxclass
argument_list|)
condition|)
block|{
name|ret
operator|=
name|arena_palloc_large
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|usize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|likely
argument_list|(
name|alignment
operator|<=
name|chunksize
argument_list|)
condition|)
name|ret
operator|=
name|huge_malloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|usize
argument_list|,
name|zero
argument_list|)
expr_stmt|;
else|else
block|{
name|ret
operator|=
name|huge_palloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|usize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|arena_prof_promoted
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|size_t
name|pageind
decl_stmt|;
name|szind_t
name|binind
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
operator|!=
name|ptr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|isalloc
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|,
name|false
argument_list|)
operator|==
name|LARGE_MINCLASS
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|isalloc
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|,
name|true
argument_list|)
operator|==
name|LARGE_MINCLASS
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|<=
name|SMALL_MAXCLASS
argument_list|)
expr_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|pageind
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|LG_PAGE
expr_stmt|;
name|binind
operator|=
name|size2index
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|binind
operator|<
name|NBINS
argument_list|)
expr_stmt|;
name|arena_mapbits_large_binind_set
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|,
name|binind
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|isalloc
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|,
name|false
argument_list|)
operator|==
name|LARGE_MINCLASS
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|isalloc
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|,
name|true
argument_list|)
operator|==
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_dissociate_bin_run
parameter_list|(
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
block|{
comment|/* Dissociate run from bin. */
if|if
condition|(
name|run
operator|==
name|bin
operator|->
name|runcur
condition|)
name|bin
operator|->
name|runcur
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|szind_t
name|binind
init|=
name|arena_bin_index
argument_list|(
name|extent_node_arena_get
argument_list|(
operator|&
name|chunk
operator|->
name|node
argument_list|)
argument_list|,
name|bin
argument_list|)
decl_stmt|;
name|arena_bin_info_t
modifier|*
name|bin_info
init|=
operator|&
name|arena_bin_info
index|[
name|binind
index|]
decl_stmt|;
comment|/* 		 * The following block's conditional is necessary because if the 		 * run only contains one region, then it never gets inserted 		 * into the non-full runs tree. 		 */
if|if
condition|(
name|bin_info
operator|->
name|nregs
operator|!=
literal|1
condition|)
block|{
name|arena_chunk_map_misc_t
modifier|*
name|miscelm
init|=
name|arena_run_to_miscelm
argument_list|(
name|run
argument_list|)
decl_stmt|;
name|arena_run_heap_remove
argument_list|(
operator|&
name|bin
operator|->
name|runs
argument_list|,
name|miscelm
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arena_dalloc_bin_run
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
block|{
name|assert
argument_list|(
name|run
operator|!=
name|bin
operator|->
name|runcur
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/******************************/
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arena_run_dalloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|run
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/****************************/
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
name|bin
operator|->
name|stats
operator|.
name|curruns
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_bin_lower_run
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
block|{
comment|/* 	 * Make sure that if bin->runcur is non-NULL, it refers to the lowest 	 * non-full run.  It is okay to NULL runcur out rather than proactively 	 * keeping it pointing at the lowest non-full run. 	 */
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|run
operator|<
operator|(
name|uintptr_t
operator|)
name|bin
operator|->
name|runcur
condition|)
block|{
comment|/* Switch runcur. */
if|if
condition|(
name|bin
operator|->
name|runcur
operator|->
name|nfree
operator|>
literal|0
condition|)
name|arena_bin_runs_insert
argument_list|(
name|bin
argument_list|,
name|bin
operator|->
name|runcur
argument_list|)
expr_stmt|;
name|bin
operator|->
name|runcur
operator|=
name|run
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
name|bin
operator|->
name|stats
operator|.
name|reruns
operator|++
expr_stmt|;
block|}
else|else
name|arena_bin_runs_insert
argument_list|(
name|bin
argument_list|,
name|run
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_dalloc_bin_locked_impl
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|arena_chunk_map_bits_t
modifier|*
name|bitselm
parameter_list|,
name|bool
name|junked
parameter_list|)
block|{
name|size_t
name|pageind
decl_stmt|,
name|rpages_ind
decl_stmt|;
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|arena_bin_t
modifier|*
name|bin
decl_stmt|;
name|arena_bin_info_t
modifier|*
name|bin_info
decl_stmt|;
name|szind_t
name|binind
decl_stmt|;
name|pageind
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|LG_PAGE
expr_stmt|;
name|rpages_ind
operator|=
name|pageind
operator|-
name|arena_mapbits_small_runind_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
expr_stmt|;
name|run
operator|=
operator|&
name|arena_miscelm_get_mutable
argument_list|(
name|chunk
argument_list|,
name|rpages_ind
argument_list|)
operator|->
name|run
expr_stmt|;
name|binind
operator|=
name|run
operator|->
name|binind
expr_stmt|;
name|bin
operator|=
operator|&
name|arena
operator|->
name|bins
index|[
name|binind
index|]
expr_stmt|;
name|bin_info
operator|=
operator|&
name|arena_bin_info
index|[
name|binind
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|junked
operator|&&
name|config_fill
operator|&&
name|unlikely
argument_list|(
name|opt_junk_free
argument_list|)
condition|)
name|arena_dalloc_junk_small
argument_list|(
name|ptr
argument_list|,
name|bin_info
argument_list|)
expr_stmt|;
name|arena_run_reg_dalloc
argument_list|(
name|run
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
operator|->
name|nfree
operator|==
name|bin_info
operator|->
name|nregs
condition|)
block|{
name|arena_dissociate_bin_run
argument_list|(
name|chunk
argument_list|,
name|run
argument_list|,
name|bin
argument_list|)
expr_stmt|;
name|arena_dalloc_bin_run
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|chunk
argument_list|,
name|run
argument_list|,
name|bin
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|run
operator|->
name|nfree
operator|==
literal|1
operator|&&
name|run
operator|!=
name|bin
operator|->
name|runcur
condition|)
name|arena_bin_lower_run
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|run
argument_list|,
name|bin
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|bin
operator|->
name|stats
operator|.
name|ndalloc
operator|++
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|curregs
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|arena_dalloc_bin_junked_locked
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|arena_chunk_map_bits_t
modifier|*
name|bitselm
parameter_list|)
block|{
name|arena_dalloc_bin_locked_impl
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|chunk
argument_list|,
name|ptr
argument_list|,
name|bitselm
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_dalloc_bin
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|pageind
parameter_list|,
name|arena_chunk_map_bits_t
modifier|*
name|bitselm
parameter_list|)
block|{
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|arena_bin_t
modifier|*
name|bin
decl_stmt|;
name|size_t
name|rpages_ind
decl_stmt|;
name|rpages_ind
operator|=
name|pageind
operator|-
name|arena_mapbits_small_runind_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
expr_stmt|;
name|run
operator|=
operator|&
name|arena_miscelm_get_mutable
argument_list|(
name|chunk
argument_list|,
name|rpages_ind
argument_list|)
operator|->
name|run
expr_stmt|;
name|bin
operator|=
operator|&
name|arena
operator|->
name|bins
index|[
name|run
operator|->
name|binind
index|]
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arena_dalloc_bin_locked_impl
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|chunk
argument_list|,
name|ptr
argument_list|,
name|bitselm
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_dalloc_small
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|pageind
parameter_list|)
block|{
name|arena_chunk_map_bits_t
modifier|*
name|bitselm
decl_stmt|;
if|if
condition|(
name|config_debug
condition|)
block|{
comment|/* arena_ptr_small_binind_get() does extra sanity checking. */
name|assert
argument_list|(
name|arena_ptr_small_binind_get
argument_list|(
name|ptr
argument_list|,
name|arena_mapbits_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
argument_list|)
operator|!=
name|BININD_INVALID
argument_list|)
expr_stmt|;
block|}
name|bitselm
operator|=
name|arena_bitselm_get_mutable
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
expr_stmt|;
name|arena_dalloc_bin
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|chunk
argument_list|,
name|ptr
argument_list|,
name|pageind
argument_list|,
name|bitselm
argument_list|)
expr_stmt|;
name|arena_decay_tick
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_JET
end_ifdef

begin_undef
undef|#
directive|undef
name|arena_dalloc_junk_large
end_undef

begin_define
define|#
directive|define
name|arena_dalloc_junk_large
value|JEMALLOC_N(n_arena_dalloc_junk_large)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|arena_dalloc_junk_large
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|usize
parameter_list|)
block|{
if|if
condition|(
name|config_fill
operator|&&
name|unlikely
argument_list|(
name|opt_junk_free
argument_list|)
condition|)
name|memset
argument_list|(
name|ptr
argument_list|,
name|JEMALLOC_FREE_JUNK
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_JET
end_ifdef

begin_undef
undef|#
directive|undef
name|arena_dalloc_junk_large
end_undef

begin_define
define|#
directive|define
name|arena_dalloc_junk_large
value|JEMALLOC_N(arena_dalloc_junk_large)
end_define

begin_decl_stmt
name|arena_dalloc_junk_large_t
modifier|*
name|arena_dalloc_junk_large
init|=
name|JEMALLOC_N
argument_list|(
name|n_arena_dalloc_junk_large
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|arena_dalloc_large_locked_impl
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|bool
name|junked
parameter_list|)
block|{
name|size_t
name|pageind
init|=
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|LG_PAGE
decl_stmt|;
name|arena_chunk_map_misc_t
modifier|*
name|miscelm
init|=
name|arena_miscelm_get_mutable
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
decl_stmt|;
name|arena_run_t
modifier|*
name|run
init|=
operator|&
name|miscelm
operator|->
name|run
decl_stmt|;
if|if
condition|(
name|config_fill
operator|||
name|config_stats
condition|)
block|{
name|size_t
name|usize
init|=
name|arena_mapbits_large_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|-
name|large_pad
decl_stmt|;
if|if
condition|(
operator|!
name|junked
condition|)
name|arena_dalloc_junk_large
argument_list|(
name|ptr
argument_list|,
name|usize
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|szind_t
name|index
init|=
name|size2index
argument_list|(
name|usize
argument_list|)
operator|-
name|NBINS
decl_stmt|;
name|arena
operator|->
name|stats
operator|.
name|ndalloc_large
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|allocated_large
operator|-=
name|usize
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|index
index|]
operator|.
name|ndalloc
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|index
index|]
operator|.
name|curruns
operator|--
expr_stmt|;
block|}
block|}
name|arena_run_dalloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|run
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_dalloc_large_junked_locked
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|arena_dalloc_large_locked_impl
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|chunk
argument_list|,
name|ptr
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_dalloc_large
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arena_dalloc_large_locked_impl
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|chunk
argument_list|,
name|ptr
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arena_decay_tick
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_ralloc_large_shrink
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|pageind
init|=
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|LG_PAGE
decl_stmt|;
name|arena_chunk_map_misc_t
modifier|*
name|miscelm
init|=
name|arena_miscelm_get_mutable
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
decl_stmt|;
name|arena_run_t
modifier|*
name|run
init|=
operator|&
name|miscelm
operator|->
name|run
decl_stmt|;
name|assert
argument_list|(
name|size
operator|<
name|oldsize
argument_list|)
expr_stmt|;
comment|/* 	 * Shrink the run, and make trailing pages available for other 	 * allocations. 	 */
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arena_run_trim_tail
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|chunk
argument_list|,
name|run
argument_list|,
name|oldsize
operator|+
name|large_pad
argument_list|,
name|size
operator|+
name|large_pad
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|szind_t
name|oldindex
init|=
name|size2index
argument_list|(
name|oldsize
argument_list|)
operator|-
name|NBINS
decl_stmt|;
name|szind_t
name|index
init|=
name|size2index
argument_list|(
name|size
argument_list|)
operator|-
name|NBINS
decl_stmt|;
name|arena
operator|->
name|stats
operator|.
name|ndalloc_large
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|allocated_large
operator|-=
name|oldsize
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|oldindex
index|]
operator|.
name|ndalloc
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|oldindex
index|]
operator|.
name|curruns
operator|--
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|nmalloc_large
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|nrequests_large
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|allocated_large
operator|+=
name|size
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|index
index|]
operator|.
name|nmalloc
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|index
index|]
operator|.
name|nrequests
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|index
index|]
operator|.
name|curruns
operator|++
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|arena_ralloc_large_grow
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|usize_min
parameter_list|,
name|size_t
name|usize_max
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|size_t
name|pageind
init|=
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|LG_PAGE
decl_stmt|;
name|size_t
name|npages
init|=
operator|(
name|oldsize
operator|+
name|large_pad
operator|)
operator|>>
name|LG_PAGE
decl_stmt|;
name|size_t
name|followsize
decl_stmt|;
name|assert
argument_list|(
name|oldsize
operator|==
name|arena_mapbits_large_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|-
name|large_pad
argument_list|)
expr_stmt|;
comment|/* Try to extend the run. */
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pageind
operator|+
name|npages
operator|>=
name|chunk_npages
operator|||
name|arena_mapbits_allocated_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|npages
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|label_fail
goto|;
name|followsize
operator|=
name|arena_mapbits_unallocated_size_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|npages
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldsize
operator|+
name|followsize
operator|>=
name|usize_min
condition|)
block|{
comment|/* 		 * The next run is available and sufficiently large.  Split the 		 * following run, then merge the first part with the existing 		 * allocation. 		 */
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|size_t
name|usize
decl_stmt|,
name|splitsize
decl_stmt|,
name|size
decl_stmt|,
name|flag_dirty
decl_stmt|,
name|flag_unzeroed_mask
decl_stmt|;
name|usize
operator|=
name|usize_max
expr_stmt|;
while|while
condition|(
name|oldsize
operator|+
name|followsize
operator|<
name|usize
condition|)
name|usize
operator|=
name|index2size
argument_list|(
name|size2index
argument_list|(
name|usize
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|usize
operator|>=
name|usize_min
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|usize
operator|>=
name|oldsize
argument_list|)
expr_stmt|;
name|splitsize
operator|=
name|usize
operator|-
name|oldsize
expr_stmt|;
if|if
condition|(
name|splitsize
operator|==
literal|0
condition|)
goto|goto
name|label_fail
goto|;
name|run
operator|=
operator|&
name|arena_miscelm_get_mutable
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|npages
argument_list|)
operator|->
name|run
expr_stmt|;
if|if
condition|(
name|arena_run_split_large
argument_list|(
name|arena
argument_list|,
name|run
argument_list|,
name|splitsize
argument_list|,
name|zero
argument_list|)
condition|)
goto|goto
name|label_fail
goto|;
if|if
condition|(
name|config_cache_oblivious
operator|&&
name|zero
condition|)
block|{
comment|/* 			 * Zero the trailing bytes of the original allocation's 			 * last page, since they are in an indeterminate state. 			 * There will always be trailing bytes, because ptr's 			 * offset from the beginning of the run is a multiple of 			 * CACHELINE in [0 .. PAGE). 			 */
name|void
modifier|*
name|zbase
init|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|+
name|oldsize
operator|)
decl_stmt|;
name|void
modifier|*
name|zpast
init|=
name|PAGE_ADDR2BASE
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|zbase
operator|+
name|PAGE
operator|)
argument_list|)
decl_stmt|;
name|size_t
name|nzero
init|=
operator|(
name|uintptr_t
operator|)
name|zpast
operator|-
operator|(
name|uintptr_t
operator|)
name|zbase
decl_stmt|;
name|assert
argument_list|(
name|nzero
operator|>
literal|0
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|zbase
argument_list|,
literal|0
argument_list|,
name|nzero
argument_list|)
expr_stmt|;
block|}
name|size
operator|=
name|oldsize
operator|+
name|splitsize
expr_stmt|;
name|npages
operator|=
operator|(
name|size
operator|+
name|large_pad
operator|)
operator|>>
name|LG_PAGE
expr_stmt|;
comment|/* 		 * Mark the extended run as dirty if either portion of the run 		 * was dirty before allocation.  This is rather pedantic, 		 * because there's not actually any sequence of events that 		 * could cause the resulting run to be passed to 		 * arena_run_dalloc() with the dirty argument set to false 		 * (which is when dirty flag consistency would really matter). 		 */
name|flag_dirty
operator|=
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator||
name|arena_mapbits_dirty_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|npages
operator|-
literal|1
argument_list|)
expr_stmt|;
name|flag_unzeroed_mask
operator|=
name|flag_dirty
operator|==
literal|0
condition|?
name|CHUNK_MAP_UNZEROED
else|:
literal|0
expr_stmt|;
name|arena_mapbits_large_set
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|,
name|size
operator|+
name|large_pad
argument_list|,
name|flag_dirty
operator||
operator|(
name|flag_unzeroed_mask
operator|&
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|arena_mapbits_large_set
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|npages
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|flag_dirty
operator||
operator|(
name|flag_unzeroed_mask
operator|&
name|arena_mapbits_unzeroed_get
argument_list|(
name|chunk
argument_list|,
name|pageind
operator|+
name|npages
operator|-
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|szind_t
name|oldindex
init|=
name|size2index
argument_list|(
name|oldsize
argument_list|)
operator|-
name|NBINS
decl_stmt|;
name|szind_t
name|index
init|=
name|size2index
argument_list|(
name|size
argument_list|)
operator|-
name|NBINS
decl_stmt|;
name|arena
operator|->
name|stats
operator|.
name|ndalloc_large
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|allocated_large
operator|-=
name|oldsize
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|oldindex
index|]
operator|.
name|ndalloc
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|oldindex
index|]
operator|.
name|curruns
operator|--
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|nmalloc_large
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|nrequests_large
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|allocated_large
operator|+=
name|size
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|index
index|]
operator|.
name|nmalloc
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|index
index|]
operator|.
name|nrequests
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|index
index|]
operator|.
name|curruns
operator|++
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
name|label_fail
label|:
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_JET
end_ifdef

begin_undef
undef|#
directive|undef
name|arena_ralloc_junk_large
end_undef

begin_define
define|#
directive|define
name|arena_ralloc_junk_large
value|JEMALLOC_N(n_arena_ralloc_junk_large)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|arena_ralloc_junk_large
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|old_usize
parameter_list|,
name|size_t
name|usize
parameter_list|)
block|{
if|if
condition|(
name|config_fill
operator|&&
name|unlikely
argument_list|(
name|opt_junk_free
argument_list|)
condition|)
block|{
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|+
name|usize
operator|)
argument_list|,
name|JEMALLOC_FREE_JUNK
argument_list|,
name|old_usize
operator|-
name|usize
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_JET
end_ifdef

begin_undef
undef|#
directive|undef
name|arena_ralloc_junk_large
end_undef

begin_define
define|#
directive|define
name|arena_ralloc_junk_large
value|JEMALLOC_N(arena_ralloc_junk_large)
end_define

begin_decl_stmt
name|arena_ralloc_junk_large_t
modifier|*
name|arena_ralloc_junk_large
init|=
name|JEMALLOC_N
argument_list|(
name|n_arena_ralloc_junk_large
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Try to resize a large allocation, in order to avoid copying.  This will  * always fail if growing an object, and the following run is already in use.  */
end_comment

begin_function
specifier|static
name|bool
name|arena_ralloc_large
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|usize_min
parameter_list|,
name|size_t
name|usize_max
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|arena_t
modifier|*
name|arena
decl_stmt|;
if|if
condition|(
name|oldsize
operator|==
name|usize_max
condition|)
block|{
comment|/* Current size class is compatible and maximal. */
return|return
operator|(
name|false
operator|)
return|;
block|}
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|arena
operator|=
name|extent_node_arena_get
argument_list|(
operator|&
name|chunk
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldsize
operator|<
name|usize_max
condition|)
block|{
name|bool
name|ret
init|=
name|arena_ralloc_large_grow
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|chunk
argument_list|,
name|ptr
argument_list|,
name|oldsize
argument_list|,
name|usize_min
argument_list|,
name|usize_max
argument_list|,
name|zero
argument_list|)
decl_stmt|;
if|if
condition|(
name|config_fill
operator|&&
operator|!
name|ret
operator|&&
operator|!
name|zero
condition|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|opt_junk_alloc
argument_list|)
condition|)
block|{
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|+
name|oldsize
operator|)
argument_list|,
name|JEMALLOC_ALLOC_JUNK
argument_list|,
name|isalloc
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|,
name|config_prof
argument_list|)
operator|-
name|oldsize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unlikely
argument_list|(
name|opt_zero
argument_list|)
condition|)
block|{
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|+
name|oldsize
operator|)
argument_list|,
literal|0
argument_list|,
name|isalloc
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|,
name|config_prof
argument_list|)
operator|-
name|oldsize
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|assert
argument_list|(
name|oldsize
operator|>
name|usize_max
argument_list|)
expr_stmt|;
comment|/* Fill before shrinking in order avoid a race. */
name|arena_ralloc_junk_large
argument_list|(
name|ptr
argument_list|,
name|oldsize
argument_list|,
name|usize_max
argument_list|)
expr_stmt|;
name|arena_ralloc_large_shrink
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|chunk
argument_list|,
name|ptr
argument_list|,
name|oldsize
argument_list|,
name|usize_max
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|arena_ralloc_no_move
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|extra
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|size_t
name|usize_min
decl_stmt|,
name|usize_max
decl_stmt|;
comment|/* Calls with non-zero extra had to clamp extra. */
name|assert
argument_list|(
name|extra
operator|==
literal|0
operator|||
name|size
operator|+
name|extra
operator|<=
name|HUGE_MAXCLASS
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|size
operator|>
name|HUGE_MAXCLASS
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|usize_min
operator|=
name|s2u
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|usize_max
operator|=
name|s2u
argument_list|(
name|size
operator|+
name|extra
argument_list|)
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|oldsize
operator|<=
name|large_maxclass
operator|&&
name|usize_min
operator|<=
name|large_maxclass
argument_list|)
condition|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
comment|/* 		 * Avoid moving the allocation if the size class can be left the 		 * same. 		 */
if|if
condition|(
name|oldsize
operator|<=
name|SMALL_MAXCLASS
condition|)
block|{
name|assert
argument_list|(
name|arena_bin_info
index|[
name|size2index
argument_list|(
name|oldsize
argument_list|)
index|]
operator|.
name|reg_size
operator|==
name|oldsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|usize_max
operator|>
name|SMALL_MAXCLASS
operator|||
name|size2index
argument_list|(
name|usize_max
argument_list|)
operator|!=
name|size2index
argument_list|(
name|oldsize
argument_list|)
operator|)
operator|&&
operator|(
name|size
operator|>
name|oldsize
operator|||
name|usize_max
operator|<
name|oldsize
operator|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|usize_max
operator|<=
name|SMALL_MAXCLASS
condition|)
return|return
operator|(
name|true
operator|)
return|;
if|if
condition|(
name|arena_ralloc_large
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|,
name|oldsize
argument_list|,
name|usize_min
argument_list|,
name|usize_max
argument_list|,
name|zero
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
block|}
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|arena_decay_tick
argument_list|(
name|tsdn
argument_list|,
name|extent_node_arena_get
argument_list|(
operator|&
name|chunk
operator|->
name|node
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|huge_ralloc_no_move
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|,
name|oldsize
argument_list|,
name|usize_min
argument_list|,
name|usize_max
argument_list|,
name|zero
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|arena_ralloc_move_helper
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
name|zero
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|)
block|{
if|if
condition|(
name|alignment
operator|==
literal|0
condition|)
return|return
operator|(
name|arena_malloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|usize
argument_list|,
name|size2index
argument_list|(
name|usize
argument_list|)
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|,
name|true
argument_list|)
operator|)
return|;
name|usize
operator|=
name|sa2u
argument_list|(
name|usize
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|usize
operator|==
literal|0
operator|||
name|usize
operator|>
name|HUGE_MAXCLASS
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|ipalloct
argument_list|(
name|tsdn
argument_list|,
name|usize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|arena_ralloc
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
name|zero
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|usize
decl_stmt|;
name|usize
operator|=
name|s2u
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|usize
operator|==
literal|0
operator|||
name|size
operator|>
name|HUGE_MAXCLASS
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|likely
argument_list|(
name|usize
operator|<=
name|large_maxclass
argument_list|)
condition|)
block|{
name|size_t
name|copysize
decl_stmt|;
comment|/* Try to avoid moving the allocation. */
if|if
condition|(
operator|!
name|arena_ralloc_no_move
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|oldsize
argument_list|,
name|usize
argument_list|,
literal|0
argument_list|,
name|zero
argument_list|)
condition|)
return|return
operator|(
name|ptr
operator|)
return|;
comment|/* 		 * size and oldsize are different enough that we need to move 		 * the object.  In that case, fall back to allocating new space 		 * and copying. 		 */
name|ret
operator|=
name|arena_ralloc_move_helper
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|arena
argument_list|,
name|usize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 		 * Junk/zero-filling were already done by 		 * ipalloc()/arena_malloc(). 		 */
name|copysize
operator|=
operator|(
name|usize
operator|<
name|oldsize
operator|)
condition|?
name|usize
else|:
name|oldsize
expr_stmt|;
name|JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED
argument_list|(
name|ret
argument_list|,
name|copysize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|ptr
argument_list|,
name|copysize
argument_list|)
expr_stmt|;
name|isqalloc
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|oldsize
argument_list|,
name|tcache
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|huge_ralloc
argument_list|(
name|tsd
argument_list|,
name|arena
argument_list|,
name|ptr
argument_list|,
name|oldsize
argument_list|,
name|usize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|dss_prec_t
name|arena_dss_prec_get
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|dss_prec_t
name|ret
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|arena
operator|->
name|dss_prec
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|arena_dss_prec_set
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|dss_prec_t
name|dss_prec
parameter_list|)
block|{
if|if
condition|(
operator|!
name|have_dss
condition|)
return|return
operator|(
name|dss_prec
operator|!=
name|dss_prec_disabled
operator|)
return|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arena
operator|->
name|dss_prec
operator|=
name|dss_prec
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
name|ssize_t
name|arena_lg_dirty_mult_default_get
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|(
name|ssize_t
operator|)
name|atomic_read_z
argument_list|(
operator|(
name|size_t
operator|*
operator|)
operator|&
name|lg_dirty_mult_default
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|arena_lg_dirty_mult_default_set
parameter_list|(
name|ssize_t
name|lg_dirty_mult
parameter_list|)
block|{
if|if
condition|(
name|opt_purge
operator|!=
name|purge_mode_ratio
condition|)
return|return
operator|(
name|true
operator|)
return|;
if|if
condition|(
operator|!
name|arena_lg_dirty_mult_valid
argument_list|(
name|lg_dirty_mult
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|atomic_write_z
argument_list|(
operator|(
name|size_t
operator|*
operator|)
operator|&
name|lg_dirty_mult_default
argument_list|,
operator|(
name|size_t
operator|)
name|lg_dirty_mult
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
name|ssize_t
name|arena_decay_time_default_get
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|(
name|ssize_t
operator|)
name|atomic_read_z
argument_list|(
operator|(
name|size_t
operator|*
operator|)
operator|&
name|decay_time_default
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|arena_decay_time_default_set
parameter_list|(
name|ssize_t
name|decay_time
parameter_list|)
block|{
if|if
condition|(
name|opt_purge
operator|!=
name|purge_mode_decay
condition|)
return|return
operator|(
name|true
operator|)
return|;
if|if
condition|(
operator|!
name|arena_decay_time_valid
argument_list|(
name|decay_time
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|atomic_write_z
argument_list|(
operator|(
name|size_t
operator|*
operator|)
operator|&
name|decay_time_default
argument_list|,
operator|(
name|size_t
operator|)
name|decay_time
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_basic_stats_merge_locked
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|unsigned
modifier|*
name|nthreads
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|dss
parameter_list|,
name|ssize_t
modifier|*
name|lg_dirty_mult
parameter_list|,
name|ssize_t
modifier|*
name|decay_time
parameter_list|,
name|size_t
modifier|*
name|nactive
parameter_list|,
name|size_t
modifier|*
name|ndirty
parameter_list|)
block|{
operator|*
name|nthreads
operator|+=
name|arena_nthreads_get
argument_list|(
name|arena
argument_list|,
name|false
argument_list|)
expr_stmt|;
operator|*
name|dss
operator|=
name|dss_prec_names
index|[
name|arena
operator|->
name|dss_prec
index|]
expr_stmt|;
operator|*
name|lg_dirty_mult
operator|=
name|arena
operator|->
name|lg_dirty_mult
expr_stmt|;
operator|*
name|decay_time
operator|=
name|arena
operator|->
name|decay_time
expr_stmt|;
operator|*
name|nactive
operator|+=
name|arena
operator|->
name|nactive
expr_stmt|;
operator|*
name|ndirty
operator|+=
name|arena
operator|->
name|ndirty
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_basic_stats_merge
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|unsigned
modifier|*
name|nthreads
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|dss
parameter_list|,
name|ssize_t
modifier|*
name|lg_dirty_mult
parameter_list|,
name|ssize_t
modifier|*
name|decay_time
parameter_list|,
name|size_t
modifier|*
name|nactive
parameter_list|,
name|size_t
modifier|*
name|ndirty
parameter_list|)
block|{
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arena_basic_stats_merge_locked
argument_list|(
name|arena
argument_list|,
name|nthreads
argument_list|,
name|dss
argument_list|,
name|lg_dirty_mult
argument_list|,
name|decay_time
argument_list|,
name|nactive
argument_list|,
name|ndirty
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_stats_merge
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|unsigned
modifier|*
name|nthreads
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|dss
parameter_list|,
name|ssize_t
modifier|*
name|lg_dirty_mult
parameter_list|,
name|ssize_t
modifier|*
name|decay_time
parameter_list|,
name|size_t
modifier|*
name|nactive
parameter_list|,
name|size_t
modifier|*
name|ndirty
parameter_list|,
name|arena_stats_t
modifier|*
name|astats
parameter_list|,
name|malloc_bin_stats_t
modifier|*
name|bstats
parameter_list|,
name|malloc_large_stats_t
modifier|*
name|lstats
parameter_list|,
name|malloc_huge_stats_t
modifier|*
name|hstats
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|cassert
argument_list|(
name|config_stats
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arena_basic_stats_merge_locked
argument_list|(
name|arena
argument_list|,
name|nthreads
argument_list|,
name|dss
argument_list|,
name|lg_dirty_mult
argument_list|,
name|decay_time
argument_list|,
name|nactive
argument_list|,
name|ndirty
argument_list|)
expr_stmt|;
name|astats
operator|->
name|mapped
operator|+=
name|arena
operator|->
name|stats
operator|.
name|mapped
expr_stmt|;
name|astats
operator|->
name|retained
operator|+=
name|arena
operator|->
name|stats
operator|.
name|retained
expr_stmt|;
name|astats
operator|->
name|npurge
operator|+=
name|arena
operator|->
name|stats
operator|.
name|npurge
expr_stmt|;
name|astats
operator|->
name|nmadvise
operator|+=
name|arena
operator|->
name|stats
operator|.
name|nmadvise
expr_stmt|;
name|astats
operator|->
name|purged
operator|+=
name|arena
operator|->
name|stats
operator|.
name|purged
expr_stmt|;
name|astats
operator|->
name|metadata_mapped
operator|+=
name|arena
operator|->
name|stats
operator|.
name|metadata_mapped
expr_stmt|;
name|astats
operator|->
name|metadata_allocated
operator|+=
name|arena_metadata_allocated_get
argument_list|(
name|arena
argument_list|)
expr_stmt|;
name|astats
operator|->
name|allocated_large
operator|+=
name|arena
operator|->
name|stats
operator|.
name|allocated_large
expr_stmt|;
name|astats
operator|->
name|nmalloc_large
operator|+=
name|arena
operator|->
name|stats
operator|.
name|nmalloc_large
expr_stmt|;
name|astats
operator|->
name|ndalloc_large
operator|+=
name|arena
operator|->
name|stats
operator|.
name|ndalloc_large
expr_stmt|;
name|astats
operator|->
name|nrequests_large
operator|+=
name|arena
operator|->
name|stats
operator|.
name|nrequests_large
expr_stmt|;
name|astats
operator|->
name|allocated_huge
operator|+=
name|arena
operator|->
name|stats
operator|.
name|allocated_huge
expr_stmt|;
name|astats
operator|->
name|nmalloc_huge
operator|+=
name|arena
operator|->
name|stats
operator|.
name|nmalloc_huge
expr_stmt|;
name|astats
operator|->
name|ndalloc_huge
operator|+=
name|arena
operator|->
name|stats
operator|.
name|ndalloc_huge
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlclasses
condition|;
name|i
operator|++
control|)
block|{
name|lstats
index|[
name|i
index|]
operator|.
name|nmalloc
operator|+=
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|i
index|]
operator|.
name|nmalloc
expr_stmt|;
name|lstats
index|[
name|i
index|]
operator|.
name|ndalloc
operator|+=
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|i
index|]
operator|.
name|ndalloc
expr_stmt|;
name|lstats
index|[
name|i
index|]
operator|.
name|nrequests
operator|+=
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|i
index|]
operator|.
name|nrequests
expr_stmt|;
name|lstats
index|[
name|i
index|]
operator|.
name|curruns
operator|+=
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|i
index|]
operator|.
name|curruns
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nhclasses
condition|;
name|i
operator|++
control|)
block|{
name|hstats
index|[
name|i
index|]
operator|.
name|nmalloc
operator|+=
name|arena
operator|->
name|stats
operator|.
name|hstats
index|[
name|i
index|]
operator|.
name|nmalloc
expr_stmt|;
name|hstats
index|[
name|i
index|]
operator|.
name|ndalloc
operator|+=
name|arena
operator|->
name|stats
operator|.
name|hstats
index|[
name|i
index|]
operator|.
name|ndalloc
expr_stmt|;
name|hstats
index|[
name|i
index|]
operator|.
name|curhchunks
operator|+=
name|arena
operator|->
name|stats
operator|.
name|hstats
index|[
name|i
index|]
operator|.
name|curhchunks
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
name|arena_bin_t
modifier|*
name|bin
init|=
operator|&
name|arena
operator|->
name|bins
index|[
name|i
index|]
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
name|bstats
index|[
name|i
index|]
operator|.
name|nmalloc
operator|+=
name|bin
operator|->
name|stats
operator|.
name|nmalloc
expr_stmt|;
name|bstats
index|[
name|i
index|]
operator|.
name|ndalloc
operator|+=
name|bin
operator|->
name|stats
operator|.
name|ndalloc
expr_stmt|;
name|bstats
index|[
name|i
index|]
operator|.
name|nrequests
operator|+=
name|bin
operator|->
name|stats
operator|.
name|nrequests
expr_stmt|;
name|bstats
index|[
name|i
index|]
operator|.
name|curregs
operator|+=
name|bin
operator|->
name|stats
operator|.
name|curregs
expr_stmt|;
if|if
condition|(
name|config_tcache
condition|)
block|{
name|bstats
index|[
name|i
index|]
operator|.
name|nfills
operator|+=
name|bin
operator|->
name|stats
operator|.
name|nfills
expr_stmt|;
name|bstats
index|[
name|i
index|]
operator|.
name|nflushes
operator|+=
name|bin
operator|->
name|stats
operator|.
name|nflushes
expr_stmt|;
block|}
name|bstats
index|[
name|i
index|]
operator|.
name|nruns
operator|+=
name|bin
operator|->
name|stats
operator|.
name|nruns
expr_stmt|;
name|bstats
index|[
name|i
index|]
operator|.
name|reruns
operator|+=
name|bin
operator|->
name|stats
operator|.
name|reruns
expr_stmt|;
name|bstats
index|[
name|i
index|]
operator|.
name|curruns
operator|+=
name|bin
operator|->
name|stats
operator|.
name|curruns
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|unsigned
name|arena_nthreads_get
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|bool
name|internal
parameter_list|)
block|{
return|return
operator|(
name|atomic_read_u
argument_list|(
operator|&
name|arena
operator|->
name|nthreads
index|[
name|internal
index|]
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|arena_nthreads_inc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|bool
name|internal
parameter_list|)
block|{
name|atomic_add_u
argument_list|(
operator|&
name|arena
operator|->
name|nthreads
index|[
name|internal
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_nthreads_dec
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|bool
name|internal
parameter_list|)
block|{
name|atomic_sub_u
argument_list|(
operator|&
name|arena
operator|->
name|nthreads
index|[
name|internal
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|arena_t
modifier|*
name|arena_new
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|unsigned
name|ind
parameter_list|)
block|{
name|arena_t
modifier|*
name|arena
decl_stmt|;
name|size_t
name|arena_size
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
comment|/* Compute arena size to incorporate sufficient runs_avail elements. */
name|arena_size
operator|=
name|offsetof
argument_list|(
name|arena_t
argument_list|,
name|runs_avail
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|arena_run_heap_t
argument_list|)
operator|*
name|runs_avail_nclasses
operator|)
expr_stmt|;
comment|/* 	 * Allocate arena, arena->lstats, and arena->hstats contiguously, mainly 	 * because there is no way to clean up if base_alloc() OOMs. 	 */
if|if
condition|(
name|config_stats
condition|)
block|{
name|arena
operator|=
operator|(
name|arena_t
operator|*
operator|)
name|base_alloc
argument_list|(
name|tsdn
argument_list|,
name|CACHELINE_CEILING
argument_list|(
name|arena_size
argument_list|)
operator|+
name|QUANTUM_CEILING
argument_list|(
name|nlclasses
operator|*
sizeof|sizeof
argument_list|(
name|malloc_large_stats_t
argument_list|)
operator|+
name|nhclasses
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|malloc_huge_stats_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|arena
operator|=
operator|(
name|arena_t
operator|*
operator|)
name|base_alloc
argument_list|(
name|tsdn
argument_list|,
name|arena_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|arena
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|arena
operator|->
name|ind
operator|=
name|ind
expr_stmt|;
name|arena
operator|->
name|nthreads
index|[
literal|0
index|]
operator|=
name|arena
operator|->
name|nthreads
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|,
literal|"arena"
argument_list|,
name|WITNESS_RANK_ARENA
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|memset
argument_list|(
operator|&
name|arena
operator|->
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|arena_stats_t
argument_list|)
argument_list|)
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
operator|=
operator|(
name|malloc_large_stats_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|arena
operator|+
name|CACHELINE_CEILING
argument_list|(
name|arena_size
argument_list|)
operator|)
expr_stmt|;
name|memset
argument_list|(
name|arena
operator|->
name|stats
operator|.
name|lstats
argument_list|,
literal|0
argument_list|,
name|nlclasses
operator|*
sizeof|sizeof
argument_list|(
name|malloc_large_stats_t
argument_list|)
argument_list|)
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|hstats
operator|=
operator|(
name|malloc_huge_stats_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|arena
operator|+
name|CACHELINE_CEILING
argument_list|(
name|arena_size
argument_list|)
operator|+
name|QUANTUM_CEILING
argument_list|(
name|nlclasses
operator|*
sizeof|sizeof
argument_list|(
name|malloc_large_stats_t
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|memset
argument_list|(
name|arena
operator|->
name|stats
operator|.
name|hstats
argument_list|,
literal|0
argument_list|,
name|nhclasses
operator|*
sizeof|sizeof
argument_list|(
name|malloc_huge_stats_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_tcache
condition|)
name|ql_new
argument_list|(
operator|&
name|arena
operator|->
name|tcache_ql
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config_prof
condition|)
name|arena
operator|->
name|prof_accumbytes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|config_cache_oblivious
condition|)
block|{
comment|/* 		 * A nondeterministic seed based on the address of arena reduces 		 * the likelihood of lockstep non-uniform cache index 		 * utilization among identical concurrent processes, but at the 		 * cost of test repeatability.  For debug builds, instead use a 		 * deterministic seed. 		 */
name|arena
operator|->
name|offset_state
operator|=
name|config_debug
condition|?
name|ind
else|:
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|arena
expr_stmt|;
block|}
name|arena
operator|->
name|dss_prec
operator|=
name|chunk_dss_prec_get
argument_list|(
name|tsdn
argument_list|)
expr_stmt|;
name|ql_new
argument_list|(
operator|&
name|arena
operator|->
name|achunks
argument_list|)
expr_stmt|;
name|arena
operator|->
name|spare
operator|=
name|NULL
expr_stmt|;
name|arena
operator|->
name|lg_dirty_mult
operator|=
name|arena_lg_dirty_mult_default_get
argument_list|()
expr_stmt|;
name|arena
operator|->
name|purging
operator|=
name|false
expr_stmt|;
name|arena
operator|->
name|nactive
operator|=
literal|0
expr_stmt|;
name|arena
operator|->
name|ndirty
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|runs_avail_nclasses
condition|;
name|i
operator|++
control|)
name|arena_run_heap_new
argument_list|(
operator|&
name|arena
operator|->
name|runs_avail
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|qr_new
argument_list|(
operator|&
name|arena
operator|->
name|runs_dirty
argument_list|,
name|rd_link
argument_list|)
expr_stmt|;
name|qr_new
argument_list|(
operator|&
name|arena
operator|->
name|chunks_cache
argument_list|,
name|cc_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_purge
operator|==
name|purge_mode_decay
condition|)
name|arena_decay_init
argument_list|(
name|arena
argument_list|,
name|arena_decay_time_default_get
argument_list|()
argument_list|)
expr_stmt|;
name|ql_new
argument_list|(
operator|&
name|arena
operator|->
name|huge
argument_list|)
expr_stmt|;
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|arena
operator|->
name|huge_mtx
argument_list|,
literal|"arena_huge"
argument_list|,
name|WITNESS_RANK_ARENA_HUGE
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|extent_tree_szad_new
argument_list|(
operator|&
name|arena
operator|->
name|chunks_szad_cached
argument_list|)
expr_stmt|;
name|extent_tree_ad_new
argument_list|(
operator|&
name|arena
operator|->
name|chunks_ad_cached
argument_list|)
expr_stmt|;
name|extent_tree_szad_new
argument_list|(
operator|&
name|arena
operator|->
name|chunks_szad_retained
argument_list|)
expr_stmt|;
name|extent_tree_ad_new
argument_list|(
operator|&
name|arena
operator|->
name|chunks_ad_retained
argument_list|)
expr_stmt|;
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|arena
operator|->
name|chunks_mtx
argument_list|,
literal|"arena_chunks"
argument_list|,
name|WITNESS_RANK_ARENA_CHUNKS
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ql_new
argument_list|(
operator|&
name|arena
operator|->
name|node_cache
argument_list|)
expr_stmt|;
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|arena
operator|->
name|node_cache_mtx
argument_list|,
literal|"arena_node_cache"
argument_list|,
name|WITNESS_RANK_ARENA_NODE_CACHE
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|arena
operator|->
name|chunk_hooks
operator|=
name|chunk_hooks_default
expr_stmt|;
comment|/* Initialize bins. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
name|arena_bin_t
modifier|*
name|bin
init|=
operator|&
name|arena
operator|->
name|bins
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|,
literal|"arena_bin"
argument_list|,
name|WITNESS_RANK_ARENA_BIN
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bin
operator|->
name|runcur
operator|=
name|NULL
expr_stmt|;
name|arena_run_heap_new
argument_list|(
operator|&
name|bin
operator|->
name|runs
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
name|memset
argument_list|(
operator|&
name|bin
operator|->
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|malloc_bin_stats_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|arena
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate bin_info->run_size such that it meets the following constraints:  *  *   *) bin_info->run_size<= arena_maxrun  *   *) bin_info->nregs<= RUN_MAXREGS  *  * bin_info->nregs and bin_info->reg0_offset are also calculated here, since  * these settings are all interdependent.  */
end_comment

begin_function
specifier|static
name|void
name|bin_info_run_size_calc
parameter_list|(
name|arena_bin_info_t
modifier|*
name|bin_info
parameter_list|)
block|{
name|size_t
name|pad_size
decl_stmt|;
name|size_t
name|try_run_size
decl_stmt|,
name|perfect_run_size
decl_stmt|,
name|actual_run_size
decl_stmt|;
name|uint32_t
name|try_nregs
decl_stmt|,
name|perfect_nregs
decl_stmt|,
name|actual_nregs
decl_stmt|;
comment|/* 	 * Determine redzone size based on minimum alignment and minimum 	 * redzone size.  Add padding to the end of the run if it is needed to 	 * align the regions.  The padding allows each redzone to be half the 	 * minimum alignment; without the padding, each redzone would have to 	 * be twice as large in order to maintain alignment. 	 */
if|if
condition|(
name|config_fill
operator|&&
name|unlikely
argument_list|(
name|opt_redzone
argument_list|)
condition|)
block|{
name|size_t
name|align_min
init|=
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
operator|(
name|ffs_zu
argument_list|(
name|bin_info
operator|->
name|reg_size
argument_list|)
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|align_min
operator|<=
name|REDZONE_MINSIZE
condition|)
block|{
name|bin_info
operator|->
name|redzone_size
operator|=
name|REDZONE_MINSIZE
expr_stmt|;
name|pad_size
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bin_info
operator|->
name|redzone_size
operator|=
name|align_min
operator|>>
literal|1
expr_stmt|;
name|pad_size
operator|=
name|bin_info
operator|->
name|redzone_size
expr_stmt|;
block|}
block|}
else|else
block|{
name|bin_info
operator|->
name|redzone_size
operator|=
literal|0
expr_stmt|;
name|pad_size
operator|=
literal|0
expr_stmt|;
block|}
name|bin_info
operator|->
name|reg_interval
operator|=
name|bin_info
operator|->
name|reg_size
operator|+
operator|(
name|bin_info
operator|->
name|redzone_size
operator|<<
literal|1
operator|)
expr_stmt|;
comment|/* 	 * Compute run size under ideal conditions (no redzones, no limit on run 	 * size). 	 */
name|try_run_size
operator|=
name|PAGE
expr_stmt|;
name|try_nregs
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|try_run_size
operator|/
name|bin_info
operator|->
name|reg_size
argument_list|)
expr_stmt|;
do|do
block|{
name|perfect_run_size
operator|=
name|try_run_size
expr_stmt|;
name|perfect_nregs
operator|=
name|try_nregs
expr_stmt|;
name|try_run_size
operator|+=
name|PAGE
expr_stmt|;
name|try_nregs
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|try_run_size
operator|/
name|bin_info
operator|->
name|reg_size
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|perfect_run_size
operator|!=
name|perfect_nregs
operator|*
name|bin_info
operator|->
name|reg_size
condition|)
do|;
name|assert
argument_list|(
name|perfect_nregs
operator|<=
name|RUN_MAXREGS
argument_list|)
expr_stmt|;
name|actual_run_size
operator|=
name|perfect_run_size
expr_stmt|;
name|actual_nregs
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|actual_run_size
operator|-
name|pad_size
operator|)
operator|/
name|bin_info
operator|->
name|reg_interval
argument_list|)
expr_stmt|;
comment|/* 	 * Redzones can require enough padding that not even a single region can 	 * fit within the number of pages that would normally be dedicated to a 	 * run for this size class.  Increase the run size until at least one 	 * region fits. 	 */
while|while
condition|(
name|actual_nregs
operator|==
literal|0
condition|)
block|{
name|assert
argument_list|(
name|config_fill
operator|&&
name|unlikely
argument_list|(
name|opt_redzone
argument_list|)
argument_list|)
expr_stmt|;
name|actual_run_size
operator|+=
name|PAGE
expr_stmt|;
name|actual_nregs
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|actual_run_size
operator|-
name|pad_size
operator|)
operator|/
name|bin_info
operator|->
name|reg_interval
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Make sure that the run will fit within an arena chunk. 	 */
while|while
condition|(
name|actual_run_size
operator|>
name|arena_maxrun
condition|)
block|{
name|actual_run_size
operator|-=
name|PAGE
expr_stmt|;
name|actual_nregs
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|actual_run_size
operator|-
name|pad_size
operator|)
operator|/
name|bin_info
operator|->
name|reg_interval
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|actual_nregs
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|actual_run_size
operator|==
name|s2u
argument_list|(
name|actual_run_size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy final settings. */
name|bin_info
operator|->
name|run_size
operator|=
name|actual_run_size
expr_stmt|;
name|bin_info
operator|->
name|nregs
operator|=
name|actual_nregs
expr_stmt|;
name|bin_info
operator|->
name|reg0_offset
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|actual_run_size
operator|-
operator|(
name|actual_nregs
operator|*
name|bin_info
operator|->
name|reg_interval
operator|)
operator|-
name|pad_size
operator|+
name|bin_info
operator|->
name|redzone_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual_run_size
operator|>
name|small_maxrun
condition|)
name|small_maxrun
operator|=
name|actual_run_size
expr_stmt|;
name|assert
argument_list|(
name|bin_info
operator|->
name|reg0_offset
operator|-
name|bin_info
operator|->
name|redzone_size
operator|+
operator|(
name|bin_info
operator|->
name|nregs
operator|*
name|bin_info
operator|->
name|reg_interval
operator|)
operator|+
name|pad_size
operator|==
name|bin_info
operator|->
name|run_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bin_info_init
parameter_list|(
name|void
parameter_list|)
block|{
name|arena_bin_info_t
modifier|*
name|bin_info
decl_stmt|;
define|#
directive|define
name|BIN_INFO_INIT_bin_yes
parameter_list|(
name|index
parameter_list|,
name|size
parameter_list|)
define|\
value|bin_info =&arena_bin_info[index];				\ 	bin_info->reg_size = size;					\ 	bin_info_run_size_calc(bin_info);				\ 	bitmap_info_init(&bin_info->bitmap_info, bin_info->nregs);
define|#
directive|define
name|BIN_INFO_INIT_bin_no
parameter_list|(
name|index
parameter_list|,
name|size
parameter_list|)
define|#
directive|define
name|SC
parameter_list|(
name|index
parameter_list|,
name|lg_grp
parameter_list|,
name|lg_delta
parameter_list|,
name|ndelta
parameter_list|,
name|bin
parameter_list|,
name|lg_delta_lookup
parameter_list|)
define|\
value|BIN_INFO_INIT_bin_##bin(index, (ZU(1)<<lg_grp) + (ZU(ndelta)<<lg_delta))
name|SIZE_CLASSES
undef|#
directive|undef
name|BIN_INFO_INIT_bin_yes
undef|#
directive|undef
name|BIN_INFO_INIT_bin_no
undef|#
directive|undef
name|SC
block|}
end_function

begin_function
specifier|static
name|bool
name|small_run_size_init
parameter_list|(
name|void
parameter_list|)
block|{
name|assert
argument_list|(
name|small_maxrun
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|small_run_tab
operator|=
operator|(
name|bool
operator|*
operator|)
name|base_alloc
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
name|bool
argument_list|)
operator|*
operator|(
name|small_maxrun
operator|>>
name|LG_PAGE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|small_run_tab
operator|==
name|NULL
condition|)
return|return
operator|(
name|true
operator|)
return|;
define|#
directive|define
name|TAB_INIT_bin_yes
parameter_list|(
name|index
parameter_list|,
name|size
parameter_list|)
value|{					\ 		arena_bin_info_t *bin_info =&arena_bin_info[index];	\ 		small_run_tab[bin_info->run_size>> LG_PAGE] = true;	\ 	}
define|#
directive|define
name|TAB_INIT_bin_no
parameter_list|(
name|index
parameter_list|,
name|size
parameter_list|)
define|#
directive|define
name|SC
parameter_list|(
name|index
parameter_list|,
name|lg_grp
parameter_list|,
name|lg_delta
parameter_list|,
name|ndelta
parameter_list|,
name|bin
parameter_list|,
name|lg_delta_lookup
parameter_list|)
define|\
value|TAB_INIT_bin_##bin(index, (ZU(1)<<lg_grp) + (ZU(ndelta)<<lg_delta))
name|SIZE_CLASSES
undef|#
directive|undef
name|TAB_INIT_bin_yes
undef|#
directive|undef
name|TAB_INIT_bin_no
undef|#
directive|undef
name|SC
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|run_quantize_init
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|run_quantize_max
operator|=
name|chunksize
operator|+
name|large_pad
expr_stmt|;
name|run_quantize_floor_tab
operator|=
operator|(
name|size_t
operator|*
operator|)
name|base_alloc
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|*
operator|(
name|run_quantize_max
operator|>>
name|LG_PAGE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|run_quantize_floor_tab
operator|==
name|NULL
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|run_quantize_ceil_tab
operator|=
operator|(
name|size_t
operator|*
operator|)
name|base_alloc
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|*
operator|(
name|run_quantize_max
operator|>>
name|LG_PAGE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|run_quantize_ceil_tab
operator|==
name|NULL
condition|)
return|return
operator|(
name|true
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|run_quantize_max
operator|>>
name|LG_PAGE
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|run_size
init|=
name|i
operator|<<
name|LG_PAGE
decl_stmt|;
name|run_quantize_floor_tab
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|run_quantize_floor_compute
argument_list|(
name|run_size
argument_list|)
expr_stmt|;
name|run_quantize_ceil_tab
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|run_quantize_ceil_compute
argument_list|(
name|run_size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|arena_boot
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|arena_lg_dirty_mult_default_set
argument_list|(
name|opt_lg_dirty_mult
argument_list|)
expr_stmt|;
name|arena_decay_time_default_set
argument_list|(
name|opt_decay_time
argument_list|)
expr_stmt|;
comment|/* 	 * Compute the header size such that it is large enough to contain the 	 * page map.  The page map is biased to omit entries for the header 	 * itself, so some iteration is necessary to compute the map bias. 	 * 	 * 1) Compute safe header_size and map_bias values that include enough 	 *    space for an unbiased page map. 	 * 2) Refine map_bias based on (1) to omit the header pages in the page 	 *    map.  The resulting map_bias may be one too small. 	 * 3) Refine map_bias based on (2).  The result will be>= the result 	 *    from (2), and will always be correct. 	 */
name|map_bias
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|header_size
init|=
name|offsetof
argument_list|(
name|arena_chunk_t
argument_list|,
name|map_bits
argument_list|)
operator|+
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|arena_chunk_map_bits_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|arena_chunk_map_misc_t
argument_list|)
operator|)
operator|*
operator|(
name|chunk_npages
operator|-
name|map_bias
operator|)
operator|)
decl_stmt|;
name|map_bias
operator|=
operator|(
name|header_size
operator|+
name|PAGE_MASK
operator|)
operator|>>
name|LG_PAGE
expr_stmt|;
block|}
name|assert
argument_list|(
name|map_bias
operator|>
literal|0
argument_list|)
expr_stmt|;
name|map_misc_offset
operator|=
name|offsetof
argument_list|(
name|arena_chunk_t
argument_list|,
name|map_bits
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|arena_chunk_map_bits_t
argument_list|)
operator|*
operator|(
name|chunk_npages
operator|-
name|map_bias
operator|)
expr_stmt|;
name|arena_maxrun
operator|=
name|chunksize
operator|-
operator|(
name|map_bias
operator|<<
name|LG_PAGE
operator|)
expr_stmt|;
name|assert
argument_list|(
name|arena_maxrun
operator|>
literal|0
argument_list|)
expr_stmt|;
name|large_maxclass
operator|=
name|index2size
argument_list|(
name|size2index
argument_list|(
name|chunksize
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|large_maxclass
operator|>
name|arena_maxrun
condition|)
block|{
comment|/* 		 * For small chunk sizes it's possible for there to be fewer 		 * non-header pages available than are necessary to serve the 		 * size classes just below chunksize. 		 */
name|large_maxclass
operator|=
name|arena_maxrun
expr_stmt|;
block|}
name|assert
argument_list|(
name|large_maxclass
operator|>
literal|0
argument_list|)
expr_stmt|;
name|nlclasses
operator|=
name|size2index
argument_list|(
name|large_maxclass
argument_list|)
operator|-
name|size2index
argument_list|(
name|SMALL_MAXCLASS
argument_list|)
expr_stmt|;
name|nhclasses
operator|=
name|NSIZES
operator|-
name|nlclasses
operator|-
name|NBINS
expr_stmt|;
name|bin_info_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|small_run_size_init
argument_list|()
condition|)
return|return
operator|(
name|true
operator|)
return|;
if|if
condition|(
name|run_quantize_init
argument_list|()
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|runs_avail_bias
operator|=
name|size2index
argument_list|(
name|PAGE
argument_list|)
expr_stmt|;
name|runs_avail_nclasses
operator|=
name|size2index
argument_list|(
name|run_quantize_max
argument_list|)
operator|+
literal|1
operator|-
name|runs_avail_bias
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
name|void
name|arena_prefork0
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|malloc_mutex_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_prefork1
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|malloc_mutex_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|chunks_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_prefork2
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|malloc_mutex_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|node_cache_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_prefork3
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
name|malloc_mutex_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|malloc_mutex_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|huge_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_postfork_parent
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|malloc_mutex_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|huge_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
name|malloc_mutex_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|node_cache_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|chunks_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_postfork_child
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|malloc_mutex_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|huge_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
name|malloc_mutex_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|node_cache_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|chunks_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

