begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|JEMALLOC_ARENA_C_
end_define

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_preamble.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_internal_includes.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/assert.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/extent_dss.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/extent_mmap.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/mutex.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/rtree.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/size_classes.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/util.h"
end_include

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/* Data. */
end_comment

begin_comment
comment|/*  * Define names for both unininitialized and initialized phases, so that  * options and mallctl processing are straightforward.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|percpu_arena_mode_names
index|[]
init|=
block|{
literal|"percpu"
block|,
literal|"phycpu"
block|,
literal|"disabled"
block|,
literal|"percpu"
block|,
literal|"phycpu"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|percpu_arena_mode_t
name|opt_percpu_arena
init|=
name|PERCPU_ARENA_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ssize_t
name|opt_dirty_decay_ms
init|=
name|DIRTY_DECAY_MS_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ssize_t
name|opt_muzzy_decay_ms
init|=
name|MUZZY_DECAY_MS_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|atomic_zd_t
name|dirty_decay_ms_default
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|atomic_zd_t
name|muzzy_decay_ms_default
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|arena_bin_info_t
name|arena_bin_info
index|[
name|NBINS
index|]
init|=
block|{
define|#
directive|define
name|BIN_INFO_bin_yes
parameter_list|(
name|reg_size
parameter_list|,
name|slab_size
parameter_list|,
name|nregs
parameter_list|)
define|\
value|{reg_size, slab_size, nregs, BITMAP_INFO_INITIALIZER(nregs)},
define|#
directive|define
name|BIN_INFO_bin_no
parameter_list|(
name|reg_size
parameter_list|,
name|slab_size
parameter_list|,
name|nregs
parameter_list|)
define|#
directive|define
name|SC
parameter_list|(
name|index
parameter_list|,
name|lg_grp
parameter_list|,
name|lg_delta
parameter_list|,
name|ndelta
parameter_list|,
name|psz
parameter_list|,
name|bin
parameter_list|,
name|pgs
parameter_list|,		\
name|lg_delta_lookup
parameter_list|)
define|\
value|BIN_INFO_bin_##bin((1U<<lg_grp) + (ndelta<<lg_delta),		\ 	    (pgs<< LG_PAGE), (pgs<< LG_PAGE) / ((1U<<lg_grp) +	\ 	    (ndelta<<lg_delta)))
name|SIZE_CLASSES
undef|#
directive|undef
name|BIN_INFO_bin_yes
undef|#
directive|undef
name|BIN_INFO_bin_no
undef|#
directive|undef
name|SC
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|uint64_t
name|h_steps
index|[
name|SMOOTHSTEP_NSTEPS
index|]
init|=
block|{
define|#
directive|define
name|STEP
parameter_list|(
name|step
parameter_list|,
name|h
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|h,
name|SMOOTHSTEP
undef|#
directive|undef
name|STEP
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Function prototypes for static functions that are referenced prior to  * definition.  */
end_comment

begin_function_decl
specifier|static
name|void
name|arena_decay_to_limit
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_decay_t
modifier|*
name|decay
parameter_list|,
name|extents_t
modifier|*
name|extents
parameter_list|,
name|bool
name|all
parameter_list|,
name|size_t
name|npages_limit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arena_decay_dirty
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|bool
name|is_background_thread
parameter_list|,
name|bool
name|all
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_dalloc_bin_slab
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|extent_t
modifier|*
name|slab
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_bin_lower_slab
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|extent_t
modifier|*
name|slab
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/******************************************************************************/
end_comment

begin_function
specifier|static
name|bool
name|arena_stats_init
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_stats_t
modifier|*
name|arena_stats
parameter_list|)
block|{
if|if
condition|(
name|config_debug
condition|)
block|{
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|arena_stats_t
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|assert
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|arena_stats
operator|)
index|[
name|i
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|JEMALLOC_ATOMIC_U64
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|arena_stats
operator|->
name|mtx
argument_list|,
literal|"arena_stats"
argument_list|,
name|WITNESS_RANK_ARENA_STATS
argument_list|,
name|malloc_mutex_rank_exclusive
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
endif|#
directive|endif
comment|/* Memory is zeroed, so there is no need to clear stats. */
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_stats_lock
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_stats_t
modifier|*
name|arena_stats
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|JEMALLOC_ATOMIC_U64
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena_stats
operator|->
name|mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|arena_stats_unlock
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_stats_t
modifier|*
name|arena_stats
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|JEMALLOC_ATOMIC_U64
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena_stats
operator|->
name|mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|arena_stats_read_u64
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_stats_t
modifier|*
name|arena_stats
parameter_list|,
name|arena_stats_u64_t
modifier|*
name|p
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|JEMALLOC_ATOMIC_U64
return|return
name|atomic_load_u64
argument_list|(
name|p
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
return|;
else|#
directive|else
name|malloc_mutex_assert_owner
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena_stats
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|*
name|p
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|arena_stats_add_u64
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_stats_t
modifier|*
name|arena_stats
parameter_list|,
name|arena_stats_u64_t
modifier|*
name|p
parameter_list|,
name|uint64_t
name|x
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|JEMALLOC_ATOMIC_U64
name|atomic_fetch_add_u64
argument_list|(
name|p
argument_list|,
name|x
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
else|#
directive|else
name|malloc_mutex_assert_owner
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena_stats
operator|->
name|mtx
argument_list|)
expr_stmt|;
operator|*
name|p
operator|+=
name|x
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|UNUSED
specifier|static
name|void
name|arena_stats_sub_u64
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_stats_t
modifier|*
name|arena_stats
parameter_list|,
name|arena_stats_u64_t
modifier|*
name|p
parameter_list|,
name|uint64_t
name|x
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|JEMALLOC_ATOMIC_U64
name|UNUSED
name|uint64_t
name|r
init|=
name|atomic_fetch_sub_u64
argument_list|(
name|p
argument_list|,
name|x
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|r
operator|-
name|x
operator|<=
name|r
argument_list|)
expr_stmt|;
else|#
directive|else
name|malloc_mutex_assert_owner
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena_stats
operator|->
name|mtx
argument_list|)
expr_stmt|;
operator|*
name|p
operator|-=
name|x
expr_stmt|;
name|assert
argument_list|(
operator|*
name|p
operator|+
name|x
operator|>=
operator|*
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Non-atomically sets *dst += src.  *dst needs external synchronization.  * This lets us avoid the cost of a fetch_add when its unnecessary (note that  * the types here are atomic).  */
end_comment

begin_function
specifier|static
name|void
name|arena_stats_accum_u64
parameter_list|(
name|arena_stats_u64_t
modifier|*
name|dst
parameter_list|,
name|uint64_t
name|src
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|JEMALLOC_ATOMIC_U64
name|uint64_t
name|cur_dst
init|=
name|atomic_load_u64
argument_list|(
name|dst
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
decl_stmt|;
name|atomic_store_u64
argument_list|(
name|dst
argument_list|,
name|src
operator|+
name|cur_dst
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
name|dst
operator|+=
name|src
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|size_t
name|arena_stats_read_zu
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_stats_t
modifier|*
name|arena_stats
parameter_list|,
name|atomic_zu_t
modifier|*
name|p
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|JEMALLOC_ATOMIC_U64
return|return
name|atomic_load_zu
argument_list|(
name|p
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
return|;
else|#
directive|else
name|malloc_mutex_assert_owner
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena_stats
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
name|atomic_load_zu
argument_list|(
name|p
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|arena_stats_add_zu
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_stats_t
modifier|*
name|arena_stats
parameter_list|,
name|atomic_zu_t
modifier|*
name|p
parameter_list|,
name|size_t
name|x
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|JEMALLOC_ATOMIC_U64
name|atomic_fetch_add_zu
argument_list|(
name|p
argument_list|,
name|x
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
else|#
directive|else
name|malloc_mutex_assert_owner
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena_stats
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|size_t
name|cur
init|=
name|atomic_load_zu
argument_list|(
name|p
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
decl_stmt|;
name|atomic_store_zu
argument_list|(
name|p
argument_list|,
name|cur
operator|+
name|x
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|arena_stats_sub_zu
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_stats_t
modifier|*
name|arena_stats
parameter_list|,
name|atomic_zu_t
modifier|*
name|p
parameter_list|,
name|size_t
name|x
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|JEMALLOC_ATOMIC_U64
name|UNUSED
name|size_t
name|r
init|=
name|atomic_fetch_sub_zu
argument_list|(
name|p
argument_list|,
name|x
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|r
operator|-
name|x
operator|<=
name|r
argument_list|)
expr_stmt|;
else|#
directive|else
name|malloc_mutex_assert_owner
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena_stats
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|size_t
name|cur
init|=
name|atomic_load_zu
argument_list|(
name|p
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
decl_stmt|;
name|atomic_store_zu
argument_list|(
name|p
argument_list|,
name|cur
operator|-
name|x
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Like the _u64 variant, needs an externally synchronized *dst. */
end_comment

begin_function
specifier|static
name|void
name|arena_stats_accum_zu
parameter_list|(
name|atomic_zu_t
modifier|*
name|dst
parameter_list|,
name|size_t
name|src
parameter_list|)
block|{
name|size_t
name|cur_dst
init|=
name|atomic_load_zu
argument_list|(
name|dst
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
decl_stmt|;
name|atomic_store_zu
argument_list|(
name|dst
argument_list|,
name|src
operator|+
name|cur_dst
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_stats_large_nrequests_add
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_stats_t
modifier|*
name|arena_stats
parameter_list|,
name|szind_t
name|szind
parameter_list|,
name|uint64_t
name|nrequests
parameter_list|)
block|{
name|arena_stats_lock
argument_list|(
name|tsdn
argument_list|,
name|arena_stats
argument_list|)
expr_stmt|;
name|arena_stats_add_u64
argument_list|(
name|tsdn
argument_list|,
name|arena_stats
argument_list|,
operator|&
name|arena_stats
operator|->
name|lstats
index|[
name|szind
operator|-
name|NBINS
index|]
operator|.
name|nrequests
argument_list|,
name|nrequests
argument_list|)
expr_stmt|;
name|arena_stats_unlock
argument_list|(
name|tsdn
argument_list|,
name|arena_stats
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_stats_mapped_add
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_stats_t
modifier|*
name|arena_stats
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|arena_stats_lock
argument_list|(
name|tsdn
argument_list|,
name|arena_stats
argument_list|)
expr_stmt|;
name|arena_stats_add_zu
argument_list|(
name|tsdn
argument_list|,
name|arena_stats
argument_list|,
operator|&
name|arena_stats
operator|->
name|mapped
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|arena_stats_unlock
argument_list|(
name|tsdn
argument_list|,
name|arena_stats
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_basic_stats_merge
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|unsigned
modifier|*
name|nthreads
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|dss
parameter_list|,
name|ssize_t
modifier|*
name|dirty_decay_ms
parameter_list|,
name|ssize_t
modifier|*
name|muzzy_decay_ms
parameter_list|,
name|size_t
modifier|*
name|nactive
parameter_list|,
name|size_t
modifier|*
name|ndirty
parameter_list|,
name|size_t
modifier|*
name|nmuzzy
parameter_list|)
block|{
operator|*
name|nthreads
operator|+=
name|arena_nthreads_get
argument_list|(
name|arena
argument_list|,
name|false
argument_list|)
expr_stmt|;
operator|*
name|dss
operator|=
name|dss_prec_names
index|[
name|arena_dss_prec_get
argument_list|(
name|arena
argument_list|)
index|]
expr_stmt|;
operator|*
name|dirty_decay_ms
operator|=
name|arena_dirty_decay_ms_get
argument_list|(
name|arena
argument_list|)
expr_stmt|;
operator|*
name|muzzy_decay_ms
operator|=
name|arena_muzzy_decay_ms_get
argument_list|(
name|arena
argument_list|)
expr_stmt|;
operator|*
name|nactive
operator|+=
name|atomic_load_zu
argument_list|(
operator|&
name|arena
operator|->
name|nactive
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
operator|*
name|ndirty
operator|+=
name|extents_npages_get
argument_list|(
operator|&
name|arena
operator|->
name|extents_dirty
argument_list|)
expr_stmt|;
operator|*
name|nmuzzy
operator|+=
name|extents_npages_get
argument_list|(
operator|&
name|arena
operator|->
name|extents_muzzy
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_stats_merge
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|unsigned
modifier|*
name|nthreads
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|dss
parameter_list|,
name|ssize_t
modifier|*
name|dirty_decay_ms
parameter_list|,
name|ssize_t
modifier|*
name|muzzy_decay_ms
parameter_list|,
name|size_t
modifier|*
name|nactive
parameter_list|,
name|size_t
modifier|*
name|ndirty
parameter_list|,
name|size_t
modifier|*
name|nmuzzy
parameter_list|,
name|arena_stats_t
modifier|*
name|astats
parameter_list|,
name|malloc_bin_stats_t
modifier|*
name|bstats
parameter_list|,
name|malloc_large_stats_t
modifier|*
name|lstats
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_stats
argument_list|)
expr_stmt|;
name|arena_basic_stats_merge
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|nthreads
argument_list|,
name|dss
argument_list|,
name|dirty_decay_ms
argument_list|,
name|muzzy_decay_ms
argument_list|,
name|nactive
argument_list|,
name|ndirty
argument_list|,
name|nmuzzy
argument_list|)
expr_stmt|;
name|size_t
name|base_allocated
decl_stmt|,
name|base_resident
decl_stmt|,
name|base_mapped
decl_stmt|;
name|base_stats_get
argument_list|(
name|tsdn
argument_list|,
name|arena
operator|->
name|base
argument_list|,
operator|&
name|base_allocated
argument_list|,
operator|&
name|base_resident
argument_list|,
operator|&
name|base_mapped
argument_list|)
expr_stmt|;
name|arena_stats_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|)
expr_stmt|;
name|arena_stats_accum_zu
argument_list|(
operator|&
name|astats
operator|->
name|mapped
argument_list|,
name|base_mapped
operator|+
name|arena_stats_read_zu
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|,
operator|&
name|arena
operator|->
name|stats
operator|.
name|mapped
argument_list|)
argument_list|)
expr_stmt|;
name|arena_stats_accum_zu
argument_list|(
operator|&
name|astats
operator|->
name|retained
argument_list|,
name|extents_npages_get
argument_list|(
operator|&
name|arena
operator|->
name|extents_retained
argument_list|)
operator|<<
name|LG_PAGE
argument_list|)
expr_stmt|;
name|arena_stats_accum_u64
argument_list|(
operator|&
name|astats
operator|->
name|decay_dirty
operator|.
name|npurge
argument_list|,
name|arena_stats_read_u64
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|,
operator|&
name|arena
operator|->
name|stats
operator|.
name|decay_dirty
operator|.
name|npurge
argument_list|)
argument_list|)
expr_stmt|;
name|arena_stats_accum_u64
argument_list|(
operator|&
name|astats
operator|->
name|decay_dirty
operator|.
name|nmadvise
argument_list|,
name|arena_stats_read_u64
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|,
operator|&
name|arena
operator|->
name|stats
operator|.
name|decay_dirty
operator|.
name|nmadvise
argument_list|)
argument_list|)
expr_stmt|;
name|arena_stats_accum_u64
argument_list|(
operator|&
name|astats
operator|->
name|decay_dirty
operator|.
name|purged
argument_list|,
name|arena_stats_read_u64
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|,
operator|&
name|arena
operator|->
name|stats
operator|.
name|decay_dirty
operator|.
name|purged
argument_list|)
argument_list|)
expr_stmt|;
name|arena_stats_accum_u64
argument_list|(
operator|&
name|astats
operator|->
name|decay_muzzy
operator|.
name|npurge
argument_list|,
name|arena_stats_read_u64
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|,
operator|&
name|arena
operator|->
name|stats
operator|.
name|decay_muzzy
operator|.
name|npurge
argument_list|)
argument_list|)
expr_stmt|;
name|arena_stats_accum_u64
argument_list|(
operator|&
name|astats
operator|->
name|decay_muzzy
operator|.
name|nmadvise
argument_list|,
name|arena_stats_read_u64
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|,
operator|&
name|arena
operator|->
name|stats
operator|.
name|decay_muzzy
operator|.
name|nmadvise
argument_list|)
argument_list|)
expr_stmt|;
name|arena_stats_accum_u64
argument_list|(
operator|&
name|astats
operator|->
name|decay_muzzy
operator|.
name|purged
argument_list|,
name|arena_stats_read_u64
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|,
operator|&
name|arena
operator|->
name|stats
operator|.
name|decay_muzzy
operator|.
name|purged
argument_list|)
argument_list|)
expr_stmt|;
name|arena_stats_accum_zu
argument_list|(
operator|&
name|astats
operator|->
name|base
argument_list|,
name|base_allocated
argument_list|)
expr_stmt|;
name|arena_stats_accum_zu
argument_list|(
operator|&
name|astats
operator|->
name|internal
argument_list|,
name|arena_internal_get
argument_list|(
name|arena
argument_list|)
argument_list|)
expr_stmt|;
name|arena_stats_accum_zu
argument_list|(
operator|&
name|astats
operator|->
name|resident
argument_list|,
name|base_resident
operator|+
operator|(
operator|(
operator|(
name|atomic_load_zu
argument_list|(
operator|&
name|arena
operator|->
name|nactive
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
operator|+
name|extents_npages_get
argument_list|(
operator|&
name|arena
operator|->
name|extents_dirty
argument_list|)
operator|+
name|extents_npages_get
argument_list|(
operator|&
name|arena
operator|->
name|extents_muzzy
argument_list|)
operator|)
operator|<<
name|LG_PAGE
operator|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|szind_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NSIZES
operator|-
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
name|nmalloc
init|=
name|arena_stats_read_u64
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|,
operator|&
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|i
index|]
operator|.
name|nmalloc
argument_list|)
decl_stmt|;
name|arena_stats_accum_u64
argument_list|(
operator|&
name|lstats
index|[
name|i
index|]
operator|.
name|nmalloc
argument_list|,
name|nmalloc
argument_list|)
expr_stmt|;
name|arena_stats_accum_u64
argument_list|(
operator|&
name|astats
operator|->
name|nmalloc_large
argument_list|,
name|nmalloc
argument_list|)
expr_stmt|;
name|uint64_t
name|ndalloc
init|=
name|arena_stats_read_u64
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|,
operator|&
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|i
index|]
operator|.
name|ndalloc
argument_list|)
decl_stmt|;
name|arena_stats_accum_u64
argument_list|(
operator|&
name|lstats
index|[
name|i
index|]
operator|.
name|ndalloc
argument_list|,
name|ndalloc
argument_list|)
expr_stmt|;
name|arena_stats_accum_u64
argument_list|(
operator|&
name|astats
operator|->
name|ndalloc_large
argument_list|,
name|ndalloc
argument_list|)
expr_stmt|;
name|uint64_t
name|nrequests
init|=
name|arena_stats_read_u64
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|,
operator|&
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|i
index|]
operator|.
name|nrequests
argument_list|)
decl_stmt|;
name|arena_stats_accum_u64
argument_list|(
operator|&
name|lstats
index|[
name|i
index|]
operator|.
name|nrequests
argument_list|,
name|nmalloc
operator|+
name|nrequests
argument_list|)
expr_stmt|;
name|arena_stats_accum_u64
argument_list|(
operator|&
name|astats
operator|->
name|nrequests_large
argument_list|,
name|nmalloc
operator|+
name|nrequests
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|nmalloc
operator|>=
name|ndalloc
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|nmalloc
operator|-
name|ndalloc
operator|<=
name|SIZE_T_MAX
argument_list|)
expr_stmt|;
name|size_t
name|curlextents
init|=
call|(
name|size_t
call|)
argument_list|(
name|nmalloc
operator|-
name|ndalloc
argument_list|)
decl_stmt|;
name|lstats
index|[
name|i
index|]
operator|.
name|curlextents
operator|+=
name|curlextents
expr_stmt|;
name|arena_stats_accum_zu
argument_list|(
operator|&
name|astats
operator|->
name|allocated_large
argument_list|,
name|curlextents
operator|*
name|sz_index2size
argument_list|(
name|NBINS
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|arena_stats_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|)
expr_stmt|;
comment|/* tcache_bytes counts currently cached bytes. */
name|atomic_store_zu
argument_list|(
operator|&
name|astats
operator|->
name|tcache_bytes
argument_list|,
literal|0
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|tcache_ql_mtx
argument_list|)
expr_stmt|;
name|tcache_t
modifier|*
name|tcache
decl_stmt|;
name|ql_foreach
argument_list|(
argument|tcache
argument_list|,
argument|&arena->tcache_ql
argument_list|,
argument|link
argument_list|)
block|{
name|szind_t
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
name|tcache_bin_t
modifier|*
name|tbin
init|=
name|tcache_small_bin_get
argument_list|(
name|tcache
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|arena_stats_accum_zu
argument_list|(
operator|&
name|astats
operator|->
name|tcache_bytes
argument_list|,
name|tbin
operator|->
name|ncached
operator|*
name|sz_index2size
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|nhbins
condition|;
name|i
operator|++
control|)
block|{
name|tcache_bin_t
modifier|*
name|tbin
init|=
name|tcache_large_bin_get
argument_list|(
name|tcache
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|arena_stats_accum_zu
argument_list|(
operator|&
name|astats
operator|->
name|tcache_bytes
argument_list|,
name|tbin
operator|->
name|ncached
operator|*
name|sz_index2size
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|malloc_mutex_prof_read
argument_list|(
name|tsdn
argument_list|,
operator|&
name|astats
operator|->
name|mutex_prof_data
index|[
name|arena_prof_mutex_tcache_list
index|]
argument_list|,
operator|&
name|arena
operator|->
name|tcache_ql_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|tcache_ql_mtx
argument_list|)
expr_stmt|;
define|#
directive|define
name|READ_ARENA_MUTEX_PROF_DATA
parameter_list|(
name|mtx
parameter_list|,
name|ind
parameter_list|)
define|\
value|malloc_mutex_lock(tsdn,&arena->mtx);				\     malloc_mutex_prof_read(tsdn,&astats->mutex_prof_data[ind],		\&arena->mtx);							\     malloc_mutex_unlock(tsdn,&arena->mtx);
comment|/* Gather per arena mutex profiling data. */
name|READ_ARENA_MUTEX_PROF_DATA
argument_list|(
name|large_mtx
argument_list|,
name|arena_prof_mutex_large
argument_list|)
expr_stmt|;
name|READ_ARENA_MUTEX_PROF_DATA
argument_list|(
argument|extent_avail_mtx
argument_list|,
argument|arena_prof_mutex_extent_avail
argument_list|)
name|READ_ARENA_MUTEX_PROF_DATA
argument_list|(
argument|extents_dirty.mtx
argument_list|,
argument|arena_prof_mutex_extents_dirty
argument_list|)
name|READ_ARENA_MUTEX_PROF_DATA
argument_list|(
argument|extents_muzzy.mtx
argument_list|,
argument|arena_prof_mutex_extents_muzzy
argument_list|)
name|READ_ARENA_MUTEX_PROF_DATA
argument_list|(
argument|extents_retained.mtx
argument_list|,
argument|arena_prof_mutex_extents_retained
argument_list|)
name|READ_ARENA_MUTEX_PROF_DATA
argument_list|(
argument|decay_dirty.mtx
argument_list|,
argument|arena_prof_mutex_decay_dirty
argument_list|)
name|READ_ARENA_MUTEX_PROF_DATA
argument_list|(
argument|decay_muzzy.mtx
argument_list|,
argument|arena_prof_mutex_decay_muzzy
argument_list|)
name|READ_ARENA_MUTEX_PROF_DATA
argument_list|(
argument|base->mtx
argument_list|,
argument|arena_prof_mutex_base
argument_list|)
undef|#
directive|undef
name|READ_ARENA_MUTEX_PROF_DATA
name|nstime_copy
argument_list|(
operator|&
name|astats
operator|->
name|uptime
argument_list|,
operator|&
name|arena
operator|->
name|create_time
argument_list|)
expr_stmt|;
name|nstime_update
argument_list|(
operator|&
name|astats
operator|->
name|uptime
argument_list|)
expr_stmt|;
name|nstime_subtract
argument_list|(
operator|&
name|astats
operator|->
name|uptime
argument_list|,
operator|&
name|arena
operator|->
name|create_time
argument_list|)
expr_stmt|;
for|for
control|(
name|szind_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
name|arena_bin_t
modifier|*
name|bin
init|=
operator|&
name|arena
operator|->
name|bins
index|[
name|i
index|]
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
name|malloc_mutex_prof_read
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bstats
index|[
name|i
index|]
operator|.
name|mutex_data
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
name|bstats
index|[
name|i
index|]
operator|.
name|nmalloc
operator|+=
name|bin
operator|->
name|stats
operator|.
name|nmalloc
expr_stmt|;
name|bstats
index|[
name|i
index|]
operator|.
name|ndalloc
operator|+=
name|bin
operator|->
name|stats
operator|.
name|ndalloc
expr_stmt|;
name|bstats
index|[
name|i
index|]
operator|.
name|nrequests
operator|+=
name|bin
operator|->
name|stats
operator|.
name|nrequests
expr_stmt|;
name|bstats
index|[
name|i
index|]
operator|.
name|curregs
operator|+=
name|bin
operator|->
name|stats
operator|.
name|curregs
expr_stmt|;
name|bstats
index|[
name|i
index|]
operator|.
name|nfills
operator|+=
name|bin
operator|->
name|stats
operator|.
name|nfills
expr_stmt|;
name|bstats
index|[
name|i
index|]
operator|.
name|nflushes
operator|+=
name|bin
operator|->
name|stats
operator|.
name|nflushes
expr_stmt|;
name|bstats
index|[
name|i
index|]
operator|.
name|nslabs
operator|+=
name|bin
operator|->
name|stats
operator|.
name|nslabs
expr_stmt|;
name|bstats
index|[
name|i
index|]
operator|.
name|reslabs
operator|+=
name|bin
operator|->
name|stats
operator|.
name|reslabs
expr_stmt|;
name|bstats
index|[
name|i
index|]
operator|.
name|curslabs
operator|+=
name|bin
operator|->
name|stats
operator|.
name|curslabs
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|arena_extents_dirty_dalloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|extent_hooks_t
modifier|*
modifier|*
name|r_extent_hooks
parameter_list|,
name|extent_t
modifier|*
name|extent
parameter_list|)
block|{
name|witness_assert_depth_to_rank
argument_list|(
name|tsdn_witness_tsdp_get
argument_list|(
name|tsdn
argument_list|)
argument_list|,
name|WITNESS_RANK_CORE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|extents_dalloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|r_extent_hooks
argument_list|,
operator|&
name|arena
operator|->
name|extents_dirty
argument_list|,
name|extent
argument_list|)
expr_stmt|;
if|if
condition|(
name|arena_dirty_decay_ms_get
argument_list|(
name|arena
argument_list|)
operator|==
literal|0
condition|)
block|{
name|arena_decay_dirty
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arena_background_thread_inactivity_check
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|arena_slab_reg_alloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|extent_t
modifier|*
name|slab
parameter_list|,
specifier|const
name|arena_bin_info_t
modifier|*
name|bin_info
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|arena_slab_data_t
modifier|*
name|slab_data
init|=
name|extent_slab_data_get
argument_list|(
name|slab
argument_list|)
decl_stmt|;
name|size_t
name|regind
decl_stmt|;
name|assert
argument_list|(
name|extent_nfree_get
argument_list|(
name|slab
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|bitmap_full
argument_list|(
name|slab_data
operator|->
name|bitmap
argument_list|,
operator|&
name|bin_info
operator|->
name|bitmap_info
argument_list|)
argument_list|)
expr_stmt|;
name|regind
operator|=
name|bitmap_sfu
argument_list|(
name|slab_data
operator|->
name|bitmap
argument_list|,
operator|&
name|bin_info
operator|->
name|bitmap_info
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|extent_addr_get
argument_list|(
name|slab
argument_list|)
operator|+
call|(
name|uintptr_t
call|)
argument_list|(
name|bin_info
operator|->
name|reg_size
operator|*
name|regind
argument_list|)
operator|)
expr_stmt|;
name|extent_nfree_dec
argument_list|(
name|slab
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|JEMALLOC_JET
end_ifndef

begin_function
specifier|static
endif|#
directive|endif
name|size_t
name|arena_slab_regind
parameter_list|(
name|extent_t
modifier|*
name|slab
parameter_list|,
name|szind_t
name|binind
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|size_t
name|diff
decl_stmt|,
name|regind
decl_stmt|;
comment|/* Freeing a pointer outside the slab can cause assertion failure. */
name|assert
argument_list|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|>=
operator|(
name|uintptr_t
operator|)
name|extent_addr_get
argument_list|(
name|slab
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|<
operator|(
name|uintptr_t
operator|)
name|extent_past_get
argument_list|(
name|slab
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Freeing an interior pointer can cause assertion failure. */
name|assert
argument_list|(
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|extent_addr_get
argument_list|(
name|slab
argument_list|)
operator|)
operator|%
operator|(
name|uintptr_t
operator|)
name|arena_bin_info
index|[
name|binind
index|]
operator|.
name|reg_size
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Avoid doing division with a variable divisor. */
name|diff
operator|=
call|(
name|size_t
call|)
argument_list|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|extent_addr_get
argument_list|(
name|slab
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|binind
condition|)
block|{
define|#
directive|define
name|REGIND_bin_yes
parameter_list|(
name|index
parameter_list|,
name|reg_size
parameter_list|)
define|\
value|case index:							\ 		regind = diff / (reg_size);				\ 		assert(diff == regind * (reg_size));			\ 		break;
define|#
directive|define
name|REGIND_bin_no
parameter_list|(
name|index
parameter_list|,
name|reg_size
parameter_list|)
define|#
directive|define
name|SC
parameter_list|(
name|index
parameter_list|,
name|lg_grp
parameter_list|,
name|lg_delta
parameter_list|,
name|ndelta
parameter_list|,
name|psz
parameter_list|,
name|bin
parameter_list|,
name|pgs
parameter_list|,		\
name|lg_delta_lookup
parameter_list|)
define|\
value|REGIND_bin_##bin(index, (1U<<lg_grp) + (ndelta<<lg_delta))
name|SIZE_CLASSES
undef|#
directive|undef
name|REGIND_bin_yes
undef|#
directive|undef
name|REGIND_bin_no
undef|#
directive|undef
name|SC
default|default:
name|not_reached
argument_list|()
expr_stmt|;
block|}
name|assert
argument_list|(
name|regind
operator|<
name|arena_bin_info
index|[
name|binind
index|]
operator|.
name|nregs
argument_list|)
expr_stmt|;
return|return
name|regind
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_slab_reg_dalloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|extent_t
modifier|*
name|slab
parameter_list|,
name|arena_slab_data_t
modifier|*
name|slab_data
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|szind_t
name|binind
init|=
name|extent_szind_get
argument_list|(
name|slab
argument_list|)
decl_stmt|;
specifier|const
name|arena_bin_info_t
modifier|*
name|bin_info
init|=
operator|&
name|arena_bin_info
index|[
name|binind
index|]
decl_stmt|;
name|size_t
name|regind
init|=
name|arena_slab_regind
argument_list|(
name|slab
argument_list|,
name|binind
argument_list|,
name|ptr
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|extent_nfree_get
argument_list|(
name|slab
argument_list|)
operator|<
name|bin_info
operator|->
name|nregs
argument_list|)
expr_stmt|;
comment|/* Freeing an unallocated pointer can cause assertion failure. */
name|assert
argument_list|(
name|bitmap_get
argument_list|(
name|slab_data
operator|->
name|bitmap
argument_list|,
operator|&
name|bin_info
operator|->
name|bitmap_info
argument_list|,
name|regind
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_unset
argument_list|(
name|slab_data
operator|->
name|bitmap
argument_list|,
operator|&
name|bin_info
operator|->
name|bitmap_info
argument_list|,
name|regind
argument_list|)
expr_stmt|;
name|extent_nfree_inc
argument_list|(
name|slab
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_nactive_add
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|add_pages
parameter_list|)
block|{
name|atomic_fetch_add_zu
argument_list|(
operator|&
name|arena
operator|->
name|nactive
argument_list|,
name|add_pages
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_nactive_sub
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|sub_pages
parameter_list|)
block|{
name|assert
argument_list|(
name|atomic_load_zu
argument_list|(
operator|&
name|arena
operator|->
name|nactive
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
operator|>=
name|sub_pages
argument_list|)
expr_stmt|;
name|atomic_fetch_sub_zu
argument_list|(
operator|&
name|arena
operator|->
name|nactive
argument_list|,
name|sub_pages
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_large_malloc_stats_update
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|usize
parameter_list|)
block|{
name|szind_t
name|index
decl_stmt|,
name|hindex
decl_stmt|;
name|cassert
argument_list|(
name|config_stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|usize
operator|<
name|LARGE_MINCLASS
condition|)
block|{
name|usize
operator|=
name|LARGE_MINCLASS
expr_stmt|;
block|}
name|index
operator|=
name|sz_size2index
argument_list|(
name|usize
argument_list|)
expr_stmt|;
name|hindex
operator|=
operator|(
name|index
operator|>=
name|NBINS
operator|)
condition|?
name|index
operator|-
name|NBINS
else|:
literal|0
expr_stmt|;
name|arena_stats_add_u64
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|,
operator|&
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|hindex
index|]
operator|.
name|nmalloc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_large_dalloc_stats_update
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|usize
parameter_list|)
block|{
name|szind_t
name|index
decl_stmt|,
name|hindex
decl_stmt|;
name|cassert
argument_list|(
name|config_stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|usize
operator|<
name|LARGE_MINCLASS
condition|)
block|{
name|usize
operator|=
name|LARGE_MINCLASS
expr_stmt|;
block|}
name|index
operator|=
name|sz_size2index
argument_list|(
name|usize
argument_list|)
expr_stmt|;
name|hindex
operator|=
operator|(
name|index
operator|>=
name|NBINS
operator|)
condition|?
name|index
operator|-
name|NBINS
else|:
literal|0
expr_stmt|;
name|arena_stats_add_u64
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|,
operator|&
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|hindex
index|]
operator|.
name|ndalloc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_large_ralloc_stats_update
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|oldusize
parameter_list|,
name|size_t
name|usize
parameter_list|)
block|{
name|arena_large_dalloc_stats_update
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|oldusize
argument_list|)
expr_stmt|;
name|arena_large_malloc_stats_update
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|extent_t
modifier|*
name|arena_extent_alloc_large
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
modifier|*
name|zero
parameter_list|)
block|{
name|extent_hooks_t
modifier|*
name|extent_hooks
init|=
name|EXTENT_HOOKS_INITIALIZER
decl_stmt|;
name|witness_assert_depth_to_rank
argument_list|(
name|tsdn_witness_tsdp_get
argument_list|(
name|tsdn
argument_list|)
argument_list|,
name|WITNESS_RANK_CORE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|szind_t
name|szind
init|=
name|sz_size2index
argument_list|(
name|usize
argument_list|)
decl_stmt|;
name|size_t
name|mapped_add
decl_stmt|;
name|bool
name|commit
init|=
name|true
decl_stmt|;
name|extent_t
modifier|*
name|extent
init|=
name|extents_alloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|extent_hooks
argument_list|,
operator|&
name|arena
operator|->
name|extents_dirty
argument_list|,
name|NULL
argument_list|,
name|usize
argument_list|,
name|sz_large_pad
argument_list|,
name|alignment
argument_list|,
name|false
argument_list|,
name|szind
argument_list|,
name|zero
argument_list|,
operator|&
name|commit
argument_list|)
decl_stmt|;
if|if
condition|(
name|extent
operator|==
name|NULL
condition|)
block|{
name|extent
operator|=
name|extents_alloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|extent_hooks
argument_list|,
operator|&
name|arena
operator|->
name|extents_muzzy
argument_list|,
name|NULL
argument_list|,
name|usize
argument_list|,
name|sz_large_pad
argument_list|,
name|alignment
argument_list|,
name|false
argument_list|,
name|szind
argument_list|,
name|zero
argument_list|,
operator|&
name|commit
argument_list|)
expr_stmt|;
block|}
name|size_t
name|size
init|=
name|usize
operator|+
name|sz_large_pad
decl_stmt|;
if|if
condition|(
name|extent
operator|==
name|NULL
condition|)
block|{
name|extent
operator|=
name|extent_alloc_wrapper
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|extent_hooks
argument_list|,
name|NULL
argument_list|,
name|usize
argument_list|,
name|sz_large_pad
argument_list|,
name|alignment
argument_list|,
name|false
argument_list|,
name|szind
argument_list|,
name|zero
argument_list|,
operator|&
name|commit
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
comment|/* 			 * extent may be NULL on OOM, but in that case 			 * mapped_add isn't used below, so there's no need to 			 * conditionlly set it to 0 here. 			 */
name|mapped_add
operator|=
name|size
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|config_stats
condition|)
block|{
name|mapped_add
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|extent
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|config_stats
condition|)
block|{
name|arena_stats_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|)
expr_stmt|;
name|arena_large_malloc_stats_update
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|usize
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapped_add
operator|!=
literal|0
condition|)
block|{
name|arena_stats_add_zu
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|,
operator|&
name|arena
operator|->
name|stats
operator|.
name|mapped
argument_list|,
name|mapped_add
argument_list|)
expr_stmt|;
block|}
name|arena_stats_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|)
expr_stmt|;
block|}
name|arena_nactive_add
argument_list|(
name|arena
argument_list|,
name|size
operator|>>
name|LG_PAGE
argument_list|)
expr_stmt|;
block|}
return|return
name|extent
return|;
block|}
end_function

begin_function
name|void
name|arena_extent_dalloc_large_prep
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|extent_t
modifier|*
name|extent
parameter_list|)
block|{
if|if
condition|(
name|config_stats
condition|)
block|{
name|arena_stats_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|)
expr_stmt|;
name|arena_large_dalloc_stats_update
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|extent_usize_get
argument_list|(
name|extent
argument_list|)
argument_list|)
expr_stmt|;
name|arena_stats_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|)
expr_stmt|;
block|}
name|arena_nactive_sub
argument_list|(
name|arena
argument_list|,
name|extent_size_get
argument_list|(
name|extent
argument_list|)
operator|>>
name|LG_PAGE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_extent_ralloc_large_shrink
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|extent_t
modifier|*
name|extent
parameter_list|,
name|size_t
name|oldusize
parameter_list|)
block|{
name|size_t
name|usize
init|=
name|extent_usize_get
argument_list|(
name|extent
argument_list|)
decl_stmt|;
name|size_t
name|udiff
init|=
name|oldusize
operator|-
name|usize
decl_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|arena_stats_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|)
expr_stmt|;
name|arena_large_ralloc_stats_update
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|oldusize
argument_list|,
name|usize
argument_list|)
expr_stmt|;
name|arena_stats_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|)
expr_stmt|;
block|}
name|arena_nactive_sub
argument_list|(
name|arena
argument_list|,
name|udiff
operator|>>
name|LG_PAGE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_extent_ralloc_large_expand
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|extent_t
modifier|*
name|extent
parameter_list|,
name|size_t
name|oldusize
parameter_list|)
block|{
name|size_t
name|usize
init|=
name|extent_usize_get
argument_list|(
name|extent
argument_list|)
decl_stmt|;
name|size_t
name|udiff
init|=
name|usize
operator|-
name|oldusize
decl_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|arena_stats_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|)
expr_stmt|;
name|arena_large_ralloc_stats_update
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|oldusize
argument_list|,
name|usize
argument_list|)
expr_stmt|;
name|arena_stats_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|)
expr_stmt|;
block|}
name|arena_nactive_add
argument_list|(
name|arena
argument_list|,
name|udiff
operator|>>
name|LG_PAGE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|arena_decay_ms_read
parameter_list|(
name|arena_decay_t
modifier|*
name|decay
parameter_list|)
block|{
return|return
name|atomic_load_zd
argument_list|(
operator|&
name|decay
operator|->
name|time_ms
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_decay_ms_write
parameter_list|(
name|arena_decay_t
modifier|*
name|decay
parameter_list|,
name|ssize_t
name|decay_ms
parameter_list|)
block|{
name|atomic_store_zd
argument_list|(
operator|&
name|decay
operator|->
name|time_ms
argument_list|,
name|decay_ms
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_decay_deadline_init
parameter_list|(
name|arena_decay_t
modifier|*
name|decay
parameter_list|)
block|{
comment|/* 	 * Generate a new deadline that is uniformly random within the next 	 * epoch after the current one. 	 */
name|nstime_copy
argument_list|(
operator|&
name|decay
operator|->
name|deadline
argument_list|,
operator|&
name|decay
operator|->
name|epoch
argument_list|)
expr_stmt|;
name|nstime_add
argument_list|(
operator|&
name|decay
operator|->
name|deadline
argument_list|,
operator|&
name|decay
operator|->
name|interval
argument_list|)
expr_stmt|;
if|if
condition|(
name|arena_decay_ms_read
argument_list|(
name|decay
argument_list|)
operator|>
literal|0
condition|)
block|{
name|nstime_t
name|jitter
decl_stmt|;
name|nstime_init
argument_list|(
operator|&
name|jitter
argument_list|,
name|prng_range_u64
argument_list|(
operator|&
name|decay
operator|->
name|jitter_state
argument_list|,
name|nstime_ns
argument_list|(
operator|&
name|decay
operator|->
name|interval
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|nstime_add
argument_list|(
operator|&
name|decay
operator|->
name|deadline
argument_list|,
operator|&
name|jitter
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|arena_decay_deadline_reached
parameter_list|(
specifier|const
name|arena_decay_t
modifier|*
name|decay
parameter_list|,
specifier|const
name|nstime_t
modifier|*
name|time
parameter_list|)
block|{
return|return
operator|(
name|nstime_compare
argument_list|(
operator|&
name|decay
operator|->
name|deadline
argument_list|,
name|time
argument_list|)
operator|<=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|arena_decay_backlog_npages_limit
parameter_list|(
specifier|const
name|arena_decay_t
modifier|*
name|decay
parameter_list|)
block|{
name|uint64_t
name|sum
decl_stmt|;
name|size_t
name|npages_limit_backlog
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
comment|/* 	 * For each element of decay_backlog, multiply by the corresponding 	 * fixed-point smoothstep decay factor.  Sum the products, then divide 	 * to round down to the nearest whole number of pages. 	 */
name|sum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SMOOTHSTEP_NSTEPS
condition|;
name|i
operator|++
control|)
block|{
name|sum
operator|+=
name|decay
operator|->
name|backlog
index|[
name|i
index|]
operator|*
name|h_steps
index|[
name|i
index|]
expr_stmt|;
block|}
name|npages_limit_backlog
operator|=
call|(
name|size_t
call|)
argument_list|(
name|sum
operator|>>
name|SMOOTHSTEP_BFP
argument_list|)
expr_stmt|;
return|return
name|npages_limit_backlog
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_decay_backlog_update_last
parameter_list|(
name|arena_decay_t
modifier|*
name|decay
parameter_list|,
name|size_t
name|current_npages
parameter_list|)
block|{
name|size_t
name|npages_delta
init|=
operator|(
name|current_npages
operator|>
name|decay
operator|->
name|nunpurged
operator|)
condition|?
name|current_npages
operator|-
name|decay
operator|->
name|nunpurged
else|:
literal|0
decl_stmt|;
name|decay
operator|->
name|backlog
index|[
name|SMOOTHSTEP_NSTEPS
operator|-
literal|1
index|]
operator|=
name|npages_delta
expr_stmt|;
if|if
condition|(
name|config_debug
condition|)
block|{
if|if
condition|(
name|current_npages
operator|>
name|decay
operator|->
name|ceil_npages
condition|)
block|{
name|decay
operator|->
name|ceil_npages
operator|=
name|current_npages
expr_stmt|;
block|}
name|size_t
name|npages_limit
init|=
name|arena_decay_backlog_npages_limit
argument_list|(
name|decay
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|decay
operator|->
name|ceil_npages
operator|>=
name|npages_limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|decay
operator|->
name|ceil_npages
operator|>
name|npages_limit
condition|)
block|{
name|decay
operator|->
name|ceil_npages
operator|=
name|npages_limit
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arena_decay_backlog_update
parameter_list|(
name|arena_decay_t
modifier|*
name|decay
parameter_list|,
name|uint64_t
name|nadvance_u64
parameter_list|,
name|size_t
name|current_npages
parameter_list|)
block|{
if|if
condition|(
name|nadvance_u64
operator|>=
name|SMOOTHSTEP_NSTEPS
condition|)
block|{
name|memset
argument_list|(
name|decay
operator|->
name|backlog
argument_list|,
literal|0
argument_list|,
operator|(
name|SMOOTHSTEP_NSTEPS
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|nadvance_z
init|=
operator|(
name|size_t
operator|)
name|nadvance_u64
decl_stmt|;
name|assert
argument_list|(
operator|(
name|uint64_t
operator|)
name|nadvance_z
operator|==
name|nadvance_u64
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|decay
operator|->
name|backlog
argument_list|,
operator|&
name|decay
operator|->
name|backlog
index|[
name|nadvance_z
index|]
argument_list|,
operator|(
name|SMOOTHSTEP_NSTEPS
operator|-
name|nadvance_z
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nadvance_z
operator|>
literal|1
condition|)
block|{
name|memset
argument_list|(
operator|&
name|decay
operator|->
name|backlog
index|[
name|SMOOTHSTEP_NSTEPS
operator|-
name|nadvance_z
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|nadvance_z
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|arena_decay_backlog_update_last
argument_list|(
name|decay
argument_list|,
name|current_npages
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_decay_try_purge
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_decay_t
modifier|*
name|decay
parameter_list|,
name|extents_t
modifier|*
name|extents
parameter_list|,
name|size_t
name|current_npages
parameter_list|,
name|size_t
name|npages_limit
parameter_list|)
block|{
if|if
condition|(
name|current_npages
operator|>
name|npages_limit
condition|)
block|{
name|arena_decay_to_limit
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|decay
argument_list|,
name|extents
argument_list|,
name|false
argument_list|,
name|npages_limit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arena_decay_epoch_advance_helper
parameter_list|(
name|arena_decay_t
modifier|*
name|decay
parameter_list|,
specifier|const
name|nstime_t
modifier|*
name|time
parameter_list|,
name|size_t
name|current_npages
parameter_list|)
block|{
name|assert
argument_list|(
name|arena_decay_deadline_reached
argument_list|(
name|decay
argument_list|,
name|time
argument_list|)
argument_list|)
expr_stmt|;
name|nstime_t
name|delta
decl_stmt|;
name|nstime_copy
argument_list|(
operator|&
name|delta
argument_list|,
name|time
argument_list|)
expr_stmt|;
name|nstime_subtract
argument_list|(
operator|&
name|delta
argument_list|,
operator|&
name|decay
operator|->
name|epoch
argument_list|)
expr_stmt|;
name|uint64_t
name|nadvance_u64
init|=
name|nstime_divide
argument_list|(
operator|&
name|delta
argument_list|,
operator|&
name|decay
operator|->
name|interval
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|nadvance_u64
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* Add nadvance_u64 decay intervals to epoch. */
name|nstime_copy
argument_list|(
operator|&
name|delta
argument_list|,
operator|&
name|decay
operator|->
name|interval
argument_list|)
expr_stmt|;
name|nstime_imultiply
argument_list|(
operator|&
name|delta
argument_list|,
name|nadvance_u64
argument_list|)
expr_stmt|;
name|nstime_add
argument_list|(
operator|&
name|decay
operator|->
name|epoch
argument_list|,
operator|&
name|delta
argument_list|)
expr_stmt|;
comment|/* Set a new deadline. */
name|arena_decay_deadline_init
argument_list|(
name|decay
argument_list|)
expr_stmt|;
comment|/* Update the backlog. */
name|arena_decay_backlog_update
argument_list|(
name|decay
argument_list|,
name|nadvance_u64
argument_list|,
name|current_npages
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_decay_epoch_advance
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_decay_t
modifier|*
name|decay
parameter_list|,
name|extents_t
modifier|*
name|extents
parameter_list|,
specifier|const
name|nstime_t
modifier|*
name|time
parameter_list|,
name|bool
name|purge
parameter_list|)
block|{
name|size_t
name|current_npages
init|=
name|extents_npages_get
argument_list|(
name|extents
argument_list|)
decl_stmt|;
name|arena_decay_epoch_advance_helper
argument_list|(
name|decay
argument_list|,
name|time
argument_list|,
name|current_npages
argument_list|)
expr_stmt|;
name|size_t
name|npages_limit
init|=
name|arena_decay_backlog_npages_limit
argument_list|(
name|decay
argument_list|)
decl_stmt|;
comment|/* We may unlock decay->mtx when try_purge(). Finish logging first. */
name|decay
operator|->
name|nunpurged
operator|=
operator|(
name|npages_limit
operator|>
name|current_npages
operator|)
condition|?
name|npages_limit
else|:
name|current_npages
expr_stmt|;
if|if
condition|(
name|purge
condition|)
block|{
name|arena_decay_try_purge
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|decay
argument_list|,
name|extents
argument_list|,
name|current_npages
argument_list|,
name|npages_limit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arena_decay_reinit
parameter_list|(
name|arena_decay_t
modifier|*
name|decay
parameter_list|,
name|extents_t
modifier|*
name|extents
parameter_list|,
name|ssize_t
name|decay_ms
parameter_list|)
block|{
name|arena_decay_ms_write
argument_list|(
name|decay
argument_list|,
name|decay_ms
argument_list|)
expr_stmt|;
if|if
condition|(
name|decay_ms
operator|>
literal|0
condition|)
block|{
name|nstime_init
argument_list|(
operator|&
name|decay
operator|->
name|interval
argument_list|,
operator|(
name|uint64_t
operator|)
name|decay_ms
operator|*
name|KQU
argument_list|(
literal|1000000
argument_list|)
argument_list|)
expr_stmt|;
name|nstime_idivide
argument_list|(
operator|&
name|decay
operator|->
name|interval
argument_list|,
name|SMOOTHSTEP_NSTEPS
argument_list|)
expr_stmt|;
block|}
name|nstime_init
argument_list|(
operator|&
name|decay
operator|->
name|epoch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nstime_update
argument_list|(
operator|&
name|decay
operator|->
name|epoch
argument_list|)
expr_stmt|;
name|decay
operator|->
name|jitter_state
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|decay
expr_stmt|;
name|arena_decay_deadline_init
argument_list|(
name|decay
argument_list|)
expr_stmt|;
name|decay
operator|->
name|nunpurged
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|decay
operator|->
name|backlog
argument_list|,
literal|0
argument_list|,
name|SMOOTHSTEP_NSTEPS
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|arena_decay_init
parameter_list|(
name|arena_decay_t
modifier|*
name|decay
parameter_list|,
name|extents_t
modifier|*
name|extents
parameter_list|,
name|ssize_t
name|decay_ms
parameter_list|,
name|decay_stats_t
modifier|*
name|stats
parameter_list|)
block|{
if|if
condition|(
name|config_debug
condition|)
block|{
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|arena_decay_t
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|assert
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|decay
operator|)
index|[
name|i
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|decay
operator|->
name|ceil_npages
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|decay
operator|->
name|mtx
argument_list|,
literal|"decay"
argument_list|,
name|WITNESS_RANK_DECAY
argument_list|,
name|malloc_mutex_rank_exclusive
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|decay
operator|->
name|purging
operator|=
name|false
expr_stmt|;
name|arena_decay_reinit
argument_list|(
name|decay
argument_list|,
name|extents
argument_list|,
name|decay_ms
argument_list|)
expr_stmt|;
comment|/* Memory is zeroed, so there is no need to clear stats. */
if|if
condition|(
name|config_stats
condition|)
block|{
name|decay
operator|->
name|stats
operator|=
name|stats
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|arena_decay_ms_valid
parameter_list|(
name|ssize_t
name|decay_ms
parameter_list|)
block|{
if|if
condition|(
name|decay_ms
operator|<
operator|-
literal|1
condition|)
block|{
return|return
name|false
return|;
block|}
if|if
condition|(
name|decay_ms
operator|==
operator|-
literal|1
operator|||
operator|(
name|uint64_t
operator|)
name|decay_ms
operator|<=
name|NSTIME_SEC_MAX
operator|*
name|KQU
argument_list|(
literal|1000
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|arena_maybe_decay
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_decay_t
modifier|*
name|decay
parameter_list|,
name|extents_t
modifier|*
name|extents
parameter_list|,
name|bool
name|is_background_thread
parameter_list|)
block|{
name|malloc_mutex_assert_owner
argument_list|(
name|tsdn
argument_list|,
operator|&
name|decay
operator|->
name|mtx
argument_list|)
expr_stmt|;
comment|/* Purge all or nothing if the option is disabled. */
name|ssize_t
name|decay_ms
init|=
name|arena_decay_ms_read
argument_list|(
name|decay
argument_list|)
decl_stmt|;
if|if
condition|(
name|decay_ms
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|decay_ms
operator|==
literal|0
condition|)
block|{
name|arena_decay_to_limit
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|decay
argument_list|,
name|extents
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
name|nstime_t
name|time
decl_stmt|;
name|nstime_init
argument_list|(
operator|&
name|time
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nstime_update
argument_list|(
operator|&
name|time
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|nstime_monotonic
argument_list|()
operator|&&
name|nstime_compare
argument_list|(
operator|&
name|decay
operator|->
name|epoch
argument_list|,
operator|&
name|time
argument_list|)
operator|>
literal|0
argument_list|)
condition|)
block|{
comment|/* 		 * Time went backwards.  Move the epoch back in time and 		 * generate a new deadline, with the expectation that time 		 * typically flows forward for long enough periods of time that 		 * epochs complete.  Unfortunately, this strategy is susceptible 		 * to clock jitter triggering premature epoch advances, but 		 * clock jitter estimation and compensation isn't feasible here 		 * because calls into this code are event-driven. 		 */
name|nstime_copy
argument_list|(
operator|&
name|decay
operator|->
name|epoch
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
name|arena_decay_deadline_init
argument_list|(
name|decay
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Verify that time does not go backwards. */
name|assert
argument_list|(
name|nstime_compare
argument_list|(
operator|&
name|decay
operator|->
name|epoch
argument_list|,
operator|&
name|time
argument_list|)
operator|<=
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the deadline has been reached, advance to the current epoch and 	 * purge to the new limit if necessary.  Note that dirty pages created 	 * during the current epoch are not subject to purge until a future 	 * epoch, so as a result purging only happens during epoch advances, or 	 * being triggered by background threads (scheduled event). 	 */
name|bool
name|advance_epoch
init|=
name|arena_decay_deadline_reached
argument_list|(
name|decay
argument_list|,
operator|&
name|time
argument_list|)
decl_stmt|;
if|if
condition|(
name|advance_epoch
condition|)
block|{
name|bool
name|should_purge
init|=
name|is_background_thread
operator|||
operator|!
name|background_thread_enabled
argument_list|()
decl_stmt|;
name|arena_decay_epoch_advance
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|decay
argument_list|,
name|extents
argument_list|,
operator|&
name|time
argument_list|,
name|should_purge
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_background_thread
condition|)
block|{
name|arena_decay_try_purge
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|decay
argument_list|,
name|extents
argument_list|,
name|extents_npages_get
argument_list|(
name|extents
argument_list|)
argument_list|,
name|arena_decay_backlog_npages_limit
argument_list|(
name|decay
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|advance_epoch
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|arena_decay_ms_get
parameter_list|(
name|arena_decay_t
modifier|*
name|decay
parameter_list|)
block|{
return|return
name|arena_decay_ms_read
argument_list|(
name|decay
argument_list|)
return|;
block|}
end_function

begin_function
name|ssize_t
name|arena_dirty_decay_ms_get
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
return|return
name|arena_decay_ms_get
argument_list|(
operator|&
name|arena
operator|->
name|decay_dirty
argument_list|)
return|;
block|}
end_function

begin_function
name|ssize_t
name|arena_muzzy_decay_ms_get
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
return|return
name|arena_decay_ms_get
argument_list|(
operator|&
name|arena
operator|->
name|decay_muzzy
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|arena_decay_ms_set
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_decay_t
modifier|*
name|decay
parameter_list|,
name|extents_t
modifier|*
name|extents
parameter_list|,
name|ssize_t
name|decay_ms
parameter_list|)
block|{
if|if
condition|(
operator|!
name|arena_decay_ms_valid
argument_list|(
name|decay_ms
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|decay
operator|->
name|mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Restart decay backlog from scratch, which may cause many dirty pages 	 * to be immediately purged.  It would conceptually be possible to map 	 * the old backlog onto the new backlog, but there is no justification 	 * for such complexity since decay_ms changes are intended to be 	 * infrequent, either between the {-1, 0,>0} states, or a one-time 	 * arbitrary change during initial arena configuration. 	 */
name|arena_decay_reinit
argument_list|(
name|decay
argument_list|,
name|extents
argument_list|,
name|decay_ms
argument_list|)
expr_stmt|;
name|arena_maybe_decay
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|decay
argument_list|,
name|extents
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|decay
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
name|bool
name|arena_dirty_decay_ms_set
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|ssize_t
name|decay_ms
parameter_list|)
block|{
return|return
name|arena_decay_ms_set
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|arena
operator|->
name|decay_dirty
argument_list|,
operator|&
name|arena
operator|->
name|extents_dirty
argument_list|,
name|decay_ms
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|arena_muzzy_decay_ms_set
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|ssize_t
name|decay_ms
parameter_list|)
block|{
return|return
name|arena_decay_ms_set
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|arena
operator|->
name|decay_muzzy
argument_list|,
operator|&
name|arena
operator|->
name|extents_muzzy
argument_list|,
name|decay_ms
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|arena_stash_decayed
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|extent_hooks_t
modifier|*
modifier|*
name|r_extent_hooks
parameter_list|,
name|extents_t
modifier|*
name|extents
parameter_list|,
name|size_t
name|npages_limit
parameter_list|,
name|extent_list_t
modifier|*
name|decay_extents
parameter_list|)
block|{
name|witness_assert_depth_to_rank
argument_list|(
name|tsdn_witness_tsdp_get
argument_list|(
name|tsdn
argument_list|)
argument_list|,
name|WITNESS_RANK_CORE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Stash extents according to npages_limit. */
name|size_t
name|nstashed
init|=
literal|0
decl_stmt|;
name|extent_t
modifier|*
name|extent
decl_stmt|;
while|while
condition|(
operator|(
name|extent
operator|=
name|extents_evict
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|r_extent_hooks
argument_list|,
name|extents
argument_list|,
name|npages_limit
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|extent_list_append
argument_list|(
name|decay_extents
argument_list|,
name|extent
argument_list|)
expr_stmt|;
name|nstashed
operator|+=
name|extent_size_get
argument_list|(
name|extent
argument_list|)
operator|>>
name|LG_PAGE
expr_stmt|;
block|}
return|return
name|nstashed
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|arena_decay_stashed
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|extent_hooks_t
modifier|*
modifier|*
name|r_extent_hooks
parameter_list|,
name|arena_decay_t
modifier|*
name|decay
parameter_list|,
name|extents_t
modifier|*
name|extents
parameter_list|,
name|bool
name|all
parameter_list|,
name|extent_list_t
modifier|*
name|decay_extents
parameter_list|)
block|{
name|UNUSED
name|size_t
name|nmadvise
decl_stmt|,
name|nunmapped
decl_stmt|;
name|size_t
name|npurged
decl_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|nmadvise
operator|=
literal|0
expr_stmt|;
name|nunmapped
operator|=
literal|0
expr_stmt|;
block|}
name|npurged
operator|=
literal|0
expr_stmt|;
name|ssize_t
name|muzzy_decay_ms
init|=
name|arena_muzzy_decay_ms_get
argument_list|(
name|arena
argument_list|)
decl_stmt|;
for|for
control|(
name|extent_t
modifier|*
name|extent
init|=
name|extent_list_first
argument_list|(
name|decay_extents
argument_list|)
init|;
name|extent
operator|!=
name|NULL
condition|;
name|extent
operator|=
name|extent_list_first
argument_list|(
name|decay_extents
argument_list|)
control|)
block|{
if|if
condition|(
name|config_stats
condition|)
block|{
name|nmadvise
operator|++
expr_stmt|;
block|}
name|size_t
name|npages
init|=
name|extent_size_get
argument_list|(
name|extent
argument_list|)
operator|>>
name|LG_PAGE
decl_stmt|;
name|npurged
operator|+=
name|npages
expr_stmt|;
name|extent_list_remove
argument_list|(
name|decay_extents
argument_list|,
name|extent
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|extents_state_get
argument_list|(
name|extents
argument_list|)
condition|)
block|{
case|case
name|extent_state_active
case|:
name|not_reached
argument_list|()
expr_stmt|;
case|case
name|extent_state_dirty
case|:
if|if
condition|(
operator|!
name|all
operator|&&
name|muzzy_decay_ms
operator|!=
literal|0
operator|&&
operator|!
name|extent_purge_lazy_wrapper
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|r_extent_hooks
argument_list|,
name|extent
argument_list|,
literal|0
argument_list|,
name|extent_size_get
argument_list|(
name|extent
argument_list|)
argument_list|)
condition|)
block|{
name|extents_dalloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|r_extent_hooks
argument_list|,
operator|&
name|arena
operator|->
name|extents_muzzy
argument_list|,
name|extent
argument_list|)
expr_stmt|;
name|arena_background_thread_inactivity_check
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through. */
case|case
name|extent_state_muzzy
case|:
name|extent_dalloc_wrapper
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|r_extent_hooks
argument_list|,
name|extent
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|nunmapped
operator|+=
name|npages
expr_stmt|;
block|}
break|break;
case|case
name|extent_state_retained
case|:
default|default:
name|not_reached
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|config_stats
condition|)
block|{
name|arena_stats_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|)
expr_stmt|;
name|arena_stats_add_u64
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|,
operator|&
name|decay
operator|->
name|stats
operator|->
name|npurge
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|arena_stats_add_u64
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|,
operator|&
name|decay
operator|->
name|stats
operator|->
name|nmadvise
argument_list|,
name|nmadvise
argument_list|)
expr_stmt|;
name|arena_stats_add_u64
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|,
operator|&
name|decay
operator|->
name|stats
operator|->
name|purged
argument_list|,
name|npurged
argument_list|)
expr_stmt|;
name|arena_stats_sub_zu
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|,
operator|&
name|arena
operator|->
name|stats
operator|.
name|mapped
argument_list|,
name|nunmapped
operator|<<
name|LG_PAGE
argument_list|)
expr_stmt|;
name|arena_stats_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|)
expr_stmt|;
block|}
return|return
name|npurged
return|;
block|}
end_function

begin_comment
comment|/*  * npages_limit: Decay as many dirty extents as possible without violating the  * invariant: (extents_npages_get(extents)>= npages_limit)  */
end_comment

begin_function
specifier|static
name|void
name|arena_decay_to_limit
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_decay_t
modifier|*
name|decay
parameter_list|,
name|extents_t
modifier|*
name|extents
parameter_list|,
name|bool
name|all
parameter_list|,
name|size_t
name|npages_limit
parameter_list|)
block|{
name|witness_assert_depth_to_rank
argument_list|(
name|tsdn_witness_tsdp_get
argument_list|(
name|tsdn
argument_list|)
argument_list|,
name|WITNESS_RANK_CORE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|malloc_mutex_assert_owner
argument_list|(
name|tsdn
argument_list|,
operator|&
name|decay
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|decay
operator|->
name|purging
condition|)
block|{
return|return;
block|}
name|decay
operator|->
name|purging
operator|=
name|true
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|decay
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|extent_hooks_t
modifier|*
name|extent_hooks
init|=
name|extent_hooks_get
argument_list|(
name|arena
argument_list|)
decl_stmt|;
name|extent_list_t
name|decay_extents
decl_stmt|;
name|extent_list_init
argument_list|(
operator|&
name|decay_extents
argument_list|)
expr_stmt|;
name|size_t
name|npurge
init|=
name|arena_stash_decayed
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|extent_hooks
argument_list|,
name|extents
argument_list|,
name|npages_limit
argument_list|,
operator|&
name|decay_extents
argument_list|)
decl_stmt|;
if|if
condition|(
name|npurge
operator|!=
literal|0
condition|)
block|{
name|UNUSED
name|size_t
name|npurged
init|=
name|arena_decay_stashed
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|extent_hooks
argument_list|,
name|decay
argument_list|,
name|extents
argument_list|,
name|all
argument_list|,
operator|&
name|decay_extents
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|npurged
operator|==
name|npurge
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|decay
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|decay
operator|->
name|purging
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|arena_decay_impl
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_decay_t
modifier|*
name|decay
parameter_list|,
name|extents_t
modifier|*
name|extents
parameter_list|,
name|bool
name|is_background_thread
parameter_list|,
name|bool
name|all
parameter_list|)
block|{
if|if
condition|(
name|all
condition|)
block|{
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|decay
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|arena_decay_to_limit
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|decay
argument_list|,
name|extents
argument_list|,
name|all
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|decay
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|malloc_mutex_trylock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|decay
operator|->
name|mtx
argument_list|)
condition|)
block|{
comment|/* No need to wait if another thread is in progress. */
return|return
name|true
return|;
block|}
name|bool
name|epoch_advanced
init|=
name|arena_maybe_decay
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|decay
argument_list|,
name|extents
argument_list|,
name|is_background_thread
argument_list|)
decl_stmt|;
name|size_t
name|npages_new
decl_stmt|;
if|if
condition|(
name|epoch_advanced
condition|)
block|{
comment|/* Backlog is updated on epoch advance. */
name|npages_new
operator|=
name|decay
operator|->
name|backlog
index|[
name|SMOOTHSTEP_NSTEPS
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|decay
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_background_thread
operator|&&
name|background_thread_enabled
argument_list|()
operator|&&
name|epoch_advanced
operator|&&
operator|!
name|is_background_thread
condition|)
block|{
name|background_thread_interval_check
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|decay
argument_list|,
name|npages_new
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|arena_decay_dirty
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|bool
name|is_background_thread
parameter_list|,
name|bool
name|all
parameter_list|)
block|{
return|return
name|arena_decay_impl
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|arena
operator|->
name|decay_dirty
argument_list|,
operator|&
name|arena
operator|->
name|extents_dirty
argument_list|,
name|is_background_thread
argument_list|,
name|all
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|arena_decay_muzzy
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|bool
name|is_background_thread
parameter_list|,
name|bool
name|all
parameter_list|)
block|{
return|return
name|arena_decay_impl
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|arena
operator|->
name|decay_muzzy
argument_list|,
operator|&
name|arena
operator|->
name|extents_muzzy
argument_list|,
name|is_background_thread
argument_list|,
name|all
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|arena_decay
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|bool
name|is_background_thread
parameter_list|,
name|bool
name|all
parameter_list|)
block|{
if|if
condition|(
name|arena_decay_dirty
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|is_background_thread
argument_list|,
name|all
argument_list|)
condition|)
block|{
return|return;
block|}
name|arena_decay_muzzy
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|is_background_thread
argument_list|,
name|all
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_slab_dalloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|extent_t
modifier|*
name|slab
parameter_list|)
block|{
name|arena_nactive_sub
argument_list|(
name|arena
argument_list|,
name|extent_size_get
argument_list|(
name|slab
argument_list|)
operator|>>
name|LG_PAGE
argument_list|)
expr_stmt|;
name|extent_hooks_t
modifier|*
name|extent_hooks
init|=
name|EXTENT_HOOKS_INITIALIZER
decl_stmt|;
name|arena_extents_dirty_dalloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|extent_hooks
argument_list|,
name|slab
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_bin_slabs_nonfull_insert
parameter_list|(
name|arena_bin_t
modifier|*
name|bin
parameter_list|,
name|extent_t
modifier|*
name|slab
parameter_list|)
block|{
name|assert
argument_list|(
name|extent_nfree_get
argument_list|(
name|slab
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|extent_heap_insert
argument_list|(
operator|&
name|bin
operator|->
name|slabs_nonfull
argument_list|,
name|slab
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_bin_slabs_nonfull_remove
parameter_list|(
name|arena_bin_t
modifier|*
name|bin
parameter_list|,
name|extent_t
modifier|*
name|slab
parameter_list|)
block|{
name|extent_heap_remove
argument_list|(
operator|&
name|bin
operator|->
name|slabs_nonfull
argument_list|,
name|slab
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|extent_t
modifier|*
name|arena_bin_slabs_nonfull_tryget
parameter_list|(
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
block|{
name|extent_t
modifier|*
name|slab
init|=
name|extent_heap_remove_first
argument_list|(
operator|&
name|bin
operator|->
name|slabs_nonfull
argument_list|)
decl_stmt|;
if|if
condition|(
name|slab
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|config_stats
condition|)
block|{
name|bin
operator|->
name|stats
operator|.
name|reslabs
operator|++
expr_stmt|;
block|}
return|return
name|slab
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_bin_slabs_full_insert
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|,
name|extent_t
modifier|*
name|slab
parameter_list|)
block|{
name|assert
argument_list|(
name|extent_nfree_get
argument_list|(
name|slab
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 *  Tracking extents is required by arena_reset, which is not allowed 	 *  for auto arenas.  Bypass this step to avoid touching the extent 	 *  linkage (often results in cache misses) for auto arenas. 	 */
if|if
condition|(
name|arena_is_auto
argument_list|(
name|arena
argument_list|)
condition|)
block|{
return|return;
block|}
name|extent_list_append
argument_list|(
operator|&
name|bin
operator|->
name|slabs_full
argument_list|,
name|slab
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_bin_slabs_full_remove
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|,
name|extent_t
modifier|*
name|slab
parameter_list|)
block|{
if|if
condition|(
name|arena_is_auto
argument_list|(
name|arena
argument_list|)
condition|)
block|{
return|return;
block|}
name|extent_list_remove
argument_list|(
operator|&
name|bin
operator|->
name|slabs_full
argument_list|,
name|slab
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_reset
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
comment|/* 	 * Locking in this function is unintuitive.  The caller guarantees that 	 * no concurrent operations are happening in this arena, but there are 	 * still reasons that some locking is necessary: 	 * 	 * - Some of the functions in the transitive closure of calls assume 	 *   appropriate locks are held, and in some cases these locks are 	 *   temporarily dropped to avoid lock order reversal or deadlock due to 	 *   reentry. 	 * - mallctl("epoch", ...) may concurrently refresh stats.  While 	 *   strictly speaking this is a "concurrent operation", disallowing 	 *   stats refreshes would impose an inconvenient burden. 	 */
comment|/* Large allocations. */
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|arena
operator|->
name|large_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|extent_t
modifier|*
name|extent
init|=
name|extent_list_first
argument_list|(
operator|&
name|arena
operator|->
name|large
argument_list|)
init|;
name|extent
operator|!=
name|NULL
condition|;
name|extent
operator|=
name|extent_list_first
argument_list|(
operator|&
name|arena
operator|->
name|large
argument_list|)
control|)
block|{
name|void
modifier|*
name|ptr
init|=
name|extent_base_get
argument_list|(
name|extent
argument_list|)
decl_stmt|;
name|size_t
name|usize
decl_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|arena
operator|->
name|large_mtx
argument_list|)
expr_stmt|;
name|alloc_ctx_t
name|alloc_ctx
decl_stmt|;
name|rtree_ctx_t
modifier|*
name|rtree_ctx
init|=
name|tsd_rtree_ctx
argument_list|(
name|tsd
argument_list|)
decl_stmt|;
name|rtree_szind_slab_read
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|extents_rtree
argument_list|,
name|rtree_ctx
argument_list|,
operator|(
name|uintptr_t
operator|)
name|ptr
argument_list|,
name|true
argument_list|,
operator|&
name|alloc_ctx
operator|.
name|szind
argument_list|,
operator|&
name|alloc_ctx
operator|.
name|slab
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|alloc_ctx
operator|.
name|szind
operator|!=
name|NSIZES
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
operator|||
operator|(
name|config_prof
operator|&&
name|opt_prof
operator|)
condition|)
block|{
name|usize
operator|=
name|sz_index2size
argument_list|(
name|alloc_ctx
operator|.
name|szind
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|usize
operator|==
name|isalloc
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Remove large allocation from prof sample set. */
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
block|{
name|prof_free
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|,
operator|&
name|alloc_ctx
argument_list|)
expr_stmt|;
block|}
name|large_dalloc
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|extent
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|arena
operator|->
name|large_mtx
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|arena
operator|->
name|large_mtx
argument_list|)
expr_stmt|;
comment|/* Bins. */
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
name|extent_t
modifier|*
name|slab
decl_stmt|;
name|arena_bin_t
modifier|*
name|bin
init|=
operator|&
name|arena
operator|->
name|bins
index|[
name|i
index|]
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|bin
operator|->
name|slabcur
operator|!=
name|NULL
condition|)
block|{
name|slab
operator|=
name|bin
operator|->
name|slabcur
expr_stmt|;
name|bin
operator|->
name|slabcur
operator|=
name|NULL
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arena_slab_dalloc
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|arena
argument_list|,
name|slab
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|slab
operator|=
name|extent_heap_remove_first
argument_list|(
operator|&
name|bin
operator|->
name|slabs_nonfull
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arena_slab_dalloc
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|arena
argument_list|,
name|slab
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|slab
operator|=
name|extent_list_first
argument_list|(
operator|&
name|bin
operator|->
name|slabs_full
argument_list|)
init|;
name|slab
operator|!=
name|NULL
condition|;
name|slab
operator|=
name|extent_list_first
argument_list|(
operator|&
name|bin
operator|->
name|slabs_full
argument_list|)
control|)
block|{
name|arena_bin_slabs_full_remove
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|,
name|slab
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arena_slab_dalloc
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|arena
argument_list|,
name|slab
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config_stats
condition|)
block|{
name|bin
operator|->
name|stats
operator|.
name|curregs
operator|=
literal|0
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|curslabs
operator|=
literal|0
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|atomic_store_zu
argument_list|(
operator|&
name|arena
operator|->
name|nactive
argument_list|,
literal|0
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_destroy_retained
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
comment|/* 	 * Iterate over the retained extents and destroy them.  This gives the 	 * extent allocator underlying the extent hooks an opportunity to unmap 	 * all retained memory without having to keep its own metadata 	 * structures.  In practice, virtual memory for dss-allocated extents is 	 * leaked here, so best practice is to avoid dss for arenas to be 	 * destroyed, or provide custom extent hooks that track retained 	 * dss-based extents for later reuse. 	 */
name|extent_hooks_t
modifier|*
name|extent_hooks
init|=
name|extent_hooks_get
argument_list|(
name|arena
argument_list|)
decl_stmt|;
name|extent_t
modifier|*
name|extent
decl_stmt|;
while|while
condition|(
operator|(
name|extent
operator|=
name|extents_evict
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|extent_hooks
argument_list|,
operator|&
name|arena
operator|->
name|extents_retained
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|extent_destroy_wrapper
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|extent_hooks
argument_list|,
name|extent
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|arena_destroy
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|assert
argument_list|(
name|base_ind_get
argument_list|(
name|arena
operator|->
name|base
argument_list|)
operator|>=
name|narenas_auto
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_nthreads_get
argument_list|(
name|arena
argument_list|,
name|false
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_nthreads_get
argument_list|(
name|arena
argument_list|,
name|true
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * No allocations have occurred since arena_reset() was called. 	 * Furthermore, the caller (arena_i_destroy_ctl()) purged all cached 	 * extents, so only retained extents may remain. 	 */
name|assert
argument_list|(
name|extents_npages_get
argument_list|(
operator|&
name|arena
operator|->
name|extents_dirty
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|extents_npages_get
argument_list|(
operator|&
name|arena
operator|->
name|extents_muzzy
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Deallocate retained memory. */
name|arena_destroy_retained
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|arena
argument_list|)
expr_stmt|;
comment|/* 	 * Remove the arena pointer from the arenas array.  We rely on the fact 	 * that there is no way for the application to get a dirty read from the 	 * arenas array unless there is an inherent race in the application 	 * involving access of an arena being concurrently destroyed.  The 	 * application must synchronize knowledge of the arena's validity, so as 	 * long as we use an atomic write to update the arenas array, the 	 * application will get a clean read any time after it synchronizes 	 * knowledge that the arena is no longer valid. 	 */
name|arena_set
argument_list|(
name|base_ind_get
argument_list|(
name|arena
operator|->
name|base
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Destroy the base allocator, which manages all metadata ever mapped by 	 * this arena. 	 */
name|base_delete
argument_list|(
name|arena
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|extent_t
modifier|*
name|arena_slab_alloc_hard
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|extent_hooks_t
modifier|*
modifier|*
name|r_extent_hooks
parameter_list|,
specifier|const
name|arena_bin_info_t
modifier|*
name|bin_info
parameter_list|,
name|szind_t
name|szind
parameter_list|)
block|{
name|extent_t
modifier|*
name|slab
decl_stmt|;
name|bool
name|zero
decl_stmt|,
name|commit
decl_stmt|;
name|witness_assert_depth_to_rank
argument_list|(
name|tsdn_witness_tsdp_get
argument_list|(
name|tsdn
argument_list|)
argument_list|,
name|WITNESS_RANK_CORE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zero
operator|=
name|false
expr_stmt|;
name|commit
operator|=
name|true
expr_stmt|;
name|slab
operator|=
name|extent_alloc_wrapper
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|r_extent_hooks
argument_list|,
name|NULL
argument_list|,
name|bin_info
operator|->
name|slab_size
argument_list|,
literal|0
argument_list|,
name|PAGE
argument_list|,
name|true
argument_list|,
name|szind
argument_list|,
operator|&
name|zero
argument_list|,
operator|&
name|commit
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
operator|&&
name|slab
operator|!=
name|NULL
condition|)
block|{
name|arena_stats_mapped_add
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|,
name|bin_info
operator|->
name|slab_size
argument_list|)
expr_stmt|;
block|}
return|return
name|slab
return|;
block|}
end_function

begin_function
specifier|static
name|extent_t
modifier|*
name|arena_slab_alloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|szind_t
name|binind
parameter_list|,
specifier|const
name|arena_bin_info_t
modifier|*
name|bin_info
parameter_list|)
block|{
name|witness_assert_depth_to_rank
argument_list|(
name|tsdn_witness_tsdp_get
argument_list|(
name|tsdn
argument_list|)
argument_list|,
name|WITNESS_RANK_CORE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|extent_hooks_t
modifier|*
name|extent_hooks
init|=
name|EXTENT_HOOKS_INITIALIZER
decl_stmt|;
name|szind_t
name|szind
init|=
name|sz_size2index
argument_list|(
name|bin_info
operator|->
name|reg_size
argument_list|)
decl_stmt|;
name|bool
name|zero
init|=
name|false
decl_stmt|;
name|bool
name|commit
init|=
name|true
decl_stmt|;
name|extent_t
modifier|*
name|slab
init|=
name|extents_alloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|extent_hooks
argument_list|,
operator|&
name|arena
operator|->
name|extents_dirty
argument_list|,
name|NULL
argument_list|,
name|bin_info
operator|->
name|slab_size
argument_list|,
literal|0
argument_list|,
name|PAGE
argument_list|,
name|true
argument_list|,
name|binind
argument_list|,
operator|&
name|zero
argument_list|,
operator|&
name|commit
argument_list|)
decl_stmt|;
if|if
condition|(
name|slab
operator|==
name|NULL
condition|)
block|{
name|slab
operator|=
name|extents_alloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|extent_hooks
argument_list|,
operator|&
name|arena
operator|->
name|extents_muzzy
argument_list|,
name|NULL
argument_list|,
name|bin_info
operator|->
name|slab_size
argument_list|,
literal|0
argument_list|,
name|PAGE
argument_list|,
name|true
argument_list|,
name|binind
argument_list|,
operator|&
name|zero
argument_list|,
operator|&
name|commit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|slab
operator|==
name|NULL
condition|)
block|{
name|slab
operator|=
name|arena_slab_alloc_hard
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|extent_hooks
argument_list|,
name|bin_info
argument_list|,
name|szind
argument_list|)
expr_stmt|;
if|if
condition|(
name|slab
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
block|}
name|assert
argument_list|(
name|extent_slab_get
argument_list|(
name|slab
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize slab internals. */
name|arena_slab_data_t
modifier|*
name|slab_data
init|=
name|extent_slab_data_get
argument_list|(
name|slab
argument_list|)
decl_stmt|;
name|extent_nfree_set
argument_list|(
name|slab
argument_list|,
name|bin_info
operator|->
name|nregs
argument_list|)
expr_stmt|;
name|bitmap_init
argument_list|(
name|slab_data
operator|->
name|bitmap
argument_list|,
operator|&
name|bin_info
operator|->
name|bitmap_info
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|arena_nactive_add
argument_list|(
name|arena
argument_list|,
name|extent_size_get
argument_list|(
name|slab
argument_list|)
operator|>>
name|LG_PAGE
argument_list|)
expr_stmt|;
return|return
name|slab
return|;
block|}
end_function

begin_function
specifier|static
name|extent_t
modifier|*
name|arena_bin_nonfull_slab_get
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|,
name|szind_t
name|binind
parameter_list|)
block|{
name|extent_t
modifier|*
name|slab
decl_stmt|;
specifier|const
name|arena_bin_info_t
modifier|*
name|bin_info
decl_stmt|;
comment|/* Look for a usable slab. */
name|slab
operator|=
name|arena_bin_slabs_nonfull_tryget
argument_list|(
name|bin
argument_list|)
expr_stmt|;
if|if
condition|(
name|slab
operator|!=
name|NULL
condition|)
block|{
return|return
name|slab
return|;
block|}
comment|/* No existing slabs have any space available. */
name|bin_info
operator|=
operator|&
name|arena_bin_info
index|[
name|binind
index|]
expr_stmt|;
comment|/* Allocate a new slab. */
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/******************************/
name|slab
operator|=
name|arena_slab_alloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|binind
argument_list|,
name|bin_info
argument_list|)
expr_stmt|;
comment|/********************************/
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|slab
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|config_stats
condition|)
block|{
name|bin
operator|->
name|stats
operator|.
name|nslabs
operator|++
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|curslabs
operator|++
expr_stmt|;
block|}
return|return
name|slab
return|;
block|}
comment|/* 	 * arena_slab_alloc() failed, but another thread may have made 	 * sufficient memory available while this one dropped bin->lock above, 	 * so search one more time. 	 */
name|slab
operator|=
name|arena_bin_slabs_nonfull_tryget
argument_list|(
name|bin
argument_list|)
expr_stmt|;
if|if
condition|(
name|slab
operator|!=
name|NULL
condition|)
block|{
return|return
name|slab
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Re-fill bin->slabcur, then call arena_slab_reg_alloc(). */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|arena_bin_malloc_hard
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|,
name|szind_t
name|binind
parameter_list|)
block|{
specifier|const
name|arena_bin_info_t
modifier|*
name|bin_info
decl_stmt|;
name|extent_t
modifier|*
name|slab
decl_stmt|;
name|bin_info
operator|=
operator|&
name|arena_bin_info
index|[
name|binind
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|arena_is_auto
argument_list|(
name|arena
argument_list|)
operator|&&
name|bin
operator|->
name|slabcur
operator|!=
name|NULL
condition|)
block|{
name|arena_bin_slabs_full_insert
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|,
name|bin
operator|->
name|slabcur
argument_list|)
expr_stmt|;
name|bin
operator|->
name|slabcur
operator|=
name|NULL
expr_stmt|;
block|}
name|slab
operator|=
name|arena_bin_nonfull_slab_get
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|bin
argument_list|,
name|binind
argument_list|)
expr_stmt|;
if|if
condition|(
name|bin
operator|->
name|slabcur
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Another thread updated slabcur while this one ran without the 		 * bin lock in arena_bin_nonfull_slab_get(). 		 */
if|if
condition|(
name|extent_nfree_get
argument_list|(
name|bin
operator|->
name|slabcur
argument_list|)
operator|>
literal|0
condition|)
block|{
name|void
modifier|*
name|ret
init|=
name|arena_slab_reg_alloc
argument_list|(
name|tsdn
argument_list|,
name|bin
operator|->
name|slabcur
argument_list|,
name|bin_info
argument_list|)
decl_stmt|;
if|if
condition|(
name|slab
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * arena_slab_alloc() may have allocated slab, 				 * or it may have been pulled from 				 * slabs_nonfull.  Therefore it is unsafe to 				 * make any assumptions about how slab has 				 * previously been used, and 				 * arena_bin_lower_slab() must be called, as if 				 * a region were just deallocated from the slab. 				 */
if|if
condition|(
name|extent_nfree_get
argument_list|(
name|slab
argument_list|)
operator|==
name|bin_info
operator|->
name|nregs
condition|)
block|{
name|arena_dalloc_bin_slab
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|slab
argument_list|,
name|bin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arena_bin_lower_slab
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|slab
argument_list|,
name|bin
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
name|arena_bin_slabs_full_insert
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|,
name|bin
operator|->
name|slabcur
argument_list|)
expr_stmt|;
name|bin
operator|->
name|slabcur
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|slab
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|bin
operator|->
name|slabcur
operator|=
name|slab
expr_stmt|;
name|assert
argument_list|(
name|extent_nfree_get
argument_list|(
name|bin
operator|->
name|slabcur
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
name|arena_slab_reg_alloc
argument_list|(
name|tsdn
argument_list|,
name|slab
argument_list|,
name|bin_info
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|arena_tcache_fill_small
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|,
name|tcache_bin_t
modifier|*
name|tbin
parameter_list|,
name|szind_t
name|binind
parameter_list|,
name|uint64_t
name|prof_accumbytes
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|nfill
decl_stmt|;
name|arena_bin_t
modifier|*
name|bin
decl_stmt|;
name|assert
argument_list|(
name|tbin
operator|->
name|ncached
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_prof
operator|&&
name|arena_prof_accum
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|prof_accumbytes
argument_list|)
condition|)
block|{
name|prof_idump
argument_list|(
name|tsdn
argument_list|)
expr_stmt|;
block|}
name|bin
operator|=
operator|&
name|arena
operator|->
name|bins
index|[
name|binind
index|]
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|nfill
operator|=
operator|(
name|tcache_bin_info
index|[
name|binind
index|]
operator|.
name|ncached_max
operator|>>
name|tcache
operator|->
name|lg_fill_div
index|[
name|binind
index|]
operator|)
init|;
name|i
operator|<
name|nfill
condition|;
name|i
operator|++
control|)
block|{
name|extent_t
modifier|*
name|slab
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
name|slab
operator|=
name|bin
operator|->
name|slabcur
operator|)
operator|!=
name|NULL
operator|&&
name|extent_nfree_get
argument_list|(
name|slab
argument_list|)
operator|>
literal|0
condition|)
block|{
name|ptr
operator|=
name|arena_slab_reg_alloc
argument_list|(
name|tsdn
argument_list|,
name|slab
argument_list|,
operator|&
name|arena_bin_info
index|[
name|binind
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptr
operator|=
name|arena_bin_malloc_hard
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|bin
argument_list|,
name|binind
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * OOM.  tbin->avail isn't yet filled down to its first 			 * element, so the successful allocations (if any) must 			 * be moved just before tbin->avail before bailing out. 			 */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|memmove
argument_list|(
name|tbin
operator|->
name|avail
operator|-
name|i
argument_list|,
name|tbin
operator|->
name|avail
operator|-
name|nfill
argument_list|,
name|i
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|config_fill
operator|&&
name|unlikely
argument_list|(
name|opt_junk_alloc
argument_list|)
condition|)
block|{
name|arena_alloc_junk_small
argument_list|(
name|ptr
argument_list|,
operator|&
name|arena_bin_info
index|[
name|binind
index|]
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
comment|/* Insert such that low regions get used first. */
operator|*
operator|(
name|tbin
operator|->
name|avail
operator|-
name|nfill
operator|+
name|i
operator|)
operator|=
name|ptr
expr_stmt|;
block|}
if|if
condition|(
name|config_stats
condition|)
block|{
name|bin
operator|->
name|stats
operator|.
name|nmalloc
operator|+=
name|i
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|nrequests
operator|+=
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|curregs
operator|+=
name|i
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|nfills
operator|++
expr_stmt|;
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
operator|=
literal|0
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
name|tbin
operator|->
name|ncached
operator|=
name|i
expr_stmt|;
name|arena_decay_tick
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_alloc_junk_small
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
specifier|const
name|arena_bin_info_t
modifier|*
name|bin_info
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
if|if
condition|(
operator|!
name|zero
condition|)
block|{
name|memset
argument_list|(
name|ptr
argument_list|,
name|JEMALLOC_ALLOC_JUNK
argument_list|,
name|bin_info
operator|->
name|reg_size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arena_dalloc_junk_small_impl
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
specifier|const
name|arena_bin_info_t
modifier|*
name|bin_info
parameter_list|)
block|{
name|memset
argument_list|(
name|ptr
argument_list|,
name|JEMALLOC_FREE_JUNK
argument_list|,
name|bin_info
operator|->
name|reg_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|arena_dalloc_junk_small_t
modifier|*
name|JET_MUTABLE
name|arena_dalloc_junk_small
init|=
name|arena_dalloc_junk_small_impl
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
modifier|*
name|arena_malloc_small
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|szind_t
name|binind
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|arena_bin_t
modifier|*
name|bin
decl_stmt|;
name|size_t
name|usize
decl_stmt|;
name|extent_t
modifier|*
name|slab
decl_stmt|;
name|assert
argument_list|(
name|binind
operator|<
name|NBINS
argument_list|)
expr_stmt|;
name|bin
operator|=
operator|&
name|arena
operator|->
name|bins
index|[
name|binind
index|]
expr_stmt|;
name|usize
operator|=
name|sz_index2size
argument_list|(
name|binind
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|slab
operator|=
name|bin
operator|->
name|slabcur
operator|)
operator|!=
name|NULL
operator|&&
name|extent_nfree_get
argument_list|(
name|slab
argument_list|)
operator|>
literal|0
condition|)
block|{
name|ret
operator|=
name|arena_slab_reg_alloc
argument_list|(
name|tsdn
argument_list|,
name|slab
argument_list|,
operator|&
name|arena_bin_info
index|[
name|binind
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|arena_bin_malloc_hard
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|bin
argument_list|,
name|binind
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|config_stats
condition|)
block|{
name|bin
operator|->
name|stats
operator|.
name|nmalloc
operator|++
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|nrequests
operator|++
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|curregs
operator|++
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_prof
operator|&&
name|arena_prof_accum
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|usize
argument_list|)
condition|)
block|{
name|prof_idump
argument_list|(
name|tsdn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|zero
condition|)
block|{
if|if
condition|(
name|config_fill
condition|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|opt_junk_alloc
argument_list|)
condition|)
block|{
name|arena_alloc_junk_small
argument_list|(
name|ret
argument_list|,
operator|&
name|arena_bin_info
index|[
name|binind
index|]
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unlikely
argument_list|(
name|opt_zero
argument_list|)
condition|)
block|{
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|config_fill
operator|&&
name|unlikely
argument_list|(
name|opt_junk_alloc
argument_list|)
condition|)
block|{
name|arena_alloc_junk_small
argument_list|(
name|ret
argument_list|,
operator|&
name|arena_bin_info
index|[
name|binind
index|]
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
name|arena_decay_tick
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|arena_malloc_hard
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|szind_t
name|ind
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|tsdn_null
argument_list|(
name|tsdn
argument_list|)
operator|||
name|arena
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
operator|!
name|tsdn_null
argument_list|(
name|tsdn
argument_list|)
argument_list|)
condition|)
block|{
name|arena
operator|=
name|arena_choose
argument_list|(
name|tsdn_tsd
argument_list|(
name|tsdn
argument_list|)
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|arena
operator|==
name|NULL
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|likely
argument_list|(
name|size
operator|<=
name|SMALL_MAXCLASS
argument_list|)
condition|)
block|{
return|return
name|arena_malloc_small
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|ind
argument_list|,
name|zero
argument_list|)
return|;
block|}
return|return
name|large_malloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|sz_index2size
argument_list|(
name|ind
argument_list|)
argument_list|,
name|zero
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|arena_palloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
name|zero
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|usize
operator|<=
name|SMALL_MAXCLASS
operator|&&
operator|(
name|alignment
operator|<
name|PAGE
operator|||
operator|(
name|alignment
operator|==
name|PAGE
operator|&&
operator|(
name|usize
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* Small; alignment doesn't require special slab placement. */
name|ret
operator|=
name|arena_malloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|usize
argument_list|,
name|sz_size2index
argument_list|(
name|usize
argument_list|)
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|likely
argument_list|(
name|alignment
operator|<=
name|CACHELINE
argument_list|)
condition|)
block|{
name|ret
operator|=
name|large_malloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|usize
argument_list|,
name|zero
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|large_palloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|usize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|arena_prof_promote
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|usize
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|isalloc
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|)
operator|==
name|LARGE_MINCLASS
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|usize
operator|<=
name|SMALL_MAXCLASS
argument_list|)
expr_stmt|;
name|rtree_ctx_t
name|rtree_ctx_fallback
decl_stmt|;
name|rtree_ctx_t
modifier|*
name|rtree_ctx
init|=
name|tsdn_rtree_ctx
argument_list|(
name|tsdn
argument_list|,
operator|&
name|rtree_ctx_fallback
argument_list|)
decl_stmt|;
name|extent_t
modifier|*
name|extent
init|=
name|rtree_extent_read
argument_list|(
name|tsdn
argument_list|,
operator|&
name|extents_rtree
argument_list|,
name|rtree_ctx
argument_list|,
operator|(
name|uintptr_t
operator|)
name|ptr
argument_list|,
name|true
argument_list|)
decl_stmt|;
name|arena_t
modifier|*
name|arena
init|=
name|extent_arena_get
argument_list|(
name|extent
argument_list|)
decl_stmt|;
name|szind_t
name|szind
init|=
name|sz_size2index
argument_list|(
name|usize
argument_list|)
decl_stmt|;
name|extent_szind_set
argument_list|(
name|extent
argument_list|,
name|szind
argument_list|)
expr_stmt|;
name|rtree_szind_slab_update
argument_list|(
name|tsdn
argument_list|,
operator|&
name|extents_rtree
argument_list|,
name|rtree_ctx
argument_list|,
operator|(
name|uintptr_t
operator|)
name|ptr
argument_list|,
name|szind
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|prof_accum_cancel
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|prof_accum
argument_list|,
name|usize
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|isalloc
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|)
operator|==
name|usize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|arena_prof_demote
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|extent_t
modifier|*
name|extent
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|extent_szind_set
argument_list|(
name|extent
argument_list|,
name|NBINS
argument_list|)
expr_stmt|;
name|rtree_ctx_t
name|rtree_ctx_fallback
decl_stmt|;
name|rtree_ctx_t
modifier|*
name|rtree_ctx
init|=
name|tsdn_rtree_ctx
argument_list|(
name|tsdn
argument_list|,
operator|&
name|rtree_ctx_fallback
argument_list|)
decl_stmt|;
name|rtree_szind_slab_update
argument_list|(
name|tsdn
argument_list|,
operator|&
name|extents_rtree
argument_list|,
name|rtree_ctx
argument_list|,
operator|(
name|uintptr_t
operator|)
name|ptr
argument_list|,
name|NBINS
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|isalloc
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|)
operator|==
name|LARGE_MINCLASS
argument_list|)
expr_stmt|;
return|return
name|LARGE_MINCLASS
return|;
block|}
end_function

begin_function
name|void
name|arena_dalloc_promoted
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|,
name|bool
name|slow_path
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|opt_prof
argument_list|)
expr_stmt|;
name|extent_t
modifier|*
name|extent
init|=
name|iealloc
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|)
decl_stmt|;
name|size_t
name|usize
init|=
name|arena_prof_demote
argument_list|(
name|tsdn
argument_list|,
name|extent
argument_list|,
name|ptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|usize
operator|<=
name|tcache_maxclass
condition|)
block|{
name|tcache_dalloc_large
argument_list|(
name|tsdn_tsd
argument_list|(
name|tsdn
argument_list|)
argument_list|,
name|tcache
argument_list|,
name|ptr
argument_list|,
name|sz_size2index
argument_list|(
name|usize
argument_list|)
argument_list|,
name|slow_path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|large_dalloc
argument_list|(
name|tsdn
argument_list|,
name|extent
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arena_dissociate_bin_slab
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|extent_t
modifier|*
name|slab
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
block|{
comment|/* Dissociate slab from bin. */
if|if
condition|(
name|slab
operator|==
name|bin
operator|->
name|slabcur
condition|)
block|{
name|bin
operator|->
name|slabcur
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|szind_t
name|binind
init|=
name|extent_szind_get
argument_list|(
name|slab
argument_list|)
decl_stmt|;
specifier|const
name|arena_bin_info_t
modifier|*
name|bin_info
init|=
operator|&
name|arena_bin_info
index|[
name|binind
index|]
decl_stmt|;
comment|/* 		 * The following block's conditional is necessary because if the 		 * slab only contains one region, then it never gets inserted 		 * into the non-full slabs heap. 		 */
if|if
condition|(
name|bin_info
operator|->
name|nregs
operator|==
literal|1
condition|)
block|{
name|arena_bin_slabs_full_remove
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|,
name|slab
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arena_bin_slabs_nonfull_remove
argument_list|(
name|bin
argument_list|,
name|slab
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arena_dalloc_bin_slab
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|extent_t
modifier|*
name|slab
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
block|{
name|assert
argument_list|(
name|slab
operator|!=
name|bin
operator|->
name|slabcur
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/******************************/
name|arena_slab_dalloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|slab
argument_list|)
expr_stmt|;
comment|/****************************/
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|bin
operator|->
name|stats
operator|.
name|curslabs
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arena_bin_lower_slab
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|extent_t
modifier|*
name|slab
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
block|{
name|assert
argument_list|(
name|extent_nfree_get
argument_list|(
name|slab
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure that if bin->slabcur is non-NULL, it refers to the 	 * oldest/lowest non-full slab.  It is okay to NULL slabcur out rather 	 * than proactively keeping it pointing at the oldest/lowest non-full 	 * slab. 	 */
if|if
condition|(
name|bin
operator|->
name|slabcur
operator|!=
name|NULL
operator|&&
name|extent_snad_comp
argument_list|(
name|bin
operator|->
name|slabcur
argument_list|,
name|slab
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Switch slabcur. */
if|if
condition|(
name|extent_nfree_get
argument_list|(
name|bin
operator|->
name|slabcur
argument_list|)
operator|>
literal|0
condition|)
block|{
name|arena_bin_slabs_nonfull_insert
argument_list|(
name|bin
argument_list|,
name|bin
operator|->
name|slabcur
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arena_bin_slabs_full_insert
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|,
name|bin
operator|->
name|slabcur
argument_list|)
expr_stmt|;
block|}
name|bin
operator|->
name|slabcur
operator|=
name|slab
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|bin
operator|->
name|stats
operator|.
name|reslabs
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|arena_bin_slabs_nonfull_insert
argument_list|(
name|bin
argument_list|,
name|slab
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arena_dalloc_bin_locked_impl
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|extent_t
modifier|*
name|slab
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|bool
name|junked
parameter_list|)
block|{
name|arena_slab_data_t
modifier|*
name|slab_data
init|=
name|extent_slab_data_get
argument_list|(
name|slab
argument_list|)
decl_stmt|;
name|szind_t
name|binind
init|=
name|extent_szind_get
argument_list|(
name|slab
argument_list|)
decl_stmt|;
name|arena_bin_t
modifier|*
name|bin
init|=
operator|&
name|arena
operator|->
name|bins
index|[
name|binind
index|]
decl_stmt|;
specifier|const
name|arena_bin_info_t
modifier|*
name|bin_info
init|=
operator|&
name|arena_bin_info
index|[
name|binind
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|junked
operator|&&
name|config_fill
operator|&&
name|unlikely
argument_list|(
name|opt_junk_free
argument_list|)
condition|)
block|{
name|arena_dalloc_junk_small
argument_list|(
name|ptr
argument_list|,
name|bin_info
argument_list|)
expr_stmt|;
block|}
name|arena_slab_reg_dalloc
argument_list|(
name|tsdn
argument_list|,
name|slab
argument_list|,
name|slab_data
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|unsigned
name|nfree
init|=
name|extent_nfree_get
argument_list|(
name|slab
argument_list|)
decl_stmt|;
if|if
condition|(
name|nfree
operator|==
name|bin_info
operator|->
name|nregs
condition|)
block|{
name|arena_dissociate_bin_slab
argument_list|(
name|arena
argument_list|,
name|slab
argument_list|,
name|bin
argument_list|)
expr_stmt|;
name|arena_dalloc_bin_slab
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|slab
argument_list|,
name|bin
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nfree
operator|==
literal|1
operator|&&
name|slab
operator|!=
name|bin
operator|->
name|slabcur
condition|)
block|{
name|arena_bin_slabs_full_remove
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|,
name|slab
argument_list|)
expr_stmt|;
name|arena_bin_lower_slab
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|slab
argument_list|,
name|bin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config_stats
condition|)
block|{
name|bin
operator|->
name|stats
operator|.
name|ndalloc
operator|++
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|curregs
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|arena_dalloc_bin_junked_locked
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|extent_t
modifier|*
name|extent
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|arena_dalloc_bin_locked_impl
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|extent
argument_list|,
name|ptr
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_dalloc_bin
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|extent_t
modifier|*
name|extent
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|szind_t
name|binind
init|=
name|extent_szind_get
argument_list|(
name|extent
argument_list|)
decl_stmt|;
name|arena_bin_t
modifier|*
name|bin
init|=
operator|&
name|arena
operator|->
name|bins
index|[
name|binind
index|]
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arena_dalloc_bin_locked_impl
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|extent
argument_list|,
name|ptr
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_dalloc_small
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|extent_t
modifier|*
name|extent
init|=
name|iealloc
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|)
decl_stmt|;
name|arena_t
modifier|*
name|arena
init|=
name|extent_arena_get
argument_list|(
name|extent
argument_list|)
decl_stmt|;
name|arena_dalloc_bin
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|extent
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|arena_decay_tick
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|arena_ralloc_no_move
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|extra
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
comment|/* Calls with non-zero extra had to clamp extra. */
name|assert
argument_list|(
name|extra
operator|==
literal|0
operator|||
name|size
operator|+
name|extra
operator|<=
name|LARGE_MAXCLASS
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|size
operator|>
name|LARGE_MAXCLASS
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|extent_t
modifier|*
name|extent
init|=
name|iealloc
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|)
decl_stmt|;
name|size_t
name|usize_min
init|=
name|sz_s2u
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|size_t
name|usize_max
init|=
name|sz_s2u
argument_list|(
name|size
operator|+
name|extra
argument_list|)
decl_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|oldsize
operator|<=
name|SMALL_MAXCLASS
operator|&&
name|usize_min
operator|<=
name|SMALL_MAXCLASS
argument_list|)
condition|)
block|{
comment|/* 		 * Avoid moving the allocation if the size class can be left the 		 * same. 		 */
name|assert
argument_list|(
name|arena_bin_info
index|[
name|sz_size2index
argument_list|(
name|oldsize
argument_list|)
index|]
operator|.
name|reg_size
operator|==
name|oldsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|usize_max
operator|>
name|SMALL_MAXCLASS
operator|||
name|sz_size2index
argument_list|(
name|usize_max
argument_list|)
operator|!=
name|sz_size2index
argument_list|(
name|oldsize
argument_list|)
operator|)
operator|&&
operator|(
name|size
operator|>
name|oldsize
operator|||
name|usize_max
operator|<
name|oldsize
operator|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|arena_decay_tick
argument_list|(
name|tsdn
argument_list|,
name|extent_arena_get
argument_list|(
name|extent
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|oldsize
operator|>=
name|LARGE_MINCLASS
operator|&&
name|usize_max
operator|>=
name|LARGE_MINCLASS
condition|)
block|{
return|return
name|large_ralloc_no_move
argument_list|(
name|tsdn
argument_list|,
name|extent
argument_list|,
name|usize_min
argument_list|,
name|usize_max
argument_list|,
name|zero
argument_list|)
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|arena_ralloc_move_helper
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
name|zero
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|)
block|{
if|if
condition|(
name|alignment
operator|==
literal|0
condition|)
block|{
return|return
name|arena_malloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|usize
argument_list|,
name|sz_size2index
argument_list|(
name|usize
argument_list|)
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|,
name|true
argument_list|)
return|;
block|}
name|usize
operator|=
name|sz_sa2u
argument_list|(
name|usize
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|usize
operator|==
literal|0
operator|||
name|usize
operator|>
name|LARGE_MAXCLASS
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|ipalloct
argument_list|(
name|tsdn
argument_list|,
name|usize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|arena_ralloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
name|zero
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|)
block|{
name|size_t
name|usize
init|=
name|sz_s2u
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|usize
operator|==
literal|0
operator|||
name|size
operator|>
name|LARGE_MAXCLASS
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|likely
argument_list|(
name|usize
operator|<=
name|SMALL_MAXCLASS
argument_list|)
condition|)
block|{
comment|/* Try to avoid moving the allocation. */
if|if
condition|(
operator|!
name|arena_ralloc_no_move
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|,
name|oldsize
argument_list|,
name|usize
argument_list|,
literal|0
argument_list|,
name|zero
argument_list|)
condition|)
block|{
return|return
name|ptr
return|;
block|}
block|}
if|if
condition|(
name|oldsize
operator|>=
name|LARGE_MINCLASS
operator|&&
name|usize
operator|>=
name|LARGE_MINCLASS
condition|)
block|{
return|return
name|large_ralloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|iealloc
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|)
argument_list|,
name|usize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|)
return|;
block|}
comment|/* 	 * size and oldsize are different enough that we need to move the 	 * object.  In that case, fall back to allocating new space and copying. 	 */
name|void
modifier|*
name|ret
init|=
name|arena_ralloc_move_helper
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|usize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|/* 	 * Junk/zero-filling were already done by 	 * ipalloc()/arena_malloc(). 	 */
name|size_t
name|copysize
init|=
operator|(
name|usize
operator|<
name|oldsize
operator|)
condition|?
name|usize
else|:
name|oldsize
decl_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|ptr
argument_list|,
name|copysize
argument_list|)
expr_stmt|;
name|isdalloct
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|,
name|oldsize
argument_list|,
name|tcache
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|dss_prec_t
name|arena_dss_prec_get
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
return|return
operator|(
name|dss_prec_t
operator|)
name|atomic_load_u
argument_list|(
operator|&
name|arena
operator|->
name|dss_prec
argument_list|,
name|ATOMIC_ACQUIRE
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|arena_dss_prec_set
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|dss_prec_t
name|dss_prec
parameter_list|)
block|{
if|if
condition|(
operator|!
name|have_dss
condition|)
block|{
return|return
operator|(
name|dss_prec
operator|!=
name|dss_prec_disabled
operator|)
return|;
block|}
name|atomic_store_u
argument_list|(
operator|&
name|arena
operator|->
name|dss_prec
argument_list|,
operator|(
name|unsigned
operator|)
name|dss_prec
argument_list|,
name|ATOMIC_RELEASE
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
name|ssize_t
name|arena_dirty_decay_ms_default_get
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|atomic_load_zd
argument_list|(
operator|&
name|dirty_decay_ms_default
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|arena_dirty_decay_ms_default_set
parameter_list|(
name|ssize_t
name|decay_ms
parameter_list|)
block|{
if|if
condition|(
operator|!
name|arena_decay_ms_valid
argument_list|(
name|decay_ms
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|atomic_store_zd
argument_list|(
operator|&
name|dirty_decay_ms_default
argument_list|,
name|decay_ms
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
name|ssize_t
name|arena_muzzy_decay_ms_default_get
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|atomic_load_zd
argument_list|(
operator|&
name|muzzy_decay_ms_default
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|arena_muzzy_decay_ms_default_set
parameter_list|(
name|ssize_t
name|decay_ms
parameter_list|)
block|{
if|if
condition|(
operator|!
name|arena_decay_ms_valid
argument_list|(
name|decay_ms
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|atomic_store_zd
argument_list|(
operator|&
name|muzzy_decay_ms_default
argument_list|,
name|decay_ms
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
name|unsigned
name|arena_nthreads_get
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|bool
name|internal
parameter_list|)
block|{
return|return
name|atomic_load_u
argument_list|(
operator|&
name|arena
operator|->
name|nthreads
index|[
name|internal
index|]
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|arena_nthreads_inc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|bool
name|internal
parameter_list|)
block|{
name|atomic_fetch_add_u
argument_list|(
operator|&
name|arena
operator|->
name|nthreads
index|[
name|internal
index|]
argument_list|,
literal|1
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_nthreads_dec
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|bool
name|internal
parameter_list|)
block|{
name|atomic_fetch_sub_u
argument_list|(
operator|&
name|arena
operator|->
name|nthreads
index|[
name|internal
index|]
argument_list|,
literal|1
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|arena_extent_sn_next
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
return|return
name|atomic_fetch_add_zu
argument_list|(
operator|&
name|arena
operator|->
name|extent_sn_next
argument_list|,
literal|1
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
return|;
block|}
end_function

begin_function
name|arena_t
modifier|*
name|arena_new
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|unsigned
name|ind
parameter_list|,
name|extent_hooks_t
modifier|*
name|extent_hooks
parameter_list|)
block|{
name|arena_t
modifier|*
name|arena
decl_stmt|;
name|base_t
modifier|*
name|base
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
name|ind
operator|==
literal|0
condition|)
block|{
name|base
operator|=
name|b0get
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
name|base_new
argument_list|(
name|tsdn
argument_list|,
name|ind
argument_list|,
name|extent_hooks
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
block|}
name|arena
operator|=
operator|(
name|arena_t
operator|*
operator|)
name|base_alloc
argument_list|(
name|tsdn
argument_list|,
name|base
argument_list|,
sizeof|sizeof
argument_list|(
name|arena_t
argument_list|)
argument_list|,
name|CACHELINE
argument_list|)
expr_stmt|;
if|if
condition|(
name|arena
operator|==
name|NULL
condition|)
block|{
goto|goto
name|label_error
goto|;
block|}
name|atomic_store_u
argument_list|(
operator|&
name|arena
operator|->
name|nthreads
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
name|atomic_store_u
argument_list|(
operator|&
name|arena
operator|->
name|nthreads
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
name|arena
operator|->
name|last_thd
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
if|if
condition|(
name|arena_stats_init
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|)
condition|)
block|{
goto|goto
name|label_error
goto|;
block|}
name|ql_new
argument_list|(
operator|&
name|arena
operator|->
name|tcache_ql
argument_list|)
expr_stmt|;
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|arena
operator|->
name|tcache_ql_mtx
argument_list|,
literal|"tcache_ql"
argument_list|,
name|WITNESS_RANK_TCACHE_QL
argument_list|,
name|malloc_mutex_rank_exclusive
argument_list|)
condition|)
block|{
goto|goto
name|label_error
goto|;
block|}
block|}
if|if
condition|(
name|config_prof
condition|)
block|{
if|if
condition|(
name|prof_accum_init
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|prof_accum
argument_list|)
condition|)
block|{
goto|goto
name|label_error
goto|;
block|}
block|}
if|if
condition|(
name|config_cache_oblivious
condition|)
block|{
comment|/* 		 * A nondeterministic seed based on the address of arena reduces 		 * the likelihood of lockstep non-uniform cache index 		 * utilization among identical concurrent processes, but at the 		 * cost of test repeatability.  For debug builds, instead use a 		 * deterministic seed. 		 */
name|atomic_store_zu
argument_list|(
operator|&
name|arena
operator|->
name|offset_state
argument_list|,
name|config_debug
condition|?
name|ind
else|:
operator|(
name|size_t
operator|)
operator|(
name|uintptr_t
operator|)
name|arena
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
block|}
name|atomic_store_zu
argument_list|(
operator|&
name|arena
operator|->
name|extent_sn_next
argument_list|,
literal|0
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
name|atomic_store_u
argument_list|(
operator|&
name|arena
operator|->
name|dss_prec
argument_list|,
operator|(
name|unsigned
operator|)
name|extent_dss_prec_get
argument_list|()
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
name|atomic_store_zu
argument_list|(
operator|&
name|arena
operator|->
name|nactive
argument_list|,
literal|0
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
name|extent_list_init
argument_list|(
operator|&
name|arena
operator|->
name|large
argument_list|)
expr_stmt|;
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|arena
operator|->
name|large_mtx
argument_list|,
literal|"arena_large"
argument_list|,
name|WITNESS_RANK_ARENA_LARGE
argument_list|,
name|malloc_mutex_rank_exclusive
argument_list|)
condition|)
block|{
goto|goto
name|label_error
goto|;
block|}
comment|/* 	 * Delay coalescing for dirty extents despite the disruptive effect on 	 * memory layout for best-fit extent allocation, since cached extents 	 * are likely to be reused soon after deallocation, and the cost of 	 * merging/splitting extents is non-trivial. 	 */
if|if
condition|(
name|extents_init
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|extents_dirty
argument_list|,
name|extent_state_dirty
argument_list|,
name|true
argument_list|)
condition|)
block|{
goto|goto
name|label_error
goto|;
block|}
comment|/* 	 * Coalesce muzzy extents immediately, because operations on them are in 	 * the critical path much less often than for dirty extents. 	 */
if|if
condition|(
name|extents_init
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|extents_muzzy
argument_list|,
name|extent_state_muzzy
argument_list|,
name|false
argument_list|)
condition|)
block|{
goto|goto
name|label_error
goto|;
block|}
comment|/* 	 * Coalesce retained extents immediately, in part because they will 	 * never be evicted (and therefore there's no opportunity for delayed 	 * coalescing), but also because operations on retained extents are not 	 * in the critical path. 	 */
if|if
condition|(
name|extents_init
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|extents_retained
argument_list|,
name|extent_state_retained
argument_list|,
name|false
argument_list|)
condition|)
block|{
goto|goto
name|label_error
goto|;
block|}
if|if
condition|(
name|arena_decay_init
argument_list|(
operator|&
name|arena
operator|->
name|decay_dirty
argument_list|,
operator|&
name|arena
operator|->
name|extents_dirty
argument_list|,
name|arena_dirty_decay_ms_default_get
argument_list|()
argument_list|,
operator|&
name|arena
operator|->
name|stats
operator|.
name|decay_dirty
argument_list|)
condition|)
block|{
goto|goto
name|label_error
goto|;
block|}
if|if
condition|(
name|arena_decay_init
argument_list|(
operator|&
name|arena
operator|->
name|decay_muzzy
argument_list|,
operator|&
name|arena
operator|->
name|extents_muzzy
argument_list|,
name|arena_muzzy_decay_ms_default_get
argument_list|()
argument_list|,
operator|&
name|arena
operator|->
name|stats
operator|.
name|decay_muzzy
argument_list|)
condition|)
block|{
goto|goto
name|label_error
goto|;
block|}
name|arena
operator|->
name|extent_grow_next
operator|=
name|sz_psz2ind
argument_list|(
name|HUGEPAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|arena
operator|->
name|extent_grow_mtx
argument_list|,
literal|"extent_grow"
argument_list|,
name|WITNESS_RANK_EXTENT_GROW
argument_list|,
name|malloc_mutex_rank_exclusive
argument_list|)
condition|)
block|{
goto|goto
name|label_error
goto|;
block|}
name|extent_avail_new
argument_list|(
operator|&
name|arena
operator|->
name|extent_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|arena
operator|->
name|extent_avail_mtx
argument_list|,
literal|"extent_avail"
argument_list|,
name|WITNESS_RANK_EXTENT_AVAIL
argument_list|,
name|malloc_mutex_rank_exclusive
argument_list|)
condition|)
block|{
goto|goto
name|label_error
goto|;
block|}
comment|/* Initialize bins. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
name|arena_bin_t
modifier|*
name|bin
init|=
operator|&
name|arena
operator|->
name|bins
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|,
literal|"arena_bin"
argument_list|,
name|WITNESS_RANK_ARENA_BIN
argument_list|,
name|malloc_mutex_rank_exclusive
argument_list|)
condition|)
block|{
goto|goto
name|label_error
goto|;
block|}
name|bin
operator|->
name|slabcur
operator|=
name|NULL
expr_stmt|;
name|extent_heap_new
argument_list|(
operator|&
name|bin
operator|->
name|slabs_nonfull
argument_list|)
expr_stmt|;
name|extent_list_init
argument_list|(
operator|&
name|bin
operator|->
name|slabs_full
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|memset
argument_list|(
operator|&
name|bin
operator|->
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|malloc_bin_stats_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|arena
operator|->
name|base
operator|=
name|base
expr_stmt|;
comment|/* Set arena before creating background threads. */
name|arena_set
argument_list|(
name|ind
argument_list|,
name|arena
argument_list|)
expr_stmt|;
name|nstime_init
argument_list|(
operator|&
name|arena
operator|->
name|create_time
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nstime_update
argument_list|(
operator|&
name|arena
operator|->
name|create_time
argument_list|)
expr_stmt|;
comment|/* We don't support reentrancy for arena 0 bootstrapping. */
if|if
condition|(
name|ind
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * If we're here, then arena 0 already exists, so bootstrapping 		 * is done enough that we should have tsd. 		 */
name|assert
argument_list|(
operator|!
name|tsdn_null
argument_list|(
name|tsdn
argument_list|)
argument_list|)
expr_stmt|;
name|pre_reentrancy
argument_list|(
name|tsdn_tsd
argument_list|(
name|tsdn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hooks_arena_new_hook
condition|)
block|{
name|hooks_arena_new_hook
argument_list|()
expr_stmt|;
block|}
name|post_reentrancy
argument_list|(
name|tsdn_tsd
argument_list|(
name|tsdn
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|arena
return|;
name|label_error
label|:
if|if
condition|(
name|ind
operator|!=
literal|0
condition|)
block|{
name|base_delete
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|arena_boot
parameter_list|(
name|void
parameter_list|)
block|{
name|arena_dirty_decay_ms_default_set
argument_list|(
name|opt_dirty_decay_ms
argument_list|)
expr_stmt|;
name|arena_muzzy_decay_ms_default_set
argument_list|(
name|opt_muzzy_decay_ms
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_prefork0
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|malloc_mutex_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|decay_dirty
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|decay_muzzy
operator|.
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_prefork1
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
if|if
condition|(
name|config_stats
condition|)
block|{
name|malloc_mutex_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|tcache_ql_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|arena_prefork2
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|extents_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|extents_dirty
argument_list|)
expr_stmt|;
name|extents_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|extents_muzzy
argument_list|)
expr_stmt|;
name|extents_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|extents_retained
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_prefork3
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|malloc_mutex_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|extent_avail_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_prefork4
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|base_prefork
argument_list|(
name|tsdn
argument_list|,
name|arena
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_prefork5
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|malloc_mutex_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|large_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_prefork6
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
name|malloc_mutex_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|arena_postfork_parent
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
name|malloc_mutex_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|large_mtx
argument_list|)
expr_stmt|;
name|base_postfork_parent
argument_list|(
name|tsdn
argument_list|,
name|arena
operator|->
name|base
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|extent_avail_mtx
argument_list|)
expr_stmt|;
name|extents_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|extents_dirty
argument_list|)
expr_stmt|;
name|extents_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|extents_muzzy
argument_list|)
expr_stmt|;
name|extents_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|extents_retained
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|decay_dirty
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|decay_muzzy
operator|.
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|malloc_mutex_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|tcache_ql_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|arena_postfork_child
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
name|malloc_mutex_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|large_mtx
argument_list|)
expr_stmt|;
name|base_postfork_child
argument_list|(
name|tsdn
argument_list|,
name|arena
operator|->
name|base
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|extent_avail_mtx
argument_list|)
expr_stmt|;
name|extents_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|extents_dirty
argument_list|)
expr_stmt|;
name|extents_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|extents_muzzy
argument_list|)
expr_stmt|;
name|extents_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|extents_retained
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|decay_dirty
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|decay_muzzy
operator|.
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|malloc_mutex_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|tcache_ql_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

