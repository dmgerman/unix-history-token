begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|JEMALLOC_RTREE_C_
end_define

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_preamble.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_internal_includes.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/assert.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/mutex.h"
end_include

begin_comment
comment|/*  * Only the most significant bits of keys passed to rtree_{read,write}() are  * used.  */
end_comment

begin_function
name|bool
name|rtree_new
parameter_list|(
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|bool
name|zeroed
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|JEMALLOC_JET
if|if
condition|(
operator|!
name|zeroed
condition|)
block|{
name|memset
argument_list|(
name|rtree
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rtree_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Clear root. */
block|}
else|#
directive|else
name|assert
argument_list|(
name|zeroed
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|rtree
operator|->
name|init_lock
argument_list|,
literal|"rtree"
argument_list|,
name|WITNESS_RANK_RTREE
argument_list|,
name|malloc_mutex_rank_exclusive
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|rtree_node_elm_t
modifier|*
name|rtree_node_alloc_impl
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|size_t
name|nelms
parameter_list|)
block|{
return|return
operator|(
name|rtree_node_elm_t
operator|*
operator|)
name|base_alloc
argument_list|(
name|tsdn
argument_list|,
name|b0get
argument_list|()
argument_list|,
name|nelms
operator|*
sizeof|sizeof
argument_list|(
name|rtree_node_elm_t
argument_list|)
argument_list|,
name|CACHELINE
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|rtree_node_alloc_t
modifier|*
name|JET_MUTABLE
name|rtree_node_alloc
init|=
name|rtree_node_alloc_impl
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|rtree_node_dalloc_impl
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_node_elm_t
modifier|*
name|node
parameter_list|)
block|{
comment|/* Nodes are never deleted during normal operation. */
name|not_reached
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|UNUSED
name|rtree_node_dalloc_t
modifier|*
name|JET_MUTABLE
name|rtree_node_dalloc
init|=
name|rtree_node_dalloc_impl
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|rtree_leaf_elm_t
modifier|*
name|rtree_leaf_alloc_impl
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|size_t
name|nelms
parameter_list|)
block|{
return|return
operator|(
name|rtree_leaf_elm_t
operator|*
operator|)
name|base_alloc
argument_list|(
name|tsdn
argument_list|,
name|b0get
argument_list|()
argument_list|,
name|nelms
operator|*
sizeof|sizeof
argument_list|(
name|rtree_leaf_elm_t
argument_list|)
argument_list|,
name|CACHELINE
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|rtree_leaf_alloc_t
modifier|*
name|JET_MUTABLE
name|rtree_leaf_alloc
init|=
name|rtree_leaf_alloc_impl
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|rtree_leaf_dalloc_impl
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_leaf_elm_t
modifier|*
name|leaf
parameter_list|)
block|{
comment|/* Leaves are never deleted during normal operation. */
name|not_reached
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|UNUSED
name|rtree_leaf_dalloc_t
modifier|*
name|JET_MUTABLE
name|rtree_leaf_dalloc
init|=
name|rtree_leaf_dalloc_impl
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_JET
end_ifdef

begin_if
if|#
directive|if
name|RTREE_HEIGHT
operator|>
literal|1
end_if

begin_function
specifier|static
name|void
name|rtree_delete_subtree
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_node_elm_t
modifier|*
name|subtree
parameter_list|,
name|unsigned
name|level
parameter_list|)
block|{
name|size_t
name|nchildren
init|=
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
name|rtree_levels
index|[
name|level
index|]
operator|.
name|bits
decl_stmt|;
if|if
condition|(
name|level
operator|+
literal|2
operator|<
name|RTREE_HEIGHT
condition|)
block|{
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nchildren
condition|;
name|i
operator|++
control|)
block|{
name|rtree_node_elm_t
modifier|*
name|node
init|=
operator|(
name|rtree_node_elm_t
operator|*
operator|)
name|atomic_load_p
argument_list|(
operator|&
name|subtree
index|[
name|i
index|]
operator|.
name|child
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
name|rtree_delete_subtree
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|node
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nchildren
condition|;
name|i
operator|++
control|)
block|{
name|rtree_leaf_elm_t
modifier|*
name|leaf
init|=
operator|(
name|rtree_leaf_elm_t
operator|*
operator|)
name|atomic_load_p
argument_list|(
operator|&
name|subtree
index|[
name|i
index|]
operator|.
name|child
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
decl_stmt|;
if|if
condition|(
name|leaf
operator|!=
name|NULL
condition|)
block|{
name|rtree_leaf_dalloc
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|leaf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|subtree
operator|!=
name|rtree
operator|->
name|root
condition|)
block|{
name|rtree_node_dalloc
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|subtree
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|rtree_delete
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|)
block|{
if|#
directive|if
name|RTREE_HEIGHT
operator|>
literal|1
name|rtree_delete_subtree
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|rtree
operator|->
name|root
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|rtree_node_elm_t
modifier|*
name|rtree_node_init
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|unsigned
name|level
parameter_list|,
name|atomic_p_t
modifier|*
name|elmp
parameter_list|)
block|{
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|rtree
operator|->
name|init_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If *elmp is non-null, then it was initialized with the init lock 	 * held, so we can get by with 'relaxed' here. 	 */
name|rtree_node_elm_t
modifier|*
name|node
init|=
name|atomic_load_p
argument_list|(
name|elmp
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
name|node
operator|=
name|rtree_node_alloc
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
name|rtree_levels
index|[
name|level
index|]
operator|.
name|bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|rtree
operator|->
name|init_lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 		 * Even though we hold the lock, a later reader might not; we 		 * need release semantics. 		 */
name|atomic_store_p
argument_list|(
name|elmp
argument_list|,
name|node
argument_list|,
name|ATOMIC_RELEASE
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|rtree
operator|->
name|init_lock
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_function
specifier|static
name|rtree_leaf_elm_t
modifier|*
name|rtree_leaf_init
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|atomic_p_t
modifier|*
name|elmp
parameter_list|)
block|{
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|rtree
operator|->
name|init_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If *elmp is non-null, then it was initialized with the init lock 	 * held, so we can get by with 'relaxed' here. 	 */
name|rtree_leaf_elm_t
modifier|*
name|leaf
init|=
name|atomic_load_p
argument_list|(
name|elmp
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
decl_stmt|;
if|if
condition|(
name|leaf
operator|==
name|NULL
condition|)
block|{
name|leaf
operator|=
name|rtree_leaf_alloc
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
name|rtree_levels
index|[
name|RTREE_HEIGHT
operator|-
literal|1
index|]
operator|.
name|bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|leaf
operator|==
name|NULL
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|rtree
operator|->
name|init_lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 		 * Even though we hold the lock, a later reader might not; we 		 * need release semantics. 		 */
name|atomic_store_p
argument_list|(
name|elmp
argument_list|,
name|leaf
argument_list|,
name|ATOMIC_RELEASE
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|rtree
operator|->
name|init_lock
argument_list|)
expr_stmt|;
return|return
name|leaf
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|rtree_node_valid
parameter_list|(
name|rtree_node_elm_t
modifier|*
name|node
parameter_list|)
block|{
return|return
operator|(
operator|(
name|uintptr_t
operator|)
name|node
operator|!=
operator|(
name|uintptr_t
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|rtree_leaf_valid
parameter_list|(
name|rtree_leaf_elm_t
modifier|*
name|leaf
parameter_list|)
block|{
return|return
operator|(
operator|(
name|uintptr_t
operator|)
name|leaf
operator|!=
operator|(
name|uintptr_t
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|rtree_node_elm_t
modifier|*
name|rtree_child_node_tryread
parameter_list|(
name|rtree_node_elm_t
modifier|*
name|elm
parameter_list|,
name|bool
name|dependent
parameter_list|)
block|{
name|rtree_node_elm_t
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|dependent
condition|)
block|{
name|node
operator|=
operator|(
name|rtree_node_elm_t
operator|*
operator|)
name|atomic_load_p
argument_list|(
operator|&
name|elm
operator|->
name|child
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|node
operator|=
operator|(
name|rtree_node_elm_t
operator|*
operator|)
name|atomic_load_p
argument_list|(
operator|&
name|elm
operator|->
name|child
argument_list|,
name|ATOMIC_ACQUIRE
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
operator|!
name|dependent
operator|||
name|node
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_function
specifier|static
name|rtree_node_elm_t
modifier|*
name|rtree_child_node_read
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_node_elm_t
modifier|*
name|elm
parameter_list|,
name|unsigned
name|level
parameter_list|,
name|bool
name|dependent
parameter_list|)
block|{
name|rtree_node_elm_t
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|rtree_child_node_tryread
argument_list|(
name|elm
argument_list|,
name|dependent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dependent
operator|&&
name|unlikely
argument_list|(
operator|!
name|rtree_node_valid
argument_list|(
name|node
argument_list|)
argument_list|)
condition|)
block|{
name|node
operator|=
name|rtree_node_init
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
name|level
operator|+
literal|1
argument_list|,
operator|&
name|elm
operator|->
name|child
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
operator|!
name|dependent
operator|||
name|node
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_function
specifier|static
name|rtree_leaf_elm_t
modifier|*
name|rtree_child_leaf_tryread
parameter_list|(
name|rtree_node_elm_t
modifier|*
name|elm
parameter_list|,
name|bool
name|dependent
parameter_list|)
block|{
name|rtree_leaf_elm_t
modifier|*
name|leaf
decl_stmt|;
if|if
condition|(
name|dependent
condition|)
block|{
name|leaf
operator|=
operator|(
name|rtree_leaf_elm_t
operator|*
operator|)
name|atomic_load_p
argument_list|(
operator|&
name|elm
operator|->
name|child
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|leaf
operator|=
operator|(
name|rtree_leaf_elm_t
operator|*
operator|)
name|atomic_load_p
argument_list|(
operator|&
name|elm
operator|->
name|child
argument_list|,
name|ATOMIC_ACQUIRE
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
operator|!
name|dependent
operator|||
name|leaf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|leaf
return|;
block|}
end_function

begin_function
specifier|static
name|rtree_leaf_elm_t
modifier|*
name|rtree_child_leaf_read
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_node_elm_t
modifier|*
name|elm
parameter_list|,
name|unsigned
name|level
parameter_list|,
name|bool
name|dependent
parameter_list|)
block|{
name|rtree_leaf_elm_t
modifier|*
name|leaf
decl_stmt|;
name|leaf
operator|=
name|rtree_child_leaf_tryread
argument_list|(
name|elm
argument_list|,
name|dependent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dependent
operator|&&
name|unlikely
argument_list|(
operator|!
name|rtree_leaf_valid
argument_list|(
name|leaf
argument_list|)
argument_list|)
condition|)
block|{
name|leaf
operator|=
name|rtree_leaf_init
argument_list|(
name|tsdn
argument_list|,
name|rtree
argument_list|,
operator|&
name|elm
operator|->
name|child
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
operator|!
name|dependent
operator|||
name|leaf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|leaf
return|;
block|}
end_function

begin_function
name|rtree_leaf_elm_t
modifier|*
name|rtree_leaf_elm_lookup_hard
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|rtree_t
modifier|*
name|rtree
parameter_list|,
name|rtree_ctx_t
modifier|*
name|rtree_ctx
parameter_list|,
name|uintptr_t
name|key
parameter_list|,
name|bool
name|dependent
parameter_list|,
name|bool
name|init_missing
parameter_list|)
block|{
name|rtree_node_elm_t
modifier|*
name|node
decl_stmt|;
name|rtree_leaf_elm_t
modifier|*
name|leaf
decl_stmt|;
if|#
directive|if
name|RTREE_HEIGHT
operator|>
literal|1
name|node
operator|=
name|rtree
operator|->
name|root
expr_stmt|;
else|#
directive|else
name|leaf
operator|=
name|rtree
operator|->
name|root
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|config_debug
condition|)
block|{
name|uintptr_t
name|leafkey
init|=
name|rtree_leafkey
argument_list|(
name|key
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|RTREE_CTX_NCACHE
condition|;
name|i
operator|++
control|)
block|{
name|assert
argument_list|(
name|rtree_ctx
operator|->
name|cache
index|[
name|i
index|]
operator|.
name|leafkey
operator|!=
name|leafkey
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|RTREE_CTX_NCACHE_L2
condition|;
name|i
operator|++
control|)
block|{
name|assert
argument_list|(
name|rtree_ctx
operator|->
name|l2_cache
index|[
name|i
index|]
operator|.
name|leafkey
operator|!=
name|leafkey
argument_list|)
expr_stmt|;
block|}
block|}
define|#
directive|define
name|RTREE_GET_CHILD
parameter_list|(
name|level
parameter_list|)
value|{					\ 		assert(level< RTREE_HEIGHT-1);				\ 		if (level != 0&& !dependent&&				\ 		    unlikely(!rtree_node_valid(node))) {		\ 			return NULL;					\ 		}							\ 		uintptr_t subkey = rtree_subkey(key, level);		\ 		if (level + 2< RTREE_HEIGHT) {				\ 			node = init_missing ?				\ 			    rtree_child_node_read(tsdn, rtree,		\&node[subkey], level, dependent) :		\ 			    rtree_child_node_tryread(&node[subkey],	\ 			    dependent);					\ 		} else {						\ 			leaf = init_missing ?				\ 			    rtree_child_leaf_read(tsdn, rtree,		\&node[subkey], level, dependent) :		\ 			    rtree_child_leaf_tryread(&node[subkey],	\ 			    dependent);					\ 		}							\ 	}
comment|/* 	 * Cache replacement upon hard lookup (i.e. L1& L2 rtree cache miss): 	 * (1) evict last entry in L2 cache; (2) move the collision slot from L1 	 * cache down to L2; and 3) fill L1. 	 */
define|#
directive|define
name|RTREE_GET_LEAF
parameter_list|(
name|level
parameter_list|)
value|{						\ 		assert(level == RTREE_HEIGHT-1);			\ 		if (!dependent&& unlikely(!rtree_leaf_valid(leaf))) {	\ 			return NULL;					\ 		}							\ 		if (RTREE_CTX_NCACHE_L2> 1) {				\ 			memmove(&rtree_ctx->l2_cache[1],		\&rtree_ctx->l2_cache[0],			\ 			    sizeof(rtree_ctx_cache_elm_t) *		\ 			    (RTREE_CTX_NCACHE_L2 - 1));			\ 		}							\ 		size_t slot = rtree_cache_direct_map(key);		\ 		rtree_ctx->l2_cache[0].leafkey =			\ 		    rtree_ctx->cache[slot].leafkey;			\ 		rtree_ctx->l2_cache[0].leaf =				\ 		    rtree_ctx->cache[slot].leaf;			\ 		uintptr_t leafkey = rtree_leafkey(key);			\ 		rtree_ctx->cache[slot].leafkey = leafkey;		\ 		rtree_ctx->cache[slot].leaf = leaf;			\ 		uintptr_t subkey = rtree_subkey(key, level);		\ 		return&leaf[subkey];					\ 	}
if|if
condition|(
name|RTREE_HEIGHT
operator|>
literal|1
condition|)
block|{
name|RTREE_GET_CHILD
argument_list|(
literal|0
argument_list|)
block|}
if|if
condition|(
name|RTREE_HEIGHT
operator|>
literal|2
condition|)
block|{
name|RTREE_GET_CHILD
argument_list|(
literal|1
argument_list|)
block|}
if|if
condition|(
name|RTREE_HEIGHT
operator|>
literal|3
condition|)
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|2
init|;
name|i
operator|<
name|RTREE_HEIGHT
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|RTREE_GET_CHILD
argument_list|(
argument|i
argument_list|)
block|}
block|}
name|RTREE_GET_LEAF
argument_list|(
argument|RTREE_HEIGHT-
literal|1
argument_list|)
undef|#
directive|undef
name|RTREE_GET_CHILD
undef|#
directive|undef
name|RTREE_GET_LEAF
name|not_reached
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rtree_ctx_data_init
parameter_list|(
name|rtree_ctx_t
modifier|*
name|ctx
parameter_list|)
block|{
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|RTREE_CTX_NCACHE
condition|;
name|i
operator|++
control|)
block|{
name|rtree_ctx_cache_elm_t
modifier|*
name|cache
init|=
operator|&
name|ctx
operator|->
name|cache
index|[
name|i
index|]
decl_stmt|;
name|cache
operator|->
name|leafkey
operator|=
name|RTREE_LEAFKEY_INVALID
expr_stmt|;
name|cache
operator|->
name|leaf
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|RTREE_CTX_NCACHE_L2
condition|;
name|i
operator|++
control|)
block|{
name|rtree_ctx_cache_elm_t
modifier|*
name|cache
init|=
operator|&
name|ctx
operator|->
name|l2_cache
index|[
name|i
index|]
decl_stmt|;
name|cache
operator|->
name|leafkey
operator|=
name|RTREE_LEAFKEY_INVALID
expr_stmt|;
name|cache
operator|->
name|leaf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

end_unit

