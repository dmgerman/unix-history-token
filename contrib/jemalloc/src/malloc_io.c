begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|JEMALLOC_MALLOC_IO_C_
end_define

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_preamble.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_internal_includes.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/malloc_io.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/util.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|assert
end_ifdef

begin_undef
undef|#
directive|undef
name|assert
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|not_reached
end_ifdef

begin_undef
undef|#
directive|undef
name|not_reached
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|not_implemented
end_ifdef

begin_undef
undef|#
directive|undef
name|not_implemented
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|assert_not_implemented
end_ifdef

begin_undef
undef|#
directive|undef
name|assert_not_implemented
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Define simple versions of assertion macros that won't recurse in case  * of assertion failures in malloc_*printf().  */
end_comment

begin_define
define|#
directive|define
name|assert
parameter_list|(
name|e
parameter_list|)
value|do {							\ 	if (config_debug&& !(e)) {					\ 		malloc_write("<jemalloc>: Failed assertion\n");		\ 		abort();						\ 	}								\ } while (0)
end_define

begin_define
define|#
directive|define
name|not_reached
parameter_list|()
value|do {						\ 	if (config_debug) {						\ 		malloc_write("<jemalloc>: Unreachable code reached\n");	\ 		abort();						\ 	}								\ 	unreachable();							\ } while (0)
end_define

begin_define
define|#
directive|define
name|not_implemented
parameter_list|()
value|do {						\ 	if (config_debug) {						\ 		malloc_write("<jemalloc>: Not implemented\n");		\ 		abort();						\ 	}								\ } while (0)
end_define

begin_define
define|#
directive|define
name|assert_not_implemented
parameter_list|(
name|e
parameter_list|)
value|do {					\ 	if (unlikely(config_debug&& !(e))) {				\ 		not_implemented();					\ 	}								\ } while (0)
end_define

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/* Function prototypes for non-inline static functions. */
end_comment

begin_function_decl
specifier|static
name|void
name|wrtmessage
parameter_list|(
name|void
modifier|*
name|cbopaque
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|U2S_BUFSIZE
value|((1U<< (LG_SIZEOF_INTMAX_T + 3)) + 1)
end_define

begin_function_decl
specifier|static
name|char
modifier|*
name|u2s
parameter_list|(
name|uintmax_t
name|x
parameter_list|,
name|unsigned
name|base
parameter_list|,
name|bool
name|uppercase
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|size_t
modifier|*
name|slen_p
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|D2S_BUFSIZE
value|(1 + U2S_BUFSIZE)
end_define

begin_function_decl
specifier|static
name|char
modifier|*
name|d2s
parameter_list|(
name|intmax_t
name|x
parameter_list|,
name|char
name|sign
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|size_t
modifier|*
name|slen_p
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|O2S_BUFSIZE
value|(1 + U2S_BUFSIZE)
end_define

begin_function_decl
specifier|static
name|char
modifier|*
name|o2s
parameter_list|(
name|uintmax_t
name|x
parameter_list|,
name|bool
name|alt_form
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|size_t
modifier|*
name|slen_p
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|X2S_BUFSIZE
value|(2 + U2S_BUFSIZE)
end_define

begin_function_decl
specifier|static
name|char
modifier|*
name|x2s
parameter_list|(
name|uintmax_t
name|x
parameter_list|,
name|bool
name|alt_form
parameter_list|,
name|bool
name|uppercase
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|size_t
modifier|*
name|slen_p
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/* malloc_message() setup. */
end_comment

begin_function
specifier|static
name|void
name|wrtmessage
parameter_list|(
name|void
modifier|*
name|cbopaque
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|JEMALLOC_USE_SYSCALL
argument_list|)
operator|&&
name|defined
argument_list|(
name|SYS_write
argument_list|)
comment|/* 	 * Use syscall(2) rather than write(2) when possible in order to avoid 	 * the possibility of memory allocation within libc.  This is necessary 	 * on FreeBSD; most operating systems do not have this problem though. 	 * 	 * syscall() returns long or int, depending on platform, so capture the 	 * unused result in the widest plausible type to avoid compiler 	 * warnings. 	 */
name|UNUSED
name|long
name|result
init|=
name|syscall
argument_list|(
name|SYS_write
argument_list|,
name|STDERR_FILENO
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|UNUSED
name|ssize_t
name|result
init|=
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function_decl
name|JEMALLOC_EXPORT
name|void
function_decl|(
modifier|*
name|je_malloc_message
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_macro
name|JEMALLOC_ATTR
argument_list|(
argument|visibility(
literal|"hidden"
argument|)
argument_list|)
end_macro

begin_function
name|void
name|wrtmessage_1_0
parameter_list|(
specifier|const
name|char
modifier|*
name|s1
parameter_list|,
specifier|const
name|char
modifier|*
name|s2
parameter_list|,
specifier|const
name|char
modifier|*
name|s3
parameter_list|,
specifier|const
name|char
modifier|*
name|s4
parameter_list|)
block|{
name|wrtmessage
argument_list|(
name|NULL
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|wrtmessage
argument_list|(
name|NULL
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|wrtmessage
argument_list|(
name|NULL
argument_list|,
name|s3
argument_list|)
expr_stmt|;
name|wrtmessage
argument_list|(
name|NULL
argument_list|,
name|s4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|void
function_decl|(
modifier|*
name|__malloc_message_1_0
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
name|s1
parameter_list|,
specifier|const
name|char
modifier|*
name|s2
parameter_list|,
specifier|const
name|char
modifier|*
name|s3
parameter_list|,
specifier|const
name|char
modifier|*
name|s4
parameter_list|)
init|=
name|wrtmessage_1_0
function_decl|;
end_function_decl

begin_expr_stmt
name|__sym_compat
argument_list|(
name|_malloc_message
argument_list|,
name|__malloc_message_1_0
argument_list|,
name|FBSD_1
literal|.0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Wrapper around malloc_message() that avoids the need for  * je_malloc_message(...) throughout the code.  */
end_comment

begin_function
name|void
name|malloc_write
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|je_malloc_message
operator|!=
name|NULL
condition|)
block|{
name|je_malloc_message
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wrtmessage
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * glibc provides a non-standard strerror_r() when _GNU_SOURCE is defined, so  * provide a wrapper.  */
end_comment

begin_function
name|int
name|buferror
parameter_list|(
name|int
name|err
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_WIN32
name|FormatMessageA
argument_list|(
name|FORMAT_MESSAGE_FROM_SYSTEM
argument_list|,
name|NULL
argument_list|,
name|err
argument_list|,
literal|0
argument_list|,
operator|(
name|LPSTR
operator|)
name|buf
argument_list|,
operator|(
name|DWORD
operator|)
name|buflen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_GNU_SOURCE
argument_list|)
name|char
modifier|*
name|b
init|=
name|strerror_r
argument_list|(
name|err
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|!=
name|buf
condition|)
block|{
name|strncpy
argument_list|(
name|buf
argument_list|,
name|b
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|buf
index|[
name|buflen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
literal|0
return|;
else|#
directive|else
return|return
name|strerror_r
argument_list|(
name|err
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|uintmax_t
name|malloc_strtoumax
parameter_list|(
specifier|const
name|char
modifier|*
specifier|restrict
name|nptr
parameter_list|,
name|char
modifier|*
modifier|*
specifier|restrict
name|endptr
parameter_list|,
name|int
name|base
parameter_list|)
block|{
name|uintmax_t
name|ret
decl_stmt|,
name|digit
decl_stmt|;
name|unsigned
name|b
decl_stmt|;
name|bool
name|neg
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|ns
decl_stmt|;
name|p
operator|=
name|nptr
expr_stmt|;
if|if
condition|(
name|base
operator|<
literal|0
operator|||
name|base
operator|==
literal|1
operator|||
name|base
operator|>
literal|36
condition|)
block|{
name|ns
operator|=
name|p
expr_stmt|;
name|set_errno
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|ret
operator|=
name|UINTMAX_MAX
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
name|b
operator|=
name|base
expr_stmt|;
comment|/* Swallow leading whitespace and get sign, if any. */
name|neg
operator|=
name|false
expr_stmt|;
while|while
condition|(
name|true
condition|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\v'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\r'
case|:
case|case
literal|' '
case|:
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|neg
operator|=
name|true
expr_stmt|;
comment|/* Fall through. */
case|case
literal|'+'
case|:
name|p
operator|++
expr_stmt|;
comment|/* Fall through. */
default|default:
goto|goto
name|label_prefix
goto|;
block|}
block|}
comment|/* Get prefix, if any. */
name|label_prefix
label|:
comment|/* 	 * Note where the first non-whitespace/sign character is so that it is 	 * possible to tell whether any digits are consumed (e.g., "  0" vs. 	 * "  -x"). 	 */
name|ns
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'0'
condition|)
block|{
switch|switch
condition|(
name|p
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
if|if
condition|(
name|b
operator|==
literal|0
condition|)
block|{
name|b
operator|=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|==
literal|8
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'X'
case|:
case|case
literal|'x'
case|:
switch|switch
condition|(
name|p
index|[
literal|2
index|]
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
if|if
condition|(
name|b
operator|==
literal|0
condition|)
block|{
name|b
operator|=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|==
literal|16
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
break|break;
default|default:
name|p
operator|++
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
block|}
if|if
condition|(
name|b
operator|==
literal|0
condition|)
block|{
name|b
operator|=
literal|10
expr_stmt|;
block|}
comment|/* Convert. */
name|ret
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
operator|&&
operator|(
name|digit
operator|=
operator|*
name|p
operator|-
literal|'0'
operator|)
operator|<
name|b
operator|)
operator|||
operator|(
operator|*
name|p
operator|>=
literal|'A'
operator|&&
operator|*
name|p
operator|<=
literal|'Z'
operator|&&
operator|(
name|digit
operator|=
literal|10
operator|+
operator|*
name|p
operator|-
literal|'A'
operator|)
operator|<
name|b
operator|)
operator|||
operator|(
operator|*
name|p
operator|>=
literal|'a'
operator|&&
operator|*
name|p
operator|<=
literal|'z'
operator|&&
operator|(
name|digit
operator|=
literal|10
operator|+
operator|*
name|p
operator|-
literal|'a'
operator|)
operator|<
name|b
operator|)
condition|)
block|{
name|uintmax_t
name|pret
init|=
name|ret
decl_stmt|;
name|ret
operator|*=
name|b
expr_stmt|;
name|ret
operator|+=
name|digit
expr_stmt|;
if|if
condition|(
name|ret
operator|<
name|pret
condition|)
block|{
comment|/* Overflow. */
name|set_errno
argument_list|(
name|ERANGE
argument_list|)
expr_stmt|;
name|ret
operator|=
name|UINTMAX_MAX
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|neg
condition|)
block|{
name|ret
operator|=
call|(
name|uintmax_t
call|)
argument_list|(
operator|-
operator|(
operator|(
name|intmax_t
operator|)
name|ret
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|ns
condition|)
block|{
comment|/* No conversion performed. */
name|set_errno
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|ret
operator|=
name|UINTMAX_MAX
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
name|label_return
label|:
if|if
condition|(
name|endptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|ns
condition|)
block|{
comment|/* No characters were converted. */
operator|*
name|endptr
operator|=
operator|(
name|char
operator|*
operator|)
name|nptr
expr_stmt|;
block|}
else|else
block|{
operator|*
name|endptr
operator|=
operator|(
name|char
operator|*
operator|)
name|p
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|u2s
parameter_list|(
name|uintmax_t
name|x
parameter_list|,
name|unsigned
name|base
parameter_list|,
name|bool
name|uppercase
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|size_t
modifier|*
name|slen_p
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|i
operator|=
name|U2S_BUFSIZE
operator|-
literal|1
expr_stmt|;
name|s
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|base
condition|)
block|{
case|case
literal|10
case|:
do|do
block|{
name|i
operator|--
expr_stmt|;
name|s
index|[
name|i
index|]
operator|=
literal|"0123456789"
index|[
name|x
operator|%
operator|(
name|uint64_t
operator|)
literal|10
index|]
expr_stmt|;
name|x
operator|/=
operator|(
name|uint64_t
operator|)
literal|10
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|>
literal|0
condition|)
do|;
break|break;
case|case
literal|16
case|:
block|{
specifier|const
name|char
modifier|*
name|digits
init|=
operator|(
name|uppercase
operator|)
condition|?
literal|"0123456789ABCDEF"
else|:
literal|"0123456789abcdef"
decl_stmt|;
do|do
block|{
name|i
operator|--
expr_stmt|;
name|s
index|[
name|i
index|]
operator|=
name|digits
index|[
name|x
operator|&
literal|0xf
index|]
expr_stmt|;
name|x
operator|>>=
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|>
literal|0
condition|)
do|;
break|break;
block|}
default|default:
block|{
specifier|const
name|char
modifier|*
name|digits
init|=
operator|(
name|uppercase
operator|)
condition|?
literal|"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
else|:
literal|"0123456789abcdefghijklmnopqrstuvwxyz"
decl_stmt|;
name|assert
argument_list|(
name|base
operator|>=
literal|2
operator|&&
name|base
operator|<=
literal|36
argument_list|)
expr_stmt|;
do|do
block|{
name|i
operator|--
expr_stmt|;
name|s
index|[
name|i
index|]
operator|=
name|digits
index|[
name|x
operator|%
operator|(
name|uint64_t
operator|)
name|base
index|]
expr_stmt|;
name|x
operator|/=
operator|(
name|uint64_t
operator|)
name|base
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|>
literal|0
condition|)
do|;
block|}
block|}
operator|*
name|slen_p
operator|=
name|U2S_BUFSIZE
operator|-
literal|1
operator|-
name|i
expr_stmt|;
return|return
operator|&
name|s
index|[
name|i
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|d2s
parameter_list|(
name|intmax_t
name|x
parameter_list|,
name|char
name|sign
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|size_t
modifier|*
name|slen_p
parameter_list|)
block|{
name|bool
name|neg
decl_stmt|;
if|if
condition|(
operator|(
name|neg
operator|=
operator|(
name|x
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
name|x
operator|=
operator|-
name|x
expr_stmt|;
block|}
name|s
operator|=
name|u2s
argument_list|(
name|x
argument_list|,
literal|10
argument_list|,
name|false
argument_list|,
name|s
argument_list|,
name|slen_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg
condition|)
block|{
name|sign
operator|=
literal|'-'
expr_stmt|;
block|}
switch|switch
condition|(
name|sign
condition|)
block|{
case|case
literal|'-'
case|:
if|if
condition|(
operator|!
name|neg
condition|)
block|{
break|break;
block|}
comment|/* Fall through. */
case|case
literal|' '
case|:
case|case
literal|'+'
case|:
name|s
operator|--
expr_stmt|;
operator|(
operator|*
name|slen_p
operator|)
operator|++
expr_stmt|;
operator|*
name|s
operator|=
name|sign
expr_stmt|;
break|break;
default|default:
name|not_reached
argument_list|()
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|o2s
parameter_list|(
name|uintmax_t
name|x
parameter_list|,
name|bool
name|alt_form
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|size_t
modifier|*
name|slen_p
parameter_list|)
block|{
name|s
operator|=
name|u2s
argument_list|(
name|x
argument_list|,
literal|8
argument_list|,
name|false
argument_list|,
name|s
argument_list|,
name|slen_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|alt_form
operator|&&
operator|*
name|s
operator|!=
literal|'0'
condition|)
block|{
name|s
operator|--
expr_stmt|;
operator|(
operator|*
name|slen_p
operator|)
operator|++
expr_stmt|;
operator|*
name|s
operator|=
literal|'0'
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|x2s
parameter_list|(
name|uintmax_t
name|x
parameter_list|,
name|bool
name|alt_form
parameter_list|,
name|bool
name|uppercase
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|size_t
modifier|*
name|slen_p
parameter_list|)
block|{
name|s
operator|=
name|u2s
argument_list|(
name|x
argument_list|,
literal|16
argument_list|,
name|uppercase
argument_list|,
name|s
argument_list|,
name|slen_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|alt_form
condition|)
block|{
name|s
operator|-=
literal|2
expr_stmt|;
operator|(
operator|*
name|slen_p
operator|)
operator|+=
literal|2
expr_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|uppercase
condition|?
literal|"0X"
else|:
literal|"0x"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
name|size_t
name|malloc_vsnprintf
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|f
decl_stmt|;
define|#
directive|define
name|APPEND_C
parameter_list|(
name|c
parameter_list|)
value|do {						\ 	if (i< size) {							\ 		str[i] = (c);						\ 	}								\ 	i++;								\ } while (0)
define|#
directive|define
name|APPEND_S
parameter_list|(
name|s
parameter_list|,
name|slen
parameter_list|)
value|do {						\ 	if (i< size) {							\ 		size_t cpylen = (slen<= size - i) ? slen : size - i;	\ 		memcpy(&str[i], s, cpylen);				\ 	}								\ 	i += slen;							\ } while (0)
define|#
directive|define
name|APPEND_PADDED_S
parameter_list|(
name|s
parameter_list|,
name|slen
parameter_list|,
name|width
parameter_list|,
name|left_justify
parameter_list|)
value|do {		\
comment|/* Left padding. */
value|\ 	size_t pad_len = (width == -1) ? 0 : ((slen< (size_t)width) ?	\ 	    (size_t)width - slen : 0);					\ 	if (!left_justify&& pad_len != 0) {				\ 		size_t j;						\ 		for (j = 0; j< pad_len; j++) {				\ 			APPEND_C(' ');					\ 		}							\ 	}								\
comment|/* Value. */
value|\ 	APPEND_S(s, slen);						\
comment|/* Right padding. */
value|\ 	if (left_justify&& pad_len != 0) {				\ 		size_t j;						\ 		for (j = 0; j< pad_len; j++) {				\ 			APPEND_C(' ');					\ 		}							\ 	}								\ } while (0)
define|#
directive|define
name|GET_ARG_NUMERIC
parameter_list|(
name|val
parameter_list|,
name|len
parameter_list|)
value|do {					\ 	switch (len) {							\ 	case '?':							\ 		val = va_arg(ap, int);					\ 		break;							\ 	case '?' | 0x80:						\ 		val = va_arg(ap, unsigned int);				\ 		break;							\ 	case 'l':							\ 		val = va_arg(ap, long);					\ 		break;							\ 	case 'l' | 0x80:						\ 		val = va_arg(ap, unsigned long);			\ 		break;							\ 	case 'q':							\ 		val = va_arg(ap, long long);				\ 		break;							\ 	case 'q' | 0x80:						\ 		val = va_arg(ap, unsigned long long);			\ 		break;							\ 	case 'j':							\ 		val = va_arg(ap, intmax_t);				\ 		break;							\ 	case 'j' | 0x80:						\ 		val = va_arg(ap, uintmax_t);				\ 		break;							\ 	case 't':							\ 		val = va_arg(ap, ptrdiff_t);				\ 		break;							\ 	case 'z':							\ 		val = va_arg(ap, ssize_t);				\ 		break;							\ 	case 'z' | 0x80:						\ 		val = va_arg(ap, size_t);				\ 		break;							\ 	case 'p':
comment|/* Synthetic; used for %p. */
value|\ 		val = va_arg(ap, uintptr_t);				\ 		break;							\ 	default:							\ 		not_reached();						\ 		val = 0;						\ 	}								\ } while (0)
name|i
operator|=
literal|0
expr_stmt|;
name|f
operator|=
name|format
expr_stmt|;
while|while
condition|(
name|true
condition|)
block|{
switch|switch
condition|(
operator|*
name|f
condition|)
block|{
case|case
literal|'\0'
case|:
goto|goto
name|label_out
goto|;
case|case
literal|'%'
case|:
block|{
name|bool
name|alt_form
init|=
name|false
decl_stmt|;
name|bool
name|left_justify
init|=
name|false
decl_stmt|;
name|bool
name|plus_space
init|=
name|false
decl_stmt|;
name|bool
name|plus_plus
init|=
name|false
decl_stmt|;
name|int
name|prec
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|width
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|char
name|len
init|=
literal|'?'
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|slen
decl_stmt|;
name|f
operator|++
expr_stmt|;
comment|/* Flags. */
while|while
condition|(
name|true
condition|)
block|{
switch|switch
condition|(
operator|*
name|f
condition|)
block|{
case|case
literal|'#'
case|:
name|assert
argument_list|(
operator|!
name|alt_form
argument_list|)
expr_stmt|;
name|alt_form
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|assert
argument_list|(
operator|!
name|left_justify
argument_list|)
expr_stmt|;
name|left_justify
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|' '
case|:
name|assert
argument_list|(
operator|!
name|plus_space
argument_list|)
expr_stmt|;
name|plus_space
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|assert
argument_list|(
operator|!
name|plus_plus
argument_list|)
expr_stmt|;
name|plus_plus
operator|=
name|true
expr_stmt|;
break|break;
default|default:
goto|goto
name|label_width
goto|;
block|}
name|f
operator|++
expr_stmt|;
block|}
comment|/* Width. */
name|label_width
label|:
switch|switch
condition|(
operator|*
name|f
condition|)
block|{
case|case
literal|'*'
case|:
name|width
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|f
operator|++
expr_stmt|;
if|if
condition|(
name|width
operator|<
literal|0
condition|)
block|{
name|left_justify
operator|=
name|true
expr_stmt|;
name|width
operator|=
operator|-
name|width
expr_stmt|;
block|}
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
block|{
name|uintmax_t
name|uwidth
decl_stmt|;
name|set_errno
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|uwidth
operator|=
name|malloc_strtoumax
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|f
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|uwidth
operator|!=
name|UINTMAX_MAX
operator|||
name|get_errno
argument_list|()
operator|!=
name|ERANGE
argument_list|)
expr_stmt|;
name|width
operator|=
operator|(
name|int
operator|)
name|uwidth
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
comment|/* Width/precision separator. */
if|if
condition|(
operator|*
name|f
operator|==
literal|'.'
condition|)
block|{
name|f
operator|++
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|label_length
goto|;
block|}
comment|/* Precision. */
switch|switch
condition|(
operator|*
name|f
condition|)
block|{
case|case
literal|'*'
case|:
name|prec
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|f
operator|++
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
block|{
name|uintmax_t
name|uprec
decl_stmt|;
name|set_errno
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|uprec
operator|=
name|malloc_strtoumax
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|f
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|uprec
operator|!=
name|UINTMAX_MAX
operator|||
name|get_errno
argument_list|()
operator|!=
name|ERANGE
argument_list|)
expr_stmt|;
name|prec
operator|=
operator|(
name|int
operator|)
name|uprec
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
comment|/* Length. */
name|label_length
label|:
switch|switch
condition|(
operator|*
name|f
condition|)
block|{
case|case
literal|'l'
case|:
name|f
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|f
operator|==
literal|'l'
condition|)
block|{
name|len
operator|=
literal|'q'
expr_stmt|;
name|f
operator|++
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
literal|'l'
expr_stmt|;
block|}
break|break;
case|case
literal|'q'
case|:
case|case
literal|'j'
case|:
case|case
literal|'t'
case|:
case|case
literal|'z'
case|:
name|len
operator|=
operator|*
name|f
expr_stmt|;
name|f
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Conversion specifier. */
switch|switch
condition|(
operator|*
name|f
condition|)
block|{
case|case
literal|'%'
case|:
comment|/* %% */
name|APPEND_C
argument_list|(
operator|*
name|f
argument_list|)
expr_stmt|;
name|f
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
block|{
name|intmax_t
name|val
name|JEMALLOC_CC_SILENCE_INIT
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
name|D2S_BUFSIZE
index|]
decl_stmt|;
name|GET_ARG_NUMERIC
argument_list|(
name|val
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|=
name|d2s
argument_list|(
name|val
argument_list|,
operator|(
name|plus_plus
condition|?
literal|'+'
else|:
operator|(
name|plus_space
condition|?
literal|' '
else|:
literal|'-'
operator|)
operator|)
argument_list|,
name|buf
argument_list|,
operator|&
name|slen
argument_list|)
expr_stmt|;
name|APPEND_PADDED_S
argument_list|(
name|s
argument_list|,
name|slen
argument_list|,
name|width
argument_list|,
name|left_justify
argument_list|)
expr_stmt|;
name|f
operator|++
expr_stmt|;
break|break;
block|}
case|case
literal|'o'
case|:
block|{
name|uintmax_t
name|val
name|JEMALLOC_CC_SILENCE_INIT
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
name|O2S_BUFSIZE
index|]
decl_stmt|;
name|GET_ARG_NUMERIC
argument_list|(
name|val
argument_list|,
name|len
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|s
operator|=
name|o2s
argument_list|(
name|val
argument_list|,
name|alt_form
argument_list|,
name|buf
argument_list|,
operator|&
name|slen
argument_list|)
expr_stmt|;
name|APPEND_PADDED_S
argument_list|(
name|s
argument_list|,
name|slen
argument_list|,
name|width
argument_list|,
name|left_justify
argument_list|)
expr_stmt|;
name|f
operator|++
expr_stmt|;
break|break;
block|}
case|case
literal|'u'
case|:
block|{
name|uintmax_t
name|val
name|JEMALLOC_CC_SILENCE_INIT
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
name|U2S_BUFSIZE
index|]
decl_stmt|;
name|GET_ARG_NUMERIC
argument_list|(
name|val
argument_list|,
name|len
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|s
operator|=
name|u2s
argument_list|(
name|val
argument_list|,
literal|10
argument_list|,
name|false
argument_list|,
name|buf
argument_list|,
operator|&
name|slen
argument_list|)
expr_stmt|;
name|APPEND_PADDED_S
argument_list|(
name|s
argument_list|,
name|slen
argument_list|,
name|width
argument_list|,
name|left_justify
argument_list|)
expr_stmt|;
name|f
operator|++
expr_stmt|;
break|break;
block|}
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
block|{
name|uintmax_t
name|val
name|JEMALLOC_CC_SILENCE_INIT
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
name|X2S_BUFSIZE
index|]
decl_stmt|;
name|GET_ARG_NUMERIC
argument_list|(
name|val
argument_list|,
name|len
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|s
operator|=
name|x2s
argument_list|(
name|val
argument_list|,
name|alt_form
argument_list|,
operator|*
name|f
operator|==
literal|'X'
argument_list|,
name|buf
argument_list|,
operator|&
name|slen
argument_list|)
expr_stmt|;
name|APPEND_PADDED_S
argument_list|(
name|s
argument_list|,
name|slen
argument_list|,
name|width
argument_list|,
name|left_justify
argument_list|)
expr_stmt|;
name|f
operator|++
expr_stmt|;
break|break;
block|}
case|case
literal|'c'
case|:
block|{
name|unsigned
name|char
name|val
decl_stmt|;
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|assert
argument_list|(
name|len
operator|==
literal|'?'
operator|||
name|len
operator|==
literal|'l'
argument_list|)
expr_stmt|;
name|assert_not_implemented
argument_list|(
name|len
operator|!=
literal|'l'
argument_list|)
expr_stmt|;
name|val
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|APPEND_PADDED_S
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|width
argument_list|,
name|left_justify
argument_list|)
expr_stmt|;
name|f
operator|++
expr_stmt|;
break|break;
block|}
case|case
literal|'s'
case|:
name|assert
argument_list|(
name|len
operator|==
literal|'?'
operator|||
name|len
operator|==
literal|'l'
argument_list|)
expr_stmt|;
name|assert_not_implemented
argument_list|(
name|len
operator|!=
literal|'l'
argument_list|)
expr_stmt|;
name|s
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|slen
operator|=
operator|(
name|prec
operator|<
literal|0
operator|)
condition|?
name|strlen
argument_list|(
name|s
argument_list|)
else|:
operator|(
name|size_t
operator|)
name|prec
expr_stmt|;
name|APPEND_PADDED_S
argument_list|(
name|s
argument_list|,
name|slen
argument_list|,
name|width
argument_list|,
name|left_justify
argument_list|)
expr_stmt|;
name|f
operator|++
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
block|{
name|uintmax_t
name|val
decl_stmt|;
name|char
name|buf
index|[
name|X2S_BUFSIZE
index|]
decl_stmt|;
name|GET_ARG_NUMERIC
argument_list|(
name|val
argument_list|,
literal|'p'
argument_list|)
expr_stmt|;
name|s
operator|=
name|x2s
argument_list|(
name|val
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
name|buf
argument_list|,
operator|&
name|slen
argument_list|)
expr_stmt|;
name|APPEND_PADDED_S
argument_list|(
name|s
argument_list|,
name|slen
argument_list|,
name|width
argument_list|,
name|left_justify
argument_list|)
expr_stmt|;
name|f
operator|++
expr_stmt|;
break|break;
block|}
default|default:
name|not_reached
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
default|default:
block|{
name|APPEND_C
argument_list|(
operator|*
name|f
argument_list|)
expr_stmt|;
name|f
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
name|label_out
label|:
if|if
condition|(
name|i
operator|<
name|size
condition|)
block|{
name|str
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|str
index|[
name|size
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
undef|#
directive|undef
name|APPEND_C
undef|#
directive|undef
name|APPEND_S
undef|#
directive|undef
name|APPEND_PADDED_S
undef|#
directive|undef
name|GET_ARG_NUMERIC
return|return
name|i
return|;
block|}
end_function

begin_macro
name|JEMALLOC_FORMAT_PRINTF
argument_list|(
literal|3
argument_list|,
literal|4
argument_list|)
end_macro

begin_function
name|size_t
name|malloc_snprintf
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|size_t
name|ret
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|ret
operator|=
name|malloc_vsnprintf
argument_list|(
name|str
argument_list|,
name|size
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|malloc_vcprintf
parameter_list|(
name|void
function_decl|(
modifier|*
name|write_cb
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|cbopaque
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|char
name|buf
index|[
name|MALLOC_PRINTF_BUFSIZE
index|]
decl_stmt|;
if|if
condition|(
name|write_cb
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * The caller did not provide an alternate write_cb callback 		 * function, so use the default one.  malloc_write() is an 		 * inline function, so use malloc_message() directly here. 		 */
name|write_cb
operator|=
operator|(
name|je_malloc_message
operator|!=
name|NULL
operator|)
condition|?
name|je_malloc_message
else|:
name|wrtmessage
expr_stmt|;
name|cbopaque
operator|=
name|NULL
expr_stmt|;
block|}
name|malloc_vsnprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|write_cb
argument_list|(
name|cbopaque
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print to a callback function in such a way as to (hopefully) avoid memory  * allocation.  */
end_comment

begin_macro
name|JEMALLOC_FORMAT_PRINTF
argument_list|(
literal|3
argument_list|,
literal|4
argument_list|)
end_macro

begin_function
name|void
name|malloc_cprintf
parameter_list|(
name|void
function_decl|(
modifier|*
name|write_cb
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|cbopaque
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|malloc_vcprintf
argument_list|(
name|write_cb
argument_list|,
name|cbopaque
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print to stderr in such a way as to avoid memory allocation. */
end_comment

begin_macro
name|JEMALLOC_FORMAT_PRINTF
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
end_macro

begin_function
name|void
name|malloc_printf
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|malloc_vcprintf
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Restore normal assertion macros, in order to make it possible to compile all  * C files as a single concatenation.  */
end_comment

begin_undef
undef|#
directive|undef
name|assert
end_undef

begin_undef
undef|#
directive|undef
name|not_reached
end_undef

begin_undef
undef|#
directive|undef
name|not_implemented
end_undef

begin_undef
undef|#
directive|undef
name|assert_not_implemented
end_undef

begin_include
include|#
directive|include
file|"jemalloc/internal/assert.h"
end_include

end_unit

