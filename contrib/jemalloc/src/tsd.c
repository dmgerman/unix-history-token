begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|JEMALLOC_TSD_C_
end_define

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_internal.h"
end_include

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/* Data. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|ncleanups
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|malloc_tsd_cleanup_t
name|cleanups
index|[
name|MALLOC_TSD_CLEANUPS_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|malloc_tsd_data
argument_list|(
argument_list|,
argument_list|,
argument|tsd_t
argument_list|,
argument|TSD_INITIALIZER
argument_list|)
end_macro

begin_comment
comment|/******************************************************************************/
end_comment

begin_function
name|void
modifier|*
name|malloc_tsd_malloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|a0malloc
argument_list|(
name|CACHELINE_CEILING
argument_list|(
name|size
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|malloc_tsd_dalloc
parameter_list|(
name|void
modifier|*
name|wrapper
parameter_list|)
block|{
name|a0dalloc
argument_list|(
name|wrapper
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|malloc_tsd_no_cleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|not_reached
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|JEMALLOC_MALLOC_THREAD_CLEANUP
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32
end_ifndef

begin_function
name|JEMALLOC_EXPORT
endif|#
directive|endif
name|void
name|_malloc_thread_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|pending
index|[
name|MALLOC_TSD_CLEANUPS_MAX
index|]
decl_stmt|,
name|again
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncleanups
condition|;
name|i
operator|++
control|)
name|pending
index|[
name|i
index|]
operator|=
name|true
expr_stmt|;
do|do
block|{
name|again
operator|=
name|false
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncleanups
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pending
index|[
name|i
index|]
condition|)
block|{
name|pending
index|[
name|i
index|]
operator|=
name|cleanups
index|[
name|i
index|]
operator|(
operator|)
expr_stmt|;
if|if
condition|(
name|pending
index|[
name|i
index|]
condition|)
name|again
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|again
condition|)
do|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|malloc_tsd_cleanup_register
parameter_list|(
name|bool
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
block|{
name|assert
argument_list|(
name|ncleanups
operator|<
name|MALLOC_TSD_CLEANUPS_MAX
argument_list|)
expr_stmt|;
name|cleanups
index|[
name|ncleanups
index|]
operator|=
name|f
expr_stmt|;
name|ncleanups
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tsd_cleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|tsd_t
modifier|*
name|tsd
init|=
operator|(
name|tsd_t
operator|*
operator|)
name|arg
decl_stmt|;
switch|switch
condition|(
name|tsd
operator|->
name|state
condition|)
block|{
case|case
name|tsd_state_uninitialized
case|:
comment|/* Do nothing. */
break|break;
case|case
name|tsd_state_nominal
case|:
define|#
directive|define
name|O
parameter_list|(
name|n
parameter_list|,
name|t
parameter_list|)
define|\
value|n##_cleanup(tsd);
name|MALLOC_TSD
undef|#
directive|undef
name|O
name|tsd
operator|->
name|state
init|=
name|tsd_state_purgatory
decl_stmt|;
name|tsd_set
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
break|break;
case|case
name|tsd_state_purgatory
case|:
comment|/* 		 * The previous time this destructor was called, we set the 		 * state to tsd_state_purgatory so that other destructors 		 * wouldn't cause re-creation of the tsd.  This time, do 		 * nothing, and do not request another callback. 		 */
break|break;
case|case
name|tsd_state_reincarnated
case|:
comment|/* 		 * Another destructor deallocated memory after this destructor 		 * was called.  Reset state to tsd_state_purgatory and request 		 * another callback. 		 */
name|tsd
operator|->
name|state
operator|=
name|tsd_state_purgatory
expr_stmt|;
name|tsd_set
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|not_reached
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|tsd_t
modifier|*
name|malloc_tsd_boot0
parameter_list|(
name|void
parameter_list|)
block|{
name|tsd_t
modifier|*
name|tsd
decl_stmt|;
name|ncleanups
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tsd_boot0
argument_list|()
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|tsd
operator|=
name|tsd_fetch
argument_list|()
expr_stmt|;
operator|*
name|tsd_arenas_tdata_bypassp_get
argument_list|(
name|tsd
argument_list|)
operator|=
name|true
expr_stmt|;
return|return
operator|(
name|tsd
operator|)
return|;
block|}
end_function

begin_function
name|void
name|malloc_tsd_boot1
parameter_list|(
name|void
parameter_list|)
block|{
name|tsd_boot1
argument_list|()
expr_stmt|;
operator|*
name|tsd_arenas_tdata_bypassp_get
argument_list|(
name|tsd_fetch
argument_list|()
argument_list|)
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_function
specifier|static
name|BOOL
name|WINAPI
name|_tls_callback
parameter_list|(
name|HINSTANCE
name|hinstDLL
parameter_list|,
name|DWORD
name|fdwReason
parameter_list|,
name|LPVOID
name|lpvReserved
parameter_list|)
block|{
switch|switch
condition|(
name|fdwReason
condition|)
block|{
ifdef|#
directive|ifdef
name|JEMALLOC_LAZY_LOCK
case|case
name|DLL_THREAD_ATTACH
case|:
name|isthreaded
operator|=
name|true
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|DLL_THREAD_DETACH
case|:
name|_malloc_thread_cleanup
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|_M_IX86
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|comment
name|(
name|linker
name|,
literal|"/INCLUDE:__tls_used"
name|)
end_pragma

begin_pragma
pragma|#
directive|pragma
name|comment
name|(
name|linker
name|,
literal|"/INCLUDE:_tls_callback"
name|)
end_pragma

begin_else
else|#
directive|else
end_else

begin_pragma
pragma|#
directive|pragma
name|comment
name|(
name|linker
name|,
literal|"/INCLUDE:_tls_used"
name|)
end_pragma

begin_pragma
pragma|#
directive|pragma
name|comment
name|(
name|linker
name|,
literal|"/INCLUDE:tls_callback"
name|)
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_pragma
pragma|#
directive|pragma
name|section
name|(
literal|".CRT$XLY"
name|,
name|long
name|,
name|read
name|)
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|JEMALLOC_SECTION
argument_list|(
literal|".CRT$XLY"
argument_list|)
end_macro

begin_function_decl
name|JEMALLOC_ATTR
function_decl|(
name|used
function_decl|)
name|BOOL
argument_list|(
argument|WINAPI *const tls_callback
argument_list|)
parameter_list|(
name|HINSTANCE
name|hinstDLL
parameter_list|,
name|DWORD
name|fdwReason
parameter_list|,
name|LPVOID
name|lpvReserved
parameter_list|)
init|=
name|_tls_callback
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|JEMALLOC_MALLOC_THREAD_CLEANUP
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|JEMALLOC_TLS
argument_list|)
operator|&&
expr|\
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|)
end_if

begin_function
name|void
modifier|*
name|tsd_init_check_recursion
parameter_list|(
name|tsd_init_head_t
modifier|*
name|head
parameter_list|,
name|tsd_init_block_t
modifier|*
name|block
parameter_list|)
block|{
name|pthread_t
name|self
init|=
name|pthread_self
argument_list|()
decl_stmt|;
name|tsd_init_block_t
modifier|*
name|iter
decl_stmt|;
comment|/* Check whether this thread has already inserted into the list. */
name|malloc_mutex_lock
argument_list|(
name|NULL
argument_list|,
operator|&
name|head
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ql_foreach
argument_list|(
argument|iter
argument_list|,
argument|&head->blocks
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|iter
operator|->
name|thread
operator|==
name|self
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
name|NULL
argument_list|,
operator|&
name|head
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|iter
operator|->
name|data
operator|)
return|;
block|}
block|}
comment|/* Insert block into list. */
name|ql_elm_new
argument_list|(
name|block
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|block
operator|->
name|thread
operator|=
name|self
expr_stmt|;
name|ql_tail_insert
argument_list|(
operator|&
name|head
operator|->
name|blocks
argument_list|,
name|block
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|NULL
argument_list|,
operator|&
name|head
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|tsd_init_finish
parameter_list|(
name|tsd_init_head_t
modifier|*
name|head
parameter_list|,
name|tsd_init_block_t
modifier|*
name|block
parameter_list|)
block|{
name|malloc_mutex_lock
argument_list|(
name|NULL
argument_list|,
operator|&
name|head
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ql_remove
argument_list|(
operator|&
name|head
operator|->
name|blocks
argument_list|,
name|block
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|NULL
argument_list|,
operator|&
name|head
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

