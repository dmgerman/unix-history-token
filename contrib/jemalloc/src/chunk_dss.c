begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|JEMALLOC_CHUNK_DSS_C_
end_define

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_internal.h"
end_include

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/* Data. */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|dss_prec_names
index|[]
init|=
block|{
literal|"disabled"
block|,
literal|"primary"
block|,
literal|"secondary"
block|,
literal|"N/A"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Current dss precedence default, used when creating new arenas.  NB: This is  * stored as unsigned rather than dss_prec_t because in principle there's no  * guarantee that sizeof(dss_prec_t) is the same as sizeof(unsigned), and we use  * atomic operations to synchronize the setting.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|dss_prec_default
init|=
operator|(
name|unsigned
operator|)
name|DSS_PREC_DEFAULT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Base address of the DSS. */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|dss_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Atomic boolean indicating whether the DSS is exhausted. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|dss_exhausted
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Atomic current upper limit on DSS addresses. */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|dss_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************/
end_comment

begin_function
specifier|static
name|void
modifier|*
name|chunk_dss_sbrk
parameter_list|(
name|intptr_t
name|increment
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|JEMALLOC_DSS
return|return
operator|(
name|sbrk
argument_list|(
name|increment
argument_list|)
operator|)
return|;
else|#
directive|else
name|not_implemented
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|dss_prec_t
name|chunk_dss_prec_get
parameter_list|(
name|void
parameter_list|)
block|{
name|dss_prec_t
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|have_dss
condition|)
return|return
operator|(
name|dss_prec_disabled
operator|)
return|;
name|ret
operator|=
operator|(
name|dss_prec_t
operator|)
name|atomic_read_u
argument_list|(
operator|&
name|dss_prec_default
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|chunk_dss_prec_set
parameter_list|(
name|dss_prec_t
name|dss_prec
parameter_list|)
block|{
if|if
condition|(
operator|!
name|have_dss
condition|)
return|return
operator|(
name|dss_prec
operator|!=
name|dss_prec_disabled
operator|)
return|;
name|atomic_write_u
argument_list|(
operator|&
name|dss_prec_default
argument_list|,
operator|(
name|unsigned
operator|)
name|dss_prec
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|chunk_dss_max_update
parameter_list|(
name|void
modifier|*
name|new_addr
parameter_list|)
block|{
name|void
modifier|*
name|max_cur
decl_stmt|;
name|spin_t
name|spinner
decl_stmt|;
comment|/* 	 * Get the current end of the DSS as max_cur and assure that dss_max is 	 * up to date. 	 */
name|spin_init
argument_list|(
operator|&
name|spinner
argument_list|)
expr_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|void
modifier|*
name|max_prev
init|=
name|atomic_read_p
argument_list|(
operator|&
name|dss_max
argument_list|)
decl_stmt|;
name|max_cur
operator|=
name|chunk_dss_sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|max_prev
operator|>
operator|(
name|uintptr_t
operator|)
name|max_cur
condition|)
block|{
comment|/* 			 * Another thread optimistically updated dss_max.  Wait 			 * for it to finish. 			 */
name|spin_adaptive
argument_list|(
operator|&
name|spinner
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|atomic_cas_p
argument_list|(
operator|&
name|dss_max
argument_list|,
name|max_prev
argument_list|,
name|max_cur
argument_list|)
condition|)
break|break;
block|}
comment|/* Fixed new_addr can only be supported if it is at the edge of DSS. */
if|if
condition|(
name|new_addr
operator|!=
name|NULL
operator|&&
name|max_cur
operator|!=
name|new_addr
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|max_cur
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|chunk_alloc_dss
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|void
modifier|*
name|new_addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
modifier|*
name|zero
parameter_list|,
name|bool
modifier|*
name|commit
parameter_list|)
block|{
name|cassert
argument_list|(
name|have_dss
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|>
literal|0
operator|&&
operator|(
name|size
operator|&
name|chunksize_mask
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|alignment
operator|>
literal|0
operator|&&
operator|(
name|alignment
operator|&
name|chunksize_mask
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * sbrk() uses a signed increment argument, so take care not to 	 * interpret a huge allocation request as a negative increment. 	 */
if|if
condition|(
operator|(
name|intptr_t
operator|)
name|size
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|!
name|atomic_read_u
argument_list|(
operator|&
name|dss_exhausted
argument_list|)
condition|)
block|{
comment|/* 		 * The loop is necessary to recover from races with other 		 * threads that are using the DSS for something other than 		 * malloc. 		 */
while|while
condition|(
name|true
condition|)
block|{
name|void
modifier|*
name|ret
decl_stmt|,
modifier|*
name|max_cur
decl_stmt|,
modifier|*
name|dss_next
decl_stmt|,
modifier|*
name|dss_prev
decl_stmt|;
name|void
modifier|*
name|gap_addr_chunk
decl_stmt|,
modifier|*
name|gap_addr_subchunk
decl_stmt|;
name|size_t
name|gap_size_chunk
decl_stmt|,
name|gap_size_subchunk
decl_stmt|;
name|intptr_t
name|incr
decl_stmt|;
name|max_cur
operator|=
name|chunk_dss_max_update
argument_list|(
name|new_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_cur
operator|==
name|NULL
condition|)
goto|goto
name|label_oom
goto|;
comment|/* 			 * Compute how much chunk-aligned gap space (if any) is 			 * necessary to satisfy alignment.  This space can be 			 * recycled for later use. 			 */
name|gap_addr_chunk
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|CHUNK_CEILING
argument_list|(
operator|(
name|uintptr_t
operator|)
name|max_cur
argument_list|)
operator|)
expr_stmt|;
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
name|ALIGNMENT_CEILING
argument_list|(
operator|(
name|uintptr_t
operator|)
name|gap_addr_chunk
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|gap_size_chunk
operator|=
operator|(
name|uintptr_t
operator|)
name|ret
operator|-
operator|(
name|uintptr_t
operator|)
name|gap_addr_chunk
expr_stmt|;
comment|/* 			 * Compute the address just past the end of the desired 			 * allocation space. 			 */
name|dss_next
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|+
name|size
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|<
operator|(
name|uintptr_t
operator|)
name|max_cur
operator|||
operator|(
name|uintptr_t
operator|)
name|dss_next
operator|<
operator|(
name|uintptr_t
operator|)
name|max_cur
condition|)
goto|goto
name|label_oom
goto|;
comment|/* Wrap-around. */
comment|/* Compute the increment, including subchunk bytes. */
name|gap_addr_subchunk
operator|=
name|max_cur
expr_stmt|;
name|gap_size_subchunk
operator|=
operator|(
name|uintptr_t
operator|)
name|ret
operator|-
operator|(
name|uintptr_t
operator|)
name|gap_addr_subchunk
expr_stmt|;
name|incr
operator|=
name|gap_size_subchunk
operator|+
name|size
expr_stmt|;
name|assert
argument_list|(
operator|(
name|uintptr_t
operator|)
name|max_cur
operator|+
name|incr
operator|==
operator|(
name|uintptr_t
operator|)
name|ret
operator|+
name|size
argument_list|)
expr_stmt|;
comment|/* 			 * Optimistically update dss_max, and roll back below if 			 * sbrk() fails.  No other thread will try to extend the 			 * DSS while dss_max is greater than the current DSS 			 * max reported by sbrk(0). 			 */
if|if
condition|(
name|atomic_cas_p
argument_list|(
operator|&
name|dss_max
argument_list|,
name|max_cur
argument_list|,
name|dss_next
argument_list|)
condition|)
continue|continue;
comment|/* Try to allocate. */
name|dss_prev
operator|=
name|chunk_dss_sbrk
argument_list|(
name|incr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dss_prev
operator|==
name|max_cur
condition|)
block|{
comment|/* Success. */
if|if
condition|(
name|gap_size_chunk
operator|!=
literal|0
condition|)
block|{
name|chunk_hooks_t
name|chunk_hooks
init|=
name|CHUNK_HOOKS_INITIALIZER
decl_stmt|;
name|chunk_dalloc_wrapper
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|chunk_hooks
argument_list|,
name|gap_addr_chunk
argument_list|,
name|gap_size_chunk
argument_list|,
name|arena_extent_sn_next
argument_list|(
name|arena
argument_list|)
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|zero
condition|)
block|{
name|JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED
argument_list|(
name|ret
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|commit
condition|)
operator|*
name|commit
operator|=
name|pages_decommit
argument_list|(
name|ret
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* 			 * Failure, whether due to OOM or a race with a raw 			 * sbrk() call from outside the allocator.  Try to roll 			 * back optimistic dss_max update; if rollback fails, 			 * it's due to another caller of this function having 			 * succeeded since this invocation started, in which 			 * case rollback is not necessary. 			 */
name|atomic_cas_p
argument_list|(
operator|&
name|dss_max
argument_list|,
name|dss_next
argument_list|,
name|max_cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|dss_prev
operator|==
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* OOM. */
name|atomic_write_u
argument_list|(
operator|&
name|dss_exhausted
argument_list|,
operator|(
name|unsigned
operator|)
name|true
argument_list|)
expr_stmt|;
goto|goto
name|label_oom
goto|;
block|}
block|}
block|}
name|label_oom
label|:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|chunk_in_dss_helper
parameter_list|(
name|void
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|max
parameter_list|)
block|{
return|return
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|>=
operator|(
name|uintptr_t
operator|)
name|dss_base
operator|&&
operator|(
name|uintptr_t
operator|)
name|chunk
operator|<
operator|(
name|uintptr_t
operator|)
name|max
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|chunk_in_dss
parameter_list|(
name|void
modifier|*
name|chunk
parameter_list|)
block|{
name|cassert
argument_list|(
name|have_dss
argument_list|)
expr_stmt|;
return|return
operator|(
name|chunk_in_dss_helper
argument_list|(
name|chunk
argument_list|,
name|atomic_read_p
argument_list|(
operator|&
name|dss_max
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|chunk_dss_mergeable
parameter_list|(
name|void
modifier|*
name|chunk_a
parameter_list|,
name|void
modifier|*
name|chunk_b
parameter_list|)
block|{
name|void
modifier|*
name|max
decl_stmt|;
name|cassert
argument_list|(
name|have_dss
argument_list|)
expr_stmt|;
name|max
operator|=
name|atomic_read_p
argument_list|(
operator|&
name|dss_max
argument_list|)
expr_stmt|;
return|return
operator|(
name|chunk_in_dss_helper
argument_list|(
name|chunk_a
argument_list|,
name|max
argument_list|)
operator|==
name|chunk_in_dss_helper
argument_list|(
name|chunk_b
argument_list|,
name|max
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|chunk_dss_boot
parameter_list|(
name|void
parameter_list|)
block|{
name|cassert
argument_list|(
name|have_dss
argument_list|)
expr_stmt|;
name|dss_base
operator|=
name|chunk_dss_sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dss_exhausted
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|dss_base
operator|==
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dss_max
operator|=
name|dss_base
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

end_unit

