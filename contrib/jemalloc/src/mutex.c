begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|JEMALLOC_MUTEX_C_
end_define

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_preamble.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_internal_includes.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/assert.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/malloc_io.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_CRT_SPINCOUNT
end_ifndef

begin_define
define|#
directive|define
name|_CRT_SPINCOUNT
value|4000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/* Data. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_LAZY_LOCK
end_ifdef

begin_decl_stmt
name|bool
name|isthreaded
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_MUTEX_INIT_CB
end_ifdef

begin_decl_stmt
specifier|static
name|bool
name|postpone_init
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|malloc_mutex_t
modifier|*
name|postponed_mutexes
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * We intercept pthread_create() calls in order to toggle isthreaded if the  * process goes multi-threaded.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|JEMALLOC_LAZY_LOCK
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
end_if

begin_function
name|JEMALLOC_EXPORT
name|int
name|pthread_create
parameter_list|(
name|pthread_t
modifier|*
name|__restrict
name|thread
parameter_list|,
specifier|const
name|pthread_attr_t
modifier|*
name|__restrict
name|attr
parameter_list|,
name|void
modifier|*
function_decl|(
modifier|*
name|start_routine
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|__restrict
name|arg
parameter_list|)
block|{
return|return
name|pthread_create_wrapper
argument_list|(
name|thread
argument_list|,
name|attr
argument_list|,
name|start_routine
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_MUTEX_INIT_CB
end_ifdef

begin_function_decl
name|JEMALLOC_EXPORT
name|int
name|_pthread_mutex_init_calloc_cb
parameter_list|(
name|pthread_mutex_t
modifier|*
name|mutex
parameter_list|,
name|void
modifier|*
function_decl|(
name|calloc_cb
function_decl|)
parameter_list|(
name|size_t
parameter_list|,
name|size_t
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_pragma
pragma|#
directive|pragma
name|weak
name|_pthread_mutex_init_calloc_cb
end_pragma

begin_function
name|int
name|_pthread_mutex_init_calloc_cb
parameter_list|(
name|pthread_mutex_t
modifier|*
name|mutex
parameter_list|,
name|void
modifier|*
function_decl|(
name|calloc_cb
function_decl|)
parameter_list|(
name|size_t
parameter_list|,
name|size_t
parameter_list|)
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|pthread_mutex_t
operator|*
argument_list|,
name|void
operator|*
call|(
modifier|*
call|)
argument_list|(
name|size_t
argument_list|,
name|size_t
argument_list|)
argument_list|)
operator|)
name|__libc_interposing
index|[
name|INTERPOS__pthread_mutex_init_calloc_cb
index|]
operator|)
operator|(
name|mutex
operator|,
name|calloc_cb
operator|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|malloc_mutex_lock_slow
parameter_list|(
name|malloc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|mutex_prof_data_t
modifier|*
name|data
init|=
operator|&
name|mutex
operator|->
name|prof_data
decl_stmt|;
name|UNUSED
name|nstime_t
name|before
init|=
name|NSTIME_ZERO_INITIALIZER
decl_stmt|;
if|if
condition|(
name|ncpus
operator|==
literal|1
condition|)
block|{
goto|goto
name|label_spin_done
goto|;
block|}
name|int
name|cnt
init|=
literal|0
decl_stmt|,
name|max_cnt
init|=
name|MALLOC_MUTEX_MAX_SPIN
decl_stmt|;
do|do
block|{
name|CPU_SPINWAIT
expr_stmt|;
if|if
condition|(
operator|!
name|malloc_mutex_trylock_final
argument_list|(
name|mutex
argument_list|)
condition|)
block|{
name|data
operator|->
name|n_spin_acquired
operator|++
expr_stmt|;
return|return;
block|}
block|}
do|while
condition|(
name|cnt
operator|++
operator|<
name|max_cnt
condition|)
do|;
if|if
condition|(
operator|!
name|config_stats
condition|)
block|{
comment|/* Only spin is useful when stats is off. */
name|malloc_mutex_lock_final
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
return|return;
block|}
name|label_spin_done
label|:
name|nstime_update
argument_list|(
operator|&
name|before
argument_list|)
expr_stmt|;
comment|/* Copy before to after to avoid clock skews. */
name|nstime_t
name|after
decl_stmt|;
name|nstime_copy
argument_list|(
operator|&
name|after
argument_list|,
operator|&
name|before
argument_list|)
expr_stmt|;
name|uint32_t
name|n_thds
init|=
name|atomic_fetch_add_u32
argument_list|(
operator|&
name|data
operator|->
name|n_waiting_thds
argument_list|,
literal|1
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|/* One last try as above two calls may take quite some cycles. */
if|if
condition|(
operator|!
name|malloc_mutex_trylock_final
argument_list|(
name|mutex
argument_list|)
condition|)
block|{
name|atomic_fetch_sub_u32
argument_list|(
operator|&
name|data
operator|->
name|n_waiting_thds
argument_list|,
literal|1
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
name|data
operator|->
name|n_spin_acquired
operator|++
expr_stmt|;
return|return;
block|}
comment|/* True slow path. */
name|malloc_mutex_lock_final
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
comment|/* Update more slow-path only counters. */
name|atomic_fetch_sub_u32
argument_list|(
operator|&
name|data
operator|->
name|n_waiting_thds
argument_list|,
literal|1
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
name|nstime_update
argument_list|(
operator|&
name|after
argument_list|)
expr_stmt|;
name|nstime_t
name|delta
decl_stmt|;
name|nstime_copy
argument_list|(
operator|&
name|delta
argument_list|,
operator|&
name|after
argument_list|)
expr_stmt|;
name|nstime_subtract
argument_list|(
operator|&
name|delta
argument_list|,
operator|&
name|before
argument_list|)
expr_stmt|;
name|data
operator|->
name|n_wait_times
operator|++
expr_stmt|;
name|nstime_add
argument_list|(
operator|&
name|data
operator|->
name|tot_wait_time
argument_list|,
operator|&
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|nstime_compare
argument_list|(
operator|&
name|data
operator|->
name|max_wait_time
argument_list|,
operator|&
name|delta
argument_list|)
operator|<
literal|0
condition|)
block|{
name|nstime_copy
argument_list|(
operator|&
name|data
operator|->
name|max_wait_time
argument_list|,
operator|&
name|delta
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n_thds
operator|>
name|data
operator|->
name|max_n_thds
condition|)
block|{
name|data
operator|->
name|max_n_thds
operator|=
name|n_thds
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mutex_prof_data_init
parameter_list|(
name|mutex_prof_data_t
modifier|*
name|data
parameter_list|)
block|{
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mutex_prof_data_t
argument_list|)
argument_list|)
expr_stmt|;
name|nstime_init
argument_list|(
operator|&
name|data
operator|->
name|max_wait_time
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nstime_init
argument_list|(
operator|&
name|data
operator|->
name|tot_wait_time
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|->
name|prev_owner
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|malloc_mutex_prof_data_reset
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|malloc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|malloc_mutex_assert_owner
argument_list|(
name|tsdn
argument_list|,
name|mutex
argument_list|)
expr_stmt|;
name|mutex_prof_data_init
argument_list|(
operator|&
name|mutex
operator|->
name|prof_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mutex_addr_comp
parameter_list|(
specifier|const
name|witness_t
modifier|*
name|witness1
parameter_list|,
name|void
modifier|*
name|mutex1
parameter_list|,
specifier|const
name|witness_t
modifier|*
name|witness2
parameter_list|,
name|void
modifier|*
name|mutex2
parameter_list|)
block|{
name|assert
argument_list|(
name|mutex1
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|mutex2
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|uintptr_t
name|mu1int
init|=
operator|(
name|uintptr_t
operator|)
name|mutex1
decl_stmt|;
name|uintptr_t
name|mu2int
init|=
operator|(
name|uintptr_t
operator|)
name|mutex2
decl_stmt|;
if|if
condition|(
name|mu1int
operator|<
name|mu2int
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|mu1int
operator|==
name|mu2int
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
name|bool
name|malloc_mutex_first_thread
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|JEMALLOC_MUTEX_INIT_CB
return|return
operator|(
name|malloc_mutex_first_thread
argument_list|()
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|false
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|bool
name|malloc_mutex_init
parameter_list|(
name|malloc_mutex_t
modifier|*
name|mutex
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|witness_rank_t
name|rank
parameter_list|,
name|malloc_mutex_lock_order_t
name|lock_order
parameter_list|)
block|{
name|mutex_prof_data_init
argument_list|(
operator|&
name|mutex
operator|->
name|prof_data
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
if|#
directive|if
name|_WIN32_WINNT
operator|>=
literal|0x0600
name|InitializeSRWLock
argument_list|(
operator|&
name|mutex
operator|->
name|lock
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|InitializeCriticalSectionAndSpinCount
argument_list|(
operator|&
name|mutex
operator|->
name|lock
argument_list|,
name|_CRT_SPINCOUNT
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
endif|#
directive|endif
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|JEMALLOC_OS_UNFAIR_LOCK
argument_list|)
operator|)
name|mutex
operator|->
name|lock
operator|=
name|OS_UNFAIR_LOCK_INIT
expr_stmt|;
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|JEMALLOC_OSSPIN
argument_list|)
operator|)
name|mutex
operator|->
name|lock
operator|=
literal|0
expr_stmt|;
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|JEMALLOC_MUTEX_INIT_CB
argument_list|)
operator|)
if|if
condition|(
name|postpone_init
condition|)
block|{
name|mutex
operator|->
name|postponed_next
operator|=
name|postponed_mutexes
expr_stmt|;
name|postponed_mutexes
operator|=
name|mutex
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|_pthread_mutex_init_calloc_cb
argument_list|(
operator|&
name|mutex
operator|->
name|lock
argument_list|,
name|bootstrap_calloc
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|true
return|;
block|}
block|}
else|#
directive|else
name|pthread_mutexattr_t
name|attr
decl_stmt|;
if|if
condition|(
name|pthread_mutexattr_init
argument_list|(
operator|&
name|attr
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|true
return|;
block|}
name|pthread_mutexattr_settype
argument_list|(
operator|&
name|attr
argument_list|,
name|MALLOC_MUTEX_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pthread_mutex_init
argument_list|(
operator|&
name|mutex
operator|->
name|lock
argument_list|,
operator|&
name|attr
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|pthread_mutexattr_destroy
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|pthread_mutexattr_destroy
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|config_debug
condition|)
block|{
name|mutex
operator|->
name|lock_order
operator|=
name|lock_order
expr_stmt|;
if|if
condition|(
name|lock_order
operator|==
name|malloc_mutex_address_ordered
condition|)
block|{
name|witness_init
argument_list|(
operator|&
name|mutex
operator|->
name|witness
argument_list|,
name|name
argument_list|,
name|rank
argument_list|,
name|mutex_addr_comp
argument_list|,
operator|&
name|mutex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|witness_init
argument_list|(
operator|&
name|mutex
operator|->
name|witness
argument_list|,
name|name
argument_list|,
name|rank
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
name|void
name|malloc_mutex_prefork
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|malloc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|malloc_mutex_postfork_parent
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|malloc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|malloc_mutex_postfork_child
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|malloc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|JEMALLOC_MUTEX_INIT_CB
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
name|mutex
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|malloc_mutex_init
argument_list|(
name|mutex
argument_list|,
name|mutex
operator|->
name|witness
operator|.
name|name
argument_list|,
name|mutex
operator|->
name|witness
operator|.
name|rank
argument_list|,
name|mutex
operator|->
name|lock_order
argument_list|)
condition|)
block|{
name|malloc_printf
argument_list|(
literal|"<jemalloc>: Error re-initializing mutex in "
literal|"child\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|bool
name|malloc_mutex_boot
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|JEMALLOC_MUTEX_INIT_CB
name|postpone_init
operator|=
name|false
expr_stmt|;
while|while
condition|(
name|postponed_mutexes
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|_pthread_mutex_init_calloc_cb
argument_list|(
operator|&
name|postponed_mutexes
operator|->
name|lock
argument_list|,
name|bootstrap_calloc
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|true
return|;
block|}
name|postponed_mutexes
operator|=
name|postponed_mutexes
operator|->
name|postponed_next
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|false
return|;
block|}
end_function

end_unit

