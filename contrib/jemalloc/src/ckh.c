begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *******************************************************************************  * Implementation of (2^1+,2) cuckoo hashing, where 2^1+ indicates that each  * hash bucket contains 2^n cells, for n>= 1, and 2 indicates that two hash  * functions are employed.  The original cuckoo hashing algorithm was described  * in:  *  *   Pagh, R., F.F. Rodler (2004) Cuckoo Hashing.  Journal of Algorithms  *     51(2):122-144.  *  * Generalization of cuckoo hashing was discussed in:  *  *   Erlingsson, U., M. Manasse, F. McSherry (2006) A cool and practical  *     alternative to traditional hash tables.  In Proceedings of the 7th  *     Workshop on Distributed Data and Structures (WDAS'06), Santa Clara, CA,  *     January 2006.  *  * This implementation uses precisely two hash functions because that is the  * fewest that can work, and supporting multiple hashes is an implementation  * burden.  Here is a reproduction of Figure 1 from Erlingsson et al. (2006)  * that shows approximate expected maximum load factors for various  * configurations:  *  *           |         #cells/bucket         |  *   #hashes |   1   |   2   |   4   |   8   |  *   --------+-------+-------+-------+-------+  *         1 | 0.006 | 0.006 | 0.03  | 0.12  |  *         2 | 0.49  | 0.86  |>0.93< |>0.96< |  *         3 | 0.91  | 0.97  | 0.98  | 0.999 |  *         4 | 0.97  | 0.99  | 0.999 |       |  *  * The number of cells per bucket is chosen such that a bucket fits in one cache  * line.  So, on 32- and 64-bit systems, we use (8,2) and (4,2) cuckoo hashing,  * respectively.  *  ******************************************************************************/
end_comment

begin_define
define|#
directive|define
name|JEMALLOC_CKH_C_
end_define

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_preamble.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/ckh.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_internal_includes.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/assert.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/hash.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/malloc_io.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/prng.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/util.h"
end_include

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/* Function prototypes for non-inline static functions. */
end_comment

begin_function_decl
specifier|static
name|bool
name|ckh_grow
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|ckh_t
modifier|*
name|ckh
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ckh_shrink
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|ckh_t
modifier|*
name|ckh
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Search bucket for key and return the cell number if found; SIZE_T_MAX  * otherwise.  */
end_comment

begin_function
specifier|static
name|size_t
name|ckh_bucket_search
parameter_list|(
name|ckh_t
modifier|*
name|ckh
parameter_list|,
name|size_t
name|bucket
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
name|ckhc_t
modifier|*
name|cell
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
name|LG_CKH_BUCKET_CELLS
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|cell
operator|=
operator|&
name|ckh
operator|->
name|tab
index|[
operator|(
name|bucket
operator|<<
name|LG_CKH_BUCKET_CELLS
operator|)
operator|+
name|i
index|]
expr_stmt|;
if|if
condition|(
name|cell
operator|->
name|key
operator|!=
name|NULL
operator|&&
name|ckh
operator|->
name|keycomp
argument_list|(
name|key
argument_list|,
name|cell
operator|->
name|key
argument_list|)
condition|)
block|{
return|return
operator|(
name|bucket
operator|<<
name|LG_CKH_BUCKET_CELLS
operator|)
operator|+
name|i
return|;
block|}
block|}
return|return
name|SIZE_T_MAX
return|;
block|}
end_function

begin_comment
comment|/*  * Search table for key and return cell number if found; SIZE_T_MAX otherwise.  */
end_comment

begin_function
specifier|static
name|size_t
name|ckh_isearch
parameter_list|(
name|ckh_t
modifier|*
name|ckh
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
name|size_t
name|hashes
index|[
literal|2
index|]
decl_stmt|,
name|bucket
decl_stmt|,
name|cell
decl_stmt|;
name|assert
argument_list|(
name|ckh
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ckh
operator|->
name|hash
argument_list|(
name|key
argument_list|,
name|hashes
argument_list|)
expr_stmt|;
comment|/* Search primary bucket. */
name|bucket
operator|=
name|hashes
index|[
literal|0
index|]
operator|&
operator|(
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
name|ckh
operator|->
name|lg_curbuckets
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|cell
operator|=
name|ckh_bucket_search
argument_list|(
name|ckh
argument_list|,
name|bucket
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|cell
operator|!=
name|SIZE_T_MAX
condition|)
block|{
return|return
name|cell
return|;
block|}
comment|/* Search secondary bucket. */
name|bucket
operator|=
name|hashes
index|[
literal|1
index|]
operator|&
operator|(
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
name|ckh
operator|->
name|lg_curbuckets
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|cell
operator|=
name|ckh_bucket_search
argument_list|(
name|ckh
argument_list|,
name|bucket
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
name|cell
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ckh_try_bucket_insert
parameter_list|(
name|ckh_t
modifier|*
name|ckh
parameter_list|,
name|size_t
name|bucket
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|)
block|{
name|ckhc_t
modifier|*
name|cell
decl_stmt|;
name|unsigned
name|offset
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Cycle through the cells in the bucket, starting at a random position. 	 * The randomness avoids worst-case search overhead as buckets fill up. 	 */
name|offset
operator|=
operator|(
name|unsigned
operator|)
name|prng_lg_range_u64
argument_list|(
operator|&
name|ckh
operator|->
name|prng_state
argument_list|,
name|LG_CKH_BUCKET_CELLS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
name|LG_CKH_BUCKET_CELLS
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|cell
operator|=
operator|&
name|ckh
operator|->
name|tab
index|[
operator|(
name|bucket
operator|<<
name|LG_CKH_BUCKET_CELLS
operator|)
operator|+
operator|(
operator|(
name|i
operator|+
name|offset
operator|)
operator|&
operator|(
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
name|LG_CKH_BUCKET_CELLS
operator|)
operator|-
literal|1
operator|)
operator|)
index|]
expr_stmt|;
if|if
condition|(
name|cell
operator|->
name|key
operator|==
name|NULL
condition|)
block|{
name|cell
operator|->
name|key
operator|=
name|key
expr_stmt|;
name|cell
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|ckh
operator|->
name|count
operator|++
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*  * No space is available in bucket.  Randomly evict an item, then try to find an  * alternate location for that item.  Iteratively repeat this  * eviction/relocation procedure until either success or detection of an  * eviction/relocation bucket cycle.  */
end_comment

begin_function
specifier|static
name|bool
name|ckh_evict_reloc_insert
parameter_list|(
name|ckh_t
modifier|*
name|ckh
parameter_list|,
name|size_t
name|argbucket
parameter_list|,
name|void
specifier|const
modifier|*
modifier|*
name|argkey
parameter_list|,
name|void
specifier|const
modifier|*
modifier|*
name|argdata
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|,
modifier|*
name|data
decl_stmt|,
modifier|*
name|tkey
decl_stmt|,
modifier|*
name|tdata
decl_stmt|;
name|ckhc_t
modifier|*
name|cell
decl_stmt|;
name|size_t
name|hashes
index|[
literal|2
index|]
decl_stmt|,
name|bucket
decl_stmt|,
name|tbucket
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|bucket
operator|=
name|argbucket
expr_stmt|;
name|key
operator|=
operator|*
name|argkey
expr_stmt|;
name|data
operator|=
operator|*
name|argdata
expr_stmt|;
while|while
condition|(
name|true
condition|)
block|{
comment|/* 		 * Choose a random item within the bucket to evict.  This is 		 * critical to correct function, because without (eventually) 		 * evicting all items within a bucket during iteration, it 		 * would be possible to get stuck in an infinite loop if there 		 * were an item for which both hashes indicated the same 		 * bucket. 		 */
name|i
operator|=
operator|(
name|unsigned
operator|)
name|prng_lg_range_u64
argument_list|(
operator|&
name|ckh
operator|->
name|prng_state
argument_list|,
name|LG_CKH_BUCKET_CELLS
argument_list|)
expr_stmt|;
name|cell
operator|=
operator|&
name|ckh
operator|->
name|tab
index|[
operator|(
name|bucket
operator|<<
name|LG_CKH_BUCKET_CELLS
operator|)
operator|+
name|i
index|]
expr_stmt|;
name|assert
argument_list|(
name|cell
operator|->
name|key
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Swap cell->{key,data} and {key,data} (evict). */
name|tkey
operator|=
name|cell
operator|->
name|key
expr_stmt|;
name|tdata
operator|=
name|cell
operator|->
name|data
expr_stmt|;
name|cell
operator|->
name|key
operator|=
name|key
expr_stmt|;
name|cell
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|key
operator|=
name|tkey
expr_stmt|;
name|data
operator|=
name|tdata
expr_stmt|;
ifdef|#
directive|ifdef
name|CKH_COUNT
name|ckh
operator|->
name|nrelocs
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* Find the alternate bucket for the evicted item. */
name|ckh
operator|->
name|hash
argument_list|(
name|key
argument_list|,
name|hashes
argument_list|)
expr_stmt|;
name|tbucket
operator|=
name|hashes
index|[
literal|1
index|]
operator|&
operator|(
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
name|ckh
operator|->
name|lg_curbuckets
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|tbucket
operator|==
name|bucket
condition|)
block|{
name|tbucket
operator|=
name|hashes
index|[
literal|0
index|]
operator|&
operator|(
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
name|ckh
operator|->
name|lg_curbuckets
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* 			 * It may be that (tbucket == bucket) still, if the 			 * item's hashes both indicate this bucket.  However, 			 * we are guaranteed to eventually escape this bucket 			 * during iteration, assuming pseudo-random item 			 * selection (true randomness would make infinite 			 * looping a remote possibility).  The reason we can 			 * never get trapped forever is that there are two 			 * cases: 			 * 			 * 1) This bucket == argbucket, so we will quickly 			 *    detect an eviction cycle and terminate. 			 * 2) An item was evicted to this bucket from another, 			 *    which means that at least one item in this bucket 			 *    has hashes that indicate distinct buckets. 			 */
block|}
comment|/* Check for a cycle. */
if|if
condition|(
name|tbucket
operator|==
name|argbucket
condition|)
block|{
operator|*
name|argkey
operator|=
name|key
expr_stmt|;
operator|*
name|argdata
operator|=
name|data
expr_stmt|;
return|return
name|true
return|;
block|}
name|bucket
operator|=
name|tbucket
expr_stmt|;
if|if
condition|(
operator|!
name|ckh_try_bucket_insert
argument_list|(
name|ckh
argument_list|,
name|bucket
argument_list|,
name|key
argument_list|,
name|data
argument_list|)
condition|)
block|{
return|return
name|false
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|ckh_try_insert
parameter_list|(
name|ckh_t
modifier|*
name|ckh
parameter_list|,
name|void
specifier|const
modifier|*
modifier|*
name|argkey
parameter_list|,
name|void
specifier|const
modifier|*
modifier|*
name|argdata
parameter_list|)
block|{
name|size_t
name|hashes
index|[
literal|2
index|]
decl_stmt|,
name|bucket
decl_stmt|;
specifier|const
name|void
modifier|*
name|key
init|=
operator|*
name|argkey
decl_stmt|;
specifier|const
name|void
modifier|*
name|data
init|=
operator|*
name|argdata
decl_stmt|;
name|ckh
operator|->
name|hash
argument_list|(
name|key
argument_list|,
name|hashes
argument_list|)
expr_stmt|;
comment|/* Try to insert in primary bucket. */
name|bucket
operator|=
name|hashes
index|[
literal|0
index|]
operator|&
operator|(
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
name|ckh
operator|->
name|lg_curbuckets
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ckh_try_bucket_insert
argument_list|(
name|ckh
argument_list|,
name|bucket
argument_list|,
name|key
argument_list|,
name|data
argument_list|)
condition|)
block|{
return|return
name|false
return|;
block|}
comment|/* Try to insert in secondary bucket. */
name|bucket
operator|=
name|hashes
index|[
literal|1
index|]
operator|&
operator|(
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
name|ckh
operator|->
name|lg_curbuckets
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ckh_try_bucket_insert
argument_list|(
name|ckh
argument_list|,
name|bucket
argument_list|,
name|key
argument_list|,
name|data
argument_list|)
condition|)
block|{
return|return
name|false
return|;
block|}
comment|/* 	 * Try to find a place for this item via iterative eviction/relocation. 	 */
return|return
name|ckh_evict_reloc_insert
argument_list|(
name|ckh
argument_list|,
name|bucket
argument_list|,
name|argkey
argument_list|,
name|argdata
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try to rebuild the hash table from scratch by inserting all items from the  * old table into the new.  */
end_comment

begin_function
specifier|static
name|bool
name|ckh_rebuild
parameter_list|(
name|ckh_t
modifier|*
name|ckh
parameter_list|,
name|ckhc_t
modifier|*
name|aTab
parameter_list|)
block|{
name|size_t
name|count
decl_stmt|,
name|i
decl_stmt|,
name|nins
decl_stmt|;
specifier|const
name|void
modifier|*
name|key
decl_stmt|,
modifier|*
name|data
decl_stmt|;
name|count
operator|=
name|ckh
operator|->
name|count
expr_stmt|;
name|ckh
operator|->
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nins
operator|=
literal|0
init|;
name|nins
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|aTab
index|[
name|i
index|]
operator|.
name|key
operator|!=
name|NULL
condition|)
block|{
name|key
operator|=
name|aTab
index|[
name|i
index|]
operator|.
name|key
expr_stmt|;
name|data
operator|=
name|aTab
index|[
name|i
index|]
operator|.
name|data
expr_stmt|;
if|if
condition|(
name|ckh_try_insert
argument_list|(
name|ckh
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|)
condition|)
block|{
name|ckh
operator|->
name|count
operator|=
name|count
expr_stmt|;
return|return
name|true
return|;
block|}
name|nins
operator|++
expr_stmt|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ckh_grow
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|ckh_t
modifier|*
name|ckh
parameter_list|)
block|{
name|bool
name|ret
decl_stmt|;
name|ckhc_t
modifier|*
name|tab
decl_stmt|,
modifier|*
name|ttab
decl_stmt|;
name|unsigned
name|lg_prevbuckets
decl_stmt|,
name|lg_curcells
decl_stmt|;
ifdef|#
directive|ifdef
name|CKH_COUNT
name|ckh
operator|->
name|ngrows
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * It is possible (though unlikely, given well behaved hashes) that the 	 * table will have to be doubled more than once in order to create a 	 * usable table. 	 */
name|lg_prevbuckets
operator|=
name|ckh
operator|->
name|lg_curbuckets
expr_stmt|;
name|lg_curcells
operator|=
name|ckh
operator|->
name|lg_curbuckets
operator|+
name|LG_CKH_BUCKET_CELLS
expr_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|size_t
name|usize
decl_stmt|;
name|lg_curcells
operator|++
expr_stmt|;
name|usize
operator|=
name|sz_sa2u
argument_list|(
sizeof|sizeof
argument_list|(
name|ckhc_t
argument_list|)
operator|<<
name|lg_curcells
argument_list|,
name|CACHELINE
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|usize
operator|==
literal|0
operator|||
name|usize
operator|>
name|LARGE_MAXCLASS
argument_list|)
condition|)
block|{
name|ret
operator|=
name|true
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
name|tab
operator|=
operator|(
name|ckhc_t
operator|*
operator|)
name|ipallocztm
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|usize
argument_list|,
name|CACHELINE
argument_list|,
name|true
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|arena_ichoose
argument_list|(
name|tsd
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tab
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|true
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
comment|/* Swap in new table. */
name|ttab
operator|=
name|ckh
operator|->
name|tab
expr_stmt|;
name|ckh
operator|->
name|tab
operator|=
name|tab
expr_stmt|;
name|tab
operator|=
name|ttab
expr_stmt|;
name|ckh
operator|->
name|lg_curbuckets
operator|=
name|lg_curcells
operator|-
name|LG_CKH_BUCKET_CELLS
expr_stmt|;
if|if
condition|(
operator|!
name|ckh_rebuild
argument_list|(
name|ckh
argument_list|,
name|tab
argument_list|)
condition|)
block|{
name|idalloctm
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tab
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Rebuilding failed, so back out partially rebuilt table. */
name|idalloctm
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ckh
operator|->
name|tab
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|ckh
operator|->
name|tab
operator|=
name|tab
expr_stmt|;
name|ckh
operator|->
name|lg_curbuckets
operator|=
name|lg_prevbuckets
expr_stmt|;
block|}
name|ret
operator|=
name|false
expr_stmt|;
name|label_return
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ckh_shrink
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|ckh_t
modifier|*
name|ckh
parameter_list|)
block|{
name|ckhc_t
modifier|*
name|tab
decl_stmt|,
modifier|*
name|ttab
decl_stmt|;
name|size_t
name|usize
decl_stmt|;
name|unsigned
name|lg_prevbuckets
decl_stmt|,
name|lg_curcells
decl_stmt|;
comment|/* 	 * It is possible (though unlikely, given well behaved hashes) that the 	 * table rebuild will fail. 	 */
name|lg_prevbuckets
operator|=
name|ckh
operator|->
name|lg_curbuckets
expr_stmt|;
name|lg_curcells
operator|=
name|ckh
operator|->
name|lg_curbuckets
operator|+
name|LG_CKH_BUCKET_CELLS
operator|-
literal|1
expr_stmt|;
name|usize
operator|=
name|sz_sa2u
argument_list|(
sizeof|sizeof
argument_list|(
name|ckhc_t
argument_list|)
operator|<<
name|lg_curcells
argument_list|,
name|CACHELINE
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|usize
operator|==
literal|0
operator|||
name|usize
operator|>
name|LARGE_MAXCLASS
argument_list|)
condition|)
block|{
return|return;
block|}
name|tab
operator|=
operator|(
name|ckhc_t
operator|*
operator|)
name|ipallocztm
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|usize
argument_list|,
name|CACHELINE
argument_list|,
name|true
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|arena_ichoose
argument_list|(
name|tsd
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tab
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * An OOM error isn't worth propagating, since it doesn't 		 * prevent this or future operations from proceeding. 		 */
return|return;
block|}
comment|/* Swap in new table. */
name|ttab
operator|=
name|ckh
operator|->
name|tab
expr_stmt|;
name|ckh
operator|->
name|tab
operator|=
name|tab
expr_stmt|;
name|tab
operator|=
name|ttab
expr_stmt|;
name|ckh
operator|->
name|lg_curbuckets
operator|=
name|lg_curcells
operator|-
name|LG_CKH_BUCKET_CELLS
expr_stmt|;
if|if
condition|(
operator|!
name|ckh_rebuild
argument_list|(
name|ckh
argument_list|,
name|tab
argument_list|)
condition|)
block|{
name|idalloctm
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tab
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CKH_COUNT
name|ckh
operator|->
name|nshrinks
operator|++
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* Rebuilding failed, so back out partially rebuilt table. */
name|idalloctm
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ckh
operator|->
name|tab
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|ckh
operator|->
name|tab
operator|=
name|tab
expr_stmt|;
name|ckh
operator|->
name|lg_curbuckets
operator|=
name|lg_prevbuckets
expr_stmt|;
ifdef|#
directive|ifdef
name|CKH_COUNT
name|ckh
operator|->
name|nshrinkfails
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|bool
name|ckh_new
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|ckh_t
modifier|*
name|ckh
parameter_list|,
name|size_t
name|minitems
parameter_list|,
name|ckh_hash_t
modifier|*
name|hash
parameter_list|,
name|ckh_keycomp_t
modifier|*
name|keycomp
parameter_list|)
block|{
name|bool
name|ret
decl_stmt|;
name|size_t
name|mincells
decl_stmt|,
name|usize
decl_stmt|;
name|unsigned
name|lg_mincells
decl_stmt|;
name|assert
argument_list|(
name|minitems
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|hash
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|keycomp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CKH_COUNT
name|ckh
operator|->
name|ngrows
operator|=
literal|0
expr_stmt|;
name|ckh
operator|->
name|nshrinks
operator|=
literal|0
expr_stmt|;
name|ckh
operator|->
name|nshrinkfails
operator|=
literal|0
expr_stmt|;
name|ckh
operator|->
name|ninserts
operator|=
literal|0
expr_stmt|;
name|ckh
operator|->
name|nrelocs
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|ckh
operator|->
name|prng_state
operator|=
literal|42
expr_stmt|;
comment|/* Value doesn't really matter. */
name|ckh
operator|->
name|count
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Find the minimum power of 2 that is large enough to fit minitems 	 * entries.  We are using (2+,2) cuckoo hashing, which has an expected 	 * maximum load factor of at least ~0.86, so 0.75 is a conservative load 	 * factor that will typically allow mincells items to fit without ever 	 * growing the table. 	 */
name|assert
argument_list|(
name|LG_CKH_BUCKET_CELLS
operator|>
literal|0
argument_list|)
expr_stmt|;
name|mincells
operator|=
operator|(
operator|(
name|minitems
operator|+
operator|(
literal|3
operator|-
operator|(
name|minitems
operator|%
literal|3
operator|)
operator|)
operator|)
operator|/
literal|3
operator|)
operator|<<
literal|2
expr_stmt|;
for|for
control|(
name|lg_mincells
operator|=
name|LG_CKH_BUCKET_CELLS
init|;
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
name|lg_mincells
operator|)
operator|<
name|mincells
condition|;
name|lg_mincells
operator|++
control|)
block|{
comment|/* Do nothing. */
block|}
name|ckh
operator|->
name|lg_minbuckets
operator|=
name|lg_mincells
operator|-
name|LG_CKH_BUCKET_CELLS
expr_stmt|;
name|ckh
operator|->
name|lg_curbuckets
operator|=
name|lg_mincells
operator|-
name|LG_CKH_BUCKET_CELLS
expr_stmt|;
name|ckh
operator|->
name|hash
operator|=
name|hash
expr_stmt|;
name|ckh
operator|->
name|keycomp
operator|=
name|keycomp
expr_stmt|;
name|usize
operator|=
name|sz_sa2u
argument_list|(
sizeof|sizeof
argument_list|(
name|ckhc_t
argument_list|)
operator|<<
name|lg_mincells
argument_list|,
name|CACHELINE
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|usize
operator|==
literal|0
operator|||
name|usize
operator|>
name|LARGE_MAXCLASS
argument_list|)
condition|)
block|{
name|ret
operator|=
name|true
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
name|ckh
operator|->
name|tab
operator|=
operator|(
name|ckhc_t
operator|*
operator|)
name|ipallocztm
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|usize
argument_list|,
name|CACHELINE
argument_list|,
name|true
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|arena_ichoose
argument_list|(
name|tsd
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ckh
operator|->
name|tab
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|true
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
name|ret
operator|=
name|false
expr_stmt|;
name|label_return
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|ckh_delete
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|ckh_t
modifier|*
name|ckh
parameter_list|)
block|{
name|assert
argument_list|(
name|ckh
operator|!=
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CKH_VERBOSE
name|malloc_printf
argument_list|(
literal|"%s(%p): ngrows: %"
name|FMTu64
literal|", nshrinks: %"
name|FMTu64
literal|","
literal|" nshrinkfails: %"
name|FMTu64
literal|", ninserts: %"
name|FMTu64
literal|","
literal|" nrelocs: %"
name|FMTu64
literal|"\n"
argument_list|,
name|__func__
argument_list|,
name|ckh
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|ckh
operator|->
name|ngrows
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|ckh
operator|->
name|nshrinks
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|ckh
operator|->
name|nshrinkfails
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|ckh
operator|->
name|ninserts
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|ckh
operator|->
name|nrelocs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|idalloctm
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ckh
operator|->
name|tab
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_debug
condition|)
block|{
name|memset
argument_list|(
name|ckh
argument_list|,
name|JEMALLOC_FREE_JUNK
argument_list|,
sizeof|sizeof
argument_list|(
name|ckh_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|size_t
name|ckh_count
parameter_list|(
name|ckh_t
modifier|*
name|ckh
parameter_list|)
block|{
name|assert
argument_list|(
name|ckh
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|ckh
operator|->
name|count
return|;
block|}
end_function

begin_function
name|bool
name|ckh_iter
parameter_list|(
name|ckh_t
modifier|*
name|ckh
parameter_list|,
name|size_t
modifier|*
name|tabind
parameter_list|,
name|void
modifier|*
modifier|*
name|key
parameter_list|,
name|void
modifier|*
modifier|*
name|data
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|ncells
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|*
name|tabind
operator|,
name|ncells
operator|=
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
operator|(
name|ckh
operator|->
name|lg_curbuckets
operator|+
name|LG_CKH_BUCKET_CELLS
operator|)
operator|)
init|;
name|i
operator|<
name|ncells
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ckh
operator|->
name|tab
index|[
name|i
index|]
operator|.
name|key
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
block|{
operator|*
name|key
operator|=
operator|(
name|void
operator|*
operator|)
name|ckh
operator|->
name|tab
index|[
name|i
index|]
operator|.
name|key
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
block|{
operator|*
name|data
operator|=
operator|(
name|void
operator|*
operator|)
name|ckh
operator|->
name|tab
index|[
name|i
index|]
operator|.
name|data
expr_stmt|;
block|}
operator|*
name|tabind
operator|=
name|i
operator|+
literal|1
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|bool
name|ckh_insert
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|ckh_t
modifier|*
name|ckh
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|)
block|{
name|bool
name|ret
decl_stmt|;
name|assert
argument_list|(
name|ckh
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ckh_search
argument_list|(
name|ckh
argument_list|,
name|key
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CKH_COUNT
name|ckh
operator|->
name|ninserts
operator|++
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|ckh_try_insert
argument_list|(
name|ckh
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|)
condition|)
block|{
if|if
condition|(
name|ckh_grow
argument_list|(
name|tsd
argument_list|,
name|ckh
argument_list|)
condition|)
block|{
name|ret
operator|=
name|true
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
block|}
name|ret
operator|=
name|false
expr_stmt|;
name|label_return
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
name|bool
name|ckh_remove
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|ckh_t
modifier|*
name|ckh
parameter_list|,
specifier|const
name|void
modifier|*
name|searchkey
parameter_list|,
name|void
modifier|*
modifier|*
name|key
parameter_list|,
name|void
modifier|*
modifier|*
name|data
parameter_list|)
block|{
name|size_t
name|cell
decl_stmt|;
name|assert
argument_list|(
name|ckh
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|cell
operator|=
name|ckh_isearch
argument_list|(
name|ckh
argument_list|,
name|searchkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|cell
operator|!=
name|SIZE_T_MAX
condition|)
block|{
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
block|{
operator|*
name|key
operator|=
operator|(
name|void
operator|*
operator|)
name|ckh
operator|->
name|tab
index|[
name|cell
index|]
operator|.
name|key
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
block|{
operator|*
name|data
operator|=
operator|(
name|void
operator|*
operator|)
name|ckh
operator|->
name|tab
index|[
name|cell
index|]
operator|.
name|data
expr_stmt|;
block|}
name|ckh
operator|->
name|tab
index|[
name|cell
index|]
operator|.
name|key
operator|=
name|NULL
expr_stmt|;
name|ckh
operator|->
name|tab
index|[
name|cell
index|]
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
comment|/* Not necessary. */
name|ckh
operator|->
name|count
operator|--
expr_stmt|;
comment|/* Try to halve the table if it is less than 1/4 full. */
if|if
condition|(
name|ckh
operator|->
name|count
operator|<
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
operator|(
name|ckh
operator|->
name|lg_curbuckets
operator|+
name|LG_CKH_BUCKET_CELLS
operator|-
literal|2
operator|)
operator|)
operator|&&
name|ckh
operator|->
name|lg_curbuckets
operator|>
name|ckh
operator|->
name|lg_minbuckets
condition|)
block|{
comment|/* Ignore error due to OOM. */
name|ckh_shrink
argument_list|(
name|tsd
argument_list|,
name|ckh
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|bool
name|ckh_search
parameter_list|(
name|ckh_t
modifier|*
name|ckh
parameter_list|,
specifier|const
name|void
modifier|*
name|searchkey
parameter_list|,
name|void
modifier|*
modifier|*
name|key
parameter_list|,
name|void
modifier|*
modifier|*
name|data
parameter_list|)
block|{
name|size_t
name|cell
decl_stmt|;
name|assert
argument_list|(
name|ckh
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|cell
operator|=
name|ckh_isearch
argument_list|(
name|ckh
argument_list|,
name|searchkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|cell
operator|!=
name|SIZE_T_MAX
condition|)
block|{
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
block|{
operator|*
name|key
operator|=
operator|(
name|void
operator|*
operator|)
name|ckh
operator|->
name|tab
index|[
name|cell
index|]
operator|.
name|key
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
block|{
operator|*
name|data
operator|=
operator|(
name|void
operator|*
operator|)
name|ckh
operator|->
name|tab
index|[
name|cell
index|]
operator|.
name|data
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|void
name|ckh_string_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|size_t
name|r_hash
index|[
literal|2
index|]
parameter_list|)
block|{
name|hash
argument_list|(
name|key
argument_list|,
name|strlen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|key
argument_list|)
argument_list|,
literal|0x94122f33U
argument_list|,
name|r_hash
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|ckh_string_keycomp
parameter_list|(
specifier|const
name|void
modifier|*
name|k1
parameter_list|,
specifier|const
name|void
modifier|*
name|k2
parameter_list|)
block|{
name|assert
argument_list|(
name|k1
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|k2
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|!
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|k1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|k2
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ckh_pointer_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|size_t
name|r_hash
index|[
literal|2
index|]
parameter_list|)
block|{
union|union
block|{
specifier|const
name|void
modifier|*
name|v
decl_stmt|;
name|size_t
name|i
decl_stmt|;
block|}
name|u
union|;
name|assert
argument_list|(
sizeof|sizeof
argument_list|(
name|u
operator|.
name|v
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|u
operator|.
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|.
name|v
operator|=
name|key
expr_stmt|;
name|hash
argument_list|(
operator|&
name|u
operator|.
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|u
operator|.
name|i
argument_list|)
argument_list|,
literal|0xd983396eU
argument_list|,
name|r_hash
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|ckh_pointer_keycomp
parameter_list|(
specifier|const
name|void
modifier|*
name|k1
parameter_list|,
specifier|const
name|void
modifier|*
name|k2
parameter_list|)
block|{
return|return
operator|(
name|k1
operator|==
name|k2
operator|)
return|;
block|}
end_function

end_unit

