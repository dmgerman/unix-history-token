begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|JEMALLOC_PROF_C_
end_define

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_internal.h"
end_include

begin_comment
comment|/******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_PROF_LIBUNWIND
end_ifdef

begin_define
define|#
directive|define
name|UNW_LOCAL_ONLY
end_define

begin_include
include|#
directive|include
file|<libunwind.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_PROF_LIBGCC
end_ifdef

begin_include
include|#
directive|include
file|<unwind.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/* Data. */
end_comment

begin_macro
name|malloc_tsd_data
argument_list|(
argument_list|,
argument|prof_tdata
argument_list|,
argument|prof_tdata_t *
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_decl_stmt
name|bool
name|opt_prof
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_prof_active
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|opt_lg_prof_sample
init|=
name|LG_PROF_SAMPLE_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ssize_t
name|opt_lg_prof_interval
init|=
name|LG_PROF_INTERVAL_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_prof_gdump
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_prof_final
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_prof_leak
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_prof_accum
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|opt_prof_prefix
index|[
comment|/* Minimize memory bloat for non-prof builds. */
ifdef|#
directive|ifdef
name|JEMALLOC_PROF
name|PATH_MAX
operator|+
endif|#
directive|endif
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|prof_interval
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|prof_promote
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Table of mutexes that are shared among ctx's.  These are leaf locks, so  * there is no problem with using them for more than one ctx at the same time.  * The primary motivation for this sharing though is that ctx's are ephemeral,  * and destroying mutexes causes complications for systems that allocate when  * creating/destroying mutexes.  */
end_comment

begin_decl_stmt
specifier|static
name|malloc_mutex_t
modifier|*
name|ctx_locks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|cum_ctxs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Atomic counter. */
end_comment

begin_comment
comment|/*  * Global hash of (prof_bt_t *)-->(prof_ctx_t *).  This is the master data  * structure that knows about all backtraces currently captured.  */
end_comment

begin_decl_stmt
specifier|static
name|ckh_t
name|bt2ctx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|bt2ctx_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|prof_dump_seq_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|prof_dump_seq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|prof_dump_iseq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|prof_dump_mseq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|prof_dump_useq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This buffer is rather large for stack allocation, so use a single buffer for  * all profile dumps.  */
end_comment

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|prof_dump_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|prof_dump_buf
index|[
comment|/* Minimize memory bloat for non-prof builds. */
ifdef|#
directive|ifdef
name|JEMALLOC_PROF
name|PROF_DUMP_BUFSIZE
else|#
directive|else
literal|1
endif|#
directive|endif
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|prof_dump_buf_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|prof_dump_fd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do not dump any profiles until bootstrapping is complete. */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|prof_booted
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************/
end_comment

begin_function
name|void
name|bt_init
parameter_list|(
name|prof_bt_t
modifier|*
name|bt
parameter_list|,
name|void
modifier|*
modifier|*
name|vec
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|bt
operator|->
name|vec
operator|=
name|vec
expr_stmt|;
name|bt
operator|->
name|len
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bt_destroy
parameter_list|(
name|prof_bt_t
modifier|*
name|bt
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|idalloc
argument_list|(
name|bt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|prof_bt_t
modifier|*
name|bt_dup
parameter_list|(
name|prof_bt_t
modifier|*
name|bt
parameter_list|)
block|{
name|prof_bt_t
modifier|*
name|ret
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
comment|/* 	 * Create a single allocation that has space for vec immediately 	 * following the prof_bt_t structure.  The backtraces that get 	 * stored in the backtrace caches are copied from stack-allocated 	 * temporary variables, so size is known at creation time.  Making this 	 * a contiguous object improves cache locality. 	 */
name|ret
operator|=
operator|(
name|prof_bt_t
operator|*
operator|)
name|imalloc
argument_list|(
name|QUANTUM_CEILING
argument_list|(
sizeof|sizeof
argument_list|(
name|prof_bt_t
argument_list|)
argument_list|)
operator|+
operator|(
name|bt
operator|->
name|len
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ret
operator|->
name|vec
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|+
name|QUANTUM_CEILING
argument_list|(
sizeof|sizeof
argument_list|(
name|prof_bt_t
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
operator|->
name|vec
argument_list|,
name|bt
operator|->
name|vec
argument_list|,
name|bt
operator|->
name|len
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|->
name|len
operator|=
name|bt
operator|->
name|len
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|prof_enter
parameter_list|(
name|prof_tdata_t
modifier|*
name|prof_tdata
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|prof_tdata
operator|->
name|enq
operator|==
name|false
argument_list|)
expr_stmt|;
name|prof_tdata
operator|->
name|enq
operator|=
name|true
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|bt2ctx_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|prof_leave
parameter_list|(
name|prof_tdata_t
modifier|*
name|prof_tdata
parameter_list|)
block|{
name|bool
name|idump
decl_stmt|,
name|gdump
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|bt2ctx_mtx
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|prof_tdata
operator|->
name|enq
argument_list|)
expr_stmt|;
name|prof_tdata
operator|->
name|enq
operator|=
name|false
expr_stmt|;
name|idump
operator|=
name|prof_tdata
operator|->
name|enq_idump
expr_stmt|;
name|prof_tdata
operator|->
name|enq_idump
operator|=
name|false
expr_stmt|;
name|gdump
operator|=
name|prof_tdata
operator|->
name|enq_gdump
expr_stmt|;
name|prof_tdata
operator|->
name|enq_gdump
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|idump
condition|)
name|prof_idump
argument_list|()
expr_stmt|;
if|if
condition|(
name|gdump
condition|)
name|prof_gdump
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_PROF_LIBUNWIND
end_ifdef

begin_function
name|void
name|prof_backtrace
parameter_list|(
name|prof_bt_t
modifier|*
name|bt
parameter_list|,
name|unsigned
name|nignore
parameter_list|)
block|{
name|unw_context_t
name|uc
decl_stmt|;
name|unw_cursor_t
name|cursor
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|int
name|err
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|bt
operator|->
name|len
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|bt
operator|->
name|vec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|unw_getcontext
argument_list|(
operator|&
name|uc
argument_list|)
expr_stmt|;
name|unw_init_local
argument_list|(
operator|&
name|cursor
argument_list|,
operator|&
name|uc
argument_list|)
expr_stmt|;
comment|/* Throw away (nignore+1) stack frames, if that many exist. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nignore
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|unw_step
argument_list|(
operator|&
name|cursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<=
literal|0
condition|)
return|return;
block|}
comment|/* 	 * Iterate over stack frames until there are no more, or until no space 	 * remains in bt. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PROF_BT_MAX
condition|;
name|i
operator|++
control|)
block|{
name|unw_get_reg
argument_list|(
operator|&
name|cursor
argument_list|,
name|UNW_REG_IP
argument_list|,
operator|(
name|unw_word_t
operator|*
operator|)
operator|&
name|bt
operator|->
name|vec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bt
operator|->
name|len
operator|++
expr_stmt|;
name|err
operator|=
name|unw_step
argument_list|(
operator|&
name|cursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<=
literal|0
condition|)
break|break;
block|}
block|}
end_function

begin_elif
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|JEMALLOC_PROF_LIBGCC
argument_list|)
operator|)
end_elif

begin_function
specifier|static
name|_Unwind_Reason_Code
name|prof_unwind_init_callback
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
return|return
operator|(
name|_URC_NO_REASON
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|_Unwind_Reason_Code
name|prof_unwind_callback
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|prof_unwind_data_t
modifier|*
name|data
init|=
operator|(
name|prof_unwind_data_t
operator|*
operator|)
name|arg
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|nignore
operator|>
literal|0
condition|)
name|data
operator|->
name|nignore
operator|--
expr_stmt|;
else|else
block|{
name|data
operator|->
name|bt
operator|->
name|vec
index|[
name|data
operator|->
name|bt
operator|->
name|len
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|_Unwind_GetIP
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|data
operator|->
name|bt
operator|->
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|bt
operator|->
name|len
operator|==
name|data
operator|->
name|max
condition|)
return|return
operator|(
name|_URC_END_OF_STACK
operator|)
return|;
block|}
return|return
operator|(
name|_URC_NO_REASON
operator|)
return|;
block|}
end_function

begin_function
name|void
name|prof_backtrace
parameter_list|(
name|prof_bt_t
modifier|*
name|bt
parameter_list|,
name|unsigned
name|nignore
parameter_list|)
block|{
name|prof_unwind_data_t
name|data
init|=
block|{
name|bt
block|,
name|nignore
block|,
name|PROF_BT_MAX
block|}
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|_Unwind_Backtrace
argument_list|(
name|prof_unwind_callback
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_elif
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|JEMALLOC_PROF_GCC
argument_list|)
operator|)
end_elif

begin_function
name|void
name|prof_backtrace
parameter_list|(
name|prof_bt_t
modifier|*
name|bt
parameter_list|,
name|unsigned
name|nignore
parameter_list|)
block|{
define|#
directive|define
name|BT_FRAME
parameter_list|(
name|i
parameter_list|)
define|\
value|if ((i)< nignore + PROF_BT_MAX) {				\ 		void *p;						\ 		if (__builtin_frame_address(i) == 0)			\ 			return;						\ 		p = __builtin_return_address(i);			\ 		if (p == NULL)						\ 			return;						\ 		if (i>= nignore) {					\ 			bt->vec[(i) - nignore] = p;			\ 			bt->len = (i) - nignore + 1;			\ 		}							\ 	} else								\ 		return;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|nignore
operator|<=
literal|3
argument_list|)
expr_stmt|;
name|BT_FRAME
argument_list|(
literal|0
argument_list|)
name|BT_FRAME
argument_list|(
literal|1
argument_list|)
name|BT_FRAME
argument_list|(
literal|2
argument_list|)
name|BT_FRAME
argument_list|(
literal|3
argument_list|)
name|BT_FRAME
argument_list|(
literal|4
argument_list|)
name|BT_FRAME
argument_list|(
literal|5
argument_list|)
name|BT_FRAME
argument_list|(
literal|6
argument_list|)
name|BT_FRAME
argument_list|(
literal|7
argument_list|)
name|BT_FRAME
argument_list|(
literal|8
argument_list|)
name|BT_FRAME
argument_list|(
literal|9
argument_list|)
name|BT_FRAME
argument_list|(
literal|10
argument_list|)
name|BT_FRAME
argument_list|(
literal|11
argument_list|)
name|BT_FRAME
argument_list|(
literal|12
argument_list|)
name|BT_FRAME
argument_list|(
literal|13
argument_list|)
name|BT_FRAME
argument_list|(
literal|14
argument_list|)
name|BT_FRAME
argument_list|(
literal|15
argument_list|)
name|BT_FRAME
argument_list|(
literal|16
argument_list|)
name|BT_FRAME
argument_list|(
literal|17
argument_list|)
name|BT_FRAME
argument_list|(
literal|18
argument_list|)
name|BT_FRAME
argument_list|(
literal|19
argument_list|)
name|BT_FRAME
argument_list|(
literal|20
argument_list|)
name|BT_FRAME
argument_list|(
literal|21
argument_list|)
name|BT_FRAME
argument_list|(
literal|22
argument_list|)
name|BT_FRAME
argument_list|(
literal|23
argument_list|)
name|BT_FRAME
argument_list|(
literal|24
argument_list|)
name|BT_FRAME
argument_list|(
literal|25
argument_list|)
name|BT_FRAME
argument_list|(
literal|26
argument_list|)
name|BT_FRAME
argument_list|(
literal|27
argument_list|)
name|BT_FRAME
argument_list|(
literal|28
argument_list|)
name|BT_FRAME
argument_list|(
literal|29
argument_list|)
name|BT_FRAME
argument_list|(
literal|30
argument_list|)
name|BT_FRAME
argument_list|(
literal|31
argument_list|)
name|BT_FRAME
argument_list|(
literal|32
argument_list|)
name|BT_FRAME
argument_list|(
literal|33
argument_list|)
name|BT_FRAME
argument_list|(
literal|34
argument_list|)
name|BT_FRAME
argument_list|(
literal|35
argument_list|)
name|BT_FRAME
argument_list|(
literal|36
argument_list|)
name|BT_FRAME
argument_list|(
literal|37
argument_list|)
name|BT_FRAME
argument_list|(
literal|38
argument_list|)
name|BT_FRAME
argument_list|(
literal|39
argument_list|)
name|BT_FRAME
argument_list|(
literal|40
argument_list|)
name|BT_FRAME
argument_list|(
literal|41
argument_list|)
name|BT_FRAME
argument_list|(
literal|42
argument_list|)
name|BT_FRAME
argument_list|(
literal|43
argument_list|)
name|BT_FRAME
argument_list|(
literal|44
argument_list|)
name|BT_FRAME
argument_list|(
literal|45
argument_list|)
name|BT_FRAME
argument_list|(
literal|46
argument_list|)
name|BT_FRAME
argument_list|(
literal|47
argument_list|)
name|BT_FRAME
argument_list|(
literal|48
argument_list|)
name|BT_FRAME
argument_list|(
literal|49
argument_list|)
name|BT_FRAME
argument_list|(
literal|50
argument_list|)
name|BT_FRAME
argument_list|(
literal|51
argument_list|)
name|BT_FRAME
argument_list|(
literal|52
argument_list|)
name|BT_FRAME
argument_list|(
literal|53
argument_list|)
name|BT_FRAME
argument_list|(
literal|54
argument_list|)
name|BT_FRAME
argument_list|(
literal|55
argument_list|)
name|BT_FRAME
argument_list|(
literal|56
argument_list|)
name|BT_FRAME
argument_list|(
literal|57
argument_list|)
name|BT_FRAME
argument_list|(
literal|58
argument_list|)
name|BT_FRAME
argument_list|(
literal|59
argument_list|)
name|BT_FRAME
argument_list|(
literal|60
argument_list|)
name|BT_FRAME
argument_list|(
literal|61
argument_list|)
name|BT_FRAME
argument_list|(
literal|62
argument_list|)
name|BT_FRAME
argument_list|(
literal|63
argument_list|)
name|BT_FRAME
argument_list|(
literal|64
argument_list|)
name|BT_FRAME
argument_list|(
literal|65
argument_list|)
name|BT_FRAME
argument_list|(
literal|66
argument_list|)
name|BT_FRAME
argument_list|(
literal|67
argument_list|)
name|BT_FRAME
argument_list|(
literal|68
argument_list|)
name|BT_FRAME
argument_list|(
literal|69
argument_list|)
name|BT_FRAME
argument_list|(
literal|70
argument_list|)
name|BT_FRAME
argument_list|(
literal|71
argument_list|)
name|BT_FRAME
argument_list|(
literal|72
argument_list|)
name|BT_FRAME
argument_list|(
literal|73
argument_list|)
name|BT_FRAME
argument_list|(
literal|74
argument_list|)
name|BT_FRAME
argument_list|(
literal|75
argument_list|)
name|BT_FRAME
argument_list|(
literal|76
argument_list|)
name|BT_FRAME
argument_list|(
literal|77
argument_list|)
name|BT_FRAME
argument_list|(
literal|78
argument_list|)
name|BT_FRAME
argument_list|(
literal|79
argument_list|)
name|BT_FRAME
argument_list|(
literal|80
argument_list|)
name|BT_FRAME
argument_list|(
literal|81
argument_list|)
name|BT_FRAME
argument_list|(
literal|82
argument_list|)
name|BT_FRAME
argument_list|(
literal|83
argument_list|)
name|BT_FRAME
argument_list|(
literal|84
argument_list|)
name|BT_FRAME
argument_list|(
literal|85
argument_list|)
name|BT_FRAME
argument_list|(
literal|86
argument_list|)
name|BT_FRAME
argument_list|(
literal|87
argument_list|)
name|BT_FRAME
argument_list|(
literal|88
argument_list|)
name|BT_FRAME
argument_list|(
literal|89
argument_list|)
name|BT_FRAME
argument_list|(
literal|90
argument_list|)
name|BT_FRAME
argument_list|(
literal|91
argument_list|)
name|BT_FRAME
argument_list|(
literal|92
argument_list|)
name|BT_FRAME
argument_list|(
literal|93
argument_list|)
name|BT_FRAME
argument_list|(
literal|94
argument_list|)
name|BT_FRAME
argument_list|(
literal|95
argument_list|)
name|BT_FRAME
argument_list|(
literal|96
argument_list|)
name|BT_FRAME
argument_list|(
literal|97
argument_list|)
name|BT_FRAME
argument_list|(
literal|98
argument_list|)
name|BT_FRAME
argument_list|(
literal|99
argument_list|)
name|BT_FRAME
argument_list|(
literal|100
argument_list|)
name|BT_FRAME
argument_list|(
literal|101
argument_list|)
name|BT_FRAME
argument_list|(
literal|102
argument_list|)
name|BT_FRAME
argument_list|(
literal|103
argument_list|)
name|BT_FRAME
argument_list|(
literal|104
argument_list|)
name|BT_FRAME
argument_list|(
literal|105
argument_list|)
name|BT_FRAME
argument_list|(
literal|106
argument_list|)
name|BT_FRAME
argument_list|(
literal|107
argument_list|)
name|BT_FRAME
argument_list|(
literal|108
argument_list|)
name|BT_FRAME
argument_list|(
literal|109
argument_list|)
name|BT_FRAME
argument_list|(
literal|110
argument_list|)
name|BT_FRAME
argument_list|(
literal|111
argument_list|)
name|BT_FRAME
argument_list|(
literal|112
argument_list|)
name|BT_FRAME
argument_list|(
literal|113
argument_list|)
name|BT_FRAME
argument_list|(
literal|114
argument_list|)
name|BT_FRAME
argument_list|(
literal|115
argument_list|)
name|BT_FRAME
argument_list|(
literal|116
argument_list|)
name|BT_FRAME
argument_list|(
literal|117
argument_list|)
name|BT_FRAME
argument_list|(
literal|118
argument_list|)
name|BT_FRAME
argument_list|(
literal|119
argument_list|)
name|BT_FRAME
argument_list|(
literal|120
argument_list|)
name|BT_FRAME
argument_list|(
literal|121
argument_list|)
name|BT_FRAME
argument_list|(
literal|122
argument_list|)
name|BT_FRAME
argument_list|(
literal|123
argument_list|)
name|BT_FRAME
argument_list|(
literal|124
argument_list|)
name|BT_FRAME
argument_list|(
literal|125
argument_list|)
name|BT_FRAME
argument_list|(
literal|126
argument_list|)
name|BT_FRAME
argument_list|(
literal|127
argument_list|)
comment|/* Extras to compensate for nignore. */
name|BT_FRAME
argument_list|(
literal|128
argument_list|)
name|BT_FRAME
argument_list|(
literal|129
argument_list|)
name|BT_FRAME
argument_list|(
literal|130
argument_list|)
undef|#
directive|undef
name|BT_FRAME
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|prof_backtrace
parameter_list|(
name|prof_bt_t
modifier|*
name|bt
parameter_list|,
name|unsigned
name|nignore
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|not_reached
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|malloc_mutex_t
modifier|*
name|prof_ctx_mutex_choose
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|nctxs
init|=
name|atomic_add_u
argument_list|(
operator|&
name|cum_ctxs
argument_list|,
literal|1
argument_list|)
decl_stmt|;
return|return
operator|(
operator|&
name|ctx_locks
index|[
operator|(
name|nctxs
operator|-
literal|1
operator|)
operator|%
name|PROF_NCTX_LOCKS
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|prof_ctx_init
parameter_list|(
name|prof_ctx_t
modifier|*
name|ctx
parameter_list|,
name|prof_bt_t
modifier|*
name|bt
parameter_list|)
block|{
name|ctx
operator|->
name|bt
operator|=
name|bt
expr_stmt|;
name|ctx
operator|->
name|lock
operator|=
name|prof_ctx_mutex_choose
argument_list|()
expr_stmt|;
comment|/* 	 * Set nlimbo to 1, in order to avoid a race condition with 	 * prof_ctx_merge()/prof_ctx_destroy(). 	 */
name|ctx
operator|->
name|nlimbo
operator|=
literal|1
expr_stmt|;
name|ql_elm_new
argument_list|(
name|ctx
argument_list|,
name|dump_link
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ctx
operator|->
name|cnt_merged
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|prof_cnt_t
argument_list|)
argument_list|)
expr_stmt|;
name|ql_new
argument_list|(
operator|&
name|ctx
operator|->
name|cnts_ql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|prof_ctx_destroy
parameter_list|(
name|prof_ctx_t
modifier|*
name|ctx
parameter_list|)
block|{
name|prof_tdata_t
modifier|*
name|prof_tdata
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
comment|/* 	 * Check that ctx is still unused by any thread cache before destroying 	 * it.  prof_lookup() increments ctx->nlimbo in order to avoid a race 	 * condition with this function, as does prof_ctx_merge() in order to 	 * avoid a race between the main body of prof_ctx_merge() and entry 	 * into this function. 	 */
name|prof_tdata
operator|=
name|prof_tdata_get
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|uintptr_t
operator|)
name|prof_tdata
operator|>
operator|(
name|uintptr_t
operator|)
name|PROF_TDATA_STATE_MAX
argument_list|)
expr_stmt|;
name|prof_enter
argument_list|(
name|prof_tdata
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ql_first
argument_list|(
operator|&
name|ctx
operator|->
name|cnts_ql
argument_list|)
operator|==
name|NULL
operator|&&
name|ctx
operator|->
name|cnt_merged
operator|.
name|curobjs
operator|==
literal|0
operator|&&
name|ctx
operator|->
name|nlimbo
operator|==
literal|1
condition|)
block|{
name|assert
argument_list|(
name|ctx
operator|->
name|cnt_merged
operator|.
name|curbytes
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ctx
operator|->
name|cnt_merged
operator|.
name|accumobjs
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ctx
operator|->
name|cnt_merged
operator|.
name|accumbytes
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Remove ctx from bt2ctx. */
if|if
condition|(
name|ckh_remove
argument_list|(
operator|&
name|bt2ctx
argument_list|,
name|ctx
operator|->
name|bt
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
name|not_reached
argument_list|()
expr_stmt|;
name|prof_leave
argument_list|(
name|prof_tdata
argument_list|)
expr_stmt|;
comment|/* Destroy ctx. */
name|malloc_mutex_unlock
argument_list|(
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|bt_destroy
argument_list|(
name|ctx
operator|->
name|bt
argument_list|)
expr_stmt|;
name|idalloc
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Compensate for increment in prof_ctx_merge() or 		 * prof_lookup(). 		 */
name|ctx
operator|->
name|nlimbo
operator|--
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|prof_leave
argument_list|(
name|prof_tdata
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|prof_ctx_merge
parameter_list|(
name|prof_ctx_t
modifier|*
name|ctx
parameter_list|,
name|prof_thr_cnt_t
modifier|*
name|cnt
parameter_list|)
block|{
name|bool
name|destroy
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
comment|/* Merge cnt stats and detach from ctx. */
name|malloc_mutex_lock
argument_list|(
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|cnt_merged
operator|.
name|curobjs
operator|+=
name|cnt
operator|->
name|cnts
operator|.
name|curobjs
expr_stmt|;
name|ctx
operator|->
name|cnt_merged
operator|.
name|curbytes
operator|+=
name|cnt
operator|->
name|cnts
operator|.
name|curbytes
expr_stmt|;
name|ctx
operator|->
name|cnt_merged
operator|.
name|accumobjs
operator|+=
name|cnt
operator|->
name|cnts
operator|.
name|accumobjs
expr_stmt|;
name|ctx
operator|->
name|cnt_merged
operator|.
name|accumbytes
operator|+=
name|cnt
operator|->
name|cnts
operator|.
name|accumbytes
expr_stmt|;
name|ql_remove
argument_list|(
operator|&
name|ctx
operator|->
name|cnts_ql
argument_list|,
name|cnt
argument_list|,
name|cnts_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_prof_accum
operator|==
name|false
operator|&&
name|ql_first
argument_list|(
operator|&
name|ctx
operator|->
name|cnts_ql
argument_list|)
operator|==
name|NULL
operator|&&
name|ctx
operator|->
name|cnt_merged
operator|.
name|curobjs
operator|==
literal|0
operator|&&
name|ctx
operator|->
name|nlimbo
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Increment ctx->nlimbo in order to keep another thread from 		 * winning the race to destroy ctx while this one has ctx->lock 		 * dropped.  Without this, it would be possible for another 		 * thread to: 		 * 		 * 1) Sample an allocation associated with ctx. 		 * 2) Deallocate the sampled object. 		 * 3) Successfully prof_ctx_destroy(ctx). 		 * 		 * The result would be that ctx no longer exists by the time 		 * this thread accesses it in prof_ctx_destroy(). 		 */
name|ctx
operator|->
name|nlimbo
operator|++
expr_stmt|;
name|destroy
operator|=
name|true
expr_stmt|;
block|}
else|else
name|destroy
operator|=
name|false
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|destroy
condition|)
name|prof_ctx_destroy
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|prof_lookup_global
parameter_list|(
name|prof_bt_t
modifier|*
name|bt
parameter_list|,
name|prof_tdata_t
modifier|*
name|prof_tdata
parameter_list|,
name|void
modifier|*
modifier|*
name|p_btkey
parameter_list|,
name|prof_ctx_t
modifier|*
modifier|*
name|p_ctx
parameter_list|,
name|bool
modifier|*
name|p_new_ctx
parameter_list|)
block|{
union|union
block|{
name|prof_ctx_t
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|v
decl_stmt|;
block|}
name|ctx
union|;
union|union
block|{
name|prof_bt_t
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|v
decl_stmt|;
block|}
name|btkey
union|;
name|bool
name|new_ctx
decl_stmt|;
name|prof_enter
argument_list|(
name|prof_tdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|ckh_search
argument_list|(
operator|&
name|bt2ctx
argument_list|,
name|bt
argument_list|,
operator|&
name|btkey
operator|.
name|v
argument_list|,
operator|&
name|ctx
operator|.
name|v
argument_list|)
condition|)
block|{
comment|/* bt has never been seen before.  Insert it. */
name|ctx
operator|.
name|v
operator|=
name|imalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|prof_ctx_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|.
name|v
operator|==
name|NULL
condition|)
block|{
name|prof_leave
argument_list|(
name|prof_tdata
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
name|btkey
operator|.
name|p
operator|=
name|bt_dup
argument_list|(
name|bt
argument_list|)
expr_stmt|;
if|if
condition|(
name|btkey
operator|.
name|v
operator|==
name|NULL
condition|)
block|{
name|prof_leave
argument_list|(
name|prof_tdata
argument_list|)
expr_stmt|;
name|idalloc
argument_list|(
name|ctx
operator|.
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
name|prof_ctx_init
argument_list|(
name|ctx
operator|.
name|p
argument_list|,
name|btkey
operator|.
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ckh_insert
argument_list|(
operator|&
name|bt2ctx
argument_list|,
name|btkey
operator|.
name|v
argument_list|,
name|ctx
operator|.
name|v
argument_list|)
condition|)
block|{
comment|/* OOM. */
name|prof_leave
argument_list|(
name|prof_tdata
argument_list|)
expr_stmt|;
name|idalloc
argument_list|(
name|btkey
operator|.
name|v
argument_list|)
expr_stmt|;
name|idalloc
argument_list|(
name|ctx
operator|.
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
name|new_ctx
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Increment nlimbo, in order to avoid a race condition with 		 * prof_ctx_merge()/prof_ctx_destroy(). 		 */
name|malloc_mutex_lock
argument_list|(
name|ctx
operator|.
name|p
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|p
operator|->
name|nlimbo
operator|++
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|ctx
operator|.
name|p
operator|->
name|lock
argument_list|)
expr_stmt|;
name|new_ctx
operator|=
name|false
expr_stmt|;
block|}
name|prof_leave
argument_list|(
name|prof_tdata
argument_list|)
expr_stmt|;
operator|*
name|p_btkey
operator|=
name|btkey
operator|.
name|v
expr_stmt|;
operator|*
name|p_ctx
operator|=
name|ctx
operator|.
name|p
expr_stmt|;
operator|*
name|p_new_ctx
operator|=
name|new_ctx
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
name|prof_thr_cnt_t
modifier|*
name|prof_lookup
parameter_list|(
name|prof_bt_t
modifier|*
name|bt
parameter_list|)
block|{
union|union
block|{
name|prof_thr_cnt_t
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|v
decl_stmt|;
block|}
name|ret
union|;
name|prof_tdata_t
modifier|*
name|prof_tdata
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|prof_tdata
operator|=
name|prof_tdata_get
argument_list|(
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|prof_tdata
operator|<=
operator|(
name|uintptr_t
operator|)
name|PROF_TDATA_STATE_MAX
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|ckh_search
argument_list|(
operator|&
name|prof_tdata
operator|->
name|bt2cnt
argument_list|,
name|bt
argument_list|,
name|NULL
argument_list|,
operator|&
name|ret
operator|.
name|v
argument_list|)
condition|)
block|{
name|void
modifier|*
name|btkey
decl_stmt|;
name|prof_ctx_t
modifier|*
name|ctx
decl_stmt|;
name|bool
name|new_ctx
decl_stmt|;
comment|/* 		 * This thread's cache lacks bt.  Look for it in the global 		 * cache. 		 */
if|if
condition|(
name|prof_lookup_global
argument_list|(
name|bt
argument_list|,
name|prof_tdata
argument_list|,
operator|&
name|btkey
argument_list|,
operator|&
name|ctx
argument_list|,
operator|&
name|new_ctx
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Link a prof_thd_cnt_t into ctx for this thread. */
if|if
condition|(
name|ckh_count
argument_list|(
operator|&
name|prof_tdata
operator|->
name|bt2cnt
argument_list|)
operator|==
name|PROF_TCMAX
condition|)
block|{
name|assert
argument_list|(
name|ckh_count
argument_list|(
operator|&
name|prof_tdata
operator|->
name|bt2cnt
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * Flush the least recently used cnt in order to keep 			 * bt2cnt from becoming too large. 			 */
name|ret
operator|.
name|p
operator|=
name|ql_last
argument_list|(
operator|&
name|prof_tdata
operator|->
name|lru_ql
argument_list|,
name|lru_link
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|.
name|v
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ckh_remove
argument_list|(
operator|&
name|prof_tdata
operator|->
name|bt2cnt
argument_list|,
name|ret
operator|.
name|p
operator|->
name|ctx
operator|->
name|bt
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
name|not_reached
argument_list|()
expr_stmt|;
name|ql_remove
argument_list|(
operator|&
name|prof_tdata
operator|->
name|lru_ql
argument_list|,
name|ret
operator|.
name|p
argument_list|,
name|lru_link
argument_list|)
expr_stmt|;
name|prof_ctx_merge
argument_list|(
name|ret
operator|.
name|p
operator|->
name|ctx
argument_list|,
name|ret
operator|.
name|p
argument_list|)
expr_stmt|;
comment|/* ret can now be re-used. */
block|}
else|else
block|{
name|assert
argument_list|(
name|ckh_count
argument_list|(
operator|&
name|prof_tdata
operator|->
name|bt2cnt
argument_list|)
operator|<
name|PROF_TCMAX
argument_list|)
expr_stmt|;
comment|/* Allocate and partially initialize a new cnt. */
name|ret
operator|.
name|v
operator|=
name|imalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|prof_thr_cnt_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|.
name|p
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|new_ctx
condition|)
name|prof_ctx_destroy
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ql_elm_new
argument_list|(
name|ret
operator|.
name|p
argument_list|,
name|cnts_link
argument_list|)
expr_stmt|;
name|ql_elm_new
argument_list|(
name|ret
operator|.
name|p
argument_list|,
name|lru_link
argument_list|)
expr_stmt|;
block|}
comment|/* Finish initializing ret. */
name|ret
operator|.
name|p
operator|->
name|ctx
operator|=
name|ctx
expr_stmt|;
name|ret
operator|.
name|p
operator|->
name|epoch
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ret
operator|.
name|p
operator|->
name|cnts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|prof_cnt_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ckh_insert
argument_list|(
operator|&
name|prof_tdata
operator|->
name|bt2cnt
argument_list|,
name|btkey
argument_list|,
name|ret
operator|.
name|v
argument_list|)
condition|)
block|{
if|if
condition|(
name|new_ctx
condition|)
name|prof_ctx_destroy
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|idalloc
argument_list|(
name|ret
operator|.
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ql_head_insert
argument_list|(
operator|&
name|prof_tdata
operator|->
name|lru_ql
argument_list|,
name|ret
operator|.
name|p
argument_list|,
name|lru_link
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ql_tail_insert
argument_list|(
operator|&
name|ctx
operator|->
name|cnts_ql
argument_list|,
name|ret
operator|.
name|p
argument_list|,
name|cnts_link
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|nlimbo
operator|--
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Move ret to the front of the LRU. */
name|ql_remove
argument_list|(
operator|&
name|prof_tdata
operator|->
name|lru_ql
argument_list|,
name|ret
operator|.
name|p
argument_list|,
name|lru_link
argument_list|)
expr_stmt|;
name|ql_head_insert
argument_list|(
operator|&
name|prof_tdata
operator|->
name|lru_ql
argument_list|,
name|ret
operator|.
name|p
argument_list|,
name|lru_link
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|.
name|p
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_JET
end_ifdef

begin_function
name|size_t
name|prof_bt_count
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|bt_count
decl_stmt|;
name|prof_tdata_t
modifier|*
name|prof_tdata
decl_stmt|;
name|prof_tdata
operator|=
name|prof_tdata_get
argument_list|(
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|prof_tdata
operator|<=
operator|(
name|uintptr_t
operator|)
name|PROF_TDATA_STATE_MAX
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|prof_enter
argument_list|(
name|prof_tdata
argument_list|)
expr_stmt|;
name|bt_count
operator|=
name|ckh_count
argument_list|(
operator|&
name|bt2ctx
argument_list|)
expr_stmt|;
name|prof_leave
argument_list|(
name|prof_tdata
argument_list|)
expr_stmt|;
return|return
operator|(
name|bt_count
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_JET
end_ifdef

begin_undef
undef|#
directive|undef
name|prof_dump_open
end_undef

begin_define
define|#
directive|define
name|prof_dump_open
value|JEMALLOC_N(prof_dump_open_impl)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|prof_dump_open
parameter_list|(
name|bool
name|propagate_err
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|fd
operator|=
name|creat
argument_list|(
name|filename
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
operator|&&
name|propagate_err
operator|==
name|false
condition|)
block|{
name|malloc_printf
argument_list|(
literal|"<jemalloc>: creat(\"%s\"), 0644) failed\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_JET
end_ifdef

begin_undef
undef|#
directive|undef
name|prof_dump_open
end_undef

begin_define
define|#
directive|define
name|prof_dump_open
value|JEMALLOC_N(prof_dump_open)
end_define

begin_decl_stmt
name|prof_dump_open_t
modifier|*
name|prof_dump_open
init|=
name|JEMALLOC_N
argument_list|(
name|prof_dump_open_impl
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|bool
name|prof_dump_flush
parameter_list|(
name|bool
name|propagate_err
parameter_list|)
block|{
name|bool
name|ret
init|=
name|false
decl_stmt|;
name|ssize_t
name|err
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|err
operator|=
name|write
argument_list|(
name|prof_dump_fd
argument_list|,
name|prof_dump_buf
argument_list|,
name|prof_dump_buf_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|propagate_err
operator|==
name|false
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: write() failed during heap "
literal|"profile flush\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|ret
operator|=
name|true
expr_stmt|;
block|}
name|prof_dump_buf_end
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|prof_dump_close
parameter_list|(
name|bool
name|propagate_err
parameter_list|)
block|{
name|bool
name|ret
decl_stmt|;
name|assert
argument_list|(
name|prof_dump_fd
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|prof_dump_flush
argument_list|(
name|propagate_err
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|prof_dump_fd
argument_list|)
expr_stmt|;
name|prof_dump_fd
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|prof_dump_write
parameter_list|(
name|bool
name|propagate_err
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|slen
decl_stmt|,
name|n
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|slen
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|slen
condition|)
block|{
comment|/* Flush the buffer if it is full. */
if|if
condition|(
name|prof_dump_buf_end
operator|==
name|PROF_DUMP_BUFSIZE
condition|)
if|if
condition|(
name|prof_dump_flush
argument_list|(
name|propagate_err
argument_list|)
operator|&&
name|propagate_err
condition|)
return|return
operator|(
name|true
operator|)
return|;
if|if
condition|(
name|prof_dump_buf_end
operator|+
name|slen
operator|<=
name|PROF_DUMP_BUFSIZE
condition|)
block|{
comment|/* Finish writing. */
name|n
operator|=
name|slen
operator|-
name|i
expr_stmt|;
block|}
else|else
block|{
comment|/* Write as much of s as will fit. */
name|n
operator|=
name|PROF_DUMP_BUFSIZE
operator|-
name|prof_dump_buf_end
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|prof_dump_buf
index|[
name|prof_dump_buf_end
index|]
argument_list|,
operator|&
name|s
index|[
name|i
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|prof_dump_buf_end
operator|+=
name|n
expr_stmt|;
name|i
operator|+=
name|n
expr_stmt|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_macro
name|JEMALLOC_ATTR
argument_list|(
argument|format(printf,
literal|2
argument|,
literal|3
argument|)
argument_list|)
end_macro

begin_function
specifier|static
name|bool
name|prof_dump_printf
parameter_list|(
name|bool
name|propagate_err
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|bool
name|ret
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|char
name|buf
index|[
name|PROF_PRINTF_BUFSIZE
index|]
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|malloc_vsnprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|ret
operator|=
name|prof_dump_write
argument_list|(
name|propagate_err
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|prof_dump_ctx_prep
parameter_list|(
name|prof_ctx_t
modifier|*
name|ctx
parameter_list|,
name|prof_cnt_t
modifier|*
name|cnt_all
parameter_list|,
name|size_t
modifier|*
name|leak_nctx
parameter_list|,
name|prof_ctx_list_t
modifier|*
name|ctx_ql
parameter_list|)
block|{
name|prof_thr_cnt_t
modifier|*
name|thr_cnt
decl_stmt|;
name|prof_cnt_t
name|tcnt
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Increment nlimbo so that ctx won't go away before dump. 	 * Additionally, link ctx into the dump list so that it is included in 	 * prof_dump()'s second pass. 	 */
name|ctx
operator|->
name|nlimbo
operator|++
expr_stmt|;
name|ql_tail_insert
argument_list|(
name|ctx_ql
argument_list|,
name|ctx
argument_list|,
name|dump_link
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ctx
operator|->
name|cnt_summed
argument_list|,
operator|&
name|ctx
operator|->
name|cnt_merged
argument_list|,
sizeof|sizeof
argument_list|(
name|prof_cnt_t
argument_list|)
argument_list|)
expr_stmt|;
name|ql_foreach
argument_list|(
argument|thr_cnt
argument_list|,
argument|&ctx->cnts_ql
argument_list|,
argument|cnts_link
argument_list|)
block|{
specifier|volatile
name|unsigned
modifier|*
name|epoch
init|=
operator|&
name|thr_cnt
operator|->
name|epoch
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|unsigned
name|epoch0
init|=
operator|*
name|epoch
decl_stmt|;
comment|/* Make sure epoch is even. */
if|if
condition|(
name|epoch0
operator|&
literal|1U
condition|)
continue|continue;
name|memcpy
argument_list|(
operator|&
name|tcnt
argument_list|,
operator|&
name|thr_cnt
operator|->
name|cnts
argument_list|,
sizeof|sizeof
argument_list|(
name|prof_cnt_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Terminate if epoch didn't change while reading. */
if|if
condition|(
operator|*
name|epoch
operator|==
name|epoch0
condition|)
break|break;
block|}
name|ctx
operator|->
name|cnt_summed
operator|.
name|curobjs
operator|+=
name|tcnt
operator|.
name|curobjs
expr_stmt|;
name|ctx
operator|->
name|cnt_summed
operator|.
name|curbytes
operator|+=
name|tcnt
operator|.
name|curbytes
expr_stmt|;
if|if
condition|(
name|opt_prof_accum
condition|)
block|{
name|ctx
operator|->
name|cnt_summed
operator|.
name|accumobjs
operator|+=
name|tcnt
operator|.
name|accumobjs
expr_stmt|;
name|ctx
operator|->
name|cnt_summed
operator|.
name|accumbytes
operator|+=
name|tcnt
operator|.
name|accumbytes
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ctx
operator|->
name|cnt_summed
operator|.
name|curobjs
operator|!=
literal|0
condition|)
operator|(
operator|*
name|leak_nctx
operator|)
operator|++
expr_stmt|;
comment|/* Add to cnt_all. */
name|cnt_all
operator|->
name|curobjs
operator|+=
name|ctx
operator|->
name|cnt_summed
operator|.
name|curobjs
expr_stmt|;
name|cnt_all
operator|->
name|curbytes
operator|+=
name|ctx
operator|->
name|cnt_summed
operator|.
name|curbytes
expr_stmt|;
if|if
condition|(
name|opt_prof_accum
condition|)
block|{
name|cnt_all
operator|->
name|accumobjs
operator|+=
name|ctx
operator|->
name|cnt_summed
operator|.
name|accumobjs
expr_stmt|;
name|cnt_all
operator|->
name|accumbytes
operator|+=
name|ctx
operator|->
name|cnt_summed
operator|.
name|accumbytes
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|prof_dump_header
parameter_list|(
name|bool
name|propagate_err
parameter_list|,
specifier|const
name|prof_cnt_t
modifier|*
name|cnt_all
parameter_list|)
block|{
if|if
condition|(
name|opt_lg_prof_sample
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prof_dump_printf
argument_list|(
name|propagate_err
argument_list|,
literal|"heap profile: %"
name|PRId64
literal|": %"
name|PRId64
literal|" [%"
name|PRIu64
literal|": %"
name|PRIu64
literal|"] @ heapprofile\n"
argument_list|,
name|cnt_all
operator|->
name|curobjs
argument_list|,
name|cnt_all
operator|->
name|curbytes
argument_list|,
name|cnt_all
operator|->
name|accumobjs
argument_list|,
name|cnt_all
operator|->
name|accumbytes
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|prof_dump_printf
argument_list|(
name|propagate_err
argument_list|,
literal|"heap profile: %"
name|PRId64
literal|": %"
name|PRId64
literal|" [%"
name|PRIu64
literal|": %"
name|PRIu64
literal|"] @ heap_v2/%"
name|PRIu64
literal|"\n"
argument_list|,
name|cnt_all
operator|->
name|curobjs
argument_list|,
name|cnt_all
operator|->
name|curbytes
argument_list|,
name|cnt_all
operator|->
name|accumobjs
argument_list|,
name|cnt_all
operator|->
name|accumbytes
argument_list|,
operator|(
operator|(
name|uint64_t
operator|)
literal|1U
operator|<<
name|opt_lg_prof_sample
operator|)
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|prof_dump_ctx_cleanup_locked
parameter_list|(
name|prof_ctx_t
modifier|*
name|ctx
parameter_list|,
name|prof_ctx_list_t
modifier|*
name|ctx_ql
parameter_list|)
block|{
name|ctx
operator|->
name|nlimbo
operator|--
expr_stmt|;
name|ql_remove
argument_list|(
name|ctx_ql
argument_list|,
name|ctx
argument_list|,
name|dump_link
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|prof_dump_ctx_cleanup
parameter_list|(
name|prof_ctx_t
modifier|*
name|ctx
parameter_list|,
name|prof_ctx_list_t
modifier|*
name|ctx_ql
parameter_list|)
block|{
name|malloc_mutex_lock
argument_list|(
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|prof_dump_ctx_cleanup_locked
argument_list|(
name|ctx
argument_list|,
name|ctx_ql
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|prof_dump_ctx
parameter_list|(
name|bool
name|propagate_err
parameter_list|,
name|prof_ctx_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|prof_bt_t
modifier|*
name|bt
parameter_list|,
name|prof_ctx_list_t
modifier|*
name|ctx_ql
parameter_list|)
block|{
name|bool
name|ret
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
comment|/* 	 * Current statistics can sum to 0 as a result of unmerged per thread 	 * statistics.  Additionally, interval- and growth-triggered dumps can 	 * occur between the time a ctx is created and when its statistics are 	 * filled in.  Avoid dumping any ctx that is an artifact of either 	 * implementation detail. 	 */
name|malloc_mutex_lock
argument_list|(
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|opt_prof_accum
operator|==
name|false
operator|&&
name|ctx
operator|->
name|cnt_summed
operator|.
name|curobjs
operator|==
literal|0
operator|)
operator|||
operator|(
name|opt_prof_accum
operator|&&
name|ctx
operator|->
name|cnt_summed
operator|.
name|accumobjs
operator|==
literal|0
operator|)
condition|)
block|{
name|assert
argument_list|(
name|ctx
operator|->
name|cnt_summed
operator|.
name|curobjs
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ctx
operator|->
name|cnt_summed
operator|.
name|curbytes
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ctx
operator|->
name|cnt_summed
operator|.
name|accumobjs
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ctx
operator|->
name|cnt_summed
operator|.
name|accumbytes
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
if|if
condition|(
name|prof_dump_printf
argument_list|(
name|propagate_err
argument_list|,
literal|"%"
name|PRId64
literal|": %"
name|PRId64
literal|" [%"
name|PRIu64
literal|": %"
name|PRIu64
literal|"] @"
argument_list|,
name|ctx
operator|->
name|cnt_summed
operator|.
name|curobjs
argument_list|,
name|ctx
operator|->
name|cnt_summed
operator|.
name|curbytes
argument_list|,
name|ctx
operator|->
name|cnt_summed
operator|.
name|accumobjs
argument_list|,
name|ctx
operator|->
name|cnt_summed
operator|.
name|accumbytes
argument_list|)
condition|)
block|{
name|ret
operator|=
name|true
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bt
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|prof_dump_printf
argument_list|(
name|propagate_err
argument_list|,
literal|" %#"
name|PRIxPTR
argument_list|,
operator|(
name|uintptr_t
operator|)
name|bt
operator|->
name|vec
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|ret
operator|=
name|true
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
block|}
if|if
condition|(
name|prof_dump_write
argument_list|(
name|propagate_err
argument_list|,
literal|"\n"
argument_list|)
condition|)
block|{
name|ret
operator|=
name|true
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
name|ret
operator|=
name|false
expr_stmt|;
name|label_return
label|:
name|prof_dump_ctx_cleanup_locked
argument_list|(
name|ctx
argument_list|,
name|ctx_ql
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|ctx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|prof_dump_maps
parameter_list|(
name|bool
name|propagate_err
parameter_list|)
block|{
name|bool
name|ret
decl_stmt|;
name|int
name|mfd
decl_stmt|;
name|char
name|filename
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|malloc_snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"/proc/curproc/map"
argument_list|)
expr_stmt|;
else|#
directive|else
name|malloc_snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"/proc/%d/maps"
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mfd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfd
operator|!=
operator|-
literal|1
condition|)
block|{
name|ssize_t
name|nread
decl_stmt|;
if|if
condition|(
name|prof_dump_write
argument_list|(
name|propagate_err
argument_list|,
literal|"\nMAPPED_LIBRARIES:\n"
argument_list|)
operator|&&
name|propagate_err
condition|)
block|{
name|ret
operator|=
name|true
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
name|nread
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|prof_dump_buf_end
operator|+=
name|nread
expr_stmt|;
if|if
condition|(
name|prof_dump_buf_end
operator|==
name|PROF_DUMP_BUFSIZE
condition|)
block|{
comment|/* Make space in prof_dump_buf before read(). */
if|if
condition|(
name|prof_dump_flush
argument_list|(
name|propagate_err
argument_list|)
operator|&&
name|propagate_err
condition|)
block|{
name|ret
operator|=
name|true
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
block|}
name|nread
operator|=
name|read
argument_list|(
name|mfd
argument_list|,
operator|&
name|prof_dump_buf
index|[
name|prof_dump_buf_end
index|]
argument_list|,
name|PROF_DUMP_BUFSIZE
operator|-
name|prof_dump_buf_end
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|nread
operator|>
literal|0
condition|)
do|;
block|}
else|else
block|{
name|ret
operator|=
name|true
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
name|ret
operator|=
name|false
expr_stmt|;
name|label_return
label|:
if|if
condition|(
name|mfd
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|mfd
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|prof_leakcheck
parameter_list|(
specifier|const
name|prof_cnt_t
modifier|*
name|cnt_all
parameter_list|,
name|size_t
name|leak_nctx
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
if|if
condition|(
name|cnt_all
operator|->
name|curbytes
operator|!=
literal|0
condition|)
block|{
name|malloc_printf
argument_list|(
literal|"<jemalloc>: Leak summary: %"
name|PRId64
literal|" byte%s, %"
name|PRId64
literal|" object%s, %zu context%s\n"
argument_list|,
name|cnt_all
operator|->
name|curbytes
argument_list|,
operator|(
name|cnt_all
operator|->
name|curbytes
operator|!=
literal|1
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|cnt_all
operator|->
name|curobjs
argument_list|,
operator|(
name|cnt_all
operator|->
name|curobjs
operator|!=
literal|1
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|leak_nctx
argument_list|,
operator|(
name|leak_nctx
operator|!=
literal|1
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"<jemalloc>: Run pprof on \"%s\" for leak detail\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|prof_dump
parameter_list|(
name|bool
name|propagate_err
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|bool
name|leakcheck
parameter_list|)
block|{
name|prof_tdata_t
modifier|*
name|prof_tdata
decl_stmt|;
name|prof_cnt_t
name|cnt_all
decl_stmt|;
name|size_t
name|tabind
decl_stmt|;
union|union
block|{
name|prof_ctx_t
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|v
decl_stmt|;
block|}
name|ctx
union|;
name|size_t
name|leak_nctx
decl_stmt|;
name|prof_ctx_list_t
name|ctx_ql
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|prof_tdata
operator|=
name|prof_tdata_get
argument_list|(
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|prof_tdata
operator|<=
operator|(
name|uintptr_t
operator|)
name|PROF_TDATA_STATE_MAX
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|prof_dump_mtx
argument_list|)
expr_stmt|;
comment|/* Merge per thread profile stats, and sum them in cnt_all. */
name|memset
argument_list|(
operator|&
name|cnt_all
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|prof_cnt_t
argument_list|)
argument_list|)
expr_stmt|;
name|leak_nctx
operator|=
literal|0
expr_stmt|;
name|ql_new
argument_list|(
operator|&
name|ctx_ql
argument_list|)
expr_stmt|;
name|prof_enter
argument_list|(
name|prof_tdata
argument_list|)
expr_stmt|;
for|for
control|(
name|tabind
operator|=
literal|0
init|;
name|ckh_iter
argument_list|(
operator|&
name|bt2ctx
argument_list|,
operator|&
name|tabind
argument_list|,
name|NULL
argument_list|,
operator|&
name|ctx
operator|.
name|v
argument_list|)
operator|==
name|false
condition|;
control|)
name|prof_dump_ctx_prep
argument_list|(
name|ctx
operator|.
name|p
argument_list|,
operator|&
name|cnt_all
argument_list|,
operator|&
name|leak_nctx
argument_list|,
operator|&
name|ctx_ql
argument_list|)
expr_stmt|;
name|prof_leave
argument_list|(
name|prof_tdata
argument_list|)
expr_stmt|;
comment|/* Create dump file. */
if|if
condition|(
operator|(
name|prof_dump_fd
operator|=
name|prof_dump_open
argument_list|(
name|propagate_err
argument_list|,
name|filename
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|label_open_close_error
goto|;
comment|/* Dump profile header. */
if|if
condition|(
name|prof_dump_header
argument_list|(
name|propagate_err
argument_list|,
operator|&
name|cnt_all
argument_list|)
condition|)
goto|goto
name|label_write_error
goto|;
comment|/* Dump per ctx profile stats. */
while|while
condition|(
operator|(
name|ctx
operator|.
name|p
operator|=
name|ql_first
argument_list|(
operator|&
name|ctx_ql
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|prof_dump_ctx
argument_list|(
name|propagate_err
argument_list|,
name|ctx
operator|.
name|p
argument_list|,
name|ctx
operator|.
name|p
operator|->
name|bt
argument_list|,
operator|&
name|ctx_ql
argument_list|)
condition|)
goto|goto
name|label_write_error
goto|;
block|}
comment|/* Dump /proc/<pid>/maps if possible. */
if|if
condition|(
name|prof_dump_maps
argument_list|(
name|propagate_err
argument_list|)
condition|)
goto|goto
name|label_write_error
goto|;
if|if
condition|(
name|prof_dump_close
argument_list|(
name|propagate_err
argument_list|)
condition|)
goto|goto
name|label_open_close_error
goto|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|prof_dump_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|leakcheck
condition|)
name|prof_leakcheck
argument_list|(
operator|&
name|cnt_all
argument_list|,
name|leak_nctx
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
name|label_write_error
label|:
name|prof_dump_close
argument_list|(
name|propagate_err
argument_list|)
expr_stmt|;
name|label_open_close_error
label|:
while|while
condition|(
operator|(
name|ctx
operator|.
name|p
operator|=
name|ql_first
argument_list|(
operator|&
name|ctx_ql
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|prof_dump_ctx_cleanup
argument_list|(
name|ctx
operator|.
name|p
argument_list|,
operator|&
name|ctx_ql
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|prof_dump_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|DUMP_FILENAME_BUFSIZE
value|(PATH_MAX + 1)
end_define

begin_define
define|#
directive|define
name|VSEQ_INVALID
value|UINT64_C(0xffffffffffffffff)
end_define

begin_function
specifier|static
name|void
name|prof_dump_filename
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|char
name|v
parameter_list|,
name|int64_t
name|vseq
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
if|if
condition|(
name|vseq
operator|!=
name|VSEQ_INVALID
condition|)
block|{
comment|/* "<prefix>.<pid>.<seq>.v<vseq>.heap" */
name|malloc_snprintf
argument_list|(
name|filename
argument_list|,
name|DUMP_FILENAME_BUFSIZE
argument_list|,
literal|"%s.%d.%"
name|PRIu64
literal|".%c%"
name|PRId64
literal|".heap"
argument_list|,
name|opt_prof_prefix
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|,
name|prof_dump_seq
argument_list|,
name|v
argument_list|,
name|vseq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* "<prefix>.<pid>.<seq>.<v>.heap" */
name|malloc_snprintf
argument_list|(
name|filename
argument_list|,
name|DUMP_FILENAME_BUFSIZE
argument_list|,
literal|"%s.%d.%"
name|PRIu64
literal|".%c.heap"
argument_list|,
name|opt_prof_prefix
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|,
name|prof_dump_seq
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
name|prof_dump_seq
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|prof_fdump
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|filename
index|[
name|DUMP_FILENAME_BUFSIZE
index|]
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
if|if
condition|(
name|prof_booted
operator|==
name|false
condition|)
return|return;
if|if
condition|(
name|opt_prof_final
operator|&&
name|opt_prof_prefix
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|malloc_mutex_lock
argument_list|(
operator|&
name|prof_dump_seq_mtx
argument_list|)
expr_stmt|;
name|prof_dump_filename
argument_list|(
name|filename
argument_list|,
literal|'f'
argument_list|,
name|VSEQ_INVALID
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|prof_dump_seq_mtx
argument_list|)
expr_stmt|;
name|prof_dump
argument_list|(
name|false
argument_list|,
name|filename
argument_list|,
name|opt_prof_leak
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|prof_idump
parameter_list|(
name|void
parameter_list|)
block|{
name|prof_tdata_t
modifier|*
name|prof_tdata
decl_stmt|;
name|char
name|filename
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
if|if
condition|(
name|prof_booted
operator|==
name|false
condition|)
return|return;
name|prof_tdata
operator|=
name|prof_tdata_get
argument_list|(
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|prof_tdata
operator|<=
operator|(
name|uintptr_t
operator|)
name|PROF_TDATA_STATE_MAX
condition|)
return|return;
if|if
condition|(
name|prof_tdata
operator|->
name|enq
condition|)
block|{
name|prof_tdata
operator|->
name|enq_idump
operator|=
name|true
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|opt_prof_prefix
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|malloc_mutex_lock
argument_list|(
operator|&
name|prof_dump_seq_mtx
argument_list|)
expr_stmt|;
name|prof_dump_filename
argument_list|(
name|filename
argument_list|,
literal|'i'
argument_list|,
name|prof_dump_iseq
argument_list|)
expr_stmt|;
name|prof_dump_iseq
operator|++
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|prof_dump_seq_mtx
argument_list|)
expr_stmt|;
name|prof_dump
argument_list|(
name|false
argument_list|,
name|filename
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|bool
name|prof_mdump
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|char
name|filename_buf
index|[
name|DUMP_FILENAME_BUFSIZE
index|]
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_prof
operator|==
name|false
operator|||
name|prof_booted
operator|==
name|false
condition|)
return|return
operator|(
name|true
operator|)
return|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
block|{
comment|/* No filename specified, so automatically generate one. */
if|if
condition|(
name|opt_prof_prefix
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|prof_dump_seq_mtx
argument_list|)
expr_stmt|;
name|prof_dump_filename
argument_list|(
name|filename_buf
argument_list|,
literal|'m'
argument_list|,
name|prof_dump_mseq
argument_list|)
expr_stmt|;
name|prof_dump_mseq
operator|++
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|prof_dump_seq_mtx
argument_list|)
expr_stmt|;
name|filename
operator|=
name|filename_buf
expr_stmt|;
block|}
return|return
operator|(
name|prof_dump
argument_list|(
name|true
argument_list|,
name|filename
argument_list|,
name|false
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|prof_gdump
parameter_list|(
name|void
parameter_list|)
block|{
name|prof_tdata_t
modifier|*
name|prof_tdata
decl_stmt|;
name|char
name|filename
index|[
name|DUMP_FILENAME_BUFSIZE
index|]
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
if|if
condition|(
name|prof_booted
operator|==
name|false
condition|)
return|return;
name|prof_tdata
operator|=
name|prof_tdata_get
argument_list|(
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|prof_tdata
operator|<=
operator|(
name|uintptr_t
operator|)
name|PROF_TDATA_STATE_MAX
condition|)
return|return;
if|if
condition|(
name|prof_tdata
operator|->
name|enq
condition|)
block|{
name|prof_tdata
operator|->
name|enq_gdump
operator|=
name|true
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|opt_prof_prefix
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|malloc_mutex_lock
argument_list|(
operator|&
name|prof_dump_seq_mtx
argument_list|)
expr_stmt|;
name|prof_dump_filename
argument_list|(
name|filename
argument_list|,
literal|'u'
argument_list|,
name|prof_dump_useq
argument_list|)
expr_stmt|;
name|prof_dump_useq
operator|++
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|prof_dump_seq_mtx
argument_list|)
expr_stmt|;
name|prof_dump
argument_list|(
name|false
argument_list|,
name|filename
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|prof_bt_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|size_t
name|r_hash
index|[
literal|2
index|]
parameter_list|)
block|{
name|prof_bt_t
modifier|*
name|bt
init|=
operator|(
name|prof_bt_t
operator|*
operator|)
name|key
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|hash
argument_list|(
name|bt
operator|->
name|vec
argument_list|,
name|bt
operator|->
name|len
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
literal|0x94122f33U
argument_list|,
name|r_hash
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|prof_bt_keycomp
parameter_list|(
specifier|const
name|void
modifier|*
name|k1
parameter_list|,
specifier|const
name|void
modifier|*
name|k2
parameter_list|)
block|{
specifier|const
name|prof_bt_t
modifier|*
name|bt1
init|=
operator|(
name|prof_bt_t
operator|*
operator|)
name|k1
decl_stmt|;
specifier|const
name|prof_bt_t
modifier|*
name|bt2
init|=
operator|(
name|prof_bt_t
operator|*
operator|)
name|k2
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt1
operator|->
name|len
operator|!=
name|bt2
operator|->
name|len
condition|)
return|return
operator|(
name|false
operator|)
return|;
return|return
operator|(
name|memcmp
argument_list|(
name|bt1
operator|->
name|vec
argument_list|,
name|bt2
operator|->
name|vec
argument_list|,
name|bt1
operator|->
name|len
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|prof_tdata_t
modifier|*
name|prof_tdata_init
parameter_list|(
name|void
parameter_list|)
block|{
name|prof_tdata_t
modifier|*
name|prof_tdata
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
comment|/* Initialize an empty cache for this thread. */
name|prof_tdata
operator|=
operator|(
name|prof_tdata_t
operator|*
operator|)
name|imalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|prof_tdata_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prof_tdata
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|ckh_new
argument_list|(
operator|&
name|prof_tdata
operator|->
name|bt2cnt
argument_list|,
name|PROF_CKH_MINITEMS
argument_list|,
name|prof_bt_hash
argument_list|,
name|prof_bt_keycomp
argument_list|)
condition|)
block|{
name|idalloc
argument_list|(
name|prof_tdata
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ql_new
argument_list|(
operator|&
name|prof_tdata
operator|->
name|lru_ql
argument_list|)
expr_stmt|;
name|prof_tdata
operator|->
name|vec
operator|=
name|imalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
name|PROF_BT_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|prof_tdata
operator|->
name|vec
operator|==
name|NULL
condition|)
block|{
name|ckh_delete
argument_list|(
operator|&
name|prof_tdata
operator|->
name|bt2cnt
argument_list|)
expr_stmt|;
name|idalloc
argument_list|(
name|prof_tdata
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|prof_tdata
operator|->
name|prng_state
operator|=
literal|0
expr_stmt|;
name|prof_tdata
operator|->
name|threshold
operator|=
literal|0
expr_stmt|;
name|prof_tdata
operator|->
name|accum
operator|=
literal|0
expr_stmt|;
name|prof_tdata
operator|->
name|enq
operator|=
name|false
expr_stmt|;
name|prof_tdata
operator|->
name|enq_idump
operator|=
name|false
expr_stmt|;
name|prof_tdata
operator|->
name|enq_gdump
operator|=
name|false
expr_stmt|;
name|prof_tdata_tsd_set
argument_list|(
operator|&
name|prof_tdata
argument_list|)
expr_stmt|;
return|return
operator|(
name|prof_tdata
operator|)
return|;
block|}
end_function

begin_function
name|void
name|prof_tdata_cleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|prof_thr_cnt_t
modifier|*
name|cnt
decl_stmt|;
name|prof_tdata_t
modifier|*
name|prof_tdata
init|=
operator|*
operator|(
name|prof_tdata_t
operator|*
operator|*
operator|)
name|arg
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
if|if
condition|(
name|prof_tdata
operator|==
name|PROF_TDATA_STATE_REINCARNATED
condition|)
block|{
comment|/* 		 * Another destructor deallocated memory after this destructor 		 * was called.  Reset prof_tdata to PROF_TDATA_STATE_PURGATORY 		 * in order to receive another callback. 		 */
name|prof_tdata
operator|=
name|PROF_TDATA_STATE_PURGATORY
expr_stmt|;
name|prof_tdata_tsd_set
argument_list|(
operator|&
name|prof_tdata
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prof_tdata
operator|==
name|PROF_TDATA_STATE_PURGATORY
condition|)
block|{
comment|/* 		 * The previous time this destructor was called, we set the key 		 * to PROF_TDATA_STATE_PURGATORY so that other destructors 		 * wouldn't cause re-creation of the prof_tdata.  This time, do 		 * nothing, so that the destructor will not be called again. 		 */
block|}
elseif|else
if|if
condition|(
name|prof_tdata
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Delete the hash table.  All of its contents can still be 		 * iterated over via the LRU. 		 */
name|ckh_delete
argument_list|(
operator|&
name|prof_tdata
operator|->
name|bt2cnt
argument_list|)
expr_stmt|;
comment|/* 		 * Iteratively merge cnt's into the global stats and delete 		 * them. 		 */
while|while
condition|(
operator|(
name|cnt
operator|=
name|ql_last
argument_list|(
operator|&
name|prof_tdata
operator|->
name|lru_ql
argument_list|,
name|lru_link
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ql_remove
argument_list|(
operator|&
name|prof_tdata
operator|->
name|lru_ql
argument_list|,
name|cnt
argument_list|,
name|lru_link
argument_list|)
expr_stmt|;
name|prof_ctx_merge
argument_list|(
name|cnt
operator|->
name|ctx
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|idalloc
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
block|}
name|idalloc
argument_list|(
name|prof_tdata
operator|->
name|vec
argument_list|)
expr_stmt|;
name|idalloc
argument_list|(
name|prof_tdata
argument_list|)
expr_stmt|;
name|prof_tdata
operator|=
name|PROF_TDATA_STATE_PURGATORY
expr_stmt|;
name|prof_tdata_tsd_set
argument_list|(
operator|&
name|prof_tdata
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|prof_boot0
parameter_list|(
name|void
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|opt_prof_prefix
argument_list|,
name|PROF_PREFIX_DEFAULT
argument_list|,
sizeof|sizeof
argument_list|(
name|PROF_PREFIX_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|prof_boot1
parameter_list|(
name|void
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
comment|/* 	 * opt_prof and prof_promote must be in their final state before any 	 * arenas are initialized, so this function must be executed early. 	 */
if|if
condition|(
name|opt_prof_leak
operator|&&
name|opt_prof
operator|==
name|false
condition|)
block|{
comment|/* 		 * Enable opt_prof, but in such a way that profiles are never 		 * automatically dumped. 		 */
name|opt_prof
operator|=
name|true
expr_stmt|;
name|opt_prof_gdump
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt_prof
condition|)
block|{
if|if
condition|(
name|opt_lg_prof_interval
operator|>=
literal|0
condition|)
block|{
name|prof_interval
operator|=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
literal|1U
operator|)
operator|<<
name|opt_lg_prof_interval
operator|)
expr_stmt|;
block|}
block|}
name|prof_promote
operator|=
operator|(
name|opt_prof
operator|&&
name|opt_lg_prof_sample
operator|>
name|LG_PAGE
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|prof_boot2
parameter_list|(
name|void
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_prof
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
name|ckh_new
argument_list|(
operator|&
name|bt2ctx
argument_list|,
name|PROF_CKH_MINITEMS
argument_list|,
name|prof_bt_hash
argument_list|,
name|prof_bt_keycomp
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|bt2ctx_mtx
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
if|if
condition|(
name|prof_tdata_tsd_boot
argument_list|()
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Error in pthread_key_create()\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|prof_dump_seq_mtx
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|prof_dump_mtx
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
if|if
condition|(
name|atexit
argument_list|(
name|prof_fdump
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Error in atexit()\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|ctx_locks
operator|=
operator|(
name|malloc_mutex_t
operator|*
operator|)
name|base_alloc
argument_list|(
name|PROF_NCTX_LOCKS
operator|*
sizeof|sizeof
argument_list|(
name|malloc_mutex_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx_locks
operator|==
name|NULL
condition|)
return|return
operator|(
name|true
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PROF_NCTX_LOCKS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|ctx_locks
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|JEMALLOC_PROF_LIBGCC
comment|/* 	 * Cause the backtracing machinery to allocate its internal state 	 * before enabling profiling. 	 */
name|_Unwind_Backtrace
argument_list|(
name|prof_unwind_init_callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|prof_booted
operator|=
name|true
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
name|void
name|prof_prefork
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|opt_prof
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
name|malloc_mutex_prefork
argument_list|(
operator|&
name|bt2ctx_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_prefork
argument_list|(
operator|&
name|prof_dump_seq_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PROF_NCTX_LOCKS
condition|;
name|i
operator|++
control|)
name|malloc_mutex_prefork
argument_list|(
operator|&
name|ctx_locks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|prof_postfork_parent
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|opt_prof
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PROF_NCTX_LOCKS
condition|;
name|i
operator|++
control|)
name|malloc_mutex_postfork_parent
argument_list|(
operator|&
name|ctx_locks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_parent
argument_list|(
operator|&
name|prof_dump_seq_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_parent
argument_list|(
operator|&
name|bt2ctx_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|prof_postfork_child
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|opt_prof
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PROF_NCTX_LOCKS
condition|;
name|i
operator|++
control|)
name|malloc_mutex_postfork_child
argument_list|(
operator|&
name|ctx_locks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_child
argument_list|(
operator|&
name|prof_dump_seq_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_child
argument_list|(
operator|&
name|bt2ctx_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

end_unit

