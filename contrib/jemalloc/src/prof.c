begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|JEMALLOC_PROF_C_
end_define

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_preamble.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_internal_includes.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/assert.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/ckh.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/hash.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/malloc_io.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/mutex.h"
end_include

begin_comment
comment|/******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_PROF_LIBUNWIND
end_ifdef

begin_define
define|#
directive|define
name|UNW_LOCAL_ONLY
end_define

begin_include
include|#
directive|include
file|<libunwind.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_PROF_LIBGCC
end_ifdef

begin_comment
comment|/*  * We have a circular dependency -- jemalloc_internal.h tells us if we should  * use libgcc's unwinding functionality, but after we've included that, we've  * already hooked _Unwind_Backtrace.  We'll temporarily disable hooking.  */
end_comment

begin_undef
undef|#
directive|undef
name|_Unwind_Backtrace
end_undef

begin_include
include|#
directive|include
file|<unwind.h>
end_include

begin_define
define|#
directive|define
name|_Unwind_Backtrace
value|JEMALLOC_HOOK(_Unwind_Backtrace, hooks_libc_hook)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/* Data. */
end_comment

begin_decl_stmt
name|bool
name|opt_prof
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_prof_active
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_prof_thread_active_init
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|opt_lg_prof_sample
init|=
name|LG_PROF_SAMPLE_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ssize_t
name|opt_lg_prof_interval
init|=
name|LG_PROF_INTERVAL_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_prof_gdump
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_prof_final
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_prof_leak
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_prof_accum
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|opt_prof_prefix
index|[
comment|/* Minimize memory bloat for non-prof builds. */
ifdef|#
directive|ifdef
name|JEMALLOC_PROF
name|PATH_MAX
operator|+
endif|#
directive|endif
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialized as opt_prof_active, and accessed via  * prof_active_[gs]et{_unlocked,}().  */
end_comment

begin_decl_stmt
name|bool
name|prof_active
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|prof_active_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialized as opt_prof_thread_active_init, and accessed via  * prof_thread_active_init_[gs]et().  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|prof_thread_active_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|prof_thread_active_init_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialized as opt_prof_gdump, and accessed via  * prof_gdump_[gs]et{_unlocked,}().  */
end_comment

begin_decl_stmt
name|bool
name|prof_gdump_val
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|prof_gdump_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|prof_interval
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|lg_prof_sample
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Table of mutexes that are shared among gctx's.  These are leaf locks, so  * there is no problem with using them for more than one gctx at the same time.  * The primary motivation for this sharing though is that gctx's are ephemeral,  * and destroying mutexes causes complications for systems that allocate when  * creating/destroying mutexes.  */
end_comment

begin_decl_stmt
specifier|static
name|malloc_mutex_t
modifier|*
name|gctx_locks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|atomic_u_t
name|cum_gctxs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Atomic counter. */
end_comment

begin_comment
comment|/*  * Table of mutexes that are shared among tdata's.  No operations require  * holding multiple tdata locks, so there is no problem with using them for more  * than one tdata at the same time, even though a gctx lock may be acquired  * while holding a tdata lock.  */
end_comment

begin_decl_stmt
specifier|static
name|malloc_mutex_t
modifier|*
name|tdata_locks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Global hash of (prof_bt_t *)-->(prof_gctx_t *).  This is the master data  * structure that knows about all backtraces currently captured.  */
end_comment

begin_decl_stmt
specifier|static
name|ckh_t
name|bt2gctx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non static to enable profiling. */
end_comment

begin_decl_stmt
name|malloc_mutex_t
name|bt2gctx_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Tree of all extant prof_tdata_t structures, regardless of state,  * {attached,detached,expired}.  */
end_comment

begin_decl_stmt
specifier|static
name|prof_tdata_tree_t
name|tdatas
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|tdatas_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|next_thr_uid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|next_thr_uid_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|prof_dump_seq_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|prof_dump_seq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|prof_dump_iseq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|prof_dump_mseq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|prof_dump_useq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This buffer is rather large for stack allocation, so use a single buffer for  * all profile dumps.  */
end_comment

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|prof_dump_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|prof_dump_buf
index|[
comment|/* Minimize memory bloat for non-prof builds. */
ifdef|#
directive|ifdef
name|JEMALLOC_PROF
name|PROF_DUMP_BUFSIZE
else|#
directive|else
literal|1
endif|#
directive|endif
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|prof_dump_buf_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|prof_dump_fd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do not dump any profiles until bootstrapping is complete. */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|prof_booted
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Function prototypes for static functions that are referenced prior to  * definition.  */
end_comment

begin_function_decl
specifier|static
name|bool
name|prof_tctx_should_destroy
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prof_tctx_destroy
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|prof_tdata_should_destroy
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|prof_tdata_t
modifier|*
name|tdata
parameter_list|,
name|bool
name|even_if_attached
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prof_tdata_destroy
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|prof_tdata_t
modifier|*
name|tdata
parameter_list|,
name|bool
name|even_if_attached
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|prof_thread_name_alloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
specifier|const
name|char
modifier|*
name|thread_name
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/* Red-black trees. */
end_comment

begin_function
specifier|static
name|int
name|prof_tctx_comp
parameter_list|(
specifier|const
name|prof_tctx_t
modifier|*
name|a
parameter_list|,
specifier|const
name|prof_tctx_t
modifier|*
name|b
parameter_list|)
block|{
name|uint64_t
name|a_thr_uid
init|=
name|a
operator|->
name|thr_uid
decl_stmt|;
name|uint64_t
name|b_thr_uid
init|=
name|b
operator|->
name|thr_uid
decl_stmt|;
name|int
name|ret
init|=
operator|(
name|a_thr_uid
operator|>
name|b_thr_uid
operator|)
operator|-
operator|(
name|a_thr_uid
operator|<
name|b_thr_uid
operator|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|uint64_t
name|a_thr_discrim
init|=
name|a
operator|->
name|thr_discrim
decl_stmt|;
name|uint64_t
name|b_thr_discrim
init|=
name|b
operator|->
name|thr_discrim
decl_stmt|;
name|ret
operator|=
operator|(
name|a_thr_discrim
operator|>
name|b_thr_discrim
operator|)
operator|-
operator|(
name|a_thr_discrim
operator|<
name|b_thr_discrim
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|uint64_t
name|a_tctx_uid
init|=
name|a
operator|->
name|tctx_uid
decl_stmt|;
name|uint64_t
name|b_tctx_uid
init|=
name|b
operator|->
name|tctx_uid
decl_stmt|;
name|ret
operator|=
operator|(
name|a_tctx_uid
operator|>
name|b_tctx_uid
operator|)
operator|-
operator|(
name|a_tctx_uid
operator|<
name|b_tctx_uid
operator|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_macro
name|rb_gen
argument_list|(
argument|static UNUSED
argument_list|,
argument|tctx_tree_
argument_list|,
argument|prof_tctx_tree_t
argument_list|,
argument|prof_tctx_t
argument_list|,
argument|tctx_link
argument_list|,
argument|prof_tctx_comp
argument_list|)
end_macro

begin_function
specifier|static
name|int
name|prof_gctx_comp
parameter_list|(
specifier|const
name|prof_gctx_t
modifier|*
name|a
parameter_list|,
specifier|const
name|prof_gctx_t
modifier|*
name|b
parameter_list|)
block|{
name|unsigned
name|a_len
init|=
name|a
operator|->
name|bt
operator|.
name|len
decl_stmt|;
name|unsigned
name|b_len
init|=
name|b
operator|->
name|bt
operator|.
name|len
decl_stmt|;
name|unsigned
name|comp_len
init|=
operator|(
name|a_len
operator|<
name|b_len
operator|)
condition|?
name|a_len
else|:
name|b_len
decl_stmt|;
name|int
name|ret
init|=
name|memcmp
argument_list|(
name|a
operator|->
name|bt
operator|.
name|vec
argument_list|,
name|b
operator|->
name|bt
operator|.
name|vec
argument_list|,
name|comp_len
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
operator|(
name|a_len
operator|>
name|b_len
operator|)
operator|-
operator|(
name|a_len
operator|<
name|b_len
operator|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_macro
name|rb_gen
argument_list|(
argument|static UNUSED
argument_list|,
argument|gctx_tree_
argument_list|,
argument|prof_gctx_tree_t
argument_list|,
argument|prof_gctx_t
argument_list|,
argument|dump_link
argument_list|,
argument|prof_gctx_comp
argument_list|)
end_macro

begin_function
specifier|static
name|int
name|prof_tdata_comp
parameter_list|(
specifier|const
name|prof_tdata_t
modifier|*
name|a
parameter_list|,
specifier|const
name|prof_tdata_t
modifier|*
name|b
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|uint64_t
name|a_uid
init|=
name|a
operator|->
name|thr_uid
decl_stmt|;
name|uint64_t
name|b_uid
init|=
name|b
operator|->
name|thr_uid
decl_stmt|;
name|ret
operator|=
operator|(
operator|(
name|a_uid
operator|>
name|b_uid
operator|)
operator|-
operator|(
name|a_uid
operator|<
name|b_uid
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|uint64_t
name|a_discrim
init|=
name|a
operator|->
name|thr_discrim
decl_stmt|;
name|uint64_t
name|b_discrim
init|=
name|b
operator|->
name|thr_discrim
decl_stmt|;
name|ret
operator|=
operator|(
operator|(
name|a_discrim
operator|>
name|b_discrim
operator|)
operator|-
operator|(
name|a_discrim
operator|<
name|b_discrim
operator|)
operator|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_macro
name|rb_gen
argument_list|(
argument|static UNUSED
argument_list|,
argument|tdata_tree_
argument_list|,
argument|prof_tdata_tree_t
argument_list|,
argument|prof_tdata_t
argument_list|,
argument|tdata_link
argument_list|,
argument|prof_tdata_comp
argument_list|)
end_macro

begin_comment
comment|/******************************************************************************/
end_comment

begin_function
name|void
name|prof_alloc_rollback
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|,
name|bool
name|updated
parameter_list|)
block|{
name|prof_tdata_t
modifier|*
name|tdata
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
if|if
condition|(
name|updated
condition|)
block|{
comment|/* 		 * Compute a new sample threshold.  This isn't very important in 		 * practice, because this function is rarely executed, so the 		 * potential for sample bias is minimal except in contrived 		 * programs. 		 */
name|tdata
operator|=
name|prof_tdata_get
argument_list|(
name|tsd
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdata
operator|!=
name|NULL
condition|)
block|{
name|prof_sample_threshold_update
argument_list|(
name|tdata
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|tctx
operator|>
operator|(
name|uintptr_t
operator|)
literal|1U
condition|)
block|{
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tctx
operator|->
name|tdata
operator|->
name|lock
argument_list|)
expr_stmt|;
name|tctx
operator|->
name|prepared
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|prof_tctx_should_destroy
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tctx
argument_list|)
condition|)
block|{
name|prof_tctx_destroy
argument_list|(
name|tsd
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tctx
operator|->
name|tdata
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|prof_malloc_sample_object
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|)
block|{
name|prof_tctx_set
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|,
name|NULL
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
name|tctx
operator|->
name|tdata
operator|->
name|lock
argument_list|)
expr_stmt|;
name|tctx
operator|->
name|cnts
operator|.
name|curobjs
operator|++
expr_stmt|;
name|tctx
operator|->
name|cnts
operator|.
name|curbytes
operator|+=
name|usize
expr_stmt|;
if|if
condition|(
name|opt_prof_accum
condition|)
block|{
name|tctx
operator|->
name|cnts
operator|.
name|accumobjs
operator|++
expr_stmt|;
name|tctx
operator|->
name|cnts
operator|.
name|accumbytes
operator|+=
name|usize
expr_stmt|;
block|}
name|tctx
operator|->
name|prepared
operator|=
name|false
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
name|tctx
operator|->
name|tdata
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|prof_free_sampled_object
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|)
block|{
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tctx
operator|->
name|tdata
operator|->
name|lock
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tctx
operator|->
name|cnts
operator|.
name|curobjs
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tctx
operator|->
name|cnts
operator|.
name|curbytes
operator|>=
name|usize
argument_list|)
expr_stmt|;
name|tctx
operator|->
name|cnts
operator|.
name|curobjs
operator|--
expr_stmt|;
name|tctx
operator|->
name|cnts
operator|.
name|curbytes
operator|-=
name|usize
expr_stmt|;
if|if
condition|(
name|prof_tctx_should_destroy
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tctx
argument_list|)
condition|)
block|{
name|prof_tctx_destroy
argument_list|(
name|tsd
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tctx
operator|->
name|tdata
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|bt_init
parameter_list|(
name|prof_bt_t
modifier|*
name|bt
parameter_list|,
name|void
modifier|*
modifier|*
name|vec
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|bt
operator|->
name|vec
operator|=
name|vec
expr_stmt|;
name|bt
operator|->
name|len
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|prof_enter
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|prof_tdata_t
modifier|*
name|tdata
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tdata
operator|==
name|prof_tdata_get
argument_list|(
name|tsd
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdata
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
operator|!
name|tdata
operator|->
name|enq
argument_list|)
expr_stmt|;
name|tdata
operator|->
name|enq
operator|=
name|true
expr_stmt|;
block|}
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|bt2gctx_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|prof_leave
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|prof_tdata_t
modifier|*
name|tdata
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tdata
operator|==
name|prof_tdata_get
argument_list|(
name|tsd
argument_list|,
name|false
argument_list|)
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|bt2gctx_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdata
operator|!=
name|NULL
condition|)
block|{
name|bool
name|idump
decl_stmt|,
name|gdump
decl_stmt|;
name|assert
argument_list|(
name|tdata
operator|->
name|enq
argument_list|)
expr_stmt|;
name|tdata
operator|->
name|enq
operator|=
name|false
expr_stmt|;
name|idump
operator|=
name|tdata
operator|->
name|enq_idump
expr_stmt|;
name|tdata
operator|->
name|enq_idump
operator|=
name|false
expr_stmt|;
name|gdump
operator|=
name|tdata
operator|->
name|enq_gdump
expr_stmt|;
name|tdata
operator|->
name|enq_gdump
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|idump
condition|)
block|{
name|prof_idump
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gdump
condition|)
block|{
name|prof_gdump
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_PROF_LIBUNWIND
end_ifdef

begin_function
name|void
name|prof_backtrace
parameter_list|(
name|prof_bt_t
modifier|*
name|bt
parameter_list|)
block|{
name|int
name|nframes
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|bt
operator|->
name|len
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|bt
operator|->
name|vec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|nframes
operator|=
name|unw_backtrace
argument_list|(
name|bt
operator|->
name|vec
argument_list|,
name|PROF_BT_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|nframes
operator|<=
literal|0
condition|)
block|{
return|return;
block|}
name|bt
operator|->
name|len
operator|=
name|nframes
expr_stmt|;
block|}
end_function

begin_elif
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|JEMALLOC_PROF_LIBGCC
argument_list|)
operator|)
end_elif

begin_function
specifier|static
name|_Unwind_Reason_Code
name|prof_unwind_init_callback
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
return|return
name|_URC_NO_REASON
return|;
block|}
end_function

begin_function
specifier|static
name|_Unwind_Reason_Code
name|prof_unwind_callback
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|prof_unwind_data_t
modifier|*
name|data
init|=
operator|(
name|prof_unwind_data_t
operator|*
operator|)
name|arg
decl_stmt|;
name|void
modifier|*
name|ip
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|(
name|void
operator|*
operator|)
name|_Unwind_GetIP
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
block|{
return|return
name|_URC_END_OF_STACK
return|;
block|}
name|data
operator|->
name|bt
operator|->
name|vec
index|[
name|data
operator|->
name|bt
operator|->
name|len
index|]
operator|=
name|ip
expr_stmt|;
name|data
operator|->
name|bt
operator|->
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|bt
operator|->
name|len
operator|==
name|data
operator|->
name|max
condition|)
block|{
return|return
name|_URC_END_OF_STACK
return|;
block|}
return|return
name|_URC_NO_REASON
return|;
block|}
end_function

begin_function
name|void
name|prof_backtrace
parameter_list|(
name|prof_bt_t
modifier|*
name|bt
parameter_list|)
block|{
name|prof_unwind_data_t
name|data
init|=
block|{
name|bt
block|,
name|PROF_BT_MAX
block|}
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|_Unwind_Backtrace
argument_list|(
name|prof_unwind_callback
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_elif
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|JEMALLOC_PROF_GCC
argument_list|)
operator|)
end_elif

begin_function
name|void
name|prof_backtrace
parameter_list|(
name|prof_bt_t
modifier|*
name|bt
parameter_list|)
block|{
define|#
directive|define
name|BT_FRAME
parameter_list|(
name|i
parameter_list|)
define|\
value|if ((i)< PROF_BT_MAX) {					\ 		void *p;						\ 		if (__builtin_frame_address(i) == 0) {			\ 			return;						\ 		}							\ 		p = __builtin_return_address(i);			\ 		if (p == NULL) {					\ 			return;						\ 		}							\ 		bt->vec[(i)] = p;					\ 		bt->len = (i) + 1;					\ 	} else {							\ 		return;							\ 	}
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|BT_FRAME
argument_list|(
literal|0
argument_list|)
name|BT_FRAME
argument_list|(
literal|1
argument_list|)
name|BT_FRAME
argument_list|(
literal|2
argument_list|)
name|BT_FRAME
argument_list|(
literal|3
argument_list|)
name|BT_FRAME
argument_list|(
literal|4
argument_list|)
name|BT_FRAME
argument_list|(
literal|5
argument_list|)
name|BT_FRAME
argument_list|(
literal|6
argument_list|)
name|BT_FRAME
argument_list|(
literal|7
argument_list|)
name|BT_FRAME
argument_list|(
literal|8
argument_list|)
name|BT_FRAME
argument_list|(
literal|9
argument_list|)
name|BT_FRAME
argument_list|(
literal|10
argument_list|)
name|BT_FRAME
argument_list|(
literal|11
argument_list|)
name|BT_FRAME
argument_list|(
literal|12
argument_list|)
name|BT_FRAME
argument_list|(
literal|13
argument_list|)
name|BT_FRAME
argument_list|(
literal|14
argument_list|)
name|BT_FRAME
argument_list|(
literal|15
argument_list|)
name|BT_FRAME
argument_list|(
literal|16
argument_list|)
name|BT_FRAME
argument_list|(
literal|17
argument_list|)
name|BT_FRAME
argument_list|(
literal|18
argument_list|)
name|BT_FRAME
argument_list|(
literal|19
argument_list|)
name|BT_FRAME
argument_list|(
literal|20
argument_list|)
name|BT_FRAME
argument_list|(
literal|21
argument_list|)
name|BT_FRAME
argument_list|(
literal|22
argument_list|)
name|BT_FRAME
argument_list|(
literal|23
argument_list|)
name|BT_FRAME
argument_list|(
literal|24
argument_list|)
name|BT_FRAME
argument_list|(
literal|25
argument_list|)
name|BT_FRAME
argument_list|(
literal|26
argument_list|)
name|BT_FRAME
argument_list|(
literal|27
argument_list|)
name|BT_FRAME
argument_list|(
literal|28
argument_list|)
name|BT_FRAME
argument_list|(
literal|29
argument_list|)
name|BT_FRAME
argument_list|(
literal|30
argument_list|)
name|BT_FRAME
argument_list|(
literal|31
argument_list|)
name|BT_FRAME
argument_list|(
literal|32
argument_list|)
name|BT_FRAME
argument_list|(
literal|33
argument_list|)
name|BT_FRAME
argument_list|(
literal|34
argument_list|)
name|BT_FRAME
argument_list|(
literal|35
argument_list|)
name|BT_FRAME
argument_list|(
literal|36
argument_list|)
name|BT_FRAME
argument_list|(
literal|37
argument_list|)
name|BT_FRAME
argument_list|(
literal|38
argument_list|)
name|BT_FRAME
argument_list|(
literal|39
argument_list|)
name|BT_FRAME
argument_list|(
literal|40
argument_list|)
name|BT_FRAME
argument_list|(
literal|41
argument_list|)
name|BT_FRAME
argument_list|(
literal|42
argument_list|)
name|BT_FRAME
argument_list|(
literal|43
argument_list|)
name|BT_FRAME
argument_list|(
literal|44
argument_list|)
name|BT_FRAME
argument_list|(
literal|45
argument_list|)
name|BT_FRAME
argument_list|(
literal|46
argument_list|)
name|BT_FRAME
argument_list|(
literal|47
argument_list|)
name|BT_FRAME
argument_list|(
literal|48
argument_list|)
name|BT_FRAME
argument_list|(
literal|49
argument_list|)
name|BT_FRAME
argument_list|(
literal|50
argument_list|)
name|BT_FRAME
argument_list|(
literal|51
argument_list|)
name|BT_FRAME
argument_list|(
literal|52
argument_list|)
name|BT_FRAME
argument_list|(
literal|53
argument_list|)
name|BT_FRAME
argument_list|(
literal|54
argument_list|)
name|BT_FRAME
argument_list|(
literal|55
argument_list|)
name|BT_FRAME
argument_list|(
literal|56
argument_list|)
name|BT_FRAME
argument_list|(
literal|57
argument_list|)
name|BT_FRAME
argument_list|(
literal|58
argument_list|)
name|BT_FRAME
argument_list|(
literal|59
argument_list|)
name|BT_FRAME
argument_list|(
literal|60
argument_list|)
name|BT_FRAME
argument_list|(
literal|61
argument_list|)
name|BT_FRAME
argument_list|(
literal|62
argument_list|)
name|BT_FRAME
argument_list|(
literal|63
argument_list|)
name|BT_FRAME
argument_list|(
literal|64
argument_list|)
name|BT_FRAME
argument_list|(
literal|65
argument_list|)
name|BT_FRAME
argument_list|(
literal|66
argument_list|)
name|BT_FRAME
argument_list|(
literal|67
argument_list|)
name|BT_FRAME
argument_list|(
literal|68
argument_list|)
name|BT_FRAME
argument_list|(
literal|69
argument_list|)
name|BT_FRAME
argument_list|(
literal|70
argument_list|)
name|BT_FRAME
argument_list|(
literal|71
argument_list|)
name|BT_FRAME
argument_list|(
literal|72
argument_list|)
name|BT_FRAME
argument_list|(
literal|73
argument_list|)
name|BT_FRAME
argument_list|(
literal|74
argument_list|)
name|BT_FRAME
argument_list|(
literal|75
argument_list|)
name|BT_FRAME
argument_list|(
literal|76
argument_list|)
name|BT_FRAME
argument_list|(
literal|77
argument_list|)
name|BT_FRAME
argument_list|(
literal|78
argument_list|)
name|BT_FRAME
argument_list|(
literal|79
argument_list|)
name|BT_FRAME
argument_list|(
literal|80
argument_list|)
name|BT_FRAME
argument_list|(
literal|81
argument_list|)
name|BT_FRAME
argument_list|(
literal|82
argument_list|)
name|BT_FRAME
argument_list|(
literal|83
argument_list|)
name|BT_FRAME
argument_list|(
literal|84
argument_list|)
name|BT_FRAME
argument_list|(
literal|85
argument_list|)
name|BT_FRAME
argument_list|(
literal|86
argument_list|)
name|BT_FRAME
argument_list|(
literal|87
argument_list|)
name|BT_FRAME
argument_list|(
literal|88
argument_list|)
name|BT_FRAME
argument_list|(
literal|89
argument_list|)
name|BT_FRAME
argument_list|(
literal|90
argument_list|)
name|BT_FRAME
argument_list|(
literal|91
argument_list|)
name|BT_FRAME
argument_list|(
literal|92
argument_list|)
name|BT_FRAME
argument_list|(
literal|93
argument_list|)
name|BT_FRAME
argument_list|(
literal|94
argument_list|)
name|BT_FRAME
argument_list|(
literal|95
argument_list|)
name|BT_FRAME
argument_list|(
literal|96
argument_list|)
name|BT_FRAME
argument_list|(
literal|97
argument_list|)
name|BT_FRAME
argument_list|(
literal|98
argument_list|)
name|BT_FRAME
argument_list|(
literal|99
argument_list|)
name|BT_FRAME
argument_list|(
literal|100
argument_list|)
name|BT_FRAME
argument_list|(
literal|101
argument_list|)
name|BT_FRAME
argument_list|(
literal|102
argument_list|)
name|BT_FRAME
argument_list|(
literal|103
argument_list|)
name|BT_FRAME
argument_list|(
literal|104
argument_list|)
name|BT_FRAME
argument_list|(
literal|105
argument_list|)
name|BT_FRAME
argument_list|(
literal|106
argument_list|)
name|BT_FRAME
argument_list|(
literal|107
argument_list|)
name|BT_FRAME
argument_list|(
literal|108
argument_list|)
name|BT_FRAME
argument_list|(
literal|109
argument_list|)
name|BT_FRAME
argument_list|(
literal|110
argument_list|)
name|BT_FRAME
argument_list|(
literal|111
argument_list|)
name|BT_FRAME
argument_list|(
literal|112
argument_list|)
name|BT_FRAME
argument_list|(
literal|113
argument_list|)
name|BT_FRAME
argument_list|(
literal|114
argument_list|)
name|BT_FRAME
argument_list|(
literal|115
argument_list|)
name|BT_FRAME
argument_list|(
literal|116
argument_list|)
name|BT_FRAME
argument_list|(
literal|117
argument_list|)
name|BT_FRAME
argument_list|(
literal|118
argument_list|)
name|BT_FRAME
argument_list|(
literal|119
argument_list|)
name|BT_FRAME
argument_list|(
literal|120
argument_list|)
name|BT_FRAME
argument_list|(
literal|121
argument_list|)
name|BT_FRAME
argument_list|(
literal|122
argument_list|)
name|BT_FRAME
argument_list|(
literal|123
argument_list|)
name|BT_FRAME
argument_list|(
literal|124
argument_list|)
name|BT_FRAME
argument_list|(
literal|125
argument_list|)
name|BT_FRAME
argument_list|(
literal|126
argument_list|)
name|BT_FRAME
argument_list|(
literal|127
argument_list|)
undef|#
directive|undef
name|BT_FRAME
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|prof_backtrace
parameter_list|(
name|prof_bt_t
modifier|*
name|bt
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|not_reached
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|malloc_mutex_t
modifier|*
name|prof_gctx_mutex_choose
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|ngctxs
init|=
name|atomic_fetch_add_u
argument_list|(
operator|&
name|cum_gctxs
argument_list|,
literal|1
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
decl_stmt|;
return|return
operator|&
name|gctx_locks
index|[
operator|(
name|ngctxs
operator|-
literal|1
operator|)
operator|%
name|PROF_NCTX_LOCKS
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|malloc_mutex_t
modifier|*
name|prof_tdata_mutex_choose
parameter_list|(
name|uint64_t
name|thr_uid
parameter_list|)
block|{
return|return
operator|&
name|tdata_locks
index|[
name|thr_uid
operator|%
name|PROF_NTDATA_LOCKS
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|prof_gctx_t
modifier|*
name|prof_gctx_create
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|prof_bt_t
modifier|*
name|bt
parameter_list|)
block|{
comment|/* 	 * Create a single allocation that has space for vec of length bt->len. 	 */
name|size_t
name|size
init|=
name|offsetof
argument_list|(
name|prof_gctx_t
argument_list|,
name|vec
argument_list|)
operator|+
operator|(
name|bt
operator|->
name|len
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|)
decl_stmt|;
name|prof_gctx_t
modifier|*
name|gctx
init|=
operator|(
name|prof_gctx_t
operator|*
operator|)
name|iallocztm
argument_list|(
name|tsdn
argument_list|,
name|size
argument_list|,
name|sz_size2index
argument_list|(
name|size
argument_list|)
argument_list|,
name|false
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|arena_get
argument_list|(
name|TSDN_NULL
argument_list|,
literal|0
argument_list|,
name|true
argument_list|)
argument_list|,
name|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|gctx
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|gctx
operator|->
name|lock
operator|=
name|prof_gctx_mutex_choose
argument_list|()
expr_stmt|;
comment|/* 	 * Set nlimbo to 1, in order to avoid a race condition with 	 * prof_tctx_destroy()/prof_gctx_try_destroy(). 	 */
name|gctx
operator|->
name|nlimbo
operator|=
literal|1
expr_stmt|;
name|tctx_tree_new
argument_list|(
operator|&
name|gctx
operator|->
name|tctxs
argument_list|)
expr_stmt|;
comment|/* Duplicate bt. */
name|memcpy
argument_list|(
name|gctx
operator|->
name|vec
argument_list|,
name|bt
operator|->
name|vec
argument_list|,
name|bt
operator|->
name|len
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|bt
operator|.
name|vec
operator|=
name|gctx
operator|->
name|vec
expr_stmt|;
name|gctx
operator|->
name|bt
operator|.
name|len
operator|=
name|bt
operator|->
name|len
expr_stmt|;
return|return
name|gctx
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|prof_gctx_try_destroy
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|prof_tdata_t
modifier|*
name|tdata_self
parameter_list|,
name|prof_gctx_t
modifier|*
name|gctx
parameter_list|,
name|prof_tdata_t
modifier|*
name|tdata
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
comment|/* 	 * Check that gctx is still unused by any thread cache before destroying 	 * it.  prof_lookup() increments gctx->nlimbo in order to avoid a race 	 * condition with this function, as does prof_tctx_destroy() in order to 	 * avoid a race between the main body of prof_tctx_destroy() and entry 	 * into this function. 	 */
name|prof_enter
argument_list|(
name|tsd
argument_list|,
name|tdata_self
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|gctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|gctx
operator|->
name|nlimbo
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tctx_tree_empty
argument_list|(
operator|&
name|gctx
operator|->
name|tctxs
argument_list|)
operator|&&
name|gctx
operator|->
name|nlimbo
operator|==
literal|1
condition|)
block|{
comment|/* Remove gctx from bt2gctx. */
if|if
condition|(
name|ckh_remove
argument_list|(
name|tsd
argument_list|,
operator|&
name|bt2gctx
argument_list|,
operator|&
name|gctx
operator|->
name|bt
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|not_reached
argument_list|()
expr_stmt|;
block|}
name|prof_leave
argument_list|(
name|tsd
argument_list|,
name|tdata_self
argument_list|)
expr_stmt|;
comment|/* Destroy gctx. */
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|gctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|idalloctm
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|gctx
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Compensate for increment in prof_tctx_destroy() or 		 * prof_lookup(). 		 */
name|gctx
operator|->
name|nlimbo
operator|--
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|gctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|prof_leave
argument_list|(
name|tsd
argument_list|,
name|tdata_self
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|prof_tctx_should_destroy
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|)
block|{
name|malloc_mutex_assert_owner
argument_list|(
name|tsdn
argument_list|,
name|tctx
operator|->
name|tdata
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_prof_accum
condition|)
block|{
return|return
name|false
return|;
block|}
if|if
condition|(
name|tctx
operator|->
name|cnts
operator|.
name|curobjs
operator|!=
literal|0
condition|)
block|{
return|return
name|false
return|;
block|}
if|if
condition|(
name|tctx
operator|->
name|prepared
condition|)
block|{
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|prof_gctx_should_destroy
parameter_list|(
name|prof_gctx_t
modifier|*
name|gctx
parameter_list|)
block|{
if|if
condition|(
name|opt_prof_accum
condition|)
block|{
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|tctx_tree_empty
argument_list|(
operator|&
name|gctx
operator|->
name|tctxs
argument_list|)
condition|)
block|{
return|return
name|false
return|;
block|}
if|if
condition|(
name|gctx
operator|->
name|nlimbo
operator|!=
literal|0
condition|)
block|{
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|prof_tctx_destroy
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|)
block|{
name|prof_tdata_t
modifier|*
name|tdata
init|=
name|tctx
operator|->
name|tdata
decl_stmt|;
name|prof_gctx_t
modifier|*
name|gctx
init|=
name|tctx
operator|->
name|gctx
decl_stmt|;
name|bool
name|destroy_tdata
decl_stmt|,
name|destroy_tctx
decl_stmt|,
name|destroy_gctx
decl_stmt|;
name|malloc_mutex_assert_owner
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tctx
operator|->
name|tdata
operator|->
name|lock
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tctx
operator|->
name|cnts
operator|.
name|curobjs
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tctx
operator|->
name|cnts
operator|.
name|curbytes
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|opt_prof_accum
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tctx
operator|->
name|cnts
operator|.
name|accumobjs
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tctx
operator|->
name|cnts
operator|.
name|accumbytes
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ckh_remove
argument_list|(
name|tsd
argument_list|,
operator|&
name|tdata
operator|->
name|bt2tctx
argument_list|,
operator|&
name|gctx
operator|->
name|bt
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|destroy_tdata
operator|=
name|prof_tdata_should_destroy
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tdata
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tdata
operator|->
name|lock
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|gctx
operator|->
name|lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tctx
operator|->
name|state
condition|)
block|{
case|case
name|prof_tctx_state_nominal
case|:
name|tctx_tree_remove
argument_list|(
operator|&
name|gctx
operator|->
name|tctxs
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
name|destroy_tctx
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|prof_gctx_should_destroy
argument_list|(
name|gctx
argument_list|)
condition|)
block|{
comment|/* 			 * Increment gctx->nlimbo in order to keep another 			 * thread from winning the race to destroy gctx while 			 * this one has gctx->lock dropped.  Without this, it 			 * would be possible for another thread to: 			 * 			 * 1) Sample an allocation associated with gctx. 			 * 2) Deallocate the sampled object. 			 * 3) Successfully prof_gctx_try_destroy(gctx). 			 * 			 * The result would be that gctx no longer exists by the 			 * time this thread accesses it in 			 * prof_gctx_try_destroy(). 			 */
name|gctx
operator|->
name|nlimbo
operator|++
expr_stmt|;
name|destroy_gctx
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|destroy_gctx
operator|=
name|false
expr_stmt|;
block|}
break|break;
case|case
name|prof_tctx_state_dumping
case|:
comment|/* 		 * A dumping thread needs tctx to remain valid until dumping 		 * has finished.  Change state such that the dumping thread will 		 * complete destruction during a late dump iteration phase. 		 */
name|tctx
operator|->
name|state
operator|=
name|prof_tctx_state_purgatory
expr_stmt|;
name|destroy_tctx
operator|=
name|false
expr_stmt|;
name|destroy_gctx
operator|=
name|false
expr_stmt|;
break|break;
default|default:
name|not_reached
argument_list|()
expr_stmt|;
name|destroy_tctx
operator|=
name|false
expr_stmt|;
name|destroy_gctx
operator|=
name|false
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|gctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|destroy_gctx
condition|)
block|{
name|prof_gctx_try_destroy
argument_list|(
name|tsd
argument_list|,
name|prof_tdata_get
argument_list|(
name|tsd
argument_list|,
name|false
argument_list|)
argument_list|,
name|gctx
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_assert_not_owner
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tctx
operator|->
name|tdata
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|destroy_tdata
condition|)
block|{
name|prof_tdata_destroy
argument_list|(
name|tsd
argument_list|,
name|tdata
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|destroy_tctx
condition|)
block|{
name|idalloctm
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tctx
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|prof_lookup_global
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|prof_bt_t
modifier|*
name|bt
parameter_list|,
name|prof_tdata_t
modifier|*
name|tdata
parameter_list|,
name|void
modifier|*
modifier|*
name|p_btkey
parameter_list|,
name|prof_gctx_t
modifier|*
modifier|*
name|p_gctx
parameter_list|,
name|bool
modifier|*
name|p_new_gctx
parameter_list|)
block|{
union|union
block|{
name|prof_gctx_t
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|v
decl_stmt|;
block|}
name|gctx
union|,
name|tgctx
union|;
union|union
block|{
name|prof_bt_t
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|v
decl_stmt|;
block|}
name|btkey
union|;
name|bool
name|new_gctx
decl_stmt|;
name|prof_enter
argument_list|(
name|tsd
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|ckh_search
argument_list|(
operator|&
name|bt2gctx
argument_list|,
name|bt
argument_list|,
operator|&
name|btkey
operator|.
name|v
argument_list|,
operator|&
name|gctx
operator|.
name|v
argument_list|)
condition|)
block|{
comment|/* bt has never been seen before.  Insert it. */
name|prof_leave
argument_list|(
name|tsd
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
name|tgctx
operator|.
name|p
operator|=
name|prof_gctx_create
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|bt
argument_list|)
expr_stmt|;
if|if
condition|(
name|tgctx
operator|.
name|v
operator|==
name|NULL
condition|)
block|{
return|return
name|true
return|;
block|}
name|prof_enter
argument_list|(
name|tsd
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|ckh_search
argument_list|(
operator|&
name|bt2gctx
argument_list|,
name|bt
argument_list|,
operator|&
name|btkey
operator|.
name|v
argument_list|,
operator|&
name|gctx
operator|.
name|v
argument_list|)
condition|)
block|{
name|gctx
operator|.
name|p
operator|=
name|tgctx
operator|.
name|p
expr_stmt|;
name|btkey
operator|.
name|p
operator|=
operator|&
name|gctx
operator|.
name|p
operator|->
name|bt
expr_stmt|;
if|if
condition|(
name|ckh_insert
argument_list|(
name|tsd
argument_list|,
operator|&
name|bt2gctx
argument_list|,
name|btkey
operator|.
name|v
argument_list|,
name|gctx
operator|.
name|v
argument_list|)
condition|)
block|{
comment|/* OOM. */
name|prof_leave
argument_list|(
name|tsd
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
name|idalloctm
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|gctx
operator|.
name|v
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|new_gctx
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|new_gctx
operator|=
name|false
expr_stmt|;
block|}
block|}
else|else
block|{
name|tgctx
operator|.
name|v
operator|=
name|NULL
expr_stmt|;
name|new_gctx
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|new_gctx
condition|)
block|{
comment|/* 		 * Increment nlimbo, in order to avoid a race condition with 		 * prof_tctx_destroy()/prof_gctx_try_destroy(). 		 */
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|gctx
operator|.
name|p
operator|->
name|lock
argument_list|)
expr_stmt|;
name|gctx
operator|.
name|p
operator|->
name|nlimbo
operator|++
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|gctx
operator|.
name|p
operator|->
name|lock
argument_list|)
expr_stmt|;
name|new_gctx
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|tgctx
operator|.
name|v
operator|!=
name|NULL
condition|)
block|{
comment|/* Lost race to insert. */
name|idalloctm
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tgctx
operator|.
name|v
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
name|prof_leave
argument_list|(
name|tsd
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
operator|*
name|p_btkey
operator|=
name|btkey
operator|.
name|v
expr_stmt|;
operator|*
name|p_gctx
operator|=
name|gctx
operator|.
name|p
expr_stmt|;
operator|*
name|p_new_gctx
operator|=
name|new_gctx
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
name|prof_tctx_t
modifier|*
name|prof_lookup
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|prof_bt_t
modifier|*
name|bt
parameter_list|)
block|{
union|union
block|{
name|prof_tctx_t
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|v
decl_stmt|;
block|}
name|ret
union|;
name|prof_tdata_t
modifier|*
name|tdata
decl_stmt|;
name|bool
name|not_found
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|tdata
operator|=
name|prof_tdata_get
argument_list|(
name|tsd
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdata
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tdata
operator|->
name|lock
argument_list|)
expr_stmt|;
name|not_found
operator|=
name|ckh_search
argument_list|(
operator|&
name|tdata
operator|->
name|bt2tctx
argument_list|,
name|bt
argument_list|,
name|NULL
argument_list|,
operator|&
name|ret
operator|.
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|not_found
condition|)
block|{
comment|/* Note double negative! */
name|ret
operator|.
name|p
operator|->
name|prepared
operator|=
name|true
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tdata
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|not_found
condition|)
block|{
name|void
modifier|*
name|btkey
decl_stmt|;
name|prof_gctx_t
modifier|*
name|gctx
decl_stmt|;
name|bool
name|new_gctx
decl_stmt|,
name|error
decl_stmt|;
comment|/* 		 * This thread's cache lacks bt.  Look for it in the global 		 * cache. 		 */
if|if
condition|(
name|prof_lookup_global
argument_list|(
name|tsd
argument_list|,
name|bt
argument_list|,
name|tdata
argument_list|,
operator|&
name|btkey
argument_list|,
operator|&
name|gctx
argument_list|,
operator|&
name|new_gctx
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|/* Link a prof_tctx_t into gctx for this thread. */
name|ret
operator|.
name|v
operator|=
name|iallocztm
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|prof_tctx_t
argument_list|)
argument_list|,
name|sz_size2index
argument_list|(
sizeof|sizeof
argument_list|(
name|prof_tctx_t
argument_list|)
argument_list|)
argument_list|,
name|false
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|arena_ichoose
argument_list|(
name|tsd
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|.
name|p
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|new_gctx
condition|)
block|{
name|prof_gctx_try_destroy
argument_list|(
name|tsd
argument_list|,
name|tdata
argument_list|,
name|gctx
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
name|ret
operator|.
name|p
operator|->
name|tdata
operator|=
name|tdata
expr_stmt|;
name|ret
operator|.
name|p
operator|->
name|thr_uid
operator|=
name|tdata
operator|->
name|thr_uid
expr_stmt|;
name|ret
operator|.
name|p
operator|->
name|thr_discrim
operator|=
name|tdata
operator|->
name|thr_discrim
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ret
operator|.
name|p
operator|->
name|cnts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|prof_cnt_t
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|.
name|p
operator|->
name|gctx
operator|=
name|gctx
expr_stmt|;
name|ret
operator|.
name|p
operator|->
name|tctx_uid
operator|=
name|tdata
operator|->
name|tctx_uid_next
operator|++
expr_stmt|;
name|ret
operator|.
name|p
operator|->
name|prepared
operator|=
name|true
expr_stmt|;
name|ret
operator|.
name|p
operator|->
name|state
operator|=
name|prof_tctx_state_initializing
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tdata
operator|->
name|lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|ckh_insert
argument_list|(
name|tsd
argument_list|,
operator|&
name|tdata
operator|->
name|bt2tctx
argument_list|,
name|btkey
argument_list|,
name|ret
operator|.
name|v
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tdata
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|new_gctx
condition|)
block|{
name|prof_gctx_try_destroy
argument_list|(
name|tsd
argument_list|,
name|tdata
argument_list|,
name|gctx
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
block|}
name|idalloctm
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ret
operator|.
name|v
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|gctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ret
operator|.
name|p
operator|->
name|state
operator|=
name|prof_tctx_state_nominal
expr_stmt|;
name|tctx_tree_insert
argument_list|(
operator|&
name|gctx
operator|->
name|tctxs
argument_list|,
name|ret
operator|.
name|p
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|nlimbo
operator|--
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|gctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
operator|.
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * The bodies of this function and prof_leakcheck() are compiled out unless heap  * profiling is enabled, so that it is possible to compile jemalloc with  * floating point support completely disabled.  Avoiding floating point code is  * important on memory-constrained systems, but it also enables a workaround for  * versions of glibc that don't properly save/restore floating point registers  * during dynamic lazy symbol loading (which internally calls into whatever  * malloc implementation happens to be integrated into the application).  Note  * that some compilers (e.g.  gcc 4.8) may use floating point registers for fast  * memory moves, so jemalloc must be compiled with such optimizations disabled  * (e.g.  * -mno-sse) in order for the workaround to be complete.  */
end_comment

begin_function
name|void
name|prof_sample_threshold_update
parameter_list|(
name|prof_tdata_t
modifier|*
name|tdata
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|JEMALLOC_PROF
name|uint64_t
name|r
decl_stmt|;
name|double
name|u
decl_stmt|;
if|if
condition|(
operator|!
name|config_prof
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|lg_prof_sample
operator|==
literal|0
condition|)
block|{
name|tdata
operator|->
name|bytes_until_sample
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* 	 * Compute sample interval as a geometrically distributed random 	 * variable with mean (2^lg_prof_sample). 	 * 	 *                             __        __ 	 *                             |  log(u)  |                     1 	 * tdata->bytes_until_sample = | -------- |, where p = --------------- 	 *                             | log(1-p) |             lg_prof_sample 	 *                                                     2 	 * 	 * For more information on the math, see: 	 * 	 *   Non-Uniform Random Variate Generation 	 *   Luc Devroye 	 *   Springer-Verlag, New York, 1986 	 *   pp 500 	 *   (http://luc.devroye.org/rnbookindex.html) 	 */
name|r
operator|=
name|prng_lg_range_u64
argument_list|(
operator|&
name|tdata
operator|->
name|prng_state
argument_list|,
literal|53
argument_list|)
expr_stmt|;
name|u
operator|=
operator|(
name|double
operator|)
name|r
operator|*
operator|(
literal|1.0
operator|/
literal|9007199254740992.0L
operator|)
expr_stmt|;
name|tdata
operator|->
name|bytes_until_sample
operator|=
call|(
name|uint64_t
call|)
argument_list|(
name|log
argument_list|(
name|u
argument_list|)
operator|/
name|log
argument_list|(
literal|1.0
operator|-
operator|(
literal|1.0
operator|/
call|(
name|double
call|)
argument_list|(
operator|(
name|uint64_t
operator|)
literal|1U
operator|<<
name|lg_prof_sample
argument_list|)
operator|)
argument_list|)
argument_list|)
operator|+
operator|(
name|uint64_t
operator|)
literal|1U
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_JET
end_ifdef

begin_function
specifier|static
name|prof_tdata_t
modifier|*
name|prof_tdata_count_iter
parameter_list|(
name|prof_tdata_tree_t
modifier|*
name|tdatas
parameter_list|,
name|prof_tdata_t
modifier|*
name|tdata
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|size_t
modifier|*
name|tdata_count
init|=
operator|(
name|size_t
operator|*
operator|)
name|arg
decl_stmt|;
operator|(
operator|*
name|tdata_count
operator|)
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|size_t
name|prof_tdata_count
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|tdata_count
init|=
literal|0
decl_stmt|;
name|tsdn_t
modifier|*
name|tsdn
decl_stmt|;
name|tsdn
operator|=
name|tsdn_fetch
argument_list|()
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|tdatas_mtx
argument_list|)
expr_stmt|;
name|tdata_tree_iter
argument_list|(
operator|&
name|tdatas
argument_list|,
name|NULL
argument_list|,
name|prof_tdata_count_iter
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|tdata_count
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|tdatas_mtx
argument_list|)
expr_stmt|;
return|return
name|tdata_count
return|;
block|}
end_function

begin_function
name|size_t
name|prof_bt_count
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|bt_count
decl_stmt|;
name|tsd_t
modifier|*
name|tsd
decl_stmt|;
name|prof_tdata_t
modifier|*
name|tdata
decl_stmt|;
name|tsd
operator|=
name|tsd_fetch
argument_list|()
expr_stmt|;
name|tdata
operator|=
name|prof_tdata_get
argument_list|(
name|tsd
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdata
operator|==
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|bt2gctx_mtx
argument_list|)
expr_stmt|;
name|bt_count
operator|=
name|ckh_count
argument_list|(
operator|&
name|bt2gctx
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|bt2gctx_mtx
argument_list|)
expr_stmt|;
return|return
name|bt_count
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|prof_dump_open_impl
parameter_list|(
name|bool
name|propagate_err
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|fd
operator|=
name|creat
argument_list|(
name|filename
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
operator|&&
operator|!
name|propagate_err
condition|)
block|{
name|malloc_printf
argument_list|(
literal|"<jemalloc>: creat(\"%s\"), 0644) failed\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|fd
return|;
block|}
end_function

begin_decl_stmt
name|prof_dump_open_t
modifier|*
name|JET_MUTABLE
name|prof_dump_open
init|=
name|prof_dump_open_impl
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bool
name|prof_dump_flush
parameter_list|(
name|bool
name|propagate_err
parameter_list|)
block|{
name|bool
name|ret
init|=
name|false
decl_stmt|;
name|ssize_t
name|err
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|err
operator|=
name|write
argument_list|(
name|prof_dump_fd
argument_list|,
name|prof_dump_buf
argument_list|,
name|prof_dump_buf_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|propagate_err
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: write() failed during heap "
literal|"profile flush\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|ret
operator|=
name|true
expr_stmt|;
block|}
name|prof_dump_buf_end
operator|=
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|prof_dump_close
parameter_list|(
name|bool
name|propagate_err
parameter_list|)
block|{
name|bool
name|ret
decl_stmt|;
name|assert
argument_list|(
name|prof_dump_fd
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|prof_dump_flush
argument_list|(
name|propagate_err
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|prof_dump_fd
argument_list|)
expr_stmt|;
name|prof_dump_fd
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|prof_dump_write
parameter_list|(
name|bool
name|propagate_err
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|slen
decl_stmt|,
name|n
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|slen
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|slen
condition|)
block|{
comment|/* Flush the buffer if it is full. */
if|if
condition|(
name|prof_dump_buf_end
operator|==
name|PROF_DUMP_BUFSIZE
condition|)
block|{
if|if
condition|(
name|prof_dump_flush
argument_list|(
name|propagate_err
argument_list|)
operator|&&
name|propagate_err
condition|)
block|{
return|return
name|true
return|;
block|}
block|}
if|if
condition|(
name|prof_dump_buf_end
operator|+
name|slen
operator|<=
name|PROF_DUMP_BUFSIZE
condition|)
block|{
comment|/* Finish writing. */
name|n
operator|=
name|slen
operator|-
name|i
expr_stmt|;
block|}
else|else
block|{
comment|/* Write as much of s as will fit. */
name|n
operator|=
name|PROF_DUMP_BUFSIZE
operator|-
name|prof_dump_buf_end
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|prof_dump_buf
index|[
name|prof_dump_buf_end
index|]
argument_list|,
operator|&
name|s
index|[
name|i
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|prof_dump_buf_end
operator|+=
name|n
expr_stmt|;
name|i
operator|+=
name|n
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_macro
name|JEMALLOC_FORMAT_PRINTF
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|)
end_macro

begin_function
specifier|static
name|bool
name|prof_dump_printf
parameter_list|(
name|bool
name|propagate_err
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|bool
name|ret
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|char
name|buf
index|[
name|PROF_PRINTF_BUFSIZE
index|]
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|malloc_vsnprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|ret
operator|=
name|prof_dump_write
argument_list|(
name|propagate_err
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|prof_tctx_merge_tdata
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|,
name|prof_tdata_t
modifier|*
name|tdata
parameter_list|)
block|{
name|malloc_mutex_assert_owner
argument_list|(
name|tsdn
argument_list|,
name|tctx
operator|->
name|tdata
operator|->
name|lock
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
name|tctx
operator|->
name|gctx
operator|->
name|lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tctx
operator|->
name|state
condition|)
block|{
case|case
name|prof_tctx_state_initializing
case|:
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
name|tctx
operator|->
name|gctx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
case|case
name|prof_tctx_state_nominal
case|:
name|tctx
operator|->
name|state
operator|=
name|prof_tctx_state_dumping
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
name|tctx
operator|->
name|gctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|tctx
operator|->
name|dump_cnts
argument_list|,
operator|&
name|tctx
operator|->
name|cnts
argument_list|,
sizeof|sizeof
argument_list|(
name|prof_cnt_t
argument_list|)
argument_list|)
expr_stmt|;
name|tdata
operator|->
name|cnt_summed
operator|.
name|curobjs
operator|+=
name|tctx
operator|->
name|dump_cnts
operator|.
name|curobjs
expr_stmt|;
name|tdata
operator|->
name|cnt_summed
operator|.
name|curbytes
operator|+=
name|tctx
operator|->
name|dump_cnts
operator|.
name|curbytes
expr_stmt|;
if|if
condition|(
name|opt_prof_accum
condition|)
block|{
name|tdata
operator|->
name|cnt_summed
operator|.
name|accumobjs
operator|+=
name|tctx
operator|->
name|dump_cnts
operator|.
name|accumobjs
expr_stmt|;
name|tdata
operator|->
name|cnt_summed
operator|.
name|accumbytes
operator|+=
name|tctx
operator|->
name|dump_cnts
operator|.
name|accumbytes
expr_stmt|;
block|}
break|break;
case|case
name|prof_tctx_state_dumping
case|:
case|case
name|prof_tctx_state_purgatory
case|:
name|not_reached
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|prof_tctx_merge_gctx
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|,
name|prof_gctx_t
modifier|*
name|gctx
parameter_list|)
block|{
name|malloc_mutex_assert_owner
argument_list|(
name|tsdn
argument_list|,
name|gctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|gctx
operator|->
name|cnt_summed
operator|.
name|curobjs
operator|+=
name|tctx
operator|->
name|dump_cnts
operator|.
name|curobjs
expr_stmt|;
name|gctx
operator|->
name|cnt_summed
operator|.
name|curbytes
operator|+=
name|tctx
operator|->
name|dump_cnts
operator|.
name|curbytes
expr_stmt|;
if|if
condition|(
name|opt_prof_accum
condition|)
block|{
name|gctx
operator|->
name|cnt_summed
operator|.
name|accumobjs
operator|+=
name|tctx
operator|->
name|dump_cnts
operator|.
name|accumobjs
expr_stmt|;
name|gctx
operator|->
name|cnt_summed
operator|.
name|accumbytes
operator|+=
name|tctx
operator|->
name|dump_cnts
operator|.
name|accumbytes
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|prof_tctx_t
modifier|*
name|prof_tctx_merge_iter
parameter_list|(
name|prof_tctx_tree_t
modifier|*
name|tctxs
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|tsdn_t
modifier|*
name|tsdn
init|=
operator|(
name|tsdn_t
operator|*
operator|)
name|arg
decl_stmt|;
name|malloc_mutex_assert_owner
argument_list|(
name|tsdn
argument_list|,
name|tctx
operator|->
name|gctx
operator|->
name|lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tctx
operator|->
name|state
condition|)
block|{
case|case
name|prof_tctx_state_nominal
case|:
comment|/* New since dumping started; ignore. */
break|break;
case|case
name|prof_tctx_state_dumping
case|:
case|case
name|prof_tctx_state_purgatory
case|:
name|prof_tctx_merge_gctx
argument_list|(
name|tsdn
argument_list|,
name|tctx
argument_list|,
name|tctx
operator|->
name|gctx
argument_list|)
expr_stmt|;
break|break;
default|default:
name|not_reached
argument_list|()
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_struct
struct|struct
name|prof_tctx_dump_iter_arg_s
block|{
name|tsdn_t
modifier|*
name|tsdn
decl_stmt|;
name|bool
name|propagate_err
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|prof_tctx_t
modifier|*
name|prof_tctx_dump_iter
parameter_list|(
name|prof_tctx_tree_t
modifier|*
name|tctxs
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|,
name|void
modifier|*
name|opaque
parameter_list|)
block|{
name|struct
name|prof_tctx_dump_iter_arg_s
modifier|*
name|arg
init|=
operator|(
expr|struct
name|prof_tctx_dump_iter_arg_s
operator|*
operator|)
name|opaque
decl_stmt|;
name|malloc_mutex_assert_owner
argument_list|(
name|arg
operator|->
name|tsdn
argument_list|,
name|tctx
operator|->
name|gctx
operator|->
name|lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tctx
operator|->
name|state
condition|)
block|{
case|case
name|prof_tctx_state_initializing
case|:
case|case
name|prof_tctx_state_nominal
case|:
comment|/* Not captured by this dump. */
break|break;
case|case
name|prof_tctx_state_dumping
case|:
case|case
name|prof_tctx_state_purgatory
case|:
if|if
condition|(
name|prof_dump_printf
argument_list|(
name|arg
operator|->
name|propagate_err
argument_list|,
literal|"  t%"
name|FMTu64
literal|": %"
name|FMTu64
literal|": %"
name|FMTu64
literal|" [%"
name|FMTu64
literal|": "
literal|"%"
name|FMTu64
literal|"]\n"
argument_list|,
name|tctx
operator|->
name|thr_uid
argument_list|,
name|tctx
operator|->
name|dump_cnts
operator|.
name|curobjs
argument_list|,
name|tctx
operator|->
name|dump_cnts
operator|.
name|curbytes
argument_list|,
name|tctx
operator|->
name|dump_cnts
operator|.
name|accumobjs
argument_list|,
name|tctx
operator|->
name|dump_cnts
operator|.
name|accumbytes
argument_list|)
condition|)
block|{
return|return
name|tctx
return|;
block|}
break|break;
default|default:
name|not_reached
argument_list|()
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|prof_tctx_t
modifier|*
name|prof_tctx_finish_iter
parameter_list|(
name|prof_tctx_tree_t
modifier|*
name|tctxs
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|tsdn_t
modifier|*
name|tsdn
init|=
operator|(
name|tsdn_t
operator|*
operator|)
name|arg
decl_stmt|;
name|prof_tctx_t
modifier|*
name|ret
decl_stmt|;
name|malloc_mutex_assert_owner
argument_list|(
name|tsdn
argument_list|,
name|tctx
operator|->
name|gctx
operator|->
name|lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tctx
operator|->
name|state
condition|)
block|{
case|case
name|prof_tctx_state_nominal
case|:
comment|/* New since dumping started; ignore. */
break|break;
case|case
name|prof_tctx_state_dumping
case|:
name|tctx
operator|->
name|state
operator|=
name|prof_tctx_state_nominal
expr_stmt|;
break|break;
case|case
name|prof_tctx_state_purgatory
case|:
name|ret
operator|=
name|tctx
expr_stmt|;
goto|goto
name|label_return
goto|;
default|default:
name|not_reached
argument_list|()
expr_stmt|;
block|}
name|ret
operator|=
name|NULL
expr_stmt|;
name|label_return
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|prof_dump_gctx_prep
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|prof_gctx_t
modifier|*
name|gctx
parameter_list|,
name|prof_gctx_tree_t
modifier|*
name|gctxs
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
name|gctx
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Increment nlimbo so that gctx won't go away before dump. 	 * Additionally, link gctx into the dump list so that it is included in 	 * prof_dump()'s second pass. 	 */
name|gctx
operator|->
name|nlimbo
operator|++
expr_stmt|;
name|gctx_tree_insert
argument_list|(
name|gctxs
argument_list|,
name|gctx
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|gctx
operator|->
name|cnt_summed
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|prof_cnt_t
argument_list|)
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
name|gctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|prof_gctx_merge_iter_arg_s
block|{
name|tsdn_t
modifier|*
name|tsdn
decl_stmt|;
name|size_t
name|leak_ngctx
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|prof_gctx_t
modifier|*
name|prof_gctx_merge_iter
parameter_list|(
name|prof_gctx_tree_t
modifier|*
name|gctxs
parameter_list|,
name|prof_gctx_t
modifier|*
name|gctx
parameter_list|,
name|void
modifier|*
name|opaque
parameter_list|)
block|{
name|struct
name|prof_gctx_merge_iter_arg_s
modifier|*
name|arg
init|=
operator|(
expr|struct
name|prof_gctx_merge_iter_arg_s
operator|*
operator|)
name|opaque
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|arg
operator|->
name|tsdn
argument_list|,
name|gctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|tctx_tree_iter
argument_list|(
operator|&
name|gctx
operator|->
name|tctxs
argument_list|,
name|NULL
argument_list|,
name|prof_tctx_merge_iter
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
operator|->
name|tsdn
argument_list|)
expr_stmt|;
if|if
condition|(
name|gctx
operator|->
name|cnt_summed
operator|.
name|curobjs
operator|!=
literal|0
condition|)
block|{
name|arg
operator|->
name|leak_ngctx
operator|++
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|arg
operator|->
name|tsdn
argument_list|,
name|gctx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|prof_gctx_finish
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|prof_gctx_tree_t
modifier|*
name|gctxs
parameter_list|)
block|{
name|prof_tdata_t
modifier|*
name|tdata
init|=
name|prof_tdata_get
argument_list|(
name|tsd
argument_list|,
name|false
argument_list|)
decl_stmt|;
name|prof_gctx_t
modifier|*
name|gctx
decl_stmt|;
comment|/* 	 * Standard tree iteration won't work here, because as soon as we 	 * decrement gctx->nlimbo and unlock gctx, another thread can 	 * concurrently destroy it, which will corrupt the tree.  Therefore, 	 * tear down the tree one node at a time during iteration. 	 */
while|while
condition|(
operator|(
name|gctx
operator|=
name|gctx_tree_first
argument_list|(
name|gctxs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|gctx_tree_remove
argument_list|(
name|gctxs
argument_list|,
name|gctx
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|gctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|{
name|prof_tctx_t
modifier|*
name|next
decl_stmt|;
name|next
operator|=
name|NULL
expr_stmt|;
do|do
block|{
name|prof_tctx_t
modifier|*
name|to_destroy
init|=
name|tctx_tree_iter
argument_list|(
operator|&
name|gctx
operator|->
name|tctxs
argument_list|,
name|next
argument_list|,
name|prof_tctx_finish_iter
argument_list|,
operator|(
name|void
operator|*
operator|)
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|to_destroy
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|tctx_tree_next
argument_list|(
operator|&
name|gctx
operator|->
name|tctxs
argument_list|,
name|to_destroy
argument_list|)
expr_stmt|;
name|tctx_tree_remove
argument_list|(
operator|&
name|gctx
operator|->
name|tctxs
argument_list|,
name|to_destroy
argument_list|)
expr_stmt|;
name|idalloctm
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|to_destroy
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
do|while
condition|(
name|next
operator|!=
name|NULL
condition|)
do|;
block|}
name|gctx
operator|->
name|nlimbo
operator|--
expr_stmt|;
if|if
condition|(
name|prof_gctx_should_destroy
argument_list|(
name|gctx
argument_list|)
condition|)
block|{
name|gctx
operator|->
name|nlimbo
operator|++
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|gctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|prof_gctx_try_destroy
argument_list|(
name|tsd
argument_list|,
name|tdata
argument_list|,
name|gctx
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|gctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_struct
struct|struct
name|prof_tdata_merge_iter_arg_s
block|{
name|tsdn_t
modifier|*
name|tsdn
decl_stmt|;
name|prof_cnt_t
name|cnt_all
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|prof_tdata_t
modifier|*
name|prof_tdata_merge_iter
parameter_list|(
name|prof_tdata_tree_t
modifier|*
name|tdatas
parameter_list|,
name|prof_tdata_t
modifier|*
name|tdata
parameter_list|,
name|void
modifier|*
name|opaque
parameter_list|)
block|{
name|struct
name|prof_tdata_merge_iter_arg_s
modifier|*
name|arg
init|=
operator|(
expr|struct
name|prof_tdata_merge_iter_arg_s
operator|*
operator|)
name|opaque
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|arg
operator|->
name|tsdn
argument_list|,
name|tdata
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tdata
operator|->
name|expired
condition|)
block|{
name|size_t
name|tabind
decl_stmt|;
union|union
block|{
name|prof_tctx_t
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|v
decl_stmt|;
block|}
name|tctx
union|;
name|tdata
operator|->
name|dumping
operator|=
name|true
expr_stmt|;
name|memset
argument_list|(
operator|&
name|tdata
operator|->
name|cnt_summed
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|prof_cnt_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|tabind
operator|=
literal|0
init|;
operator|!
name|ckh_iter
argument_list|(
operator|&
name|tdata
operator|->
name|bt2tctx
argument_list|,
operator|&
name|tabind
argument_list|,
name|NULL
argument_list|,
operator|&
name|tctx
operator|.
name|v
argument_list|)
condition|;
control|)
block|{
name|prof_tctx_merge_tdata
argument_list|(
name|arg
operator|->
name|tsdn
argument_list|,
name|tctx
operator|.
name|p
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
block|}
name|arg
operator|->
name|cnt_all
operator|.
name|curobjs
operator|+=
name|tdata
operator|->
name|cnt_summed
operator|.
name|curobjs
expr_stmt|;
name|arg
operator|->
name|cnt_all
operator|.
name|curbytes
operator|+=
name|tdata
operator|->
name|cnt_summed
operator|.
name|curbytes
expr_stmt|;
if|if
condition|(
name|opt_prof_accum
condition|)
block|{
name|arg
operator|->
name|cnt_all
operator|.
name|accumobjs
operator|+=
name|tdata
operator|->
name|cnt_summed
operator|.
name|accumobjs
expr_stmt|;
name|arg
operator|->
name|cnt_all
operator|.
name|accumbytes
operator|+=
name|tdata
operator|->
name|cnt_summed
operator|.
name|accumbytes
expr_stmt|;
block|}
block|}
else|else
block|{
name|tdata
operator|->
name|dumping
operator|=
name|false
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|arg
operator|->
name|tsdn
argument_list|,
name|tdata
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|prof_tdata_t
modifier|*
name|prof_tdata_dump_iter
parameter_list|(
name|prof_tdata_tree_t
modifier|*
name|tdatas
parameter_list|,
name|prof_tdata_t
modifier|*
name|tdata
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|bool
name|propagate_err
init|=
operator|*
operator|(
name|bool
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|tdata
operator|->
name|dumping
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|prof_dump_printf
argument_list|(
name|propagate_err
argument_list|,
literal|"  t%"
name|FMTu64
literal|": %"
name|FMTu64
literal|": %"
name|FMTu64
literal|" [%"
name|FMTu64
literal|": %"
name|FMTu64
literal|"]%s%s\n"
argument_list|,
name|tdata
operator|->
name|thr_uid
argument_list|,
name|tdata
operator|->
name|cnt_summed
operator|.
name|curobjs
argument_list|,
name|tdata
operator|->
name|cnt_summed
operator|.
name|curbytes
argument_list|,
name|tdata
operator|->
name|cnt_summed
operator|.
name|accumobjs
argument_list|,
name|tdata
operator|->
name|cnt_summed
operator|.
name|accumbytes
argument_list|,
operator|(
name|tdata
operator|->
name|thread_name
operator|!=
name|NULL
operator|)
condition|?
literal|" "
else|:
literal|""
argument_list|,
operator|(
name|tdata
operator|->
name|thread_name
operator|!=
name|NULL
operator|)
condition|?
name|tdata
operator|->
name|thread_name
else|:
literal|""
argument_list|)
condition|)
block|{
return|return
name|tdata
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|prof_dump_header_impl
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|bool
name|propagate_err
parameter_list|,
specifier|const
name|prof_cnt_t
modifier|*
name|cnt_all
parameter_list|)
block|{
name|bool
name|ret
decl_stmt|;
if|if
condition|(
name|prof_dump_printf
argument_list|(
name|propagate_err
argument_list|,
literal|"heap_v2/%"
name|FMTu64
literal|"\n"
literal|"  t*: %"
name|FMTu64
literal|": %"
name|FMTu64
literal|" [%"
name|FMTu64
literal|": %"
name|FMTu64
literal|"]\n"
argument_list|,
operator|(
operator|(
name|uint64_t
operator|)
literal|1U
operator|<<
name|lg_prof_sample
operator|)
argument_list|,
name|cnt_all
operator|->
name|curobjs
argument_list|,
name|cnt_all
operator|->
name|curbytes
argument_list|,
name|cnt_all
operator|->
name|accumobjs
argument_list|,
name|cnt_all
operator|->
name|accumbytes
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|tdatas_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|tdata_tree_iter
argument_list|(
operator|&
name|tdatas
argument_list|,
name|NULL
argument_list|,
name|prof_tdata_dump_iter
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|propagate_err
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|tdatas_mtx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_decl_stmt
name|prof_dump_header_t
modifier|*
name|JET_MUTABLE
name|prof_dump_header
init|=
name|prof_dump_header_impl
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bool
name|prof_dump_gctx
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|bool
name|propagate_err
parameter_list|,
name|prof_gctx_t
modifier|*
name|gctx
parameter_list|,
specifier|const
name|prof_bt_t
modifier|*
name|bt
parameter_list|,
name|prof_gctx_tree_t
modifier|*
name|gctxs
parameter_list|)
block|{
name|bool
name|ret
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|struct
name|prof_tctx_dump_iter_arg_s
name|prof_tctx_dump_iter_arg
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|malloc_mutex_assert_owner
argument_list|(
name|tsdn
argument_list|,
name|gctx
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* Avoid dumping such gctx's that have no useful data. */
if|if
condition|(
operator|(
operator|!
name|opt_prof_accum
operator|&&
name|gctx
operator|->
name|cnt_summed
operator|.
name|curobjs
operator|==
literal|0
operator|)
operator|||
operator|(
name|opt_prof_accum
operator|&&
name|gctx
operator|->
name|cnt_summed
operator|.
name|accumobjs
operator|==
literal|0
operator|)
condition|)
block|{
name|assert
argument_list|(
name|gctx
operator|->
name|cnt_summed
operator|.
name|curobjs
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|gctx
operator|->
name|cnt_summed
operator|.
name|curbytes
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|gctx
operator|->
name|cnt_summed
operator|.
name|accumobjs
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|gctx
operator|->
name|cnt_summed
operator|.
name|accumbytes
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
if|if
condition|(
name|prof_dump_printf
argument_list|(
name|propagate_err
argument_list|,
literal|"@"
argument_list|)
condition|)
block|{
name|ret
operator|=
name|true
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bt
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|prof_dump_printf
argument_list|(
name|propagate_err
argument_list|,
literal|" %#"
name|FMTxPTR
argument_list|,
operator|(
name|uintptr_t
operator|)
name|bt
operator|->
name|vec
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|ret
operator|=
name|true
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
block|}
if|if
condition|(
name|prof_dump_printf
argument_list|(
name|propagate_err
argument_list|,
literal|"\n"
literal|"  t*: %"
name|FMTu64
literal|": %"
name|FMTu64
literal|" [%"
name|FMTu64
literal|": %"
name|FMTu64
literal|"]\n"
argument_list|,
name|gctx
operator|->
name|cnt_summed
operator|.
name|curobjs
argument_list|,
name|gctx
operator|->
name|cnt_summed
operator|.
name|curbytes
argument_list|,
name|gctx
operator|->
name|cnt_summed
operator|.
name|accumobjs
argument_list|,
name|gctx
operator|->
name|cnt_summed
operator|.
name|accumbytes
argument_list|)
condition|)
block|{
name|ret
operator|=
name|true
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
name|prof_tctx_dump_iter_arg
operator|.
name|tsdn
operator|=
name|tsdn
expr_stmt|;
name|prof_tctx_dump_iter_arg
operator|.
name|propagate_err
operator|=
name|propagate_err
expr_stmt|;
if|if
condition|(
name|tctx_tree_iter
argument_list|(
operator|&
name|gctx
operator|->
name|tctxs
argument_list|,
name|NULL
argument_list|,
name|prof_tctx_dump_iter
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|prof_tctx_dump_iter_arg
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|true
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
name|ret
operator|=
name|false
expr_stmt|;
name|label_return
label|:
return|return
name|ret
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32
end_ifndef

begin_macro
name|JEMALLOC_FORMAT_PRINTF
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
end_macro

begin_function
specifier|static
name|int
name|prof_open_maps
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|mfd
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|char
name|filename
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|malloc_vsnprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|mfd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
operator||
name|O_CLOEXEC
argument_list|)
expr_stmt|;
return|return
name|mfd
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|prof_getpid
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_WIN32
return|return
name|GetCurrentProcessId
argument_list|()
return|;
else|#
directive|else
return|return
name|getpid
argument_list|()
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|bool
name|prof_dump_maps
parameter_list|(
name|bool
name|propagate_err
parameter_list|)
block|{
name|bool
name|ret
decl_stmt|;
name|int
name|mfd
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|mfd
operator|=
name|prof_open_maps
argument_list|(
literal|"/proc/curproc/map"
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|_WIN32
argument_list|)
name|mfd
operator|=
operator|-
literal|1
expr_stmt|;
comment|// Not implemented
else|#
directive|else
block|{
name|int
name|pid
init|=
name|prof_getpid
argument_list|()
decl_stmt|;
name|mfd
operator|=
name|prof_open_maps
argument_list|(
literal|"/proc/%d/task/%d/maps"
argument_list|,
name|pid
argument_list|,
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfd
operator|==
operator|-
literal|1
condition|)
block|{
name|mfd
operator|=
name|prof_open_maps
argument_list|(
literal|"/proc/%d/maps"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|mfd
operator|!=
operator|-
literal|1
condition|)
block|{
name|ssize_t
name|nread
decl_stmt|;
if|if
condition|(
name|prof_dump_write
argument_list|(
name|propagate_err
argument_list|,
literal|"\nMAPPED_LIBRARIES:\n"
argument_list|)
operator|&&
name|propagate_err
condition|)
block|{
name|ret
operator|=
name|true
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
name|nread
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|prof_dump_buf_end
operator|+=
name|nread
expr_stmt|;
if|if
condition|(
name|prof_dump_buf_end
operator|==
name|PROF_DUMP_BUFSIZE
condition|)
block|{
comment|/* Make space in prof_dump_buf before read(). */
if|if
condition|(
name|prof_dump_flush
argument_list|(
name|propagate_err
argument_list|)
operator|&&
name|propagate_err
condition|)
block|{
name|ret
operator|=
name|true
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
block|}
name|nread
operator|=
name|read
argument_list|(
name|mfd
argument_list|,
operator|&
name|prof_dump_buf
index|[
name|prof_dump_buf_end
index|]
argument_list|,
name|PROF_DUMP_BUFSIZE
operator|-
name|prof_dump_buf_end
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|nread
operator|>
literal|0
condition|)
do|;
block|}
else|else
block|{
name|ret
operator|=
name|true
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
name|ret
operator|=
name|false
expr_stmt|;
name|label_return
label|:
if|if
condition|(
name|mfd
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|mfd
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * See prof_sample_threshold_update() comment for why the body of this function  * is conditionally compiled.  */
end_comment

begin_function
specifier|static
name|void
name|prof_leakcheck
parameter_list|(
specifier|const
name|prof_cnt_t
modifier|*
name|cnt_all
parameter_list|,
name|size_t
name|leak_ngctx
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|JEMALLOC_PROF
comment|/* 	 * Scaling is equivalent AdjustSamples() in jeprof, but the result may 	 * differ slightly from what jeprof reports, because here we scale the 	 * summary values, whereas jeprof scales each context individually and 	 * reports the sums of the scaled values. 	 */
if|if
condition|(
name|cnt_all
operator|->
name|curbytes
operator|!=
literal|0
condition|)
block|{
name|double
name|sample_period
init|=
call|(
name|double
call|)
argument_list|(
operator|(
name|uint64_t
operator|)
literal|1
operator|<<
name|lg_prof_sample
argument_list|)
decl_stmt|;
name|double
name|ratio
init|=
operator|(
operator|(
operator|(
name|double
operator|)
name|cnt_all
operator|->
name|curbytes
operator|)
operator|/
operator|(
name|double
operator|)
name|cnt_all
operator|->
name|curobjs
operator|)
operator|/
name|sample_period
decl_stmt|;
name|double
name|scale_factor
init|=
literal|1.0
operator|/
operator|(
literal|1.0
operator|-
name|exp
argument_list|(
operator|-
name|ratio
argument_list|)
operator|)
decl_stmt|;
name|uint64_t
name|curbytes
init|=
operator|(
name|uint64_t
operator|)
name|round
argument_list|(
operator|(
operator|(
name|double
operator|)
name|cnt_all
operator|->
name|curbytes
operator|)
operator|*
name|scale_factor
argument_list|)
decl_stmt|;
name|uint64_t
name|curobjs
init|=
operator|(
name|uint64_t
operator|)
name|round
argument_list|(
operator|(
operator|(
name|double
operator|)
name|cnt_all
operator|->
name|curobjs
operator|)
operator|*
name|scale_factor
argument_list|)
decl_stmt|;
name|malloc_printf
argument_list|(
literal|"<jemalloc>: Leak approximation summary: ~%"
name|FMTu64
literal|" byte%s, ~%"
name|FMTu64
literal|" object%s,>= %zu context%s\n"
argument_list|,
name|curbytes
argument_list|,
operator|(
name|curbytes
operator|!=
literal|1
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|curobjs
argument_list|,
operator|(
name|curobjs
operator|!=
literal|1
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|leak_ngctx
argument_list|,
operator|(
name|leak_ngctx
operator|!=
literal|1
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"<jemalloc>: Run jeprof on \"%s\" for leak detail\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_struct
struct|struct
name|prof_gctx_dump_iter_arg_s
block|{
name|tsdn_t
modifier|*
name|tsdn
decl_stmt|;
name|bool
name|propagate_err
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|prof_gctx_t
modifier|*
name|prof_gctx_dump_iter
parameter_list|(
name|prof_gctx_tree_t
modifier|*
name|gctxs
parameter_list|,
name|prof_gctx_t
modifier|*
name|gctx
parameter_list|,
name|void
modifier|*
name|opaque
parameter_list|)
block|{
name|prof_gctx_t
modifier|*
name|ret
decl_stmt|;
name|struct
name|prof_gctx_dump_iter_arg_s
modifier|*
name|arg
init|=
operator|(
expr|struct
name|prof_gctx_dump_iter_arg_s
operator|*
operator|)
name|opaque
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|arg
operator|->
name|tsdn
argument_list|,
name|gctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|prof_dump_gctx
argument_list|(
name|arg
operator|->
name|tsdn
argument_list|,
name|arg
operator|->
name|propagate_err
argument_list|,
name|gctx
argument_list|,
operator|&
name|gctx
operator|->
name|bt
argument_list|,
name|gctxs
argument_list|)
condition|)
block|{
name|ret
operator|=
name|gctx
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
name|ret
operator|=
name|NULL
expr_stmt|;
name|label_return
label|:
name|malloc_mutex_unlock
argument_list|(
name|arg
operator|->
name|tsdn
argument_list|,
name|gctx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|prof_dump_prep
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|prof_tdata_t
modifier|*
name|tdata
parameter_list|,
name|struct
name|prof_tdata_merge_iter_arg_s
modifier|*
name|prof_tdata_merge_iter_arg
parameter_list|,
name|struct
name|prof_gctx_merge_iter_arg_s
modifier|*
name|prof_gctx_merge_iter_arg
parameter_list|,
name|prof_gctx_tree_t
modifier|*
name|gctxs
parameter_list|)
block|{
name|size_t
name|tabind
decl_stmt|;
union|union
block|{
name|prof_gctx_t
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|v
decl_stmt|;
block|}
name|gctx
union|;
name|prof_enter
argument_list|(
name|tsd
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
comment|/* 	 * Put gctx's in limbo and clear their counters in preparation for 	 * summing. 	 */
name|gctx_tree_new
argument_list|(
name|gctxs
argument_list|)
expr_stmt|;
for|for
control|(
name|tabind
operator|=
literal|0
init|;
operator|!
name|ckh_iter
argument_list|(
operator|&
name|bt2gctx
argument_list|,
operator|&
name|tabind
argument_list|,
name|NULL
argument_list|,
operator|&
name|gctx
operator|.
name|v
argument_list|)
condition|;
control|)
block|{
name|prof_dump_gctx_prep
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|gctx
operator|.
name|p
argument_list|,
name|gctxs
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Iterate over tdatas, and for the non-expired ones snapshot their tctx 	 * stats and merge them into the associated gctx's. 	 */
name|prof_tdata_merge_iter_arg
operator|->
name|tsdn
operator|=
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|prof_tdata_merge_iter_arg
operator|->
name|cnt_all
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|prof_cnt_t
argument_list|)
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|tdatas_mtx
argument_list|)
expr_stmt|;
name|tdata_tree_iter
argument_list|(
operator|&
name|tdatas
argument_list|,
name|NULL
argument_list|,
name|prof_tdata_merge_iter
argument_list|,
operator|(
name|void
operator|*
operator|)
name|prof_tdata_merge_iter_arg
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|tdatas_mtx
argument_list|)
expr_stmt|;
comment|/* Merge tctx stats into gctx's. */
name|prof_gctx_merge_iter_arg
operator|->
name|tsdn
operator|=
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
name|prof_gctx_merge_iter_arg
operator|->
name|leak_ngctx
operator|=
literal|0
expr_stmt|;
name|gctx_tree_iter
argument_list|(
name|gctxs
argument_list|,
name|NULL
argument_list|,
name|prof_gctx_merge_iter
argument_list|,
operator|(
name|void
operator|*
operator|)
name|prof_gctx_merge_iter_arg
argument_list|)
expr_stmt|;
name|prof_leave
argument_list|(
name|tsd
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|prof_dump_file
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|bool
name|propagate_err
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|bool
name|leakcheck
parameter_list|,
name|prof_tdata_t
modifier|*
name|tdata
parameter_list|,
name|struct
name|prof_tdata_merge_iter_arg_s
modifier|*
name|prof_tdata_merge_iter_arg
parameter_list|,
name|struct
name|prof_gctx_merge_iter_arg_s
modifier|*
name|prof_gctx_merge_iter_arg
parameter_list|,
name|struct
name|prof_gctx_dump_iter_arg_s
modifier|*
name|prof_gctx_dump_iter_arg
parameter_list|,
name|prof_gctx_tree_t
modifier|*
name|gctxs
parameter_list|)
block|{
comment|/* Create dump file. */
if|if
condition|(
operator|(
name|prof_dump_fd
operator|=
name|prof_dump_open
argument_list|(
name|propagate_err
argument_list|,
name|filename
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|true
return|;
block|}
comment|/* Dump profile header. */
if|if
condition|(
name|prof_dump_header
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|propagate_err
argument_list|,
operator|&
name|prof_tdata_merge_iter_arg
operator|->
name|cnt_all
argument_list|)
condition|)
block|{
goto|goto
name|label_write_error
goto|;
block|}
comment|/* Dump per gctx profile stats. */
name|prof_gctx_dump_iter_arg
operator|->
name|tsdn
operator|=
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
name|prof_gctx_dump_iter_arg
operator|->
name|propagate_err
operator|=
name|propagate_err
expr_stmt|;
if|if
condition|(
name|gctx_tree_iter
argument_list|(
name|gctxs
argument_list|,
name|NULL
argument_list|,
name|prof_gctx_dump_iter
argument_list|,
operator|(
name|void
operator|*
operator|)
name|prof_gctx_dump_iter_arg
argument_list|)
operator|!=
name|NULL
condition|)
block|{
goto|goto
name|label_write_error
goto|;
block|}
comment|/* Dump /proc/<pid>/maps if possible. */
if|if
condition|(
name|prof_dump_maps
argument_list|(
name|propagate_err
argument_list|)
condition|)
block|{
goto|goto
name|label_write_error
goto|;
block|}
if|if
condition|(
name|prof_dump_close
argument_list|(
name|propagate_err
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
return|return
name|false
return|;
name|label_write_error
label|:
name|prof_dump_close
argument_list|(
name|propagate_err
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|prof_dump
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|bool
name|propagate_err
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|bool
name|leakcheck
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tsd_reentrancy_level_get
argument_list|(
name|tsd
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|prof_tdata_t
modifier|*
name|tdata
init|=
name|prof_tdata_get
argument_list|(
name|tsd
argument_list|,
name|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|tdata
operator|==
name|NULL
condition|)
block|{
return|return
name|true
return|;
block|}
name|pre_reentrancy
argument_list|(
name|tsd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|prof_dump_mtx
argument_list|)
expr_stmt|;
name|prof_gctx_tree_t
name|gctxs
decl_stmt|;
name|struct
name|prof_tdata_merge_iter_arg_s
name|prof_tdata_merge_iter_arg
decl_stmt|;
name|struct
name|prof_gctx_merge_iter_arg_s
name|prof_gctx_merge_iter_arg
decl_stmt|;
name|struct
name|prof_gctx_dump_iter_arg_s
name|prof_gctx_dump_iter_arg
decl_stmt|;
name|prof_dump_prep
argument_list|(
name|tsd
argument_list|,
name|tdata
argument_list|,
operator|&
name|prof_tdata_merge_iter_arg
argument_list|,
operator|&
name|prof_gctx_merge_iter_arg
argument_list|,
operator|&
name|gctxs
argument_list|)
expr_stmt|;
name|bool
name|err
init|=
name|prof_dump_file
argument_list|(
name|tsd
argument_list|,
name|propagate_err
argument_list|,
name|filename
argument_list|,
name|leakcheck
argument_list|,
name|tdata
argument_list|,
operator|&
name|prof_tdata_merge_iter_arg
argument_list|,
operator|&
name|prof_gctx_merge_iter_arg
argument_list|,
operator|&
name|prof_gctx_dump_iter_arg
argument_list|,
operator|&
name|gctxs
argument_list|)
decl_stmt|;
name|prof_gctx_finish
argument_list|(
name|tsd
argument_list|,
operator|&
name|gctxs
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|prof_dump_mtx
argument_list|)
expr_stmt|;
name|post_reentrancy
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
name|true
return|;
block|}
if|if
condition|(
name|leakcheck
condition|)
block|{
name|prof_leakcheck
argument_list|(
operator|&
name|prof_tdata_merge_iter_arg
operator|.
name|cnt_all
argument_list|,
name|prof_gctx_merge_iter_arg
operator|.
name|leak_ngctx
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_JET
end_ifdef

begin_function
name|void
name|prof_cnt_all
parameter_list|(
name|uint64_t
modifier|*
name|curobjs
parameter_list|,
name|uint64_t
modifier|*
name|curbytes
parameter_list|,
name|uint64_t
modifier|*
name|accumobjs
parameter_list|,
name|uint64_t
modifier|*
name|accumbytes
parameter_list|)
block|{
name|tsd_t
modifier|*
name|tsd
decl_stmt|;
name|prof_tdata_t
modifier|*
name|tdata
decl_stmt|;
name|struct
name|prof_tdata_merge_iter_arg_s
name|prof_tdata_merge_iter_arg
decl_stmt|;
name|struct
name|prof_gctx_merge_iter_arg_s
name|prof_gctx_merge_iter_arg
decl_stmt|;
name|prof_gctx_tree_t
name|gctxs
decl_stmt|;
name|tsd
operator|=
name|tsd_fetch
argument_list|()
expr_stmt|;
name|tdata
operator|=
name|prof_tdata_get
argument_list|(
name|tsd
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdata
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|curobjs
operator|!=
name|NULL
condition|)
block|{
operator|*
name|curobjs
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|curbytes
operator|!=
name|NULL
condition|)
block|{
operator|*
name|curbytes
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|accumobjs
operator|!=
name|NULL
condition|)
block|{
operator|*
name|accumobjs
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|accumbytes
operator|!=
name|NULL
condition|)
block|{
operator|*
name|accumbytes
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
name|prof_dump_prep
argument_list|(
name|tsd
argument_list|,
name|tdata
argument_list|,
operator|&
name|prof_tdata_merge_iter_arg
argument_list|,
operator|&
name|prof_gctx_merge_iter_arg
argument_list|,
operator|&
name|gctxs
argument_list|)
expr_stmt|;
name|prof_gctx_finish
argument_list|(
name|tsd
argument_list|,
operator|&
name|gctxs
argument_list|)
expr_stmt|;
if|if
condition|(
name|curobjs
operator|!=
name|NULL
condition|)
block|{
operator|*
name|curobjs
operator|=
name|prof_tdata_merge_iter_arg
operator|.
name|cnt_all
operator|.
name|curobjs
expr_stmt|;
block|}
if|if
condition|(
name|curbytes
operator|!=
name|NULL
condition|)
block|{
operator|*
name|curbytes
operator|=
name|prof_tdata_merge_iter_arg
operator|.
name|cnt_all
operator|.
name|curbytes
expr_stmt|;
block|}
if|if
condition|(
name|accumobjs
operator|!=
name|NULL
condition|)
block|{
operator|*
name|accumobjs
operator|=
name|prof_tdata_merge_iter_arg
operator|.
name|cnt_all
operator|.
name|accumobjs
expr_stmt|;
block|}
if|if
condition|(
name|accumbytes
operator|!=
name|NULL
condition|)
block|{
operator|*
name|accumbytes
operator|=
name|prof_tdata_merge_iter_arg
operator|.
name|cnt_all
operator|.
name|accumbytes
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DUMP_FILENAME_BUFSIZE
value|(PATH_MAX + 1)
end_define

begin_define
define|#
directive|define
name|VSEQ_INVALID
value|UINT64_C(0xffffffffffffffff)
end_define

begin_function
specifier|static
name|void
name|prof_dump_filename
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|char
name|v
parameter_list|,
name|uint64_t
name|vseq
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
if|if
condition|(
name|vseq
operator|!=
name|VSEQ_INVALID
condition|)
block|{
comment|/* "<prefix>.<pid>.<seq>.v<vseq>.heap" */
name|malloc_snprintf
argument_list|(
name|filename
argument_list|,
name|DUMP_FILENAME_BUFSIZE
argument_list|,
literal|"%s.%d.%"
name|FMTu64
literal|".%c%"
name|FMTu64
literal|".heap"
argument_list|,
name|opt_prof_prefix
argument_list|,
name|prof_getpid
argument_list|()
argument_list|,
name|prof_dump_seq
argument_list|,
name|v
argument_list|,
name|vseq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* "<prefix>.<pid>.<seq>.<v>.heap" */
name|malloc_snprintf
argument_list|(
name|filename
argument_list|,
name|DUMP_FILENAME_BUFSIZE
argument_list|,
literal|"%s.%d.%"
name|FMTu64
literal|".%c.heap"
argument_list|,
name|opt_prof_prefix
argument_list|,
name|prof_getpid
argument_list|()
argument_list|,
name|prof_dump_seq
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
name|prof_dump_seq
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|prof_fdump
parameter_list|(
name|void
parameter_list|)
block|{
name|tsd_t
modifier|*
name|tsd
decl_stmt|;
name|char
name|filename
index|[
name|DUMP_FILENAME_BUFSIZE
index|]
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|opt_prof_final
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|opt_prof_prefix
index|[
literal|0
index|]
operator|!=
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prof_booted
condition|)
block|{
return|return;
block|}
name|tsd
operator|=
name|tsd_fetch
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|tsd_reentrancy_level_get
argument_list|(
name|tsd
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|prof_dump_seq_mtx
argument_list|)
expr_stmt|;
name|prof_dump_filename
argument_list|(
name|filename
argument_list|,
literal|'f'
argument_list|,
name|VSEQ_INVALID
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|prof_dump_seq_mtx
argument_list|)
expr_stmt|;
name|prof_dump
argument_list|(
name|tsd
argument_list|,
name|false
argument_list|,
name|filename
argument_list|,
name|opt_prof_leak
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|prof_accum_init
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|prof_accum_t
modifier|*
name|prof_accum
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|JEMALLOC_ATOMIC_U64
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|prof_accum
operator|->
name|mtx
argument_list|,
literal|"prof_accum"
argument_list|,
name|WITNESS_RANK_PROF_ACCUM
argument_list|,
name|malloc_mutex_rank_exclusive
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|prof_accum
operator|->
name|accumbytes
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|atomic_store_u64
argument_list|(
operator|&
name|prof_accum
operator|->
name|accumbytes
argument_list|,
literal|0
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|false
return|;
block|}
end_function

begin_function
name|void
name|prof_idump
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
block|{
name|tsd_t
modifier|*
name|tsd
decl_stmt|;
name|prof_tdata_t
modifier|*
name|tdata
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prof_booted
operator|||
name|tsdn_null
argument_list|(
name|tsdn
argument_list|)
condition|)
block|{
return|return;
block|}
name|tsd
operator|=
name|tsdn_tsd
argument_list|(
name|tsdn
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsd_reentrancy_level_get
argument_list|(
name|tsd
argument_list|)
operator|>
literal|0
condition|)
block|{
return|return;
block|}
name|tdata
operator|=
name|prof_tdata_get
argument_list|(
name|tsd
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdata
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|tdata
operator|->
name|enq
condition|)
block|{
name|tdata
operator|->
name|enq_idump
operator|=
name|true
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|opt_prof_prefix
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|char
name|filename
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|prof_dump_seq_mtx
argument_list|)
expr_stmt|;
name|prof_dump_filename
argument_list|(
name|filename
argument_list|,
literal|'i'
argument_list|,
name|prof_dump_iseq
argument_list|)
expr_stmt|;
name|prof_dump_iseq
operator|++
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|prof_dump_seq_mtx
argument_list|)
expr_stmt|;
name|prof_dump
argument_list|(
name|tsd
argument_list|,
name|false
argument_list|,
name|filename
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|bool
name|prof_mdump
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tsd_reentrancy_level_get
argument_list|(
name|tsd
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opt_prof
operator|||
operator|!
name|prof_booted
condition|)
block|{
return|return
name|true
return|;
block|}
name|char
name|filename_buf
index|[
name|DUMP_FILENAME_BUFSIZE
index|]
decl_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
block|{
comment|/* No filename specified, so automatically generate one. */
if|if
condition|(
name|opt_prof_prefix
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
return|return
name|true
return|;
block|}
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|prof_dump_seq_mtx
argument_list|)
expr_stmt|;
name|prof_dump_filename
argument_list|(
name|filename_buf
argument_list|,
literal|'m'
argument_list|,
name|prof_dump_mseq
argument_list|)
expr_stmt|;
name|prof_dump_mseq
operator|++
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|prof_dump_seq_mtx
argument_list|)
expr_stmt|;
name|filename
operator|=
name|filename_buf
expr_stmt|;
block|}
return|return
name|prof_dump
argument_list|(
name|tsd
argument_list|,
name|true
argument_list|,
name|filename
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|prof_gdump
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
block|{
name|tsd_t
modifier|*
name|tsd
decl_stmt|;
name|prof_tdata_t
modifier|*
name|tdata
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prof_booted
operator|||
name|tsdn_null
argument_list|(
name|tsdn
argument_list|)
condition|)
block|{
return|return;
block|}
name|tsd
operator|=
name|tsdn_tsd
argument_list|(
name|tsdn
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsd_reentrancy_level_get
argument_list|(
name|tsd
argument_list|)
operator|>
literal|0
condition|)
block|{
return|return;
block|}
name|tdata
operator|=
name|prof_tdata_get
argument_list|(
name|tsd
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdata
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|tdata
operator|->
name|enq
condition|)
block|{
name|tdata
operator|->
name|enq_gdump
operator|=
name|true
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|opt_prof_prefix
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|char
name|filename
index|[
name|DUMP_FILENAME_BUFSIZE
index|]
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_dump_seq_mtx
argument_list|)
expr_stmt|;
name|prof_dump_filename
argument_list|(
name|filename
argument_list|,
literal|'u'
argument_list|,
name|prof_dump_useq
argument_list|)
expr_stmt|;
name|prof_dump_useq
operator|++
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_dump_seq_mtx
argument_list|)
expr_stmt|;
name|prof_dump
argument_list|(
name|tsd
argument_list|,
name|false
argument_list|,
name|filename
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|prof_bt_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|size_t
name|r_hash
index|[
literal|2
index|]
parameter_list|)
block|{
name|prof_bt_t
modifier|*
name|bt
init|=
operator|(
name|prof_bt_t
operator|*
operator|)
name|key
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|hash
argument_list|(
name|bt
operator|->
name|vec
argument_list|,
name|bt
operator|->
name|len
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
literal|0x94122f33U
argument_list|,
name|r_hash
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|prof_bt_keycomp
parameter_list|(
specifier|const
name|void
modifier|*
name|k1
parameter_list|,
specifier|const
name|void
modifier|*
name|k2
parameter_list|)
block|{
specifier|const
name|prof_bt_t
modifier|*
name|bt1
init|=
operator|(
name|prof_bt_t
operator|*
operator|)
name|k1
decl_stmt|;
specifier|const
name|prof_bt_t
modifier|*
name|bt2
init|=
operator|(
name|prof_bt_t
operator|*
operator|)
name|k2
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt1
operator|->
name|len
operator|!=
name|bt2
operator|->
name|len
condition|)
block|{
return|return
name|false
return|;
block|}
return|return
operator|(
name|memcmp
argument_list|(
name|bt1
operator|->
name|vec
argument_list|,
name|bt2
operator|->
name|vec
argument_list|,
name|bt1
operator|->
name|len
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|prof_thr_uid_alloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
block|{
name|uint64_t
name|thr_uid
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|next_thr_uid_mtx
argument_list|)
expr_stmt|;
name|thr_uid
operator|=
name|next_thr_uid
expr_stmt|;
name|next_thr_uid
operator|++
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|next_thr_uid_mtx
argument_list|)
expr_stmt|;
return|return
name|thr_uid
return|;
block|}
end_function

begin_function
specifier|static
name|prof_tdata_t
modifier|*
name|prof_tdata_init_impl
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|uint64_t
name|thr_uid
parameter_list|,
name|uint64_t
name|thr_discrim
parameter_list|,
name|char
modifier|*
name|thread_name
parameter_list|,
name|bool
name|active
parameter_list|)
block|{
name|prof_tdata_t
modifier|*
name|tdata
decl_stmt|;
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
comment|/* Initialize an empty cache for this thread. */
name|tdata
operator|=
operator|(
name|prof_tdata_t
operator|*
operator|)
name|iallocztm
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|prof_tdata_t
argument_list|)
argument_list|,
name|sz_size2index
argument_list|(
sizeof|sizeof
argument_list|(
name|prof_tdata_t
argument_list|)
argument_list|)
argument_list|,
name|false
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|arena_get
argument_list|(
name|TSDN_NULL
argument_list|,
literal|0
argument_list|,
name|true
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdata
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|tdata
operator|->
name|lock
operator|=
name|prof_tdata_mutex_choose
argument_list|(
name|thr_uid
argument_list|)
expr_stmt|;
name|tdata
operator|->
name|thr_uid
operator|=
name|thr_uid
expr_stmt|;
name|tdata
operator|->
name|thr_discrim
operator|=
name|thr_discrim
expr_stmt|;
name|tdata
operator|->
name|thread_name
operator|=
name|thread_name
expr_stmt|;
name|tdata
operator|->
name|attached
operator|=
name|true
expr_stmt|;
name|tdata
operator|->
name|expired
operator|=
name|false
expr_stmt|;
name|tdata
operator|->
name|tctx_uid_next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ckh_new
argument_list|(
name|tsd
argument_list|,
operator|&
name|tdata
operator|->
name|bt2tctx
argument_list|,
name|PROF_CKH_MINITEMS
argument_list|,
name|prof_bt_hash
argument_list|,
name|prof_bt_keycomp
argument_list|)
condition|)
block|{
name|idalloctm
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tdata
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|tdata
operator|->
name|prng_state
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|tdata
expr_stmt|;
name|prof_sample_threshold_update
argument_list|(
name|tdata
argument_list|)
expr_stmt|;
name|tdata
operator|->
name|enq
operator|=
name|false
expr_stmt|;
name|tdata
operator|->
name|enq_idump
operator|=
name|false
expr_stmt|;
name|tdata
operator|->
name|enq_gdump
operator|=
name|false
expr_stmt|;
name|tdata
operator|->
name|dumping
operator|=
name|false
expr_stmt|;
name|tdata
operator|->
name|active
operator|=
name|active
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|tdatas_mtx
argument_list|)
expr_stmt|;
name|tdata_tree_insert
argument_list|(
operator|&
name|tdatas
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|tdatas_mtx
argument_list|)
expr_stmt|;
return|return
name|tdata
return|;
block|}
end_function

begin_function
name|prof_tdata_t
modifier|*
name|prof_tdata_init
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|)
block|{
return|return
name|prof_tdata_init_impl
argument_list|(
name|tsd
argument_list|,
name|prof_thr_uid_alloc
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|prof_thread_active_init_get
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|prof_tdata_should_destroy_unlocked
parameter_list|(
name|prof_tdata_t
modifier|*
name|tdata
parameter_list|,
name|bool
name|even_if_attached
parameter_list|)
block|{
if|if
condition|(
name|tdata
operator|->
name|attached
operator|&&
operator|!
name|even_if_attached
condition|)
block|{
return|return
name|false
return|;
block|}
if|if
condition|(
name|ckh_count
argument_list|(
operator|&
name|tdata
operator|->
name|bt2tctx
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|prof_tdata_should_destroy
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|prof_tdata_t
modifier|*
name|tdata
parameter_list|,
name|bool
name|even_if_attached
parameter_list|)
block|{
name|malloc_mutex_assert_owner
argument_list|(
name|tsdn
argument_list|,
name|tdata
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|prof_tdata_should_destroy_unlocked
argument_list|(
name|tdata
argument_list|,
name|even_if_attached
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|prof_tdata_destroy_locked
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|prof_tdata_t
modifier|*
name|tdata
parameter_list|,
name|bool
name|even_if_attached
parameter_list|)
block|{
name|malloc_mutex_assert_owner
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|tdatas_mtx
argument_list|)
expr_stmt|;
name|tdata_tree_remove
argument_list|(
operator|&
name|tdatas
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|prof_tdata_should_destroy_unlocked
argument_list|(
name|tdata
argument_list|,
name|even_if_attached
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdata
operator|->
name|thread_name
operator|!=
name|NULL
condition|)
block|{
name|idalloctm
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tdata
operator|->
name|thread_name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|ckh_delete
argument_list|(
name|tsd
argument_list|,
operator|&
name|tdata
operator|->
name|bt2tctx
argument_list|)
expr_stmt|;
name|idalloctm
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tdata
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|prof_tdata_destroy
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|prof_tdata_t
modifier|*
name|tdata
parameter_list|,
name|bool
name|even_if_attached
parameter_list|)
block|{
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|tdatas_mtx
argument_list|)
expr_stmt|;
name|prof_tdata_destroy_locked
argument_list|(
name|tsd
argument_list|,
name|tdata
argument_list|,
name|even_if_attached
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|tdatas_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|prof_tdata_detach
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|prof_tdata_t
modifier|*
name|tdata
parameter_list|)
block|{
name|bool
name|destroy_tdata
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tdata
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdata
operator|->
name|attached
condition|)
block|{
name|destroy_tdata
operator|=
name|prof_tdata_should_destroy
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tdata
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* 		 * Only detach if !destroy_tdata, because detaching would allow 		 * another thread to win the race to destroy tdata. 		 */
if|if
condition|(
operator|!
name|destroy_tdata
condition|)
block|{
name|tdata
operator|->
name|attached
operator|=
name|false
expr_stmt|;
block|}
name|tsd_prof_tdata_set
argument_list|(
name|tsd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|destroy_tdata
operator|=
name|false
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tdata
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|destroy_tdata
condition|)
block|{
name|prof_tdata_destroy
argument_list|(
name|tsd
argument_list|,
name|tdata
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|prof_tdata_t
modifier|*
name|prof_tdata_reinit
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|prof_tdata_t
modifier|*
name|tdata
parameter_list|)
block|{
name|uint64_t
name|thr_uid
init|=
name|tdata
operator|->
name|thr_uid
decl_stmt|;
name|uint64_t
name|thr_discrim
init|=
name|tdata
operator|->
name|thr_discrim
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|thread_name
init|=
operator|(
name|tdata
operator|->
name|thread_name
operator|!=
name|NULL
operator|)
condition|?
name|prof_thread_name_alloc
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tdata
operator|->
name|thread_name
argument_list|)
else|:
name|NULL
decl_stmt|;
name|bool
name|active
init|=
name|tdata
operator|->
name|active
decl_stmt|;
name|prof_tdata_detach
argument_list|(
name|tsd
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
return|return
name|prof_tdata_init_impl
argument_list|(
name|tsd
argument_list|,
name|thr_uid
argument_list|,
name|thr_discrim
argument_list|,
name|thread_name
argument_list|,
name|active
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|prof_tdata_expire
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|prof_tdata_t
modifier|*
name|tdata
parameter_list|)
block|{
name|bool
name|destroy_tdata
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
name|tdata
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tdata
operator|->
name|expired
condition|)
block|{
name|tdata
operator|->
name|expired
operator|=
name|true
expr_stmt|;
name|destroy_tdata
operator|=
name|tdata
operator|->
name|attached
condition|?
name|false
else|:
name|prof_tdata_should_destroy
argument_list|(
name|tsdn
argument_list|,
name|tdata
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|destroy_tdata
operator|=
name|false
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
name|tdata
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|destroy_tdata
return|;
block|}
end_function

begin_function
specifier|static
name|prof_tdata_t
modifier|*
name|prof_tdata_reset_iter
parameter_list|(
name|prof_tdata_tree_t
modifier|*
name|tdatas
parameter_list|,
name|prof_tdata_t
modifier|*
name|tdata
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|tsdn_t
modifier|*
name|tsdn
init|=
operator|(
name|tsdn_t
operator|*
operator|)
name|arg
decl_stmt|;
return|return
operator|(
name|prof_tdata_expire
argument_list|(
name|tsdn
argument_list|,
name|tdata
argument_list|)
condition|?
name|tdata
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|prof_reset
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|size_t
name|lg_sample
parameter_list|)
block|{
name|prof_tdata_t
modifier|*
name|next
decl_stmt|;
name|assert
argument_list|(
name|lg_sample
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|prof_dump_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|tdatas_mtx
argument_list|)
expr_stmt|;
name|lg_prof_sample
operator|=
name|lg_sample
expr_stmt|;
name|next
operator|=
name|NULL
expr_stmt|;
do|do
block|{
name|prof_tdata_t
modifier|*
name|to_destroy
init|=
name|tdata_tree_iter
argument_list|(
operator|&
name|tdatas
argument_list|,
name|next
argument_list|,
name|prof_tdata_reset_iter
argument_list|,
operator|(
name|void
operator|*
operator|)
name|tsd
argument_list|)
decl_stmt|;
if|if
condition|(
name|to_destroy
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|tdata_tree_next
argument_list|(
operator|&
name|tdatas
argument_list|,
name|to_destroy
argument_list|)
expr_stmt|;
name|prof_tdata_destroy_locked
argument_list|(
name|tsd
argument_list|,
name|to_destroy
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
do|while
condition|(
name|next
operator|!=
name|NULL
condition|)
do|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|tdatas_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|prof_dump_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|prof_tdata_cleanup
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|)
block|{
name|prof_tdata_t
modifier|*
name|tdata
decl_stmt|;
if|if
condition|(
operator|!
name|config_prof
condition|)
block|{
return|return;
block|}
name|tdata
operator|=
name|tsd_prof_tdata_get
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdata
operator|!=
name|NULL
condition|)
block|{
name|prof_tdata_detach
argument_list|(
name|tsd
argument_list|,
name|tdata
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|bool
name|prof_active_get
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
block|{
name|bool
name|prof_active_current
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_active_mtx
argument_list|)
expr_stmt|;
name|prof_active_current
operator|=
name|prof_active
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_active_mtx
argument_list|)
expr_stmt|;
return|return
name|prof_active_current
return|;
block|}
end_function

begin_function
name|bool
name|prof_active_set
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|bool
name|active
parameter_list|)
block|{
name|bool
name|prof_active_old
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_active_mtx
argument_list|)
expr_stmt|;
name|prof_active_old
operator|=
name|prof_active
expr_stmt|;
name|prof_active
operator|=
name|active
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_active_mtx
argument_list|)
expr_stmt|;
return|return
name|prof_active_old
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|prof_thread_name_get
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|)
block|{
name|prof_tdata_t
modifier|*
name|tdata
decl_stmt|;
name|tdata
operator|=
name|prof_tdata_get
argument_list|(
name|tsd
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdata
operator|==
name|NULL
condition|)
block|{
return|return
literal|""
return|;
block|}
return|return
operator|(
name|tdata
operator|->
name|thread_name
operator|!=
name|NULL
condition|?
name|tdata
operator|->
name|thread_name
else|:
literal|""
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|prof_thread_name_alloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
specifier|const
name|char
modifier|*
name|thread_name
parameter_list|)
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|if
condition|(
name|thread_name
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|size
operator|=
name|strlen
argument_list|(
name|thread_name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
return|return
literal|""
return|;
block|}
name|ret
operator|=
name|iallocztm
argument_list|(
name|tsdn
argument_list|,
name|size
argument_list|,
name|sz_size2index
argument_list|(
name|size
argument_list|)
argument_list|,
name|false
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|arena_get
argument_list|(
name|TSDN_NULL
argument_list|,
literal|0
argument_list|,
name|true
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|memcpy
argument_list|(
name|ret
argument_list|,
name|thread_name
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|prof_thread_name_set
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
specifier|const
name|char
modifier|*
name|thread_name
parameter_list|)
block|{
name|prof_tdata_t
modifier|*
name|tdata
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|tdata
operator|=
name|prof_tdata_get
argument_list|(
name|tsd
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdata
operator|==
name|NULL
condition|)
block|{
return|return
name|EAGAIN
return|;
block|}
comment|/* Validate input. */
if|if
condition|(
name|thread_name
operator|==
name|NULL
condition|)
block|{
return|return
name|EFAULT
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|thread_name
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|thread_name
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|isgraph
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|isblank
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
name|EFAULT
return|;
block|}
block|}
name|s
operator|=
name|prof_thread_name_alloc
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|thread_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
return|return
name|EAGAIN
return|;
block|}
if|if
condition|(
name|tdata
operator|->
name|thread_name
operator|!=
name|NULL
condition|)
block|{
name|idalloctm
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tdata
operator|->
name|thread_name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|tdata
operator|->
name|thread_name
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|>
literal|0
condition|)
block|{
name|tdata
operator|->
name|thread_name
operator|=
name|s
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|bool
name|prof_thread_active_get
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|)
block|{
name|prof_tdata_t
modifier|*
name|tdata
decl_stmt|;
name|tdata
operator|=
name|prof_tdata_get
argument_list|(
name|tsd
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdata
operator|==
name|NULL
condition|)
block|{
return|return
name|false
return|;
block|}
return|return
name|tdata
operator|->
name|active
return|;
block|}
end_function

begin_function
name|bool
name|prof_thread_active_set
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|bool
name|active
parameter_list|)
block|{
name|prof_tdata_t
modifier|*
name|tdata
decl_stmt|;
name|tdata
operator|=
name|prof_tdata_get
argument_list|(
name|tsd
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdata
operator|==
name|NULL
condition|)
block|{
return|return
name|true
return|;
block|}
name|tdata
operator|->
name|active
operator|=
name|active
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
name|bool
name|prof_thread_active_init_get
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
block|{
name|bool
name|active_init
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_thread_active_init_mtx
argument_list|)
expr_stmt|;
name|active_init
operator|=
name|prof_thread_active_init
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_thread_active_init_mtx
argument_list|)
expr_stmt|;
return|return
name|active_init
return|;
block|}
end_function

begin_function
name|bool
name|prof_thread_active_init_set
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|bool
name|active_init
parameter_list|)
block|{
name|bool
name|active_init_old
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_thread_active_init_mtx
argument_list|)
expr_stmt|;
name|active_init_old
operator|=
name|prof_thread_active_init
expr_stmt|;
name|prof_thread_active_init
operator|=
name|active_init
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_thread_active_init_mtx
argument_list|)
expr_stmt|;
return|return
name|active_init_old
return|;
block|}
end_function

begin_function
name|bool
name|prof_gdump_get
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
block|{
name|bool
name|prof_gdump_current
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_gdump_mtx
argument_list|)
expr_stmt|;
name|prof_gdump_current
operator|=
name|prof_gdump_val
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_gdump_mtx
argument_list|)
expr_stmt|;
return|return
name|prof_gdump_current
return|;
block|}
end_function

begin_function
name|bool
name|prof_gdump_set
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|bool
name|gdump
parameter_list|)
block|{
name|bool
name|prof_gdump_old
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_gdump_mtx
argument_list|)
expr_stmt|;
name|prof_gdump_old
operator|=
name|prof_gdump_val
expr_stmt|;
name|prof_gdump_val
operator|=
name|gdump
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_gdump_mtx
argument_list|)
expr_stmt|;
return|return
name|prof_gdump_old
return|;
block|}
end_function

begin_function
name|void
name|prof_boot0
parameter_list|(
name|void
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|opt_prof_prefix
argument_list|,
name|PROF_PREFIX_DEFAULT
argument_list|,
sizeof|sizeof
argument_list|(
name|PROF_PREFIX_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|prof_boot1
parameter_list|(
name|void
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
comment|/* 	 * opt_prof must be in its final state before any arenas are 	 * initialized, so this function must be executed early. 	 */
if|if
condition|(
name|opt_prof_leak
operator|&&
operator|!
name|opt_prof
condition|)
block|{
comment|/* 		 * Enable opt_prof, but in such a way that profiles are never 		 * automatically dumped. 		 */
name|opt_prof
operator|=
name|true
expr_stmt|;
name|opt_prof_gdump
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt_prof
condition|)
block|{
if|if
condition|(
name|opt_lg_prof_interval
operator|>=
literal|0
condition|)
block|{
name|prof_interval
operator|=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
literal|1U
operator|)
operator|<<
name|opt_lg_prof_interval
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|bool
name|prof_boot2
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_prof
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_prof
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
name|lg_prof_sample
operator|=
name|opt_lg_prof_sample
expr_stmt|;
name|prof_active
operator|=
name|opt_prof_active
expr_stmt|;
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|prof_active_mtx
argument_list|,
literal|"prof_active"
argument_list|,
name|WITNESS_RANK_PROF_ACTIVE
argument_list|,
name|malloc_mutex_rank_exclusive
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|prof_gdump_val
operator|=
name|opt_prof_gdump
expr_stmt|;
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|prof_gdump_mtx
argument_list|,
literal|"prof_gdump"
argument_list|,
name|WITNESS_RANK_PROF_GDUMP
argument_list|,
name|malloc_mutex_rank_exclusive
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|prof_thread_active_init
operator|=
name|opt_prof_thread_active_init
expr_stmt|;
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|prof_thread_active_init_mtx
argument_list|,
literal|"prof_thread_active_init"
argument_list|,
name|WITNESS_RANK_PROF_THREAD_ACTIVE_INIT
argument_list|,
name|malloc_mutex_rank_exclusive
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
if|if
condition|(
name|ckh_new
argument_list|(
name|tsd
argument_list|,
operator|&
name|bt2gctx
argument_list|,
name|PROF_CKH_MINITEMS
argument_list|,
name|prof_bt_hash
argument_list|,
name|prof_bt_keycomp
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|bt2gctx_mtx
argument_list|,
literal|"prof_bt2gctx"
argument_list|,
name|WITNESS_RANK_PROF_BT2GCTX
argument_list|,
name|malloc_mutex_rank_exclusive
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|tdata_tree_new
argument_list|(
operator|&
name|tdatas
argument_list|)
expr_stmt|;
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|tdatas_mtx
argument_list|,
literal|"prof_tdatas"
argument_list|,
name|WITNESS_RANK_PROF_TDATAS
argument_list|,
name|malloc_mutex_rank_exclusive
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|next_thr_uid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|next_thr_uid_mtx
argument_list|,
literal|"prof_next_thr_uid"
argument_list|,
name|WITNESS_RANK_PROF_NEXT_THR_UID
argument_list|,
name|malloc_mutex_rank_exclusive
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|prof_dump_seq_mtx
argument_list|,
literal|"prof_dump_seq"
argument_list|,
name|WITNESS_RANK_PROF_DUMP_SEQ
argument_list|,
name|malloc_mutex_rank_exclusive
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|prof_dump_mtx
argument_list|,
literal|"prof_dump"
argument_list|,
name|WITNESS_RANK_PROF_DUMP
argument_list|,
name|malloc_mutex_rank_exclusive
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
if|if
condition|(
name|opt_prof_final
operator|&&
name|opt_prof_prefix
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|atexit
argument_list|(
name|prof_fdump
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Error in atexit()\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|gctx_locks
operator|=
operator|(
name|malloc_mutex_t
operator|*
operator|)
name|base_alloc
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|b0get
argument_list|()
argument_list|,
name|PROF_NCTX_LOCKS
operator|*
sizeof|sizeof
argument_list|(
name|malloc_mutex_t
argument_list|)
argument_list|,
name|CACHELINE
argument_list|)
expr_stmt|;
if|if
condition|(
name|gctx_locks
operator|==
name|NULL
condition|)
block|{
return|return
name|true
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PROF_NCTX_LOCKS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|gctx_locks
index|[
name|i
index|]
argument_list|,
literal|"prof_gctx"
argument_list|,
name|WITNESS_RANK_PROF_GCTX
argument_list|,
name|malloc_mutex_rank_exclusive
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
block|}
name|tdata_locks
operator|=
operator|(
name|malloc_mutex_t
operator|*
operator|)
name|base_alloc
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|b0get
argument_list|()
argument_list|,
name|PROF_NTDATA_LOCKS
operator|*
sizeof|sizeof
argument_list|(
name|malloc_mutex_t
argument_list|)
argument_list|,
name|CACHELINE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdata_locks
operator|==
name|NULL
condition|)
block|{
return|return
name|true
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PROF_NTDATA_LOCKS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|tdata_locks
index|[
name|i
index|]
argument_list|,
literal|"prof_tdata"
argument_list|,
name|WITNESS_RANK_PROF_TDATA
argument_list|,
name|malloc_mutex_rank_exclusive
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|JEMALLOC_PROF_LIBGCC
comment|/* 	 * Cause the backtracing machinery to allocate its internal state 	 * before enabling profiling. 	 */
name|_Unwind_Backtrace
argument_list|(
name|prof_unwind_init_callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|prof_booted
operator|=
name|true
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
name|void
name|prof_prefork0
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
block|{
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
name|malloc_mutex_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_dump_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bt2gctx_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|tdatas_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PROF_NTDATA_LOCKS
condition|;
name|i
operator|++
control|)
block|{
name|malloc_mutex_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|tdata_locks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PROF_NCTX_LOCKS
condition|;
name|i
operator|++
control|)
block|{
name|malloc_mutex_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|gctx_locks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|prof_prefork1
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
block|{
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
block|{
name|malloc_mutex_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_active_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_dump_seq_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_gdump_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|next_thr_uid_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_thread_active_init_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|prof_postfork_parent
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
block|{
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
name|malloc_mutex_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_thread_active_init_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|next_thr_uid_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_gdump_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_dump_seq_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_active_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PROF_NCTX_LOCKS
condition|;
name|i
operator|++
control|)
block|{
name|malloc_mutex_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|gctx_locks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PROF_NTDATA_LOCKS
condition|;
name|i
operator|++
control|)
block|{
name|malloc_mutex_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|tdata_locks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|tdatas_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bt2gctx_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_dump_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|prof_postfork_child
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
block|{
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
name|malloc_mutex_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_thread_active_init_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|next_thr_uid_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_gdump_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_dump_seq_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_active_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PROF_NCTX_LOCKS
condition|;
name|i
operator|++
control|)
block|{
name|malloc_mutex_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|gctx_locks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PROF_NTDATA_LOCKS
condition|;
name|i
operator|++
control|)
block|{
name|malloc_mutex_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|tdata_locks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|tdatas_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bt2gctx_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|prof_dump_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

end_unit

