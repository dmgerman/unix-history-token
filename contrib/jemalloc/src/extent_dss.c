begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|JEMALLOC_EXTENT_DSS_C_
end_define

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_preamble.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_internal_includes.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/assert.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/extent_dss.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/spin.h"
end_include

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/* Data. */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|opt_dss
init|=
name|DSS_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|dss_prec_names
index|[]
init|=
block|{
literal|"disabled"
block|,
literal|"primary"
block|,
literal|"secondary"
block|,
literal|"N/A"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Current dss precedence default, used when creating new arenas.  NB: This is  * stored as unsigned rather than dss_prec_t because in principle there's no  * guarantee that sizeof(dss_prec_t) is the same as sizeof(unsigned), and we use  * atomic operations to synchronize the setting.  */
end_comment

begin_decl_stmt
specifier|static
name|atomic_u_t
name|dss_prec_default
init|=
name|ATOMIC_INIT
argument_list|(
operator|(
name|unsigned
operator|)
name|DSS_PREC_DEFAULT
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Base address of the DSS. */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|dss_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Atomic boolean indicating whether a thread is currently extending DSS. */
end_comment

begin_decl_stmt
specifier|static
name|atomic_b_t
name|dss_extending
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Atomic boolean indicating whether the DSS is exhausted. */
end_comment

begin_decl_stmt
specifier|static
name|atomic_b_t
name|dss_exhausted
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Atomic current upper limit on DSS addresses. */
end_comment

begin_decl_stmt
specifier|static
name|atomic_p_t
name|dss_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************/
end_comment

begin_function
specifier|static
name|void
modifier|*
name|extent_dss_sbrk
parameter_list|(
name|intptr_t
name|increment
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|JEMALLOC_DSS
return|return
name|sbrk
argument_list|(
name|increment
argument_list|)
return|;
else|#
directive|else
name|not_implemented
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|dss_prec_t
name|extent_dss_prec_get
parameter_list|(
name|void
parameter_list|)
block|{
name|dss_prec_t
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|have_dss
condition|)
block|{
return|return
name|dss_prec_disabled
return|;
block|}
name|ret
operator|=
operator|(
name|dss_prec_t
operator|)
name|atomic_load_u
argument_list|(
operator|&
name|dss_prec_default
argument_list|,
name|ATOMIC_ACQUIRE
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|bool
name|extent_dss_prec_set
parameter_list|(
name|dss_prec_t
name|dss_prec
parameter_list|)
block|{
if|if
condition|(
operator|!
name|have_dss
condition|)
block|{
return|return
operator|(
name|dss_prec
operator|!=
name|dss_prec_disabled
operator|)
return|;
block|}
name|atomic_store_u
argument_list|(
operator|&
name|dss_prec_default
argument_list|,
operator|(
name|unsigned
operator|)
name|dss_prec
argument_list|,
name|ATOMIC_RELEASE
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|extent_dss_extending_start
parameter_list|(
name|void
parameter_list|)
block|{
name|spin_t
name|spinner
init|=
name|SPIN_INITIALIZER
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|bool
name|expected
init|=
name|false
decl_stmt|;
if|if
condition|(
name|atomic_compare_exchange_weak_b
argument_list|(
operator|&
name|dss_extending
argument_list|,
operator|&
name|expected
argument_list|,
name|true
argument_list|,
name|ATOMIC_ACQ_REL
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
condition|)
block|{
break|break;
block|}
name|spin_adaptive
argument_list|(
operator|&
name|spinner
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|extent_dss_extending_finish
parameter_list|(
name|void
parameter_list|)
block|{
name|assert
argument_list|(
name|atomic_load_b
argument_list|(
operator|&
name|dss_extending
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
argument_list|)
expr_stmt|;
name|atomic_store_b
argument_list|(
operator|&
name|dss_extending
argument_list|,
name|false
argument_list|,
name|ATOMIC_RELEASE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|extent_dss_max_update
parameter_list|(
name|void
modifier|*
name|new_addr
parameter_list|)
block|{
comment|/* 	 * Get the current end of the DSS as max_cur and assure that dss_max is 	 * up to date. 	 */
name|void
modifier|*
name|max_cur
init|=
name|extent_dss_sbrk
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|max_cur
operator|==
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|atomic_store_p
argument_list|(
operator|&
name|dss_max
argument_list|,
name|max_cur
argument_list|,
name|ATOMIC_RELEASE
argument_list|)
expr_stmt|;
comment|/* Fixed new_addr can only be supported if it is at the edge of DSS. */
if|if
condition|(
name|new_addr
operator|!=
name|NULL
operator|&&
name|max_cur
operator|!=
name|new_addr
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|max_cur
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|extent_alloc_dss
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|void
modifier|*
name|new_addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
modifier|*
name|zero
parameter_list|,
name|bool
modifier|*
name|commit
parameter_list|)
block|{
name|extent_t
modifier|*
name|gap
decl_stmt|;
name|cassert
argument_list|(
name|have_dss
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|alignment
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * sbrk() uses a signed increment argument, so take care not to 	 * interpret a large allocation request as a negative increment. 	 */
if|if
condition|(
operator|(
name|intptr_t
operator|)
name|size
operator|<
literal|0
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|gap
operator|=
name|extent_alloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|extent_dss_extending_start
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|atomic_load_b
argument_list|(
operator|&
name|dss_exhausted
argument_list|,
name|ATOMIC_ACQUIRE
argument_list|)
condition|)
block|{
comment|/* 		 * The loop is necessary to recover from races with other 		 * threads that are using the DSS for something other than 		 * malloc. 		 */
while|while
condition|(
name|true
condition|)
block|{
name|void
modifier|*
name|max_cur
init|=
name|extent_dss_max_update
argument_list|(
name|new_addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|max_cur
operator|==
name|NULL
condition|)
block|{
goto|goto
name|label_oom
goto|;
block|}
comment|/* 			 * Compute how much page-aligned gap space (if any) is 			 * necessary to satisfy alignment.  This space can be 			 * recycled for later use. 			 */
name|void
modifier|*
name|gap_addr_page
init|=
operator|(
name|void
operator|*
operator|)
operator|(
name|PAGE_CEILING
argument_list|(
operator|(
name|uintptr_t
operator|)
name|max_cur
argument_list|)
operator|)
decl_stmt|;
name|void
modifier|*
name|ret
init|=
operator|(
name|void
operator|*
operator|)
name|ALIGNMENT_CEILING
argument_list|(
operator|(
name|uintptr_t
operator|)
name|gap_addr_page
argument_list|,
name|alignment
argument_list|)
decl_stmt|;
name|size_t
name|gap_size_page
init|=
operator|(
name|uintptr_t
operator|)
name|ret
operator|-
operator|(
name|uintptr_t
operator|)
name|gap_addr_page
decl_stmt|;
if|if
condition|(
name|gap_size_page
operator|!=
literal|0
condition|)
block|{
name|extent_init
argument_list|(
name|gap
argument_list|,
name|arena
argument_list|,
name|gap_addr_page
argument_list|,
name|gap_size_page
argument_list|,
name|false
argument_list|,
name|NSIZES
argument_list|,
name|arena_extent_sn_next
argument_list|(
name|arena
argument_list|)
argument_list|,
name|extent_state_active
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Compute the address just past the end of the desired 			 * allocation space. 			 */
name|void
modifier|*
name|dss_next
init|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|+
name|size
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|<
operator|(
name|uintptr_t
operator|)
name|max_cur
operator|||
operator|(
name|uintptr_t
operator|)
name|dss_next
operator|<
operator|(
name|uintptr_t
operator|)
name|max_cur
condition|)
block|{
goto|goto
name|label_oom
goto|;
comment|/* Wrap-around. */
block|}
comment|/* Compute the increment, including subpage bytes. */
name|void
modifier|*
name|gap_addr_subpage
init|=
name|max_cur
decl_stmt|;
name|size_t
name|gap_size_subpage
init|=
operator|(
name|uintptr_t
operator|)
name|ret
operator|-
operator|(
name|uintptr_t
operator|)
name|gap_addr_subpage
decl_stmt|;
name|intptr_t
name|incr
init|=
name|gap_size_subpage
operator|+
name|size
decl_stmt|;
name|assert
argument_list|(
operator|(
name|uintptr_t
operator|)
name|max_cur
operator|+
name|incr
operator|==
operator|(
name|uintptr_t
operator|)
name|ret
operator|+
name|size
argument_list|)
expr_stmt|;
comment|/* Try to allocate. */
name|void
modifier|*
name|dss_prev
init|=
name|extent_dss_sbrk
argument_list|(
name|incr
argument_list|)
decl_stmt|;
if|if
condition|(
name|dss_prev
operator|==
name|max_cur
condition|)
block|{
comment|/* Success. */
name|atomic_store_p
argument_list|(
operator|&
name|dss_max
argument_list|,
name|dss_next
argument_list|,
name|ATOMIC_RELEASE
argument_list|)
expr_stmt|;
name|extent_dss_extending_finish
argument_list|()
expr_stmt|;
if|if
condition|(
name|gap_size_page
operator|!=
literal|0
condition|)
block|{
name|extent_dalloc_gap
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|gap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|extent_dalloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|gap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|commit
condition|)
block|{
operator|*
name|commit
operator|=
name|pages_decommit
argument_list|(
name|ret
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|zero
operator|&&
operator|*
name|commit
condition|)
block|{
name|extent_hooks_t
modifier|*
name|extent_hooks
init|=
name|EXTENT_HOOKS_INITIALIZER
decl_stmt|;
name|extent_t
name|extent
decl_stmt|;
name|extent_init
argument_list|(
operator|&
name|extent
argument_list|,
name|arena
argument_list|,
name|ret
argument_list|,
name|size
argument_list|,
name|size
argument_list|,
name|false
argument_list|,
name|NSIZES
argument_list|,
name|extent_state_active
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|extent_purge_forced_wrapper
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
operator|&
name|extent_hooks
argument_list|,
operator|&
name|extent
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
comment|/* 			 * Failure, whether due to OOM or a race with a raw 			 * sbrk() call from outside the allocator. 			 */
if|if
condition|(
name|dss_prev
operator|==
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* OOM. */
name|atomic_store_b
argument_list|(
operator|&
name|dss_exhausted
argument_list|,
name|true
argument_list|,
name|ATOMIC_RELEASE
argument_list|)
expr_stmt|;
goto|goto
name|label_oom
goto|;
block|}
block|}
block|}
name|label_oom
label|:
name|extent_dss_extending_finish
argument_list|()
expr_stmt|;
name|extent_dalloc
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|gap
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|extent_in_dss_helper
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|void
modifier|*
name|max
parameter_list|)
block|{
return|return
operator|(
operator|(
name|uintptr_t
operator|)
name|addr
operator|>=
operator|(
name|uintptr_t
operator|)
name|dss_base
operator|&&
operator|(
name|uintptr_t
operator|)
name|addr
operator|<
operator|(
name|uintptr_t
operator|)
name|max
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|extent_in_dss
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|cassert
argument_list|(
name|have_dss
argument_list|)
expr_stmt|;
return|return
name|extent_in_dss_helper
argument_list|(
name|addr
argument_list|,
name|atomic_load_p
argument_list|(
operator|&
name|dss_max
argument_list|,
name|ATOMIC_ACQUIRE
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|extent_dss_mergeable
parameter_list|(
name|void
modifier|*
name|addr_a
parameter_list|,
name|void
modifier|*
name|addr_b
parameter_list|)
block|{
name|void
modifier|*
name|max
decl_stmt|;
name|cassert
argument_list|(
name|have_dss
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|addr_a
operator|<
operator|(
name|uintptr_t
operator|)
name|dss_base
operator|&&
operator|(
name|uintptr_t
operator|)
name|addr_b
operator|<
operator|(
name|uintptr_t
operator|)
name|dss_base
condition|)
block|{
return|return
name|true
return|;
block|}
name|max
operator|=
name|atomic_load_p
argument_list|(
operator|&
name|dss_max
argument_list|,
name|ATOMIC_ACQUIRE
argument_list|)
expr_stmt|;
return|return
operator|(
name|extent_in_dss_helper
argument_list|(
name|addr_a
argument_list|,
name|max
argument_list|)
operator|==
name|extent_in_dss_helper
argument_list|(
name|addr_b
argument_list|,
name|max
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|extent_dss_boot
parameter_list|(
name|void
parameter_list|)
block|{
name|cassert
argument_list|(
name|have_dss
argument_list|)
expr_stmt|;
name|dss_base
operator|=
name|extent_dss_sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|atomic_store_b
argument_list|(
operator|&
name|dss_extending
argument_list|,
name|false
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
name|atomic_store_b
argument_list|(
operator|&
name|dss_exhausted
argument_list|,
name|dss_base
operator|==
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
name|atomic_store_p
argument_list|(
operator|&
name|dss_max
argument_list|,
name|dss_base
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

end_unit

