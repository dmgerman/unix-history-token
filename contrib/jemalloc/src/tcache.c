begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|JEMALLOC_TCACHE_C_
end_define

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_internal.h"
end_include

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/* Data. */
end_comment

begin_macro
name|malloc_tsd_data
argument_list|(
argument_list|,
argument|tcache
argument_list|,
argument|tcache_t *
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_macro
name|malloc_tsd_data
argument_list|(
argument_list|,
argument|tcache_enabled
argument_list|,
argument|tcache_enabled_t
argument_list|,
argument|tcache_enabled_default
argument_list|)
end_macro

begin_decl_stmt
name|bool
name|opt_tcache
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ssize_t
name|opt_lg_tcache_max
init|=
name|LG_TCACHE_MAXCLASS_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tcache_bin_info_t
modifier|*
name|tcache_bin_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|stack_nelms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total stack elms per tcache. */
end_comment

begin_decl_stmt
name|size_t
name|nhbins
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|tcache_maxclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************/
end_comment

begin_function
name|size_t
name|tcache_salloc
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
operator|(
name|arena_salloc
argument_list|(
name|ptr
argument_list|,
name|false
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|tcache_event_hard
parameter_list|(
name|tcache_t
modifier|*
name|tcache
parameter_list|)
block|{
name|size_t
name|binind
init|=
name|tcache
operator|->
name|next_gc_bin
decl_stmt|;
name|tcache_bin_t
modifier|*
name|tbin
init|=
operator|&
name|tcache
operator|->
name|tbins
index|[
name|binind
index|]
decl_stmt|;
name|tcache_bin_info_t
modifier|*
name|tbin_info
init|=
operator|&
name|tcache_bin_info
index|[
name|binind
index|]
decl_stmt|;
if|if
condition|(
name|tbin
operator|->
name|low_water
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Flush (ceiling) 3/4 of the objects below the low water mark. 		 */
if|if
condition|(
name|binind
operator|<
name|NBINS
condition|)
block|{
name|tcache_bin_flush_small
argument_list|(
name|tbin
argument_list|,
name|binind
argument_list|,
name|tbin
operator|->
name|ncached
operator|-
name|tbin
operator|->
name|low_water
operator|+
operator|(
name|tbin
operator|->
name|low_water
operator|>>
literal|2
operator|)
argument_list|,
name|tcache
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tcache_bin_flush_large
argument_list|(
name|tbin
argument_list|,
name|binind
argument_list|,
name|tbin
operator|->
name|ncached
operator|-
name|tbin
operator|->
name|low_water
operator|+
operator|(
name|tbin
operator|->
name|low_water
operator|>>
literal|2
operator|)
argument_list|,
name|tcache
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Reduce fill count by 2X.  Limit lg_fill_div such that the 		 * fill count is always at least 1. 		 */
if|if
condition|(
operator|(
name|tbin_info
operator|->
name|ncached_max
operator|>>
operator|(
name|tbin
operator|->
name|lg_fill_div
operator|+
literal|1
operator|)
operator|)
operator|>=
literal|1
condition|)
name|tbin
operator|->
name|lg_fill_div
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tbin
operator|->
name|low_water
operator|<
literal|0
condition|)
block|{
comment|/* 		 * Increase fill count by 2X.  Make sure lg_fill_div stays 		 * greater than 0. 		 */
if|if
condition|(
name|tbin
operator|->
name|lg_fill_div
operator|>
literal|1
condition|)
name|tbin
operator|->
name|lg_fill_div
operator|--
expr_stmt|;
block|}
name|tbin
operator|->
name|low_water
operator|=
name|tbin
operator|->
name|ncached
expr_stmt|;
name|tcache
operator|->
name|next_gc_bin
operator|++
expr_stmt|;
if|if
condition|(
name|tcache
operator|->
name|next_gc_bin
operator|==
name|nhbins
condition|)
name|tcache
operator|->
name|next_gc_bin
operator|=
literal|0
expr_stmt|;
name|tcache
operator|->
name|ev_cnt
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|tcache_alloc_small_hard
parameter_list|(
name|tcache_t
modifier|*
name|tcache
parameter_list|,
name|tcache_bin_t
modifier|*
name|tbin
parameter_list|,
name|size_t
name|binind
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|arena_tcache_fill_small
argument_list|(
name|tcache
operator|->
name|arena
argument_list|,
name|tbin
argument_list|,
name|binind
argument_list|,
name|config_prof
condition|?
name|tcache
operator|->
name|prof_accumbytes
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_prof
condition|)
name|tcache
operator|->
name|prof_accumbytes
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|tcache_alloc_easy
argument_list|(
name|tbin
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|tcache_bin_flush_small
parameter_list|(
name|tcache_bin_t
modifier|*
name|tbin
parameter_list|,
name|size_t
name|binind
parameter_list|,
name|unsigned
name|rem
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|nflush
decl_stmt|,
name|ndeferred
decl_stmt|;
name|bool
name|merged_stats
init|=
name|false
decl_stmt|;
name|assert
argument_list|(
name|binind
operator|<
name|NBINS
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rem
operator|<=
name|tbin
operator|->
name|ncached
argument_list|)
expr_stmt|;
for|for
control|(
name|nflush
operator|=
name|tbin
operator|->
name|ncached
operator|-
name|rem
init|;
name|nflush
operator|>
literal|0
condition|;
name|nflush
operator|=
name|ndeferred
control|)
block|{
comment|/* Lock the arena bin associated with the first object. */
name|arena_chunk_t
modifier|*
name|chunk
init|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|tbin
operator|->
name|avail
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|arena_t
modifier|*
name|arena
init|=
name|chunk
operator|->
name|arena
decl_stmt|;
name|arena_bin_t
modifier|*
name|bin
init|=
operator|&
name|arena
operator|->
name|bins
index|[
name|binind
index|]
decl_stmt|;
if|if
condition|(
name|config_prof
operator|&&
name|arena
operator|==
name|tcache
operator|->
name|arena
condition|)
block|{
if|if
condition|(
name|arena_prof_accum
argument_list|(
name|arena
argument_list|,
name|tcache
operator|->
name|prof_accumbytes
argument_list|)
condition|)
name|prof_idump
argument_list|()
expr_stmt|;
name|tcache
operator|->
name|prof_accumbytes
operator|=
literal|0
expr_stmt|;
block|}
name|malloc_mutex_lock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
operator|&&
name|arena
operator|==
name|tcache
operator|->
name|arena
condition|)
block|{
name|assert
argument_list|(
name|merged_stats
operator|==
name|false
argument_list|)
expr_stmt|;
name|merged_stats
operator|=
name|true
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|nflushes
operator|++
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|nrequests
operator|+=
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
expr_stmt|;
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
operator|=
literal|0
expr_stmt|;
block|}
name|ndeferred
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nflush
condition|;
name|i
operator|++
control|)
block|{
name|ptr
operator|=
name|tbin
operator|->
name|avail
index|[
name|i
index|]
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|->
name|arena
operator|==
name|arena
condition|)
block|{
name|size_t
name|pageind
init|=
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|LG_PAGE
decl_stmt|;
name|arena_chunk_map_t
modifier|*
name|mapelm
init|=
name|arena_mapp_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
decl_stmt|;
if|if
condition|(
name|config_fill
operator|&&
name|opt_junk
condition|)
block|{
name|arena_alloc_junk_small
argument_list|(
name|ptr
argument_list|,
operator|&
name|arena_bin_info
index|[
name|binind
index|]
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|arena_dalloc_bin_locked
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|ptr
argument_list|,
name|mapelm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * This object was allocated via a different 				 * arena bin than the one that is currently 				 * locked.  Stash the object, so that it can be 				 * handled in a future pass. 				 */
name|tbin
operator|->
name|avail
index|[
name|ndeferred
index|]
operator|=
name|ptr
expr_stmt|;
name|ndeferred
operator|++
expr_stmt|;
block|}
block|}
name|malloc_mutex_unlock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config_stats
operator|&&
name|merged_stats
operator|==
name|false
condition|)
block|{
comment|/* 		 * The flush loop didn't happen to flush to this thread's 		 * arena, so the stats didn't get merged.  Manually do so now. 		 */
name|arena_bin_t
modifier|*
name|bin
init|=
operator|&
name|tcache
operator|->
name|arena
operator|->
name|bins
index|[
name|binind
index|]
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|nflushes
operator|++
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|nrequests
operator|+=
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
expr_stmt|;
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
operator|=
literal|0
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|memmove
argument_list|(
name|tbin
operator|->
name|avail
argument_list|,
operator|&
name|tbin
operator|->
name|avail
index|[
name|tbin
operator|->
name|ncached
operator|-
name|rem
index|]
argument_list|,
name|rem
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|tbin
operator|->
name|ncached
operator|=
name|rem
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|tbin
operator|->
name|ncached
operator|<
name|tbin
operator|->
name|low_water
condition|)
name|tbin
operator|->
name|low_water
operator|=
name|tbin
operator|->
name|ncached
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tcache_bin_flush_large
parameter_list|(
name|tcache_bin_t
modifier|*
name|tbin
parameter_list|,
name|size_t
name|binind
parameter_list|,
name|unsigned
name|rem
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|nflush
decl_stmt|,
name|ndeferred
decl_stmt|;
name|bool
name|merged_stats
init|=
name|false
decl_stmt|;
name|assert
argument_list|(
name|binind
operator|<
name|nhbins
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rem
operator|<=
name|tbin
operator|->
name|ncached
argument_list|)
expr_stmt|;
for|for
control|(
name|nflush
operator|=
name|tbin
operator|->
name|ncached
operator|-
name|rem
init|;
name|nflush
operator|>
literal|0
condition|;
name|nflush
operator|=
name|ndeferred
control|)
block|{
comment|/* Lock the arena associated with the first object. */
name|arena_chunk_t
modifier|*
name|chunk
init|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|tbin
operator|->
name|avail
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|arena_t
modifier|*
name|arena
init|=
name|chunk
operator|->
name|arena
decl_stmt|;
name|UNUSED
name|bool
name|idump
decl_stmt|;
if|if
condition|(
name|config_prof
condition|)
name|idump
operator|=
name|false
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|config_prof
operator|||
name|config_stats
operator|)
operator|&&
name|arena
operator|==
name|tcache
operator|->
name|arena
condition|)
block|{
if|if
condition|(
name|config_prof
condition|)
block|{
name|idump
operator|=
name|arena_prof_accum_locked
argument_list|(
name|arena
argument_list|,
name|tcache
operator|->
name|prof_accumbytes
argument_list|)
expr_stmt|;
name|tcache
operator|->
name|prof_accumbytes
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|config_stats
condition|)
block|{
name|merged_stats
operator|=
name|true
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|nrequests_large
operator|+=
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|binind
operator|-
name|NBINS
index|]
operator|.
name|nrequests
operator|+=
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
expr_stmt|;
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|ndeferred
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nflush
condition|;
name|i
operator|++
control|)
block|{
name|ptr
operator|=
name|tbin
operator|->
name|avail
index|[
name|i
index|]
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|->
name|arena
operator|==
name|arena
condition|)
name|arena_dalloc_large_locked
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 				 * This object was allocated via a different 				 * arena than the one that is currently locked. 				 * Stash the object, so that it can be handled 				 * in a future pass. 				 */
name|tbin
operator|->
name|avail
index|[
name|ndeferred
index|]
operator|=
name|ptr
expr_stmt|;
name|ndeferred
operator|++
expr_stmt|;
block|}
block|}
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_prof
operator|&&
name|idump
condition|)
name|prof_idump
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|config_stats
operator|&&
name|merged_stats
operator|==
name|false
condition|)
block|{
comment|/* 		 * The flush loop didn't happen to flush to this thread's 		 * arena, so the stats didn't get merged.  Manually do so now. 		 */
name|arena_t
modifier|*
name|arena
init|=
name|tcache
operator|->
name|arena
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|nrequests_large
operator|+=
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|binind
operator|-
name|NBINS
index|]
operator|.
name|nrequests
operator|+=
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
expr_stmt|;
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
operator|=
literal|0
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|memmove
argument_list|(
name|tbin
operator|->
name|avail
argument_list|,
operator|&
name|tbin
operator|->
name|avail
index|[
name|tbin
operator|->
name|ncached
operator|-
name|rem
index|]
argument_list|,
name|rem
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|tbin
operator|->
name|ncached
operator|=
name|rem
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|tbin
operator|->
name|ncached
operator|<
name|tbin
operator|->
name|low_water
condition|)
name|tbin
operator|->
name|low_water
operator|=
name|tbin
operator|->
name|ncached
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tcache_arena_associate
parameter_list|(
name|tcache_t
modifier|*
name|tcache
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
if|if
condition|(
name|config_stats
condition|)
block|{
comment|/* Link into list of extant tcaches. */
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ql_elm_new
argument_list|(
name|tcache
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ql_tail_insert
argument_list|(
operator|&
name|arena
operator|->
name|tcache_ql
argument_list|,
name|tcache
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|tcache
operator|->
name|arena
operator|=
name|arena
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tcache_arena_dissociate
parameter_list|(
name|tcache_t
modifier|*
name|tcache
parameter_list|)
block|{
if|if
condition|(
name|config_stats
condition|)
block|{
comment|/* Unlink from list of extant tcaches. */
name|malloc_mutex_lock
argument_list|(
operator|&
name|tcache
operator|->
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ql_remove
argument_list|(
operator|&
name|tcache
operator|->
name|arena
operator|->
name|tcache_ql
argument_list|,
name|tcache
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|tcache_stats_merge
argument_list|(
name|tcache
argument_list|,
name|tcache
operator|->
name|arena
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|tcache
operator|->
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|tcache_t
modifier|*
name|tcache_create
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|tcache_t
modifier|*
name|tcache
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|stack_offset
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|size
operator|=
name|offsetof
argument_list|(
name|tcache_t
argument_list|,
name|tbins
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|tcache_bin_t
argument_list|)
operator|*
name|nhbins
operator|)
expr_stmt|;
comment|/* Naturally align the pointer stacks. */
name|size
operator|=
name|PTR_CEILING
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|stack_offset
operator|=
name|size
expr_stmt|;
name|size
operator|+=
name|stack_nelms
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * Round up to the nearest multiple of the cacheline size, in order to 	 * avoid the possibility of false cacheline sharing. 	 * 	 * That this works relies on the same logic as in ipalloc(), but we 	 * cannot directly call ipalloc() here due to tcache bootstrapping 	 * issues. 	 */
name|size
operator|=
operator|(
name|size
operator|+
name|CACHELINE_MASK
operator|)
operator|&
operator|(
operator|-
name|CACHELINE
operator|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|SMALL_MAXCLASS
condition|)
name|tcache
operator|=
operator|(
name|tcache_t
operator|*
operator|)
name|arena_malloc_small
argument_list|(
name|arena
argument_list|,
name|size
argument_list|,
name|true
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|<=
name|tcache_maxclass
condition|)
name|tcache
operator|=
operator|(
name|tcache_t
operator|*
operator|)
name|arena_malloc_large
argument_list|(
name|arena
argument_list|,
name|size
argument_list|,
name|true
argument_list|)
expr_stmt|;
else|else
name|tcache
operator|=
operator|(
name|tcache_t
operator|*
operator|)
name|icalloct
argument_list|(
name|size
argument_list|,
name|false
argument_list|,
name|arena
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcache
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|tcache_arena_associate
argument_list|(
name|tcache
argument_list|,
name|arena
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|TCACHE_NSLOTS_SMALL_MAX
operator|&
literal|1U
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nhbins
condition|;
name|i
operator|++
control|)
block|{
name|tcache
operator|->
name|tbins
index|[
name|i
index|]
operator|.
name|lg_fill_div
operator|=
literal|1
expr_stmt|;
name|tcache
operator|->
name|tbins
index|[
name|i
index|]
operator|.
name|avail
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tcache
operator|+
operator|(
name|uintptr_t
operator|)
name|stack_offset
operator|)
expr_stmt|;
name|stack_offset
operator|+=
name|tcache_bin_info
index|[
name|i
index|]
operator|.
name|ncached_max
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
block|}
name|tcache_tsd_set
argument_list|(
operator|&
name|tcache
argument_list|)
expr_stmt|;
return|return
operator|(
name|tcache
operator|)
return|;
block|}
end_function

begin_function
name|void
name|tcache_destroy
parameter_list|(
name|tcache_t
modifier|*
name|tcache
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|size_t
name|tcache_size
decl_stmt|;
name|tcache_arena_dissociate
argument_list|(
name|tcache
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
name|tcache_bin_t
modifier|*
name|tbin
init|=
operator|&
name|tcache
operator|->
name|tbins
index|[
name|i
index|]
decl_stmt|;
name|tcache_bin_flush_small
argument_list|(
name|tbin
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|tcache
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
operator|&&
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
operator|!=
literal|0
condition|)
block|{
name|arena_t
modifier|*
name|arena
init|=
name|tcache
operator|->
name|arena
decl_stmt|;
name|arena_bin_t
modifier|*
name|bin
init|=
operator|&
name|arena
operator|->
name|bins
index|[
name|i
index|]
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|nrequests
operator|+=
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|i
operator|<
name|nhbins
condition|;
name|i
operator|++
control|)
block|{
name|tcache_bin_t
modifier|*
name|tbin
init|=
operator|&
name|tcache
operator|->
name|tbins
index|[
name|i
index|]
decl_stmt|;
name|tcache_bin_flush_large
argument_list|(
name|tbin
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|tcache
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
operator|&&
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
operator|!=
literal|0
condition|)
block|{
name|arena_t
modifier|*
name|arena
init|=
name|tcache
operator|->
name|arena
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|nrequests_large
operator|+=
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|i
operator|-
name|NBINS
index|]
operator|.
name|nrequests
operator|+=
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|config_prof
operator|&&
name|tcache
operator|->
name|prof_accumbytes
operator|>
literal|0
operator|&&
name|arena_prof_accum
argument_list|(
name|tcache
operator|->
name|arena
argument_list|,
name|tcache
operator|->
name|prof_accumbytes
argument_list|)
condition|)
name|prof_idump
argument_list|()
expr_stmt|;
name|tcache_size
operator|=
name|arena_salloc
argument_list|(
name|tcache
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcache_size
operator|<=
name|SMALL_MAXCLASS
condition|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
init|=
name|CHUNK_ADDR2BASE
argument_list|(
name|tcache
argument_list|)
decl_stmt|;
name|arena_t
modifier|*
name|arena
init|=
name|chunk
operator|->
name|arena
decl_stmt|;
name|size_t
name|pageind
init|=
operator|(
operator|(
name|uintptr_t
operator|)
name|tcache
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|LG_PAGE
decl_stmt|;
name|arena_chunk_map_t
modifier|*
name|mapelm
init|=
name|arena_mapp_get
argument_list|(
name|chunk
argument_list|,
name|pageind
argument_list|)
decl_stmt|;
name|arena_dalloc_bin
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|tcache
argument_list|,
name|pageind
argument_list|,
name|mapelm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tcache_size
operator|<=
name|tcache_maxclass
condition|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
init|=
name|CHUNK_ADDR2BASE
argument_list|(
name|tcache
argument_list|)
decl_stmt|;
name|arena_t
modifier|*
name|arena
init|=
name|chunk
operator|->
name|arena
decl_stmt|;
name|arena_dalloc_large
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|tcache
argument_list|)
expr_stmt|;
block|}
else|else
name|idalloct
argument_list|(
name|tcache
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tcache_thread_cleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|tcache_t
modifier|*
name|tcache
init|=
operator|*
operator|(
name|tcache_t
operator|*
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|tcache
operator|==
name|TCACHE_STATE_DISABLED
condition|)
block|{
comment|/* Do nothing. */
block|}
elseif|else
if|if
condition|(
name|tcache
operator|==
name|TCACHE_STATE_REINCARNATED
condition|)
block|{
comment|/* 		 * Another destructor called an allocator function after this 		 * destructor was called.  Reset tcache to 		 * TCACHE_STATE_PURGATORY in order to receive another callback. 		 */
name|tcache
operator|=
name|TCACHE_STATE_PURGATORY
expr_stmt|;
name|tcache_tsd_set
argument_list|(
operator|&
name|tcache
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tcache
operator|==
name|TCACHE_STATE_PURGATORY
condition|)
block|{
comment|/* 		 * The previous time this destructor was called, we set the key 		 * to TCACHE_STATE_PURGATORY so that other destructors wouldn't 		 * cause re-creation of the tcache.  This time, do nothing, so 		 * that the destructor will not be called again. 		 */
block|}
elseif|else
if|if
condition|(
name|tcache
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|tcache
operator|!=
name|TCACHE_STATE_PURGATORY
argument_list|)
expr_stmt|;
name|tcache_destroy
argument_list|(
name|tcache
argument_list|)
expr_stmt|;
name|tcache
operator|=
name|TCACHE_STATE_PURGATORY
expr_stmt|;
name|tcache_tsd_set
argument_list|(
operator|&
name|tcache
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Caller must own arena->lock. */
end_comment

begin_function
name|void
name|tcache_stats_merge
parameter_list|(
name|tcache_t
modifier|*
name|tcache
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|cassert
argument_list|(
name|config_stats
argument_list|)
expr_stmt|;
comment|/* Merge and reset tcache stats. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
name|arena_bin_t
modifier|*
name|bin
init|=
operator|&
name|arena
operator|->
name|bins
index|[
name|i
index|]
decl_stmt|;
name|tcache_bin_t
modifier|*
name|tbin
init|=
operator|&
name|tcache
operator|->
name|tbins
index|[
name|i
index|]
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|nrequests
operator|+=
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|nhbins
condition|;
name|i
operator|++
control|)
block|{
name|malloc_large_stats_t
modifier|*
name|lstats
init|=
operator|&
name|arena
operator|->
name|stats
operator|.
name|lstats
index|[
name|i
operator|-
name|NBINS
index|]
decl_stmt|;
name|tcache_bin_t
modifier|*
name|tbin
init|=
operator|&
name|tcache
operator|->
name|tbins
index|[
name|i
index|]
decl_stmt|;
name|arena
operator|->
name|stats
operator|.
name|nrequests_large
operator|+=
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
expr_stmt|;
name|lstats
operator|->
name|nrequests
operator|+=
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
expr_stmt|;
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|bool
name|tcache_boot0
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
comment|/* 	 * If necessary, clamp opt_lg_tcache_max, now that arena_maxclass is 	 * known. 	 */
if|if
condition|(
name|opt_lg_tcache_max
operator|<
literal|0
operator|||
operator|(
literal|1U
operator|<<
name|opt_lg_tcache_max
operator|)
operator|<
name|SMALL_MAXCLASS
condition|)
name|tcache_maxclass
operator|=
name|SMALL_MAXCLASS
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
literal|1U
operator|<<
name|opt_lg_tcache_max
operator|)
operator|>
name|arena_maxclass
condition|)
name|tcache_maxclass
operator|=
name|arena_maxclass
expr_stmt|;
else|else
name|tcache_maxclass
operator|=
operator|(
literal|1U
operator|<<
name|opt_lg_tcache_max
operator|)
expr_stmt|;
name|nhbins
operator|=
name|NBINS
operator|+
operator|(
name|tcache_maxclass
operator|>>
name|LG_PAGE
operator|)
expr_stmt|;
comment|/* Initialize tcache_bin_info. */
name|tcache_bin_info
operator|=
operator|(
name|tcache_bin_info_t
operator|*
operator|)
name|base_alloc
argument_list|(
name|nhbins
operator|*
sizeof|sizeof
argument_list|(
name|tcache_bin_info_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcache_bin_info
operator|==
name|NULL
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|stack_nelms
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|arena_bin_info
index|[
name|i
index|]
operator|.
name|nregs
operator|<<
literal|1
operator|)
operator|<=
name|TCACHE_NSLOTS_SMALL_MAX
condition|)
block|{
name|tcache_bin_info
index|[
name|i
index|]
operator|.
name|ncached_max
operator|=
operator|(
name|arena_bin_info
index|[
name|i
index|]
operator|.
name|nregs
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|tcache_bin_info
index|[
name|i
index|]
operator|.
name|ncached_max
operator|=
name|TCACHE_NSLOTS_SMALL_MAX
expr_stmt|;
block|}
name|stack_nelms
operator|+=
name|tcache_bin_info
index|[
name|i
index|]
operator|.
name|ncached_max
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|nhbins
condition|;
name|i
operator|++
control|)
block|{
name|tcache_bin_info
index|[
name|i
index|]
operator|.
name|ncached_max
operator|=
name|TCACHE_NSLOTS_LARGE
expr_stmt|;
name|stack_nelms
operator|+=
name|tcache_bin_info
index|[
name|i
index|]
operator|.
name|ncached_max
expr_stmt|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|tcache_boot1
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|tcache_tsd_boot
argument_list|()
operator|||
name|tcache_enabled_tsd_boot
argument_list|()
condition|)
return|return
operator|(
name|true
operator|)
return|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

end_unit

