begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|JEMALLOC_TCACHE_C_
end_define

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_preamble.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_internal_includes.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/assert.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/mutex.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/size_classes.h"
end_include

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/* Data. */
end_comment

begin_decl_stmt
name|bool
name|opt_tcache
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ssize_t
name|opt_lg_tcache_max
init|=
name|LG_TCACHE_MAXCLASS_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tcache_bin_info_t
modifier|*
name|tcache_bin_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|stack_nelms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total stack elms per tcache. */
end_comment

begin_decl_stmt
name|unsigned
name|nhbins
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|tcache_maxclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tcaches_t
modifier|*
name|tcaches
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of first element within tcaches that has never been used. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|tcaches_past
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Head of singly linked list tracking available tcaches elements. */
end_comment

begin_decl_stmt
specifier|static
name|tcaches_t
modifier|*
name|tcaches_avail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Protects tcaches{,_past,_avail}. */
end_comment

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|tcaches_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************/
end_comment

begin_function
name|size_t
name|tcache_salloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
name|arena_salloc
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|tcache_event_hard
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|)
block|{
name|szind_t
name|binind
init|=
name|tcache
operator|->
name|next_gc_bin
decl_stmt|;
name|tcache_bin_t
modifier|*
name|tbin
decl_stmt|;
if|if
condition|(
name|binind
operator|<
name|NBINS
condition|)
block|{
name|tbin
operator|=
name|tcache_small_bin_get
argument_list|(
name|tcache
argument_list|,
name|binind
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tbin
operator|=
name|tcache_large_bin_get
argument_list|(
name|tcache
argument_list|,
name|binind
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tbin
operator|->
name|low_water
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Flush (ceiling) 3/4 of the objects below the low water mark. 		 */
if|if
condition|(
name|binind
operator|<
name|NBINS
condition|)
block|{
name|tcache_bin_flush_small
argument_list|(
name|tsd
argument_list|,
name|tcache
argument_list|,
name|tbin
argument_list|,
name|binind
argument_list|,
name|tbin
operator|->
name|ncached
operator|-
name|tbin
operator|->
name|low_water
operator|+
operator|(
name|tbin
operator|->
name|low_water
operator|>>
literal|2
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Reduce fill count by 2X.  Limit lg_fill_div such that 			 * the fill count is always at least 1. 			 */
name|tcache_bin_info_t
modifier|*
name|tbin_info
init|=
operator|&
name|tcache_bin_info
index|[
name|binind
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|tbin_info
operator|->
name|ncached_max
operator|>>
operator|(
name|tcache
operator|->
name|lg_fill_div
index|[
name|binind
index|]
operator|+
literal|1
operator|)
operator|)
operator|>=
literal|1
condition|)
block|{
name|tcache
operator|->
name|lg_fill_div
index|[
name|binind
index|]
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|tcache_bin_flush_large
argument_list|(
name|tsd
argument_list|,
name|tbin
argument_list|,
name|binind
argument_list|,
name|tbin
operator|->
name|ncached
operator|-
name|tbin
operator|->
name|low_water
operator|+
operator|(
name|tbin
operator|->
name|low_water
operator|>>
literal|2
operator|)
argument_list|,
name|tcache
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tbin
operator|->
name|low_water
operator|<
literal|0
condition|)
block|{
comment|/* 		 * Increase fill count by 2X for small bins.  Make sure 		 * lg_fill_div stays greater than 0. 		 */
if|if
condition|(
name|binind
operator|<
name|NBINS
operator|&&
name|tcache
operator|->
name|lg_fill_div
index|[
name|binind
index|]
operator|>
literal|1
condition|)
block|{
name|tcache
operator|->
name|lg_fill_div
index|[
name|binind
index|]
operator|--
expr_stmt|;
block|}
block|}
name|tbin
operator|->
name|low_water
operator|=
name|tbin
operator|->
name|ncached
expr_stmt|;
name|tcache
operator|->
name|next_gc_bin
operator|++
expr_stmt|;
if|if
condition|(
name|tcache
operator|->
name|next_gc_bin
operator|==
name|nhbins
condition|)
block|{
name|tcache
operator|->
name|next_gc_bin
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
modifier|*
name|tcache_alloc_small_hard
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|,
name|tcache_bin_t
modifier|*
name|tbin
parameter_list|,
name|szind_t
name|binind
parameter_list|,
name|bool
modifier|*
name|tcache_success
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|assert
argument_list|(
name|tcache
operator|->
name|arena
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|arena_tcache_fill_small
argument_list|(
name|tsdn
argument_list|,
name|arena
argument_list|,
name|tcache
argument_list|,
name|tbin
argument_list|,
name|binind
argument_list|,
name|config_prof
condition|?
name|tcache
operator|->
name|prof_accumbytes
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_prof
condition|)
block|{
name|tcache
operator|->
name|prof_accumbytes
operator|=
literal|0
expr_stmt|;
block|}
name|ret
operator|=
name|tcache_alloc_easy
argument_list|(
name|tbin
argument_list|,
name|tcache_success
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|tcache_bin_flush_small
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|,
name|tcache_bin_t
modifier|*
name|tbin
parameter_list|,
name|szind_t
name|binind
parameter_list|,
name|unsigned
name|rem
parameter_list|)
block|{
name|bool
name|merged_stats
init|=
name|false
decl_stmt|;
name|assert
argument_list|(
name|binind
operator|<
name|NBINS
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rem
operator|<=
name|tbin
operator|->
name|ncached
argument_list|)
expr_stmt|;
name|arena_t
modifier|*
name|arena
init|=
name|tcache
operator|->
name|arena
decl_stmt|;
name|assert
argument_list|(
name|arena
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|unsigned
name|nflush
init|=
name|tbin
operator|->
name|ncached
operator|-
name|rem
decl_stmt|;
name|VARIABLE_ARRAY
argument_list|(
name|extent_t
operator|*
argument_list|,
name|item_extent
argument_list|,
name|nflush
argument_list|)
expr_stmt|;
comment|/* Look up extent once per item. */
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nflush
condition|;
name|i
operator|++
control|)
block|{
name|item_extent
index|[
name|i
index|]
operator|=
name|iealloc
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|*
operator|(
name|tbin
operator|->
name|avail
operator|-
literal|1
operator|-
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|nflush
operator|>
literal|0
condition|)
block|{
comment|/* Lock the arena bin associated with the first object. */
name|extent_t
modifier|*
name|extent
init|=
name|item_extent
index|[
literal|0
index|]
decl_stmt|;
name|arena_t
modifier|*
name|bin_arena
init|=
name|extent_arena_get
argument_list|(
name|extent
argument_list|)
decl_stmt|;
name|arena_bin_t
modifier|*
name|bin
init|=
operator|&
name|bin_arena
operator|->
name|bins
index|[
name|binind
index|]
decl_stmt|;
if|if
condition|(
name|config_prof
operator|&&
name|bin_arena
operator|==
name|arena
condition|)
block|{
if|if
condition|(
name|arena_prof_accum
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|arena
argument_list|,
name|tcache
operator|->
name|prof_accumbytes
argument_list|)
condition|)
block|{
name|prof_idump
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tcache
operator|->
name|prof_accumbytes
operator|=
literal|0
expr_stmt|;
block|}
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
operator|&&
name|bin_arena
operator|==
name|arena
condition|)
block|{
name|assert
argument_list|(
operator|!
name|merged_stats
argument_list|)
expr_stmt|;
name|merged_stats
operator|=
name|true
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|nflushes
operator|++
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|nrequests
operator|+=
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
expr_stmt|;
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
operator|=
literal|0
expr_stmt|;
block|}
name|unsigned
name|ndeferred
init|=
literal|0
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nflush
condition|;
name|i
operator|++
control|)
block|{
name|void
modifier|*
name|ptr
init|=
operator|*
operator|(
name|tbin
operator|->
name|avail
operator|-
literal|1
operator|-
name|i
operator|)
decl_stmt|;
name|extent
operator|=
name|item_extent
index|[
name|i
index|]
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
operator|&&
name|extent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|extent_arena_get
argument_list|(
name|extent
argument_list|)
operator|==
name|bin_arena
condition|)
block|{
name|arena_dalloc_bin_junked_locked
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|bin_arena
argument_list|,
name|extent
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * This object was allocated via a different 				 * arena bin than the one that is currently 				 * locked.  Stash the object, so that it can be 				 * handled in a future pass. 				 */
operator|*
operator|(
name|tbin
operator|->
name|avail
operator|-
literal|1
operator|-
name|ndeferred
operator|)
operator|=
name|ptr
expr_stmt|;
name|item_extent
index|[
name|ndeferred
index|]
operator|=
name|extent
expr_stmt|;
name|ndeferred
operator|++
expr_stmt|;
block|}
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arena_decay_ticks
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|bin_arena
argument_list|,
name|nflush
operator|-
name|ndeferred
argument_list|)
expr_stmt|;
name|nflush
operator|=
name|ndeferred
expr_stmt|;
block|}
if|if
condition|(
name|config_stats
operator|&&
operator|!
name|merged_stats
condition|)
block|{
comment|/* 		 * The flush loop didn't happen to flush to this thread's 		 * arena, so the stats didn't get merged.  Manually do so now. 		 */
name|arena_bin_t
modifier|*
name|bin
init|=
operator|&
name|arena
operator|->
name|bins
index|[
name|binind
index|]
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|nflushes
operator|++
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|nrequests
operator|+=
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
expr_stmt|;
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
operator|=
literal|0
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|memmove
argument_list|(
name|tbin
operator|->
name|avail
operator|-
name|rem
argument_list|,
name|tbin
operator|->
name|avail
operator|-
name|tbin
operator|->
name|ncached
argument_list|,
name|rem
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|tbin
operator|->
name|ncached
operator|=
name|rem
expr_stmt|;
if|if
condition|(
operator|(
name|low_water_t
operator|)
name|tbin
operator|->
name|ncached
operator|<
name|tbin
operator|->
name|low_water
condition|)
block|{
name|tbin
operator|->
name|low_water
operator|=
name|tbin
operator|->
name|ncached
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|tcache_bin_flush_large
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|tcache_bin_t
modifier|*
name|tbin
parameter_list|,
name|szind_t
name|binind
parameter_list|,
name|unsigned
name|rem
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|)
block|{
name|bool
name|merged_stats
init|=
name|false
decl_stmt|;
name|assert
argument_list|(
name|binind
operator|<
name|nhbins
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rem
operator|<=
name|tbin
operator|->
name|ncached
argument_list|)
expr_stmt|;
name|arena_t
modifier|*
name|arena
init|=
name|tcache
operator|->
name|arena
decl_stmt|;
name|assert
argument_list|(
name|arena
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|unsigned
name|nflush
init|=
name|tbin
operator|->
name|ncached
operator|-
name|rem
decl_stmt|;
name|VARIABLE_ARRAY
argument_list|(
name|extent_t
operator|*
argument_list|,
name|item_extent
argument_list|,
name|nflush
argument_list|)
expr_stmt|;
comment|/* Look up extent once per item. */
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nflush
condition|;
name|i
operator|++
control|)
block|{
name|item_extent
index|[
name|i
index|]
operator|=
name|iealloc
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|*
operator|(
name|tbin
operator|->
name|avail
operator|-
literal|1
operator|-
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|nflush
operator|>
literal|0
condition|)
block|{
comment|/* Lock the arena associated with the first object. */
name|extent_t
modifier|*
name|extent
init|=
name|item_extent
index|[
literal|0
index|]
decl_stmt|;
name|arena_t
modifier|*
name|locked_arena
init|=
name|extent_arena_get
argument_list|(
name|extent
argument_list|)
decl_stmt|;
name|UNUSED
name|bool
name|idump
decl_stmt|;
if|if
condition|(
name|config_prof
condition|)
block|{
name|idump
operator|=
name|false
expr_stmt|;
block|}
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|locked_arena
operator|->
name|large_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nflush
condition|;
name|i
operator|++
control|)
block|{
name|void
modifier|*
name|ptr
init|=
operator|*
operator|(
name|tbin
operator|->
name|avail
operator|-
literal|1
operator|-
name|i
operator|)
decl_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|extent
operator|=
name|item_extent
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|extent_arena_get
argument_list|(
name|extent
argument_list|)
operator|==
name|locked_arena
condition|)
block|{
name|large_dalloc_prep_junked_locked
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|extent
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|config_prof
operator|||
name|config_stats
operator|)
operator|&&
name|locked_arena
operator|==
name|arena
condition|)
block|{
if|if
condition|(
name|config_prof
condition|)
block|{
name|idump
operator|=
name|arena_prof_accum
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|arena
argument_list|,
name|tcache
operator|->
name|prof_accumbytes
argument_list|)
expr_stmt|;
name|tcache
operator|->
name|prof_accumbytes
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|config_stats
condition|)
block|{
name|merged_stats
operator|=
name|true
expr_stmt|;
name|arena_stats_large_nrequests_add
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|,
name|binind
argument_list|,
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
argument_list|)
expr_stmt|;
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|locked_arena
operator|->
name|large_mtx
argument_list|)
expr_stmt|;
name|unsigned
name|ndeferred
init|=
literal|0
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nflush
condition|;
name|i
operator|++
control|)
block|{
name|void
modifier|*
name|ptr
init|=
operator|*
operator|(
name|tbin
operator|->
name|avail
operator|-
literal|1
operator|-
name|i
operator|)
decl_stmt|;
name|extent
operator|=
name|item_extent
index|[
name|i
index|]
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
operator|&&
name|extent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|extent_arena_get
argument_list|(
name|extent
argument_list|)
operator|==
name|locked_arena
condition|)
block|{
name|large_dalloc_finish
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|extent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * This object was allocated via a different 				 * arena than the one that is currently locked. 				 * Stash the object, so that it can be handled 				 * in a future pass. 				 */
operator|*
operator|(
name|tbin
operator|->
name|avail
operator|-
literal|1
operator|-
name|ndeferred
operator|)
operator|=
name|ptr
expr_stmt|;
name|item_extent
index|[
name|ndeferred
index|]
operator|=
name|extent
expr_stmt|;
name|ndeferred
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|config_prof
operator|&&
name|idump
condition|)
block|{
name|prof_idump
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|arena_decay_ticks
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|locked_arena
argument_list|,
name|nflush
operator|-
name|ndeferred
argument_list|)
expr_stmt|;
name|nflush
operator|=
name|ndeferred
expr_stmt|;
block|}
if|if
condition|(
name|config_stats
operator|&&
operator|!
name|merged_stats
condition|)
block|{
comment|/* 		 * The flush loop didn't happen to flush to this thread's 		 * arena, so the stats didn't get merged.  Manually do so now. 		 */
name|arena_stats_large_nrequests_add
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|,
name|binind
argument_list|,
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
argument_list|)
expr_stmt|;
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
operator|=
literal|0
expr_stmt|;
block|}
name|memmove
argument_list|(
name|tbin
operator|->
name|avail
operator|-
name|rem
argument_list|,
name|tbin
operator|->
name|avail
operator|-
name|tbin
operator|->
name|ncached
argument_list|,
name|rem
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|tbin
operator|->
name|ncached
operator|=
name|rem
expr_stmt|;
if|if
condition|(
operator|(
name|low_water_t
operator|)
name|tbin
operator|->
name|ncached
operator|<
name|tbin
operator|->
name|low_water
condition|)
block|{
name|tbin
operator|->
name|low_water
operator|=
name|tbin
operator|->
name|ncached
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|tcache_arena_associate
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|assert
argument_list|(
name|tcache
operator|->
name|arena
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|tcache
operator|->
name|arena
operator|=
name|arena
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
comment|/* Link into list of extant tcaches. */
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|tcache_ql_mtx
argument_list|)
expr_stmt|;
name|ql_elm_new
argument_list|(
name|tcache
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ql_tail_insert
argument_list|(
operator|&
name|arena
operator|->
name|tcache_ql
argument_list|,
name|tcache
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|tcache_ql_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tcache_arena_dissociate
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|)
block|{
name|arena_t
modifier|*
name|arena
init|=
name|tcache
operator|->
name|arena
decl_stmt|;
name|assert
argument_list|(
name|arena
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
comment|/* Unlink from list of extant tcaches. */
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|tcache_ql_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_debug
condition|)
block|{
name|bool
name|in_ql
init|=
name|false
decl_stmt|;
name|tcache_t
modifier|*
name|iter
decl_stmt|;
name|ql_foreach
argument_list|(
argument|iter
argument_list|,
argument|&arena->tcache_ql
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|iter
operator|==
name|tcache
condition|)
block|{
name|in_ql
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
name|assert
argument_list|(
name|in_ql
argument_list|)
expr_stmt|;
block|}
name|ql_remove
argument_list|(
operator|&
name|arena
operator|->
name|tcache_ql
argument_list|,
name|tcache
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|tcache_stats_merge
argument_list|(
name|tsdn
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|tcache_ql_mtx
argument_list|)
expr_stmt|;
block|}
name|tcache
operator|->
name|arena
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tcache_arena_reassociate
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|tcache_arena_dissociate
argument_list|(
name|tsdn
argument_list|,
name|tcache
argument_list|)
expr_stmt|;
name|tcache_arena_associate
argument_list|(
name|tsdn
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|tsd_tcache_enabled_data_init
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|)
block|{
comment|/* Called upon tsd initialization. */
name|tsd_tcache_enabled_set
argument_list|(
name|tsd
argument_list|,
name|opt_tcache
argument_list|)
expr_stmt|;
name|tsd_slow_update
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_tcache
condition|)
block|{
comment|/* Trigger tcache init. */
name|tsd_tcache_data_init
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Initialize auto tcache (embedded in TSD). */
end_comment

begin_function
specifier|static
name|void
name|tcache_init
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|,
name|void
modifier|*
name|avail_stack
parameter_list|)
block|{
name|memset
argument_list|(
operator|&
name|tcache
operator|->
name|link
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ql_elm
argument_list|(
name|tcache_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tcache
operator|->
name|prof_accumbytes
operator|=
literal|0
expr_stmt|;
name|tcache
operator|->
name|next_gc_bin
operator|=
literal|0
expr_stmt|;
name|tcache
operator|->
name|arena
operator|=
name|NULL
expr_stmt|;
name|ticker_init
argument_list|(
operator|&
name|tcache
operator|->
name|gc_ticker
argument_list|,
name|TCACHE_GC_INCR
argument_list|)
expr_stmt|;
name|size_t
name|stack_offset
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
operator|(
name|TCACHE_NSLOTS_SMALL_MAX
operator|&
literal|1U
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tcache
operator|->
name|tbins_small
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tcache_bin_t
argument_list|)
operator|*
name|NBINS
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tcache
operator|->
name|tbins_large
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tcache_bin_t
argument_list|)
operator|*
operator|(
name|nhbins
operator|-
name|NBINS
operator|)
argument_list|)
expr_stmt|;
name|unsigned
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
name|tcache
operator|->
name|lg_fill_div
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|stack_offset
operator|+=
name|tcache_bin_info
index|[
name|i
index|]
operator|.
name|ncached_max
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
comment|/* 		 * avail points past the available space.  Allocations will 		 * access the slots toward higher addresses (for the benefit of 		 * prefetch). 		 */
name|tcache_small_bin_get
argument_list|(
name|tcache
argument_list|,
name|i
argument_list|)
operator|->
name|avail
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|avail_stack
operator|+
operator|(
name|uintptr_t
operator|)
name|stack_offset
operator|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|nhbins
condition|;
name|i
operator|++
control|)
block|{
name|stack_offset
operator|+=
name|tcache_bin_info
index|[
name|i
index|]
operator|.
name|ncached_max
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
name|tcache_large_bin_get
argument_list|(
name|tcache
argument_list|,
name|i
argument_list|)
operator|->
name|avail
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|avail_stack
operator|+
operator|(
name|uintptr_t
operator|)
name|stack_offset
operator|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|stack_offset
operator|==
name|stack_nelms
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize auto tcache (embedded in TSD). */
end_comment

begin_function
name|bool
name|tsd_tcache_data_init
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|)
block|{
name|tcache_t
modifier|*
name|tcache
init|=
name|tsd_tcachep_get_unsafe
argument_list|(
name|tsd
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|tcache_small_bin_get
argument_list|(
name|tcache
argument_list|,
literal|0
argument_list|)
operator|->
name|avail
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|size_t
name|size
init|=
name|stack_nelms
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
decl_stmt|;
comment|/* Avoid false cacheline sharing. */
name|size
operator|=
name|sz_sa2u
argument_list|(
name|size
argument_list|,
name|CACHELINE
argument_list|)
expr_stmt|;
name|void
modifier|*
name|avail_array
init|=
name|ipallocztm
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|size
argument_list|,
name|CACHELINE
argument_list|,
name|true
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|arena_get
argument_list|(
name|TSDN_NULL
argument_list|,
literal|0
argument_list|,
name|true
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|avail_array
operator|==
name|NULL
condition|)
block|{
return|return
name|true
return|;
block|}
name|tcache_init
argument_list|(
name|tsd
argument_list|,
name|tcache
argument_list|,
name|avail_array
argument_list|)
expr_stmt|;
comment|/* 	 * Initialization is a bit tricky here.  After malloc init is done, all 	 * threads can rely on arena_choose and associate tcache accordingly. 	 * However, the thread that does actual malloc bootstrapping relies on 	 * functional tsd, and it can only rely on a0.  In that case, we 	 * associate its tcache to a0 temporarily, and later on 	 * arena_choose_hard() will re-associate properly. 	 */
name|tcache
operator|->
name|arena
operator|=
name|NULL
expr_stmt|;
name|arena_t
modifier|*
name|arena
decl_stmt|;
if|if
condition|(
operator|!
name|malloc_initialized
argument_list|()
condition|)
block|{
comment|/* If in initialization, assign to a0. */
name|arena
operator|=
name|arena_get
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|tcache_arena_associate
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arena
operator|=
name|arena_choose
argument_list|(
name|tsd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* This may happen if thread.tcache.enabled is used. */
if|if
condition|(
name|tcache
operator|->
name|arena
operator|==
name|NULL
condition|)
block|{
name|tcache_arena_associate
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
name|arena
operator|==
name|tcache
operator|->
name|arena
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Created manual tcache for tcache.create mallctl. */
end_comment

begin_function
name|tcache_t
modifier|*
name|tcache_create_explicit
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|)
block|{
name|tcache_t
modifier|*
name|tcache
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|stack_offset
decl_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|tcache_t
argument_list|)
expr_stmt|;
comment|/* Naturally align the pointer stacks. */
name|size
operator|=
name|PTR_CEILING
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|stack_offset
operator|=
name|size
expr_stmt|;
name|size
operator|+=
name|stack_nelms
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
comment|/* Avoid false cacheline sharing. */
name|size
operator|=
name|sz_sa2u
argument_list|(
name|size
argument_list|,
name|CACHELINE
argument_list|)
expr_stmt|;
name|tcache
operator|=
name|ipallocztm
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|size
argument_list|,
name|CACHELINE
argument_list|,
name|true
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|arena_get
argument_list|(
name|TSDN_NULL
argument_list|,
literal|0
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcache
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|tcache_init
argument_list|(
name|tsd
argument_list|,
name|tcache
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tcache
operator|+
operator|(
name|uintptr_t
operator|)
name|stack_offset
operator|)
argument_list|)
expr_stmt|;
name|tcache_arena_associate
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tcache
argument_list|,
name|arena_ichoose
argument_list|(
name|tsd
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tcache
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tcache_flush_cache
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|)
block|{
name|assert
argument_list|(
name|tcache
operator|->
name|arena
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
name|tcache_bin_t
modifier|*
name|tbin
init|=
name|tcache_small_bin_get
argument_list|(
name|tcache
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tcache_bin_flush_small
argument_list|(
name|tsd
argument_list|,
name|tcache
argument_list|,
name|tbin
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|assert
argument_list|(
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|unsigned
name|i
init|=
name|NBINS
init|;
name|i
operator|<
name|nhbins
condition|;
name|i
operator|++
control|)
block|{
name|tcache_bin_t
modifier|*
name|tbin
init|=
name|tcache_large_bin_get
argument_list|(
name|tcache
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tcache_bin_flush_large
argument_list|(
name|tsd
argument_list|,
name|tbin
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|tcache
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|assert
argument_list|(
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|config_prof
operator|&&
name|tcache
operator|->
name|prof_accumbytes
operator|>
literal|0
operator|&&
name|arena_prof_accum
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tcache
operator|->
name|arena
argument_list|,
name|tcache
operator|->
name|prof_accumbytes
argument_list|)
condition|)
block|{
name|prof_idump
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|tcache_flush
parameter_list|(
name|void
parameter_list|)
block|{
name|tsd_t
modifier|*
name|tsd
init|=
name|tsd_fetch
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|tcache_available
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
name|tcache_flush_cache
argument_list|(
name|tsd
argument_list|,
name|tsd_tcachep_get
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tcache_destroy
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|,
name|bool
name|tsd_tcache
parameter_list|)
block|{
name|tcache_flush_cache
argument_list|(
name|tsd
argument_list|,
name|tcache
argument_list|)
expr_stmt|;
name|tcache_arena_dissociate
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tcache
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsd_tcache
condition|)
block|{
comment|/* Release the avail array for the TSD embedded auto tcache. */
name|void
modifier|*
name|avail_array
init|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tcache_small_bin_get
argument_list|(
name|tcache
argument_list|,
literal|0
argument_list|)
operator|->
name|avail
operator|-
operator|(
name|uintptr_t
operator|)
name|tcache_bin_info
index|[
literal|0
index|]
operator|.
name|ncached_max
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|)
decl_stmt|;
name|idalloctm
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|avail_array
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Release both the tcache struct and avail array. */
name|idalloctm
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|tcache
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* For auto tcache (embedded in TSD) only. */
end_comment

begin_function
name|void
name|tcache_cleanup
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|)
block|{
name|tcache_t
modifier|*
name|tcache
init|=
name|tsd_tcachep_get
argument_list|(
name|tsd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tcache_available
argument_list|(
name|tsd
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|tsd_tcache_enabled_get
argument_list|(
name|tsd
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_debug
condition|)
block|{
name|assert
argument_list|(
name|tcache_small_bin_get
argument_list|(
name|tcache
argument_list|,
literal|0
argument_list|)
operator|->
name|avail
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|assert
argument_list|(
name|tsd_tcache_enabled_get
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tcache_small_bin_get
argument_list|(
name|tcache
argument_list|,
literal|0
argument_list|)
operator|->
name|avail
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tcache_destroy
argument_list|(
name|tsd
argument_list|,
name|tcache
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_debug
condition|)
block|{
name|tcache_small_bin_get
argument_list|(
name|tcache
argument_list|,
literal|0
argument_list|)
operator|->
name|avail
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|tcache_stats_merge
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|cassert
argument_list|(
name|config_stats
argument_list|)
expr_stmt|;
comment|/* Merge and reset tcache stats. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
name|arena_bin_t
modifier|*
name|bin
init|=
operator|&
name|arena
operator|->
name|bins
index|[
name|i
index|]
decl_stmt|;
name|tcache_bin_t
modifier|*
name|tbin
init|=
name|tcache_small_bin_get
argument_list|(
name|tcache
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|nrequests
operator|+=
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|bin
operator|->
name|lock
argument_list|)
expr_stmt|;
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|nhbins
condition|;
name|i
operator|++
control|)
block|{
name|tcache_bin_t
modifier|*
name|tbin
init|=
name|tcache_large_bin_get
argument_list|(
name|tcache
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|arena_stats_large_nrequests_add
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|stats
argument_list|,
name|i
argument_list|,
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
argument_list|)
expr_stmt|;
name|tbin
operator|->
name|tstats
operator|.
name|nrequests
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|tcaches_create_prep
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|)
block|{
name|bool
name|err
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|tcaches_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcaches
operator|==
name|NULL
condition|)
block|{
name|tcaches
operator|=
name|base_alloc
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|b0get
argument_list|()
argument_list|,
sizeof|sizeof
argument_list|(
name|tcache_t
operator|*
argument_list|)
operator|*
operator|(
name|MALLOCX_TCACHE_MAX
operator|+
literal|1
operator|)
argument_list|,
name|CACHELINE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcaches
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|true
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
block|}
if|if
condition|(
name|tcaches_avail
operator|==
name|NULL
operator|&&
name|tcaches_past
operator|>
name|MALLOCX_TCACHE_MAX
condition|)
block|{
name|err
operator|=
name|true
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
name|err
operator|=
name|false
expr_stmt|;
name|label_return
label|:
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|tcaches_mtx
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|bool
name|tcaches_create
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|unsigned
modifier|*
name|r_ind
parameter_list|)
block|{
name|witness_assert_depth
argument_list|(
name|tsdn_witness_tsdp_get
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bool
name|err
decl_stmt|;
if|if
condition|(
name|tcaches_create_prep
argument_list|(
name|tsd
argument_list|)
condition|)
block|{
name|err
operator|=
name|true
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
name|tcache_t
modifier|*
name|tcache
init|=
name|tcache_create_explicit
argument_list|(
name|tsd
argument_list|)
decl_stmt|;
if|if
condition|(
name|tcache
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|true
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
name|tcaches_t
modifier|*
name|elm
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|tcaches_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcaches_avail
operator|!=
name|NULL
condition|)
block|{
name|elm
operator|=
name|tcaches_avail
expr_stmt|;
name|tcaches_avail
operator|=
name|tcaches_avail
operator|->
name|next
expr_stmt|;
name|elm
operator|->
name|tcache
operator|=
name|tcache
expr_stmt|;
operator|*
name|r_ind
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|elm
operator|-
name|tcaches
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|elm
operator|=
operator|&
name|tcaches
index|[
name|tcaches_past
index|]
expr_stmt|;
name|elm
operator|->
name|tcache
operator|=
name|tcache
expr_stmt|;
operator|*
name|r_ind
operator|=
name|tcaches_past
expr_stmt|;
name|tcaches_past
operator|++
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|tcaches_mtx
argument_list|)
expr_stmt|;
name|err
operator|=
name|false
expr_stmt|;
name|label_return
label|:
name|witness_assert_depth
argument_list|(
name|tsdn_witness_tsdp_get
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|tcache_t
modifier|*
name|tcaches_elm_remove
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|tcaches_t
modifier|*
name|elm
parameter_list|)
block|{
name|malloc_mutex_assert_owner
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|tcaches_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|elm
operator|->
name|tcache
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|tcache_t
modifier|*
name|tcache
init|=
name|elm
operator|->
name|tcache
decl_stmt|;
name|elm
operator|->
name|tcache
operator|=
name|NULL
expr_stmt|;
return|return
name|tcache
return|;
block|}
end_function

begin_function
name|void
name|tcaches_flush
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|unsigned
name|ind
parameter_list|)
block|{
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|tcaches_mtx
argument_list|)
expr_stmt|;
name|tcache_t
modifier|*
name|tcache
init|=
name|tcaches_elm_remove
argument_list|(
name|tsd
argument_list|,
operator|&
name|tcaches
index|[
name|ind
index|]
argument_list|)
decl_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|tcaches_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcache
operator|!=
name|NULL
condition|)
block|{
name|tcache_destroy
argument_list|(
name|tsd
argument_list|,
name|tcache
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|tcaches_destroy
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|unsigned
name|ind
parameter_list|)
block|{
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|tcaches_mtx
argument_list|)
expr_stmt|;
name|tcaches_t
modifier|*
name|elm
init|=
operator|&
name|tcaches
index|[
name|ind
index|]
decl_stmt|;
name|tcache_t
modifier|*
name|tcache
init|=
name|tcaches_elm_remove
argument_list|(
name|tsd
argument_list|,
name|elm
argument_list|)
decl_stmt|;
name|elm
operator|->
name|next
operator|=
name|tcaches_avail
expr_stmt|;
name|tcaches_avail
operator|=
name|elm
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|tcaches_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcache
operator|!=
name|NULL
condition|)
block|{
name|tcache_destroy
argument_list|(
name|tsd
argument_list|,
name|tcache
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|bool
name|tcache_boot
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
block|{
comment|/* If necessary, clamp opt_lg_tcache_max. */
if|if
condition|(
name|opt_lg_tcache_max
operator|<
literal|0
operator|||
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
name|opt_lg_tcache_max
operator|)
operator|<
name|SMALL_MAXCLASS
condition|)
block|{
name|tcache_maxclass
operator|=
name|SMALL_MAXCLASS
expr_stmt|;
block|}
else|else
block|{
name|tcache_maxclass
operator|=
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
name|opt_lg_tcache_max
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|tcaches_mtx
argument_list|,
literal|"tcaches"
argument_list|,
name|WITNESS_RANK_TCACHES
argument_list|,
name|malloc_mutex_rank_exclusive
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|nhbins
operator|=
name|sz_size2index
argument_list|(
name|tcache_maxclass
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Initialize tcache_bin_info. */
name|tcache_bin_info
operator|=
operator|(
name|tcache_bin_info_t
operator|*
operator|)
name|base_alloc
argument_list|(
name|tsdn
argument_list|,
name|b0get
argument_list|()
argument_list|,
name|nhbins
operator|*
sizeof|sizeof
argument_list|(
name|tcache_bin_info_t
argument_list|)
argument_list|,
name|CACHELINE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcache_bin_info
operator|==
name|NULL
condition|)
block|{
return|return
name|true
return|;
block|}
name|stack_nelms
operator|=
literal|0
expr_stmt|;
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|arena_bin_info
index|[
name|i
index|]
operator|.
name|nregs
operator|<<
literal|1
operator|)
operator|<=
name|TCACHE_NSLOTS_SMALL_MIN
condition|)
block|{
name|tcache_bin_info
index|[
name|i
index|]
operator|.
name|ncached_max
operator|=
name|TCACHE_NSLOTS_SMALL_MIN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|arena_bin_info
index|[
name|i
index|]
operator|.
name|nregs
operator|<<
literal|1
operator|)
operator|<=
name|TCACHE_NSLOTS_SMALL_MAX
condition|)
block|{
name|tcache_bin_info
index|[
name|i
index|]
operator|.
name|ncached_max
operator|=
operator|(
name|arena_bin_info
index|[
name|i
index|]
operator|.
name|nregs
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|tcache_bin_info
index|[
name|i
index|]
operator|.
name|ncached_max
operator|=
name|TCACHE_NSLOTS_SMALL_MAX
expr_stmt|;
block|}
name|stack_nelms
operator|+=
name|tcache_bin_info
index|[
name|i
index|]
operator|.
name|ncached_max
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|nhbins
condition|;
name|i
operator|++
control|)
block|{
name|tcache_bin_info
index|[
name|i
index|]
operator|.
name|ncached_max
operator|=
name|TCACHE_NSLOTS_LARGE
expr_stmt|;
name|stack_nelms
operator|+=
name|tcache_bin_info
index|[
name|i
index|]
operator|.
name|ncached_max
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
name|void
name|tcache_prefork
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|config_prof
operator|&&
name|opt_tcache
condition|)
block|{
name|malloc_mutex_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|tcaches_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|tcache_postfork_parent
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|config_prof
operator|&&
name|opt_tcache
condition|)
block|{
name|malloc_mutex_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|tcaches_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|tcache_postfork_child
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|config_prof
operator|&&
name|opt_tcache
condition|)
block|{
name|malloc_mutex_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|tcaches_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

