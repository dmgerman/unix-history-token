begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|JEMALLOC_C_
end_define

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_preamble.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_internal_includes.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/assert.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/atomic.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/ctl.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/extent_dss.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/extent_mmap.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_internal_types.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/malloc_io.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/mutex.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/rtree.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/size_classes.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/spin.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/sz.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/ticker.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/util.h"
end_include

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/* Data. */
end_comment

begin_comment
comment|/* Work around<http://llvm.org/bugs/show_bug.cgi?id=12623>: */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|__malloc_options_1_0
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|__sym_compat
argument_list|(
name|_malloc_options
argument_list|,
name|__malloc_options_1_0
argument_list|,
name|FBSD_1
literal|.0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Runtime configuration options. */
end_comment

begin_function_decl
specifier|const
name|char
modifier|*
name|je_malloc_conf
ifndef|#
directive|ifndef
name|_WIN32
name|JEMALLOC_ATTR
parameter_list|(
name|weak
parameter_list|)
endif|#
directive|endif
function_decl|;
end_function_decl

begin_decl_stmt
name|bool
name|opt_abort
init|=
ifdef|#
directive|ifdef
name|JEMALLOC_DEBUG
name|true
else|#
directive|else
name|false
endif|#
directive|endif
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_abort_conf
init|=
ifdef|#
directive|ifdef
name|JEMALLOC_DEBUG
name|true
else|#
directive|else
name|false
endif|#
directive|endif
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|opt_junk
init|=
if|#
directive|if
operator|(
name|defined
argument_list|(
name|JEMALLOC_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|JEMALLOC_FILL
argument_list|)
operator|)
literal|"true"
else|#
directive|else
literal|"false"
endif|#
directive|endif
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_junk_alloc
init|=
if|#
directive|if
operator|(
name|defined
argument_list|(
name|JEMALLOC_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|JEMALLOC_FILL
argument_list|)
operator|)
name|true
else|#
directive|else
name|false
endif|#
directive|endif
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_junk_free
init|=
if|#
directive|if
operator|(
name|defined
argument_list|(
name|JEMALLOC_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|JEMALLOC_FILL
argument_list|)
operator|)
name|true
else|#
directive|else
name|false
endif|#
directive|endif
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_utrace
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_xmalloc
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_zero
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|opt_narenas
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|ncpus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Protects arenas initialization. */
end_comment

begin_decl_stmt
name|malloc_mutex_t
name|arenas_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Arenas that are used to service external requests.  Not all elements of the  * arenas array are necessarily used; arenas are created lazily as needed.  *  * arenas[0..narenas_auto) are used for automatic multiplexing of threads and  * arenas.  arenas[narenas_auto..narenas_total) are only used if the application  * takes some action to create them and allocate from them.  *  * Points to an arena_t.  */
end_comment

begin_macro
name|JEMALLOC_ALIGNED
argument_list|(
argument|CACHELINE
argument_list|)
end_macro

begin_decl_stmt
name|atomic_p_t
name|arenas
index|[
name|MALLOCX_ARENA_LIMIT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|atomic_u_t
name|narenas_total
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use narenas_total_*(). */
end_comment

begin_decl_stmt
specifier|static
name|arena_t
modifier|*
name|a0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* arenas[0]; read-only after initialization. */
end_comment

begin_decl_stmt
name|unsigned
name|narenas_auto
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read-only after initialization. */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|malloc_init_uninitialized
init|=
literal|3
block|,
name|malloc_init_a0_initialized
init|=
literal|2
block|,
name|malloc_init_recursible
init|=
literal|1
block|,
name|malloc_init_initialized
init|=
literal|0
comment|/* Common case --> jnz. */
block|}
name|malloc_init_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|malloc_init_t
name|malloc_init_state
init|=
name|malloc_init_uninitialized
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* False should be the common case.  Set to true to trigger initialization. */
end_comment

begin_decl_stmt
name|bool
name|malloc_slow
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When malloc_slow is true, set the corresponding bits for sanity check. */
end_comment

begin_enum
enum|enum
block|{
name|flag_opt_junk_alloc
init|=
operator|(
literal|1U
operator|)
block|,
name|flag_opt_junk_free
init|=
operator|(
literal|1U
operator|<<
literal|1
operator|)
block|,
name|flag_opt_zero
init|=
operator|(
literal|1U
operator|<<
literal|2
operator|)
block|,
name|flag_opt_utrace
init|=
operator|(
literal|1U
operator|<<
literal|3
operator|)
block|,
name|flag_opt_xmalloc
init|=
operator|(
literal|1U
operator|<<
literal|4
operator|)
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|uint8_t
name|malloc_slow_flags
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_THREADED_INIT
end_ifdef

begin_comment
comment|/* Used to let the initializing thread recursively allocate. */
end_comment

begin_define
define|#
directive|define
name|NO_INITIALIZER
value|((unsigned long)0)
end_define

begin_define
define|#
directive|define
name|INITIALIZER
value|pthread_self()
end_define

begin_define
define|#
directive|define
name|IS_INITIALIZER
value|(malloc_initializer == pthread_self())
end_define

begin_decl_stmt
specifier|static
name|pthread_t
name|malloc_initializer
init|=
name|NO_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NO_INITIALIZER
value|false
end_define

begin_define
define|#
directive|define
name|INITIALIZER
value|true
end_define

begin_define
define|#
directive|define
name|IS_INITIALIZER
value|malloc_initializer
end_define

begin_decl_stmt
specifier|static
name|bool
name|malloc_initializer
init|=
name|NO_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Used to avoid initialization races. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_if
if|#
directive|if
name|_WIN32_WINNT
operator|>=
literal|0x0600
end_if

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|init_lock
init|=
name|SRWLOCK_INIT
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|init_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|init_lock_initialized
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_macro
name|JEMALLOC_ATTR
argument_list|(
argument|constructor
argument_list|)
end_macro

begin_function
specifier|static
name|void
name|WINAPI
name|_init_init_lock
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * If another constructor in the same binary is using mallctl to e.g. 	 * set up extent hooks, it may end up running before this one, and 	 * malloc_init_hard will crash trying to lock the uninitialized lock. So 	 * we force an initialization of the lock in malloc_init_hard as well. 	 * We don't try to care about atomicity of the accessed to the 	 * init_lock_initialized boolean, since it really only matters early in 	 * the process creation, before any separate thread normally starts 	 * doing anything. 	 */
if|if
condition|(
operator|!
name|init_lock_initialized
condition|)
block|{
name|malloc_mutex_init
argument_list|(
operator|&
name|init_lock
argument_list|,
literal|"init"
argument_list|,
name|WITNESS_RANK_INIT
argument_list|,
name|malloc_mutex_rank_exclusive
argument_list|)
expr_stmt|;
block|}
name|init_lock_initialized
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|section
name|(
literal|".CRT$XCU"
name|,
name|read
name|)
end_pragma

begin_macro
name|JEMALLOC_SECTION
argument_list|(
literal|".CRT$XCU"
argument_list|)
end_macro

begin_macro
name|JEMALLOC_ATTR
argument_list|(
argument|used
argument_list|)
end_macro

begin_function_decl
specifier|static
specifier|const
name|void
function_decl|(
name|WINAPI
modifier|*
name|init_init_lock
function_decl|)
parameter_list|(
name|void
parameter_list|)
init|=
name|_init_init_lock
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|init_lock
init|=
name|MALLOC_MUTEX_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
block|{
name|void
modifier|*
name|p
decl_stmt|;
comment|/* Input pointer (as in realloc(p, s)). */
name|size_t
name|s
decl_stmt|;
comment|/* Request size. */
name|void
modifier|*
name|r
decl_stmt|;
comment|/* Result pointer. */
block|}
name|malloc_utrace_t
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_UTRACE
end_ifdef

begin_define
define|#
directive|define
name|UTRACE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|do {						\ 	if (unlikely(opt_utrace)) {					\ 		int utrace_serrno = errno;				\ 		malloc_utrace_t ut;					\ 		ut.p = (a);						\ 		ut.s = (b);						\ 		ut.r = (c);						\ 		utrace(&ut, sizeof(ut));				\ 		errno = utrace_serrno;					\ 	}								\ } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|UTRACE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Whether encountered any invalid config options. */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|had_conf_error
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Function prototypes for static functions that are referenced prior to  * definition.  */
end_comment

begin_function_decl
specifier|static
name|bool
name|malloc_init_hard_a0
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|malloc_init_hard
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin miscellaneous support functions.  */
end_comment

begin_function
name|bool
name|malloc_initialized
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|malloc_init_state
operator|==
name|malloc_init_initialized
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|bool
name|malloc_init_a0
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|malloc_init_state
operator|==
name|malloc_init_uninitialized
argument_list|)
condition|)
block|{
return|return
name|malloc_init_hard_a0
argument_list|()
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|bool
name|malloc_init
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|malloc_initialized
argument_list|()
argument_list|)
operator|&&
name|malloc_init_hard
argument_list|()
condition|)
block|{
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * The a0*() functions are used instead of i{d,}alloc() in situations that  * cannot tolerate TLS variable access.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|a0ialloc
parameter_list|(
name|size_t
name|size
parameter_list|,
name|bool
name|zero
parameter_list|,
name|bool
name|is_internal
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|malloc_init_a0
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
return|return
name|iallocztm
argument_list|(
name|TSDN_NULL
argument_list|,
name|size
argument_list|,
name|sz_size2index
argument_list|(
name|size
argument_list|)
argument_list|,
name|zero
argument_list|,
name|NULL
argument_list|,
name|is_internal
argument_list|,
name|arena_get
argument_list|(
name|TSDN_NULL
argument_list|,
literal|0
argument_list|,
name|true
argument_list|)
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|a0idalloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|bool
name|is_internal
parameter_list|)
block|{
name|idalloctm
argument_list|(
name|TSDN_NULL
argument_list|,
name|ptr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|is_internal
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|a0malloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
return|return
name|a0ialloc
argument_list|(
name|size
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|a0dalloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|a0idalloc
argument_list|(
name|ptr
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * FreeBSD's libc uses the bootstrap_*() functions in bootstrap-senstive  * situations that cannot tolerate TLS variable access (TLS allocation and very  * early internal data structure initialization).  */
end_comment

begin_function
name|void
modifier|*
name|bootstrap_malloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|size
operator|==
literal|0
argument_list|)
condition|)
block|{
name|size
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|a0ialloc
argument_list|(
name|size
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|bootstrap_calloc
parameter_list|(
name|size_t
name|num
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|num_size
decl_stmt|;
name|num_size
operator|=
name|num
operator|*
name|size
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|num_size
operator|==
literal|0
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|num
operator|==
literal|0
operator|||
name|size
operator|==
literal|0
argument_list|)
expr_stmt|;
name|num_size
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|a0ialloc
argument_list|(
name|num_size
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|bootstrap_free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|ptr
operator|==
name|NULL
argument_list|)
condition|)
block|{
return|return;
block|}
name|a0idalloc
argument_list|(
name|ptr
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_set
parameter_list|(
name|unsigned
name|ind
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|atomic_store_p
argument_list|(
operator|&
name|arenas
index|[
name|ind
index|]
argument_list|,
name|arena
argument_list|,
name|ATOMIC_RELEASE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|narenas_total_set
parameter_list|(
name|unsigned
name|narenas
parameter_list|)
block|{
name|atomic_store_u
argument_list|(
operator|&
name|narenas_total
argument_list|,
name|narenas
argument_list|,
name|ATOMIC_RELEASE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|narenas_total_inc
parameter_list|(
name|void
parameter_list|)
block|{
name|atomic_fetch_add_u
argument_list|(
operator|&
name|narenas_total
argument_list|,
literal|1
argument_list|,
name|ATOMIC_RELEASE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|narenas_total_get
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|atomic_load_u
argument_list|(
operator|&
name|narenas_total
argument_list|,
name|ATOMIC_ACQUIRE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a new arena and insert it into the arenas array at index ind. */
end_comment

begin_function
specifier|static
name|arena_t
modifier|*
name|arena_init_locked
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|unsigned
name|ind
parameter_list|,
name|extent_hooks_t
modifier|*
name|extent_hooks
parameter_list|)
block|{
name|arena_t
modifier|*
name|arena
decl_stmt|;
name|assert
argument_list|(
name|ind
operator|<=
name|narenas_total_get
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind
operator|>=
name|MALLOCX_ARENA_LIMIT
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|ind
operator|==
name|narenas_total_get
argument_list|()
condition|)
block|{
name|narenas_total_inc
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Another thread may have already initialized arenas[ind] if it's an 	 * auto arena. 	 */
name|arena
operator|=
name|arena_get
argument_list|(
name|tsdn
argument_list|,
name|ind
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|arena
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|ind
operator|<
name|narenas_auto
argument_list|)
expr_stmt|;
return|return
name|arena
return|;
block|}
comment|/* Actually initialize the arena. */
name|arena
operator|=
name|arena_new
argument_list|(
name|tsdn
argument_list|,
name|ind
argument_list|,
name|extent_hooks
argument_list|)
expr_stmt|;
return|return
name|arena
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_new_create_background_thread
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|unsigned
name|ind
parameter_list|)
block|{
if|if
condition|(
name|ind
operator|==
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|have_background_thread
condition|)
block|{
name|bool
name|err
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|background_thread_lock
argument_list|)
expr_stmt|;
name|err
operator|=
name|background_thread_create
argument_list|(
name|tsdn_tsd
argument_list|(
name|tsdn
argument_list|)
argument_list|,
name|ind
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|background_thread_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|malloc_printf
argument_list|(
literal|"<jemalloc>: error in background thread "
literal|"creation for arena %u. Abort.\n"
argument_list|,
name|ind
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|arena_t
modifier|*
name|arena_init
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|unsigned
name|ind
parameter_list|,
name|extent_hooks_t
modifier|*
name|extent_hooks
parameter_list|)
block|{
name|arena_t
modifier|*
name|arena
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
name|arena
operator|=
name|arena_init_locked
argument_list|(
name|tsdn
argument_list|,
name|ind
argument_list|,
name|extent_hooks
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
name|arena_new_create_background_thread
argument_list|(
name|tsdn
argument_list|,
name|ind
argument_list|)
expr_stmt|;
return|return
name|arena
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_bind
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|unsigned
name|ind
parameter_list|,
name|bool
name|internal
parameter_list|)
block|{
name|arena_t
modifier|*
name|arena
init|=
name|arena_get
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ind
argument_list|,
name|false
argument_list|)
decl_stmt|;
name|arena_nthreads_inc
argument_list|(
name|arena
argument_list|,
name|internal
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal
condition|)
block|{
name|tsd_iarena_set
argument_list|(
name|tsd
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tsd_arena_set
argument_list|(
name|tsd
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|arena_migrate
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|unsigned
name|oldind
parameter_list|,
name|unsigned
name|newind
parameter_list|)
block|{
name|arena_t
modifier|*
name|oldarena
decl_stmt|,
modifier|*
name|newarena
decl_stmt|;
name|oldarena
operator|=
name|arena_get
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|oldind
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|newarena
operator|=
name|arena_get
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|newind
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|arena_nthreads_dec
argument_list|(
name|oldarena
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|arena_nthreads_inc
argument_list|(
name|newarena
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|tsd_arena_set
argument_list|(
name|tsd
argument_list|,
name|newarena
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_unbind
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|unsigned
name|ind
parameter_list|,
name|bool
name|internal
parameter_list|)
block|{
name|arena_t
modifier|*
name|arena
decl_stmt|;
name|arena
operator|=
name|arena_get
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ind
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|arena_nthreads_dec
argument_list|(
name|arena
argument_list|,
name|internal
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal
condition|)
block|{
name|tsd_iarena_set
argument_list|(
name|tsd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tsd_arena_set
argument_list|(
name|tsd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|arena_tdata_t
modifier|*
name|arena_tdata_get_hard
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|unsigned
name|ind
parameter_list|)
block|{
name|arena_tdata_t
modifier|*
name|tdata
decl_stmt|,
modifier|*
name|arenas_tdata_old
decl_stmt|;
name|arena_tdata_t
modifier|*
name|arenas_tdata
init|=
name|tsd_arenas_tdata_get
argument_list|(
name|tsd
argument_list|)
decl_stmt|;
name|unsigned
name|narenas_tdata_old
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|narenas_tdata
init|=
name|tsd_narenas_tdata_get
argument_list|(
name|tsd
argument_list|)
decl_stmt|;
name|unsigned
name|narenas_actual
init|=
name|narenas_total_get
argument_list|()
decl_stmt|;
comment|/* 	 * Dissociate old tdata array (and set up for deallocation upon return) 	 * if it's too small. 	 */
if|if
condition|(
name|arenas_tdata
operator|!=
name|NULL
operator|&&
name|narenas_tdata
operator|<
name|narenas_actual
condition|)
block|{
name|arenas_tdata_old
operator|=
name|arenas_tdata
expr_stmt|;
name|narenas_tdata_old
operator|=
name|narenas_tdata
expr_stmt|;
name|arenas_tdata
operator|=
name|NULL
expr_stmt|;
name|narenas_tdata
operator|=
literal|0
expr_stmt|;
name|tsd_arenas_tdata_set
argument_list|(
name|tsd
argument_list|,
name|arenas_tdata
argument_list|)
expr_stmt|;
name|tsd_narenas_tdata_set
argument_list|(
name|tsd
argument_list|,
name|narenas_tdata
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arenas_tdata_old
operator|=
name|NULL
expr_stmt|;
name|narenas_tdata_old
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Allocate tdata array if it's missing. */
if|if
condition|(
name|arenas_tdata
operator|==
name|NULL
condition|)
block|{
name|bool
modifier|*
name|arenas_tdata_bypassp
init|=
name|tsd_arenas_tdata_bypassp_get
argument_list|(
name|tsd
argument_list|)
decl_stmt|;
name|narenas_tdata
operator|=
operator|(
name|ind
operator|<
name|narenas_actual
operator|)
condition|?
name|narenas_actual
else|:
name|ind
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tsd_nominal
argument_list|(
name|tsd
argument_list|)
operator|&&
operator|!
operator|*
name|arenas_tdata_bypassp
condition|)
block|{
operator|*
name|arenas_tdata_bypassp
operator|=
name|true
expr_stmt|;
name|arenas_tdata
operator|=
operator|(
name|arena_tdata_t
operator|*
operator|)
name|a0malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arena_tdata_t
argument_list|)
operator|*
name|narenas_tdata
argument_list|)
expr_stmt|;
operator|*
name|arenas_tdata_bypassp
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|arenas_tdata
operator|==
name|NULL
condition|)
block|{
name|tdata
operator|=
name|NULL
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
name|assert
argument_list|(
name|tsd_nominal
argument_list|(
name|tsd
argument_list|)
operator|&&
operator|!
operator|*
name|arenas_tdata_bypassp
argument_list|)
expr_stmt|;
name|tsd_arenas_tdata_set
argument_list|(
name|tsd
argument_list|,
name|arenas_tdata
argument_list|)
expr_stmt|;
name|tsd_narenas_tdata_set
argument_list|(
name|tsd
argument_list|,
name|narenas_tdata
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Copy to tdata array.  It's possible that the actual number of arenas 	 * has increased since narenas_total_get() was called above, but that 	 * causes no correctness issues unless two threads concurrently execute 	 * the arenas.create mallctl, which we trust mallctl synchronization to 	 * prevent. 	 */
comment|/* Copy/initialize tickers. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|narenas_actual
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|narenas_tdata_old
condition|)
block|{
name|ticker_copy
argument_list|(
operator|&
name|arenas_tdata
index|[
name|i
index|]
operator|.
name|decay_ticker
argument_list|,
operator|&
name|arenas_tdata_old
index|[
name|i
index|]
operator|.
name|decay_ticker
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ticker_init
argument_list|(
operator|&
name|arenas_tdata
index|[
name|i
index|]
operator|.
name|decay_ticker
argument_list|,
name|DECAY_NTICKS_PER_UPDATE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|narenas_tdata
operator|>
name|narenas_actual
condition|)
block|{
name|memset
argument_list|(
operator|&
name|arenas_tdata
index|[
name|narenas_actual
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|arena_tdata_t
argument_list|)
operator|*
operator|(
name|narenas_tdata
operator|-
name|narenas_actual
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Read the refreshed tdata array. */
name|tdata
operator|=
operator|&
name|arenas_tdata
index|[
name|ind
index|]
expr_stmt|;
name|label_return
label|:
if|if
condition|(
name|arenas_tdata_old
operator|!=
name|NULL
condition|)
block|{
name|a0dalloc
argument_list|(
name|arenas_tdata_old
argument_list|)
expr_stmt|;
block|}
return|return
name|tdata
return|;
block|}
end_function

begin_comment
comment|/* Slow path, called only by arena_choose(). */
end_comment

begin_function
name|arena_t
modifier|*
name|arena_choose_hard
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|bool
name|internal
parameter_list|)
block|{
name|arena_t
modifier|*
name|ret
name|JEMALLOC_CC_SILENCE_INIT
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|have_percpu_arena
operator|&&
name|PERCPU_ARENA_ENABLED
argument_list|(
name|opt_percpu_arena
argument_list|)
condition|)
block|{
name|unsigned
name|choose
init|=
name|percpu_arena_choose
argument_list|()
decl_stmt|;
name|ret
operator|=
name|arena_get
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|choose
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|arena_bind
argument_list|(
name|tsd
argument_list|,
name|arena_ind_get
argument_list|(
name|ret
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|arena_bind
argument_list|(
name|tsd
argument_list|,
name|arena_ind_get
argument_list|(
name|ret
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|narenas_auto
operator|>
literal|1
condition|)
block|{
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|,
name|choose
index|[
literal|2
index|]
decl_stmt|,
name|first_null
decl_stmt|;
name|bool
name|is_new_arena
index|[
literal|2
index|]
decl_stmt|;
comment|/* 		 * Determine binding for both non-internal and internal 		 * allocation. 		 * 		 *   choose[0]: For application allocation. 		 *   choose[1]: For internal metadata allocation. 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|choose
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|is_new_arena
index|[
name|j
index|]
operator|=
name|false
expr_stmt|;
block|}
name|first_null
operator|=
name|narenas_auto
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_get
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|narenas_auto
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|arena_get
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|i
argument_list|,
name|false
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Choose the first arena that has the lowest 				 * number of threads assigned to it. 				 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|arena_nthreads_get
argument_list|(
name|arena_get
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|i
argument_list|,
name|false
argument_list|)
argument_list|,
operator|!
operator|!
name|j
argument_list|)
operator|<
name|arena_nthreads_get
argument_list|(
name|arena_get
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|choose
index|[
name|j
index|]
argument_list|,
name|false
argument_list|)
argument_list|,
operator|!
operator|!
name|j
argument_list|)
condition|)
block|{
name|choose
index|[
name|j
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|first_null
operator|==
name|narenas_auto
condition|)
block|{
comment|/* 				 * Record the index of the first uninitialized 				 * arena, in case all extant arenas are in use. 				 * 				 * NB: It is possible for there to be 				 * discontinuities in terms of initialized 				 * versus uninitialized arenas, due to the 				 * "thread.arena" mallctl. 				 */
name|first_null
operator|=
name|i
expr_stmt|;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|arena_nthreads_get
argument_list|(
name|arena_get
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|choose
index|[
name|j
index|]
argument_list|,
name|false
argument_list|)
argument_list|,
operator|!
operator|!
name|j
argument_list|)
operator|==
literal|0
operator|||
name|first_null
operator|==
name|narenas_auto
condition|)
block|{
comment|/* 				 * Use an unloaded arena, or the least loaded 				 * arena if all arenas are already initialized. 				 */
if|if
condition|(
operator|!
operator|!
name|j
operator|==
name|internal
condition|)
block|{
name|ret
operator|=
name|arena_get
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|choose
index|[
name|j
index|]
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|arena_t
modifier|*
name|arena
decl_stmt|;
comment|/* Initialize a new arena. */
name|choose
index|[
name|j
index|]
operator|=
name|first_null
expr_stmt|;
name|arena
operator|=
name|arena_init_locked
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|choose
index|[
name|j
index|]
argument_list|,
operator|(
name|extent_hooks_t
operator|*
operator|)
operator|&
name|extent_hooks_default
argument_list|)
expr_stmt|;
if|if
condition|(
name|arena
operator|==
name|NULL
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|is_new_arena
index|[
name|j
index|]
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
operator|!
name|j
operator|==
name|internal
condition|)
block|{
name|ret
operator|=
name|arena
expr_stmt|;
block|}
block|}
name|arena_bind
argument_list|(
name|tsd
argument_list|,
name|choose
index|[
name|j
index|]
argument_list|,
operator|!
operator|!
name|j
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|is_new_arena
index|[
name|j
index|]
condition|)
block|{
name|assert
argument_list|(
name|choose
index|[
name|j
index|]
operator|>
literal|0
argument_list|)
expr_stmt|;
name|arena_new_create_background_thread
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|choose
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|ret
operator|=
name|arena_get
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|arena_bind
argument_list|(
name|tsd
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|arena_bind
argument_list|(
name|tsd
argument_list|,
literal|0
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|iarena_cleanup
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|)
block|{
name|arena_t
modifier|*
name|iarena
decl_stmt|;
name|iarena
operator|=
name|tsd_iarena_get
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
if|if
condition|(
name|iarena
operator|!=
name|NULL
condition|)
block|{
name|arena_unbind
argument_list|(
name|tsd
argument_list|,
name|arena_ind_get
argument_list|(
name|iarena
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|arena_cleanup
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|)
block|{
name|arena_t
modifier|*
name|arena
decl_stmt|;
name|arena
operator|=
name|tsd_arena_get
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
if|if
condition|(
name|arena
operator|!=
name|NULL
condition|)
block|{
name|arena_unbind
argument_list|(
name|tsd
argument_list|,
name|arena_ind_get
argument_list|(
name|arena
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|arenas_tdata_cleanup
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|)
block|{
name|arena_tdata_t
modifier|*
name|arenas_tdata
decl_stmt|;
comment|/* Prevent tsd->arenas_tdata from being (re)created. */
operator|*
name|tsd_arenas_tdata_bypassp_get
argument_list|(
name|tsd
argument_list|)
operator|=
name|true
expr_stmt|;
name|arenas_tdata
operator|=
name|tsd_arenas_tdata_get
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
if|if
condition|(
name|arenas_tdata
operator|!=
name|NULL
condition|)
block|{
name|tsd_arenas_tdata_set
argument_list|(
name|tsd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|a0dalloc
argument_list|(
name|arenas_tdata
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|stats_print_atexit
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|config_stats
condition|)
block|{
name|tsdn_t
modifier|*
name|tsdn
decl_stmt|;
name|unsigned
name|narenas
decl_stmt|,
name|i
decl_stmt|;
name|tsdn
operator|=
name|tsdn_fetch
argument_list|()
expr_stmt|;
comment|/* 		 * Merge stats from extant threads.  This is racy, since 		 * individual threads do not lock when recording tcache stats 		 * events.  As a consequence, the final stats may be slightly 		 * out of date by the time they are reported, if other threads 		 * continue to allocate. 		 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|narenas
operator|=
name|narenas_total_get
argument_list|()
init|;
name|i
operator|<
name|narenas
condition|;
name|i
operator|++
control|)
block|{
name|arena_t
modifier|*
name|arena
init|=
name|arena_get
argument_list|(
name|tsdn
argument_list|,
name|i
argument_list|,
name|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|arena
operator|!=
name|NULL
condition|)
block|{
name|tcache_t
modifier|*
name|tcache
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|tcache_ql_mtx
argument_list|)
expr_stmt|;
name|ql_foreach
argument_list|(
argument|tcache
argument_list|,
argument|&arena->tcache_ql
argument_list|,
argument|link
argument_list|)
block|{
name|tcache_stats_merge
argument_list|(
name|tsdn
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|arena
operator|->
name|tcache_ql_mtx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|je_malloc_stats_print
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|opt_stats_print_opts
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Ensure that we don't hold any locks upon entry to or exit from allocator  * code (in a "broad" sense that doesn't count a reentrant allocation as an  * entrance or exit).  */
end_comment

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|void
name|check_entry_exit_locking
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|config_debug
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|tsdn_null
argument_list|(
name|tsdn
argument_list|)
condition|)
block|{
return|return;
block|}
name|tsd_t
modifier|*
name|tsd
init|=
name|tsdn_tsd
argument_list|(
name|tsdn
argument_list|)
decl_stmt|;
comment|/* 	 * It's possible we hold locks at entry/exit if we're in a nested 	 * allocation. 	 */
name|int8_t
name|reentrancy_level
init|=
name|tsd_reentrancy_level_get
argument_list|(
name|tsd
argument_list|)
decl_stmt|;
if|if
condition|(
name|reentrancy_level
operator|!=
literal|0
condition|)
block|{
return|return;
block|}
name|witness_assert_lockless
argument_list|(
name|tsdn_witness_tsdp_get
argument_list|(
name|tsdn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * End miscellaneous support functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin initialization functions.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|jemalloc_secure_getenv
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|JEMALLOC_HAVE_SECURE_GETENV
return|return
name|secure_getenv
argument_list|(
name|name
argument_list|)
return|;
else|#
directive|else
ifdef|#
directive|ifdef
name|JEMALLOC_HAVE_ISSETUGID
if|if
condition|(
name|issetugid
argument_list|()
operator|!=
literal|0
condition|)
block|{
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
return|return
name|getenv
argument_list|(
name|name
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|unsigned
name|malloc_ncpus
parameter_list|(
name|void
parameter_list|)
block|{
name|long
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
name|SYSTEM_INFO
name|si
decl_stmt|;
name|GetSystemInfo
argument_list|(
operator|&
name|si
argument_list|)
expr_stmt|;
name|result
operator|=
name|si
operator|.
name|dwNumberOfProcessors
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|JEMALLOC_GLIBC_MALLOC_HOOK
argument_list|)
operator|&&
name|defined
argument_list|(
name|CPU_COUNT
argument_list|)
comment|/* 	 * glibc>= 2.6 has the CPU_COUNT macro. 	 * 	 * glibc's sysconf() uses isspace().  glibc allocates for the first time 	 * *before* setting up the isspace tables.  Therefore we need a 	 * different method to get the number of CPUs. 	 */
block|{
name|cpu_set_t
name|set
decl_stmt|;
name|pthread_getaffinity_np
argument_list|(
name|pthread_self
argument_list|()
argument_list|,
sizeof|sizeof
argument_list|(
name|set
argument_list|)
argument_list|,
operator|&
name|set
argument_list|)
expr_stmt|;
name|result
operator|=
name|CPU_COUNT
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|result
operator|=
name|sysconf
argument_list|(
name|_SC_NPROCESSORS_ONLN
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|(
name|result
operator|==
operator|-
literal|1
operator|)
condition|?
literal|1
else|:
operator|(
name|unsigned
operator|)
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_opt_stats_print_opts
parameter_list|(
specifier|const
name|char
modifier|*
name|v
parameter_list|,
name|size_t
name|vlen
parameter_list|)
block|{
name|size_t
name|opts_len
init|=
name|strlen
argument_list|(
name|opt_stats_print_opts
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|opts_len
operator|<=
name|stats_print_tot_num_options
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vlen
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|v
index|[
name|i
index|]
condition|)
block|{
define|#
directive|define
name|OPTION
parameter_list|(
name|o
parameter_list|,
name|v
parameter_list|,
name|d
parameter_list|,
name|s
parameter_list|)
value|case o: break;
name|STATS_PRINT_OPTIONS
undef|#
directive|undef
name|OPTION
default|default:
continue|continue;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|opt_stats_print_opts
argument_list|,
name|v
index|[
name|i
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Ignore repeated. */
continue|continue;
block|}
name|opt_stats_print_opts
index|[
name|opts_len
operator|++
index|]
operator|=
name|v
index|[
name|i
index|]
expr_stmt|;
name|opt_stats_print_opts
index|[
name|opts_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|assert
argument_list|(
name|opts_len
operator|<=
name|stats_print_tot_num_options
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|opts_len
operator|==
name|strlen
argument_list|(
name|opt_stats_print_opts
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|malloc_conf_next
parameter_list|(
name|char
specifier|const
modifier|*
modifier|*
name|opts_p
parameter_list|,
name|char
specifier|const
modifier|*
modifier|*
name|k_p
parameter_list|,
name|size_t
modifier|*
name|klen_p
parameter_list|,
name|char
specifier|const
modifier|*
modifier|*
name|v_p
parameter_list|,
name|size_t
modifier|*
name|vlen_p
parameter_list|)
block|{
name|bool
name|accept
decl_stmt|;
specifier|const
name|char
modifier|*
name|opts
init|=
operator|*
name|opts_p
decl_stmt|;
operator|*
name|k_p
operator|=
name|opts
expr_stmt|;
for|for
control|(
name|accept
operator|=
name|false
init|;
operator|!
name|accept
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|opts
condition|)
block|{
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'_'
case|:
name|opts
operator|++
expr_stmt|;
break|break;
case|case
literal|':'
case|:
name|opts
operator|++
expr_stmt|;
operator|*
name|klen_p
operator|=
operator|(
name|uintptr_t
operator|)
name|opts
operator|-
literal|1
operator|-
operator|(
name|uintptr_t
operator|)
operator|*
name|k_p
expr_stmt|;
operator|*
name|v_p
operator|=
name|opts
expr_stmt|;
name|accept
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
if|if
condition|(
name|opts
operator|!=
operator|*
name|opts_p
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Conf string ends "
literal|"with key\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
default|default:
name|malloc_write
argument_list|(
literal|"<jemalloc>: Malformed conf string\n"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
for|for
control|(
name|accept
operator|=
name|false
init|;
operator|!
name|accept
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|opts
condition|)
block|{
case|case
literal|','
case|:
name|opts
operator|++
expr_stmt|;
comment|/* 			 * Look ahead one character here, because the next time 			 * this function is called, it will assume that end of 			 * input has been cleanly reached if no input remains, 			 * but we have optimistically already consumed the 			 * comma if one exists. 			 */
if|if
condition|(
operator|*
name|opts
operator|==
literal|'\0'
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Conf string ends "
literal|"with comma\n"
argument_list|)
expr_stmt|;
block|}
operator|*
name|vlen_p
operator|=
operator|(
name|uintptr_t
operator|)
name|opts
operator|-
literal|1
operator|-
operator|(
name|uintptr_t
operator|)
operator|*
name|v_p
expr_stmt|;
name|accept
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
operator|*
name|vlen_p
operator|=
operator|(
name|uintptr_t
operator|)
name|opts
operator|-
operator|(
name|uintptr_t
operator|)
operator|*
name|v_p
expr_stmt|;
name|accept
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|opts
operator|++
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|opts_p
operator|=
name|opts
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|malloc_abort_invalid_conf
parameter_list|(
name|void
parameter_list|)
block|{
name|assert
argument_list|(
name|opt_abort_conf
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"<jemalloc>: Abort (abort_conf:true) on invalid conf "
literal|"value (see above).\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|malloc_conf_error
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|k
parameter_list|,
name|size_t
name|klen
parameter_list|,
specifier|const
name|char
modifier|*
name|v
parameter_list|,
name|size_t
name|vlen
parameter_list|)
block|{
name|malloc_printf
argument_list|(
literal|"<jemalloc>: %s: %.*s:%.*s\n"
argument_list|,
name|msg
argument_list|,
operator|(
name|int
operator|)
name|klen
argument_list|,
name|k
argument_list|,
operator|(
name|int
operator|)
name|vlen
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|had_conf_error
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|opt_abort_conf
condition|)
block|{
name|malloc_abort_invalid_conf
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|malloc_slow_flag_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Combine the runtime options into malloc_slow for fast path.  Called 	 * after processing all the options. 	 */
name|malloc_slow_flags
operator||=
operator|(
name|opt_junk_alloc
condition|?
name|flag_opt_junk_alloc
else|:
literal|0
operator|)
operator||
operator|(
name|opt_junk_free
condition|?
name|flag_opt_junk_free
else|:
literal|0
operator|)
operator||
operator|(
name|opt_zero
condition|?
name|flag_opt_zero
else|:
literal|0
operator|)
operator||
operator|(
name|opt_utrace
condition|?
name|flag_opt_utrace
else|:
literal|0
operator|)
operator||
operator|(
name|opt_xmalloc
condition|?
name|flag_opt_xmalloc
else|:
literal|0
operator|)
expr_stmt|;
name|malloc_slow
operator|=
operator|(
name|malloc_slow_flags
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|malloc_conf_init
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|char
name|buf
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|opts
decl_stmt|,
modifier|*
name|k
decl_stmt|,
modifier|*
name|v
decl_stmt|;
name|size_t
name|klen
decl_stmt|,
name|vlen
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
comment|/* Get runtime configuration. */
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
name|opts
operator|=
name|config_malloc_conf
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|je_malloc_conf
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Use options that were compiled into the 				 * program. 				 */
name|opts
operator|=
name|je_malloc_conf
expr_stmt|;
block|}
else|else
block|{
comment|/* No configuration specified. */
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opts
operator|=
name|buf
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
block|{
name|ssize_t
name|linklen
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|_WIN32
name|int
name|saved_errno
init|=
name|errno
decl_stmt|;
specifier|const
name|char
modifier|*
name|linkname
init|=
ifdef|#
directive|ifdef
name|JEMALLOC_PREFIX
literal|"/etc/"
name|JEMALLOC_PREFIX
literal|"malloc.conf"
else|#
directive|else
literal|"/etc/malloc.conf"
endif|#
directive|endif
decl_stmt|;
comment|/* 			 * Try to use the contents of the "/etc/malloc.conf" 			 * symbolic link's name. 			 */
name|linklen
operator|=
name|readlink
argument_list|(
name|linkname
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|linklen
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* No configuration specified. */
name|linklen
operator|=
literal|0
expr_stmt|;
comment|/* Restore errno. */
name|set_errno
argument_list|(
name|saved_errno
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|buf
index|[
name|linklen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opts
operator|=
name|buf
expr_stmt|;
break|break;
block|}
case|case
literal|3
case|:
block|{
specifier|const
name|char
modifier|*
name|envname
init|=
ifdef|#
directive|ifdef
name|JEMALLOC_PREFIX
name|JEMALLOC_CPREFIX
literal|"MALLOC_CONF"
else|#
directive|else
literal|"MALLOC_CONF"
endif|#
directive|endif
decl_stmt|;
if|if
condition|(
operator|(
name|opts
operator|=
name|jemalloc_secure_getenv
argument_list|(
name|envname
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Do nothing; opts is already initialized to 				 * the value of the MALLOC_CONF environment 				 * variable. 				 */
block|}
else|else
block|{
comment|/* No configuration specified. */
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opts
operator|=
name|buf
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|not_reached
argument_list|()
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opts
operator|=
name|buf
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|opts
operator|!=
literal|'\0'
operator|&&
operator|!
name|malloc_conf_next
argument_list|(
operator|&
name|opts
argument_list|,
operator|&
name|k
argument_list|,
operator|&
name|klen
argument_list|,
operator|&
name|v
argument_list|,
operator|&
name|vlen
argument_list|)
condition|)
block|{
define|#
directive|define
name|CONF_MATCH
parameter_list|(
name|n
parameter_list|)
define|\
value|(sizeof(n)-1 == klen&& strncmp(n, k, klen) == 0)
define|#
directive|define
name|CONF_MATCH_VALUE
parameter_list|(
name|n
parameter_list|)
define|\
value|(sizeof(n)-1 == vlen&& strncmp(n, v, vlen) == 0)
define|#
directive|define
name|CONF_HANDLE_BOOL
parameter_list|(
name|o
parameter_list|,
name|n
parameter_list|)
define|\
value|if (CONF_MATCH(n)) {				\ 				if (CONF_MATCH_VALUE("true")) {		\ 					o = true;			\ 				} else if (CONF_MATCH_VALUE("false")) {	\ 					o = false;			\ 				} else {				\ 					malloc_conf_error(		\ 					    "Invalid conf value",	\ 					    k, klen, v, vlen);		\ 				}					\ 				continue;				\ 			}
define|#
directive|define
name|CONF_MIN_no
parameter_list|(
name|um
parameter_list|,
name|min
parameter_list|)
value|false
define|#
directive|define
name|CONF_MIN_yes
parameter_list|(
name|um
parameter_list|,
name|min
parameter_list|)
value|((um)< (min))
define|#
directive|define
name|CONF_MAX_no
parameter_list|(
name|um
parameter_list|,
name|max
parameter_list|)
value|false
define|#
directive|define
name|CONF_MAX_yes
parameter_list|(
name|um
parameter_list|,
name|max
parameter_list|)
value|((um)> (max))
define|#
directive|define
name|CONF_HANDLE_T_U
parameter_list|(
name|t
parameter_list|,
name|o
parameter_list|,
name|n
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|,
name|check_min
parameter_list|,
name|check_max
parameter_list|,
name|clip
parameter_list|)
define|\
value|if (CONF_MATCH(n)) {				\ 				uintmax_t um;				\ 				char *end;				\ 									\ 				set_errno(0);				\ 				um = malloc_strtoumax(v,&end, 0);	\ 				if (get_errno() != 0 || (uintptr_t)end -\ 				    (uintptr_t)v != vlen) {		\ 					malloc_conf_error(		\ 					    "Invalid conf value",	\ 					    k, klen, v, vlen);		\ 				} else if (clip) {			\ 					if (CONF_MIN_##check_min(um,	\ 					    (t)(min))) {		\ 						o = (t)(min);		\ 					} else if (			\ 					    CONF_MAX_##check_max(um,	\ 					    (t)(max))) {		\ 						o = (t)(max);		\ 					} else {			\ 						o = (t)um;		\ 					}				\ 				} else {				\ 					if (CONF_MIN_##check_min(um,	\ 					    (t)(min)) ||		\ 					    CONF_MAX_##check_max(um,	\ 					    (t)(max))) {		\ 						malloc_conf_error(	\ 						    "Out-of-range "	\ 						    "conf value",	\ 						    k, klen, v, vlen);	\ 					} else {			\ 						o = (t)um;		\ 					}				\ 				}					\ 				continue;				\ 			}
define|#
directive|define
name|CONF_HANDLE_UNSIGNED
parameter_list|(
name|o
parameter_list|,
name|n
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|,
name|check_min
parameter_list|,
name|check_max
parameter_list|,	\
name|clip
parameter_list|)
define|\
value|CONF_HANDLE_T_U(unsigned, o, n, min, max,	\ 			    check_min, check_max, clip)
define|#
directive|define
name|CONF_HANDLE_SIZE_T
parameter_list|(
name|o
parameter_list|,
name|n
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|,
name|check_min
parameter_list|,
name|check_max
parameter_list|,
name|clip
parameter_list|)
define|\
value|CONF_HANDLE_T_U(size_t, o, n, min, max,		\ 			    check_min, check_max, clip)
define|#
directive|define
name|CONF_HANDLE_SSIZE_T
parameter_list|(
name|o
parameter_list|,
name|n
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|)
define|\
value|if (CONF_MATCH(n)) {				\ 				long l;					\ 				char *end;				\ 									\ 				set_errno(0);				\ 				l = strtol(v,&end, 0);			\ 				if (get_errno() != 0 || (uintptr_t)end -\ 				    (uintptr_t)v != vlen) {		\ 					malloc_conf_error(		\ 					    "Invalid conf value",	\ 					    k, klen, v, vlen);		\ 				} else if (l< (ssize_t)(min) || l>	\ 				    (ssize_t)(max)) {			\ 					malloc_conf_error(		\ 					    "Out-of-range conf value",	\ 					    k, klen, v, vlen);		\ 				} else {				\ 					o = l;				\ 				}					\ 				continue;				\ 			}
define|#
directive|define
name|CONF_HANDLE_CHAR_P
parameter_list|(
name|o
parameter_list|,
name|n
parameter_list|,
name|d
parameter_list|)
define|\
value|if (CONF_MATCH(n)) {				\ 				size_t cpylen = (vlen<=		\ 				    sizeof(o)-1) ? vlen :		\ 				    sizeof(o)-1;			\ 				strncpy(o, v, cpylen);			\ 				o[cpylen] = '\0';			\ 				continue;				\ 			}
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_abort
argument_list|,
literal|"abort"
argument_list|)
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_abort_conf
argument_list|,
literal|"abort_conf"
argument_list|)
if|if
condition|(
name|opt_abort_conf
operator|&&
name|had_conf_error
condition|)
block|{
name|malloc_abort_invalid_conf
argument_list|()
expr_stmt|;
block|}
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_retain
argument_list|,
literal|"retain"
argument_list|)
if|if
condition|(
name|strncmp
argument_list|(
literal|"dss"
argument_list|,
name|k
argument_list|,
name|klen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|bool
name|match
init|=
name|false
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dss_prec_limit
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|dss_prec_names
index|[
name|i
index|]
argument_list|,
name|v
argument_list|,
name|vlen
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|extent_dss_prec_set
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|malloc_conf_error
argument_list|(
literal|"Error setting dss"
argument_list|,
name|k
argument_list|,
name|klen
argument_list|,
name|v
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|opt_dss
operator|=
name|dss_prec_names
index|[
name|i
index|]
expr_stmt|;
name|match
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|match
condition|)
block|{
name|malloc_conf_error
argument_list|(
literal|"Invalid conf value"
argument_list|,
name|k
argument_list|,
name|klen
argument_list|,
name|v
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|CONF_HANDLE_UNSIGNED
argument_list|(
argument|opt_narenas
argument_list|,
literal|"narenas"
argument_list|,
literal|1
argument_list|,
argument|UINT_MAX
argument_list|,
argument|yes
argument_list|,
argument|no
argument_list|,
argument|false
argument_list|)
name|CONF_HANDLE_SSIZE_T
argument_list|(
name|opt_dirty_decay_ms
argument_list|,
literal|"dirty_decay_ms"
argument_list|,
operator|-
literal|1
argument_list|,
name|NSTIME_SEC_MAX
operator|*
name|KQU
argument_list|(
literal|1000
argument_list|)
operator|<
name|QU
argument_list|(
name|SSIZE_MAX
argument_list|)
condition|?
name|NSTIME_SEC_MAX
operator|*
name|KQU
argument_list|(
literal|1000
argument_list|)
else|:
name|SSIZE_MAX
argument_list|)
expr_stmt|;
name|CONF_HANDLE_SSIZE_T
argument_list|(
name|opt_muzzy_decay_ms
argument_list|,
literal|"muzzy_decay_ms"
argument_list|,
operator|-
literal|1
argument_list|,
name|NSTIME_SEC_MAX
operator|*
name|KQU
argument_list|(
literal|1000
argument_list|)
operator|<
name|QU
argument_list|(
name|SSIZE_MAX
argument_list|)
condition|?
name|NSTIME_SEC_MAX
operator|*
name|KQU
argument_list|(
literal|1000
argument_list|)
else|:
name|SSIZE_MAX
argument_list|)
expr_stmt|;
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_stats_print
argument_list|,
literal|"stats_print"
argument_list|)
if|if
condition|(
name|CONF_MATCH
argument_list|(
literal|"stats_print_opts"
argument_list|)
condition|)
block|{
name|init_opt_stats_print_opts
argument_list|(
name|v
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|config_fill
condition|)
block|{
if|if
condition|(
name|CONF_MATCH
argument_list|(
literal|"junk"
argument_list|)
condition|)
block|{
if|if
condition|(
name|CONF_MATCH_VALUE
argument_list|(
literal|"true"
argument_list|)
condition|)
block|{
name|opt_junk
operator|=
literal|"true"
expr_stmt|;
name|opt_junk_alloc
operator|=
name|opt_junk_free
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONF_MATCH_VALUE
argument_list|(
literal|"false"
argument_list|)
condition|)
block|{
name|opt_junk
operator|=
literal|"false"
expr_stmt|;
name|opt_junk_alloc
operator|=
name|opt_junk_free
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONF_MATCH_VALUE
argument_list|(
literal|"alloc"
argument_list|)
condition|)
block|{
name|opt_junk
operator|=
literal|"alloc"
expr_stmt|;
name|opt_junk_alloc
operator|=
name|true
expr_stmt|;
name|opt_junk_free
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONF_MATCH_VALUE
argument_list|(
literal|"free"
argument_list|)
condition|)
block|{
name|opt_junk
operator|=
literal|"free"
expr_stmt|;
name|opt_junk_alloc
operator|=
name|false
expr_stmt|;
name|opt_junk_free
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|malloc_conf_error
argument_list|(
literal|"Invalid conf value"
argument_list|,
name|k
argument_list|,
name|klen
argument_list|,
name|v
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_zero
argument_list|,
literal|"zero"
argument_list|)
block|}
if|if
condition|(
name|config_utrace
condition|)
block|{
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_utrace
argument_list|,
literal|"utrace"
argument_list|)
block|}
if|if
condition|(
name|config_xmalloc
condition|)
block|{
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_xmalloc
argument_list|,
literal|"xmalloc"
argument_list|)
block|}
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_tcache
argument_list|,
literal|"tcache"
argument_list|)
name|CONF_HANDLE_SSIZE_T
argument_list|(
argument|opt_lg_tcache_max
argument_list|,
literal|"lg_tcache_max"
argument_list|,
argument|-
literal|1
argument_list|,
argument|(sizeof(size_t)<<
literal|3
argument|) -
literal|1
argument_list|)
if|if
condition|(
name|strncmp
argument_list|(
literal|"percpu_arena"
argument_list|,
name|k
argument_list|,
name|klen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|bool
name|match
init|=
name|false
decl_stmt|;
for|for
control|(
name|i
operator|=
name|percpu_arena_mode_names_base
init|;
name|i
operator|<
name|percpu_arena_mode_names_limit
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|percpu_arena_mode_names
index|[
name|i
index|]
argument_list|,
name|v
argument_list|,
name|vlen
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|have_percpu_arena
condition|)
block|{
name|malloc_conf_error
argument_list|(
literal|"No getcpu support"
argument_list|,
name|k
argument_list|,
name|klen
argument_list|,
name|v
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
block|}
name|opt_percpu_arena
operator|=
name|i
expr_stmt|;
name|match
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|match
condition|)
block|{
name|malloc_conf_error
argument_list|(
literal|"Invalid conf value"
argument_list|,
name|k
argument_list|,
name|klen
argument_list|,
name|v
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|CONF_HANDLE_BOOL
argument_list|(
name|opt_background_thread
argument_list|,
literal|"background_thread"
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_prof
condition|)
block|{
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_prof
argument_list|,
literal|"prof"
argument_list|)
name|CONF_HANDLE_CHAR_P
argument_list|(
argument|opt_prof_prefix
argument_list|,
literal|"prof_prefix"
argument_list|,
literal|"jeprof"
argument_list|)
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_prof_active
argument_list|,
literal|"prof_active"
argument_list|)
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_prof_thread_active_init
argument_list|,
literal|"prof_thread_active_init"
argument_list|)
name|CONF_HANDLE_SIZE_T
argument_list|(
argument|opt_lg_prof_sample
argument_list|,
literal|"lg_prof_sample"
argument_list|,
literal|0
argument_list|,
argument|(sizeof(uint64_t)<<
literal|3
argument|) 				    -
literal|1
argument_list|,
argument|no
argument_list|,
argument|yes
argument_list|,
argument|true
argument_list|)
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_prof_accum
argument_list|,
literal|"prof_accum"
argument_list|)
name|CONF_HANDLE_SSIZE_T
argument_list|(
argument|opt_lg_prof_interval
argument_list|,
literal|"lg_prof_interval"
argument_list|,
argument|-
literal|1
argument_list|,
argument|(sizeof(uint64_t)<<
literal|3
argument|) -
literal|1
argument_list|)
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_prof_gdump
argument_list|,
literal|"prof_gdump"
argument_list|)
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_prof_final
argument_list|,
literal|"prof_final"
argument_list|)
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_prof_leak
argument_list|,
literal|"prof_leak"
argument_list|)
block|}
name|malloc_conf_error
argument_list|(
literal|"Invalid conf pair"
argument_list|,
name|k
argument_list|,
name|klen
argument_list|,
name|v
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|CONF_MATCH
undef|#
directive|undef
name|CONF_MATCH_VALUE
undef|#
directive|undef
name|CONF_HANDLE_BOOL
undef|#
directive|undef
name|CONF_MIN_no
undef|#
directive|undef
name|CONF_MIN_yes
undef|#
directive|undef
name|CONF_MAX_no
undef|#
directive|undef
name|CONF_MAX_yes
undef|#
directive|undef
name|CONF_HANDLE_T_U
undef|#
directive|undef
name|CONF_HANDLE_UNSIGNED
undef|#
directive|undef
name|CONF_HANDLE_SIZE_T
undef|#
directive|undef
name|CONF_HANDLE_SSIZE_T
undef|#
directive|undef
name|CONF_HANDLE_CHAR_P
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|malloc_init_hard_needed
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|malloc_initialized
argument_list|()
operator|||
operator|(
name|IS_INITIALIZER
operator|&&
name|malloc_init_state
operator|==
name|malloc_init_recursible
operator|)
condition|)
block|{
comment|/* 		 * Another thread initialized the allocator before this one 		 * acquired init_lock, or this thread is the initializing 		 * thread, and it is recursively allocating. 		 */
return|return
name|false
return|;
block|}
ifdef|#
directive|ifdef
name|JEMALLOC_THREADED_INIT
if|if
condition|(
name|malloc_initializer
operator|!=
name|NO_INITIALIZER
operator|&&
operator|!
name|IS_INITIALIZER
condition|)
block|{
comment|/* Busy-wait until the initializing thread completes. */
name|spin_t
name|spinner
init|=
name|SPIN_INITIALIZER
decl_stmt|;
do|do
block|{
name|malloc_mutex_unlock
argument_list|(
name|TSDN_NULL
argument_list|,
operator|&
name|init_lock
argument_list|)
expr_stmt|;
name|spin_adaptive
argument_list|(
operator|&
name|spinner
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|TSDN_NULL
argument_list|,
operator|&
name|init_lock
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|malloc_initialized
argument_list|()
condition|)
do|;
return|return
name|false
return|;
block|}
endif|#
directive|endif
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|malloc_init_hard_a0_locked
parameter_list|()
block|{
name|malloc_initializer
operator|=
name|INITIALIZER
expr_stmt|;
if|if
condition|(
name|config_prof
condition|)
block|{
name|prof_boot0
argument_list|()
expr_stmt|;
block|}
name|malloc_conf_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|opt_stats_print
condition|)
block|{
comment|/* Print statistics at exit. */
if|if
condition|(
name|atexit
argument_list|(
name|stats_print_atexit
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Error in atexit()\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|pages_boot
argument_list|()
condition|)
block|{
return|return
name|true
return|;
block|}
if|if
condition|(
name|base_boot
argument_list|(
name|TSDN_NULL
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
if|if
condition|(
name|extent_boot
argument_list|()
condition|)
block|{
return|return
name|true
return|;
block|}
if|if
condition|(
name|ctl_boot
argument_list|()
condition|)
block|{
return|return
name|true
return|;
block|}
if|if
condition|(
name|config_prof
condition|)
block|{
name|prof_boot1
argument_list|()
expr_stmt|;
block|}
name|arena_boot
argument_list|()
expr_stmt|;
if|if
condition|(
name|tcache_boot
argument_list|(
name|TSDN_NULL
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|arenas_lock
argument_list|,
literal|"arenas"
argument_list|,
name|WITNESS_RANK_ARENAS
argument_list|,
name|malloc_mutex_rank_exclusive
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
comment|/* 	 * Create enough scaffolding to allow recursive allocation in 	 * malloc_ncpus(). 	 */
name|narenas_auto
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
name|arenas
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|arena_t
operator|*
argument_list|)
operator|*
name|narenas_auto
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize one arena here.  The rest are lazily created in 	 * arena_choose_hard(). 	 */
if|if
condition|(
name|arena_init
argument_list|(
name|TSDN_NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|extent_hooks_t
operator|*
operator|)
operator|&
name|extent_hooks_default
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
name|true
return|;
block|}
name|a0
operator|=
name|arena_get
argument_list|(
name|TSDN_NULL
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|malloc_init_state
operator|=
name|malloc_init_a0_initialized
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|malloc_init_hard_a0
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|ret
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|TSDN_NULL
argument_list|,
operator|&
name|init_lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|malloc_init_hard_a0_locked
argument_list|()
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|TSDN_NULL
argument_list|,
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Initialize data structures which may trigger recursive allocation. */
end_comment

begin_function
specifier|static
name|bool
name|malloc_init_hard_recursible
parameter_list|(
name|void
parameter_list|)
block|{
name|malloc_init_state
operator|=
name|malloc_init_recursible
expr_stmt|;
name|ncpus
operator|=
name|malloc_ncpus
argument_list|()
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|JEMALLOC_HAVE_PTHREAD_ATFORK
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|JEMALLOC_MUTEX_INIT_CB
argument_list|)
expr|\
operator|&&
operator|!
name|defined
argument_list|(
name|JEMALLOC_ZONE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
expr|\
operator|!
name|defined
argument_list|(
name|__native_client__
argument_list|)
operator|)
comment|/* LinuxThreads' pthread_atfork() allocates. */
if|if
condition|(
name|pthread_atfork
argument_list|(
name|jemalloc_prefork
argument_list|,
name|jemalloc_postfork_parent
argument_list|,
name|jemalloc_postfork_child
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Error in pthread_atfork()\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|background_thread_boot0
argument_list|()
condition|)
block|{
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|malloc_narenas_default
parameter_list|(
name|void
parameter_list|)
block|{
name|assert
argument_list|(
name|ncpus
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * For SMP systems, create more than one arena per CPU by 	 * default. 	 */
if|if
condition|(
name|ncpus
operator|>
literal|1
condition|)
block|{
return|return
name|ncpus
operator|<<
literal|2
return|;
block|}
else|else
block|{
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|percpu_arena_mode_t
name|percpu_arena_as_initialized
parameter_list|(
name|percpu_arena_mode_t
name|mode
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|malloc_initialized
argument_list|()
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|mode
operator|<=
name|percpu_arena_disabled
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|percpu_arena_disabled
condition|)
block|{
name|mode
operator|+=
name|percpu_arena_mode_enabled_base
expr_stmt|;
block|}
return|return
name|mode
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|malloc_init_narenas
parameter_list|(
name|void
parameter_list|)
block|{
name|assert
argument_list|(
name|ncpus
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_percpu_arena
operator|!=
name|percpu_arena_disabled
condition|)
block|{
if|if
condition|(
operator|!
name|have_percpu_arena
operator|||
name|malloc_getcpu
argument_list|()
operator|<
literal|0
condition|)
block|{
name|opt_percpu_arena
operator|=
name|percpu_arena_disabled
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"<jemalloc>: perCPU arena getcpu() not "
literal|"available. Setting narenas to %u.\n"
argument_list|,
name|opt_narenas
condition|?
name|opt_narenas
else|:
name|malloc_narenas_default
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ncpus
operator|>=
name|MALLOCX_ARENA_LIMIT
condition|)
block|{
name|malloc_printf
argument_list|(
literal|"<jemalloc>: narenas w/ percpu"
literal|"arena beyond limit (%d)\n"
argument_list|,
name|ncpus
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
comment|/* NB: opt_percpu_arena isn't fully initialized yet. */
if|if
condition|(
name|percpu_arena_as_initialized
argument_list|(
name|opt_percpu_arena
argument_list|)
operator|==
name|per_phycpu_arena
operator|&&
name|ncpus
operator|%
literal|2
operator|!=
literal|0
condition|)
block|{
name|malloc_printf
argument_list|(
literal|"<jemalloc>: invalid "
literal|"configuration -- per physical CPU arena "
literal|"with odd number (%u) of CPUs (no hyper "
literal|"threading?).\n"
argument_list|,
name|ncpus
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|unsigned
name|n
init|=
name|percpu_arena_ind_limit
argument_list|(
name|percpu_arena_as_initialized
argument_list|(
name|opt_percpu_arena
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|opt_narenas
operator|<
name|n
condition|)
block|{
comment|/* 				 * If narenas is specified with percpu_arena 				 * enabled, actual narenas is set as the greater 				 * of the two. percpu_arena_choose will be free 				 * to use any of the arenas based on CPU 				 * id. This is conservative (at a small cost) 				 * but ensures correctness. 				 * 				 * If for some reason the ncpus determined at 				 * boot is not the actual number (e.g. because 				 * of affinity setting from numactl), reserving 				 * narenas this way provides a workaround for 				 * percpu_arena. 				 */
name|opt_narenas
operator|=
name|n
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|opt_narenas
operator|==
literal|0
condition|)
block|{
name|opt_narenas
operator|=
name|malloc_narenas_default
argument_list|()
expr_stmt|;
block|}
name|assert
argument_list|(
name|opt_narenas
operator|>
literal|0
argument_list|)
expr_stmt|;
name|narenas_auto
operator|=
name|opt_narenas
expr_stmt|;
comment|/* 	 * Limit the number of arenas to the indexing range of MALLOCX_ARENA(). 	 */
if|if
condition|(
name|narenas_auto
operator|>=
name|MALLOCX_ARENA_LIMIT
condition|)
block|{
name|narenas_auto
operator|=
name|MALLOCX_ARENA_LIMIT
operator|-
literal|1
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"<jemalloc>: Reducing narenas to limit (%d)\n"
argument_list|,
name|narenas_auto
argument_list|)
expr_stmt|;
block|}
name|narenas_total_set
argument_list|(
name|narenas_auto
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|malloc_init_percpu
parameter_list|(
name|void
parameter_list|)
block|{
name|opt_percpu_arena
operator|=
name|percpu_arena_as_initialized
argument_list|(
name|opt_percpu_arena
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|malloc_init_hard_finish
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|malloc_mutex_boot
argument_list|()
condition|)
block|{
return|return
name|true
return|;
block|}
name|malloc_init_state
operator|=
name|malloc_init_initialized
expr_stmt|;
name|malloc_slow_flag_init
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|malloc_init_hard_cleanup
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|bool
name|reentrancy_set
parameter_list|)
block|{
name|malloc_mutex_assert_owner
argument_list|(
name|tsdn
argument_list|,
operator|&
name|init_lock
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|init_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|reentrancy_set
condition|)
block|{
name|assert
argument_list|(
operator|!
name|tsdn_null
argument_list|(
name|tsdn
argument_list|)
argument_list|)
expr_stmt|;
name|tsd_t
modifier|*
name|tsd
init|=
name|tsdn_tsd
argument_list|(
name|tsdn
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|tsd_reentrancy_level_get
argument_list|(
name|tsd
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|post_reentrancy
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|malloc_init_hard
parameter_list|(
name|void
parameter_list|)
block|{
name|tsd_t
modifier|*
name|tsd
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
name|_WIN32_WINNT
operator|<
literal|0x0600
name|_init_init_lock
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|malloc_mutex_lock
argument_list|(
name|TSDN_NULL
argument_list|,
operator|&
name|init_lock
argument_list|)
expr_stmt|;
define|#
directive|define
name|UNLOCK_RETURN
parameter_list|(
name|tsdn
parameter_list|,
name|ret
parameter_list|,
name|reentrancy
parameter_list|)
define|\
value|malloc_init_hard_cleanup(tsdn, reentrancy);	\ 	return ret;
if|if
condition|(
operator|!
name|malloc_init_hard_needed
argument_list|()
condition|)
block|{
name|UNLOCK_RETURN
argument_list|(
argument|TSDN_NULL
argument_list|,
argument|false
argument_list|,
argument|false
argument_list|)
block|}
if|if
condition|(
name|malloc_init_state
operator|!=
name|malloc_init_a0_initialized
operator|&&
name|malloc_init_hard_a0_locked
argument_list|()
condition|)
block|{
name|UNLOCK_RETURN
argument_list|(
argument|TSDN_NULL
argument_list|,
argument|true
argument_list|,
argument|false
argument_list|)
block|}
name|malloc_mutex_unlock
argument_list|(
name|TSDN_NULL
argument_list|,
operator|&
name|init_lock
argument_list|)
expr_stmt|;
comment|/* Recursive allocation relies on functional tsd. */
name|tsd
operator|=
name|malloc_tsd_boot0
argument_list|()
expr_stmt|;
if|if
condition|(
name|tsd
operator|==
name|NULL
condition|)
block|{
return|return
name|true
return|;
block|}
if|if
condition|(
name|malloc_init_hard_recursible
argument_list|()
condition|)
block|{
return|return
name|true
return|;
block|}
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|init_lock
argument_list|)
expr_stmt|;
comment|/* Set reentrancy level to 1 during init. */
name|pre_reentrancy
argument_list|(
name|tsd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Initialize narenas before prof_boot2 (for allocation). */
if|if
condition|(
name|malloc_init_narenas
argument_list|()
operator|||
name|background_thread_boot1
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
condition|)
block|{
name|UNLOCK_RETURN
argument_list|(
argument|tsd_tsdn(tsd)
argument_list|,
argument|true
argument_list|,
argument|true
argument_list|)
block|}
if|if
condition|(
name|config_prof
operator|&&
name|prof_boot2
argument_list|(
name|tsd
argument_list|)
condition|)
block|{
name|UNLOCK_RETURN
argument_list|(
argument|tsd_tsdn(tsd)
argument_list|,
argument|true
argument_list|,
argument|true
argument_list|)
block|}
name|malloc_init_percpu
argument_list|()
expr_stmt|;
if|if
condition|(
name|malloc_init_hard_finish
argument_list|()
condition|)
block|{
name|UNLOCK_RETURN
argument_list|(
argument|tsd_tsdn(tsd)
argument_list|,
argument|true
argument_list|,
argument|true
argument_list|)
block|}
name|post_reentrancy
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|init_lock
argument_list|)
expr_stmt|;
name|malloc_tsd_boot1
argument_list|()
expr_stmt|;
comment|/* Update TSD after tsd_boot1. */
name|tsd
operator|=
name|tsd_fetch
argument_list|()
expr_stmt|;
if|if
condition|(
name|opt_background_thread
condition|)
block|{
name|assert
argument_list|(
name|have_background_thread
argument_list|)
expr_stmt|;
comment|/* 		 * Need to finish init& unlock first before creating background 		 * threads (pthread_create depends on malloc). 		 */
name|malloc_mutex_lock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|background_thread_lock
argument_list|)
expr_stmt|;
name|bool
name|err
init|=
name|background_thread_create
argument_list|(
name|tsd
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|background_thread_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
name|true
return|;
block|}
block|}
undef|#
directive|undef
name|UNLOCK_RETURN
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * End initialization functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin allocation-path internal functions and data structures.  */
end_comment

begin_comment
comment|/*  * Settings determined by the documented behavior of the allocation functions.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|static_opts_s
name|static_opts_t
typedef|;
end_typedef

begin_struct
struct|struct
name|static_opts_s
block|{
comment|/* Whether or not allocation size may overflow. */
name|bool
name|may_overflow
decl_stmt|;
comment|/* Whether or not allocations of size 0 should be treated as size 1. */
name|bool
name|bump_empty_alloc
decl_stmt|;
comment|/* 	 * Whether to assert that allocations are not of size 0 (after any 	 * bumping). 	 */
name|bool
name|assert_nonempty_alloc
decl_stmt|;
comment|/* 	 * Whether or not to modify the 'result' argument to malloc in case of 	 * error. 	 */
name|bool
name|null_out_result_on_error
decl_stmt|;
comment|/* Whether to set errno when we encounter an error condition. */
name|bool
name|set_errno_on_error
decl_stmt|;
comment|/* 	 * The minimum valid alignment for functions requesting aligned storage. 	 */
name|size_t
name|min_alignment
decl_stmt|;
comment|/* The error string to use if we oom. */
specifier|const
name|char
modifier|*
name|oom_string
decl_stmt|;
comment|/* The error string to use if the passed-in alignment is invalid. */
specifier|const
name|char
modifier|*
name|invalid_alignment_string
decl_stmt|;
comment|/* 	 * False if we're configured to skip some time-consuming operations. 	 * 	 * This isn't really a malloc "behavior", but it acts as a useful 	 * summary of several other static (or at least, static after program 	 * initialization) options. 	 */
name|bool
name|slow
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|void
name|static_opts_init
parameter_list|(
name|static_opts_t
modifier|*
name|static_opts
parameter_list|)
block|{
name|static_opts
operator|->
name|may_overflow
operator|=
name|false
expr_stmt|;
name|static_opts
operator|->
name|bump_empty_alloc
operator|=
name|false
expr_stmt|;
name|static_opts
operator|->
name|assert_nonempty_alloc
operator|=
name|false
expr_stmt|;
name|static_opts
operator|->
name|null_out_result_on_error
operator|=
name|false
expr_stmt|;
name|static_opts
operator|->
name|set_errno_on_error
operator|=
name|false
expr_stmt|;
name|static_opts
operator|->
name|min_alignment
operator|=
literal|0
expr_stmt|;
name|static_opts
operator|->
name|oom_string
operator|=
literal|""
expr_stmt|;
name|static_opts
operator|->
name|invalid_alignment_string
operator|=
literal|""
expr_stmt|;
name|static_opts
operator|->
name|slow
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * These correspond to the macros in jemalloc/jemalloc_macros.h.  Broadly, we  * should have one constant here per magic value there.  Note however that the  * representations need not be related.  */
end_comment

begin_define
define|#
directive|define
name|TCACHE_IND_NONE
value|((unsigned)-1)
end_define

begin_define
define|#
directive|define
name|TCACHE_IND_AUTOMATIC
value|((unsigned)-2)
end_define

begin_define
define|#
directive|define
name|ARENA_IND_AUTOMATIC
value|((unsigned)-1)
end_define

begin_typedef
typedef|typedef
name|struct
name|dynamic_opts_s
name|dynamic_opts_t
typedef|;
end_typedef

begin_struct
struct|struct
name|dynamic_opts_s
block|{
name|void
modifier|*
modifier|*
name|result
decl_stmt|;
name|size_t
name|num_items
decl_stmt|;
name|size_t
name|item_size
decl_stmt|;
name|size_t
name|alignment
decl_stmt|;
name|bool
name|zero
decl_stmt|;
name|unsigned
name|tcache_ind
decl_stmt|;
name|unsigned
name|arena_ind
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|void
name|dynamic_opts_init
parameter_list|(
name|dynamic_opts_t
modifier|*
name|dynamic_opts
parameter_list|)
block|{
name|dynamic_opts
operator|->
name|result
operator|=
name|NULL
expr_stmt|;
name|dynamic_opts
operator|->
name|num_items
operator|=
literal|0
expr_stmt|;
name|dynamic_opts
operator|->
name|item_size
operator|=
literal|0
expr_stmt|;
name|dynamic_opts
operator|->
name|alignment
operator|=
literal|0
expr_stmt|;
name|dynamic_opts
operator|->
name|zero
operator|=
name|false
expr_stmt|;
name|dynamic_opts
operator|->
name|tcache_ind
operator|=
name|TCACHE_IND_AUTOMATIC
expr_stmt|;
name|dynamic_opts
operator|->
name|arena_ind
operator|=
name|ARENA_IND_AUTOMATIC
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ind is ignored if dopts->alignment> 0. */
end_comment

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|void
modifier|*
name|imalloc_no_sample
parameter_list|(
name|static_opts_t
modifier|*
name|sopts
parameter_list|,
name|dynamic_opts_t
modifier|*
name|dopts
parameter_list|,
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|szind_t
name|ind
parameter_list|)
block|{
name|tcache_t
modifier|*
name|tcache
decl_stmt|;
name|arena_t
modifier|*
name|arena
decl_stmt|;
comment|/* Fill in the tcache. */
if|if
condition|(
name|dopts
operator|->
name|tcache_ind
operator|==
name|TCACHE_IND_AUTOMATIC
condition|)
block|{
if|if
condition|(
name|likely
argument_list|(
operator|!
name|sopts
operator|->
name|slow
argument_list|)
condition|)
block|{
comment|/* Getting tcache ptr unconditionally. */
name|tcache
operator|=
name|tsd_tcachep_get
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tcache
operator|==
name|tcache_get
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tcache
operator|=
name|tcache_get
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dopts
operator|->
name|tcache_ind
operator|==
name|TCACHE_IND_NONE
condition|)
block|{
name|tcache
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|tcache
operator|=
name|tcaches_get
argument_list|(
name|tsd
argument_list|,
name|dopts
operator|->
name|tcache_ind
argument_list|)
expr_stmt|;
block|}
comment|/* Fill in the arena. */
if|if
condition|(
name|dopts
operator|->
name|arena_ind
operator|==
name|ARENA_IND_AUTOMATIC
condition|)
block|{
comment|/* 		 * In case of automatic arena management, we defer arena 		 * computation until as late as we can, hoping to fill the 		 * allocation out of the tcache. 		 */
name|arena
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|arena
operator|=
name|arena_get
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|dopts
operator|->
name|arena_ind
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|dopts
operator|->
name|alignment
operator|!=
literal|0
argument_list|)
condition|)
block|{
return|return
name|ipalloct
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|usize
argument_list|,
name|dopts
operator|->
name|alignment
argument_list|,
name|dopts
operator|->
name|zero
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|)
return|;
block|}
return|return
name|iallocztm
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|size
argument_list|,
name|ind
argument_list|,
name|dopts
operator|->
name|zero
argument_list|,
name|tcache
argument_list|,
name|false
argument_list|,
name|arena
argument_list|,
name|sopts
operator|->
name|slow
argument_list|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|void
modifier|*
name|imalloc_sample
parameter_list|(
name|static_opts_t
modifier|*
name|sopts
parameter_list|,
name|dynamic_opts_t
modifier|*
name|dopts
parameter_list|,
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|szind_t
name|ind
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
comment|/* 	 * For small allocations, sampling bumps the usize.  If so, we allocate 	 * from the ind_large bucket. 	 */
name|szind_t
name|ind_large
decl_stmt|;
name|size_t
name|bumped_usize
init|=
name|usize
decl_stmt|;
if|if
condition|(
name|usize
operator|<=
name|SMALL_MAXCLASS
condition|)
block|{
name|assert
argument_list|(
operator|(
operator|(
name|dopts
operator|->
name|alignment
operator|==
literal|0
operator|)
condition|?
name|sz_s2u
argument_list|(
name|LARGE_MINCLASS
argument_list|)
else|:
name|sz_sa2u
argument_list|(
name|LARGE_MINCLASS
argument_list|,
name|dopts
operator|->
name|alignment
argument_list|)
operator|)
operator|==
name|LARGE_MINCLASS
argument_list|)
expr_stmt|;
name|ind_large
operator|=
name|sz_size2index
argument_list|(
name|LARGE_MINCLASS
argument_list|)
expr_stmt|;
name|bumped_usize
operator|=
name|sz_s2u
argument_list|(
name|LARGE_MINCLASS
argument_list|)
expr_stmt|;
name|ret
operator|=
name|imalloc_no_sample
argument_list|(
name|sopts
argument_list|,
name|dopts
argument_list|,
name|tsd
argument_list|,
name|bumped_usize
argument_list|,
name|bumped_usize
argument_list|,
name|ind_large
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ret
operator|==
name|NULL
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|arena_prof_promote
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ret
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|imalloc_no_sample
argument_list|(
name|sopts
argument_list|,
name|dopts
argument_list|,
name|tsd
argument_list|,
name|usize
argument_list|,
name|usize
argument_list|,
name|ind
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true if the allocation will overflow, and false otherwise.  Sets  * *size to the product either way.  */
end_comment

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|bool
name|compute_size_with_overflow
parameter_list|(
name|bool
name|may_overflow
parameter_list|,
name|dynamic_opts_t
modifier|*
name|dopts
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
comment|/* 	 * This function is just num_items * item_size, except that we may have 	 * to check for overflow. 	 */
if|if
condition|(
operator|!
name|may_overflow
condition|)
block|{
name|assert
argument_list|(
name|dopts
operator|->
name|num_items
operator|==
literal|1
argument_list|)
expr_stmt|;
operator|*
name|size
operator|=
name|dopts
operator|->
name|item_size
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* A size_t with its high-half bits all set to 1. */
specifier|const
specifier|static
name|size_t
name|high_bits
init|=
name|SIZE_T_MAX
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|*
literal|8
operator|/
literal|2
operator|)
decl_stmt|;
operator|*
name|size
operator|=
name|dopts
operator|->
name|item_size
operator|*
name|dopts
operator|->
name|num_items
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|*
name|size
operator|==
literal|0
argument_list|)
condition|)
block|{
return|return
operator|(
name|dopts
operator|->
name|num_items
operator|!=
literal|0
operator|&&
name|dopts
operator|->
name|item_size
operator|!=
literal|0
operator|)
return|;
block|}
comment|/* 	 * We got a non-zero size, but we don't know if we overflowed to get 	 * there.  To avoid having to do a divide, we'll be clever and note that 	 * if both A and B can be represented in N/2 bits, then their product 	 * can be represented in N bits (without the possibility of overflow). 	 */
if|if
condition|(
name|likely
argument_list|(
operator|(
name|high_bits
operator|&
operator|(
name|dopts
operator|->
name|num_items
operator||
name|dopts
operator|->
name|item_size
operator|)
operator|)
operator|==
literal|0
argument_list|)
condition|)
block|{
return|return
name|false
return|;
block|}
if|if
condition|(
name|likely
argument_list|(
operator|*
name|size
operator|/
name|dopts
operator|->
name|item_size
operator|==
name|dopts
operator|->
name|num_items
argument_list|)
condition|)
block|{
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|int
name|imalloc_body
parameter_list|(
name|static_opts_t
modifier|*
name|sopts
parameter_list|,
name|dynamic_opts_t
modifier|*
name|dopts
parameter_list|,
name|tsd_t
modifier|*
name|tsd
parameter_list|)
block|{
comment|/* Where the actual allocated memory will live. */
name|void
modifier|*
name|allocation
init|=
name|NULL
decl_stmt|;
comment|/* Filled in by compute_size_with_overflow below. */
name|size_t
name|size
init|=
literal|0
decl_stmt|;
comment|/* 	 * For unaligned allocations, we need only ind.  For aligned 	 * allocations, or in case of stats or profiling we need usize. 	 * 	 * These are actually dead stores, in that their values are reset before 	 * any branch on their value is taken.  Sometimes though, it's 	 * convenient to pass them as arguments before this point.  To avoid 	 * undefined behavior then, we initialize them with dummy stores. 	 */
name|szind_t
name|ind
init|=
literal|0
decl_stmt|;
name|size_t
name|usize
init|=
literal|0
decl_stmt|;
comment|/* Reentrancy is only checked on slow path. */
name|int8_t
name|reentrancy_level
decl_stmt|;
comment|/* Compute the amount of memory the user wants. */
if|if
condition|(
name|unlikely
argument_list|(
name|compute_size_with_overflow
argument_list|(
name|sopts
operator|->
name|may_overflow
argument_list|,
name|dopts
argument_list|,
operator|&
name|size
argument_list|)
argument_list|)
condition|)
block|{
goto|goto
name|label_oom
goto|;
block|}
comment|/* Validate the user input. */
if|if
condition|(
name|sopts
operator|->
name|bump_empty_alloc
condition|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|size
operator|==
literal|0
argument_list|)
condition|)
block|{
name|size
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sopts
operator|->
name|assert_nonempty_alloc
condition|)
block|{
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|dopts
operator|->
name|alignment
operator|<
name|sopts
operator|->
name|min_alignment
operator|||
operator|(
name|dopts
operator|->
name|alignment
operator|&
operator|(
name|dopts
operator|->
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
argument_list|)
condition|)
block|{
goto|goto
name|label_invalid_alignment
goto|;
block|}
comment|/* This is the beginning of the "core" algorithm. */
if|if
condition|(
name|dopts
operator|->
name|alignment
operator|==
literal|0
condition|)
block|{
name|ind
operator|=
name|sz_size2index
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ind
operator|>=
name|NSIZES
argument_list|)
condition|)
block|{
goto|goto
name|label_oom
goto|;
block|}
if|if
condition|(
name|config_stats
operator|||
operator|(
name|config_prof
operator|&&
name|opt_prof
operator|)
condition|)
block|{
name|usize
operator|=
name|sz_index2size
argument_list|(
name|ind
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|usize
operator|>
literal|0
operator|&&
name|usize
operator|<=
name|LARGE_MAXCLASS
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|usize
operator|=
name|sz_sa2u
argument_list|(
name|size
argument_list|,
name|dopts
operator|->
name|alignment
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|usize
operator|==
literal|0
operator|||
name|usize
operator|>
name|LARGE_MAXCLASS
argument_list|)
condition|)
block|{
goto|goto
name|label_oom
goto|;
block|}
block|}
name|check_entry_exit_locking
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we need to handle reentrancy, we can do it out of a 	 * known-initialized arena (i.e. arena 0). 	 */
name|reentrancy_level
operator|=
name|tsd_reentrancy_level_get
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sopts
operator|->
name|slow
operator|&&
name|unlikely
argument_list|(
name|reentrancy_level
operator|>
literal|0
argument_list|)
condition|)
block|{
comment|/* 		 * We should never specify particular arenas or tcaches from 		 * within our internal allocations. 		 */
name|assert
argument_list|(
name|dopts
operator|->
name|tcache_ind
operator|==
name|TCACHE_IND_AUTOMATIC
operator|||
name|dopts
operator|->
name|tcache_ind
operator|==
name|TCACHE_IND_NONE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dopts
operator|->
name|arena_ind
operator|==
name|ARENA_IND_AUTOMATIC
argument_list|)
expr_stmt|;
name|dopts
operator|->
name|tcache_ind
operator|=
name|TCACHE_IND_NONE
expr_stmt|;
comment|/* We know that arena 0 has already been initialized. */
name|dopts
operator|->
name|arena_ind
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If profiling is on, get our profiling context. */
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
block|{
comment|/* 		 * Note that if we're going down this path, usize must have been 		 * initialized in the previous if statement. 		 */
name|prof_tctx_t
modifier|*
name|tctx
init|=
name|prof_alloc_prep
argument_list|(
name|tsd
argument_list|,
name|usize
argument_list|,
name|prof_active_get_unlocked
argument_list|()
argument_list|,
name|true
argument_list|)
decl_stmt|;
name|alloc_ctx_t
name|alloc_ctx
decl_stmt|;
if|if
condition|(
name|likely
argument_list|(
operator|(
name|uintptr_t
operator|)
name|tctx
operator|==
operator|(
name|uintptr_t
operator|)
literal|1U
argument_list|)
condition|)
block|{
name|alloc_ctx
operator|.
name|slab
operator|=
operator|(
name|usize
operator|<=
name|SMALL_MAXCLASS
operator|)
expr_stmt|;
name|allocation
operator|=
name|imalloc_no_sample
argument_list|(
name|sopts
argument_list|,
name|dopts
argument_list|,
name|tsd
argument_list|,
name|usize
argument_list|,
name|usize
argument_list|,
name|ind
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|tctx
operator|>
operator|(
name|uintptr_t
operator|)
literal|1U
condition|)
block|{
comment|/* 			 * Note that ind might still be 0 here.  This is fine; 			 * imalloc_sample ignores ind if dopts->alignment> 0. 			 */
name|allocation
operator|=
name|imalloc_sample
argument_list|(
name|sopts
argument_list|,
name|dopts
argument_list|,
name|tsd
argument_list|,
name|usize
argument_list|,
name|ind
argument_list|)
expr_stmt|;
name|alloc_ctx
operator|.
name|slab
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|allocation
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|allocation
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|prof_alloc_rollback
argument_list|(
name|tsd
argument_list|,
name|tctx
argument_list|,
name|true
argument_list|)
expr_stmt|;
goto|goto
name|label_oom
goto|;
block|}
name|prof_malloc
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|allocation
argument_list|,
name|usize
argument_list|,
operator|&
name|alloc_ctx
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If dopts->alignment> 0, then ind is still 0, but usize was 		 * computed in the previous if statement.  Down the positive 		 * alignment path, imalloc_no_sample ignores ind and size 		 * (relying only on usize). 		 */
name|allocation
operator|=
name|imalloc_no_sample
argument_list|(
name|sopts
argument_list|,
name|dopts
argument_list|,
name|tsd
argument_list|,
name|size
argument_list|,
name|usize
argument_list|,
name|ind
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|allocation
operator|==
name|NULL
argument_list|)
condition|)
block|{
goto|goto
name|label_oom
goto|;
block|}
block|}
comment|/* 	 * Allocation has been done at this point.  We still have some 	 * post-allocation work to do though. 	 */
name|assert
argument_list|(
name|dopts
operator|->
name|alignment
operator|==
literal|0
operator|||
operator|(
operator|(
name|uintptr_t
operator|)
name|allocation
operator|&
operator|(
name|dopts
operator|->
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|==
name|ZU
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|assert
argument_list|(
name|usize
operator|==
name|isalloc
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|allocation
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|tsd_thread_allocatedp_get
argument_list|(
name|tsd
argument_list|)
operator|+=
name|usize
expr_stmt|;
block|}
if|if
condition|(
name|sopts
operator|->
name|slow
condition|)
block|{
name|UTRACE
argument_list|(
literal|0
argument_list|,
name|size
argument_list|,
name|allocation
argument_list|)
expr_stmt|;
block|}
comment|/* Success! */
name|check_entry_exit_locking
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|dopts
operator|->
name|result
operator|=
name|allocation
expr_stmt|;
return|return
literal|0
return|;
name|label_oom
label|:
if|if
condition|(
name|unlikely
argument_list|(
name|sopts
operator|->
name|slow
argument_list|)
operator|&&
name|config_xmalloc
operator|&&
name|unlikely
argument_list|(
name|opt_xmalloc
argument_list|)
condition|)
block|{
name|malloc_write
argument_list|(
name|sopts
operator|->
name|oom_string
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|sopts
operator|->
name|slow
condition|)
block|{
name|UTRACE
argument_list|(
name|NULL
argument_list|,
name|size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|check_entry_exit_locking
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sopts
operator|->
name|set_errno_on_error
condition|)
block|{
name|set_errno
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sopts
operator|->
name|null_out_result_on_error
condition|)
block|{
operator|*
name|dopts
operator|->
name|result
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|ENOMEM
return|;
comment|/* 	 * This label is only jumped to by one goto; we move it out of line 	 * anyways to avoid obscuring the non-error paths, and for symmetry with 	 * the oom case. 	 */
name|label_invalid_alignment
label|:
if|if
condition|(
name|config_xmalloc
operator|&&
name|unlikely
argument_list|(
name|opt_xmalloc
argument_list|)
condition|)
block|{
name|malloc_write
argument_list|(
name|sopts
operator|->
name|invalid_alignment_string
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|sopts
operator|->
name|set_errno_on_error
condition|)
block|{
name|set_errno
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sopts
operator|->
name|slow
condition|)
block|{
name|UTRACE
argument_list|(
name|NULL
argument_list|,
name|size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|check_entry_exit_locking
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sopts
operator|->
name|null_out_result_on_error
condition|)
block|{
operator|*
name|dopts
operator|->
name|result
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/* Returns the errno-style error code of the allocation. */
end_comment

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|int
name|imalloc
parameter_list|(
name|static_opts_t
modifier|*
name|sopts
parameter_list|,
name|dynamic_opts_t
modifier|*
name|dopts
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|malloc_initialized
argument_list|()
argument_list|)
operator|&&
name|unlikely
argument_list|(
name|malloc_init
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|config_xmalloc
operator|&&
name|unlikely
argument_list|(
name|opt_xmalloc
argument_list|)
condition|)
block|{
name|malloc_write
argument_list|(
name|sopts
operator|->
name|oom_string
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|UTRACE
argument_list|(
name|NULL
argument_list|,
name|dopts
operator|->
name|num_items
operator|*
name|dopts
operator|->
name|item_size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|set_errno
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
operator|*
name|dopts
operator|->
name|result
operator|=
name|NULL
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
comment|/* We always need the tsd.  Let's grab it right away. */
name|tsd_t
modifier|*
name|tsd
init|=
name|tsd_fetch
argument_list|()
decl_stmt|;
name|assert
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|tsd_fast
argument_list|(
name|tsd
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Fast and common path. */
name|tsd_assert_fast
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
name|sopts
operator|->
name|slow
operator|=
name|false
expr_stmt|;
return|return
name|imalloc_body
argument_list|(
name|sopts
argument_list|,
name|dopts
argument_list|,
name|tsd
argument_list|)
return|;
block|}
else|else
block|{
name|sopts
operator|->
name|slow
operator|=
name|true
expr_stmt|;
return|return
name|imalloc_body
argument_list|(
name|sopts
argument_list|,
name|dopts
argument_list|,
name|tsd
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin malloc(3)-compatible functions.  */
end_comment

begin_function
name|JEMALLOC_EXPORT
name|JEMALLOC_ALLOCATOR
name|JEMALLOC_RESTRICT_RETURN
name|void
name|JEMALLOC_NOTHROW
modifier|*
name|JEMALLOC_ATTR
parameter_list|(
name|malloc
parameter_list|)
function|JEMALLOC_ALLOC_SIZE
parameter_list|(
function|1
end_function

begin_macro
unit|)
name|je_malloc
argument_list|(
argument|size_t size
argument_list|)
end_macro

begin_block
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|static_opts_t
name|sopts
decl_stmt|;
name|dynamic_opts_t
name|dopts
decl_stmt|;
name|static_opts_init
argument_list|(
operator|&
name|sopts
argument_list|)
expr_stmt|;
name|dynamic_opts_init
argument_list|(
operator|&
name|dopts
argument_list|)
expr_stmt|;
name|sopts
operator|.
name|bump_empty_alloc
operator|=
name|true
expr_stmt|;
name|sopts
operator|.
name|null_out_result_on_error
operator|=
name|true
expr_stmt|;
name|sopts
operator|.
name|set_errno_on_error
operator|=
name|true
expr_stmt|;
name|sopts
operator|.
name|oom_string
operator|=
literal|"<jemalloc>: Error in malloc(): out of memory\n"
expr_stmt|;
name|dopts
operator|.
name|result
operator|=
operator|&
name|ret
expr_stmt|;
name|dopts
operator|.
name|num_items
operator|=
literal|1
expr_stmt|;
name|dopts
operator|.
name|item_size
operator|=
name|size
expr_stmt|;
name|imalloc
argument_list|(
operator|&
name|sopts
argument_list|,
operator|&
name|dopts
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_block

begin_decl_stmt
name|JEMALLOC_EXPORT
name|int
name|JEMALLOC_NOTHROW
name|JEMALLOC_ATTR
argument_list|(
name|nonnull
argument_list|(
literal|1
argument_list|)
argument_list|)
name|je_posix_memalign
argument_list|(
name|void
operator|*
operator|*
name|memptr
argument_list|,
name|size_t
name|alignment
argument_list|,
name|size_t
name|size
argument_list|)
block|{
name|int
name|ret
decl_stmt|;
name|static_opts_t
name|sopts
decl_stmt|;
name|dynamic_opts_t
name|dopts
decl_stmt|;
name|static_opts_init
argument_list|(
operator|&
name|sopts
argument_list|)
expr_stmt|;
name|dynamic_opts_init
argument_list|(
operator|&
name|dopts
argument_list|)
expr_stmt|;
name|sopts
operator|.
name|bump_empty_alloc
operator|=
name|true
expr_stmt|;
name|sopts
operator|.
name|min_alignment
operator|=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
name|sopts
operator|.
name|oom_string
operator|=
literal|"<jemalloc>: Error allocating aligned memory: out of memory\n"
expr_stmt|;
name|sopts
operator|.
name|invalid_alignment_string
operator|=
literal|"<jemalloc>: Error allocating aligned memory: invalid alignment\n"
expr_stmt|;
name|dopts
operator|.
name|result
operator|=
name|memptr
expr_stmt|;
name|dopts
operator|.
name|num_items
operator|=
literal|1
expr_stmt|;
name|dopts
operator|.
name|item_size
operator|=
name|size
expr_stmt|;
name|dopts
operator|.
name|alignment
operator|=
name|alignment
expr_stmt|;
name|ret
operator|=
name|imalloc
argument_list|(
operator|&
name|sopts
argument_list|,
operator|&
name|dopts
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_decl_stmt

begin_function
name|JEMALLOC_EXPORT
name|JEMALLOC_ALLOCATOR
name|JEMALLOC_RESTRICT_RETURN
name|void
name|JEMALLOC_NOTHROW
modifier|*
name|JEMALLOC_ATTR
parameter_list|(
name|malloc
parameter_list|)
function|JEMALLOC_ALLOC_SIZE
parameter_list|(
function|2
end_function

begin_macro
unit|)
name|je_aligned_alloc
argument_list|(
argument|size_t alignment
argument_list|,
argument|size_t size
argument_list|)
end_macro

begin_block
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|static_opts_t
name|sopts
decl_stmt|;
name|dynamic_opts_t
name|dopts
decl_stmt|;
name|static_opts_init
argument_list|(
operator|&
name|sopts
argument_list|)
expr_stmt|;
name|dynamic_opts_init
argument_list|(
operator|&
name|dopts
argument_list|)
expr_stmt|;
name|sopts
operator|.
name|bump_empty_alloc
operator|=
name|true
expr_stmt|;
name|sopts
operator|.
name|null_out_result_on_error
operator|=
name|true
expr_stmt|;
name|sopts
operator|.
name|set_errno_on_error
operator|=
name|true
expr_stmt|;
name|sopts
operator|.
name|min_alignment
operator|=
literal|1
expr_stmt|;
name|sopts
operator|.
name|oom_string
operator|=
literal|"<jemalloc>: Error allocating aligned memory: out of memory\n"
expr_stmt|;
name|sopts
operator|.
name|invalid_alignment_string
operator|=
literal|"<jemalloc>: Error allocating aligned memory: invalid alignment\n"
expr_stmt|;
name|dopts
operator|.
name|result
operator|=
operator|&
name|ret
expr_stmt|;
name|dopts
operator|.
name|num_items
operator|=
literal|1
expr_stmt|;
name|dopts
operator|.
name|item_size
operator|=
name|size
expr_stmt|;
name|dopts
operator|.
name|alignment
operator|=
name|alignment
expr_stmt|;
name|imalloc
argument_list|(
operator|&
name|sopts
argument_list|,
operator|&
name|dopts
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_block

begin_function
name|JEMALLOC_EXPORT
name|JEMALLOC_ALLOCATOR
name|JEMALLOC_RESTRICT_RETURN
name|void
name|JEMALLOC_NOTHROW
modifier|*
name|JEMALLOC_ATTR
parameter_list|(
name|malloc
parameter_list|)
function|JEMALLOC_ALLOC_SIZE2
parameter_list|(
function|1
operator|,
function|2
end_function

begin_macro
unit|)
name|je_calloc
argument_list|(
argument|size_t num
argument_list|,
argument|size_t size
argument_list|)
end_macro

begin_block
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|static_opts_t
name|sopts
decl_stmt|;
name|dynamic_opts_t
name|dopts
decl_stmt|;
name|static_opts_init
argument_list|(
operator|&
name|sopts
argument_list|)
expr_stmt|;
name|dynamic_opts_init
argument_list|(
operator|&
name|dopts
argument_list|)
expr_stmt|;
name|sopts
operator|.
name|may_overflow
operator|=
name|true
expr_stmt|;
name|sopts
operator|.
name|bump_empty_alloc
operator|=
name|true
expr_stmt|;
name|sopts
operator|.
name|null_out_result_on_error
operator|=
name|true
expr_stmt|;
name|sopts
operator|.
name|set_errno_on_error
operator|=
name|true
expr_stmt|;
name|sopts
operator|.
name|oom_string
operator|=
literal|"<jemalloc>: Error in calloc(): out of memory\n"
expr_stmt|;
name|dopts
operator|.
name|result
operator|=
operator|&
name|ret
expr_stmt|;
name|dopts
operator|.
name|num_items
operator|=
name|num
expr_stmt|;
name|dopts
operator|.
name|item_size
operator|=
name|size
expr_stmt|;
name|dopts
operator|.
name|zero
operator|=
name|true
expr_stmt|;
name|imalloc
argument_list|(
operator|&
name|sopts
argument_list|,
operator|&
name|dopts
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_block

begin_function
specifier|static
name|void
modifier|*
name|irealloc_prof_sample
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|void
modifier|*
name|old_ptr
parameter_list|,
name|size_t
name|old_usize
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|tctx
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|usize
operator|<=
name|SMALL_MAXCLASS
condition|)
block|{
name|p
operator|=
name|iralloc
argument_list|(
name|tsd
argument_list|,
name|old_ptr
argument_list|,
name|old_usize
argument_list|,
name|LARGE_MINCLASS
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|arena_prof_promote
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|p
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|iralloc
argument_list|(
name|tsd
argument_list|,
name|old_ptr
argument_list|,
name|old_usize
argument_list|,
name|usize
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|void
modifier|*
name|irealloc_prof
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|void
modifier|*
name|old_ptr
parameter_list|,
name|size_t
name|old_usize
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|alloc_ctx_t
modifier|*
name|alloc_ctx
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|bool
name|prof_active
decl_stmt|;
name|prof_tctx_t
modifier|*
name|old_tctx
decl_stmt|,
modifier|*
name|tctx
decl_stmt|;
name|prof_active
operator|=
name|prof_active_get_unlocked
argument_list|()
expr_stmt|;
name|old_tctx
operator|=
name|prof_tctx_get
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|old_ptr
argument_list|,
name|alloc_ctx
argument_list|)
expr_stmt|;
name|tctx
operator|=
name|prof_alloc_prep
argument_list|(
name|tsd
argument_list|,
name|usize
argument_list|,
name|prof_active
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|uintptr_t
operator|)
name|tctx
operator|!=
operator|(
name|uintptr_t
operator|)
literal|1U
argument_list|)
condition|)
block|{
name|p
operator|=
name|irealloc_prof_sample
argument_list|(
name|tsd
argument_list|,
name|old_ptr
argument_list|,
name|old_usize
argument_list|,
name|usize
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|iralloc
argument_list|(
name|tsd
argument_list|,
name|old_ptr
argument_list|,
name|old_usize
argument_list|,
name|usize
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|p
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|prof_alloc_rollback
argument_list|(
name|tsd
argument_list|,
name|tctx
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|prof_realloc
argument_list|(
name|tsd
argument_list|,
name|p
argument_list|,
name|usize
argument_list|,
name|tctx
argument_list|,
name|prof_active
argument_list|,
name|true
argument_list|,
name|old_ptr
argument_list|,
name|old_usize
argument_list|,
name|old_tctx
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|void
name|ifree
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|,
name|bool
name|slow_path
parameter_list|)
block|{
if|if
condition|(
operator|!
name|slow_path
condition|)
block|{
name|tsd_assert_fast
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
block|}
name|check_entry_exit_locking
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsd_reentrancy_level_get
argument_list|(
name|tsd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|assert
argument_list|(
name|slow_path
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|malloc_initialized
argument_list|()
operator|||
name|IS_INITIALIZER
argument_list|)
expr_stmt|;
name|alloc_ctx_t
name|alloc_ctx
decl_stmt|;
name|rtree_ctx_t
modifier|*
name|rtree_ctx
init|=
name|tsd_rtree_ctx
argument_list|(
name|tsd
argument_list|)
decl_stmt|;
name|rtree_szind_slab_read
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|extents_rtree
argument_list|,
name|rtree_ctx
argument_list|,
operator|(
name|uintptr_t
operator|)
name|ptr
argument_list|,
name|true
argument_list|,
operator|&
name|alloc_ctx
operator|.
name|szind
argument_list|,
operator|&
name|alloc_ctx
operator|.
name|slab
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|alloc_ctx
operator|.
name|szind
operator|!=
name|NSIZES
argument_list|)
expr_stmt|;
name|size_t
name|usize
decl_stmt|;
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
block|{
name|usize
operator|=
name|sz_index2size
argument_list|(
name|alloc_ctx
operator|.
name|szind
argument_list|)
expr_stmt|;
name|prof_free
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|,
operator|&
name|alloc_ctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|config_stats
condition|)
block|{
name|usize
operator|=
name|sz_index2size
argument_list|(
name|alloc_ctx
operator|.
name|szind
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config_stats
condition|)
block|{
operator|*
name|tsd_thread_deallocatedp_get
argument_list|(
name|tsd
argument_list|)
operator|+=
name|usize
expr_stmt|;
block|}
if|if
condition|(
name|likely
argument_list|(
operator|!
name|slow_path
argument_list|)
condition|)
block|{
name|idalloctm
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|tcache
argument_list|,
operator|&
name|alloc_ctx
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|idalloctm
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|tcache
argument_list|,
operator|&
name|alloc_ctx
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|void
name|isfree
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|,
name|bool
name|slow_path
parameter_list|)
block|{
if|if
condition|(
operator|!
name|slow_path
condition|)
block|{
name|tsd_assert_fast
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
block|}
name|check_entry_exit_locking
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsd_reentrancy_level_get
argument_list|(
name|tsd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|assert
argument_list|(
name|slow_path
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|malloc_initialized
argument_list|()
operator|||
name|IS_INITIALIZER
argument_list|)
expr_stmt|;
name|alloc_ctx_t
name|alloc_ctx
decl_stmt|,
modifier|*
name|ctx
decl_stmt|;
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
block|{
name|rtree_ctx_t
modifier|*
name|rtree_ctx
init|=
name|tsd_rtree_ctx
argument_list|(
name|tsd
argument_list|)
decl_stmt|;
name|rtree_szind_slab_read
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|extents_rtree
argument_list|,
name|rtree_ctx
argument_list|,
operator|(
name|uintptr_t
operator|)
name|ptr
argument_list|,
name|true
argument_list|,
operator|&
name|alloc_ctx
operator|.
name|szind
argument_list|,
operator|&
name|alloc_ctx
operator|.
name|slab
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|alloc_ctx
operator|.
name|szind
operator|==
name|sz_size2index
argument_list|(
name|usize
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|=
operator|&
name|alloc_ctx
expr_stmt|;
name|prof_free
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|config_stats
condition|)
block|{
operator|*
name|tsd_thread_deallocatedp_get
argument_list|(
name|tsd
argument_list|)
operator|+=
name|usize
expr_stmt|;
block|}
if|if
condition|(
name|likely
argument_list|(
operator|!
name|slow_path
argument_list|)
condition|)
block|{
name|isdalloct
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|,
name|tcache
argument_list|,
name|ctx
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isdalloct
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|,
name|tcache
argument_list|,
name|ctx
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|JEMALLOC_EXPORT
name|JEMALLOC_ALLOCATOR
name|JEMALLOC_RESTRICT_RETURN
name|void
name|JEMALLOC_NOTHROW
modifier|*
name|JEMALLOC_ALLOC_SIZE
argument_list|(
literal|2
argument_list|)
name|je_realloc
argument_list|(
name|void
operator|*
name|ptr
argument_list|,
name|size_t
name|size
argument_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|tsdn_t
modifier|*
name|tsdn
name|JEMALLOC_CC_SILENCE_INIT
parameter_list|(
name|NULL
parameter_list|)
function_decl|;
name|size_t
name|usize
name|JEMALLOC_CC_SILENCE_INIT
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|size_t
name|old_usize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|size
operator|==
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
comment|/* realloc(ptr, 0) is equivalent to free(ptr). */
name|UTRACE
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tcache_t
modifier|*
name|tcache
decl_stmt|;
name|tsd_t
modifier|*
name|tsd
init|=
name|tsd_fetch
argument_list|()
decl_stmt|;
if|if
condition|(
name|tsd_reentrancy_level_get
argument_list|(
name|tsd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tcache
operator|=
name|tcache_get
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tcache
operator|=
name|NULL
expr_stmt|;
block|}
name|ifree
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|tcache
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|size
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|likely
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|malloc_initialized
argument_list|()
operator|||
name|IS_INITIALIZER
argument_list|)
expr_stmt|;
name|tsd_t
modifier|*
name|tsd
init|=
name|tsd_fetch
argument_list|()
decl_stmt|;
name|check_entry_exit_locking
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
name|alloc_ctx_t
name|alloc_ctx
decl_stmt|;
name|rtree_ctx_t
modifier|*
name|rtree_ctx
init|=
name|tsd_rtree_ctx
argument_list|(
name|tsd
argument_list|)
decl_stmt|;
name|rtree_szind_slab_read
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|extents_rtree
argument_list|,
name|rtree_ctx
argument_list|,
operator|(
name|uintptr_t
operator|)
name|ptr
argument_list|,
name|true
argument_list|,
operator|&
name|alloc_ctx
operator|.
name|szind
argument_list|,
operator|&
name|alloc_ctx
operator|.
name|slab
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|alloc_ctx
operator|.
name|szind
operator|!=
name|NSIZES
argument_list|)
expr_stmt|;
name|old_usize
operator|=
name|sz_index2size
argument_list|(
name|alloc_ctx
operator|.
name|szind
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|old_usize
operator|==
name|isalloc
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
block|{
name|usize
operator|=
name|sz_s2u
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|ret
operator|=
name|unlikely
argument_list|(
name|usize
operator|==
literal|0
operator|||
name|usize
operator|>
name|LARGE_MAXCLASS
argument_list|)
condition|?
name|NULL
else|:
name|irealloc_prof
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|usize
argument_list|,
operator|&
name|alloc_ctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|config_stats
condition|)
block|{
name|usize
operator|=
name|sz_s2u
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|iralloc
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|tsdn
operator|=
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* realloc(NULL, size) is equivalent to malloc(size). */
return|return
name|je_malloc
argument_list|(
name|size
argument_list|)
return|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|ret
operator|==
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
name|config_xmalloc
operator|&&
name|unlikely
argument_list|(
name|opt_xmalloc
argument_list|)
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Error in realloc(): "
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|set_errno
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config_stats
operator|&&
name|likely
argument_list|(
name|ret
operator|!=
name|NULL
argument_list|)
condition|)
block|{
name|tsd_t
modifier|*
name|tsd
decl_stmt|;
name|assert
argument_list|(
name|usize
operator|==
name|isalloc
argument_list|(
name|tsdn
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|tsd
operator|=
name|tsdn_tsd
argument_list|(
name|tsdn
argument_list|)
expr_stmt|;
operator|*
name|tsd_thread_allocatedp_get
argument_list|(
name|tsd
argument_list|)
operator|+=
name|usize
expr_stmt|;
operator|*
name|tsd_thread_deallocatedp_get
argument_list|(
name|tsd
argument_list|)
operator|+=
name|old_usize
expr_stmt|;
block|}
name|UTRACE
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|check_entry_exit_locking
argument_list|(
name|tsdn
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_decl_stmt

begin_function
name|JEMALLOC_EXPORT
name|void
name|JEMALLOC_NOTHROW
name|je_free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|UTRACE
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
condition|)
block|{
comment|/* 		 * We avoid setting up tsd fully (e.g. tcache, arena binding) 		 * based on only free() calls -- other activities trigger the 		 * minimal to full transition.  This is because free() may 		 * happen during thread shutdown after tls deallocation: if a 		 * thread never had any malloc activities until then, a 		 * fully-setup tsd won't be destructed properly. 		 */
name|tsd_t
modifier|*
name|tsd
init|=
name|tsd_fetch_min
argument_list|()
decl_stmt|;
name|check_entry_exit_locking
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
name|tcache_t
modifier|*
name|tcache
decl_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|tsd_fast
argument_list|(
name|tsd
argument_list|)
argument_list|)
condition|)
block|{
name|tsd_assert_fast
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
comment|/* Unconditionally get tcache ptr on fast path. */
name|tcache
operator|=
name|tsd_tcachep_get
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|tcache
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|likely
argument_list|(
name|tsd_reentrancy_level_get
argument_list|(
name|tsd
argument_list|)
operator|==
literal|0
argument_list|)
condition|)
block|{
name|tcache
operator|=
name|tcache_get
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tcache
operator|=
name|NULL
expr_stmt|;
block|}
name|ifree
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|tcache
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|check_entry_exit_locking
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * End malloc(3)-compatible functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin non-standard override functions.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_OVERRIDE_MEMALIGN
end_ifdef

begin_function
name|JEMALLOC_EXPORT
name|JEMALLOC_ALLOCATOR
name|JEMALLOC_RESTRICT_RETURN
name|void
name|JEMALLOC_NOTHROW
modifier|*
name|JEMALLOC_ATTR
parameter_list|(
name|malloc
parameter_list|)
function|je_memalign
parameter_list|(
name|size_t
name|alignment
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|static_opts_t
name|sopts
decl_stmt|;
name|dynamic_opts_t
name|dopts
decl_stmt|;
name|static_opts_init
argument_list|(
operator|&
name|sopts
argument_list|)
expr_stmt|;
name|dynamic_opts_init
argument_list|(
operator|&
name|dopts
argument_list|)
expr_stmt|;
name|sopts
operator|.
name|bump_empty_alloc
operator|=
name|true
expr_stmt|;
name|sopts
operator|.
name|min_alignment
operator|=
literal|1
expr_stmt|;
name|sopts
operator|.
name|oom_string
operator|=
literal|"<jemalloc>: Error allocating aligned memory: out of memory\n"
expr_stmt|;
name|sopts
operator|.
name|invalid_alignment_string
operator|=
literal|"<jemalloc>: Error allocating aligned memory: invalid alignment\n"
expr_stmt|;
name|sopts
operator|.
name|null_out_result_on_error
operator|=
name|true
expr_stmt|;
name|dopts
operator|.
name|result
operator|=
operator|&
name|ret
expr_stmt|;
name|dopts
operator|.
name|num_items
operator|=
literal|1
expr_stmt|;
name|dopts
operator|.
name|item_size
operator|=
name|size
expr_stmt|;
name|dopts
operator|.
name|alignment
operator|=
name|alignment
expr_stmt|;
name|imalloc
argument_list|(
operator|&
name|sopts
argument_list|,
operator|&
name|dopts
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_OVERRIDE_VALLOC
end_ifdef

begin_function
name|JEMALLOC_EXPORT
name|JEMALLOC_ALLOCATOR
name|JEMALLOC_RESTRICT_RETURN
name|void
name|JEMALLOC_NOTHROW
modifier|*
name|JEMALLOC_ATTR
parameter_list|(
name|malloc
parameter_list|)
function|je_valloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|static_opts_t
name|sopts
decl_stmt|;
name|dynamic_opts_t
name|dopts
decl_stmt|;
name|static_opts_init
argument_list|(
operator|&
name|sopts
argument_list|)
expr_stmt|;
name|dynamic_opts_init
argument_list|(
operator|&
name|dopts
argument_list|)
expr_stmt|;
name|sopts
operator|.
name|bump_empty_alloc
operator|=
name|true
expr_stmt|;
name|sopts
operator|.
name|null_out_result_on_error
operator|=
name|true
expr_stmt|;
name|sopts
operator|.
name|min_alignment
operator|=
name|PAGE
expr_stmt|;
name|sopts
operator|.
name|oom_string
operator|=
literal|"<jemalloc>: Error allocating aligned memory: out of memory\n"
expr_stmt|;
name|sopts
operator|.
name|invalid_alignment_string
operator|=
literal|"<jemalloc>: Error allocating aligned memory: invalid alignment\n"
expr_stmt|;
name|dopts
operator|.
name|result
operator|=
operator|&
name|ret
expr_stmt|;
name|dopts
operator|.
name|num_items
operator|=
literal|1
expr_stmt|;
name|dopts
operator|.
name|item_size
operator|=
name|size
expr_stmt|;
name|dopts
operator|.
name|alignment
operator|=
name|PAGE
expr_stmt|;
name|imalloc
argument_list|(
operator|&
name|sopts
argument_list|,
operator|&
name|dopts
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|JEMALLOC_IS_MALLOC
argument_list|)
operator|&&
name|defined
argument_list|(
name|JEMALLOC_GLIBC_MALLOC_HOOK
argument_list|)
end_if

begin_comment
comment|/*  * glibc provides the RTLD_DEEPBIND flag for dlopen which can make it possible  * to inconsistently reference libc's malloc(3)-compatible functions  * (https://bugzilla.mozilla.org/show_bug.cgi?id=493541).  *  * These definitions interpose hooks in glibc.  The functions are actually  * passed an extra argument for the caller return address, which will be  * ignored.  */
end_comment

begin_function_decl
name|JEMALLOC_EXPORT
name|void
function_decl|(
modifier|*
name|__free_hook
function_decl|)
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
init|=
name|je_free
function_decl|;
end_function_decl

begin_function_decl
name|JEMALLOC_EXPORT
name|void
modifier|*
function_decl|(
modifier|*
name|__malloc_hook
function_decl|)
parameter_list|(
name|size_t
name|size
parameter_list|)
init|=
name|je_malloc
function_decl|;
end_function_decl

begin_function_decl
name|JEMALLOC_EXPORT
name|void
modifier|*
function_decl|(
modifier|*
name|__realloc_hook
function_decl|)
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
init|=
name|je_realloc
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_GLIBC_MEMALIGN_HOOK
end_ifdef

begin_function_decl
name|JEMALLOC_EXPORT
name|void
modifier|*
function_decl|(
modifier|*
name|__memalign_hook
function_decl|)
parameter_list|(
name|size_t
name|alignment
parameter_list|,
name|size_t
name|size
parameter_list|)
init|=
name|je_memalign
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CPU_COUNT
end_ifdef

begin_comment
comment|/*  * To enable static linking with glibc, the libc specific malloc interface must  * be implemented also, so none of glibc's malloc.o functions are added to the  * link.  */
end_comment

begin_define
define|#
directive|define
name|ALIAS
parameter_list|(
name|je_fn
parameter_list|)
value|__attribute__((alias (#je_fn), used))
end_define

begin_comment
comment|/* To force macro expansion of je_ prefix before stringification. */
end_comment

begin_define
define|#
directive|define
name|PREALIAS
parameter_list|(
name|je_fn
parameter_list|)
value|ALIAS(je_fn)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_OVERRIDE___LIBC_CALLOC
end_ifdef

begin_function_decl
name|void
modifier|*
name|__libc_calloc
parameter_list|(
name|size_t
name|n
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|PREALIAS
parameter_list|(
name|je_calloc
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_OVERRIDE___LIBC_FREE
end_ifdef

begin_function_decl
name|void
name|__libc_free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|PREALIAS
parameter_list|(
name|je_free
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_OVERRIDE___LIBC_MALLOC
end_ifdef

begin_function_decl
name|void
modifier|*
name|__libc_malloc
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|PREALIAS
parameter_list|(
name|je_malloc
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_OVERRIDE___LIBC_MEMALIGN
end_ifdef

begin_function_decl
name|void
modifier|*
name|__libc_memalign
parameter_list|(
name|size_t
name|align
parameter_list|,
name|size_t
name|s
parameter_list|)
function_decl|PREALIAS
parameter_list|(
name|je_memalign
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_OVERRIDE___LIBC_REALLOC
end_ifdef

begin_function_decl
name|void
modifier|*
name|__libc_realloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|PREALIAS
parameter_list|(
name|je_realloc
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_OVERRIDE___LIBC_VALLOC
end_ifdef

begin_function_decl
name|void
modifier|*
name|__libc_valloc
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|PREALIAS
parameter_list|(
name|je_valloc
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_OVERRIDE___POSIX_MEMALIGN
end_ifdef

begin_function_decl
name|int
name|__posix_memalign
parameter_list|(
name|void
modifier|*
modifier|*
name|r
parameter_list|,
name|size_t
name|a
parameter_list|,
name|size_t
name|s
parameter_list|)
function_decl|PREALIAS
parameter_list|(
name|je_posix_memalign
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|PREALIAS
end_undef

begin_undef
undef|#
directive|undef
name|ALIAS
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * End non-standard override functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin non-standard functions.  */
end_comment

begin_function
name|JEMALLOC_EXPORT
name|JEMALLOC_ALLOCATOR
name|JEMALLOC_RESTRICT_RETURN
name|void
name|JEMALLOC_NOTHROW
modifier|*
name|JEMALLOC_ATTR
parameter_list|(
name|malloc
parameter_list|)
function|JEMALLOC_ALLOC_SIZE
parameter_list|(
function|1
end_function

begin_macro
unit|)
name|je_mallocx
argument_list|(
argument|size_t size
argument_list|,
argument|int flags
argument_list|)
end_macro

begin_block
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|static_opts_t
name|sopts
decl_stmt|;
name|dynamic_opts_t
name|dopts
decl_stmt|;
name|static_opts_init
argument_list|(
operator|&
name|sopts
argument_list|)
expr_stmt|;
name|dynamic_opts_init
argument_list|(
operator|&
name|dopts
argument_list|)
expr_stmt|;
name|sopts
operator|.
name|assert_nonempty_alloc
operator|=
name|true
expr_stmt|;
name|sopts
operator|.
name|null_out_result_on_error
operator|=
name|true
expr_stmt|;
name|sopts
operator|.
name|oom_string
operator|=
literal|"<jemalloc>: Error in mallocx(): out of memory\n"
expr_stmt|;
name|dopts
operator|.
name|result
operator|=
operator|&
name|ret
expr_stmt|;
name|dopts
operator|.
name|num_items
operator|=
literal|1
expr_stmt|;
name|dopts
operator|.
name|item_size
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|flags
operator|!=
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|MALLOCX_LG_ALIGN_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|dopts
operator|.
name|alignment
operator|=
name|MALLOCX_ALIGN_GET_SPECIFIED
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
name|dopts
operator|.
name|zero
operator|=
name|MALLOCX_ZERO_GET
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|MALLOCX_TCACHE_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|MALLOCX_TCACHE_MASK
operator|)
operator|==
name|MALLOCX_TCACHE_NONE
condition|)
block|{
name|dopts
operator|.
name|tcache_ind
operator|=
name|TCACHE_IND_NONE
expr_stmt|;
block|}
else|else
block|{
name|dopts
operator|.
name|tcache_ind
operator|=
name|MALLOCX_TCACHE_GET
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dopts
operator|.
name|tcache_ind
operator|=
name|TCACHE_IND_AUTOMATIC
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|MALLOCX_ARENA_MASK
operator|)
operator|!=
literal|0
condition|)
name|dopts
operator|.
name|arena_ind
operator|=
name|MALLOCX_ARENA_GET
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
name|imalloc
argument_list|(
operator|&
name|sopts
argument_list|,
operator|&
name|dopts
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_block

begin_function
specifier|static
name|void
modifier|*
name|irallocx_prof_sample
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|void
modifier|*
name|old_ptr
parameter_list|,
name|size_t
name|old_usize
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
name|zero
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|tctx
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|usize
operator|<=
name|SMALL_MAXCLASS
condition|)
block|{
name|p
operator|=
name|iralloct
argument_list|(
name|tsdn
argument_list|,
name|old_ptr
argument_list|,
name|old_usize
argument_list|,
name|LARGE_MINCLASS
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|arena_prof_promote
argument_list|(
name|tsdn
argument_list|,
name|p
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|iralloct
argument_list|(
name|tsdn
argument_list|,
name|old_ptr
argument_list|,
name|old_usize
argument_list|,
name|usize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|void
modifier|*
name|irallocx_prof
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|void
modifier|*
name|old_ptr
parameter_list|,
name|size_t
name|old_usize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|size_t
modifier|*
name|usize
parameter_list|,
name|bool
name|zero
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|alloc_ctx_t
modifier|*
name|alloc_ctx
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|bool
name|prof_active
decl_stmt|;
name|prof_tctx_t
modifier|*
name|old_tctx
decl_stmt|,
modifier|*
name|tctx
decl_stmt|;
name|prof_active
operator|=
name|prof_active_get_unlocked
argument_list|()
expr_stmt|;
name|old_tctx
operator|=
name|prof_tctx_get
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|old_ptr
argument_list|,
name|alloc_ctx
argument_list|)
expr_stmt|;
name|tctx
operator|=
name|prof_alloc_prep
argument_list|(
name|tsd
argument_list|,
operator|*
name|usize
argument_list|,
name|prof_active
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|uintptr_t
operator|)
name|tctx
operator|!=
operator|(
name|uintptr_t
operator|)
literal|1U
argument_list|)
condition|)
block|{
name|p
operator|=
name|irallocx_prof_sample
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|old_ptr
argument_list|,
name|old_usize
argument_list|,
operator|*
name|usize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|iralloct
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|old_ptr
argument_list|,
name|old_usize
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|p
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|prof_alloc_rollback
argument_list|(
name|tsd
argument_list|,
name|tctx
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|p
operator|==
name|old_ptr
operator|&&
name|alignment
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The allocation did not move, so it is possible that the size 		 * class is smaller than would guarantee the requested 		 * alignment, and that the alignment constraint was 		 * serendipitously satisfied.  Additionally, old_usize may not 		 * be the same as the current usize because of in-place large 		 * reallocation.  Therefore, query the actual value of usize. 		 */
operator|*
name|usize
operator|=
name|isalloc
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|prof_realloc
argument_list|(
name|tsd
argument_list|,
name|p
argument_list|,
operator|*
name|usize
argument_list|,
name|tctx
argument_list|,
name|prof_active
argument_list|,
name|false
argument_list|,
name|old_ptr
argument_list|,
name|old_usize
argument_list|,
name|old_tctx
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_decl_stmt
name|JEMALLOC_EXPORT
name|JEMALLOC_ALLOCATOR
name|JEMALLOC_RESTRICT_RETURN
name|void
name|JEMALLOC_NOTHROW
modifier|*
name|JEMALLOC_ALLOC_SIZE
argument_list|(
literal|2
argument_list|)
name|je_rallocx
argument_list|(
name|void
operator|*
name|ptr
argument_list|,
name|size_t
name|size
argument_list|,
name|int
name|flags
argument_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|tsd_t
modifier|*
name|tsd
decl_stmt|;
name|size_t
name|usize
decl_stmt|;
name|size_t
name|old_usize
decl_stmt|;
name|size_t
name|alignment
init|=
name|MALLOCX_ALIGN_GET
argument_list|(
name|flags
argument_list|)
decl_stmt|;
name|bool
name|zero
init|=
name|flags
operator|&
name|MALLOCX_ZERO
decl_stmt|;
name|arena_t
modifier|*
name|arena
decl_stmt|;
name|tcache_t
modifier|*
name|tcache
decl_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|malloc_initialized
argument_list|()
operator|||
name|IS_INITIALIZER
argument_list|)
expr_stmt|;
name|tsd
operator|=
name|tsd_fetch
argument_list|()
expr_stmt|;
name|check_entry_exit_locking
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|flags
operator|&
name|MALLOCX_ARENA_MASK
operator|)
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|unsigned
name|arena_ind
init|=
name|MALLOCX_ARENA_GET
argument_list|(
name|flags
argument_list|)
decl_stmt|;
name|arena
operator|=
name|arena_get
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|arena_ind
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|arena
operator|==
name|NULL
argument_list|)
condition|)
block|{
goto|goto
name|label_oom
goto|;
block|}
block|}
else|else
block|{
name|arena
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|flags
operator|&
name|MALLOCX_TCACHE_MASK
operator|)
operator|!=
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|MALLOCX_TCACHE_MASK
operator|)
operator|==
name|MALLOCX_TCACHE_NONE
condition|)
block|{
name|tcache
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|tcache
operator|=
name|tcaches_get
argument_list|(
name|tsd
argument_list|,
name|MALLOCX_TCACHE_GET
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tcache
operator|=
name|tcache_get
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
block|}
name|alloc_ctx_t
name|alloc_ctx
decl_stmt|;
name|rtree_ctx_t
modifier|*
name|rtree_ctx
init|=
name|tsd_rtree_ctx
argument_list|(
name|tsd
argument_list|)
decl_stmt|;
name|rtree_szind_slab_read
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|extents_rtree
argument_list|,
name|rtree_ctx
argument_list|,
operator|(
name|uintptr_t
operator|)
name|ptr
argument_list|,
name|true
argument_list|,
operator|&
name|alloc_ctx
operator|.
name|szind
argument_list|,
operator|&
name|alloc_ctx
operator|.
name|slab
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|alloc_ctx
operator|.
name|szind
operator|!=
name|NSIZES
argument_list|)
expr_stmt|;
name|old_usize
operator|=
name|sz_index2size
argument_list|(
name|alloc_ctx
operator|.
name|szind
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|old_usize
operator|==
name|isalloc
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
block|{
name|usize
operator|=
operator|(
name|alignment
operator|==
literal|0
operator|)
condition|?
name|sz_s2u
argument_list|(
name|size
argument_list|)
else|:
name|sz_sa2u
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|usize
operator|==
literal|0
operator|||
name|usize
operator|>
name|LARGE_MAXCLASS
argument_list|)
condition|)
block|{
goto|goto
name|label_oom
goto|;
block|}
name|p
operator|=
name|irallocx_prof
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|,
operator|&
name|usize
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|,
operator|&
name|alloc_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|p
operator|==
name|NULL
argument_list|)
condition|)
block|{
goto|goto
name|label_oom
goto|;
block|}
block|}
else|else
block|{
name|p
operator|=
name|iralloct
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|p
operator|==
name|NULL
argument_list|)
condition|)
block|{
goto|goto
name|label_oom
goto|;
block|}
if|if
condition|(
name|config_stats
condition|)
block|{
name|usize
operator|=
name|isalloc
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
name|alignment
operator|==
literal|0
operator|||
operator|(
operator|(
name|uintptr_t
operator|)
name|p
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|==
name|ZU
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
operator|*
name|tsd_thread_allocatedp_get
argument_list|(
name|tsd
argument_list|)
operator|+=
name|usize
expr_stmt|;
operator|*
name|tsd_thread_deallocatedp_get
argument_list|(
name|tsd
argument_list|)
operator|+=
name|old_usize
expr_stmt|;
block|}
name|UTRACE
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|check_entry_exit_locking
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|p
return|;
name|label_oom
label|:
if|if
condition|(
name|config_xmalloc
operator|&&
name|unlikely
argument_list|(
name|opt_xmalloc
argument_list|)
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Error in rallocx(): out of memory\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|UTRACE
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|check_entry_exit_locking
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_decl_stmt

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|size_t
name|ixallocx_helper
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|old_usize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|extra
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|size_t
name|usize
decl_stmt|;
if|if
condition|(
name|ixalloc
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|size
argument_list|,
name|extra
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|)
condition|)
block|{
return|return
name|old_usize
return|;
block|}
name|usize
operator|=
name|isalloc
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
return|return
name|usize
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|ixallocx_prof_sample
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|old_usize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|extra
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
name|zero
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|)
block|{
name|size_t
name|usize
decl_stmt|;
if|if
condition|(
name|tctx
operator|==
name|NULL
condition|)
block|{
return|return
name|old_usize
return|;
block|}
name|usize
operator|=
name|ixallocx_helper
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|size
argument_list|,
name|extra
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|)
expr_stmt|;
return|return
name|usize
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|size_t
name|ixallocx_prof
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|old_usize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|extra
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
name|zero
parameter_list|,
name|alloc_ctx_t
modifier|*
name|alloc_ctx
parameter_list|)
block|{
name|size_t
name|usize_max
decl_stmt|,
name|usize
decl_stmt|;
name|bool
name|prof_active
decl_stmt|;
name|prof_tctx_t
modifier|*
name|old_tctx
decl_stmt|,
modifier|*
name|tctx
decl_stmt|;
name|prof_active
operator|=
name|prof_active_get_unlocked
argument_list|()
expr_stmt|;
name|old_tctx
operator|=
name|prof_tctx_get
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|alloc_ctx
argument_list|)
expr_stmt|;
comment|/* 	 * usize isn't knowable before ixalloc() returns when extra is non-zero. 	 * Therefore, compute its maximum possible value and use that in 	 * prof_alloc_prep() to decide whether to capture a backtrace. 	 * prof_realloc() will use the actual usize to decide whether to sample. 	 */
if|if
condition|(
name|alignment
operator|==
literal|0
condition|)
block|{
name|usize_max
operator|=
name|sz_s2u
argument_list|(
name|size
operator|+
name|extra
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|usize_max
operator|>
literal|0
operator|&&
name|usize_max
operator|<=
name|LARGE_MAXCLASS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usize_max
operator|=
name|sz_sa2u
argument_list|(
name|size
operator|+
name|extra
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|usize_max
operator|==
literal|0
operator|||
name|usize_max
operator|>
name|LARGE_MAXCLASS
argument_list|)
condition|)
block|{
comment|/* 			 * usize_max is out of range, and chances are that 			 * allocation will fail, but use the maximum possible 			 * value and carry on with prof_alloc_prep(), just in 			 * case allocation succeeds. 			 */
name|usize_max
operator|=
name|LARGE_MAXCLASS
expr_stmt|;
block|}
block|}
name|tctx
operator|=
name|prof_alloc_prep
argument_list|(
name|tsd
argument_list|,
name|usize_max
argument_list|,
name|prof_active
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|uintptr_t
operator|)
name|tctx
operator|!=
operator|(
name|uintptr_t
operator|)
literal|1U
argument_list|)
condition|)
block|{
name|usize
operator|=
name|ixallocx_prof_sample
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|size
argument_list|,
name|extra
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usize
operator|=
name|ixallocx_helper
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|size
argument_list|,
name|extra
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usize
operator|==
name|old_usize
condition|)
block|{
name|prof_alloc_rollback
argument_list|(
name|tsd
argument_list|,
name|tctx
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|usize
return|;
block|}
name|prof_realloc
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|,
name|tctx
argument_list|,
name|prof_active
argument_list|,
name|false
argument_list|,
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|old_tctx
argument_list|)
expr_stmt|;
return|return
name|usize
return|;
block|}
end_function

begin_function
name|JEMALLOC_EXPORT
name|size_t
name|JEMALLOC_NOTHROW
name|je_xallocx
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|extra
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tsd_t
modifier|*
name|tsd
decl_stmt|;
name|size_t
name|usize
decl_stmt|,
name|old_usize
decl_stmt|;
name|size_t
name|alignment
init|=
name|MALLOCX_ALIGN_GET
argument_list|(
name|flags
argument_list|)
decl_stmt|;
name|bool
name|zero
init|=
name|flags
operator|&
name|MALLOCX_ZERO
decl_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|SIZE_T_MAX
operator|-
name|size
operator|>=
name|extra
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|malloc_initialized
argument_list|()
operator|||
name|IS_INITIALIZER
argument_list|)
expr_stmt|;
name|tsd
operator|=
name|tsd_fetch
argument_list|()
expr_stmt|;
name|check_entry_exit_locking
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
name|alloc_ctx_t
name|alloc_ctx
decl_stmt|;
name|rtree_ctx_t
modifier|*
name|rtree_ctx
init|=
name|tsd_rtree_ctx
argument_list|(
name|tsd
argument_list|)
decl_stmt|;
name|rtree_szind_slab_read
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|extents_rtree
argument_list|,
name|rtree_ctx
argument_list|,
operator|(
name|uintptr_t
operator|)
name|ptr
argument_list|,
name|true
argument_list|,
operator|&
name|alloc_ctx
operator|.
name|szind
argument_list|,
operator|&
name|alloc_ctx
operator|.
name|slab
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|alloc_ctx
operator|.
name|szind
operator|!=
name|NSIZES
argument_list|)
expr_stmt|;
name|old_usize
operator|=
name|sz_index2size
argument_list|(
name|alloc_ctx
operator|.
name|szind
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|old_usize
operator|==
name|isalloc
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * The API explicitly absolves itself of protecting against (size + 	 * extra) numerical overflow, but we may need to clamp extra to avoid 	 * exceeding LARGE_MAXCLASS. 	 * 	 * Ordinarily, size limit checking is handled deeper down, but here we 	 * have to check as part of (size + extra) clamping, since we need the 	 * clamped value in the above helper functions. 	 */
if|if
condition|(
name|unlikely
argument_list|(
name|size
operator|>
name|LARGE_MAXCLASS
argument_list|)
condition|)
block|{
name|usize
operator|=
name|old_usize
expr_stmt|;
goto|goto
name|label_not_resized
goto|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|LARGE_MAXCLASS
operator|-
name|size
operator|<
name|extra
argument_list|)
condition|)
block|{
name|extra
operator|=
name|LARGE_MAXCLASS
operator|-
name|size
expr_stmt|;
block|}
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
block|{
name|usize
operator|=
name|ixallocx_prof
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|size
argument_list|,
name|extra
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
operator|&
name|alloc_ctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usize
operator|=
name|ixallocx_helper
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|size
argument_list|,
name|extra
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|usize
operator|==
name|old_usize
argument_list|)
condition|)
block|{
goto|goto
name|label_not_resized
goto|;
block|}
if|if
condition|(
name|config_stats
condition|)
block|{
operator|*
name|tsd_thread_allocatedp_get
argument_list|(
name|tsd
argument_list|)
operator|+=
name|usize
expr_stmt|;
operator|*
name|tsd_thread_deallocatedp_get
argument_list|(
name|tsd
argument_list|)
operator|+=
name|old_usize
expr_stmt|;
block|}
name|label_not_resized
label|:
name|UTRACE
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|check_entry_exit_locking
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|usize
return|;
block|}
end_function

begin_function
name|JEMALLOC_EXPORT
name|size_t
name|JEMALLOC_NOTHROW
name|JEMALLOC_ATTR
parameter_list|(
name|pure
parameter_list|)
function|je_sallocx
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|size_t
name|usize
decl_stmt|;
name|tsdn_t
modifier|*
name|tsdn
decl_stmt|;
name|assert
argument_list|(
name|malloc_initialized
argument_list|()
operator|||
name|IS_INITIALIZER
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tsdn
operator|=
name|tsdn_fetch
argument_list|()
expr_stmt|;
name|check_entry_exit_locking
argument_list|(
name|tsdn
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_debug
operator|||
name|force_ivsalloc
condition|)
block|{
name|usize
operator|=
name|ivsalloc
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|force_ivsalloc
operator|||
name|usize
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usize
operator|=
name|isalloc
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
name|check_entry_exit_locking
argument_list|(
name|tsdn
argument_list|)
expr_stmt|;
return|return
name|usize
return|;
block|}
end_function

begin_function
name|JEMALLOC_EXPORT
name|void
name|JEMALLOC_NOTHROW
name|je_dallocx
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|malloc_initialized
argument_list|()
operator|||
name|IS_INITIALIZER
argument_list|)
expr_stmt|;
name|tsd_t
modifier|*
name|tsd
init|=
name|tsd_fetch
argument_list|()
decl_stmt|;
name|bool
name|fast
init|=
name|tsd_fast
argument_list|(
name|tsd
argument_list|)
decl_stmt|;
name|check_entry_exit_locking
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
name|tcache_t
modifier|*
name|tcache
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|flags
operator|&
name|MALLOCX_TCACHE_MASK
operator|)
operator|!=
literal|0
argument_list|)
condition|)
block|{
comment|/* Not allowed to be reentrant and specify a custom tcache. */
name|assert
argument_list|(
name|tsd_reentrancy_level_get
argument_list|(
name|tsd
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|MALLOCX_TCACHE_MASK
operator|)
operator|==
name|MALLOCX_TCACHE_NONE
condition|)
block|{
name|tcache
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|tcache
operator|=
name|tcaches_get
argument_list|(
name|tsd
argument_list|,
name|MALLOCX_TCACHE_GET
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|likely
argument_list|(
name|fast
argument_list|)
condition|)
block|{
name|tcache
operator|=
name|tsd_tcachep_get
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tcache
operator|==
name|tcache_get
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|likely
argument_list|(
name|tsd_reentrancy_level_get
argument_list|(
name|tsd
argument_list|)
operator|==
literal|0
argument_list|)
condition|)
block|{
name|tcache
operator|=
name|tcache_get
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tcache
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
name|UTRACE
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|fast
argument_list|)
condition|)
block|{
name|tsd_assert_fast
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|tcache
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifree
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|tcache
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|check_entry_exit_locking
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE
name|size_t
name|inallocx
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|check_entry_exit_locking
argument_list|(
name|tsdn
argument_list|)
expr_stmt|;
name|size_t
name|usize
decl_stmt|;
if|if
condition|(
name|likely
argument_list|(
operator|(
name|flags
operator|&
name|MALLOCX_LG_ALIGN_MASK
operator|)
operator|==
literal|0
argument_list|)
condition|)
block|{
name|usize
operator|=
name|sz_s2u
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usize
operator|=
name|sz_sa2u
argument_list|(
name|size
argument_list|,
name|MALLOCX_ALIGN_GET_SPECIFIED
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|check_entry_exit_locking
argument_list|(
name|tsdn
argument_list|)
expr_stmt|;
return|return
name|usize
return|;
block|}
end_function

begin_function
name|JEMALLOC_EXPORT
name|void
name|JEMALLOC_NOTHROW
name|je_sdallocx
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|malloc_initialized
argument_list|()
operator|||
name|IS_INITIALIZER
argument_list|)
expr_stmt|;
name|tsd_t
modifier|*
name|tsd
init|=
name|tsd_fetch
argument_list|()
decl_stmt|;
name|bool
name|fast
init|=
name|tsd_fast
argument_list|(
name|tsd
argument_list|)
decl_stmt|;
name|size_t
name|usize
init|=
name|inallocx
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|size
argument_list|,
name|flags
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|usize
operator|==
name|isalloc
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
name|check_entry_exit_locking
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
name|tcache_t
modifier|*
name|tcache
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|flags
operator|&
name|MALLOCX_TCACHE_MASK
operator|)
operator|!=
literal|0
argument_list|)
condition|)
block|{
comment|/* Not allowed to be reentrant and specify a custom tcache. */
name|assert
argument_list|(
name|tsd_reentrancy_level_get
argument_list|(
name|tsd
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|MALLOCX_TCACHE_MASK
operator|)
operator|==
name|MALLOCX_TCACHE_NONE
condition|)
block|{
name|tcache
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|tcache
operator|=
name|tcaches_get
argument_list|(
name|tsd
argument_list|,
name|MALLOCX_TCACHE_GET
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|likely
argument_list|(
name|fast
argument_list|)
condition|)
block|{
name|tcache
operator|=
name|tsd_tcachep_get
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tcache
operator|==
name|tcache_get
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|likely
argument_list|(
name|tsd_reentrancy_level_get
argument_list|(
name|tsd
argument_list|)
operator|==
literal|0
argument_list|)
condition|)
block|{
name|tcache
operator|=
name|tcache_get
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tcache
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
name|UTRACE
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|fast
argument_list|)
condition|)
block|{
name|tsd_assert_fast
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
name|isfree
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|,
name|tcache
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isfree
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|,
name|tcache
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|check_entry_exit_locking
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_EXPORT
name|size_t
name|JEMALLOC_NOTHROW
name|JEMALLOC_ATTR
parameter_list|(
name|pure
parameter_list|)
function|je_nallocx
parameter_list|(
name|size_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|size_t
name|usize
decl_stmt|;
name|tsdn_t
modifier|*
name|tsdn
decl_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|malloc_init
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
name|tsdn
operator|=
name|tsdn_fetch
argument_list|()
expr_stmt|;
name|check_entry_exit_locking
argument_list|(
name|tsdn
argument_list|)
expr_stmt|;
name|usize
operator|=
name|inallocx
argument_list|(
name|tsdn
argument_list|,
name|size
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|usize
operator|>
name|LARGE_MAXCLASS
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
name|check_entry_exit_locking
argument_list|(
name|tsdn
argument_list|)
expr_stmt|;
return|return
name|usize
return|;
block|}
end_function

begin_function
name|JEMALLOC_EXPORT
name|int
name|JEMALLOC_NOTHROW
name|je_mallctl
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|oldp
parameter_list|,
name|size_t
modifier|*
name|oldlenp
parameter_list|,
name|void
modifier|*
name|newp
parameter_list|,
name|size_t
name|newlen
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|tsd_t
modifier|*
name|tsd
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|malloc_init
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|EAGAIN
return|;
block|}
name|tsd
operator|=
name|tsd_fetch
argument_list|()
expr_stmt|;
name|check_entry_exit_locking
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ctl_byname
argument_list|(
name|tsd
argument_list|,
name|name
argument_list|,
name|oldp
argument_list|,
name|oldlenp
argument_list|,
name|newp
argument_list|,
name|newlen
argument_list|)
expr_stmt|;
name|check_entry_exit_locking
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|JEMALLOC_EXPORT
name|int
name|JEMALLOC_NOTHROW
name|je_mallctlnametomib
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
modifier|*
name|mibp
parameter_list|,
name|size_t
modifier|*
name|miblenp
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|malloc_init
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|EAGAIN
return|;
block|}
name|tsd_t
modifier|*
name|tsd
init|=
name|tsd_fetch
argument_list|()
decl_stmt|;
name|check_entry_exit_locking
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ctl_nametomib
argument_list|(
name|tsd
argument_list|,
name|name
argument_list|,
name|mibp
argument_list|,
name|miblenp
argument_list|)
expr_stmt|;
name|check_entry_exit_locking
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|JEMALLOC_EXPORT
name|int
name|JEMALLOC_NOTHROW
name|je_mallctlbymib
parameter_list|(
specifier|const
name|size_t
modifier|*
name|mib
parameter_list|,
name|size_t
name|miblen
parameter_list|,
name|void
modifier|*
name|oldp
parameter_list|,
name|size_t
modifier|*
name|oldlenp
parameter_list|,
name|void
modifier|*
name|newp
parameter_list|,
name|size_t
name|newlen
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|tsd_t
modifier|*
name|tsd
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|malloc_init
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|EAGAIN
return|;
block|}
name|tsd
operator|=
name|tsd_fetch
argument_list|()
expr_stmt|;
name|check_entry_exit_locking
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ctl_bymib
argument_list|(
name|tsd
argument_list|,
name|mib
argument_list|,
name|miblen
argument_list|,
name|oldp
argument_list|,
name|oldlenp
argument_list|,
name|newp
argument_list|,
name|newlen
argument_list|)
expr_stmt|;
name|check_entry_exit_locking
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|JEMALLOC_EXPORT
name|void
name|JEMALLOC_NOTHROW
name|je_malloc_stats_print
parameter_list|(
name|void
function_decl|(
modifier|*
name|write_cb
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|cbopaque
parameter_list|,
specifier|const
name|char
modifier|*
name|opts
parameter_list|)
block|{
name|tsdn_t
modifier|*
name|tsdn
decl_stmt|;
name|tsdn
operator|=
name|tsdn_fetch
argument_list|()
expr_stmt|;
name|check_entry_exit_locking
argument_list|(
name|tsdn
argument_list|)
expr_stmt|;
name|stats_print
argument_list|(
name|write_cb
argument_list|,
name|cbopaque
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|check_entry_exit_locking
argument_list|(
name|tsdn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_EXPORT
name|size_t
name|JEMALLOC_NOTHROW
name|je_malloc_usable_size
parameter_list|(
name|JEMALLOC_USABLE_SIZE_CONST
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|size_t
name|ret
decl_stmt|;
name|tsdn_t
modifier|*
name|tsdn
decl_stmt|;
name|assert
argument_list|(
name|malloc_initialized
argument_list|()
operator|||
name|IS_INITIALIZER
argument_list|)
expr_stmt|;
name|tsdn
operator|=
name|tsdn_fetch
argument_list|()
expr_stmt|;
name|check_entry_exit_locking
argument_list|(
name|tsdn
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ptr
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|config_debug
operator|||
name|force_ivsalloc
condition|)
block|{
name|ret
operator|=
name|ivsalloc
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|force_ivsalloc
operator|||
name|ret
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|isalloc
argument_list|(
name|tsdn
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
name|check_entry_exit_locking
argument_list|(
name|tsdn
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * End non-standard functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin compatibility functions.  */
end_comment

begin_define
define|#
directive|define
name|ALLOCM_LG_ALIGN
parameter_list|(
name|la
parameter_list|)
value|(la)
end_define

begin_define
define|#
directive|define
name|ALLOCM_ALIGN
parameter_list|(
name|a
parameter_list|)
value|(ffsl(a)-1)
end_define

begin_define
define|#
directive|define
name|ALLOCM_ZERO
value|((int)0x40)
end_define

begin_define
define|#
directive|define
name|ALLOCM_NO_MOVE
value|((int)0x80)
end_define

begin_define
define|#
directive|define
name|ALLOCM_SUCCESS
value|0
end_define

begin_define
define|#
directive|define
name|ALLOCM_ERR_OOM
value|1
end_define

begin_define
define|#
directive|define
name|ALLOCM_ERR_NOT_MOVED
value|2
end_define

begin_function
name|int
name|je_allocm
parameter_list|(
name|void
modifier|*
modifier|*
name|ptr
parameter_list|,
name|size_t
modifier|*
name|rsize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|void
modifier|*
name|p
init|=
name|je_mallocx
argument_list|(
name|size
argument_list|,
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ALLOCM_ERR_OOM
operator|)
return|;
block|}
if|if
condition|(
name|rsize
operator|!=
name|NULL
condition|)
block|{
operator|*
name|rsize
operator|=
name|isalloc
argument_list|(
name|tsdn_fetch
argument_list|()
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
operator|*
name|ptr
operator|=
name|p
expr_stmt|;
return|return
name|ALLOCM_SUCCESS
return|;
block|}
end_function

begin_function
name|int
name|je_rallocm
parameter_list|(
name|void
modifier|*
modifier|*
name|ptr
parameter_list|,
name|size_t
modifier|*
name|rsize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|extra
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|*
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|SIZE_T_MAX
operator|-
name|size
operator|>=
name|extra
argument_list|)
expr_stmt|;
name|int
name|ret
decl_stmt|;
name|bool
name|no_move
init|=
name|flags
operator|&
name|ALLOCM_NO_MOVE
decl_stmt|;
if|if
condition|(
name|no_move
condition|)
block|{
name|size_t
name|usize
init|=
name|je_xallocx
argument_list|(
operator|*
name|ptr
argument_list|,
name|size
argument_list|,
name|extra
argument_list|,
name|flags
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|(
name|usize
operator|>=
name|size
operator|)
condition|?
name|ALLOCM_SUCCESS
else|:
name|ALLOCM_ERR_NOT_MOVED
expr_stmt|;
if|if
condition|(
name|rsize
operator|!=
name|NULL
condition|)
block|{
operator|*
name|rsize
operator|=
name|usize
expr_stmt|;
block|}
block|}
else|else
block|{
name|void
modifier|*
name|p
init|=
name|je_rallocx
argument_list|(
operator|*
name|ptr
argument_list|,
name|size
operator|+
name|extra
argument_list|,
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ptr
operator|=
name|p
expr_stmt|;
name|ret
operator|=
name|ALLOCM_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|ALLOCM_ERR_OOM
expr_stmt|;
block|}
if|if
condition|(
name|rsize
operator|!=
name|NULL
condition|)
block|{
operator|*
name|rsize
operator|=
name|isalloc
argument_list|(
name|tsdn_fetch
argument_list|()
argument_list|,
operator|*
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|je_sallocm
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
modifier|*
name|rsize
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|assert
argument_list|(
name|rsize
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|rsize
operator|=
name|je_sallocx
argument_list|(
name|ptr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|ALLOCM_SUCCESS
return|;
block|}
end_function

begin_function
name|int
name|je_dallocm
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|je_dallocx
argument_list|(
name|ptr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|ALLOCM_SUCCESS
return|;
block|}
end_function

begin_function
name|int
name|je_nallocm
parameter_list|(
name|size_t
modifier|*
name|rsize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|size_t
name|usize
init|=
name|je_nallocx
argument_list|(
name|size
argument_list|,
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|usize
operator|==
literal|0
condition|)
block|{
return|return
name|ALLOCM_ERR_OOM
return|;
block|}
if|if
condition|(
name|rsize
operator|!=
name|NULL
condition|)
block|{
operator|*
name|rsize
operator|=
name|usize
expr_stmt|;
block|}
return|return
name|ALLOCM_SUCCESS
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|ALLOCM_LG_ALIGN
end_undef

begin_undef
undef|#
directive|undef
name|ALLOCM_ALIGN
end_undef

begin_undef
undef|#
directive|undef
name|ALLOCM_ZERO
end_undef

begin_undef
undef|#
directive|undef
name|ALLOCM_NO_MOVE
end_undef

begin_undef
undef|#
directive|undef
name|ALLOCM_SUCCESS
end_undef

begin_undef
undef|#
directive|undef
name|ALLOCM_ERR_OOM
end_undef

begin_undef
undef|#
directive|undef
name|ALLOCM_ERR_NOT_MOVED
end_undef

begin_comment
comment|/*  * End compatibility functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * The following functions are used by threading libraries for protection of  * malloc during fork().  */
end_comment

begin_comment
comment|/*  * If an application creates a thread before doing any allocation in the main  * thread, then calls fork(2) in the main thread followed by memory allocation  * in the child process, a race can occur that results in deadlock within the  * child: the main thread may have forked while the created thread had  * partially initialized the allocator.  Ordinarily jemalloc prevents  * fork/malloc races via the following functions it registers during  * initialization using pthread_atfork(), but of course that does no good if  * the allocator isn't fully initialized at fork time.  The following library  * constructor is a partial solution to this problem.  It may still be possible  * to trigger the deadlock described above, but doing so would involve forking  * via a library constructor that runs before jemalloc's runs.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|JEMALLOC_JET
end_ifndef

begin_macro
name|JEMALLOC_ATTR
argument_list|(
argument|constructor
argument_list|)
end_macro

begin_function
specifier|static
name|void
name|jemalloc_constructor
parameter_list|(
name|void
parameter_list|)
block|{
name|malloc_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|JEMALLOC_MUTEX_INIT_CB
end_ifndef

begin_decl_stmt
name|void
name|jemalloc_prefork
argument_list|(
name|void
argument_list|)
else|#
directive|else
name|JEMALLOC_EXPORT
name|void
name|_malloc_prefork
argument_list|(
name|void
argument_list|)
endif|#
directive|endif
block|{
name|tsd_t
modifier|*
name|tsd
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|,
name|narenas
decl_stmt|;
name|arena_t
modifier|*
name|arena
decl_stmt|;
ifdef|#
directive|ifdef
name|JEMALLOC_MUTEX_INIT_CB
if|if
condition|(
operator|!
name|malloc_initialized
argument_list|()
condition|)
block|{
return|return;
block|}
endif|#
directive|endif
name|assert
argument_list|(
name|malloc_initialized
argument_list|()
argument_list|)
expr_stmt|;
name|tsd
operator|=
name|tsd_fetch
argument_list|()
expr_stmt|;
name|narenas
operator|=
name|narenas_total_get
argument_list|()
expr_stmt|;
name|witness_prefork
argument_list|(
name|tsd_witness_tsdp_get
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Acquire all mutexes in a safe order. */
name|ctl_prefork
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
name|tcache_prefork
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
name|malloc_mutex_prefork
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_background_thread
condition|)
block|{
name|background_thread_prefork0
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|prof_prefork0
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_background_thread
condition|)
block|{
name|background_thread_prefork1
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Break arena prefork into stages to preserve lock order. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|narenas
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|arena
operator|=
name|arena_get
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|j
argument_list|,
name|false
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
name|arena_prefork0
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|arena
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|arena_prefork1
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|arena
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|arena_prefork2
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|arena
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|arena_prefork3
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|arena
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|arena_prefork4
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|arena
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|arena_prefork5
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|arena
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|arena_prefork6
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|arena
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|arena_prefork7
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|arena
argument_list|)
expr_stmt|;
break|break;
default|default:
name|not_reached
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
name|prof_prefork1
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|JEMALLOC_MUTEX_INIT_CB
end_ifndef

begin_decl_stmt
name|void
name|jemalloc_postfork_parent
argument_list|(
name|void
argument_list|)
else|#
directive|else
name|JEMALLOC_EXPORT
name|void
name|_malloc_postfork
argument_list|(
name|void
argument_list|)
endif|#
directive|endif
block|{
name|tsd_t
modifier|*
name|tsd
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|narenas
decl_stmt|;
ifdef|#
directive|ifdef
name|JEMALLOC_MUTEX_INIT_CB
if|if
condition|(
operator|!
name|malloc_initialized
argument_list|()
condition|)
block|{
return|return;
block|}
endif|#
directive|endif
name|assert
argument_list|(
name|malloc_initialized
argument_list|()
argument_list|)
expr_stmt|;
name|tsd
operator|=
name|tsd_fetch
argument_list|()
expr_stmt|;
name|witness_postfork_parent
argument_list|(
name|tsd_witness_tsdp_get
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Release all mutexes, now that fork() has completed. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|narenas
operator|=
name|narenas_total_get
argument_list|()
init|;
name|i
operator|<
name|narenas
condition|;
name|i
operator|++
control|)
block|{
name|arena_t
modifier|*
name|arena
decl_stmt|;
if|if
condition|(
operator|(
name|arena
operator|=
name|arena_get
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|i
argument_list|,
name|false
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|arena_postfork_parent
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
block|}
name|prof_postfork_parent
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_background_thread
condition|)
block|{
name|background_thread_postfork_parent
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_postfork_parent
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
name|tcache_postfork_parent
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_postfork_parent
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
name|jemalloc_postfork_child
parameter_list|(
name|void
parameter_list|)
block|{
name|tsd_t
modifier|*
name|tsd
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|narenas
decl_stmt|;
name|assert
argument_list|(
name|malloc_initialized
argument_list|()
argument_list|)
expr_stmt|;
name|tsd
operator|=
name|tsd_fetch
argument_list|()
expr_stmt|;
name|witness_postfork_child
argument_list|(
name|tsd_witness_tsdp_get
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Release all mutexes, now that fork() has completed. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|narenas
operator|=
name|narenas_total_get
argument_list|()
init|;
name|i
operator|<
name|narenas
condition|;
name|i
operator|++
control|)
block|{
name|arena_t
modifier|*
name|arena
decl_stmt|;
if|if
condition|(
operator|(
name|arena
operator|=
name|arena_get
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|i
argument_list|,
name|false
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|arena_postfork_child
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
block|}
name|prof_postfork_child
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_background_thread
condition|)
block|{
name|background_thread_postfork_child
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_postfork_child
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|,
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
name|tcache_postfork_child
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_postfork_child
argument_list|(
name|tsd_tsdn
argument_list|(
name|tsd
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_malloc_first_thread
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|malloc_mutex_first_thread
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

end_unit

