begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|JEMALLOC_C_
end_define

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_internal.h"
end_include

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/* Data. */
end_comment

begin_comment
comment|/* Work around<http://llvm.org/bugs/show_bug.cgi?id=12623>: */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|__malloc_options_1_0
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|__sym_compat
argument_list|(
name|_malloc_options
argument_list|,
name|__malloc_options_1_0
argument_list|,
name|FBSD_1
literal|.0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Runtime configuration options. */
end_comment

begin_function_decl
specifier|const
name|char
modifier|*
name|je_malloc_conf
name|JEMALLOC_ATTR
parameter_list|(
name|weak
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|bool
name|opt_abort
init|=
ifdef|#
directive|ifdef
name|JEMALLOC_DEBUG
name|true
else|#
directive|else
name|false
endif|#
directive|endif
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|opt_junk
init|=
if|#
directive|if
operator|(
name|defined
argument_list|(
name|JEMALLOC_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|JEMALLOC_FILL
argument_list|)
operator|)
literal|"true"
else|#
directive|else
literal|"false"
endif|#
directive|endif
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_junk_alloc
init|=
if|#
directive|if
operator|(
name|defined
argument_list|(
name|JEMALLOC_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|JEMALLOC_FILL
argument_list|)
operator|)
name|true
else|#
directive|else
name|false
endif|#
directive|endif
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_junk_free
init|=
if|#
directive|if
operator|(
name|defined
argument_list|(
name|JEMALLOC_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|JEMALLOC_FILL
argument_list|)
operator|)
name|true
else|#
directive|else
name|false
endif|#
directive|endif
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|opt_quarantine
init|=
name|ZU
argument_list|(
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_redzone
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_utrace
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_xmalloc
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_zero
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|opt_narenas
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialized to true if the process is running inside Valgrind. */
end_comment

begin_decl_stmt
name|bool
name|in_valgrind
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|ncpus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Protects arenas initialization. */
end_comment

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|arenas_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Arenas that are used to service external requests.  Not all elements of the  * arenas array are necessarily used; arenas are created lazily as needed.  *  * arenas[0..narenas_auto) are used for automatic multiplexing of threads and  * arenas.  arenas[narenas_auto..narenas_total) are only used if the application  * takes some action to create them and allocate from them.  */
end_comment

begin_decl_stmt
name|arena_t
modifier|*
modifier|*
name|arenas
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|narenas_total
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use narenas_total_*(). */
end_comment

begin_decl_stmt
specifier|static
name|arena_t
modifier|*
name|a0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* arenas[0]; read-only after initialization. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|narenas_auto
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read-only after initialization. */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|malloc_init_uninitialized
init|=
literal|3
block|,
name|malloc_init_a0_initialized
init|=
literal|2
block|,
name|malloc_init_recursible
init|=
literal|1
block|,
name|malloc_init_initialized
init|=
literal|0
comment|/* Common case --> jnz. */
block|}
name|malloc_init_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|malloc_init_t
name|malloc_init_state
init|=
name|malloc_init_uninitialized
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 should be the common case.  Set to true to trigger initialization. */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|malloc_slow
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When malloc_slow != 0, set the corresponding bits for sanity check. */
end_comment

begin_enum
enum|enum
block|{
name|flag_opt_junk_alloc
init|=
operator|(
literal|1U
operator|)
block|,
name|flag_opt_junk_free
init|=
operator|(
literal|1U
operator|<<
literal|1
operator|)
block|,
name|flag_opt_quarantine
init|=
operator|(
literal|1U
operator|<<
literal|2
operator|)
block|,
name|flag_opt_zero
init|=
operator|(
literal|1U
operator|<<
literal|3
operator|)
block|,
name|flag_opt_utrace
init|=
operator|(
literal|1U
operator|<<
literal|4
operator|)
block|,
name|flag_in_valgrind
init|=
operator|(
literal|1U
operator|<<
literal|5
operator|)
block|,
name|flag_opt_xmalloc
init|=
operator|(
literal|1U
operator|<<
literal|6
operator|)
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|uint8_t
name|malloc_slow_flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last entry for overflow detection only.  */
end_comment

begin_macro
name|JEMALLOC_ALIGNED
argument_list|(
argument|CACHELINE
argument_list|)
end_macro

begin_decl_stmt
specifier|const
name|size_t
name|index2size_tab
index|[
name|NSIZES
operator|+
literal|1
index|]
init|=
block|{
define|#
directive|define
name|SC
parameter_list|(
name|index
parameter_list|,
name|lg_grp
parameter_list|,
name|lg_delta
parameter_list|,
name|ndelta
parameter_list|,
name|bin
parameter_list|,
name|lg_delta_lookup
parameter_list|)
define|\
value|((ZU(1)<<lg_grp) + (ZU(ndelta)<<lg_delta)),
name|SIZE_CLASSES
undef|#
directive|undef
name|SC
name|ZU
argument_list|(
literal|0
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|JEMALLOC_ALIGNED
argument_list|(
argument|CACHELINE
argument_list|)
end_macro

begin_decl_stmt
specifier|const
name|uint8_t
name|size2index_tab
index|[]
init|=
block|{
if|#
directive|if
name|LG_TINY_MIN
operator|==
literal|0
warning|#
directive|warning
literal|"Dangerous LG_TINY_MIN"
define|#
directive|define
name|S2B_0
parameter_list|(
name|i
parameter_list|)
value|i,
elif|#
directive|elif
name|LG_TINY_MIN
operator|==
literal|1
warning|#
directive|warning
literal|"Dangerous LG_TINY_MIN"
define|#
directive|define
name|S2B_1
parameter_list|(
name|i
parameter_list|)
value|i,
elif|#
directive|elif
name|LG_TINY_MIN
operator|==
literal|2
warning|#
directive|warning
literal|"Dangerous LG_TINY_MIN"
define|#
directive|define
name|S2B_2
parameter_list|(
name|i
parameter_list|)
value|i,
elif|#
directive|elif
name|LG_TINY_MIN
operator|==
literal|3
define|#
directive|define
name|S2B_3
parameter_list|(
name|i
parameter_list|)
value|i,
elif|#
directive|elif
name|LG_TINY_MIN
operator|==
literal|4
define|#
directive|define
name|S2B_4
parameter_list|(
name|i
parameter_list|)
value|i,
elif|#
directive|elif
name|LG_TINY_MIN
operator|==
literal|5
define|#
directive|define
name|S2B_5
parameter_list|(
name|i
parameter_list|)
value|i,
elif|#
directive|elif
name|LG_TINY_MIN
operator|==
literal|6
define|#
directive|define
name|S2B_6
parameter_list|(
name|i
parameter_list|)
value|i,
elif|#
directive|elif
name|LG_TINY_MIN
operator|==
literal|7
define|#
directive|define
name|S2B_7
parameter_list|(
name|i
parameter_list|)
value|i,
elif|#
directive|elif
name|LG_TINY_MIN
operator|==
literal|8
define|#
directive|define
name|S2B_8
parameter_list|(
name|i
parameter_list|)
value|i,
elif|#
directive|elif
name|LG_TINY_MIN
operator|==
literal|9
define|#
directive|define
name|S2B_9
parameter_list|(
name|i
parameter_list|)
value|i,
elif|#
directive|elif
name|LG_TINY_MIN
operator|==
literal|10
define|#
directive|define
name|S2B_10
parameter_list|(
name|i
parameter_list|)
value|i,
elif|#
directive|elif
name|LG_TINY_MIN
operator|==
literal|11
define|#
directive|define
name|S2B_11
parameter_list|(
name|i
parameter_list|)
value|i,
else|#
directive|else
error|#
directive|error
literal|"Unsupported LG_TINY_MIN"
endif|#
directive|endif
if|#
directive|if
name|LG_TINY_MIN
operator|<
literal|1
define|#
directive|define
name|S2B_1
parameter_list|(
name|i
parameter_list|)
value|S2B_0(i) S2B_0(i)
endif|#
directive|endif
if|#
directive|if
name|LG_TINY_MIN
operator|<
literal|2
define|#
directive|define
name|S2B_2
parameter_list|(
name|i
parameter_list|)
value|S2B_1(i) S2B_1(i)
endif|#
directive|endif
if|#
directive|if
name|LG_TINY_MIN
operator|<
literal|3
define|#
directive|define
name|S2B_3
parameter_list|(
name|i
parameter_list|)
value|S2B_2(i) S2B_2(i)
endif|#
directive|endif
if|#
directive|if
name|LG_TINY_MIN
operator|<
literal|4
define|#
directive|define
name|S2B_4
parameter_list|(
name|i
parameter_list|)
value|S2B_3(i) S2B_3(i)
endif|#
directive|endif
if|#
directive|if
name|LG_TINY_MIN
operator|<
literal|5
define|#
directive|define
name|S2B_5
parameter_list|(
name|i
parameter_list|)
value|S2B_4(i) S2B_4(i)
endif|#
directive|endif
if|#
directive|if
name|LG_TINY_MIN
operator|<
literal|6
define|#
directive|define
name|S2B_6
parameter_list|(
name|i
parameter_list|)
value|S2B_5(i) S2B_5(i)
endif|#
directive|endif
if|#
directive|if
name|LG_TINY_MIN
operator|<
literal|7
define|#
directive|define
name|S2B_7
parameter_list|(
name|i
parameter_list|)
value|S2B_6(i) S2B_6(i)
endif|#
directive|endif
if|#
directive|if
name|LG_TINY_MIN
operator|<
literal|8
define|#
directive|define
name|S2B_8
parameter_list|(
name|i
parameter_list|)
value|S2B_7(i) S2B_7(i)
endif|#
directive|endif
if|#
directive|if
name|LG_TINY_MIN
operator|<
literal|9
define|#
directive|define
name|S2B_9
parameter_list|(
name|i
parameter_list|)
value|S2B_8(i) S2B_8(i)
endif|#
directive|endif
if|#
directive|if
name|LG_TINY_MIN
operator|<
literal|10
define|#
directive|define
name|S2B_10
parameter_list|(
name|i
parameter_list|)
value|S2B_9(i) S2B_9(i)
endif|#
directive|endif
if|#
directive|if
name|LG_TINY_MIN
operator|<
literal|11
define|#
directive|define
name|S2B_11
parameter_list|(
name|i
parameter_list|)
value|S2B_10(i) S2B_10(i)
endif|#
directive|endif
define|#
directive|define
name|S2B_no
parameter_list|(
name|i
parameter_list|)
define|#
directive|define
name|SC
parameter_list|(
name|index
parameter_list|,
name|lg_grp
parameter_list|,
name|lg_delta
parameter_list|,
name|ndelta
parameter_list|,
name|bin
parameter_list|,
name|lg_delta_lookup
parameter_list|)
define|\
value|S2B_##lg_delta_lookup(index)
name|SIZE_CLASSES
undef|#
directive|undef
name|S2B_3
undef|#
directive|undef
name|S2B_4
undef|#
directive|undef
name|S2B_5
undef|#
directive|undef
name|S2B_6
undef|#
directive|undef
name|S2B_7
undef|#
directive|undef
name|S2B_8
undef|#
directive|undef
name|S2B_9
undef|#
directive|undef
name|S2B_10
undef|#
directive|undef
name|S2B_11
undef|#
directive|undef
name|S2B_no
undef|#
directive|undef
name|SC
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_THREADED_INIT
end_ifdef

begin_comment
comment|/* Used to let the initializing thread recursively allocate. */
end_comment

begin_define
define|#
directive|define
name|NO_INITIALIZER
value|((unsigned long)0)
end_define

begin_define
define|#
directive|define
name|INITIALIZER
value|pthread_self()
end_define

begin_define
define|#
directive|define
name|IS_INITIALIZER
value|(malloc_initializer == pthread_self())
end_define

begin_decl_stmt
specifier|static
name|pthread_t
name|malloc_initializer
init|=
name|NO_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NO_INITIALIZER
value|false
end_define

begin_define
define|#
directive|define
name|INITIALIZER
value|true
end_define

begin_define
define|#
directive|define
name|IS_INITIALIZER
value|malloc_initializer
end_define

begin_decl_stmt
specifier|static
name|bool
name|malloc_initializer
init|=
name|NO_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Used to avoid initialization races. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_if
if|#
directive|if
name|_WIN32_WINNT
operator|>=
literal|0x0600
end_if

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|init_lock
init|=
name|SRWLOCK_INIT
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|init_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|init_lock_initialized
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_macro
name|JEMALLOC_ATTR
argument_list|(
argument|constructor
argument_list|)
end_macro

begin_function
specifier|static
name|void
name|WINAPI
name|_init_init_lock
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* If another constructor in the same binary is using mallctl to 	 * e.g. setup chunk hooks, it may end up running before this one, 	 * and malloc_init_hard will crash trying to lock the uninitialized 	 * lock. So we force an initialization of the lock in 	 * malloc_init_hard as well. We don't try to care about atomicity 	 * of the accessed to the init_lock_initialized boolean, since it 	 * really only matters early in the process creation, before any 	 * separate thread normally starts doing anything. */
if|if
condition|(
operator|!
name|init_lock_initialized
condition|)
name|malloc_mutex_init
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
name|init_lock_initialized
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|section
name|(
literal|".CRT$XCU"
name|,
name|read
name|)
end_pragma

begin_macro
name|JEMALLOC_SECTION
argument_list|(
literal|".CRT$XCU"
argument_list|)
end_macro

begin_macro
name|JEMALLOC_ATTR
argument_list|(
argument|used
argument_list|)
end_macro

begin_function_decl
specifier|static
specifier|const
name|void
function_decl|(
name|WINAPI
modifier|*
name|init_init_lock
function_decl|)
parameter_list|(
name|void
parameter_list|)
init|=
name|_init_init_lock
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|init_lock
init|=
name|MALLOC_MUTEX_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
block|{
name|void
modifier|*
name|p
decl_stmt|;
comment|/* Input pointer (as in realloc(p, s)). */
name|size_t
name|s
decl_stmt|;
comment|/* Request size. */
name|void
modifier|*
name|r
decl_stmt|;
comment|/* Result pointer. */
block|}
name|malloc_utrace_t
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_UTRACE
end_ifdef

begin_define
define|#
directive|define
name|UTRACE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|do {						\ 	if (unlikely(opt_utrace)) {					\ 		int utrace_serrno = errno;				\ 		malloc_utrace_t ut;					\ 		ut.p = (a);						\ 		ut.s = (b);						\ 		ut.r = (c);						\ 		utrace(&ut, sizeof(ut));				\ 		errno = utrace_serrno;					\ 	}								\ } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|UTRACE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Function prototypes for static functions that are referenced prior to  * definition.  */
end_comment

begin_function_decl
specifier|static
name|bool
name|malloc_init_hard_a0
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|malloc_init_hard
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin miscellaneous support functions.  */
end_comment

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|bool
name|malloc_initialized
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|malloc_init_state
operator|==
name|malloc_init_initialized
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|void
name|malloc_thread_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * TSD initialization can't be safely done as a side effect of 	 * deallocation, because it is possible for a thread to do nothing but 	 * deallocate its TLS data via free(), in which case writing to TLS 	 * would cause write-after-free memory corruption.  The quarantine 	 * facility *only* gets used as a side effect of deallocation, so make 	 * a best effort attempt at initializing its TSD by hooking all 	 * allocation events. 	 */
if|if
condition|(
name|config_fill
operator|&&
name|unlikely
argument_list|(
name|opt_quarantine
argument_list|)
condition|)
name|quarantine_alloc_hook
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|bool
name|malloc_init_a0
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|malloc_init_state
operator|==
name|malloc_init_uninitialized
argument_list|)
condition|)
return|return
operator|(
name|malloc_init_hard_a0
argument_list|()
operator|)
return|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|bool
name|malloc_init
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|malloc_initialized
argument_list|()
argument_list|)
operator|&&
name|malloc_init_hard
argument_list|()
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|malloc_thread_init
argument_list|()
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The a0*() functions are used instead of i[mcd]alloc() in situations that  * cannot tolerate TLS variable access.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|a0ialloc
parameter_list|(
name|size_t
name|size
parameter_list|,
name|bool
name|zero
parameter_list|,
name|bool
name|is_metadata
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|malloc_init_a0
argument_list|()
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|iallocztm
argument_list|(
name|NULL
argument_list|,
name|size
argument_list|,
name|size2index
argument_list|(
name|size
argument_list|)
argument_list|,
name|zero
argument_list|,
name|false
argument_list|,
name|is_metadata
argument_list|,
name|arena_get
argument_list|(
literal|0
argument_list|,
name|false
argument_list|)
argument_list|,
name|true
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|a0idalloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|bool
name|is_metadata
parameter_list|)
block|{
name|idalloctm
argument_list|(
name|NULL
argument_list|,
name|ptr
argument_list|,
name|false
argument_list|,
name|is_metadata
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|a0malloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|a0ialloc
argument_list|(
name|size
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|a0dalloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|a0idalloc
argument_list|(
name|ptr
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * FreeBSD's libc uses the bootstrap_*() functions in bootstrap-senstive  * situations that cannot tolerate TLS variable access (TLS allocation and very  * early internal data structure initialization).  */
end_comment

begin_function
name|void
modifier|*
name|bootstrap_malloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|size
operator|==
literal|0
argument_list|)
condition|)
name|size
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|a0ialloc
argument_list|(
name|size
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|bootstrap_calloc
parameter_list|(
name|size_t
name|num
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|num_size
decl_stmt|;
name|num_size
operator|=
name|num
operator|*
name|size
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|num_size
operator|==
literal|0
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|num
operator|==
literal|0
operator|||
name|size
operator|==
literal|0
argument_list|)
expr_stmt|;
name|num_size
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|a0ialloc
argument_list|(
name|num_size
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|bootstrap_free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|ptr
operator|==
name|NULL
argument_list|)
condition|)
return|return;
name|a0idalloc
argument_list|(
name|ptr
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_set
parameter_list|(
name|unsigned
name|ind
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|atomic_write_p
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|arenas
index|[
name|ind
index|]
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|narenas_total_set
parameter_list|(
name|unsigned
name|narenas
parameter_list|)
block|{
name|atomic_write_u
argument_list|(
operator|&
name|narenas_total
argument_list|,
name|narenas
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|narenas_total_inc
parameter_list|(
name|void
parameter_list|)
block|{
name|atomic_add_u
argument_list|(
operator|&
name|narenas_total
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|narenas_total_get
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|atomic_read_u
argument_list|(
operator|&
name|narenas_total
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create a new arena and insert it into the arenas array at index ind. */
end_comment

begin_function
specifier|static
name|arena_t
modifier|*
name|arena_init_locked
parameter_list|(
name|unsigned
name|ind
parameter_list|)
block|{
name|arena_t
modifier|*
name|arena
decl_stmt|;
name|assert
argument_list|(
name|ind
operator|<=
name|narenas_total_get
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind
operator|>
name|MALLOCX_ARENA_MAX
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|ind
operator|==
name|narenas_total_get
argument_list|()
condition|)
name|narenas_total_inc
argument_list|()
expr_stmt|;
comment|/* 	 * Another thread may have already initialized arenas[ind] if it's an 	 * auto arena. 	 */
name|arena
operator|=
name|arena_get
argument_list|(
name|ind
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|arena
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|ind
operator|<
name|narenas_auto
argument_list|)
expr_stmt|;
return|return
operator|(
name|arena
operator|)
return|;
block|}
comment|/* Actually initialize the arena. */
name|arena
operator|=
name|arena_new
argument_list|(
name|ind
argument_list|)
expr_stmt|;
name|arena_set
argument_list|(
name|ind
argument_list|,
name|arena
argument_list|)
expr_stmt|;
return|return
operator|(
name|arena
operator|)
return|;
block|}
end_function

begin_function
name|arena_t
modifier|*
name|arena_init
parameter_list|(
name|unsigned
name|ind
parameter_list|)
block|{
name|arena_t
modifier|*
name|arena
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
name|arena
operator|=
name|arena_init_locked
argument_list|(
name|ind
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|arena
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_bind
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|unsigned
name|ind
parameter_list|)
block|{
name|arena_t
modifier|*
name|arena
decl_stmt|;
name|arena
operator|=
name|arena_get
argument_list|(
name|ind
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|arena_nthreads_inc
argument_list|(
name|arena
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsd_nominal
argument_list|(
name|tsd
argument_list|)
condition|)
name|tsd_arena_set
argument_list|(
name|tsd
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arena_migrate
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|unsigned
name|oldind
parameter_list|,
name|unsigned
name|newind
parameter_list|)
block|{
name|arena_t
modifier|*
name|oldarena
decl_stmt|,
modifier|*
name|newarena
decl_stmt|;
name|oldarena
operator|=
name|arena_get
argument_list|(
name|oldind
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|newarena
operator|=
name|arena_get
argument_list|(
name|newind
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|arena_nthreads_dec
argument_list|(
name|oldarena
argument_list|)
expr_stmt|;
name|arena_nthreads_inc
argument_list|(
name|newarena
argument_list|)
expr_stmt|;
name|tsd_arena_set
argument_list|(
name|tsd
argument_list|,
name|newarena
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_unbind
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|unsigned
name|ind
parameter_list|)
block|{
name|arena_t
modifier|*
name|arena
decl_stmt|;
name|arena
operator|=
name|arena_get
argument_list|(
name|ind
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|arena_nthreads_dec
argument_list|(
name|arena
argument_list|)
expr_stmt|;
name|tsd_arena_set
argument_list|(
name|tsd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|arena_tdata_t
modifier|*
name|arena_tdata_get_hard
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|unsigned
name|ind
parameter_list|)
block|{
name|arena_tdata_t
modifier|*
name|tdata
decl_stmt|,
modifier|*
name|arenas_tdata_old
decl_stmt|;
name|arena_tdata_t
modifier|*
name|arenas_tdata
init|=
name|tsd_arenas_tdata_get
argument_list|(
name|tsd
argument_list|)
decl_stmt|;
name|unsigned
name|narenas_tdata_old
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|narenas_tdata
init|=
name|tsd_narenas_tdata_get
argument_list|(
name|tsd
argument_list|)
decl_stmt|;
name|unsigned
name|narenas_actual
init|=
name|narenas_total_get
argument_list|()
decl_stmt|;
comment|/* 	 * Dissociate old tdata array (and set up for deallocation upon return) 	 * if it's too small. 	 */
if|if
condition|(
name|arenas_tdata
operator|!=
name|NULL
operator|&&
name|narenas_tdata
operator|<
name|narenas_actual
condition|)
block|{
name|arenas_tdata_old
operator|=
name|arenas_tdata
expr_stmt|;
name|narenas_tdata_old
operator|=
name|narenas_tdata
expr_stmt|;
name|arenas_tdata
operator|=
name|NULL
expr_stmt|;
name|narenas_tdata
operator|=
literal|0
expr_stmt|;
name|tsd_arenas_tdata_set
argument_list|(
name|tsd
argument_list|,
name|arenas_tdata
argument_list|)
expr_stmt|;
name|tsd_narenas_tdata_set
argument_list|(
name|tsd
argument_list|,
name|narenas_tdata
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arenas_tdata_old
operator|=
name|NULL
expr_stmt|;
name|narenas_tdata_old
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Allocate tdata array if it's missing. */
if|if
condition|(
name|arenas_tdata
operator|==
name|NULL
condition|)
block|{
name|bool
modifier|*
name|arenas_tdata_bypassp
init|=
name|tsd_arenas_tdata_bypassp_get
argument_list|(
name|tsd
argument_list|)
decl_stmt|;
name|narenas_tdata
operator|=
operator|(
name|ind
operator|<
name|narenas_actual
operator|)
condition|?
name|narenas_actual
else|:
name|ind
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tsd_nominal
argument_list|(
name|tsd
argument_list|)
operator|&&
operator|!
operator|*
name|arenas_tdata_bypassp
condition|)
block|{
operator|*
name|arenas_tdata_bypassp
operator|=
name|true
expr_stmt|;
name|arenas_tdata
operator|=
operator|(
name|arena_tdata_t
operator|*
operator|)
name|a0malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arena_tdata_t
argument_list|)
operator|*
name|narenas_tdata
argument_list|)
expr_stmt|;
operator|*
name|arenas_tdata_bypassp
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|arenas_tdata
operator|==
name|NULL
condition|)
block|{
name|tdata
operator|=
name|NULL
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
name|assert
argument_list|(
name|tsd_nominal
argument_list|(
name|tsd
argument_list|)
operator|&&
operator|!
operator|*
name|arenas_tdata_bypassp
argument_list|)
expr_stmt|;
name|tsd_arenas_tdata_set
argument_list|(
name|tsd
argument_list|,
name|arenas_tdata
argument_list|)
expr_stmt|;
name|tsd_narenas_tdata_set
argument_list|(
name|tsd
argument_list|,
name|narenas_tdata
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Copy to tdata array.  It's possible that the actual number of arenas 	 * has increased since narenas_total_get() was called above, but that 	 * causes no correctness issues unless two threads concurrently execute 	 * the arenas.extend mallctl, which we trust mallctl synchronization to 	 * prevent. 	 */
comment|/* Copy/initialize tickers. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|narenas_actual
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|narenas_tdata_old
condition|)
block|{
name|ticker_copy
argument_list|(
operator|&
name|arenas_tdata
index|[
name|i
index|]
operator|.
name|decay_ticker
argument_list|,
operator|&
name|arenas_tdata_old
index|[
name|i
index|]
operator|.
name|decay_ticker
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ticker_init
argument_list|(
operator|&
name|arenas_tdata
index|[
name|i
index|]
operator|.
name|decay_ticker
argument_list|,
name|DECAY_NTICKS_PER_UPDATE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|narenas_tdata
operator|>
name|narenas_actual
condition|)
block|{
name|memset
argument_list|(
operator|&
name|arenas_tdata
index|[
name|narenas_actual
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|arena_tdata_t
argument_list|)
operator|*
operator|(
name|narenas_tdata
operator|-
name|narenas_actual
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Read the refreshed tdata array. */
name|tdata
operator|=
operator|&
name|arenas_tdata
index|[
name|ind
index|]
expr_stmt|;
name|label_return
label|:
if|if
condition|(
name|arenas_tdata_old
operator|!=
name|NULL
condition|)
name|a0dalloc
argument_list|(
name|arenas_tdata_old
argument_list|)
expr_stmt|;
return|return
operator|(
name|tdata
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Slow path, called only by arena_choose(). */
end_comment

begin_function
name|arena_t
modifier|*
name|arena_choose_hard
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|)
block|{
name|arena_t
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|narenas_auto
operator|>
literal|1
condition|)
block|{
name|unsigned
name|i
decl_stmt|,
name|choose
decl_stmt|,
name|first_null
decl_stmt|;
name|choose
operator|=
literal|0
expr_stmt|;
name|first_null
operator|=
name|narenas_auto
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_get
argument_list|(
literal|0
argument_list|,
name|false
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|narenas_auto
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|arena_get
argument_list|(
name|i
argument_list|,
name|false
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Choose the first arena that has the lowest 				 * number of threads assigned to it. 				 */
if|if
condition|(
name|arena_nthreads_get
argument_list|(
name|arena_get
argument_list|(
name|i
argument_list|,
name|false
argument_list|)
argument_list|)
operator|<
name|arena_nthreads_get
argument_list|(
name|arena_get
argument_list|(
name|choose
argument_list|,
name|false
argument_list|)
argument_list|)
condition|)
name|choose
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|first_null
operator|==
name|narenas_auto
condition|)
block|{
comment|/* 				 * Record the index of the first uninitialized 				 * arena, in case all extant arenas are in use. 				 * 				 * NB: It is possible for there to be 				 * discontinuities in terms of initialized 				 * versus uninitialized arenas, due to the 				 * "thread.arena" mallctl. 				 */
name|first_null
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|arena_nthreads_get
argument_list|(
name|arena_get
argument_list|(
name|choose
argument_list|,
name|false
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|first_null
operator|==
name|narenas_auto
condition|)
block|{
comment|/* 			 * Use an unloaded arena, or the least loaded arena if 			 * all arenas are already initialized. 			 */
name|ret
operator|=
name|arena_get
argument_list|(
name|choose
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Initialize a new arena. */
name|choose
operator|=
name|first_null
expr_stmt|;
name|ret
operator|=
name|arena_init_locked
argument_list|(
name|choose
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|arena_bind
argument_list|(
name|tsd
argument_list|,
name|choose
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|arena_get
argument_list|(
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|arena_bind
argument_list|(
name|tsd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|thread_allocated_cleanup
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|)
block|{
comment|/* Do nothing. */
block|}
end_function

begin_function
name|void
name|thread_deallocated_cleanup
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|)
block|{
comment|/* Do nothing. */
block|}
end_function

begin_function
name|void
name|arena_cleanup
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|)
block|{
name|arena_t
modifier|*
name|arena
decl_stmt|;
name|arena
operator|=
name|tsd_arena_get
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
if|if
condition|(
name|arena
operator|!=
name|NULL
condition|)
name|arena_unbind
argument_list|(
name|tsd
argument_list|,
name|arena
operator|->
name|ind
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arenas_tdata_cleanup
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|)
block|{
name|arena_tdata_t
modifier|*
name|arenas_tdata
decl_stmt|;
comment|/* Prevent tsd->arenas_tdata from being (re)created. */
operator|*
name|tsd_arenas_tdata_bypassp_get
argument_list|(
name|tsd
argument_list|)
operator|=
name|true
expr_stmt|;
name|arenas_tdata
operator|=
name|tsd_arenas_tdata_get
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
if|if
condition|(
name|arenas_tdata
operator|!=
name|NULL
condition|)
block|{
name|tsd_arenas_tdata_set
argument_list|(
name|tsd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|a0dalloc
argument_list|(
name|arenas_tdata
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|narenas_tdata_cleanup
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|)
block|{
comment|/* Do nothing. */
block|}
end_function

begin_function
name|void
name|arenas_tdata_bypass_cleanup
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|)
block|{
comment|/* Do nothing. */
block|}
end_function

begin_function
specifier|static
name|void
name|stats_print_atexit
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|config_tcache
operator|&&
name|config_stats
condition|)
block|{
name|unsigned
name|narenas
decl_stmt|,
name|i
decl_stmt|;
comment|/* 		 * Merge stats from extant threads.  This is racy, since 		 * individual threads do not lock when recording tcache stats 		 * events.  As a consequence, the final stats may be slightly 		 * out of date by the time they are reported, if other threads 		 * continue to allocate. 		 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|narenas
operator|=
name|narenas_total_get
argument_list|()
init|;
name|i
operator|<
name|narenas
condition|;
name|i
operator|++
control|)
block|{
name|arena_t
modifier|*
name|arena
init|=
name|arena_get
argument_list|(
name|i
argument_list|,
name|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|arena
operator|!=
name|NULL
condition|)
block|{
name|tcache_t
modifier|*
name|tcache
decl_stmt|;
comment|/* 				 * tcache_stats_merge() locks bins, so if any 				 * code is introduced that acquires both arena 				 * and bin locks in the opposite order, 				 * deadlocks may result. 				 */
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ql_foreach
argument_list|(
argument|tcache
argument_list|,
argument|&arena->tcache_ql
argument_list|,
argument|link
argument_list|)
block|{
name|tcache_stats_merge
argument_list|(
name|tcache
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|je_malloc_stats_print
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * End miscellaneous support functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin initialization functions.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|JEMALLOC_HAVE_SECURE_GETENV
end_ifndef

begin_function
specifier|static
name|char
modifier|*
name|secure_getenv
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|JEMALLOC_HAVE_ISSETUGID
if|if
condition|(
name|issetugid
argument_list|()
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
name|getenv
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|unsigned
name|malloc_ncpus
parameter_list|(
name|void
parameter_list|)
block|{
name|long
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
name|SYSTEM_INFO
name|si
decl_stmt|;
name|GetSystemInfo
argument_list|(
operator|&
name|si
argument_list|)
expr_stmt|;
name|result
operator|=
name|si
operator|.
name|dwNumberOfProcessors
expr_stmt|;
else|#
directive|else
name|result
operator|=
name|sysconf
argument_list|(
name|_SC_NPROCESSORS_ONLN
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|(
name|result
operator|==
operator|-
literal|1
operator|)
condition|?
literal|1
else|:
operator|(
name|unsigned
operator|)
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|malloc_conf_next
parameter_list|(
name|char
specifier|const
modifier|*
modifier|*
name|opts_p
parameter_list|,
name|char
specifier|const
modifier|*
modifier|*
name|k_p
parameter_list|,
name|size_t
modifier|*
name|klen_p
parameter_list|,
name|char
specifier|const
modifier|*
modifier|*
name|v_p
parameter_list|,
name|size_t
modifier|*
name|vlen_p
parameter_list|)
block|{
name|bool
name|accept
decl_stmt|;
specifier|const
name|char
modifier|*
name|opts
init|=
operator|*
name|opts_p
decl_stmt|;
operator|*
name|k_p
operator|=
name|opts
expr_stmt|;
for|for
control|(
name|accept
operator|=
name|false
init|;
operator|!
name|accept
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|opts
condition|)
block|{
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'_'
case|:
name|opts
operator|++
expr_stmt|;
break|break;
case|case
literal|':'
case|:
name|opts
operator|++
expr_stmt|;
operator|*
name|klen_p
operator|=
operator|(
name|uintptr_t
operator|)
name|opts
operator|-
literal|1
operator|-
operator|(
name|uintptr_t
operator|)
operator|*
name|k_p
expr_stmt|;
operator|*
name|v_p
operator|=
name|opts
expr_stmt|;
name|accept
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
if|if
condition|(
name|opts
operator|!=
operator|*
name|opts_p
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Conf string ends "
literal|"with key\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|true
operator|)
return|;
default|default:
name|malloc_write
argument_list|(
literal|"<jemalloc>: Malformed conf string\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
block|}
for|for
control|(
name|accept
operator|=
name|false
init|;
operator|!
name|accept
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|opts
condition|)
block|{
case|case
literal|','
case|:
name|opts
operator|++
expr_stmt|;
comment|/* 			 * Look ahead one character here, because the next time 			 * this function is called, it will assume that end of 			 * input has been cleanly reached if no input remains, 			 * but we have optimistically already consumed the 			 * comma if one exists. 			 */
if|if
condition|(
operator|*
name|opts
operator|==
literal|'\0'
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Conf string ends "
literal|"with comma\n"
argument_list|)
expr_stmt|;
block|}
operator|*
name|vlen_p
operator|=
operator|(
name|uintptr_t
operator|)
name|opts
operator|-
literal|1
operator|-
operator|(
name|uintptr_t
operator|)
operator|*
name|v_p
expr_stmt|;
name|accept
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
operator|*
name|vlen_p
operator|=
operator|(
name|uintptr_t
operator|)
name|opts
operator|-
operator|(
name|uintptr_t
operator|)
operator|*
name|v_p
expr_stmt|;
name|accept
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|opts
operator|++
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|opts_p
operator|=
name|opts
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|malloc_conf_error
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|k
parameter_list|,
name|size_t
name|klen
parameter_list|,
specifier|const
name|char
modifier|*
name|v
parameter_list|,
name|size_t
name|vlen
parameter_list|)
block|{
name|malloc_printf
argument_list|(
literal|"<jemalloc>: %s: %.*s:%.*s\n"
argument_list|,
name|msg
argument_list|,
operator|(
name|int
operator|)
name|klen
argument_list|,
name|k
argument_list|,
operator|(
name|int
operator|)
name|vlen
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|malloc_slow_flag_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Combine the runtime options into malloc_slow for fast path.  Called 	 * after processing all the options. 	 */
name|malloc_slow_flags
operator||=
operator|(
name|opt_junk_alloc
condition|?
name|flag_opt_junk_alloc
else|:
literal|0
operator|)
operator||
operator|(
name|opt_junk_free
condition|?
name|flag_opt_junk_free
else|:
literal|0
operator|)
operator||
operator|(
name|opt_quarantine
condition|?
name|flag_opt_quarantine
else|:
literal|0
operator|)
operator||
operator|(
name|opt_zero
condition|?
name|flag_opt_zero
else|:
literal|0
operator|)
operator||
operator|(
name|opt_utrace
condition|?
name|flag_opt_utrace
else|:
literal|0
operator|)
operator||
operator|(
name|opt_xmalloc
condition|?
name|flag_opt_xmalloc
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|config_valgrind
condition|)
name|malloc_slow_flags
operator||=
operator|(
name|in_valgrind
condition|?
name|flag_in_valgrind
else|:
literal|0
operator|)
expr_stmt|;
name|malloc_slow
operator|=
operator|(
name|malloc_slow_flags
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|malloc_conf_init
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|char
name|buf
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|opts
decl_stmt|,
modifier|*
name|k
decl_stmt|,
modifier|*
name|v
decl_stmt|;
name|size_t
name|klen
decl_stmt|,
name|vlen
decl_stmt|;
comment|/* 	 * Automatically configure valgrind before processing options.  The 	 * valgrind option remains in jemalloc 3.x for compatibility reasons. 	 */
if|if
condition|(
name|config_valgrind
condition|)
block|{
name|in_valgrind
operator|=
operator|(
name|RUNNING_ON_VALGRIND
operator|!=
literal|0
operator|)
condition|?
name|true
else|:
name|false
expr_stmt|;
if|if
condition|(
name|config_fill
operator|&&
name|unlikely
argument_list|(
name|in_valgrind
argument_list|)
condition|)
block|{
name|opt_junk
operator|=
literal|"false"
expr_stmt|;
name|opt_junk_alloc
operator|=
name|false
expr_stmt|;
name|opt_junk_free
operator|=
name|false
expr_stmt|;
name|assert
argument_list|(
operator|!
name|opt_zero
argument_list|)
expr_stmt|;
name|opt_quarantine
operator|=
name|JEMALLOC_VALGRIND_QUARANTINE_DEFAULT
expr_stmt|;
name|opt_redzone
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|config_tcache
operator|&&
name|unlikely
argument_list|(
name|in_valgrind
argument_list|)
condition|)
name|opt_tcache
operator|=
name|false
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
comment|/* Get runtime configuration. */
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
name|opts
operator|=
name|config_malloc_conf
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|je_malloc_conf
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Use options that were compiled into the 				 * program. 				 */
name|opts
operator|=
name|je_malloc_conf
expr_stmt|;
block|}
else|else
block|{
comment|/* No configuration specified. */
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opts
operator|=
name|buf
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
block|{
name|ssize_t
name|linklen
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|_WIN32
name|int
name|saved_errno
init|=
name|errno
decl_stmt|;
specifier|const
name|char
modifier|*
name|linkname
init|=
ifdef|#
directive|ifdef
name|JEMALLOC_PREFIX
literal|"/etc/"
name|JEMALLOC_PREFIX
literal|"malloc.conf"
else|#
directive|else
literal|"/etc/malloc.conf"
endif|#
directive|endif
decl_stmt|;
comment|/* 			 * Try to use the contents of the "/etc/malloc.conf" 			 * symbolic link's name. 			 */
name|linklen
operator|=
name|readlink
argument_list|(
name|linkname
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|linklen
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* No configuration specified. */
name|linklen
operator|=
literal|0
expr_stmt|;
comment|/* Restore errno. */
name|set_errno
argument_list|(
name|saved_errno
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|buf
index|[
name|linklen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opts
operator|=
name|buf
expr_stmt|;
break|break;
block|}
case|case
literal|3
case|:
block|{
specifier|const
name|char
modifier|*
name|envname
init|=
ifdef|#
directive|ifdef
name|JEMALLOC_PREFIX
name|JEMALLOC_CPREFIX
literal|"MALLOC_CONF"
else|#
directive|else
literal|"MALLOC_CONF"
endif|#
directive|endif
decl_stmt|;
if|if
condition|(
operator|(
name|opts
operator|=
name|secure_getenv
argument_list|(
name|envname
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Do nothing; opts is already initialized to 				 * the value of the MALLOC_CONF environment 				 * variable. 				 */
block|}
else|else
block|{
comment|/* No configuration specified. */
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opts
operator|=
name|buf
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|not_reached
argument_list|()
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opts
operator|=
name|buf
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|opts
operator|!=
literal|'\0'
operator|&&
operator|!
name|malloc_conf_next
argument_list|(
operator|&
name|opts
argument_list|,
operator|&
name|k
argument_list|,
operator|&
name|klen
argument_list|,
operator|&
name|v
argument_list|,
operator|&
name|vlen
argument_list|)
condition|)
block|{
define|#
directive|define
name|CONF_MATCH
parameter_list|(
name|n
parameter_list|)
define|\
value|(sizeof(n)-1 == klen&& strncmp(n, k, klen) == 0)
define|#
directive|define
name|CONF_MATCH_VALUE
parameter_list|(
name|n
parameter_list|)
define|\
value|(sizeof(n)-1 == vlen&& strncmp(n, v, vlen) == 0)
define|#
directive|define
name|CONF_HANDLE_BOOL
parameter_list|(
name|o
parameter_list|,
name|n
parameter_list|,
name|cont
parameter_list|)
define|\
value|if (CONF_MATCH(n)) {				\ 				if (CONF_MATCH_VALUE("true"))		\ 					o = true;			\ 				else if (CONF_MATCH_VALUE("false"))	\ 					o = false;			\ 				else {					\ 					malloc_conf_error(		\ 					    "Invalid conf value",	\ 					    k, klen, v, vlen);		\ 				}					\ 				if (cont)				\ 					continue;			\ 			}
define|#
directive|define
name|CONF_HANDLE_T_U
parameter_list|(
name|t
parameter_list|,
name|o
parameter_list|,
name|n
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|,
name|clip
parameter_list|)
define|\
value|if (CONF_MATCH(n)) {				\ 				uintmax_t um;				\ 				char *end;				\ 									\ 				set_errno(0);				\ 				um = malloc_strtoumax(v,&end, 0);	\ 				if (get_errno() != 0 || (uintptr_t)end -\ 				    (uintptr_t)v != vlen) {		\ 					malloc_conf_error(		\ 					    "Invalid conf value",	\ 					    k, klen, v, vlen);		\ 				} else if (clip) {			\ 					if ((min) != 0&& um< (min))	\ 						o = (t)(min);		\ 					else if (um> (max))		\ 						o = (t)(max);		\ 					else				\ 						o = (t)um;		\ 				} else {				\ 					if (((min) != 0&& um< (min))	\ 					    || um> (max)) {		\ 						malloc_conf_error(	\ 						    "Out-of-range "	\ 						    "conf value",	\ 						    k, klen, v, vlen);	\ 					} else				\ 						o = (t)um;		\ 				}					\ 				continue;				\ 			}
define|#
directive|define
name|CONF_HANDLE_UNSIGNED
parameter_list|(
name|o
parameter_list|,
name|n
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|,
name|clip
parameter_list|)
define|\
value|CONF_HANDLE_T_U(unsigned, o, n, min, max, clip)
define|#
directive|define
name|CONF_HANDLE_SIZE_T
parameter_list|(
name|o
parameter_list|,
name|n
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|,
name|clip
parameter_list|)
define|\
value|CONF_HANDLE_T_U(size_t, o, n, min, max, clip)
define|#
directive|define
name|CONF_HANDLE_SSIZE_T
parameter_list|(
name|o
parameter_list|,
name|n
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|)
define|\
value|if (CONF_MATCH(n)) {				\ 				long l;					\ 				char *end;				\ 									\ 				set_errno(0);				\ 				l = strtol(v,&end, 0);			\ 				if (get_errno() != 0 || (uintptr_t)end -\ 				    (uintptr_t)v != vlen) {		\ 					malloc_conf_error(		\ 					    "Invalid conf value",	\ 					    k, klen, v, vlen);		\ 				} else if (l< (ssize_t)(min) || l>	\ 				    (ssize_t)(max)) {			\ 					malloc_conf_error(		\ 					    "Out-of-range conf value",	\ 					    k, klen, v, vlen);		\ 				} else					\ 					o = l;				\ 				continue;				\ 			}
define|#
directive|define
name|CONF_HANDLE_CHAR_P
parameter_list|(
name|o
parameter_list|,
name|n
parameter_list|,
name|d
parameter_list|)
define|\
value|if (CONF_MATCH(n)) {				\ 				size_t cpylen = (vlen<=		\ 				    sizeof(o)-1) ? vlen :		\ 				    sizeof(o)-1;			\ 				strncpy(o, v, cpylen);			\ 				o[cpylen] = '\0';			\ 				continue;				\ 			}
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_abort
argument_list|,
literal|"abort"
argument_list|,
argument|true
argument_list|)
comment|/* 			 * Chunks always require at least one header page, 			 * as many as 2^(LG_SIZE_CLASS_GROUP+1) data pages, and 			 * possibly an additional page in the presence of 			 * redzones.  In order to simplify options processing, 			 * use a conservative bound that accommodates all these 			 * constraints. 			 */
name|CONF_HANDLE_SIZE_T
argument_list|(
argument|opt_lg_chunk
argument_list|,
literal|"lg_chunk"
argument_list|,
argument|LG_PAGE + 			    LG_SIZE_CLASS_GROUP + (config_fill ?
literal|2
argument|:
literal|1
argument|)
argument_list|,
argument|(sizeof(size_t)<<
literal|3
argument|) -
literal|1
argument_list|,
argument|true
argument_list|)
if|if
condition|(
name|strncmp
argument_list|(
literal|"dss"
argument_list|,
name|k
argument_list|,
name|klen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|bool
name|match
init|=
name|false
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dss_prec_limit
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|dss_prec_names
index|[
name|i
index|]
argument_list|,
name|v
argument_list|,
name|vlen
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|chunk_dss_prec_set
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|malloc_conf_error
argument_list|(
literal|"Error setting dss"
argument_list|,
name|k
argument_list|,
name|klen
argument_list|,
name|v
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|opt_dss
operator|=
name|dss_prec_names
index|[
name|i
index|]
expr_stmt|;
name|match
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|match
condition|)
block|{
name|malloc_conf_error
argument_list|(
literal|"Invalid conf value"
argument_list|,
name|k
argument_list|,
name|klen
argument_list|,
name|v
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|CONF_HANDLE_UNSIGNED
argument_list|(
argument|opt_narenas
argument_list|,
literal|"narenas"
argument_list|,
literal|1
argument_list|,
argument|UINT_MAX
argument_list|,
argument|false
argument_list|)
if|if
condition|(
name|strncmp
argument_list|(
literal|"purge"
argument_list|,
name|k
argument_list|,
name|klen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|bool
name|match
init|=
name|false
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|purge_mode_limit
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|purge_mode_names
index|[
name|i
index|]
argument_list|,
name|v
argument_list|,
name|vlen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|opt_purge
operator|=
operator|(
name|purge_mode_t
operator|)
name|i
expr_stmt|;
name|match
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|match
condition|)
block|{
name|malloc_conf_error
argument_list|(
literal|"Invalid conf value"
argument_list|,
name|k
argument_list|,
name|klen
argument_list|,
name|v
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|CONF_HANDLE_SSIZE_T
argument_list|(
argument|opt_lg_dirty_mult
argument_list|,
literal|"lg_dirty_mult"
argument_list|,
argument|-
literal|1
argument_list|,
argument|(sizeof(size_t)<<
literal|3
argument|) -
literal|1
argument_list|)
name|CONF_HANDLE_SSIZE_T
argument_list|(
name|opt_decay_time
argument_list|,
literal|"decay_time"
argument_list|,
operator|-
literal|1
argument_list|,
name|NSTIME_SEC_MAX
argument_list|)
expr_stmt|;
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_stats_print
argument_list|,
literal|"stats_print"
argument_list|,
argument|true
argument_list|)
if|if
condition|(
name|config_fill
condition|)
block|{
if|if
condition|(
name|CONF_MATCH
argument_list|(
literal|"junk"
argument_list|)
condition|)
block|{
if|if
condition|(
name|CONF_MATCH_VALUE
argument_list|(
literal|"true"
argument_list|)
condition|)
block|{
name|opt_junk
operator|=
literal|"true"
expr_stmt|;
name|opt_junk_alloc
operator|=
name|opt_junk_free
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONF_MATCH_VALUE
argument_list|(
literal|"false"
argument_list|)
condition|)
block|{
name|opt_junk
operator|=
literal|"false"
expr_stmt|;
name|opt_junk_alloc
operator|=
name|opt_junk_free
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONF_MATCH_VALUE
argument_list|(
literal|"alloc"
argument_list|)
condition|)
block|{
name|opt_junk
operator|=
literal|"alloc"
expr_stmt|;
name|opt_junk_alloc
operator|=
name|true
expr_stmt|;
name|opt_junk_free
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONF_MATCH_VALUE
argument_list|(
literal|"free"
argument_list|)
condition|)
block|{
name|opt_junk
operator|=
literal|"free"
expr_stmt|;
name|opt_junk_alloc
operator|=
name|false
expr_stmt|;
name|opt_junk_free
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|malloc_conf_error
argument_list|(
literal|"Invalid conf value"
argument_list|,
name|k
argument_list|,
name|klen
argument_list|,
name|v
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|CONF_HANDLE_SIZE_T
argument_list|(
argument|opt_quarantine
argument_list|,
literal|"quarantine"
argument_list|,
literal|0
argument_list|,
argument|SIZE_T_MAX
argument_list|,
argument|false
argument_list|)
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_redzone
argument_list|,
literal|"redzone"
argument_list|,
argument|true
argument_list|)
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_zero
argument_list|,
literal|"zero"
argument_list|,
argument|true
argument_list|)
block|}
if|if
condition|(
name|config_utrace
condition|)
block|{
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_utrace
argument_list|,
literal|"utrace"
argument_list|,
argument|true
argument_list|)
block|}
if|if
condition|(
name|config_xmalloc
condition|)
block|{
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_xmalloc
argument_list|,
literal|"xmalloc"
argument_list|,
argument|true
argument_list|)
block|}
if|if
condition|(
name|config_tcache
condition|)
block|{
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_tcache
argument_list|,
literal|"tcache"
argument_list|,
argument|!config_valgrind || !in_valgrind
argument_list|)
if|if
condition|(
name|CONF_MATCH
argument_list|(
literal|"tcache"
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|config_valgrind
operator|&&
name|in_valgrind
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_tcache
condition|)
block|{
name|opt_tcache
operator|=
name|false
expr_stmt|;
name|malloc_conf_error
argument_list|(
literal|"tcache cannot be enabled "
literal|"while running inside Valgrind"
argument_list|,
name|k
argument_list|,
name|klen
argument_list|,
name|v
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|CONF_HANDLE_SSIZE_T
argument_list|(
argument|opt_lg_tcache_max
argument_list|,
literal|"lg_tcache_max"
argument_list|,
argument|-
literal|1
argument_list|,
argument|(sizeof(size_t)<<
literal|3
argument|) -
literal|1
argument_list|)
block|}
if|if
condition|(
name|config_prof
condition|)
block|{
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_prof
argument_list|,
literal|"prof"
argument_list|,
argument|true
argument_list|)
name|CONF_HANDLE_CHAR_P
argument_list|(
argument|opt_prof_prefix
argument_list|,
literal|"prof_prefix"
argument_list|,
literal|"jeprof"
argument_list|)
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_prof_active
argument_list|,
literal|"prof_active"
argument_list|,
argument|true
argument_list|)
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_prof_thread_active_init
argument_list|,
literal|"prof_thread_active_init"
argument_list|,
argument|true
argument_list|)
name|CONF_HANDLE_SIZE_T
argument_list|(
argument|opt_lg_prof_sample
argument_list|,
literal|"lg_prof_sample"
argument_list|,
literal|0
argument_list|,
argument|(sizeof(uint64_t)<<
literal|3
argument|) -
literal|1
argument_list|,
argument|true
argument_list|)
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_prof_accum
argument_list|,
literal|"prof_accum"
argument_list|,
argument|true
argument_list|)
name|CONF_HANDLE_SSIZE_T
argument_list|(
argument|opt_lg_prof_interval
argument_list|,
literal|"lg_prof_interval"
argument_list|,
argument|-
literal|1
argument_list|,
argument|(sizeof(uint64_t)<<
literal|3
argument|) -
literal|1
argument_list|)
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_prof_gdump
argument_list|,
literal|"prof_gdump"
argument_list|,
argument|true
argument_list|)
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_prof_final
argument_list|,
literal|"prof_final"
argument_list|,
argument|true
argument_list|)
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_prof_leak
argument_list|,
literal|"prof_leak"
argument_list|,
argument|true
argument_list|)
block|}
name|malloc_conf_error
argument_list|(
literal|"Invalid conf pair"
argument_list|,
name|k
argument_list|,
name|klen
argument_list|,
name|v
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|CONF_MATCH
undef|#
directive|undef
name|CONF_HANDLE_BOOL
undef|#
directive|undef
name|CONF_HANDLE_SIZE_T
undef|#
directive|undef
name|CONF_HANDLE_SSIZE_T
undef|#
directive|undef
name|CONF_HANDLE_CHAR_P
block|}
block|}
block|}
end_function

begin_comment
comment|/* init_lock must be held. */
end_comment

begin_function
specifier|static
name|bool
name|malloc_init_hard_needed
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|malloc_initialized
argument_list|()
operator|||
operator|(
name|IS_INITIALIZER
operator|&&
name|malloc_init_state
operator|==
name|malloc_init_recursible
operator|)
condition|)
block|{
comment|/* 		 * Another thread initialized the allocator before this one 		 * acquired init_lock, or this thread is the initializing 		 * thread, and it is recursively allocating. 		 */
return|return
operator|(
name|false
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|JEMALLOC_THREADED_INIT
if|if
condition|(
name|malloc_initializer
operator|!=
name|NO_INITIALIZER
operator|&&
operator|!
name|IS_INITIALIZER
condition|)
block|{
comment|/* Busy-wait until the initializing thread completes. */
do|do
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
name|CPU_SPINWAIT
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|malloc_initialized
argument_list|()
condition|)
do|;
return|return
operator|(
name|false
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/* init_lock must be held. */
end_comment

begin_function
specifier|static
name|bool
name|malloc_init_hard_a0_locked
parameter_list|(
name|void
parameter_list|)
block|{
name|malloc_initializer
operator|=
name|INITIALIZER
expr_stmt|;
if|if
condition|(
name|config_prof
condition|)
name|prof_boot0
argument_list|()
expr_stmt|;
name|malloc_conf_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|opt_stats_print
condition|)
block|{
comment|/* Print statistics at exit. */
if|if
condition|(
name|atexit
argument_list|(
name|stats_print_atexit
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Error in atexit()\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|base_boot
argument_list|()
condition|)
return|return
operator|(
name|true
operator|)
return|;
if|if
condition|(
name|chunk_boot
argument_list|()
condition|)
return|return
operator|(
name|true
operator|)
return|;
if|if
condition|(
name|ctl_boot
argument_list|()
condition|)
return|return
operator|(
name|true
operator|)
return|;
if|if
condition|(
name|config_prof
condition|)
name|prof_boot1
argument_list|()
expr_stmt|;
if|if
condition|(
name|arena_boot
argument_list|()
condition|)
return|return
operator|(
name|true
operator|)
return|;
if|if
condition|(
name|config_tcache
operator|&&
name|tcache_boot
argument_list|()
condition|)
return|return
operator|(
name|true
operator|)
return|;
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|arenas_lock
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
comment|/* 	 * Create enough scaffolding to allow recursive allocation in 	 * malloc_ncpus(). 	 */
name|narenas_auto
operator|=
literal|1
expr_stmt|;
name|narenas_total_set
argument_list|(
name|narenas_auto
argument_list|)
expr_stmt|;
name|arenas
operator|=
operator|&
name|a0
expr_stmt|;
name|memset
argument_list|(
name|arenas
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|arena_t
operator|*
argument_list|)
operator|*
name|narenas_auto
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize one arena here.  The rest are lazily created in 	 * arena_choose_hard(). 	 */
if|if
condition|(
name|arena_init
argument_list|(
literal|0
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|malloc_init_state
operator|=
name|malloc_init_a0_initialized
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|malloc_init_hard_a0
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|ret
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|malloc_init_hard_a0_locked
argument_list|()
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize data structures which may trigger recursive allocation.  *  * init_lock must be held.  */
end_comment

begin_function
specifier|static
name|bool
name|malloc_init_hard_recursible
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|ret
init|=
name|false
decl_stmt|;
name|malloc_init_state
operator|=
name|malloc_init_recursible
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
comment|/* LinuxThreads' pthread_setspecific() allocates. */
if|if
condition|(
name|malloc_tsd_boot0
argument_list|()
condition|)
block|{
name|ret
operator|=
name|true
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
name|ncpus
operator|=
name|malloc_ncpus
argument_list|()
expr_stmt|;
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|JEMALLOC_MUTEX_INIT_CB
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|JEMALLOC_ZONE
argument_list|)
expr|\
operator|&&
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__native_client__
argument_list|)
operator|)
comment|/* LinuxThreads' pthread_atfork() allocates. */
if|if
condition|(
name|pthread_atfork
argument_list|(
name|jemalloc_prefork
argument_list|,
name|jemalloc_postfork_parent
argument_list|,
name|jemalloc_postfork_child
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|true
expr_stmt|;
name|malloc_write
argument_list|(
literal|"<jemalloc>: Error in pthread_atfork()\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|label_return
label|:
name|malloc_mutex_lock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* init_lock must be held. */
end_comment

begin_function
specifier|static
name|bool
name|malloc_init_hard_finish
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|mutex_boot
argument_list|()
condition|)
return|return
operator|(
name|true
operator|)
return|;
if|if
condition|(
name|opt_narenas
operator|==
literal|0
condition|)
block|{
comment|/* 		 * For SMP systems, create more than one arena per CPU by 		 * default. 		 */
if|if
condition|(
name|ncpus
operator|>
literal|1
condition|)
name|opt_narenas
operator|=
name|ncpus
operator|<<
literal|2
expr_stmt|;
else|else
name|opt_narenas
operator|=
literal|1
expr_stmt|;
block|}
name|narenas_auto
operator|=
name|opt_narenas
expr_stmt|;
comment|/* 	 * Limit the number of arenas to the indexing range of MALLOCX_ARENA(). 	 */
if|if
condition|(
name|narenas_auto
operator|>
name|MALLOCX_ARENA_MAX
condition|)
block|{
name|narenas_auto
operator|=
name|MALLOCX_ARENA_MAX
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"<jemalloc>: Reducing narenas to limit (%d)\n"
argument_list|,
name|narenas_auto
argument_list|)
expr_stmt|;
block|}
name|narenas_total_set
argument_list|(
name|narenas_auto
argument_list|)
expr_stmt|;
comment|/* Allocate and initialize arenas. */
name|arenas
operator|=
operator|(
name|arena_t
operator|*
operator|*
operator|)
name|base_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arena_t
operator|*
argument_list|)
operator|*
operator|(
name|MALLOCX_ARENA_MAX
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arenas
operator|==
name|NULL
condition|)
return|return
operator|(
name|true
operator|)
return|;
comment|/* Copy the pointer to the one arena that was already initialized. */
name|arena_set
argument_list|(
literal|0
argument_list|,
name|a0
argument_list|)
expr_stmt|;
name|malloc_init_state
operator|=
name|malloc_init_initialized
expr_stmt|;
name|malloc_slow_flag_init
argument_list|()
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|malloc_init_hard
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
name|_WIN32_WINNT
operator|<
literal|0x0600
name|_init_init_lock
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|malloc_mutex_lock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|malloc_init_hard_needed
argument_list|()
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
if|if
condition|(
name|malloc_init_state
operator|!=
name|malloc_init_a0_initialized
operator|&&
name|malloc_init_hard_a0_locked
argument_list|()
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
if|if
condition|(
name|malloc_init_hard_recursible
argument_list|()
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
if|if
condition|(
name|config_prof
operator|&&
name|prof_boot2
argument_list|()
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
if|if
condition|(
name|malloc_init_hard_finish
argument_list|()
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
name|malloc_tsd_boot1
argument_list|()
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * End initialization functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin malloc(3)-compatible functions.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|imalloc_prof_sample
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|szind_t
name|ind
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|,
name|bool
name|slow_path
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|tctx
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|usize
operator|<=
name|SMALL_MAXCLASS
condition|)
block|{
name|szind_t
name|ind_large
init|=
name|size2index
argument_list|(
name|LARGE_MINCLASS
argument_list|)
decl_stmt|;
name|p
operator|=
name|imalloc
argument_list|(
name|tsd
argument_list|,
name|LARGE_MINCLASS
argument_list|,
name|ind_large
argument_list|,
name|slow_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|arena_prof_promoted
argument_list|(
name|p
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|=
name|imalloc
argument_list|(
name|tsd
argument_list|,
name|usize
argument_list|,
name|ind
argument_list|,
name|slow_path
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|void
modifier|*
name|imalloc_prof
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|szind_t
name|ind
parameter_list|,
name|bool
name|slow_path
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|prof_tctx_t
modifier|*
name|tctx
decl_stmt|;
name|tctx
operator|=
name|prof_alloc_prep
argument_list|(
name|tsd
argument_list|,
name|usize
argument_list|,
name|prof_active_get_unlocked
argument_list|()
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|uintptr_t
operator|)
name|tctx
operator|!=
operator|(
name|uintptr_t
operator|)
literal|1U
argument_list|)
condition|)
name|p
operator|=
name|imalloc_prof_sample
argument_list|(
name|tsd
argument_list|,
name|usize
argument_list|,
name|ind
argument_list|,
name|tctx
argument_list|,
name|slow_path
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|imalloc
argument_list|(
name|tsd
argument_list|,
name|usize
argument_list|,
name|ind
argument_list|,
name|slow_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|p
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|prof_alloc_rollback
argument_list|(
name|tsd
argument_list|,
name|tctx
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|prof_malloc
argument_list|(
name|p
argument_list|,
name|usize
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|void
modifier|*
name|imalloc_body
parameter_list|(
name|size_t
name|size
parameter_list|,
name|tsd_t
modifier|*
modifier|*
name|tsd
parameter_list|,
name|size_t
modifier|*
name|usize
parameter_list|,
name|bool
name|slow_path
parameter_list|)
block|{
name|szind_t
name|ind
decl_stmt|;
if|if
condition|(
name|slow_path
operator|&&
name|unlikely
argument_list|(
name|malloc_init
argument_list|()
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|*
name|tsd
operator|=
name|tsd_fetch
argument_list|()
expr_stmt|;
name|ind
operator|=
name|size2index
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ind
operator|>=
name|NSIZES
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|config_stats
operator|||
operator|(
name|config_prof
operator|&&
name|opt_prof
operator|)
operator|||
operator|(
name|slow_path
operator|&&
name|config_valgrind
operator|&&
name|unlikely
argument_list|(
name|in_valgrind
argument_list|)
operator|)
condition|)
block|{
operator|*
name|usize
operator|=
name|index2size
argument_list|(
name|ind
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|*
name|usize
operator|>
literal|0
operator|&&
operator|*
name|usize
operator|<=
name|HUGE_MAXCLASS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
return|return
operator|(
name|imalloc_prof
argument_list|(
operator|*
name|tsd
argument_list|,
operator|*
name|usize
argument_list|,
name|ind
argument_list|,
name|slow_path
argument_list|)
operator|)
return|;
return|return
operator|(
name|imalloc
argument_list|(
operator|*
name|tsd
argument_list|,
name|size
argument_list|,
name|ind
argument_list|,
name|slow_path
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|void
name|imalloc_post_check
parameter_list|(
name|void
modifier|*
name|ret
parameter_list|,
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|bool
name|slow_path
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|ret
operator|==
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
name|slow_path
operator|&&
name|config_xmalloc
operator|&&
name|unlikely
argument_list|(
name|opt_xmalloc
argument_list|)
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Error in malloc(): "
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|set_errno
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config_stats
operator|&&
name|likely
argument_list|(
name|ret
operator|!=
name|NULL
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|usize
operator|==
name|isalloc
argument_list|(
name|ret
argument_list|,
name|config_prof
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|tsd_thread_allocatedp_get
argument_list|(
name|tsd
argument_list|)
operator|+=
name|usize
expr_stmt|;
block|}
block|}
end_function

begin_function
name|JEMALLOC_EXPORT
name|JEMALLOC_ALLOCATOR
name|JEMALLOC_RESTRICT_RETURN
name|void
name|JEMALLOC_NOTHROW
modifier|*
name|JEMALLOC_ATTR
parameter_list|(
name|malloc
parameter_list|)
function|JEMALLOC_ALLOC_SIZE
parameter_list|(
function|1
end_function

begin_macro
unit|)
name|je_malloc
argument_list|(
argument|size_t size
argument_list|)
end_macro

begin_block
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|tsd_t
modifier|*
name|tsd
decl_stmt|;
name|size_t
name|usize
name|JEMALLOC_CC_SILENCE_INIT
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
operator|!
name|malloc_slow
argument_list|)
condition|)
block|{
comment|/* 		 * imalloc_body() is inlined so that fast and slow paths are 		 * generated separately with statically known slow_path. 		 */
name|ret
operator|=
name|imalloc_body
argument_list|(
name|size
argument_list|,
operator|&
name|tsd
argument_list|,
operator|&
name|usize
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|imalloc_post_check
argument_list|(
name|ret
argument_list|,
name|tsd
argument_list|,
name|usize
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|imalloc_body
argument_list|(
name|size
argument_list|,
operator|&
name|tsd
argument_list|,
operator|&
name|usize
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|imalloc_post_check
argument_list|(
name|ret
argument_list|,
name|tsd
argument_list|,
name|usize
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|UTRACE
argument_list|(
literal|0
argument_list|,
name|size
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|JEMALLOC_VALGRIND_MALLOC
argument_list|(
name|ret
operator|!=
name|NULL
argument_list|,
name|ret
argument_list|,
name|usize
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
modifier|*
name|imemalign_prof_sample
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|tctx
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|usize
operator|<=
name|SMALL_MAXCLASS
condition|)
block|{
name|assert
argument_list|(
name|sa2u
argument_list|(
name|LARGE_MINCLASS
argument_list|,
name|alignment
argument_list|)
operator|==
name|LARGE_MINCLASS
argument_list|)
expr_stmt|;
name|p
operator|=
name|ipalloc
argument_list|(
name|tsd
argument_list|,
name|LARGE_MINCLASS
argument_list|,
name|alignment
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|arena_prof_promoted
argument_list|(
name|p
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|=
name|ipalloc
argument_list|(
name|tsd
argument_list|,
name|usize
argument_list|,
name|alignment
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|void
modifier|*
name|imemalign_prof
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|size_t
name|usize
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|prof_tctx_t
modifier|*
name|tctx
decl_stmt|;
name|tctx
operator|=
name|prof_alloc_prep
argument_list|(
name|tsd
argument_list|,
name|usize
argument_list|,
name|prof_active_get_unlocked
argument_list|()
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|uintptr_t
operator|)
name|tctx
operator|!=
operator|(
name|uintptr_t
operator|)
literal|1U
argument_list|)
condition|)
name|p
operator|=
name|imemalign_prof_sample
argument_list|(
name|tsd
argument_list|,
name|alignment
argument_list|,
name|usize
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|ipalloc
argument_list|(
name|tsd
argument_list|,
name|usize
argument_list|,
name|alignment
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|p
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|prof_alloc_rollback
argument_list|(
name|tsd
argument_list|,
name|tctx
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|prof_malloc
argument_list|(
name|p
argument_list|,
name|usize
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_macro
name|JEMALLOC_ATTR
argument_list|(
argument|nonnull(
literal|1
argument|)
argument_list|)
end_macro

begin_function
specifier|static
name|int
name|imemalign
parameter_list|(
name|void
modifier|*
modifier|*
name|memptr
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|min_alignment
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|tsd_t
modifier|*
name|tsd
decl_stmt|;
name|size_t
name|usize
decl_stmt|;
name|void
modifier|*
name|result
decl_stmt|;
name|assert
argument_list|(
name|min_alignment
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|malloc_init
argument_list|()
argument_list|)
condition|)
block|{
name|result
operator|=
name|NULL
expr_stmt|;
goto|goto
name|label_oom
goto|;
block|}
name|tsd
operator|=
name|tsd_fetch
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
literal|1
expr_stmt|;
comment|/* Make sure that alignment is a large enough power of 2. */
if|if
condition|(
name|unlikely
argument_list|(
operator|(
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|&
name|alignment
operator|)
operator|!=
literal|0
operator|||
operator|(
name|alignment
operator|<
name|min_alignment
operator|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|config_xmalloc
operator|&&
name|unlikely
argument_list|(
name|opt_xmalloc
argument_list|)
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Error allocating "
literal|"aligned memory: invalid alignment\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|result
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
name|usize
operator|=
name|sa2u
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|usize
operator|==
literal|0
operator|||
name|usize
operator|>
name|HUGE_MAXCLASS
argument_list|)
condition|)
block|{
name|result
operator|=
name|NULL
expr_stmt|;
goto|goto
name|label_oom
goto|;
block|}
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
name|result
operator|=
name|imemalign_prof
argument_list|(
name|tsd
argument_list|,
name|alignment
argument_list|,
name|usize
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|ipalloc
argument_list|(
name|tsd
argument_list|,
name|usize
argument_list|,
name|alignment
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|result
operator|==
name|NULL
argument_list|)
condition|)
goto|goto
name|label_oom
goto|;
name|assert
argument_list|(
operator|(
operator|(
name|uintptr_t
operator|)
name|result
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|==
name|ZU
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|memptr
operator|=
name|result
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|label_return
label|:
if|if
condition|(
name|config_stats
operator|&&
name|likely
argument_list|(
name|result
operator|!=
name|NULL
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|usize
operator|==
name|isalloc
argument_list|(
name|result
argument_list|,
name|config_prof
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|tsd_thread_allocatedp_get
argument_list|(
name|tsd
argument_list|)
operator|+=
name|usize
expr_stmt|;
block|}
name|UTRACE
argument_list|(
literal|0
argument_list|,
name|size
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
name|label_oom
label|:
name|assert
argument_list|(
name|result
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_xmalloc
operator|&&
name|unlikely
argument_list|(
name|opt_xmalloc
argument_list|)
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Error allocating aligned memory: "
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
end_function

begin_decl_stmt
name|JEMALLOC_EXPORT
name|int
name|JEMALLOC_NOTHROW
name|JEMALLOC_ATTR
argument_list|(
name|nonnull
argument_list|(
literal|1
argument_list|)
argument_list|)
name|je_posix_memalign
argument_list|(
name|void
operator|*
operator|*
name|memptr
argument_list|,
name|size_t
name|alignment
argument_list|,
name|size_t
name|size
argument_list|)
block|{
name|int
name|ret
init|=
name|imemalign
argument_list|(
name|memptr
argument_list|,
name|alignment
argument_list|,
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|JEMALLOC_VALGRIND_MALLOC
argument_list|(
name|ret
operator|==
literal|0
argument_list|,
operator|*
name|memptr
argument_list|,
name|isalloc
argument_list|(
operator|*
name|memptr
argument_list|,
name|config_prof
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_decl_stmt

begin_function
name|JEMALLOC_EXPORT
name|JEMALLOC_ALLOCATOR
name|JEMALLOC_RESTRICT_RETURN
name|void
name|JEMALLOC_NOTHROW
modifier|*
name|JEMALLOC_ATTR
parameter_list|(
name|malloc
parameter_list|)
function|JEMALLOC_ALLOC_SIZE
parameter_list|(
function|2
end_function

begin_macro
unit|)
name|je_aligned_alloc
argument_list|(
argument|size_t alignment
argument_list|,
argument|size_t size
argument_list|)
end_macro

begin_block
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|err
operator|=
name|imemalign
argument_list|(
operator|&
name|ret
argument_list|,
name|alignment
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|ret
operator|=
name|NULL
expr_stmt|;
name|set_errno
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
name|JEMALLOC_VALGRIND_MALLOC
argument_list|(
name|err
operator|==
literal|0
argument_list|,
name|ret
argument_list|,
name|isalloc
argument_list|(
name|ret
argument_list|,
name|config_prof
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
modifier|*
name|icalloc_prof_sample
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|szind_t
name|ind
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|tctx
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|usize
operator|<=
name|SMALL_MAXCLASS
condition|)
block|{
name|szind_t
name|ind_large
init|=
name|size2index
argument_list|(
name|LARGE_MINCLASS
argument_list|)
decl_stmt|;
name|p
operator|=
name|icalloc
argument_list|(
name|tsd
argument_list|,
name|LARGE_MINCLASS
argument_list|,
name|ind_large
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|arena_prof_promoted
argument_list|(
name|p
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|=
name|icalloc
argument_list|(
name|tsd
argument_list|,
name|usize
argument_list|,
name|ind
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|void
modifier|*
name|icalloc_prof
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|szind_t
name|ind
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|prof_tctx_t
modifier|*
name|tctx
decl_stmt|;
name|tctx
operator|=
name|prof_alloc_prep
argument_list|(
name|tsd
argument_list|,
name|usize
argument_list|,
name|prof_active_get_unlocked
argument_list|()
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|uintptr_t
operator|)
name|tctx
operator|!=
operator|(
name|uintptr_t
operator|)
literal|1U
argument_list|)
condition|)
name|p
operator|=
name|icalloc_prof_sample
argument_list|(
name|tsd
argument_list|,
name|usize
argument_list|,
name|ind
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|icalloc
argument_list|(
name|tsd
argument_list|,
name|usize
argument_list|,
name|ind
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|p
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|prof_alloc_rollback
argument_list|(
name|tsd
argument_list|,
name|tctx
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|prof_malloc
argument_list|(
name|p
argument_list|,
name|usize
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_EXPORT
name|JEMALLOC_ALLOCATOR
name|JEMALLOC_RESTRICT_RETURN
name|void
name|JEMALLOC_NOTHROW
modifier|*
name|JEMALLOC_ATTR
parameter_list|(
name|malloc
parameter_list|)
function|JEMALLOC_ALLOC_SIZE2
parameter_list|(
function|1
operator|,
function|2
end_function

begin_macro
unit|)
name|je_calloc
argument_list|(
argument|size_t num
argument_list|,
argument|size_t size
argument_list|)
end_macro

begin_block
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|tsd_t
modifier|*
name|tsd
decl_stmt|;
name|size_t
name|num_size
decl_stmt|;
name|szind_t
name|ind
decl_stmt|;
name|size_t
name|usize
name|JEMALLOC_CC_SILENCE_INIT
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|malloc_init
argument_list|()
argument_list|)
condition|)
block|{
name|num_size
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
name|tsd
operator|=
name|tsd_fetch
argument_list|()
expr_stmt|;
name|num_size
operator|=
name|num
operator|*
name|size
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|num_size
operator|==
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|num
operator|==
literal|0
operator|||
name|size
operator|==
literal|0
condition|)
name|num_size
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
comment|/* 	 * Try to avoid division here.  We know that it isn't possible to 	 * overflow during multiplication if neither operand uses any of the 	 * most significant half of the bits in a size_t. 	 */
block|}
elseif|else
if|if
condition|(
name|unlikely
argument_list|(
operator|(
operator|(
name|num
operator||
name|size
operator|)
operator|&
operator|(
name|SIZE_T_MAX
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|<<
literal|2
operator|)
operator|)
operator|)
operator|&&
operator|(
name|num_size
operator|/
name|size
operator|!=
name|num
operator|)
argument_list|)
condition|)
block|{
comment|/* size_t overflow. */
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
name|ind
operator|=
name|size2index
argument_list|(
name|num_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ind
operator|>=
name|NSIZES
argument_list|)
condition|)
block|{
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
block|{
name|usize
operator|=
name|index2size
argument_list|(
name|ind
argument_list|)
expr_stmt|;
name|ret
operator|=
name|icalloc_prof
argument_list|(
name|tsd
argument_list|,
name|usize
argument_list|,
name|ind
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|config_stats
operator|||
operator|(
name|config_valgrind
operator|&&
name|unlikely
argument_list|(
name|in_valgrind
argument_list|)
operator|)
condition|)
name|usize
operator|=
name|index2size
argument_list|(
name|ind
argument_list|)
expr_stmt|;
name|ret
operator|=
name|icalloc
argument_list|(
name|tsd
argument_list|,
name|num_size
argument_list|,
name|ind
argument_list|)
expr_stmt|;
block|}
name|label_return
label|:
if|if
condition|(
name|unlikely
argument_list|(
name|ret
operator|==
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
name|config_xmalloc
operator|&&
name|unlikely
argument_list|(
name|opt_xmalloc
argument_list|)
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Error in calloc(): out of "
literal|"memory\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|set_errno
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config_stats
operator|&&
name|likely
argument_list|(
name|ret
operator|!=
name|NULL
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|usize
operator|==
name|isalloc
argument_list|(
name|ret
argument_list|,
name|config_prof
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|tsd_thread_allocatedp_get
argument_list|(
name|tsd
argument_list|)
operator|+=
name|usize
expr_stmt|;
block|}
name|UTRACE
argument_list|(
literal|0
argument_list|,
name|num_size
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|JEMALLOC_VALGRIND_MALLOC
argument_list|(
name|ret
operator|!=
name|NULL
argument_list|,
name|ret
argument_list|,
name|usize
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
modifier|*
name|irealloc_prof_sample
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|void
modifier|*
name|old_ptr
parameter_list|,
name|size_t
name|old_usize
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|tctx
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|usize
operator|<=
name|SMALL_MAXCLASS
condition|)
block|{
name|p
operator|=
name|iralloc
argument_list|(
name|tsd
argument_list|,
name|old_ptr
argument_list|,
name|old_usize
argument_list|,
name|LARGE_MINCLASS
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|arena_prof_promoted
argument_list|(
name|p
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|=
name|iralloc
argument_list|(
name|tsd
argument_list|,
name|old_ptr
argument_list|,
name|old_usize
argument_list|,
name|usize
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|void
modifier|*
name|irealloc_prof
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|void
modifier|*
name|old_ptr
parameter_list|,
name|size_t
name|old_usize
parameter_list|,
name|size_t
name|usize
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|bool
name|prof_active
decl_stmt|;
name|prof_tctx_t
modifier|*
name|old_tctx
decl_stmt|,
modifier|*
name|tctx
decl_stmt|;
name|prof_active
operator|=
name|prof_active_get_unlocked
argument_list|()
expr_stmt|;
name|old_tctx
operator|=
name|prof_tctx_get
argument_list|(
name|old_ptr
argument_list|)
expr_stmt|;
name|tctx
operator|=
name|prof_alloc_prep
argument_list|(
name|tsd
argument_list|,
name|usize
argument_list|,
name|prof_active
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|uintptr_t
operator|)
name|tctx
operator|!=
operator|(
name|uintptr_t
operator|)
literal|1U
argument_list|)
condition|)
name|p
operator|=
name|irealloc_prof_sample
argument_list|(
name|tsd
argument_list|,
name|old_ptr
argument_list|,
name|old_usize
argument_list|,
name|usize
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|iralloc
argument_list|(
name|tsd
argument_list|,
name|old_ptr
argument_list|,
name|old_usize
argument_list|,
name|usize
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|p
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|prof_alloc_rollback
argument_list|(
name|tsd
argument_list|,
name|tctx
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|prof_realloc
argument_list|(
name|tsd
argument_list|,
name|p
argument_list|,
name|usize
argument_list|,
name|tctx
argument_list|,
name|prof_active
argument_list|,
name|true
argument_list|,
name|old_ptr
argument_list|,
name|old_usize
argument_list|,
name|old_tctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_INLINE_C
name|void
name|ifree
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|,
name|bool
name|slow_path
parameter_list|)
block|{
name|size_t
name|usize
decl_stmt|;
name|UNUSED
name|size_t
name|rzsize
name|JEMALLOC_CC_SILENCE_INIT
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|malloc_initialized
argument_list|()
operator|||
name|IS_INITIALIZER
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
block|{
name|usize
operator|=
name|isalloc
argument_list|(
name|ptr
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
name|prof_free
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|config_stats
operator|||
name|config_valgrind
condition|)
name|usize
operator|=
name|isalloc
argument_list|(
name|ptr
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
operator|*
name|tsd_thread_deallocatedp_get
argument_list|(
name|tsd
argument_list|)
operator|+=
name|usize
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
operator|!
name|slow_path
argument_list|)
condition|)
name|iqalloc
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|tcache
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|config_valgrind
operator|&&
name|unlikely
argument_list|(
name|in_valgrind
argument_list|)
condition|)
name|rzsize
operator|=
name|p2rz
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|iqalloc
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|tcache
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|JEMALLOC_VALGRIND_FREE
argument_list|(
name|ptr
argument_list|,
name|rzsize
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|JEMALLOC_INLINE_C
name|void
name|isfree
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|)
block|{
name|UNUSED
name|size_t
name|rzsize
name|JEMALLOC_CC_SILENCE_INIT
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|malloc_initialized
argument_list|()
operator|||
name|IS_INITIALIZER
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
name|prof_free
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
operator|*
name|tsd_thread_deallocatedp_get
argument_list|(
name|tsd
argument_list|)
operator|+=
name|usize
expr_stmt|;
if|if
condition|(
name|config_valgrind
operator|&&
name|unlikely
argument_list|(
name|in_valgrind
argument_list|)
condition|)
name|rzsize
operator|=
name|p2rz
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|isqalloc
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|,
name|tcache
argument_list|)
expr_stmt|;
name|JEMALLOC_VALGRIND_FREE
argument_list|(
name|ptr
argument_list|,
name|rzsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|JEMALLOC_EXPORT
name|JEMALLOC_ALLOCATOR
name|JEMALLOC_RESTRICT_RETURN
name|void
name|JEMALLOC_NOTHROW
modifier|*
name|JEMALLOC_ALLOC_SIZE
argument_list|(
literal|2
argument_list|)
name|je_realloc
argument_list|(
name|void
operator|*
name|ptr
argument_list|,
name|size_t
name|size
argument_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|tsd_t
modifier|*
name|tsd
name|JEMALLOC_CC_SILENCE_INIT
parameter_list|(
name|NULL
parameter_list|)
function_decl|;
name|size_t
name|usize
name|JEMALLOC_CC_SILENCE_INIT
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|size_t
name|old_usize
init|=
literal|0
decl_stmt|;
name|UNUSED
name|size_t
name|old_rzsize
name|JEMALLOC_CC_SILENCE_INIT
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|size
operator|==
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
comment|/* realloc(ptr, 0) is equivalent to free(ptr). */
name|UTRACE
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tsd
operator|=
name|tsd_fetch
argument_list|()
expr_stmt|;
name|ifree
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|tcache_get
argument_list|(
name|tsd
argument_list|,
name|false
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|size
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|likely
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|malloc_initialized
argument_list|()
operator|||
name|IS_INITIALIZER
argument_list|)
expr_stmt|;
name|malloc_thread_init
argument_list|()
expr_stmt|;
name|tsd
operator|=
name|tsd_fetch
argument_list|()
expr_stmt|;
name|old_usize
operator|=
name|isalloc
argument_list|(
name|ptr
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_valgrind
operator|&&
name|unlikely
argument_list|(
name|in_valgrind
argument_list|)
condition|)
name|old_rzsize
operator|=
name|config_prof
condition|?
name|p2rz
argument_list|(
name|ptr
argument_list|)
else|:
name|u2rz
argument_list|(
name|old_usize
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
block|{
name|usize
operator|=
name|s2u
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|ret
operator|=
name|unlikely
argument_list|(
name|usize
operator|==
literal|0
operator|||
name|usize
operator|>
name|HUGE_MAXCLASS
argument_list|)
condition|?
name|NULL
else|:
name|irealloc_prof
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|config_stats
operator|||
operator|(
name|config_valgrind
operator|&&
name|unlikely
argument_list|(
name|in_valgrind
argument_list|)
operator|)
condition|)
name|usize
operator|=
name|s2u
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|ret
operator|=
name|iralloc
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* realloc(NULL, size) is equivalent to malloc(size). */
if|if
condition|(
name|likely
argument_list|(
operator|!
name|malloc_slow
argument_list|)
condition|)
name|ret
operator|=
name|imalloc_body
argument_list|(
name|size
argument_list|,
operator|&
name|tsd
argument_list|,
operator|&
name|usize
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|imalloc_body
argument_list|(
name|size
argument_list|,
operator|&
name|tsd
argument_list|,
operator|&
name|usize
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|ret
operator|==
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
name|config_xmalloc
operator|&&
name|unlikely
argument_list|(
name|opt_xmalloc
argument_list|)
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Error in realloc(): "
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|set_errno
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config_stats
operator|&&
name|likely
argument_list|(
name|ret
operator|!=
name|NULL
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|usize
operator|==
name|isalloc
argument_list|(
name|ret
argument_list|,
name|config_prof
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|tsd_thread_allocatedp_get
argument_list|(
name|tsd
argument_list|)
operator|+=
name|usize
expr_stmt|;
operator|*
name|tsd_thread_deallocatedp_get
argument_list|(
name|tsd
argument_list|)
operator|+=
name|old_usize
expr_stmt|;
block|}
name|UTRACE
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|JEMALLOC_VALGRIND_REALLOC
argument_list|(
name|true
argument_list|,
name|ret
argument_list|,
name|usize
argument_list|,
name|true
argument_list|,
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|old_rzsize
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_decl_stmt

begin_function
name|JEMALLOC_EXPORT
name|void
name|JEMALLOC_NOTHROW
name|je_free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|UTRACE
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
condition|)
block|{
name|tsd_t
modifier|*
name|tsd
init|=
name|tsd_fetch
argument_list|()
decl_stmt|;
if|if
condition|(
name|likely
argument_list|(
operator|!
name|malloc_slow
argument_list|)
condition|)
name|ifree
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|tcache_get
argument_list|(
name|tsd
argument_list|,
name|false
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
name|ifree
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|tcache_get
argument_list|(
name|tsd
argument_list|,
name|false
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * End malloc(3)-compatible functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin non-standard override functions.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_OVERRIDE_MEMALIGN
end_ifdef

begin_function
name|JEMALLOC_EXPORT
name|JEMALLOC_ALLOCATOR
name|JEMALLOC_RESTRICT_RETURN
name|void
name|JEMALLOC_NOTHROW
modifier|*
name|JEMALLOC_ATTR
parameter_list|(
name|malloc
parameter_list|)
function|je_memalign
parameter_list|(
name|size_t
name|alignment
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
name|JEMALLOC_CC_SILENCE_INIT
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|imemalign
argument_list|(
operator|&
name|ret
argument_list|,
name|alignment
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
argument_list|)
condition|)
name|ret
operator|=
name|NULL
expr_stmt|;
name|JEMALLOC_VALGRIND_MALLOC
argument_list|(
name|ret
operator|!=
name|NULL
argument_list|,
name|ret
argument_list|,
name|size
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_OVERRIDE_VALLOC
end_ifdef

begin_function
name|JEMALLOC_EXPORT
name|JEMALLOC_ALLOCATOR
name|JEMALLOC_RESTRICT_RETURN
name|void
name|JEMALLOC_NOTHROW
modifier|*
name|JEMALLOC_ATTR
parameter_list|(
name|malloc
parameter_list|)
function|je_valloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
name|JEMALLOC_CC_SILENCE_INIT
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|imemalign
argument_list|(
operator|&
name|ret
argument_list|,
name|PAGE
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
argument_list|)
condition|)
name|ret
operator|=
name|NULL
expr_stmt|;
name|JEMALLOC_VALGRIND_MALLOC
argument_list|(
name|ret
operator|!=
name|NULL
argument_list|,
name|ret
argument_list|,
name|size
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * is_malloc(je_malloc) is some macro magic to detect if jemalloc_defs.h has  * #define je_malloc malloc  */
end_comment

begin_define
define|#
directive|define
name|malloc_is_malloc
value|1
end_define

begin_define
define|#
directive|define
name|is_malloc_
parameter_list|(
name|a
parameter_list|)
value|malloc_is_ ## a
end_define

begin_define
define|#
directive|define
name|is_malloc
parameter_list|(
name|a
parameter_list|)
value|is_malloc_(a)
end_define

begin_if
if|#
directive|if
operator|(
operator|(
name|is_malloc
argument_list|(
name|je_malloc
argument_list|)
operator|==
literal|1
operator|)
operator|&&
name|defined
argument_list|(
name|JEMALLOC_GLIBC_MALLOC_HOOK
argument_list|)
operator|)
end_if

begin_comment
comment|/*  * glibc provides the RTLD_DEEPBIND flag for dlopen which can make it possible  * to inconsistently reference libc's malloc(3)-compatible functions  * (https://bugzilla.mozilla.org/show_bug.cgi?id=493541).  *  * These definitions interpose hooks in glibc.  The functions are actually  * passed an extra argument for the caller return address, which will be  * ignored.  */
end_comment

begin_function_decl
name|JEMALLOC_EXPORT
name|void
function_decl|(
modifier|*
name|__free_hook
function_decl|)
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
init|=
name|je_free
function_decl|;
end_function_decl

begin_function_decl
name|JEMALLOC_EXPORT
name|void
modifier|*
function_decl|(
modifier|*
name|__malloc_hook
function_decl|)
parameter_list|(
name|size_t
name|size
parameter_list|)
init|=
name|je_malloc
function_decl|;
end_function_decl

begin_function_decl
name|JEMALLOC_EXPORT
name|void
modifier|*
function_decl|(
modifier|*
name|__realloc_hook
function_decl|)
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
init|=
name|je_realloc
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_GLIBC_MEMALIGN_HOOK
end_ifdef

begin_function_decl
name|JEMALLOC_EXPORT
name|void
modifier|*
function_decl|(
modifier|*
name|__memalign_hook
function_decl|)
parameter_list|(
name|size_t
name|alignment
parameter_list|,
name|size_t
name|size
parameter_list|)
init|=
name|je_memalign
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * End non-standard override functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin non-standard functions.  */
end_comment

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|bool
name|imallocx_flags_decode_hard
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|,
name|size_t
modifier|*
name|usize
parameter_list|,
name|size_t
modifier|*
name|alignment
parameter_list|,
name|bool
modifier|*
name|zero
parameter_list|,
name|tcache_t
modifier|*
modifier|*
name|tcache
parameter_list|,
name|arena_t
modifier|*
modifier|*
name|arena
parameter_list|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|MALLOCX_LG_ALIGN_MASK
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|alignment
operator|=
literal|0
expr_stmt|;
operator|*
name|usize
operator|=
name|s2u
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|alignment
operator|=
name|MALLOCX_ALIGN_GET_SPECIFIED
argument_list|(
name|flags
argument_list|)
expr_stmt|;
operator|*
name|usize
operator|=
name|sa2u
argument_list|(
name|size
argument_list|,
operator|*
name|alignment
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
operator|*
name|usize
operator|==
literal|0
operator|||
operator|*
name|usize
operator|>
name|HUGE_MAXCLASS
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
operator|*
name|zero
operator|=
name|MALLOCX_ZERO_GET
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|MALLOCX_TCACHE_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|MALLOCX_TCACHE_MASK
operator|)
operator|==
name|MALLOCX_TCACHE_NONE
condition|)
operator|*
name|tcache
operator|=
name|NULL
expr_stmt|;
else|else
operator|*
name|tcache
operator|=
name|tcaches_get
argument_list|(
name|tsd
argument_list|,
name|MALLOCX_TCACHE_GET
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|tcache
operator|=
name|tcache_get
argument_list|(
name|tsd
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|MALLOCX_ARENA_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|arena_ind
init|=
name|MALLOCX_ARENA_GET
argument_list|(
name|flags
argument_list|)
decl_stmt|;
operator|*
name|arena
operator|=
name|arena_get
argument_list|(
name|arena_ind
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|*
name|arena
operator|==
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
block|}
else|else
operator|*
name|arena
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|bool
name|imallocx_flags_decode
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|,
name|size_t
modifier|*
name|usize
parameter_list|,
name|size_t
modifier|*
name|alignment
parameter_list|,
name|bool
modifier|*
name|zero
parameter_list|,
name|tcache_t
modifier|*
modifier|*
name|tcache
parameter_list|,
name|arena_t
modifier|*
modifier|*
name|arena
parameter_list|)
block|{
if|if
condition|(
name|likely
argument_list|(
name|flags
operator|==
literal|0
argument_list|)
condition|)
block|{
operator|*
name|usize
operator|=
name|s2u
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|*
name|usize
operator|==
literal|0
operator|||
operator|*
name|usize
operator|>
name|HUGE_MAXCLASS
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
operator|*
name|alignment
operator|=
literal|0
expr_stmt|;
operator|*
name|zero
operator|=
name|false
expr_stmt|;
operator|*
name|tcache
operator|=
name|tcache_get
argument_list|(
name|tsd
argument_list|,
name|true
argument_list|)
expr_stmt|;
operator|*
name|arena
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|imallocx_flags_decode_hard
argument_list|(
name|tsd
argument_list|,
name|size
argument_list|,
name|flags
argument_list|,
name|usize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|void
modifier|*
name|imallocx_flags
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
name|zero
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|szind_t
name|ind
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|alignment
operator|!=
literal|0
argument_list|)
condition|)
return|return
operator|(
name|ipalloct
argument_list|(
name|tsd
argument_list|,
name|usize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|)
operator|)
return|;
name|ind
operator|=
name|size2index
argument_list|(
name|usize
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ind
operator|<
name|NSIZES
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|zero
argument_list|)
condition|)
return|return
operator|(
name|icalloct
argument_list|(
name|tsd
argument_list|,
name|usize
argument_list|,
name|ind
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|)
operator|)
return|;
return|return
operator|(
name|imalloct
argument_list|(
name|tsd
argument_list|,
name|usize
argument_list|,
name|ind
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|imallocx_prof_sample
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
name|zero
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|usize
operator|<=
name|SMALL_MAXCLASS
condition|)
block|{
name|assert
argument_list|(
operator|(
operator|(
name|alignment
operator|==
literal|0
operator|)
condition|?
name|s2u
argument_list|(
name|LARGE_MINCLASS
argument_list|)
else|:
name|sa2u
argument_list|(
name|LARGE_MINCLASS
argument_list|,
name|alignment
argument_list|)
operator|)
operator|==
name|LARGE_MINCLASS
argument_list|)
expr_stmt|;
name|p
operator|=
name|imallocx_flags
argument_list|(
name|tsd
argument_list|,
name|LARGE_MINCLASS
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|arena_prof_promoted
argument_list|(
name|p
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|=
name|imallocx_flags
argument_list|(
name|tsd
argument_list|,
name|usize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|void
modifier|*
name|imallocx_prof
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|,
name|size_t
modifier|*
name|usize
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|size_t
name|alignment
decl_stmt|;
name|bool
name|zero
decl_stmt|;
name|tcache_t
modifier|*
name|tcache
decl_stmt|;
name|arena_t
modifier|*
name|arena
decl_stmt|;
name|prof_tctx_t
modifier|*
name|tctx
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|imallocx_flags_decode
argument_list|(
name|tsd
argument_list|,
name|size
argument_list|,
name|flags
argument_list|,
name|usize
argument_list|,
operator|&
name|alignment
argument_list|,
operator|&
name|zero
argument_list|,
operator|&
name|tcache
argument_list|,
operator|&
name|arena
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|tctx
operator|=
name|prof_alloc_prep
argument_list|(
name|tsd
argument_list|,
operator|*
name|usize
argument_list|,
name|prof_active_get_unlocked
argument_list|()
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
operator|(
name|uintptr_t
operator|)
name|tctx
operator|==
operator|(
name|uintptr_t
operator|)
literal|1U
argument_list|)
condition|)
name|p
operator|=
name|imallocx_flags
argument_list|(
name|tsd
argument_list|,
operator|*
name|usize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|tctx
operator|>
operator|(
name|uintptr_t
operator|)
literal|1U
condition|)
block|{
name|p
operator|=
name|imallocx_prof_sample
argument_list|(
name|tsd
argument_list|,
operator|*
name|usize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|p
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|prof_alloc_rollback
argument_list|(
name|tsd
argument_list|,
name|tctx
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|prof_malloc
argument_list|(
name|p
argument_list|,
operator|*
name|usize
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|alignment
operator|==
literal|0
operator|||
operator|(
operator|(
name|uintptr_t
operator|)
name|p
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|==
name|ZU
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|void
modifier|*
name|imallocx_no_prof
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|,
name|size_t
modifier|*
name|usize
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|size_t
name|alignment
decl_stmt|;
name|bool
name|zero
decl_stmt|;
name|tcache_t
modifier|*
name|tcache
decl_stmt|;
name|arena_t
modifier|*
name|arena
decl_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|flags
operator|==
literal|0
argument_list|)
condition|)
block|{
name|szind_t
name|ind
init|=
name|size2index
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ind
operator|>=
name|NSIZES
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|config_stats
operator|||
operator|(
name|config_valgrind
operator|&&
name|unlikely
argument_list|(
name|in_valgrind
argument_list|)
operator|)
condition|)
block|{
operator|*
name|usize
operator|=
name|index2size
argument_list|(
name|ind
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|*
name|usize
operator|>
literal|0
operator|&&
operator|*
name|usize
operator|<=
name|HUGE_MAXCLASS
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|imalloc
argument_list|(
name|tsd
argument_list|,
name|size
argument_list|,
name|ind
argument_list|,
name|true
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|imallocx_flags_decode_hard
argument_list|(
name|tsd
argument_list|,
name|size
argument_list|,
name|flags
argument_list|,
name|usize
argument_list|,
operator|&
name|alignment
argument_list|,
operator|&
name|zero
argument_list|,
operator|&
name|tcache
argument_list|,
operator|&
name|arena
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|p
operator|=
name|imallocx_flags
argument_list|(
name|tsd
argument_list|,
operator|*
name|usize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|alignment
operator|==
literal|0
operator|||
operator|(
operator|(
name|uintptr_t
operator|)
name|p
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|==
name|ZU
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_EXPORT
name|JEMALLOC_ALLOCATOR
name|JEMALLOC_RESTRICT_RETURN
name|void
name|JEMALLOC_NOTHROW
modifier|*
name|JEMALLOC_ATTR
parameter_list|(
name|malloc
parameter_list|)
function|JEMALLOC_ALLOC_SIZE
parameter_list|(
function|1
end_function

begin_macro
unit|)
name|je_mallocx
argument_list|(
argument|size_t size
argument_list|,
argument|int flags
argument_list|)
end_macro

begin_block
block|{
name|tsd_t
modifier|*
name|tsd
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
name|size_t
name|usize
decl_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|malloc_init
argument_list|()
argument_list|)
condition|)
goto|goto
name|label_oom
goto|;
name|tsd
operator|=
name|tsd_fetch
argument_list|()
expr_stmt|;
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
name|p
operator|=
name|imallocx_prof
argument_list|(
name|tsd
argument_list|,
name|size
argument_list|,
name|flags
argument_list|,
operator|&
name|usize
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|imallocx_no_prof
argument_list|(
name|tsd
argument_list|,
name|size
argument_list|,
name|flags
argument_list|,
operator|&
name|usize
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|p
operator|==
name|NULL
argument_list|)
condition|)
goto|goto
name|label_oom
goto|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|assert
argument_list|(
name|usize
operator|==
name|isalloc
argument_list|(
name|p
argument_list|,
name|config_prof
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|tsd_thread_allocatedp_get
argument_list|(
name|tsd
argument_list|)
operator|+=
name|usize
expr_stmt|;
block|}
name|UTRACE
argument_list|(
literal|0
argument_list|,
name|size
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|JEMALLOC_VALGRIND_MALLOC
argument_list|(
name|true
argument_list|,
name|p
argument_list|,
name|usize
argument_list|,
name|MALLOCX_ZERO_GET
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
name|label_oom
label|:
if|if
condition|(
name|config_xmalloc
operator|&&
name|unlikely
argument_list|(
name|opt_xmalloc
argument_list|)
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Error in mallocx(): out of memory\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|UTRACE
argument_list|(
literal|0
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
modifier|*
name|irallocx_prof_sample
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|void
modifier|*
name|old_ptr
parameter_list|,
name|size_t
name|old_usize
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
name|zero
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|tctx
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|usize
operator|<=
name|SMALL_MAXCLASS
condition|)
block|{
name|p
operator|=
name|iralloct
argument_list|(
name|tsd
argument_list|,
name|old_ptr
argument_list|,
name|old_usize
argument_list|,
name|LARGE_MINCLASS
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|arena_prof_promoted
argument_list|(
name|p
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|iralloct
argument_list|(
name|tsd
argument_list|,
name|old_ptr
argument_list|,
name|old_usize
argument_list|,
name|usize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|void
modifier|*
name|irallocx_prof
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|void
modifier|*
name|old_ptr
parameter_list|,
name|size_t
name|old_usize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|size_t
modifier|*
name|usize
parameter_list|,
name|bool
name|zero
parameter_list|,
name|tcache_t
modifier|*
name|tcache
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|bool
name|prof_active
decl_stmt|;
name|prof_tctx_t
modifier|*
name|old_tctx
decl_stmt|,
modifier|*
name|tctx
decl_stmt|;
name|prof_active
operator|=
name|prof_active_get_unlocked
argument_list|()
expr_stmt|;
name|old_tctx
operator|=
name|prof_tctx_get
argument_list|(
name|old_ptr
argument_list|)
expr_stmt|;
name|tctx
operator|=
name|prof_alloc_prep
argument_list|(
name|tsd
argument_list|,
operator|*
name|usize
argument_list|,
name|prof_active
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|uintptr_t
operator|)
name|tctx
operator|!=
operator|(
name|uintptr_t
operator|)
literal|1U
argument_list|)
condition|)
block|{
name|p
operator|=
name|irallocx_prof_sample
argument_list|(
name|tsd
argument_list|,
name|old_ptr
argument_list|,
name|old_usize
argument_list|,
operator|*
name|usize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|iralloct
argument_list|(
name|tsd
argument_list|,
name|old_ptr
argument_list|,
name|old_usize
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|p
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|prof_alloc_rollback
argument_list|(
name|tsd
argument_list|,
name|tctx
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|==
name|old_ptr
operator|&&
name|alignment
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The allocation did not move, so it is possible that the size 		 * class is smaller than would guarantee the requested 		 * alignment, and that the alignment constraint was 		 * serendipitously satisfied.  Additionally, old_usize may not 		 * be the same as the current usize because of in-place large 		 * reallocation.  Therefore, query the actual value of usize. 		 */
operator|*
name|usize
operator|=
name|isalloc
argument_list|(
name|p
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
block|}
name|prof_realloc
argument_list|(
name|tsd
argument_list|,
name|p
argument_list|,
operator|*
name|usize
argument_list|,
name|tctx
argument_list|,
name|prof_active
argument_list|,
name|true
argument_list|,
name|old_ptr
argument_list|,
name|old_usize
argument_list|,
name|old_tctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|JEMALLOC_EXPORT
name|JEMALLOC_ALLOCATOR
name|JEMALLOC_RESTRICT_RETURN
name|void
name|JEMALLOC_NOTHROW
modifier|*
name|JEMALLOC_ALLOC_SIZE
argument_list|(
literal|2
argument_list|)
name|je_rallocx
argument_list|(
name|void
operator|*
name|ptr
argument_list|,
name|size_t
name|size
argument_list|,
name|int
name|flags
argument_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|tsd_t
modifier|*
name|tsd
decl_stmt|;
name|size_t
name|usize
decl_stmt|;
name|size_t
name|old_usize
decl_stmt|;
name|UNUSED
name|size_t
name|old_rzsize
name|JEMALLOC_CC_SILENCE_INIT
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|size_t
name|alignment
init|=
name|MALLOCX_ALIGN_GET
argument_list|(
name|flags
argument_list|)
decl_stmt|;
name|bool
name|zero
init|=
name|flags
operator|&
name|MALLOCX_ZERO
decl_stmt|;
name|arena_t
modifier|*
name|arena
decl_stmt|;
name|tcache_t
modifier|*
name|tcache
decl_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|malloc_initialized
argument_list|()
operator|||
name|IS_INITIALIZER
argument_list|)
expr_stmt|;
name|malloc_thread_init
argument_list|()
expr_stmt|;
name|tsd
operator|=
name|tsd_fetch
argument_list|()
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|flags
operator|&
name|MALLOCX_ARENA_MASK
operator|)
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|unsigned
name|arena_ind
init|=
name|MALLOCX_ARENA_GET
argument_list|(
name|flags
argument_list|)
decl_stmt|;
name|arena
operator|=
name|arena_get
argument_list|(
name|arena_ind
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|arena
operator|==
name|NULL
argument_list|)
condition|)
goto|goto
name|label_oom
goto|;
block|}
else|else
name|arena
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|flags
operator|&
name|MALLOCX_TCACHE_MASK
operator|)
operator|!=
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|MALLOCX_TCACHE_MASK
operator|)
operator|==
name|MALLOCX_TCACHE_NONE
condition|)
name|tcache
operator|=
name|NULL
expr_stmt|;
else|else
name|tcache
operator|=
name|tcaches_get
argument_list|(
name|tsd
argument_list|,
name|MALLOCX_TCACHE_GET
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|tcache
operator|=
name|tcache_get
argument_list|(
name|tsd
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|old_usize
operator|=
name|isalloc
argument_list|(
name|ptr
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_valgrind
operator|&&
name|unlikely
argument_list|(
name|in_valgrind
argument_list|)
condition|)
name|old_rzsize
operator|=
name|u2rz
argument_list|(
name|old_usize
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
block|{
name|usize
operator|=
operator|(
name|alignment
operator|==
literal|0
operator|)
condition|?
name|s2u
argument_list|(
name|size
argument_list|)
else|:
name|sa2u
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|usize
operator|==
literal|0
operator|||
name|usize
operator|>
name|HUGE_MAXCLASS
argument_list|)
condition|)
goto|goto
name|label_oom
goto|;
name|p
operator|=
name|irallocx_prof
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|,
operator|&
name|usize
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|p
operator|==
name|NULL
argument_list|)
condition|)
goto|goto
name|label_oom
goto|;
block|}
else|else
block|{
name|p
operator|=
name|iralloct
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|tcache
argument_list|,
name|arena
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|p
operator|==
name|NULL
argument_list|)
condition|)
goto|goto
name|label_oom
goto|;
if|if
condition|(
name|config_stats
operator|||
operator|(
name|config_valgrind
operator|&&
name|unlikely
argument_list|(
name|in_valgrind
argument_list|)
operator|)
condition|)
name|usize
operator|=
name|isalloc
argument_list|(
name|p
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|alignment
operator|==
literal|0
operator|||
operator|(
operator|(
name|uintptr_t
operator|)
name|p
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|==
name|ZU
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
operator|*
name|tsd_thread_allocatedp_get
argument_list|(
name|tsd
argument_list|)
operator|+=
name|usize
expr_stmt|;
operator|*
name|tsd_thread_deallocatedp_get
argument_list|(
name|tsd
argument_list|)
operator|+=
name|old_usize
expr_stmt|;
block|}
name|UTRACE
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|JEMALLOC_VALGRIND_REALLOC
argument_list|(
name|true
argument_list|,
name|p
argument_list|,
name|usize
argument_list|,
name|false
argument_list|,
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|old_rzsize
argument_list|,
name|false
argument_list|,
name|zero
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
name|label_oom
label|:
if|if
condition|(
name|config_xmalloc
operator|&&
name|unlikely
argument_list|(
name|opt_xmalloc
argument_list|)
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Error in rallocx(): out of memory\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|UTRACE
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_decl_stmt

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|size_t
name|ixallocx_helper
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|old_usize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|extra
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|size_t
name|usize
decl_stmt|;
if|if
condition|(
name|ixalloc
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|size
argument_list|,
name|extra
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|)
condition|)
return|return
operator|(
name|old_usize
operator|)
return|;
name|usize
operator|=
name|isalloc
argument_list|(
name|ptr
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
return|return
operator|(
name|usize
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|ixallocx_prof_sample
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|old_usize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|extra
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
name|zero
parameter_list|,
name|prof_tctx_t
modifier|*
name|tctx
parameter_list|)
block|{
name|size_t
name|usize
decl_stmt|;
if|if
condition|(
name|tctx
operator|==
name|NULL
condition|)
return|return
operator|(
name|old_usize
operator|)
return|;
name|usize
operator|=
name|ixallocx_helper
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|size
argument_list|,
name|extra
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|)
expr_stmt|;
return|return
operator|(
name|usize
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|size_t
name|ixallocx_prof
parameter_list|(
name|tsd_t
modifier|*
name|tsd
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|old_usize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|extra
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|size_t
name|usize_max
decl_stmt|,
name|usize
decl_stmt|;
name|bool
name|prof_active
decl_stmt|;
name|prof_tctx_t
modifier|*
name|old_tctx
decl_stmt|,
modifier|*
name|tctx
decl_stmt|;
name|prof_active
operator|=
name|prof_active_get_unlocked
argument_list|()
expr_stmt|;
name|old_tctx
operator|=
name|prof_tctx_get
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
comment|/* 	 * usize isn't knowable before ixalloc() returns when extra is non-zero. 	 * Therefore, compute its maximum possible value and use that in 	 * prof_alloc_prep() to decide whether to capture a backtrace. 	 * prof_realloc() will use the actual usize to decide whether to sample. 	 */
if|if
condition|(
name|alignment
operator|==
literal|0
condition|)
block|{
name|usize_max
operator|=
name|s2u
argument_list|(
name|size
operator|+
name|extra
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|usize_max
operator|>
literal|0
operator|&&
name|usize_max
operator|<=
name|HUGE_MAXCLASS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usize_max
operator|=
name|sa2u
argument_list|(
name|size
operator|+
name|extra
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|usize_max
operator|==
literal|0
operator|||
name|usize_max
operator|>
name|HUGE_MAXCLASS
argument_list|)
condition|)
block|{
comment|/* 			 * usize_max is out of range, and chances are that 			 * allocation will fail, but use the maximum possible 			 * value and carry on with prof_alloc_prep(), just in 			 * case allocation succeeds. 			 */
name|usize_max
operator|=
name|HUGE_MAXCLASS
expr_stmt|;
block|}
block|}
name|tctx
operator|=
name|prof_alloc_prep
argument_list|(
name|tsd
argument_list|,
name|usize_max
argument_list|,
name|prof_active
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|uintptr_t
operator|)
name|tctx
operator|!=
operator|(
name|uintptr_t
operator|)
literal|1U
argument_list|)
condition|)
block|{
name|usize
operator|=
name|ixallocx_prof_sample
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|size
argument_list|,
name|extra
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usize
operator|=
name|ixallocx_helper
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|size
argument_list|,
name|extra
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usize
operator|==
name|old_usize
condition|)
block|{
name|prof_alloc_rollback
argument_list|(
name|tsd
argument_list|,
name|tctx
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
operator|(
name|usize
operator|)
return|;
block|}
name|prof_realloc
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|,
name|tctx
argument_list|,
name|prof_active
argument_list|,
name|false
argument_list|,
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|old_tctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|usize
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_EXPORT
name|size_t
name|JEMALLOC_NOTHROW
name|je_xallocx
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|extra
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tsd_t
modifier|*
name|tsd
decl_stmt|;
name|size_t
name|usize
decl_stmt|,
name|old_usize
decl_stmt|;
name|UNUSED
name|size_t
name|old_rzsize
name|JEMALLOC_CC_SILENCE_INIT
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|size_t
name|alignment
init|=
name|MALLOCX_ALIGN_GET
argument_list|(
name|flags
argument_list|)
decl_stmt|;
name|bool
name|zero
init|=
name|flags
operator|&
name|MALLOCX_ZERO
decl_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|SIZE_T_MAX
operator|-
name|size
operator|>=
name|extra
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|malloc_initialized
argument_list|()
operator|||
name|IS_INITIALIZER
argument_list|)
expr_stmt|;
name|malloc_thread_init
argument_list|()
expr_stmt|;
name|tsd
operator|=
name|tsd_fetch
argument_list|()
expr_stmt|;
name|old_usize
operator|=
name|isalloc
argument_list|(
name|ptr
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
comment|/* 	 * The API explicitly absolves itself of protecting against (size + 	 * extra) numerical overflow, but we may need to clamp extra to avoid 	 * exceeding HUGE_MAXCLASS. 	 * 	 * Ordinarily, size limit checking is handled deeper down, but here we 	 * have to check as part of (size + extra) clamping, since we need the 	 * clamped value in the above helper functions. 	 */
if|if
condition|(
name|unlikely
argument_list|(
name|size
operator|>
name|HUGE_MAXCLASS
argument_list|)
condition|)
block|{
name|usize
operator|=
name|old_usize
expr_stmt|;
goto|goto
name|label_not_resized
goto|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|HUGE_MAXCLASS
operator|-
name|size
operator|<
name|extra
argument_list|)
condition|)
name|extra
operator|=
name|HUGE_MAXCLASS
operator|-
name|size
expr_stmt|;
if|if
condition|(
name|config_valgrind
operator|&&
name|unlikely
argument_list|(
name|in_valgrind
argument_list|)
condition|)
name|old_rzsize
operator|=
name|u2rz
argument_list|(
name|old_usize
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
block|{
name|usize
operator|=
name|ixallocx_prof
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|size
argument_list|,
name|extra
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usize
operator|=
name|ixallocx_helper
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|size
argument_list|,
name|extra
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|usize
operator|==
name|old_usize
argument_list|)
condition|)
goto|goto
name|label_not_resized
goto|;
if|if
condition|(
name|config_stats
condition|)
block|{
operator|*
name|tsd_thread_allocatedp_get
argument_list|(
name|tsd
argument_list|)
operator|+=
name|usize
expr_stmt|;
operator|*
name|tsd_thread_deallocatedp_get
argument_list|(
name|tsd
argument_list|)
operator|+=
name|old_usize
expr_stmt|;
block|}
name|JEMALLOC_VALGRIND_REALLOC
argument_list|(
name|false
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|,
name|false
argument_list|,
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|old_rzsize
argument_list|,
name|false
argument_list|,
name|zero
argument_list|)
expr_stmt|;
name|label_not_resized
label|:
name|UTRACE
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|usize
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_EXPORT
name|size_t
name|JEMALLOC_NOTHROW
name|JEMALLOC_ATTR
parameter_list|(
name|pure
parameter_list|)
function|je_sallocx
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|size_t
name|usize
decl_stmt|;
name|assert
argument_list|(
name|malloc_initialized
argument_list|()
operator|||
name|IS_INITIALIZER
argument_list|)
expr_stmt|;
name|malloc_thread_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|config_ivsalloc
condition|)
name|usize
operator|=
name|ivsalloc
argument_list|(
name|ptr
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
else|else
name|usize
operator|=
name|isalloc
argument_list|(
name|ptr
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
return|return
operator|(
name|usize
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_EXPORT
name|void
name|JEMALLOC_NOTHROW
name|je_dallocx
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tsd_t
modifier|*
name|tsd
decl_stmt|;
name|tcache_t
modifier|*
name|tcache
decl_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|malloc_initialized
argument_list|()
operator|||
name|IS_INITIALIZER
argument_list|)
expr_stmt|;
name|tsd
operator|=
name|tsd_fetch
argument_list|()
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|flags
operator|&
name|MALLOCX_TCACHE_MASK
operator|)
operator|!=
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|MALLOCX_TCACHE_MASK
operator|)
operator|==
name|MALLOCX_TCACHE_NONE
condition|)
name|tcache
operator|=
name|NULL
expr_stmt|;
else|else
name|tcache
operator|=
name|tcaches_get
argument_list|(
name|tsd
argument_list|,
name|MALLOCX_TCACHE_GET
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|tcache
operator|=
name|tcache_get
argument_list|(
name|tsd
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|UTRACE
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|tsd_fetch
argument_list|()
argument_list|,
name|ptr
argument_list|,
name|tcache
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|size_t
name|inallocx
parameter_list|(
name|size_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|size_t
name|usize
decl_stmt|;
if|if
condition|(
name|likely
argument_list|(
operator|(
name|flags
operator|&
name|MALLOCX_LG_ALIGN_MASK
operator|)
operator|==
literal|0
argument_list|)
condition|)
name|usize
operator|=
name|s2u
argument_list|(
name|size
argument_list|)
expr_stmt|;
else|else
name|usize
operator|=
name|sa2u
argument_list|(
name|size
argument_list|,
name|MALLOCX_ALIGN_GET_SPECIFIED
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|usize
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_EXPORT
name|void
name|JEMALLOC_NOTHROW
name|je_sdallocx
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tsd_t
modifier|*
name|tsd
decl_stmt|;
name|tcache_t
modifier|*
name|tcache
decl_stmt|;
name|size_t
name|usize
decl_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|malloc_initialized
argument_list|()
operator|||
name|IS_INITIALIZER
argument_list|)
expr_stmt|;
name|usize
operator|=
name|inallocx
argument_list|(
name|size
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|usize
operator|==
name|isalloc
argument_list|(
name|ptr
argument_list|,
name|config_prof
argument_list|)
argument_list|)
expr_stmt|;
name|tsd
operator|=
name|tsd_fetch
argument_list|()
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|flags
operator|&
name|MALLOCX_TCACHE_MASK
operator|)
operator|!=
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|MALLOCX_TCACHE_MASK
operator|)
operator|==
name|MALLOCX_TCACHE_NONE
condition|)
name|tcache
operator|=
name|NULL
expr_stmt|;
else|else
name|tcache
operator|=
name|tcaches_get
argument_list|(
name|tsd
argument_list|,
name|MALLOCX_TCACHE_GET
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|tcache
operator|=
name|tcache_get
argument_list|(
name|tsd
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|UTRACE
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|isfree
argument_list|(
name|tsd
argument_list|,
name|ptr
argument_list|,
name|usize
argument_list|,
name|tcache
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_EXPORT
name|size_t
name|JEMALLOC_NOTHROW
name|JEMALLOC_ATTR
parameter_list|(
name|pure
parameter_list|)
function|je_nallocx
parameter_list|(
name|size_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|size_t
name|usize
decl_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|malloc_init
argument_list|()
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|usize
operator|=
name|inallocx
argument_list|(
name|size
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|usize
operator|>
name|HUGE_MAXCLASS
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|usize
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_EXPORT
name|int
name|JEMALLOC_NOTHROW
name|je_mallctl
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|oldp
parameter_list|,
name|size_t
modifier|*
name|oldlenp
parameter_list|,
name|void
modifier|*
name|newp
parameter_list|,
name|size_t
name|newlen
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|malloc_init
argument_list|()
argument_list|)
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
return|return
operator|(
name|ctl_byname
argument_list|(
name|name
argument_list|,
name|oldp
argument_list|,
name|oldlenp
argument_list|,
name|newp
argument_list|,
name|newlen
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_EXPORT
name|int
name|JEMALLOC_NOTHROW
name|je_mallctlnametomib
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
modifier|*
name|mibp
parameter_list|,
name|size_t
modifier|*
name|miblenp
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|malloc_init
argument_list|()
argument_list|)
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
return|return
operator|(
name|ctl_nametomib
argument_list|(
name|name
argument_list|,
name|mibp
argument_list|,
name|miblenp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_EXPORT
name|int
name|JEMALLOC_NOTHROW
name|je_mallctlbymib
parameter_list|(
specifier|const
name|size_t
modifier|*
name|mib
parameter_list|,
name|size_t
name|miblen
parameter_list|,
name|void
modifier|*
name|oldp
parameter_list|,
name|size_t
modifier|*
name|oldlenp
parameter_list|,
name|void
modifier|*
name|newp
parameter_list|,
name|size_t
name|newlen
parameter_list|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|malloc_init
argument_list|()
argument_list|)
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
return|return
operator|(
name|ctl_bymib
argument_list|(
name|mib
argument_list|,
name|miblen
argument_list|,
name|oldp
argument_list|,
name|oldlenp
argument_list|,
name|newp
argument_list|,
name|newlen
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_EXPORT
name|void
name|JEMALLOC_NOTHROW
name|je_malloc_stats_print
parameter_list|(
name|void
function_decl|(
modifier|*
name|write_cb
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|cbopaque
parameter_list|,
specifier|const
name|char
modifier|*
name|opts
parameter_list|)
block|{
name|stats_print
argument_list|(
name|write_cb
argument_list|,
name|cbopaque
argument_list|,
name|opts
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_EXPORT
name|size_t
name|JEMALLOC_NOTHROW
name|je_malloc_usable_size
parameter_list|(
name|JEMALLOC_USABLE_SIZE_CONST
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|size_t
name|ret
decl_stmt|;
name|assert
argument_list|(
name|malloc_initialized
argument_list|()
operator|||
name|IS_INITIALIZER
argument_list|)
expr_stmt|;
name|malloc_thread_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|config_ivsalloc
condition|)
name|ret
operator|=
name|ivsalloc
argument_list|(
name|ptr
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
operator|(
name|ptr
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|isalloc
argument_list|(
name|ptr
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * End non-standard functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin compatibility functions.  */
end_comment

begin_define
define|#
directive|define
name|ALLOCM_LG_ALIGN
parameter_list|(
name|la
parameter_list|)
value|(la)
end_define

begin_define
define|#
directive|define
name|ALLOCM_ALIGN
parameter_list|(
name|a
parameter_list|)
value|(ffsl(a)-1)
end_define

begin_define
define|#
directive|define
name|ALLOCM_ZERO
value|((int)0x40)
end_define

begin_define
define|#
directive|define
name|ALLOCM_NO_MOVE
value|((int)0x80)
end_define

begin_define
define|#
directive|define
name|ALLOCM_SUCCESS
value|0
end_define

begin_define
define|#
directive|define
name|ALLOCM_ERR_OOM
value|1
end_define

begin_define
define|#
directive|define
name|ALLOCM_ERR_NOT_MOVED
value|2
end_define

begin_function
name|int
name|je_allocm
parameter_list|(
name|void
modifier|*
modifier|*
name|ptr
parameter_list|,
name|size_t
modifier|*
name|rsize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|p
operator|=
name|je_mallocx
argument_list|(
name|size
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|ALLOCM_ERR_OOM
operator|)
return|;
if|if
condition|(
name|rsize
operator|!=
name|NULL
condition|)
operator|*
name|rsize
operator|=
name|isalloc
argument_list|(
name|p
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|ALLOCM_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|je_rallocm
parameter_list|(
name|void
modifier|*
modifier|*
name|ptr
parameter_list|,
name|size_t
modifier|*
name|rsize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|extra
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|bool
name|no_move
init|=
name|flags
operator|&
name|ALLOCM_NO_MOVE
decl_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|*
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|SIZE_T_MAX
operator|-
name|size
operator|>=
name|extra
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_move
condition|)
block|{
name|size_t
name|usize
init|=
name|je_xallocx
argument_list|(
operator|*
name|ptr
argument_list|,
name|size
argument_list|,
name|extra
argument_list|,
name|flags
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|(
name|usize
operator|>=
name|size
operator|)
condition|?
name|ALLOCM_SUCCESS
else|:
name|ALLOCM_ERR_NOT_MOVED
expr_stmt|;
if|if
condition|(
name|rsize
operator|!=
name|NULL
condition|)
operator|*
name|rsize
operator|=
name|usize
expr_stmt|;
block|}
else|else
block|{
name|void
modifier|*
name|p
init|=
name|je_rallocx
argument_list|(
operator|*
name|ptr
argument_list|,
name|size
operator|+
name|extra
argument_list|,
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ptr
operator|=
name|p
expr_stmt|;
name|ret
operator|=
name|ALLOCM_SUCCESS
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|ALLOCM_ERR_OOM
expr_stmt|;
if|if
condition|(
name|rsize
operator|!=
name|NULL
condition|)
operator|*
name|rsize
operator|=
name|isalloc
argument_list|(
operator|*
name|ptr
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|je_sallocm
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
modifier|*
name|rsize
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|assert
argument_list|(
name|rsize
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|rsize
operator|=
name|je_sallocx
argument_list|(
name|ptr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|ALLOCM_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|je_dallocm
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|je_dallocx
argument_list|(
name|ptr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|ALLOCM_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|je_nallocm
parameter_list|(
name|size_t
modifier|*
name|rsize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|size_t
name|usize
decl_stmt|;
name|usize
operator|=
name|je_nallocx
argument_list|(
name|size
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|usize
operator|==
literal|0
condition|)
return|return
operator|(
name|ALLOCM_ERR_OOM
operator|)
return|;
if|if
condition|(
name|rsize
operator|!=
name|NULL
condition|)
operator|*
name|rsize
operator|=
name|usize
expr_stmt|;
return|return
operator|(
name|ALLOCM_SUCCESS
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|ALLOCM_LG_ALIGN
end_undef

begin_undef
undef|#
directive|undef
name|ALLOCM_ALIGN
end_undef

begin_undef
undef|#
directive|undef
name|ALLOCM_ZERO
end_undef

begin_undef
undef|#
directive|undef
name|ALLOCM_NO_MOVE
end_undef

begin_undef
undef|#
directive|undef
name|ALLOCM_SUCCESS
end_undef

begin_undef
undef|#
directive|undef
name|ALLOCM_ERR_OOM
end_undef

begin_undef
undef|#
directive|undef
name|ALLOCM_ERR_NOT_MOVED
end_undef

begin_comment
comment|/*  * End compatibility functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * The following functions are used by threading libraries for protection of  * malloc during fork().  */
end_comment

begin_comment
comment|/*  * If an application creates a thread before doing any allocation in the main  * thread, then calls fork(2) in the main thread followed by memory allocation  * in the child process, a race can occur that results in deadlock within the  * child: the main thread may have forked while the created thread had  * partially initialized the allocator.  Ordinarily jemalloc prevents  * fork/malloc races via the following functions it registers during  * initialization using pthread_atfork(), but of course that does no good if  * the allocator isn't fully initialized at fork time.  The following library  * constructor is a partial solution to this problem.  It may still be possible  * to trigger the deadlock described above, but doing so would involve forking  * via a library constructor that runs before jemalloc's runs.  */
end_comment

begin_macro
name|JEMALLOC_ATTR
argument_list|(
argument|constructor
argument_list|)
end_macro

begin_function
specifier|static
name|void
name|jemalloc_constructor
parameter_list|(
name|void
parameter_list|)
block|{
name|malloc_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|JEMALLOC_MUTEX_INIT_CB
end_ifndef

begin_decl_stmt
name|void
name|jemalloc_prefork
argument_list|(
name|void
argument_list|)
else|#
directive|else
name|JEMALLOC_EXPORT
name|void
name|_malloc_prefork
argument_list|(
name|void
argument_list|)
endif|#
directive|endif
block|{
name|unsigned
name|i
decl_stmt|,
name|narenas
decl_stmt|;
ifdef|#
directive|ifdef
name|JEMALLOC_MUTEX_INIT_CB
if|if
condition|(
operator|!
name|malloc_initialized
argument_list|()
condition|)
return|return;
endif|#
directive|endif
name|assert
argument_list|(
name|malloc_initialized
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Acquire all mutexes in a safe order. */
name|ctl_prefork
argument_list|()
expr_stmt|;
name|prof_prefork
argument_list|()
expr_stmt|;
name|malloc_mutex_prefork
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|narenas
operator|=
name|narenas_total_get
argument_list|()
init|;
name|i
operator|<
name|narenas
condition|;
name|i
operator|++
control|)
block|{
name|arena_t
modifier|*
name|arena
decl_stmt|;
if|if
condition|(
operator|(
name|arena
operator|=
name|arena_get
argument_list|(
name|i
argument_list|,
name|false
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|arena_prefork
argument_list|(
name|arena
argument_list|)
expr_stmt|;
block|}
name|chunk_prefork
argument_list|()
expr_stmt|;
name|base_prefork
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|JEMALLOC_MUTEX_INIT_CB
end_ifndef

begin_decl_stmt
name|void
name|jemalloc_postfork_parent
argument_list|(
name|void
argument_list|)
else|#
directive|else
name|JEMALLOC_EXPORT
name|void
name|_malloc_postfork
argument_list|(
name|void
argument_list|)
endif|#
directive|endif
block|{
name|unsigned
name|i
decl_stmt|,
name|narenas
decl_stmt|;
ifdef|#
directive|ifdef
name|JEMALLOC_MUTEX_INIT_CB
if|if
condition|(
operator|!
name|malloc_initialized
argument_list|()
condition|)
return|return;
endif|#
directive|endif
name|assert
argument_list|(
name|malloc_initialized
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Release all mutexes, now that fork() has completed. */
name|base_postfork_parent
argument_list|()
expr_stmt|;
name|chunk_postfork_parent
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|narenas
operator|=
name|narenas_total_get
argument_list|()
init|;
name|i
operator|<
name|narenas
condition|;
name|i
operator|++
control|)
block|{
name|arena_t
modifier|*
name|arena
decl_stmt|;
if|if
condition|(
operator|(
name|arena
operator|=
name|arena_get
argument_list|(
name|i
argument_list|,
name|false
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|arena_postfork_parent
argument_list|(
name|arena
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_postfork_parent
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
name|prof_postfork_parent
argument_list|()
expr_stmt|;
name|ctl_postfork_parent
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
name|jemalloc_postfork_child
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|narenas
decl_stmt|;
name|assert
argument_list|(
name|malloc_initialized
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Release all mutexes, now that fork() has completed. */
name|base_postfork_child
argument_list|()
expr_stmt|;
name|chunk_postfork_child
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|narenas
operator|=
name|narenas_total_get
argument_list|()
init|;
name|i
operator|<
name|narenas
condition|;
name|i
operator|++
control|)
block|{
name|arena_t
modifier|*
name|arena
decl_stmt|;
if|if
condition|(
operator|(
name|arena
operator|=
name|arena_get
argument_list|(
name|i
argument_list|,
name|false
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|arena_postfork_child
argument_list|(
name|arena
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_postfork_child
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
name|prof_postfork_child
argument_list|()
expr_stmt|;
name|ctl_postfork_child
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_malloc_first_thread
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|malloc_mutex_first_thread
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

end_unit

