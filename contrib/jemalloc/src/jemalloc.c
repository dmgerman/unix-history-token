begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|JEMALLOC_C_
end_define

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_internal.h"
end_include

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/* Data. */
end_comment

begin_macro
name|malloc_tsd_data
argument_list|(
argument_list|,
argument|arenas
argument_list|,
argument|arena_t *
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_macro
name|malloc_tsd_data
argument_list|(
argument_list|,
argument|thread_allocated
argument_list|,
argument|thread_allocated_t
argument_list|,
argument|THREAD_ALLOCATED_INITIALIZER
argument_list|)
end_macro

begin_comment
comment|/* Work around<http://llvm.org/bugs/show_bug.cgi?id=12623>: */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|__malloc_options_1_0
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|__sym_compat
argument_list|(
name|_malloc_options
argument_list|,
name|__malloc_options_1_0
argument_list|,
name|FBSD_1
literal|.0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Runtime configuration options. */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|je_malloc_conf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_abort
init|=
ifdef|#
directive|ifdef
name|JEMALLOC_DEBUG
name|true
else|#
directive|else
name|false
endif|#
directive|endif
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_junk
init|=
if|#
directive|if
operator|(
name|defined
argument_list|(
name|JEMALLOC_DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|JEMALLOC_FILL
argument_list|)
operator|)
name|true
else|#
directive|else
name|false
endif|#
directive|endif
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|opt_quarantine
init|=
name|ZU
argument_list|(
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_redzone
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_utrace
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_valgrind
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_xmalloc
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|opt_zero
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|opt_narenas
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|ncpus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|malloc_mutex_t
name|arenas_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|arena_t
modifier|*
modifier|*
name|arenas
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|narenas_total
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|narenas_auto
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to true once the allocator has been initialized. */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|malloc_initialized
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_THREADED_INIT
end_ifdef

begin_comment
comment|/* Used to let the initializing thread recursively allocate. */
end_comment

begin_define
define|#
directive|define
name|NO_INITIALIZER
value|((unsigned long)0)
end_define

begin_define
define|#
directive|define
name|INITIALIZER
value|pthread_self()
end_define

begin_define
define|#
directive|define
name|IS_INITIALIZER
value|(malloc_initializer == pthread_self())
end_define

begin_decl_stmt
specifier|static
name|pthread_t
name|malloc_initializer
init|=
name|NO_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NO_INITIALIZER
value|false
end_define

begin_define
define|#
directive|define
name|INITIALIZER
value|true
end_define

begin_define
define|#
directive|define
name|IS_INITIALIZER
value|malloc_initializer
end_define

begin_decl_stmt
specifier|static
name|bool
name|malloc_initializer
init|=
name|NO_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Used to avoid initialization races. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|init_lock
decl_stmt|;
end_decl_stmt

begin_macro
name|JEMALLOC_ATTR
argument_list|(
argument|constructor
argument_list|)
end_macro

begin_function
specifier|static
name|void
name|WINAPI
name|_init_init_lock
parameter_list|(
name|void
parameter_list|)
block|{
name|malloc_mutex_init
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|section
name|(
literal|".CRT$XCU"
name|,
name|read
name|)
end_pragma

begin_macro
name|JEMALLOC_SECTION
argument_list|(
literal|".CRT$XCU"
argument_list|)
end_macro

begin_macro
name|JEMALLOC_ATTR
argument_list|(
argument|used
argument_list|)
end_macro

begin_function_decl
specifier|static
specifier|const
name|void
function_decl|(
name|WINAPI
modifier|*
name|init_init_lock
function_decl|)
parameter_list|(
name|void
parameter_list|)
init|=
name|_init_init_lock
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|init_lock
init|=
name|MALLOC_MUTEX_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
block|{
name|void
modifier|*
name|p
decl_stmt|;
comment|/* Input pointer (as in realloc(p, s)). */
name|size_t
name|s
decl_stmt|;
comment|/* Request size. */
name|void
modifier|*
name|r
decl_stmt|;
comment|/* Result pointer. */
block|}
name|malloc_utrace_t
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_UTRACE
end_ifdef

begin_define
define|#
directive|define
name|UTRACE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|do {						\ 	if (opt_utrace) {						\ 		int utrace_serrno = errno;				\ 		malloc_utrace_t ut;					\ 		ut.p = (a);						\ 		ut.s = (b);						\ 		ut.r = (c);						\ 		utrace(&ut, sizeof(ut));				\ 		errno = utrace_serrno;					\ 	}								\ } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|UTRACE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Function prototypes for static functions that are referenced prior to  * definition.  */
end_comment

begin_function_decl
specifier|static
name|bool
name|malloc_init_hard
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin miscellaneous support functions.  */
end_comment

begin_comment
comment|/* Create a new arena and insert it into the arenas array at index ind. */
end_comment

begin_function
name|arena_t
modifier|*
name|arenas_extend
parameter_list|(
name|unsigned
name|ind
parameter_list|)
block|{
name|arena_t
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
name|arena_t
operator|*
operator|)
name|base_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arena_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
operator|&&
name|arena_new
argument_list|(
name|ret
argument_list|,
name|ind
argument_list|)
operator|==
name|false
condition|)
block|{
name|arenas
index|[
name|ind
index|]
operator|=
name|ret
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* Only reached if there is an OOM error. */
comment|/* 	 * OOM here is quite inconvenient to propagate, since dealing with it 	 * would require a check for failure in the fast path.  Instead, punt 	 * by using arenas[0].  In practice, this is an extremely unlikely 	 * failure. 	 */
name|malloc_write
argument_list|(
literal|"<jemalloc>: Error initializing arena\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|arenas
index|[
literal|0
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Slow path, called only by choose_arena(). */
end_comment

begin_function
name|arena_t
modifier|*
name|choose_arena_hard
parameter_list|(
name|void
parameter_list|)
block|{
name|arena_t
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|narenas_auto
operator|>
literal|1
condition|)
block|{
name|unsigned
name|i
decl_stmt|,
name|choose
decl_stmt|,
name|first_null
decl_stmt|;
name|choose
operator|=
literal|0
expr_stmt|;
name|first_null
operator|=
name|narenas_auto
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arenas
index|[
literal|0
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|narenas_auto
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|arenas
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Choose the first arena that has the lowest 				 * number of threads assigned to it. 				 */
if|if
condition|(
name|arenas
index|[
name|i
index|]
operator|->
name|nthreads
operator|<
name|arenas
index|[
name|choose
index|]
operator|->
name|nthreads
condition|)
name|choose
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|first_null
operator|==
name|narenas_auto
condition|)
block|{
comment|/* 				 * Record the index of the first uninitialized 				 * arena, in case all extant arenas are in use. 				 * 				 * NB: It is possible for there to be 				 * discontinuities in terms of initialized 				 * versus uninitialized arenas, due to the 				 * "thread.arena" mallctl. 				 */
name|first_null
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|arenas
index|[
name|choose
index|]
operator|->
name|nthreads
operator|==
literal|0
operator|||
name|first_null
operator|==
name|narenas_auto
condition|)
block|{
comment|/* 			 * Use an unloaded arena, or the least loaded arena if 			 * all arenas are already initialized. 			 */
name|ret
operator|=
name|arenas
index|[
name|choose
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* Initialize a new arena. */
name|ret
operator|=
name|arenas_extend
argument_list|(
name|first_null
argument_list|)
expr_stmt|;
block|}
name|ret
operator|->
name|nthreads
operator|++
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|arenas
index|[
literal|0
index|]
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
name|ret
operator|->
name|nthreads
operator|++
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
block|}
name|arenas_tsd_set
argument_list|(
operator|&
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|stats_print_atexit
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|config_tcache
operator|&&
name|config_stats
condition|)
block|{
name|unsigned
name|narenas
decl_stmt|,
name|i
decl_stmt|;
comment|/* 		 * Merge stats from extant threads.  This is racy, since 		 * individual threads do not lock when recording tcache stats 		 * events.  As a consequence, the final stats may be slightly 		 * out of date by the time they are reported, if other threads 		 * continue to allocate. 		 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|narenas
operator|=
name|narenas_total_get
argument_list|()
init|;
name|i
operator|<
name|narenas
condition|;
name|i
operator|++
control|)
block|{
name|arena_t
modifier|*
name|arena
init|=
name|arenas
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|arena
operator|!=
name|NULL
condition|)
block|{
name|tcache_t
modifier|*
name|tcache
decl_stmt|;
comment|/* 				 * tcache_stats_merge() locks bins, so if any 				 * code is introduced that acquires both arena 				 * and bin locks in the opposite order, 				 * deadlocks may result. 				 */
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ql_foreach
argument_list|(
argument|tcache
argument_list|,
argument|&arena->tcache_ql
argument_list|,
argument|link
argument_list|)
block|{
name|tcache_stats_merge
argument_list|(
name|tcache
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|je_malloc_stats_print
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * End miscellaneous support functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin initialization functions.  */
end_comment

begin_function
specifier|static
name|unsigned
name|malloc_ncpus
parameter_list|(
name|void
parameter_list|)
block|{
name|long
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|_WIN32
name|SYSTEM_INFO
name|si
decl_stmt|;
name|GetSystemInfo
argument_list|(
operator|&
name|si
argument_list|)
expr_stmt|;
name|result
operator|=
name|si
operator|.
name|dwNumberOfProcessors
expr_stmt|;
else|#
directive|else
name|result
operator|=
name|sysconf
argument_list|(
name|_SC_NPROCESSORS_ONLN
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|(
name|result
operator|==
operator|-
literal|1
operator|)
condition|?
literal|1
else|:
operator|(
name|unsigned
operator|)
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|arenas_cleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|arena_t
modifier|*
name|arena
init|=
operator|*
operator|(
name|arena_t
operator|*
operator|*
operator|)
name|arg
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
name|arena
operator|->
name|nthreads
operator|--
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|void
name|malloc_thread_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * TSD initialization can't be safely done as a side effect of 	 * deallocation, because it is possible for a thread to do nothing but 	 * deallocate its TLS data via free(), in which case writing to TLS 	 * would cause write-after-free memory corruption.  The quarantine 	 * facility *only* gets used as a side effect of deallocation, so make 	 * a best effort attempt at initializing its TSD by hooking all 	 * allocation events. 	 */
if|if
condition|(
name|config_fill
operator|&&
name|opt_quarantine
condition|)
name|quarantine_alloc_hook
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|bool
name|malloc_init
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|malloc_initialized
operator|==
name|false
operator|&&
name|malloc_init_hard
argument_list|()
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|malloc_thread_init
argument_list|()
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|malloc_conf_next
parameter_list|(
name|char
specifier|const
modifier|*
modifier|*
name|opts_p
parameter_list|,
name|char
specifier|const
modifier|*
modifier|*
name|k_p
parameter_list|,
name|size_t
modifier|*
name|klen_p
parameter_list|,
name|char
specifier|const
modifier|*
modifier|*
name|v_p
parameter_list|,
name|size_t
modifier|*
name|vlen_p
parameter_list|)
block|{
name|bool
name|accept
decl_stmt|;
specifier|const
name|char
modifier|*
name|opts
init|=
operator|*
name|opts_p
decl_stmt|;
operator|*
name|k_p
operator|=
name|opts
expr_stmt|;
for|for
control|(
name|accept
operator|=
name|false
init|;
name|accept
operator|==
name|false
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|opts
condition|)
block|{
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'_'
case|:
name|opts
operator|++
expr_stmt|;
break|break;
case|case
literal|':'
case|:
name|opts
operator|++
expr_stmt|;
operator|*
name|klen_p
operator|=
operator|(
name|uintptr_t
operator|)
name|opts
operator|-
literal|1
operator|-
operator|(
name|uintptr_t
operator|)
operator|*
name|k_p
expr_stmt|;
operator|*
name|v_p
operator|=
name|opts
expr_stmt|;
name|accept
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
if|if
condition|(
name|opts
operator|!=
operator|*
name|opts_p
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Conf string ends "
literal|"with key\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|true
operator|)
return|;
default|default:
name|malloc_write
argument_list|(
literal|"<jemalloc>: Malformed conf string\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
block|}
for|for
control|(
name|accept
operator|=
name|false
init|;
name|accept
operator|==
name|false
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|opts
condition|)
block|{
case|case
literal|','
case|:
name|opts
operator|++
expr_stmt|;
comment|/* 			 * Look ahead one character here, because the next time 			 * this function is called, it will assume that end of 			 * input has been cleanly reached if no input remains, 			 * but we have optimistically already consumed the 			 * comma if one exists. 			 */
if|if
condition|(
operator|*
name|opts
operator|==
literal|'\0'
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Conf string ends "
literal|"with comma\n"
argument_list|)
expr_stmt|;
block|}
operator|*
name|vlen_p
operator|=
operator|(
name|uintptr_t
operator|)
name|opts
operator|-
literal|1
operator|-
operator|(
name|uintptr_t
operator|)
operator|*
name|v_p
expr_stmt|;
name|accept
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
operator|*
name|vlen_p
operator|=
operator|(
name|uintptr_t
operator|)
name|opts
operator|-
operator|(
name|uintptr_t
operator|)
operator|*
name|v_p
expr_stmt|;
name|accept
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|opts
operator|++
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|opts_p
operator|=
name|opts
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|malloc_conf_error
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|k
parameter_list|,
name|size_t
name|klen
parameter_list|,
specifier|const
name|char
modifier|*
name|v
parameter_list|,
name|size_t
name|vlen
parameter_list|)
block|{
name|malloc_printf
argument_list|(
literal|"<jemalloc>: %s: %.*s:%.*s\n"
argument_list|,
name|msg
argument_list|,
operator|(
name|int
operator|)
name|klen
argument_list|,
name|k
argument_list|,
operator|(
name|int
operator|)
name|vlen
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|malloc_conf_init
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|char
name|buf
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|opts
decl_stmt|,
modifier|*
name|k
decl_stmt|,
modifier|*
name|v
decl_stmt|;
name|size_t
name|klen
decl_stmt|,
name|vlen
decl_stmt|;
comment|/* 	 * Automatically configure valgrind before processing options.  The 	 * valgrind option remains in jemalloc 3.x for compatibility reasons. 	 */
if|if
condition|(
name|config_valgrind
condition|)
block|{
name|opt_valgrind
operator|=
operator|(
name|RUNNING_ON_VALGRIND
operator|!=
literal|0
operator|)
condition|?
name|true
else|:
name|false
expr_stmt|;
if|if
condition|(
name|config_fill
operator|&&
name|opt_valgrind
condition|)
block|{
name|opt_junk
operator|=
name|false
expr_stmt|;
name|assert
argument_list|(
name|opt_zero
operator|==
name|false
argument_list|)
expr_stmt|;
name|opt_quarantine
operator|=
name|JEMALLOC_VALGRIND_QUARANTINE_DEFAULT
expr_stmt|;
name|opt_redzone
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|config_tcache
operator|&&
name|opt_valgrind
condition|)
name|opt_tcache
operator|=
name|false
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
comment|/* Get runtime configuration. */
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|je_malloc_conf
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Use options that were compiled into the 				 * program. 				 */
name|opts
operator|=
name|je_malloc_conf
expr_stmt|;
block|}
else|else
block|{
comment|/* No configuration specified. */
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opts
operator|=
name|buf
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
block|{
name|int
name|linklen
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|_WIN32
name|int
name|saved_errno
init|=
name|errno
decl_stmt|;
specifier|const
name|char
modifier|*
name|linkname
init|=
ifdef|#
directive|ifdef
name|JEMALLOC_PREFIX
literal|"/etc/"
name|JEMALLOC_PREFIX
literal|"malloc.conf"
else|#
directive|else
literal|"/etc/malloc.conf"
endif|#
directive|endif
decl_stmt|;
comment|/* 			 * Try to use the contents of the "/etc/malloc.conf" 			 * symbolic link's name. 			 */
name|linklen
operator|=
name|readlink
argument_list|(
name|linkname
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|linklen
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* No configuration specified. */
name|linklen
operator|=
literal|0
expr_stmt|;
comment|/* restore errno */
name|set_errno
argument_list|(
name|saved_errno
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|buf
index|[
name|linklen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opts
operator|=
name|buf
expr_stmt|;
break|break;
block|}
case|case
literal|2
case|:
block|{
specifier|const
name|char
modifier|*
name|envname
init|=
ifdef|#
directive|ifdef
name|JEMALLOC_PREFIX
name|JEMALLOC_CPREFIX
literal|"MALLOC_CONF"
else|#
directive|else
literal|"MALLOC_CONF"
endif|#
directive|endif
decl_stmt|;
if|if
condition|(
name|issetugid
argument_list|()
operator|==
literal|0
operator|&&
operator|(
name|opts
operator|=
name|getenv
argument_list|(
name|envname
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Do nothing; opts is already initialized to 				 * the value of the MALLOC_CONF environment 				 * variable. 				 */
block|}
else|else
block|{
comment|/* No configuration specified. */
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opts
operator|=
name|buf
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|not_reached
argument_list|()
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opts
operator|=
name|buf
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|opts
operator|!=
literal|'\0'
operator|&&
name|malloc_conf_next
argument_list|(
operator|&
name|opts
argument_list|,
operator|&
name|k
argument_list|,
operator|&
name|klen
argument_list|,
operator|&
name|v
argument_list|,
operator|&
name|vlen
argument_list|)
operator|==
name|false
condition|)
block|{
define|#
directive|define
name|CONF_HANDLE_BOOL
parameter_list|(
name|o
parameter_list|,
name|n
parameter_list|)
define|\
value|if (sizeof(n)-1 == klen&& strncmp(n, k,	\ 			    klen) == 0) {				\ 				if (strncmp("true", v, vlen) == 0&&	\ 				    vlen == sizeof("true")-1)		\ 					o = true;			\ 				else if (strncmp("false", v, vlen) ==	\ 				    0&& vlen == sizeof("false")-1)	\ 					o = false;			\ 				else {					\ 					malloc_conf_error(		\ 					    "Invalid conf value",	\ 					    k, klen, v, vlen);		\ 				}					\ 				continue;				\ 			}
define|#
directive|define
name|CONF_HANDLE_SIZE_T
parameter_list|(
name|o
parameter_list|,
name|n
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|,
name|clip
parameter_list|)
define|\
value|if (sizeof(n)-1 == klen&& strncmp(n, k,	\ 			    klen) == 0) {				\ 				uintmax_t um;				\ 				char *end;				\ 									\ 				set_errno(0);				\ 				um = malloc_strtoumax(v,&end, 0);	\ 				if (get_errno() != 0 || (uintptr_t)end -\ 				    (uintptr_t)v != vlen) {		\ 					malloc_conf_error(		\ 					    "Invalid conf value",	\ 					    k, klen, v, vlen);		\ 				} else if (clip) {			\ 					if (min != 0&& um< min)	\ 						o = min;		\ 					else if (um> max)		\ 						o = max;		\ 					else				\ 						o = um;			\ 				} else {				\ 					if ((min != 0&& um< min) ||	\ 					    um> max) {			\ 						malloc_conf_error(	\ 						    "Out-of-range "	\ 						    "conf value",	\ 						    k, klen, v, vlen);	\ 					} else				\ 						o = um;			\ 				}					\ 				continue;				\ 			}
define|#
directive|define
name|CONF_HANDLE_SSIZE_T
parameter_list|(
name|o
parameter_list|,
name|n
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|)
define|\
value|if (sizeof(n)-1 == klen&& strncmp(n, k,	\ 			    klen) == 0) {				\ 				long l;					\ 				char *end;				\ 									\ 				set_errno(0);				\ 				l = strtol(v,&end, 0);			\ 				if (get_errno() != 0 || (uintptr_t)end -\ 				    (uintptr_t)v != vlen) {		\ 					malloc_conf_error(		\ 					    "Invalid conf value",	\ 					    k, klen, v, vlen);		\ 				} else if (l< (ssize_t)min || l>	\ 				    (ssize_t)max) {			\ 					malloc_conf_error(		\ 					    "Out-of-range conf value",	\ 					    k, klen, v, vlen);		\ 				} else					\ 					o = l;				\ 				continue;				\ 			}
define|#
directive|define
name|CONF_HANDLE_CHAR_P
parameter_list|(
name|o
parameter_list|,
name|n
parameter_list|,
name|d
parameter_list|)
define|\
value|if (sizeof(n)-1 == klen&& strncmp(n, k,	\ 			    klen) == 0) {				\ 				size_t cpylen = (vlen<=		\ 				    sizeof(o)-1) ? vlen :		\ 				    sizeof(o)-1;			\ 				strncpy(o, v, cpylen);			\ 				o[cpylen] = '\0';			\ 				continue;				\ 			}
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_abort
argument_list|,
literal|"abort"
argument_list|)
comment|/* 			 * Chunks always require at least one header page, plus 			 * one data page in the absence of redzones, or three 			 * pages in the presence of redzones.  In order to 			 * simplify options processing, fix the limit based on 			 * config_fill. 			 */
name|CONF_HANDLE_SIZE_T
argument_list|(
argument|opt_lg_chunk
argument_list|,
literal|"lg_chunk"
argument_list|,
argument|LG_PAGE + 			    (config_fill ?
literal|2
argument|:
literal|1
argument|)
argument_list|,
argument|(sizeof(size_t)<<
literal|3
argument|) -
literal|1
argument_list|,
argument|true
argument_list|)
if|if
condition|(
name|strncmp
argument_list|(
literal|"dss"
argument_list|,
name|k
argument_list|,
name|klen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|bool
name|match
init|=
name|false
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dss_prec_limit
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|dss_prec_names
index|[
name|i
index|]
argument_list|,
name|v
argument_list|,
name|vlen
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|chunk_dss_prec_set
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|malloc_conf_error
argument_list|(
literal|"Error setting dss"
argument_list|,
name|k
argument_list|,
name|klen
argument_list|,
name|v
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|opt_dss
operator|=
name|dss_prec_names
index|[
name|i
index|]
expr_stmt|;
name|match
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|match
operator|==
name|false
condition|)
block|{
name|malloc_conf_error
argument_list|(
literal|"Invalid conf value"
argument_list|,
name|k
argument_list|,
name|klen
argument_list|,
name|v
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|CONF_HANDLE_SIZE_T
argument_list|(
argument|opt_narenas
argument_list|,
literal|"narenas"
argument_list|,
literal|1
argument_list|,
argument|SIZE_T_MAX
argument_list|,
argument|false
argument_list|)
name|CONF_HANDLE_SSIZE_T
argument_list|(
argument|opt_lg_dirty_mult
argument_list|,
literal|"lg_dirty_mult"
argument_list|,
argument|-
literal|1
argument_list|,
argument|(sizeof(size_t)<<
literal|3
argument|) -
literal|1
argument_list|)
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_stats_print
argument_list|,
literal|"stats_print"
argument_list|)
if|if
condition|(
name|config_fill
condition|)
block|{
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_junk
argument_list|,
literal|"junk"
argument_list|)
name|CONF_HANDLE_SIZE_T
argument_list|(
argument|opt_quarantine
argument_list|,
literal|"quarantine"
argument_list|,
literal|0
argument_list|,
argument|SIZE_T_MAX
argument_list|,
argument|false
argument_list|)
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_redzone
argument_list|,
literal|"redzone"
argument_list|)
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_zero
argument_list|,
literal|"zero"
argument_list|)
block|}
if|if
condition|(
name|config_utrace
condition|)
block|{
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_utrace
argument_list|,
literal|"utrace"
argument_list|)
block|}
if|if
condition|(
name|config_valgrind
condition|)
block|{
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_valgrind
argument_list|,
literal|"valgrind"
argument_list|)
block|}
if|if
condition|(
name|config_xmalloc
condition|)
block|{
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_xmalloc
argument_list|,
literal|"xmalloc"
argument_list|)
block|}
if|if
condition|(
name|config_tcache
condition|)
block|{
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_tcache
argument_list|,
literal|"tcache"
argument_list|)
name|CONF_HANDLE_SSIZE_T
argument_list|(
argument|opt_lg_tcache_max
argument_list|,
literal|"lg_tcache_max"
argument_list|,
argument|-
literal|1
argument_list|,
argument|(sizeof(size_t)<<
literal|3
argument|) -
literal|1
argument_list|)
block|}
if|if
condition|(
name|config_prof
condition|)
block|{
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_prof
argument_list|,
literal|"prof"
argument_list|)
name|CONF_HANDLE_CHAR_P
argument_list|(
argument|opt_prof_prefix
argument_list|,
literal|"prof_prefix"
argument_list|,
literal|"jeprof"
argument_list|)
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_prof_active
argument_list|,
literal|"prof_active"
argument_list|)
name|CONF_HANDLE_SSIZE_T
argument_list|(
argument|opt_lg_prof_sample
argument_list|,
literal|"lg_prof_sample"
argument_list|,
literal|0
argument_list|,
argument|(sizeof(uint64_t)<<
literal|3
argument|) -
literal|1
argument_list|)
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_prof_accum
argument_list|,
literal|"prof_accum"
argument_list|)
name|CONF_HANDLE_SSIZE_T
argument_list|(
argument|opt_lg_prof_interval
argument_list|,
literal|"lg_prof_interval"
argument_list|,
argument|-
literal|1
argument_list|,
argument|(sizeof(uint64_t)<<
literal|3
argument|) -
literal|1
argument_list|)
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_prof_gdump
argument_list|,
literal|"prof_gdump"
argument_list|)
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_prof_final
argument_list|,
literal|"prof_final"
argument_list|)
name|CONF_HANDLE_BOOL
argument_list|(
argument|opt_prof_leak
argument_list|,
literal|"prof_leak"
argument_list|)
block|}
name|malloc_conf_error
argument_list|(
literal|"Invalid conf pair"
argument_list|,
name|k
argument_list|,
name|klen
argument_list|,
name|v
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|CONF_HANDLE_BOOL
undef|#
directive|undef
name|CONF_HANDLE_SIZE_T
undef|#
directive|undef
name|CONF_HANDLE_SSIZE_T
undef|#
directive|undef
name|CONF_HANDLE_CHAR_P
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|malloc_init_hard
parameter_list|(
name|void
parameter_list|)
block|{
name|arena_t
modifier|*
name|init_arenas
index|[
literal|1
index|]
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|malloc_initialized
operator|||
name|IS_INITIALIZER
condition|)
block|{
comment|/* 		 * Another thread initialized the allocator before this one 		 * acquired init_lock, or this thread is the initializing 		 * thread, and it is recursively allocating. 		 */
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|JEMALLOC_THREADED_INIT
if|if
condition|(
name|malloc_initializer
operator|!=
name|NO_INITIALIZER
operator|&&
name|IS_INITIALIZER
operator|==
name|false
condition|)
block|{
comment|/* Busy-wait until the initializing thread completes. */
do|do
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
name|CPU_SPINWAIT
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|malloc_initialized
operator|==
name|false
condition|)
do|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
endif|#
directive|endif
name|malloc_initializer
operator|=
name|INITIALIZER
expr_stmt|;
name|malloc_tsd_boot
argument_list|()
expr_stmt|;
if|if
condition|(
name|config_prof
condition|)
name|prof_boot0
argument_list|()
expr_stmt|;
name|malloc_conf_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|opt_stats_print
condition|)
block|{
comment|/* Print statistics at exit. */
if|if
condition|(
name|atexit
argument_list|(
name|stats_print_atexit
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Error in atexit()\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|base_boot
argument_list|()
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
if|if
condition|(
name|chunk_boot
argument_list|()
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
if|if
condition|(
name|ctl_boot
argument_list|()
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
if|if
condition|(
name|config_prof
condition|)
name|prof_boot1
argument_list|()
expr_stmt|;
name|arena_boot
argument_list|()
expr_stmt|;
if|if
condition|(
name|config_tcache
operator|&&
name|tcache_boot0
argument_list|()
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
if|if
condition|(
name|huge_boot
argument_list|()
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|arenas_lock
argument_list|)
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
comment|/* 	 * Create enough scaffolding to allow recursive allocation in 	 * malloc_ncpus(). 	 */
name|narenas_total
operator|=
name|narenas_auto
operator|=
literal|1
expr_stmt|;
name|arenas
operator|=
name|init_arenas
expr_stmt|;
name|memset
argument_list|(
name|arenas
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|arena_t
operator|*
argument_list|)
operator|*
name|narenas_auto
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize one arena here.  The rest are lazily created in 	 * choose_arena_hard(). 	 */
name|arenas_extend
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arenas
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
comment|/* Initialize allocation counters before any allocations can occur. */
if|if
condition|(
name|config_stats
operator|&&
name|thread_allocated_tsd_boot
argument_list|()
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
if|if
condition|(
name|arenas_tsd_boot
argument_list|()
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
if|if
condition|(
name|config_tcache
operator|&&
name|tcache_boot1
argument_list|()
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
if|if
condition|(
name|config_fill
operator|&&
name|quarantine_boot
argument_list|()
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
if|if
condition|(
name|config_prof
operator|&&
name|prof_boot2
argument_list|()
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
comment|/**********************************************************************/
comment|/* Recursive allocation may follow. */
name|ncpus
operator|=
name|malloc_ncpus
argument_list|()
expr_stmt|;
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|JEMALLOC_MUTEX_INIT_CB
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|JEMALLOC_ZONE
argument_list|)
expr|\
operator|&&
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|)
comment|/* LinuxThreads's pthread_atfork() allocates. */
if|if
condition|(
name|pthread_atfork
argument_list|(
name|jemalloc_prefork
argument_list|,
name|jemalloc_postfork_parent
argument_list|,
name|jemalloc_postfork_child
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Error in pthread_atfork()\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Done recursively allocating. */
comment|/**********************************************************************/
name|malloc_mutex_lock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mutex_boot
argument_list|()
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
if|if
condition|(
name|opt_narenas
operator|==
literal|0
condition|)
block|{
comment|/* 		 * For SMP systems, create more than one arena per CPU by 		 * default. 		 */
if|if
condition|(
name|ncpus
operator|>
literal|1
condition|)
name|opt_narenas
operator|=
name|ncpus
operator|<<
literal|2
expr_stmt|;
else|else
name|opt_narenas
operator|=
literal|1
expr_stmt|;
block|}
name|narenas_auto
operator|=
name|opt_narenas
expr_stmt|;
comment|/* 	 * Make sure that the arenas array can be allocated.  In practice, this 	 * limit is enough to allow the allocator to function, but the ctl 	 * machinery will fail to allocate memory at far lower limits. 	 */
if|if
condition|(
name|narenas_auto
operator|>
name|chunksize
operator|/
sizeof|sizeof
argument_list|(
name|arena_t
operator|*
argument_list|)
condition|)
block|{
name|narenas_auto
operator|=
name|chunksize
operator|/
sizeof|sizeof
argument_list|(
name|arena_t
operator|*
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"<jemalloc>: Reducing narenas to limit (%d)\n"
argument_list|,
name|narenas_auto
argument_list|)
expr_stmt|;
block|}
name|narenas_total
operator|=
name|narenas_auto
expr_stmt|;
comment|/* Allocate and initialize arenas. */
name|arenas
operator|=
operator|(
name|arena_t
operator|*
operator|*
operator|)
name|base_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arena_t
operator|*
argument_list|)
operator|*
name|narenas_total
argument_list|)
expr_stmt|;
if|if
condition|(
name|arenas
operator|==
name|NULL
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
comment|/* 	 * Zero the array.  In practice, this should always be pre-zeroed, 	 * since it was just mmap()ed, but let's be sure. 	 */
name|memset
argument_list|(
name|arenas
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|arena_t
operator|*
argument_list|)
operator|*
name|narenas_total
argument_list|)
expr_stmt|;
comment|/* Copy the pointer to the one arena that was already initialized. */
name|arenas
index|[
literal|0
index|]
operator|=
name|init_arenas
index|[
literal|0
index|]
expr_stmt|;
name|malloc_initialized
operator|=
name|true
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * End initialization functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin malloc(3)-compatible functions.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|imalloc_prof_sample
parameter_list|(
name|size_t
name|usize
parameter_list|,
name|prof_thr_cnt_t
modifier|*
name|cnt
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|cnt
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|prof_promote
operator|&&
name|usize
operator|<=
name|SMALL_MAXCLASS
condition|)
block|{
name|p
operator|=
name|imalloc
argument_list|(
name|SMALL_MAXCLASS
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|arena_prof_promoted
argument_list|(
name|p
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|=
name|imalloc
argument_list|(
name|usize
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|void
modifier|*
name|imalloc_prof
parameter_list|(
name|size_t
name|usize
parameter_list|,
name|prof_thr_cnt_t
modifier|*
name|cnt
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|cnt
operator|!=
operator|(
name|uintptr_t
operator|)
literal|1U
condition|)
name|p
operator|=
name|imalloc_prof_sample
argument_list|(
name|usize
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|imalloc
argument_list|(
name|usize
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|prof_malloc
argument_list|(
name|p
argument_list|,
name|usize
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * MALLOC_BODY() is a macro rather than a function because its contents are in  * the fast path, but inlining would cause reliability issues when determining  * how many frames to discard from heap profiling backtraces.  */
end_comment

begin_define
define|#
directive|define
name|MALLOC_BODY
parameter_list|(
name|ret
parameter_list|,
name|size
parameter_list|,
name|usize
parameter_list|)
value|do {				\ 	if (malloc_init())						\ 		ret = NULL;						\ 	else {								\ 		if (config_prof&& opt_prof) {				\ 			prof_thr_cnt_t *cnt;				\ 									\ 			usize = s2u(size);				\
comment|/*						\ 			 * Call PROF_ALLOC_PREP() here rather than in	\ 			 * imalloc_prof() so that imalloc_prof() can be	\ 			 * inlined without introducing uncertainty	\ 			 * about the number of backtrace frames to	\ 			 * ignore.  imalloc_prof() is in the fast path	\ 			 * when heap profiling is enabled, so inlining	\ 			 * is critical to performance.  (For		\ 			 * consistency all callers of PROF_ALLOC_PREP()	\ 			 * are structured similarly, even though e.g.	\ 			 * realloc() isn't called enough for inlining	\ 			 * to be critical.)				\ 			 */
value|\ 			PROF_ALLOC_PREP(1, usize, cnt);			\ 			ret = imalloc_prof(usize, cnt);			\ 		} else {						\ 			if (config_stats || (config_valgrind&&		\ 			    opt_valgrind))				\ 				usize = s2u(size);			\ 			ret = imalloc(size);				\ 		}							\ 	}								\ } while (0)
end_define

begin_function
name|void
modifier|*
name|je_malloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|usize
name|JEMALLOC_CC_SILENCE_INIT
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
literal|1
expr_stmt|;
name|MALLOC_BODY
argument_list|(
name|ret
argument_list|,
name|size
argument_list|,
name|usize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|config_xmalloc
operator|&&
name|opt_xmalloc
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Error in malloc(): "
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|set_errno
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config_stats
operator|&&
name|ret
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|usize
operator|==
name|isalloc
argument_list|(
name|ret
argument_list|,
name|config_prof
argument_list|)
argument_list|)
expr_stmt|;
name|thread_allocated_tsd_get
argument_list|()
operator|->
name|allocated
operator|+=
name|usize
expr_stmt|;
block|}
name|UTRACE
argument_list|(
literal|0
argument_list|,
name|size
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|JEMALLOC_VALGRIND_MALLOC
argument_list|(
name|ret
operator|!=
name|NULL
argument_list|,
name|ret
argument_list|,
name|usize
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|imemalign_prof_sample
parameter_list|(
name|size_t
name|alignment
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|prof_thr_cnt_t
modifier|*
name|cnt
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|cnt
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|prof_promote
operator|&&
name|usize
operator|<=
name|SMALL_MAXCLASS
condition|)
block|{
name|assert
argument_list|(
name|sa2u
argument_list|(
name|SMALL_MAXCLASS
operator|+
literal|1
argument_list|,
name|alignment
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|ipalloc
argument_list|(
name|sa2u
argument_list|(
name|SMALL_MAXCLASS
operator|+
literal|1
argument_list|,
name|alignment
argument_list|)
argument_list|,
name|alignment
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|arena_prof_promoted
argument_list|(
name|p
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|=
name|ipalloc
argument_list|(
name|usize
argument_list|,
name|alignment
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|void
modifier|*
name|imemalign_prof
parameter_list|(
name|size_t
name|alignment
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|prof_thr_cnt_t
modifier|*
name|cnt
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|cnt
operator|!=
operator|(
name|uintptr_t
operator|)
literal|1U
condition|)
name|p
operator|=
name|imemalign_prof_sample
argument_list|(
name|alignment
argument_list|,
name|usize
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|ipalloc
argument_list|(
name|usize
argument_list|,
name|alignment
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|prof_malloc
argument_list|(
name|p
argument_list|,
name|usize
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_macro
name|JEMALLOC_ATTR
argument_list|(
argument|nonnull(
literal|1
argument|)
argument_list|)
end_macro

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_PROF
end_ifdef

begin_comment
comment|/*  * Avoid any uncertainty as to how many backtrace frames to ignore in  * PROF_ALLOC_PREP().  */
end_comment

begin_function
name|JEMALLOC_NOINLINE
endif|#
directive|endif
specifier|static
name|int
name|imemalign
parameter_list|(
name|void
modifier|*
modifier|*
name|memptr
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|min_alignment
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|size_t
name|usize
decl_stmt|;
name|void
modifier|*
name|result
decl_stmt|;
name|assert
argument_list|(
name|min_alignment
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|malloc_init
argument_list|()
condition|)
block|{
name|result
operator|=
name|NULL
expr_stmt|;
goto|goto
name|label_oom
goto|;
block|}
else|else
block|{
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
literal|1
expr_stmt|;
comment|/* Make sure that alignment is a large enough power of 2. */
if|if
condition|(
operator|(
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|&
name|alignment
operator|)
operator|!=
literal|0
operator|||
operator|(
name|alignment
operator|<
name|min_alignment
operator|)
condition|)
block|{
if|if
condition|(
name|config_xmalloc
operator|&&
name|opt_xmalloc
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Error allocating "
literal|"aligned memory: invalid alignment\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|result
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
name|usize
operator|=
name|sa2u
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
if|if
condition|(
name|usize
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|NULL
expr_stmt|;
goto|goto
name|label_oom
goto|;
block|}
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
block|{
name|prof_thr_cnt_t
modifier|*
name|cnt
decl_stmt|;
name|PROF_ALLOC_PREP
argument_list|(
literal|2
argument_list|,
name|usize
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|result
operator|=
name|imemalign_prof
argument_list|(
name|alignment
argument_list|,
name|usize
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|ipalloc
argument_list|(
name|usize
argument_list|,
name|alignment
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
goto|goto
name|label_oom
goto|;
block|}
operator|*
name|memptr
operator|=
name|result
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|label_return
label|:
if|if
condition|(
name|config_stats
operator|&&
name|result
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|usize
operator|==
name|isalloc
argument_list|(
name|result
argument_list|,
name|config_prof
argument_list|)
argument_list|)
expr_stmt|;
name|thread_allocated_tsd_get
argument_list|()
operator|->
name|allocated
operator|+=
name|usize
expr_stmt|;
block|}
name|UTRACE
argument_list|(
literal|0
argument_list|,
name|size
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
name|label_oom
label|:
name|assert
argument_list|(
name|result
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_xmalloc
operator|&&
name|opt_xmalloc
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Error allocating aligned memory: "
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
end_function

begin_function
name|int
name|je_posix_memalign
parameter_list|(
name|void
modifier|*
modifier|*
name|memptr
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|int
name|ret
init|=
name|imemalign
argument_list|(
name|memptr
argument_list|,
name|alignment
argument_list|,
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|JEMALLOC_VALGRIND_MALLOC
argument_list|(
name|ret
operator|==
literal|0
argument_list|,
operator|*
name|memptr
argument_list|,
name|isalloc
argument_list|(
operator|*
name|memptr
argument_list|,
name|config_prof
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|je_aligned_alloc
parameter_list|(
name|size_t
name|alignment
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|imemalign
argument_list|(
operator|&
name|ret
argument_list|,
name|alignment
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|NULL
expr_stmt|;
name|set_errno
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
name|JEMALLOC_VALGRIND_MALLOC
argument_list|(
name|err
operator|==
literal|0
argument_list|,
name|ret
argument_list|,
name|isalloc
argument_list|(
name|ret
argument_list|,
name|config_prof
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|icalloc_prof_sample
parameter_list|(
name|size_t
name|usize
parameter_list|,
name|prof_thr_cnt_t
modifier|*
name|cnt
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|cnt
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|prof_promote
operator|&&
name|usize
operator|<=
name|SMALL_MAXCLASS
condition|)
block|{
name|p
operator|=
name|icalloc
argument_list|(
name|SMALL_MAXCLASS
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|arena_prof_promoted
argument_list|(
name|p
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|=
name|icalloc
argument_list|(
name|usize
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|void
modifier|*
name|icalloc_prof
parameter_list|(
name|size_t
name|usize
parameter_list|,
name|prof_thr_cnt_t
modifier|*
name|cnt
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|cnt
operator|!=
operator|(
name|uintptr_t
operator|)
literal|1U
condition|)
name|p
operator|=
name|icalloc_prof_sample
argument_list|(
name|usize
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|icalloc
argument_list|(
name|usize
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|prof_malloc
argument_list|(
name|p
argument_list|,
name|usize
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|je_calloc
parameter_list|(
name|size_t
name|num
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|num_size
decl_stmt|;
name|size_t
name|usize
name|JEMALLOC_CC_SILENCE_INIT
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|malloc_init
argument_list|()
condition|)
block|{
name|num_size
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
name|num_size
operator|=
name|num
operator|*
name|size
expr_stmt|;
if|if
condition|(
name|num_size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|num
operator|==
literal|0
operator|||
name|size
operator|==
literal|0
condition|)
name|num_size
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
comment|/* 	 * Try to avoid division here.  We know that it isn't possible to 	 * overflow during multiplication if neither operand uses any of the 	 * most significant half of the bits in a size_t. 	 */
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|num
operator||
name|size
operator|)
operator|&
operator|(
name|SIZE_T_MAX
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|<<
literal|2
operator|)
operator|)
operator|)
operator|&&
operator|(
name|num_size
operator|/
name|size
operator|!=
name|num
operator|)
condition|)
block|{
comment|/* size_t overflow. */
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
block|{
name|prof_thr_cnt_t
modifier|*
name|cnt
decl_stmt|;
name|usize
operator|=
name|s2u
argument_list|(
name|num_size
argument_list|)
expr_stmt|;
name|PROF_ALLOC_PREP
argument_list|(
literal|1
argument_list|,
name|usize
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|ret
operator|=
name|icalloc_prof
argument_list|(
name|usize
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|config_stats
operator|||
operator|(
name|config_valgrind
operator|&&
name|opt_valgrind
operator|)
condition|)
name|usize
operator|=
name|s2u
argument_list|(
name|num_size
argument_list|)
expr_stmt|;
name|ret
operator|=
name|icalloc
argument_list|(
name|num_size
argument_list|)
expr_stmt|;
block|}
name|label_return
label|:
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|config_xmalloc
operator|&&
name|opt_xmalloc
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Error in calloc(): out of "
literal|"memory\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|set_errno
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config_stats
operator|&&
name|ret
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|usize
operator|==
name|isalloc
argument_list|(
name|ret
argument_list|,
name|config_prof
argument_list|)
argument_list|)
expr_stmt|;
name|thread_allocated_tsd_get
argument_list|()
operator|->
name|allocated
operator|+=
name|usize
expr_stmt|;
block|}
name|UTRACE
argument_list|(
literal|0
argument_list|,
name|num_size
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|JEMALLOC_VALGRIND_MALLOC
argument_list|(
name|ret
operator|!=
name|NULL
argument_list|,
name|ret
argument_list|,
name|usize
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|irealloc_prof_sample
parameter_list|(
name|void
modifier|*
name|oldptr
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|prof_thr_cnt_t
modifier|*
name|cnt
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|cnt
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|prof_promote
operator|&&
name|usize
operator|<=
name|SMALL_MAXCLASS
condition|)
block|{
name|p
operator|=
name|iralloc
argument_list|(
name|oldptr
argument_list|,
name|SMALL_MAXCLASS
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|arena_prof_promoted
argument_list|(
name|p
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|=
name|iralloc
argument_list|(
name|oldptr
argument_list|,
name|usize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|void
modifier|*
name|irealloc_prof
parameter_list|(
name|void
modifier|*
name|oldptr
parameter_list|,
name|size_t
name|old_usize
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|prof_thr_cnt_t
modifier|*
name|cnt
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|prof_ctx_t
modifier|*
name|old_ctx
decl_stmt|;
name|old_ctx
operator|=
name|prof_ctx_get
argument_list|(
name|oldptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|cnt
operator|!=
operator|(
name|uintptr_t
operator|)
literal|1U
condition|)
name|p
operator|=
name|irealloc_prof_sample
argument_list|(
name|oldptr
argument_list|,
name|usize
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|iralloc
argument_list|(
name|oldptr
argument_list|,
name|usize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|prof_realloc
argument_list|(
name|p
argument_list|,
name|usize
argument_list|,
name|cnt
argument_list|,
name|old_usize
argument_list|,
name|old_ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_INLINE_C
name|void
name|ifree
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|size_t
name|usize
decl_stmt|;
name|UNUSED
name|size_t
name|rzsize
name|JEMALLOC_CC_SILENCE_INIT
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|malloc_initialized
operator|||
name|IS_INITIALIZER
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
block|{
name|usize
operator|=
name|isalloc
argument_list|(
name|ptr
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
name|prof_free
argument_list|(
name|ptr
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|config_stats
operator|||
name|config_valgrind
condition|)
name|usize
operator|=
name|isalloc
argument_list|(
name|ptr
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
name|thread_allocated_tsd_get
argument_list|()
operator|->
name|deallocated
operator|+=
name|usize
expr_stmt|;
if|if
condition|(
name|config_valgrind
operator|&&
name|opt_valgrind
condition|)
name|rzsize
operator|=
name|p2rz
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|iqalloc
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|JEMALLOC_VALGRIND_FREE
argument_list|(
name|ptr
argument_list|,
name|rzsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|je_realloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|usize
name|JEMALLOC_CC_SILENCE_INIT
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|size_t
name|old_usize
init|=
literal|0
decl_stmt|;
name|UNUSED
name|size_t
name|old_rzsize
name|JEMALLOC_CC_SILENCE_INIT
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
comment|/* realloc(ptr, 0) is equivalent to free(ptr). */
name|UTRACE
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|size
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|malloc_initialized
operator|||
name|IS_INITIALIZER
argument_list|)
expr_stmt|;
name|malloc_thread_init
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|config_prof
operator|&&
name|opt_prof
operator|)
operator|||
name|config_stats
operator|||
operator|(
name|config_valgrind
operator|&&
name|opt_valgrind
operator|)
condition|)
name|old_usize
operator|=
name|isalloc
argument_list|(
name|ptr
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_valgrind
operator|&&
name|opt_valgrind
condition|)
name|old_rzsize
operator|=
name|config_prof
condition|?
name|p2rz
argument_list|(
name|ptr
argument_list|)
else|:
name|u2rz
argument_list|(
name|old_usize
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
block|{
name|prof_thr_cnt_t
modifier|*
name|cnt
decl_stmt|;
name|usize
operator|=
name|s2u
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|PROF_ALLOC_PREP
argument_list|(
literal|1
argument_list|,
name|usize
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|ret
operator|=
name|irealloc_prof
argument_list|(
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|usize
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|config_stats
operator|||
operator|(
name|config_valgrind
operator|&&
name|opt_valgrind
operator|)
condition|)
name|usize
operator|=
name|s2u
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|ret
operator|=
name|iralloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* realloc(NULL, size) is equivalent to malloc(size). */
name|MALLOC_BODY
argument_list|(
name|ret
argument_list|,
name|size
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|config_xmalloc
operator|&&
name|opt_xmalloc
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Error in realloc(): "
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|set_errno
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config_stats
operator|&&
name|ret
operator|!=
name|NULL
condition|)
block|{
name|thread_allocated_t
modifier|*
name|ta
decl_stmt|;
name|assert
argument_list|(
name|usize
operator|==
name|isalloc
argument_list|(
name|ret
argument_list|,
name|config_prof
argument_list|)
argument_list|)
expr_stmt|;
name|ta
operator|=
name|thread_allocated_tsd_get
argument_list|()
expr_stmt|;
name|ta
operator|->
name|allocated
operator|+=
name|usize
expr_stmt|;
name|ta
operator|->
name|deallocated
operator|+=
name|old_usize
expr_stmt|;
block|}
name|UTRACE
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|JEMALLOC_VALGRIND_REALLOC
argument_list|(
name|ret
argument_list|,
name|usize
argument_list|,
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|old_rzsize
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|je_free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|UTRACE
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
name|ifree
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * End malloc(3)-compatible functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin non-standard override functions.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_OVERRIDE_MEMALIGN
end_ifdef

begin_function
name|void
modifier|*
name|je_memalign
parameter_list|(
name|size_t
name|alignment
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
name|JEMALLOC_CC_SILENCE_INIT
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|imemalign
argument_list|(
operator|&
name|ret
argument_list|,
name|alignment
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|JEMALLOC_VALGRIND_MALLOC
argument_list|(
name|ret
operator|!=
name|NULL
argument_list|,
name|ret
argument_list|,
name|size
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_OVERRIDE_VALLOC
end_ifdef

begin_function
name|void
modifier|*
name|je_valloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
name|JEMALLOC_CC_SILENCE_INIT
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|imemalign
argument_list|(
operator|&
name|ret
argument_list|,
name|PAGE
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|JEMALLOC_VALGRIND_MALLOC
argument_list|(
name|ret
operator|!=
name|NULL
argument_list|,
name|ret
argument_list|,
name|size
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * is_malloc(je_malloc) is some macro magic to detect if jemalloc_defs.h has  * #define je_malloc malloc  */
end_comment

begin_define
define|#
directive|define
name|malloc_is_malloc
value|1
end_define

begin_define
define|#
directive|define
name|is_malloc_
parameter_list|(
name|a
parameter_list|)
value|malloc_is_ ## a
end_define

begin_define
define|#
directive|define
name|is_malloc
parameter_list|(
name|a
parameter_list|)
value|is_malloc_(a)
end_define

begin_if
if|#
directive|if
operator|(
operator|(
name|is_malloc
argument_list|(
name|je_malloc
argument_list|)
operator|==
literal|1
operator|)
operator|&&
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__UCLIBC__
argument_list|)
operator|)
end_if

begin_comment
comment|/*  * glibc provides the RTLD_DEEPBIND flag for dlopen which can make it possible  * to inconsistently reference libc's malloc(3)-compatible functions  * (https://bugzilla.mozilla.org/show_bug.cgi?id=493541).  *  * These definitions interpose hooks in glibc.  The functions are actually  * passed an extra argument for the caller return address, which will be  * ignored.  */
end_comment

begin_function_decl
name|JEMALLOC_EXPORT
name|void
function_decl|(
modifier|*
name|__free_hook
function_decl|)
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
init|=
name|je_free
function_decl|;
end_function_decl

begin_function_decl
name|JEMALLOC_EXPORT
name|void
modifier|*
function_decl|(
modifier|*
name|__malloc_hook
function_decl|)
parameter_list|(
name|size_t
name|size
parameter_list|)
init|=
name|je_malloc
function_decl|;
end_function_decl

begin_function_decl
name|JEMALLOC_EXPORT
name|void
modifier|*
function_decl|(
modifier|*
name|__realloc_hook
function_decl|)
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
init|=
name|je_realloc
function_decl|;
end_function_decl

begin_function_decl
name|JEMALLOC_EXPORT
name|void
modifier|*
function_decl|(
modifier|*
name|__memalign_hook
function_decl|)
parameter_list|(
name|size_t
name|alignment
parameter_list|,
name|size_t
name|size
parameter_list|)
init|=
name|je_memalign
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * End non-standard override functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin non-standard functions.  */
end_comment

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|void
modifier|*
name|imallocx
parameter_list|(
name|size_t
name|usize
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
name|zero
parameter_list|,
name|bool
name|try_tcache
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|assert
argument_list|(
name|usize
operator|==
operator|(
operator|(
name|alignment
operator|==
literal|0
operator|)
condition|?
name|s2u
argument_list|(
name|usize
argument_list|)
else|:
name|sa2u
argument_list|(
name|usize
argument_list|,
name|alignment
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|alignment
operator|!=
literal|0
condition|)
return|return
operator|(
name|ipalloct
argument_list|(
name|usize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|try_tcache
argument_list|,
name|arena
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|zero
condition|)
return|return
operator|(
name|icalloct
argument_list|(
name|usize
argument_list|,
name|try_tcache
argument_list|,
name|arena
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|imalloct
argument_list|(
name|usize
argument_list|,
name|try_tcache
argument_list|,
name|arena
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|imallocx_prof_sample
parameter_list|(
name|size_t
name|usize
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
name|zero
parameter_list|,
name|bool
name|try_tcache
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|prof_thr_cnt_t
modifier|*
name|cnt
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|cnt
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|prof_promote
operator|&&
name|usize
operator|<=
name|SMALL_MAXCLASS
condition|)
block|{
name|size_t
name|usize_promoted
init|=
operator|(
name|alignment
operator|==
literal|0
operator|)
condition|?
name|s2u
argument_list|(
name|SMALL_MAXCLASS
operator|+
literal|1
argument_list|)
else|:
name|sa2u
argument_list|(
name|SMALL_MAXCLASS
operator|+
literal|1
argument_list|,
name|alignment
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|usize_promoted
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|imallocx
argument_list|(
name|usize_promoted
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|try_tcache
argument_list|,
name|arena
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|arena_prof_promoted
argument_list|(
name|p
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|=
name|imallocx
argument_list|(
name|usize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|try_tcache
argument_list|,
name|arena
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|void
modifier|*
name|imallocx_prof
parameter_list|(
name|size_t
name|usize
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
name|zero
parameter_list|,
name|bool
name|try_tcache
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|prof_thr_cnt_t
modifier|*
name|cnt
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|cnt
operator|!=
operator|(
name|uintptr_t
operator|)
literal|1U
condition|)
block|{
name|p
operator|=
name|imallocx_prof_sample
argument_list|(
name|usize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|try_tcache
argument_list|,
name|arena
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|=
name|imallocx
argument_list|(
name|usize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|try_tcache
argument_list|,
name|arena
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|prof_malloc
argument_list|(
name|p
argument_list|,
name|usize
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|je_mallocx
parameter_list|(
name|size_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|size_t
name|usize
decl_stmt|;
name|size_t
name|alignment
init|=
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
operator|(
name|flags
operator|&
name|MALLOCX_LG_ALIGN_MASK
operator|)
operator|&
operator|(
name|SIZE_T_MAX
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
name|bool
name|zero
init|=
name|flags
operator|&
name|MALLOCX_ZERO
decl_stmt|;
name|unsigned
name|arena_ind
init|=
operator|(
call|(
name|unsigned
call|)
argument_list|(
name|flags
operator|>>
literal|8
argument_list|)
operator|)
operator|-
literal|1
decl_stmt|;
name|arena_t
modifier|*
name|arena
decl_stmt|;
name|bool
name|try_tcache
decl_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|malloc_init
argument_list|()
condition|)
goto|goto
name|label_oom
goto|;
if|if
condition|(
name|arena_ind
operator|!=
name|UINT_MAX
condition|)
block|{
name|arena
operator|=
name|arenas
index|[
name|arena_ind
index|]
expr_stmt|;
name|try_tcache
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|arena
operator|=
name|NULL
expr_stmt|;
name|try_tcache
operator|=
name|true
expr_stmt|;
block|}
name|usize
operator|=
operator|(
name|alignment
operator|==
literal|0
operator|)
condition|?
name|s2u
argument_list|(
name|size
argument_list|)
else|:
name|sa2u
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|usize
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
block|{
name|prof_thr_cnt_t
modifier|*
name|cnt
decl_stmt|;
name|PROF_ALLOC_PREP
argument_list|(
literal|1
argument_list|,
name|usize
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|p
operator|=
name|imallocx_prof
argument_list|(
name|usize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|try_tcache
argument_list|,
name|arena
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|=
name|imallocx
argument_list|(
name|usize
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|try_tcache
argument_list|,
name|arena
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
goto|goto
name|label_oom
goto|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|assert
argument_list|(
name|usize
operator|==
name|isalloc
argument_list|(
name|p
argument_list|,
name|config_prof
argument_list|)
argument_list|)
expr_stmt|;
name|thread_allocated_tsd_get
argument_list|()
operator|->
name|allocated
operator|+=
name|usize
expr_stmt|;
block|}
name|UTRACE
argument_list|(
literal|0
argument_list|,
name|size
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|JEMALLOC_VALGRIND_MALLOC
argument_list|(
name|true
argument_list|,
name|p
argument_list|,
name|usize
argument_list|,
name|zero
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
name|label_oom
label|:
if|if
condition|(
name|config_xmalloc
operator|&&
name|opt_xmalloc
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Error in mallocx(): out of memory\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|UTRACE
argument_list|(
literal|0
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|irallocx_prof_sample
parameter_list|(
name|void
modifier|*
name|oldptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|size_t
name|usize
parameter_list|,
name|bool
name|zero
parameter_list|,
name|bool
name|try_tcache_alloc
parameter_list|,
name|bool
name|try_tcache_dalloc
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|prof_thr_cnt_t
modifier|*
name|cnt
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|cnt
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|prof_promote
operator|&&
name|usize
operator|<=
name|SMALL_MAXCLASS
condition|)
block|{
name|p
operator|=
name|iralloct
argument_list|(
name|oldptr
argument_list|,
name|SMALL_MAXCLASS
operator|+
literal|1
argument_list|,
operator|(
name|SMALL_MAXCLASS
operator|+
literal|1
operator|>=
name|size
operator|)
condition|?
literal|0
else|:
name|size
operator|-
operator|(
name|SMALL_MAXCLASS
operator|+
literal|1
operator|)
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|try_tcache_alloc
argument_list|,
name|try_tcache_dalloc
argument_list|,
name|arena
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|arena_prof_promoted
argument_list|(
name|p
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|iralloct
argument_list|(
name|oldptr
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|try_tcache_alloc
argument_list|,
name|try_tcache_dalloc
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|void
modifier|*
name|irallocx_prof
parameter_list|(
name|void
modifier|*
name|oldptr
parameter_list|,
name|size_t
name|old_usize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|size_t
modifier|*
name|usize
parameter_list|,
name|bool
name|zero
parameter_list|,
name|bool
name|try_tcache_alloc
parameter_list|,
name|bool
name|try_tcache_dalloc
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|prof_thr_cnt_t
modifier|*
name|cnt
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|prof_ctx_t
modifier|*
name|old_ctx
decl_stmt|;
name|old_ctx
operator|=
name|prof_ctx_get
argument_list|(
name|oldptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|cnt
operator|!=
operator|(
name|uintptr_t
operator|)
literal|1U
condition|)
name|p
operator|=
name|irallocx_prof_sample
argument_list|(
name|oldptr
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|,
operator|*
name|usize
argument_list|,
name|zero
argument_list|,
name|try_tcache_alloc
argument_list|,
name|try_tcache_dalloc
argument_list|,
name|arena
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
else|else
block|{
name|p
operator|=
name|iralloct
argument_list|(
name|oldptr
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|try_tcache_alloc
argument_list|,
name|try_tcache_dalloc
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|p
operator|==
name|oldptr
operator|&&
name|alignment
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The allocation did not move, so it is possible that the size 		 * class is smaller than would guarantee the requested 		 * alignment, and that the alignment constraint was 		 * serendipitously satisfied.  Additionally, old_usize may not 		 * be the same as the current usize because of in-place large 		 * reallocation.  Therefore, query the actual value of usize. 		 */
operator|*
name|usize
operator|=
name|isalloc
argument_list|(
name|p
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
block|}
name|prof_realloc
argument_list|(
name|p
argument_list|,
operator|*
name|usize
argument_list|,
name|cnt
argument_list|,
name|old_usize
argument_list|,
name|old_ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|je_rallocx
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|size_t
name|usize
decl_stmt|,
name|old_usize
decl_stmt|;
name|UNUSED
name|size_t
name|old_rzsize
name|JEMALLOC_CC_SILENCE_INIT
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|size_t
name|alignment
init|=
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
operator|(
name|flags
operator|&
name|MALLOCX_LG_ALIGN_MASK
operator|)
operator|&
operator|(
name|SIZE_T_MAX
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
name|bool
name|zero
init|=
name|flags
operator|&
name|MALLOCX_ZERO
decl_stmt|;
name|unsigned
name|arena_ind
init|=
operator|(
call|(
name|unsigned
call|)
argument_list|(
name|flags
operator|>>
literal|8
argument_list|)
operator|)
operator|-
literal|1
decl_stmt|;
name|bool
name|try_tcache_alloc
decl_stmt|,
name|try_tcache_dalloc
decl_stmt|;
name|arena_t
modifier|*
name|arena
decl_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|malloc_initialized
operator|||
name|IS_INITIALIZER
argument_list|)
expr_stmt|;
name|malloc_thread_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|arena_ind
operator|!=
name|UINT_MAX
condition|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|try_tcache_alloc
operator|=
name|false
expr_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|try_tcache_dalloc
operator|=
operator|(
name|chunk
operator|==
name|ptr
operator|||
name|chunk
operator|->
name|arena
operator|!=
name|arenas
index|[
name|arena_ind
index|]
operator|)
expr_stmt|;
name|arena
operator|=
name|arenas
index|[
name|arena_ind
index|]
expr_stmt|;
block|}
else|else
block|{
name|try_tcache_alloc
operator|=
name|true
expr_stmt|;
name|try_tcache_dalloc
operator|=
name|true
expr_stmt|;
name|arena
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|config_prof
operator|&&
name|opt_prof
operator|)
operator|||
name|config_stats
operator|||
operator|(
name|config_valgrind
operator|&&
name|opt_valgrind
operator|)
condition|)
name|old_usize
operator|=
name|isalloc
argument_list|(
name|ptr
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_valgrind
operator|&&
name|opt_valgrind
condition|)
name|old_rzsize
operator|=
name|u2rz
argument_list|(
name|old_usize
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
block|{
name|prof_thr_cnt_t
modifier|*
name|cnt
decl_stmt|;
name|usize
operator|=
operator|(
name|alignment
operator|==
literal|0
operator|)
condition|?
name|s2u
argument_list|(
name|size
argument_list|)
else|:
name|sa2u
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|usize
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|PROF_ALLOC_PREP
argument_list|(
literal|1
argument_list|,
name|usize
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|p
operator|=
name|irallocx_prof
argument_list|(
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|,
operator|&
name|usize
argument_list|,
name|zero
argument_list|,
name|try_tcache_alloc
argument_list|,
name|try_tcache_dalloc
argument_list|,
name|arena
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
goto|goto
name|label_oom
goto|;
block|}
else|else
block|{
name|p
operator|=
name|iralloct
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|try_tcache_alloc
argument_list|,
name|try_tcache_dalloc
argument_list|,
name|arena
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
goto|goto
name|label_oom
goto|;
if|if
condition|(
name|config_stats
operator|||
operator|(
name|config_valgrind
operator|&&
name|opt_valgrind
operator|)
condition|)
name|usize
operator|=
name|isalloc
argument_list|(
name|p
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config_stats
condition|)
block|{
name|thread_allocated_t
modifier|*
name|ta
decl_stmt|;
name|ta
operator|=
name|thread_allocated_tsd_get
argument_list|()
expr_stmt|;
name|ta
operator|->
name|allocated
operator|+=
name|usize
expr_stmt|;
name|ta
operator|->
name|deallocated
operator|+=
name|old_usize
expr_stmt|;
block|}
name|UTRACE
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|JEMALLOC_VALGRIND_REALLOC
argument_list|(
name|p
argument_list|,
name|usize
argument_list|,
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|old_rzsize
argument_list|,
name|zero
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
name|label_oom
label|:
if|if
condition|(
name|config_xmalloc
operator|&&
name|opt_xmalloc
condition|)
block|{
name|malloc_write
argument_list|(
literal|"<jemalloc>: Error in rallocx(): out of memory\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|UTRACE
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|size_t
name|ixallocx_helper
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|old_usize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|extra
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|bool
name|zero
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|size_t
name|usize
decl_stmt|;
if|if
condition|(
name|ixalloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|extra
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|)
condition|)
return|return
operator|(
name|old_usize
operator|)
return|;
name|usize
operator|=
name|isalloc
argument_list|(
name|ptr
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
return|return
operator|(
name|usize
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|ixallocx_prof_sample
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|old_usize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|extra
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|size_t
name|max_usize
parameter_list|,
name|bool
name|zero
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|prof_thr_cnt_t
modifier|*
name|cnt
parameter_list|)
block|{
name|size_t
name|usize
decl_stmt|;
if|if
condition|(
name|cnt
operator|==
name|NULL
condition|)
return|return
operator|(
name|old_usize
operator|)
return|;
comment|/* Use minimum usize to determine whether promotion may happen. */
if|if
condition|(
name|prof_promote
operator|&&
operator|(
operator|(
name|alignment
operator|==
literal|0
operator|)
condition|?
name|s2u
argument_list|(
name|size
argument_list|)
else|:
name|sa2u
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
operator|)
operator|<=
name|SMALL_MAXCLASS
condition|)
block|{
if|if
condition|(
name|ixalloc
argument_list|(
name|ptr
argument_list|,
name|SMALL_MAXCLASS
operator|+
literal|1
argument_list|,
operator|(
name|SMALL_MAXCLASS
operator|+
literal|1
operator|>=
name|size
operator|+
name|extra
operator|)
condition|?
literal|0
else|:
name|size
operator|+
name|extra
operator|-
operator|(
name|SMALL_MAXCLASS
operator|+
literal|1
operator|)
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|)
condition|)
return|return
operator|(
name|old_usize
operator|)
return|;
name|usize
operator|=
name|isalloc
argument_list|(
name|ptr
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_usize
operator|<
name|PAGE
condition|)
name|arena_prof_promoted
argument_list|(
name|ptr
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usize
operator|=
name|ixallocx_helper
argument_list|(
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|size
argument_list|,
name|extra
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|usize
operator|)
return|;
block|}
end_function

begin_function
name|JEMALLOC_ALWAYS_INLINE_C
name|size_t
name|ixallocx_prof
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|old_usize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|extra
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|size_t
name|max_usize
parameter_list|,
name|bool
name|zero
parameter_list|,
name|arena_t
modifier|*
name|arena
parameter_list|,
name|prof_thr_cnt_t
modifier|*
name|cnt
parameter_list|)
block|{
name|size_t
name|usize
decl_stmt|;
name|prof_ctx_t
modifier|*
name|old_ctx
decl_stmt|;
name|old_ctx
operator|=
name|prof_ctx_get
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|cnt
operator|!=
operator|(
name|uintptr_t
operator|)
literal|1U
condition|)
block|{
name|usize
operator|=
name|ixallocx_prof_sample
argument_list|(
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|size
argument_list|,
name|extra
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|max_usize
argument_list|,
name|arena
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usize
operator|=
name|ixallocx_helper
argument_list|(
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|size
argument_list|,
name|extra
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usize
operator|==
name|old_usize
condition|)
return|return
operator|(
name|usize
operator|)
return|;
name|prof_realloc
argument_list|(
name|ptr
argument_list|,
name|usize
argument_list|,
name|cnt
argument_list|,
name|old_usize
argument_list|,
name|old_ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|usize
operator|)
return|;
block|}
end_function

begin_function
name|size_t
name|je_xallocx
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|extra
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|size_t
name|usize
decl_stmt|,
name|old_usize
decl_stmt|;
name|UNUSED
name|size_t
name|old_rzsize
name|JEMALLOC_CC_SILENCE_INIT
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|size_t
name|alignment
init|=
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
operator|(
name|flags
operator|&
name|MALLOCX_LG_ALIGN_MASK
operator|)
operator|&
operator|(
name|SIZE_T_MAX
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
name|bool
name|zero
init|=
name|flags
operator|&
name|MALLOCX_ZERO
decl_stmt|;
name|unsigned
name|arena_ind
init|=
operator|(
call|(
name|unsigned
call|)
argument_list|(
name|flags
operator|>>
literal|8
argument_list|)
operator|)
operator|-
literal|1
decl_stmt|;
name|arena_t
modifier|*
name|arena
decl_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|SIZE_T_MAX
operator|-
name|size
operator|>=
name|extra
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|malloc_initialized
operator|||
name|IS_INITIALIZER
argument_list|)
expr_stmt|;
name|malloc_thread_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|arena_ind
operator|!=
name|UINT_MAX
condition|)
name|arena
operator|=
name|arenas
index|[
name|arena_ind
index|]
expr_stmt|;
else|else
name|arena
operator|=
name|NULL
expr_stmt|;
name|old_usize
operator|=
name|isalloc
argument_list|(
name|ptr
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_valgrind
operator|&&
name|opt_valgrind
condition|)
name|old_rzsize
operator|=
name|u2rz
argument_list|(
name|old_usize
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
block|{
name|prof_thr_cnt_t
modifier|*
name|cnt
decl_stmt|;
comment|/* 		 * usize isn't knowable before ixalloc() returns when extra is 		 * non-zero.  Therefore, compute its maximum possible value and 		 * use that in PROF_ALLOC_PREP() to decide whether to capture a 		 * backtrace.  prof_realloc() will use the actual usize to 		 * decide whether to sample. 		 */
name|size_t
name|max_usize
init|=
operator|(
name|alignment
operator|==
literal|0
operator|)
condition|?
name|s2u
argument_list|(
name|size
operator|+
name|extra
argument_list|)
else|:
name|sa2u
argument_list|(
name|size
operator|+
name|extra
argument_list|,
name|alignment
argument_list|)
decl_stmt|;
name|PROF_ALLOC_PREP
argument_list|(
literal|1
argument_list|,
name|max_usize
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|usize
operator|=
name|ixallocx_prof
argument_list|(
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|size
argument_list|,
name|extra
argument_list|,
name|alignment
argument_list|,
name|max_usize
argument_list|,
name|zero
argument_list|,
name|arena
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usize
operator|=
name|ixallocx_helper
argument_list|(
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|size
argument_list|,
name|extra
argument_list|,
name|alignment
argument_list|,
name|zero
argument_list|,
name|arena
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usize
operator|==
name|old_usize
condition|)
goto|goto
name|label_not_resized
goto|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|thread_allocated_t
modifier|*
name|ta
decl_stmt|;
name|ta
operator|=
name|thread_allocated_tsd_get
argument_list|()
expr_stmt|;
name|ta
operator|->
name|allocated
operator|+=
name|usize
expr_stmt|;
name|ta
operator|->
name|deallocated
operator|+=
name|old_usize
expr_stmt|;
block|}
name|JEMALLOC_VALGRIND_REALLOC
argument_list|(
name|ptr
argument_list|,
name|usize
argument_list|,
name|ptr
argument_list|,
name|old_usize
argument_list|,
name|old_rzsize
argument_list|,
name|zero
argument_list|)
expr_stmt|;
name|label_not_resized
label|:
name|UTRACE
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|usize
operator|)
return|;
block|}
end_function

begin_function
name|size_t
name|je_sallocx
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|size_t
name|usize
decl_stmt|;
name|assert
argument_list|(
name|malloc_initialized
operator|||
name|IS_INITIALIZER
argument_list|)
expr_stmt|;
name|malloc_thread_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|config_ivsalloc
condition|)
name|usize
operator|=
name|ivsalloc
argument_list|(
name|ptr
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|usize
operator|=
name|isalloc
argument_list|(
name|ptr
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|usize
operator|)
return|;
block|}
end_function

begin_function
name|void
name|je_dallocx
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|size_t
name|usize
decl_stmt|;
name|UNUSED
name|size_t
name|rzsize
name|JEMALLOC_CC_SILENCE_INIT
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|arena_ind
init|=
operator|(
call|(
name|unsigned
call|)
argument_list|(
name|flags
operator|>>
literal|8
argument_list|)
operator|)
operator|-
literal|1
decl_stmt|;
name|bool
name|try_tcache
decl_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|malloc_initialized
operator|||
name|IS_INITIALIZER
argument_list|)
expr_stmt|;
if|if
condition|(
name|arena_ind
operator|!=
name|UINT_MAX
condition|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
init|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
name|try_tcache
operator|=
operator|(
name|chunk
operator|==
name|ptr
operator|||
name|chunk
operator|->
name|arena
operator|!=
name|arenas
index|[
name|arena_ind
index|]
operator|)
expr_stmt|;
block|}
else|else
name|try_tcache
operator|=
name|true
expr_stmt|;
name|UTRACE
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
operator|||
name|config_valgrind
condition|)
name|usize
operator|=
name|isalloc
argument_list|(
name|ptr
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_prof
operator|&&
name|opt_prof
condition|)
block|{
if|if
condition|(
name|config_stats
operator|==
name|false
operator|&&
name|config_valgrind
operator|==
name|false
condition|)
name|usize
operator|=
name|isalloc
argument_list|(
name|ptr
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
name|prof_free
argument_list|(
name|ptr
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config_stats
condition|)
name|thread_allocated_tsd_get
argument_list|()
operator|->
name|deallocated
operator|+=
name|usize
expr_stmt|;
if|if
condition|(
name|config_valgrind
operator|&&
name|opt_valgrind
condition|)
name|rzsize
operator|=
name|p2rz
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|iqalloct
argument_list|(
name|ptr
argument_list|,
name|try_tcache
argument_list|)
expr_stmt|;
name|JEMALLOC_VALGRIND_FREE
argument_list|(
name|ptr
argument_list|,
name|rzsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|je_nallocx
parameter_list|(
name|size_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|size_t
name|usize
decl_stmt|;
name|size_t
name|alignment
init|=
operator|(
name|ZU
argument_list|(
literal|1
argument_list|)
operator|<<
operator|(
name|flags
operator|&
name|MALLOCX_LG_ALIGN_MASK
operator|)
operator|&
operator|(
name|SIZE_T_MAX
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|malloc_init
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|usize
operator|=
operator|(
name|alignment
operator|==
literal|0
operator|)
condition|?
name|s2u
argument_list|(
name|size
argument_list|)
else|:
name|sa2u
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|usize
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|usize
operator|)
return|;
block|}
end_function

begin_function
name|int
name|je_mallctl
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|oldp
parameter_list|,
name|size_t
modifier|*
name|oldlenp
parameter_list|,
name|void
modifier|*
name|newp
parameter_list|,
name|size_t
name|newlen
parameter_list|)
block|{
if|if
condition|(
name|malloc_init
argument_list|()
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
return|return
operator|(
name|ctl_byname
argument_list|(
name|name
argument_list|,
name|oldp
argument_list|,
name|oldlenp
argument_list|,
name|newp
argument_list|,
name|newlen
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|je_mallctlnametomib
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
modifier|*
name|mibp
parameter_list|,
name|size_t
modifier|*
name|miblenp
parameter_list|)
block|{
if|if
condition|(
name|malloc_init
argument_list|()
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
return|return
operator|(
name|ctl_nametomib
argument_list|(
name|name
argument_list|,
name|mibp
argument_list|,
name|miblenp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|je_mallctlbymib
parameter_list|(
specifier|const
name|size_t
modifier|*
name|mib
parameter_list|,
name|size_t
name|miblen
parameter_list|,
name|void
modifier|*
name|oldp
parameter_list|,
name|size_t
modifier|*
name|oldlenp
parameter_list|,
name|void
modifier|*
name|newp
parameter_list|,
name|size_t
name|newlen
parameter_list|)
block|{
if|if
condition|(
name|malloc_init
argument_list|()
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
return|return
operator|(
name|ctl_bymib
argument_list|(
name|mib
argument_list|,
name|miblen
argument_list|,
name|oldp
argument_list|,
name|oldlenp
argument_list|,
name|newp
argument_list|,
name|newlen
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|je_malloc_stats_print
parameter_list|(
name|void
function_decl|(
modifier|*
name|write_cb
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|cbopaque
parameter_list|,
specifier|const
name|char
modifier|*
name|opts
parameter_list|)
block|{
name|stats_print
argument_list|(
name|write_cb
argument_list|,
name|cbopaque
argument_list|,
name|opts
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|je_malloc_usable_size
parameter_list|(
name|JEMALLOC_USABLE_SIZE_CONST
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|size_t
name|ret
decl_stmt|;
name|assert
argument_list|(
name|malloc_initialized
operator|||
name|IS_INITIALIZER
argument_list|)
expr_stmt|;
name|malloc_thread_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|config_ivsalloc
condition|)
name|ret
operator|=
name|ivsalloc
argument_list|(
name|ptr
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
operator|(
name|ptr
operator|!=
name|NULL
operator|)
condition|?
name|isalloc
argument_list|(
name|ptr
argument_list|,
name|config_prof
argument_list|)
else|:
literal|0
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * End non-standard functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin experimental functions.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JEMALLOC_EXPERIMENTAL
end_ifdef

begin_function
name|int
name|je_allocm
parameter_list|(
name|void
modifier|*
modifier|*
name|ptr
parameter_list|,
name|size_t
modifier|*
name|rsize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|p
operator|=
name|je_mallocx
argument_list|(
name|size
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|ALLOCM_ERR_OOM
operator|)
return|;
if|if
condition|(
name|rsize
operator|!=
name|NULL
condition|)
operator|*
name|rsize
operator|=
name|isalloc
argument_list|(
name|p
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|ALLOCM_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|je_rallocm
parameter_list|(
name|void
modifier|*
modifier|*
name|ptr
parameter_list|,
name|size_t
modifier|*
name|rsize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|extra
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|bool
name|no_move
init|=
name|flags
operator|&
name|ALLOCM_NO_MOVE
decl_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|*
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|SIZE_T_MAX
operator|-
name|size
operator|>=
name|extra
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_move
condition|)
block|{
name|size_t
name|usize
init|=
name|je_xallocx
argument_list|(
operator|*
name|ptr
argument_list|,
name|size
argument_list|,
name|extra
argument_list|,
name|flags
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|(
name|usize
operator|>=
name|size
operator|)
condition|?
name|ALLOCM_SUCCESS
else|:
name|ALLOCM_ERR_NOT_MOVED
expr_stmt|;
if|if
condition|(
name|rsize
operator|!=
name|NULL
condition|)
operator|*
name|rsize
operator|=
name|usize
expr_stmt|;
block|}
else|else
block|{
name|void
modifier|*
name|p
init|=
name|je_rallocx
argument_list|(
operator|*
name|ptr
argument_list|,
name|size
operator|+
name|extra
argument_list|,
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ptr
operator|=
name|p
expr_stmt|;
name|ret
operator|=
name|ALLOCM_SUCCESS
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|ALLOCM_ERR_OOM
expr_stmt|;
if|if
condition|(
name|rsize
operator|!=
name|NULL
condition|)
operator|*
name|rsize
operator|=
name|isalloc
argument_list|(
operator|*
name|ptr
argument_list|,
name|config_prof
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|je_sallocm
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
modifier|*
name|rsize
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|assert
argument_list|(
name|rsize
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|rsize
operator|=
name|je_sallocx
argument_list|(
name|ptr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|ALLOCM_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|je_dallocm
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|je_dallocx
argument_list|(
name|ptr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|ALLOCM_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|je_nallocm
parameter_list|(
name|size_t
modifier|*
name|rsize
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|size_t
name|usize
decl_stmt|;
name|usize
operator|=
name|je_nallocx
argument_list|(
name|size
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|usize
operator|==
literal|0
condition|)
return|return
operator|(
name|ALLOCM_ERR_OOM
operator|)
return|;
if|if
condition|(
name|rsize
operator|!=
name|NULL
condition|)
operator|*
name|rsize
operator|=
name|usize
expr_stmt|;
return|return
operator|(
name|ALLOCM_SUCCESS
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * End experimental functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * The following functions are used by threading libraries for protection of  * malloc during fork().  */
end_comment

begin_comment
comment|/*  * If an application creates a thread before doing any allocation in the main  * thread, then calls fork(2) in the main thread followed by memory allocation  * in the child process, a race can occur that results in deadlock within the  * child: the main thread may have forked while the created thread had  * partially initialized the allocator.  Ordinarily jemalloc prevents  * fork/malloc races via the following functions it registers during  * initialization using pthread_atfork(), but of course that does no good if  * the allocator isn't fully initialized at fork time.  The following library  * constructor is a partial solution to this problem.  It may still possible to  * trigger the deadlock described above, but doing so would involve forking via  * a library constructor that runs before jemalloc's runs.  */
end_comment

begin_macro
name|JEMALLOC_ATTR
argument_list|(
argument|constructor
argument_list|)
end_macro

begin_function
specifier|static
name|void
name|jemalloc_constructor
parameter_list|(
name|void
parameter_list|)
block|{
name|malloc_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|JEMALLOC_MUTEX_INIT_CB
end_ifndef

begin_decl_stmt
name|void
name|jemalloc_prefork
argument_list|(
name|void
argument_list|)
else|#
directive|else
name|JEMALLOC_EXPORT
name|void
name|_malloc_prefork
argument_list|(
name|void
argument_list|)
endif|#
directive|endif
block|{
name|unsigned
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|JEMALLOC_MUTEX_INIT_CB
if|if
condition|(
name|malloc_initialized
operator|==
name|false
condition|)
return|return;
endif|#
directive|endif
name|assert
argument_list|(
name|malloc_initialized
argument_list|)
expr_stmt|;
comment|/* Acquire all mutexes in a safe order. */
name|ctl_prefork
argument_list|()
expr_stmt|;
name|prof_prefork
argument_list|()
expr_stmt|;
name|malloc_mutex_prefork
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|narenas_total
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|arenas
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|arena_prefork
argument_list|(
name|arenas
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|chunk_prefork
argument_list|()
expr_stmt|;
name|base_prefork
argument_list|()
expr_stmt|;
name|huge_prefork
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|JEMALLOC_MUTEX_INIT_CB
end_ifndef

begin_decl_stmt
name|void
name|jemalloc_postfork_parent
argument_list|(
name|void
argument_list|)
else|#
directive|else
name|JEMALLOC_EXPORT
name|void
name|_malloc_postfork
argument_list|(
name|void
argument_list|)
endif|#
directive|endif
block|{
name|unsigned
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|JEMALLOC_MUTEX_INIT_CB
if|if
condition|(
name|malloc_initialized
operator|==
name|false
condition|)
return|return;
endif|#
directive|endif
name|assert
argument_list|(
name|malloc_initialized
argument_list|)
expr_stmt|;
comment|/* Release all mutexes, now that fork() has completed. */
name|huge_postfork_parent
argument_list|()
expr_stmt|;
name|base_postfork_parent
argument_list|()
expr_stmt|;
name|chunk_postfork_parent
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|narenas_total
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|arenas
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|arena_postfork_parent
argument_list|(
name|arenas
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_postfork_parent
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
name|prof_postfork_parent
argument_list|()
expr_stmt|;
name|ctl_postfork_parent
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
name|jemalloc_postfork_child
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|assert
argument_list|(
name|malloc_initialized
argument_list|)
expr_stmt|;
comment|/* Release all mutexes, now that fork() has completed. */
name|huge_postfork_child
argument_list|()
expr_stmt|;
name|base_postfork_child
argument_list|()
expr_stmt|;
name|chunk_postfork_child
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|narenas_total
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|arenas
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|arena_postfork_child
argument_list|(
name|arenas
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_postfork_child
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
name|prof_postfork_child
argument_list|()
expr_stmt|;
name|ctl_postfork_child
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * The following functions are used for TLS allocation/deallocation in static  * binaries on FreeBSD.  The primary difference between these and i[mcd]alloc()  * is that these avoid accessing TLS variables.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|a0alloc
parameter_list|(
name|size_t
name|size
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
if|if
condition|(
name|malloc_init
argument_list|()
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|arena_maxclass
condition|)
return|return
operator|(
name|arena_malloc
argument_list|(
name|arenas
index|[
literal|0
index|]
argument_list|,
name|size
argument_list|,
name|zero
argument_list|,
name|false
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|huge_malloc
argument_list|(
name|size
argument_list|,
name|zero
argument_list|,
name|huge_dss_prec_get
argument_list|(
name|arenas
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|a0malloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|a0alloc
argument_list|(
name|size
argument_list|,
name|false
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|a0calloc
parameter_list|(
name|size_t
name|num
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|a0alloc
argument_list|(
name|num
operator|*
name|size
argument_list|,
name|true
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|a0free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|!=
name|ptr
condition|)
name|arena_dalloc
argument_list|(
name|chunk
operator|->
name|arena
argument_list|,
name|chunk
argument_list|,
name|ptr
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
name|huge_dalloc
argument_list|(
name|ptr
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

end_unit

