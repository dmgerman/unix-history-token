begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|JEMALLOC_BASE_C_
end_define

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_internal.h"
end_include

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/* Data. */
end_comment

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|base_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|extent_tree_t
name|base_avail_szad
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|extent_node_t
modifier|*
name|base_nodes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|base_allocated
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|base_resident
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|base_mapped
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************/
end_comment

begin_function
specifier|static
name|extent_node_t
modifier|*
name|base_node_try_alloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
block|{
name|extent_node_t
modifier|*
name|node
decl_stmt|;
name|malloc_mutex_assert_owner
argument_list|(
name|tsdn
argument_list|,
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_nodes
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|node
operator|=
name|base_nodes
expr_stmt|;
name|base_nodes
operator|=
operator|*
operator|(
name|extent_node_t
operator|*
operator|*
operator|)
name|node
expr_stmt|;
name|JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED
argument_list|(
name|node
argument_list|,
sizeof|sizeof
argument_list|(
name|extent_node_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|node
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|base_node_dalloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|extent_node_t
modifier|*
name|node
parameter_list|)
block|{
name|malloc_mutex_assert_owner
argument_list|(
name|tsdn
argument_list|,
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
name|JEMALLOC_VALGRIND_MAKE_MEM_UNDEFINED
argument_list|(
name|node
argument_list|,
sizeof|sizeof
argument_list|(
name|extent_node_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|extent_node_t
operator|*
operator|*
operator|)
name|node
operator|=
name|base_nodes
expr_stmt|;
name|base_nodes
operator|=
name|node
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|extent_node_t
modifier|*
name|base_chunk_alloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|size_t
name|minsize
parameter_list|)
block|{
name|extent_node_t
modifier|*
name|node
decl_stmt|;
name|size_t
name|csize
decl_stmt|,
name|nsize
decl_stmt|;
name|void
modifier|*
name|addr
decl_stmt|;
name|malloc_mutex_assert_owner
argument_list|(
name|tsdn
argument_list|,
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|minsize
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|node
operator|=
name|base_node_try_alloc
argument_list|(
name|tsdn
argument_list|)
expr_stmt|;
comment|/* Allocate enough space to also carve a node out if necessary. */
name|nsize
operator|=
operator|(
name|node
operator|==
name|NULL
operator|)
condition|?
name|CACHELINE_CEILING
argument_list|(
sizeof|sizeof
argument_list|(
name|extent_node_t
argument_list|)
argument_list|)
else|:
literal|0
expr_stmt|;
name|csize
operator|=
name|CHUNK_CEILING
argument_list|(
name|minsize
operator|+
name|nsize
argument_list|)
expr_stmt|;
name|addr
operator|=
name|chunk_alloc_base
argument_list|(
name|csize
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|base_node_dalloc
argument_list|(
name|tsdn
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|base_mapped
operator|+=
name|csize
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
name|node
operator|=
operator|(
name|extent_node_t
operator|*
operator|)
name|addr
expr_stmt|;
name|addr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|addr
operator|+
name|nsize
operator|)
expr_stmt|;
name|csize
operator|-=
name|nsize
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|base_allocated
operator|+=
name|nsize
expr_stmt|;
name|base_resident
operator|+=
name|PAGE_CEILING
argument_list|(
name|nsize
argument_list|)
expr_stmt|;
block|}
block|}
name|extent_node_init
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|,
name|addr
argument_list|,
name|csize
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
operator|(
name|node
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * base_alloc() guarantees demand-zeroed memory, in order to make multi-page  * sparse data structures such as radix tree nodes efficient with respect to  * physical memory usage.  */
end_comment

begin_function
name|void
modifier|*
name|base_alloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|csize
decl_stmt|,
name|usize
decl_stmt|;
name|extent_node_t
modifier|*
name|node
decl_stmt|;
name|extent_node_t
name|key
decl_stmt|;
comment|/* 	 * Round size up to nearest multiple of the cacheline size, so that 	 * there is no chance of false cache line sharing. 	 */
name|csize
operator|=
name|CACHELINE_CEILING
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|usize
operator|=
name|s2u
argument_list|(
name|csize
argument_list|)
expr_stmt|;
name|extent_node_init
argument_list|(
operator|&
name|key
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|usize
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
name|node
operator|=
name|extent_tree_szad_nsearch
argument_list|(
operator|&
name|base_avail_szad
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
comment|/* Use existing space. */
name|extent_tree_szad_remove
argument_list|(
operator|&
name|base_avail_szad
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Try to allocate more space. */
name|node
operator|=
name|base_chunk_alloc
argument_list|(
name|tsdn
argument_list|,
name|csize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
name|ret
operator|=
name|extent_node_addr_get
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|extent_node_size_get
argument_list|(
name|node
argument_list|)
operator|>
name|csize
condition|)
block|{
name|extent_node_addr_set
argument_list|(
name|node
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|+
name|csize
operator|)
argument_list|)
expr_stmt|;
name|extent_node_size_set
argument_list|(
name|node
argument_list|,
name|extent_node_size_get
argument_list|(
name|node
argument_list|)
operator|-
name|csize
argument_list|)
expr_stmt|;
name|extent_tree_szad_insert
argument_list|(
operator|&
name|base_avail_szad
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|base_node_dalloc
argument_list|(
name|tsdn
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|base_allocated
operator|+=
name|csize
expr_stmt|;
comment|/* 		 * Add one PAGE to base_resident for every page boundary that is 		 * crossed by the new allocation. 		 */
name|base_resident
operator|+=
name|PAGE_CEILING
argument_list|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|+
name|csize
argument_list|)
operator|-
name|PAGE_CEILING
argument_list|(
operator|(
name|uintptr_t
operator|)
name|ret
argument_list|)
expr_stmt|;
block|}
name|JEMALLOC_VALGRIND_MAKE_MEM_DEFINED
argument_list|(
name|ret
argument_list|,
name|csize
argument_list|)
expr_stmt|;
name|label_return
label|:
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|base_stats_get
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|size_t
modifier|*
name|allocated
parameter_list|,
name|size_t
modifier|*
name|resident
parameter_list|,
name|size_t
modifier|*
name|mapped
parameter_list|)
block|{
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|base_allocated
operator|<=
name|base_resident
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|base_resident
operator|<=
name|base_mapped
argument_list|)
expr_stmt|;
operator|*
name|allocated
operator|=
name|base_allocated
expr_stmt|;
operator|*
name|resident
operator|=
name|base_resident
expr_stmt|;
operator|*
name|mapped
operator|=
name|base_mapped
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|base_boot
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|base_mtx
argument_list|,
literal|"base"
argument_list|,
name|WITNESS_RANK_BASE
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|extent_tree_szad_new
argument_list|(
operator|&
name|base_avail_szad
argument_list|)
expr_stmt|;
name|base_nodes
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
name|void
name|base_prefork
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
block|{
name|malloc_mutex_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|base_postfork_parent
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
block|{
name|malloc_mutex_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|base_postfork_child
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
block|{
name|malloc_mutex_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

