begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|JEMALLOC_BASE_C_
end_define

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_preamble.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/jemalloc_internal_includes.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/assert.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/extent_mmap.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/mutex.h"
end_include

begin_include
include|#
directive|include
file|"jemalloc/internal/sz.h"
end_include

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/* Data. */
end_comment

begin_decl_stmt
specifier|static
name|base_t
modifier|*
name|b0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************/
end_comment

begin_function
specifier|static
name|void
modifier|*
name|base_map
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|extent_hooks_t
modifier|*
name|extent_hooks
parameter_list|,
name|unsigned
name|ind
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|addr
decl_stmt|;
name|bool
name|zero
init|=
name|true
decl_stmt|;
name|bool
name|commit
init|=
name|true
decl_stmt|;
name|assert
argument_list|(
name|size
operator|==
name|HUGEPAGE_CEILING
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|extent_hooks
operator|==
operator|&
name|extent_hooks_default
condition|)
block|{
name|addr
operator|=
name|extent_alloc_mmap
argument_list|(
name|NULL
argument_list|,
name|size
argument_list|,
name|PAGE
argument_list|,
operator|&
name|zero
argument_list|,
operator|&
name|commit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No arena context as we are creating new arenas. */
name|tsd_t
modifier|*
name|tsd
init|=
name|tsdn_null
argument_list|(
name|tsdn
argument_list|)
condition|?
name|tsd_fetch
argument_list|()
else|:
name|tsdn_tsd
argument_list|(
name|tsdn
argument_list|)
decl_stmt|;
name|pre_reentrancy
argument_list|(
name|tsd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addr
operator|=
name|extent_hooks
operator|->
name|alloc
argument_list|(
name|extent_hooks
argument_list|,
name|NULL
argument_list|,
name|size
argument_list|,
name|PAGE
argument_list|,
operator|&
name|zero
argument_list|,
operator|&
name|commit
argument_list|,
name|ind
argument_list|)
expr_stmt|;
name|post_reentrancy
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
block|}
return|return
name|addr
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|base_unmap
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|extent_hooks_t
modifier|*
name|extent_hooks
parameter_list|,
name|unsigned
name|ind
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
comment|/* 	 * Cascade through dalloc, decommit, purge_forced, and purge_lazy, 	 * stopping at first success.  This cascade is performed for consistency 	 * with the cascade in extent_dalloc_wrapper() because an application's 	 * custom hooks may not support e.g. dalloc.  This function is only ever 	 * called as a side effect of arena destruction, so although it might 	 * seem pointless to do anything besides dalloc here, the application 	 * may in fact want the end state of all associated virtual memory to be 	 * in some consistent-but-allocated state. 	 */
if|if
condition|(
name|extent_hooks
operator|==
operator|&
name|extent_hooks_default
condition|)
block|{
if|if
condition|(
operator|!
name|extent_dalloc_mmap
argument_list|(
name|addr
argument_list|,
name|size
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|pages_decommit
argument_list|(
name|addr
argument_list|,
name|size
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|pages_purge_forced
argument_list|(
name|addr
argument_list|,
name|size
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|pages_purge_lazy
argument_list|(
name|addr
argument_list|,
name|size
argument_list|)
condition|)
block|{
return|return;
block|}
comment|/* Nothing worked.  This should never happen. */
name|not_reached
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|tsd_t
modifier|*
name|tsd
init|=
name|tsdn_null
argument_list|(
name|tsdn
argument_list|)
condition|?
name|tsd_fetch
argument_list|()
else|:
name|tsdn_tsd
argument_list|(
name|tsdn
argument_list|)
decl_stmt|;
name|pre_reentrancy
argument_list|(
name|tsd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|extent_hooks
operator|->
name|dalloc
operator|!=
name|NULL
operator|&&
operator|!
name|extent_hooks
operator|->
name|dalloc
argument_list|(
name|extent_hooks
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|true
argument_list|,
name|ind
argument_list|)
condition|)
block|{
goto|goto
name|label_done
goto|;
block|}
if|if
condition|(
name|extent_hooks
operator|->
name|decommit
operator|!=
name|NULL
operator|&&
operator|!
name|extent_hooks
operator|->
name|decommit
argument_list|(
name|extent_hooks
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
name|size
argument_list|,
name|ind
argument_list|)
condition|)
block|{
goto|goto
name|label_done
goto|;
block|}
if|if
condition|(
name|extent_hooks
operator|->
name|purge_forced
operator|!=
name|NULL
operator|&&
operator|!
name|extent_hooks
operator|->
name|purge_forced
argument_list|(
name|extent_hooks
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
name|size
argument_list|,
name|ind
argument_list|)
condition|)
block|{
goto|goto
name|label_done
goto|;
block|}
if|if
condition|(
name|extent_hooks
operator|->
name|purge_lazy
operator|!=
name|NULL
operator|&&
operator|!
name|extent_hooks
operator|->
name|purge_lazy
argument_list|(
name|extent_hooks
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
name|size
argument_list|,
name|ind
argument_list|)
condition|)
block|{
goto|goto
name|label_done
goto|;
block|}
comment|/* Nothing worked.  That's the application's problem. */
name|label_done
label|:
name|post_reentrancy
argument_list|(
name|tsd
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|base_extent_init
parameter_list|(
name|size_t
modifier|*
name|extent_sn_next
parameter_list|,
name|extent_t
modifier|*
name|extent
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|sn
decl_stmt|;
name|sn
operator|=
operator|*
name|extent_sn_next
expr_stmt|;
operator|(
operator|*
name|extent_sn_next
operator|)
operator|++
expr_stmt|;
name|extent_binit
argument_list|(
name|extent
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|sn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|base_extent_bump_alloc_helper
parameter_list|(
name|extent_t
modifier|*
name|extent
parameter_list|,
name|size_t
modifier|*
name|gap_size
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|alignment
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|assert
argument_list|(
name|alignment
operator|==
name|ALIGNMENT_CEILING
argument_list|(
name|alignment
argument_list|,
name|QUANTUM
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|==
name|ALIGNMENT_CEILING
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|gap_size
operator|=
name|ALIGNMENT_CEILING
argument_list|(
operator|(
name|uintptr_t
operator|)
name|extent_addr_get
argument_list|(
name|extent
argument_list|)
argument_list|,
name|alignment
argument_list|)
operator|-
operator|(
name|uintptr_t
operator|)
name|extent_addr_get
argument_list|(
name|extent
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|extent_addr_get
argument_list|(
name|extent
argument_list|)
operator|+
operator|*
name|gap_size
operator|)
expr_stmt|;
name|assert
argument_list|(
name|extent_bsize_get
argument_list|(
name|extent
argument_list|)
operator|>=
operator|*
name|gap_size
operator|+
name|size
argument_list|)
expr_stmt|;
name|extent_binit
argument_list|(
name|extent
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|extent_addr_get
argument_list|(
name|extent
argument_list|)
operator|+
operator|*
name|gap_size
operator|+
name|size
operator|)
argument_list|,
name|extent_bsize_get
argument_list|(
name|extent
argument_list|)
operator|-
operator|*
name|gap_size
operator|-
name|size
argument_list|,
name|extent_sn_get
argument_list|(
name|extent
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|base_extent_bump_alloc_post
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|base_t
modifier|*
name|base
parameter_list|,
name|extent_t
modifier|*
name|extent
parameter_list|,
name|size_t
name|gap_size
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|extent_bsize_get
argument_list|(
name|extent
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Compute the index for the largest size class that does not 		 * exceed extent's size. 		 */
name|szind_t
name|index_floor
init|=
name|sz_size2index
argument_list|(
name|extent_bsize_get
argument_list|(
name|extent
argument_list|)
operator|+
literal|1
argument_list|)
operator|-
literal|1
decl_stmt|;
name|extent_heap_insert
argument_list|(
operator|&
name|base
operator|->
name|avail
index|[
name|index_floor
index|]
argument_list|,
name|extent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config_stats
condition|)
block|{
name|base
operator|->
name|allocated
operator|+=
name|size
expr_stmt|;
comment|/* 		 * Add one PAGE to base_resident for every page boundary that is 		 * crossed by the new allocation. 		 */
name|base
operator|->
name|resident
operator|+=
name|PAGE_CEILING
argument_list|(
operator|(
name|uintptr_t
operator|)
name|addr
operator|+
name|size
argument_list|)
operator|-
name|PAGE_CEILING
argument_list|(
operator|(
name|uintptr_t
operator|)
name|addr
operator|-
name|gap_size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|base
operator|->
name|allocated
operator|<=
name|base
operator|->
name|resident
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|base
operator|->
name|resident
operator|<=
name|base
operator|->
name|mapped
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|base_extent_bump_alloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|base_t
modifier|*
name|base
parameter_list|,
name|extent_t
modifier|*
name|extent
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|alignment
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|gap_size
decl_stmt|;
name|ret
operator|=
name|base_extent_bump_alloc_helper
argument_list|(
name|extent
argument_list|,
operator|&
name|gap_size
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|base_extent_bump_alloc_post
argument_list|(
name|tsdn
argument_list|,
name|base
argument_list|,
name|extent
argument_list|,
name|gap_size
argument_list|,
name|ret
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a block of virtual memory that is large enough to start with a  * base_block_t header, followed by an object of specified size and alignment.  * On success a pointer to the initialized base_block_t header is returned.  */
end_comment

begin_function
specifier|static
name|base_block_t
modifier|*
name|base_block_alloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|extent_hooks_t
modifier|*
name|extent_hooks
parameter_list|,
name|unsigned
name|ind
parameter_list|,
name|pszind_t
modifier|*
name|pind_last
parameter_list|,
name|size_t
modifier|*
name|extent_sn_next
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|alignment
parameter_list|)
block|{
name|alignment
operator|=
name|ALIGNMENT_CEILING
argument_list|(
name|alignment
argument_list|,
name|QUANTUM
argument_list|)
expr_stmt|;
name|size_t
name|usize
init|=
name|ALIGNMENT_CEILING
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
decl_stmt|;
name|size_t
name|header_size
init|=
sizeof|sizeof
argument_list|(
name|base_block_t
argument_list|)
decl_stmt|;
name|size_t
name|gap_size
init|=
name|ALIGNMENT_CEILING
argument_list|(
name|header_size
argument_list|,
name|alignment
argument_list|)
operator|-
name|header_size
decl_stmt|;
comment|/* 	 * Create increasingly larger blocks in order to limit the total number 	 * of disjoint virtual memory ranges.  Choose the next size in the page 	 * size class series (skipping size classes that are not a multiple of 	 * HUGEPAGE), or a size large enough to satisfy the requested size and 	 * alignment, whichever is larger. 	 */
name|size_t
name|min_block_size
init|=
name|HUGEPAGE_CEILING
argument_list|(
name|sz_psz2u
argument_list|(
name|header_size
operator|+
name|gap_size
operator|+
name|usize
argument_list|)
argument_list|)
decl_stmt|;
name|pszind_t
name|pind_next
init|=
operator|(
operator|*
name|pind_last
operator|+
literal|1
operator|<
name|NPSIZES
operator|)
condition|?
operator|*
name|pind_last
operator|+
literal|1
else|:
operator|*
name|pind_last
decl_stmt|;
name|size_t
name|next_block_size
init|=
name|HUGEPAGE_CEILING
argument_list|(
name|sz_pind2sz
argument_list|(
name|pind_next
argument_list|)
argument_list|)
decl_stmt|;
name|size_t
name|block_size
init|=
operator|(
name|min_block_size
operator|>
name|next_block_size
operator|)
condition|?
name|min_block_size
else|:
name|next_block_size
decl_stmt|;
name|base_block_t
modifier|*
name|block
init|=
operator|(
name|base_block_t
operator|*
operator|)
name|base_map
argument_list|(
name|tsdn
argument_list|,
name|extent_hooks
argument_list|,
name|ind
argument_list|,
name|block_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|block
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
operator|*
name|pind_last
operator|=
name|sz_psz2ind
argument_list|(
name|block_size
argument_list|)
expr_stmt|;
name|block
operator|->
name|size
operator|=
name|block_size
expr_stmt|;
name|block
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|assert
argument_list|(
name|block_size
operator|>=
name|header_size
argument_list|)
expr_stmt|;
name|base_extent_init
argument_list|(
name|extent_sn_next
argument_list|,
operator|&
name|block
operator|->
name|extent
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|block
operator|+
name|header_size
operator|)
argument_list|,
name|block_size
operator|-
name|header_size
argument_list|)
expr_stmt|;
return|return
name|block
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate an extent that is at least as large as specified size, with  * specified alignment.  */
end_comment

begin_function
specifier|static
name|extent_t
modifier|*
name|base_extent_alloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|base_t
modifier|*
name|base
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|alignment
parameter_list|)
block|{
name|malloc_mutex_assert_owner
argument_list|(
name|tsdn
argument_list|,
operator|&
name|base
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|extent_hooks_t
modifier|*
name|extent_hooks
init|=
name|base_extent_hooks_get
argument_list|(
name|base
argument_list|)
decl_stmt|;
comment|/* 	 * Drop mutex during base_block_alloc(), because an extent hook will be 	 * called. 	 */
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|base
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|base_block_t
modifier|*
name|block
init|=
name|base_block_alloc
argument_list|(
name|tsdn
argument_list|,
name|extent_hooks
argument_list|,
name|base_ind_get
argument_list|(
name|base
argument_list|)
argument_list|,
operator|&
name|base
operator|->
name|pind_last
argument_list|,
operator|&
name|base
operator|->
name|extent_sn_next
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|)
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|base
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|block
operator|->
name|next
operator|=
name|base
operator|->
name|blocks
expr_stmt|;
name|base
operator|->
name|blocks
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|config_stats
condition|)
block|{
name|base
operator|->
name|allocated
operator|+=
sizeof|sizeof
argument_list|(
name|base_block_t
argument_list|)
expr_stmt|;
name|base
operator|->
name|resident
operator|+=
name|PAGE_CEILING
argument_list|(
sizeof|sizeof
argument_list|(
name|base_block_t
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|->
name|mapped
operator|+=
name|block
operator|->
name|size
expr_stmt|;
name|assert
argument_list|(
name|base
operator|->
name|allocated
operator|<=
name|base
operator|->
name|resident
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|base
operator|->
name|resident
operator|<=
name|base
operator|->
name|mapped
argument_list|)
expr_stmt|;
block|}
return|return
operator|&
name|block
operator|->
name|extent
return|;
block|}
end_function

begin_function
name|base_t
modifier|*
name|b0get
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|b0
return|;
block|}
end_function

begin_function
name|base_t
modifier|*
name|base_new
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|unsigned
name|ind
parameter_list|,
name|extent_hooks_t
modifier|*
name|extent_hooks
parameter_list|)
block|{
name|pszind_t
name|pind_last
init|=
literal|0
decl_stmt|;
name|size_t
name|extent_sn_next
init|=
literal|0
decl_stmt|;
name|base_block_t
modifier|*
name|block
init|=
name|base_block_alloc
argument_list|(
name|tsdn
argument_list|,
name|extent_hooks
argument_list|,
name|ind
argument_list|,
operator|&
name|pind_last
argument_list|,
operator|&
name|extent_sn_next
argument_list|,
sizeof|sizeof
argument_list|(
name|base_t
argument_list|)
argument_list|,
name|QUANTUM
argument_list|)
decl_stmt|;
if|if
condition|(
name|block
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|size_t
name|gap_size
decl_stmt|;
name|size_t
name|base_alignment
init|=
name|CACHELINE
decl_stmt|;
name|size_t
name|base_size
init|=
name|ALIGNMENT_CEILING
argument_list|(
sizeof|sizeof
argument_list|(
name|base_t
argument_list|)
argument_list|,
name|base_alignment
argument_list|)
decl_stmt|;
name|base_t
modifier|*
name|base
init|=
operator|(
name|base_t
operator|*
operator|)
name|base_extent_bump_alloc_helper
argument_list|(
operator|&
name|block
operator|->
name|extent
argument_list|,
operator|&
name|gap_size
argument_list|,
name|base_size
argument_list|,
name|base_alignment
argument_list|)
decl_stmt|;
name|base
operator|->
name|ind
operator|=
name|ind
expr_stmt|;
name|atomic_store_p
argument_list|(
operator|&
name|base
operator|->
name|extent_hooks
argument_list|,
name|extent_hooks
argument_list|,
name|ATOMIC_RELAXED
argument_list|)
expr_stmt|;
if|if
condition|(
name|malloc_mutex_init
argument_list|(
operator|&
name|base
operator|->
name|mtx
argument_list|,
literal|"base"
argument_list|,
name|WITNESS_RANK_BASE
argument_list|,
name|malloc_mutex_rank_exclusive
argument_list|)
condition|)
block|{
name|base_unmap
argument_list|(
name|tsdn
argument_list|,
name|extent_hooks
argument_list|,
name|ind
argument_list|,
name|block
argument_list|,
name|block
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|base
operator|->
name|pind_last
operator|=
name|pind_last
expr_stmt|;
name|base
operator|->
name|extent_sn_next
operator|=
name|extent_sn_next
expr_stmt|;
name|base
operator|->
name|blocks
operator|=
name|block
expr_stmt|;
for|for
control|(
name|szind_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NSIZES
condition|;
name|i
operator|++
control|)
block|{
name|extent_heap_new
argument_list|(
operator|&
name|base
operator|->
name|avail
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config_stats
condition|)
block|{
name|base
operator|->
name|allocated
operator|=
sizeof|sizeof
argument_list|(
name|base_block_t
argument_list|)
expr_stmt|;
name|base
operator|->
name|resident
operator|=
name|PAGE_CEILING
argument_list|(
sizeof|sizeof
argument_list|(
name|base_block_t
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|->
name|mapped
operator|=
name|block
operator|->
name|size
expr_stmt|;
name|assert
argument_list|(
name|base
operator|->
name|allocated
operator|<=
name|base
operator|->
name|resident
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|base
operator|->
name|resident
operator|<=
name|base
operator|->
name|mapped
argument_list|)
expr_stmt|;
block|}
name|base_extent_bump_alloc_post
argument_list|(
name|tsdn
argument_list|,
name|base
argument_list|,
operator|&
name|block
operator|->
name|extent
argument_list|,
name|gap_size
argument_list|,
name|base
argument_list|,
name|base_size
argument_list|)
expr_stmt|;
return|return
name|base
return|;
block|}
end_function

begin_function
name|void
name|base_delete
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|base_t
modifier|*
name|base
parameter_list|)
block|{
name|extent_hooks_t
modifier|*
name|extent_hooks
init|=
name|base_extent_hooks_get
argument_list|(
name|base
argument_list|)
decl_stmt|;
name|base_block_t
modifier|*
name|next
init|=
name|base
operator|->
name|blocks
decl_stmt|;
do|do
block|{
name|base_block_t
modifier|*
name|block
init|=
name|next
decl_stmt|;
name|next
operator|=
name|block
operator|->
name|next
expr_stmt|;
name|base_unmap
argument_list|(
name|tsdn
argument_list|,
name|extent_hooks
argument_list|,
name|base_ind_get
argument_list|(
name|base
argument_list|)
argument_list|,
name|block
argument_list|,
name|block
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|next
operator|!=
name|NULL
condition|)
do|;
block|}
end_function

begin_function
name|extent_hooks_t
modifier|*
name|base_extent_hooks_get
parameter_list|(
name|base_t
modifier|*
name|base
parameter_list|)
block|{
return|return
operator|(
name|extent_hooks_t
operator|*
operator|)
name|atomic_load_p
argument_list|(
operator|&
name|base
operator|->
name|extent_hooks
argument_list|,
name|ATOMIC_ACQUIRE
argument_list|)
return|;
block|}
end_function

begin_function
name|extent_hooks_t
modifier|*
name|base_extent_hooks_set
parameter_list|(
name|base_t
modifier|*
name|base
parameter_list|,
name|extent_hooks_t
modifier|*
name|extent_hooks
parameter_list|)
block|{
name|extent_hooks_t
modifier|*
name|old_extent_hooks
init|=
name|base_extent_hooks_get
argument_list|(
name|base
argument_list|)
decl_stmt|;
name|atomic_store_p
argument_list|(
operator|&
name|base
operator|->
name|extent_hooks
argument_list|,
name|extent_hooks
argument_list|,
name|ATOMIC_RELEASE
argument_list|)
expr_stmt|;
return|return
name|old_extent_hooks
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|base_alloc_impl
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|base_t
modifier|*
name|base
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|size_t
modifier|*
name|esn
parameter_list|)
block|{
name|alignment
operator|=
name|QUANTUM_CEILING
argument_list|(
name|alignment
argument_list|)
expr_stmt|;
name|size_t
name|usize
init|=
name|ALIGNMENT_CEILING
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
decl_stmt|;
name|size_t
name|asize
init|=
name|usize
operator|+
name|alignment
operator|-
name|QUANTUM
decl_stmt|;
name|extent_t
modifier|*
name|extent
init|=
name|NULL
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|base
operator|->
name|mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|szind_t
name|i
init|=
name|sz_size2index
argument_list|(
name|asize
argument_list|)
init|;
name|i
operator|<
name|NSIZES
condition|;
name|i
operator|++
control|)
block|{
name|extent
operator|=
name|extent_heap_remove_first
argument_list|(
operator|&
name|base
operator|->
name|avail
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|extent
operator|!=
name|NULL
condition|)
block|{
comment|/* Use existing space. */
break|break;
block|}
block|}
if|if
condition|(
name|extent
operator|==
name|NULL
condition|)
block|{
comment|/* Try to allocate more space. */
name|extent
operator|=
name|base_extent_alloc
argument_list|(
name|tsdn
argument_list|,
name|base
argument_list|,
name|usize
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
block|}
name|void
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|extent
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|label_return
goto|;
block|}
name|ret
operator|=
name|base_extent_bump_alloc
argument_list|(
name|tsdn
argument_list|,
name|base
argument_list|,
name|extent
argument_list|,
name|usize
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
if|if
condition|(
name|esn
operator|!=
name|NULL
condition|)
block|{
operator|*
name|esn
operator|=
name|extent_sn_get
argument_list|(
name|extent
argument_list|)
expr_stmt|;
block|}
name|label_return
label|:
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|base
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * base_alloc() returns zeroed memory, which is always demand-zeroed for the  * auto arenas, in order to make multi-page sparse data structures such as radix  * tree nodes efficient with respect to physical memory usage.  Upon success a  * pointer to at least size bytes with specified alignment is returned.  Note  * that size is rounded up to the nearest multiple of alignment to avoid false  * sharing.  */
end_comment

begin_function
name|void
modifier|*
name|base_alloc
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|base_t
modifier|*
name|base
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|alignment
parameter_list|)
block|{
return|return
name|base_alloc_impl
argument_list|(
name|tsdn
argument_list|,
name|base
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|extent_t
modifier|*
name|base_alloc_extent
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|base_t
modifier|*
name|base
parameter_list|)
block|{
name|size_t
name|esn
decl_stmt|;
name|extent_t
modifier|*
name|extent
init|=
name|base_alloc_impl
argument_list|(
name|tsdn
argument_list|,
name|base
argument_list|,
sizeof|sizeof
argument_list|(
name|extent_t
argument_list|)
argument_list|,
name|CACHELINE
argument_list|,
operator|&
name|esn
argument_list|)
decl_stmt|;
if|if
condition|(
name|extent
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|extent_esn_set
argument_list|(
name|extent
argument_list|,
name|esn
argument_list|)
expr_stmt|;
return|return
name|extent
return|;
block|}
end_function

begin_function
name|void
name|base_stats_get
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|base_t
modifier|*
name|base
parameter_list|,
name|size_t
modifier|*
name|allocated
parameter_list|,
name|size_t
modifier|*
name|resident
parameter_list|,
name|size_t
modifier|*
name|mapped
parameter_list|)
block|{
name|cassert
argument_list|(
name|config_stats
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|base
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|base
operator|->
name|allocated
operator|<=
name|base
operator|->
name|resident
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|base
operator|->
name|resident
operator|<=
name|base
operator|->
name|mapped
argument_list|)
expr_stmt|;
operator|*
name|allocated
operator|=
name|base
operator|->
name|allocated
expr_stmt|;
operator|*
name|resident
operator|=
name|base
operator|->
name|resident
expr_stmt|;
operator|*
name|mapped
operator|=
name|base
operator|->
name|mapped
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
name|tsdn
argument_list|,
operator|&
name|base
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|base_prefork
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|base_t
modifier|*
name|base
parameter_list|)
block|{
name|malloc_mutex_prefork
argument_list|(
name|tsdn
argument_list|,
operator|&
name|base
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|base_postfork_parent
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|base_t
modifier|*
name|base
parameter_list|)
block|{
name|malloc_mutex_postfork_parent
argument_list|(
name|tsdn
argument_list|,
operator|&
name|base
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|base_postfork_child
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|,
name|base_t
modifier|*
name|base
parameter_list|)
block|{
name|malloc_mutex_postfork_child
argument_list|(
name|tsdn
argument_list|,
operator|&
name|base
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|base_boot
parameter_list|(
name|tsdn_t
modifier|*
name|tsdn
parameter_list|)
block|{
name|b0
operator|=
name|base_new
argument_list|(
name|tsdn
argument_list|,
literal|0
argument_list|,
operator|(
name|extent_hooks_t
operator|*
operator|)
operator|&
name|extent_hooks_default
argument_list|)
expr_stmt|;
return|return
operator|(
name|b0
operator|==
name|NULL
operator|)
return|;
block|}
end_function

end_unit

