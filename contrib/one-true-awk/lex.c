begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright (C) Lucent Technologies 1997 All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the name Lucent Technologies or any of its entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ****************************************************************/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"awk.h"
end_include

begin_include
include|#
directive|include
file|"ytab.h"
end_include

begin_decl_stmt
specifier|extern
name|YYSTYPE
name|yylval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|infunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lineno
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bracecnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|brackcnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|parencnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|Keyword
block|{
specifier|const
name|char
modifier|*
name|word
decl_stmt|;
name|int
name|sub
decl_stmt|;
name|int
name|type
decl_stmt|;
block|}
name|Keyword
typedef|;
end_typedef

begin_decl_stmt
name|Keyword
name|keywords
index|[]
init|=
block|{
comment|/* keep sorted: binary searched */
block|{
literal|"BEGIN"
block|,
name|XBEGIN
block|,
name|XBEGIN
block|}
block|,
block|{
literal|"END"
block|,
name|XEND
block|,
name|XEND
block|}
block|,
block|{
literal|"NF"
block|,
name|VARNF
block|,
name|VARNF
block|}
block|,
block|{
literal|"atan2"
block|,
name|FATAN
block|,
name|BLTIN
block|}
block|,
block|{
literal|"break"
block|,
name|BREAK
block|,
name|BREAK
block|}
block|,
block|{
literal|"close"
block|,
name|CLOSE
block|,
name|CLOSE
block|}
block|,
block|{
literal|"continue"
block|,
name|CONTINUE
block|,
name|CONTINUE
block|}
block|,
block|{
literal|"cos"
block|,
name|FCOS
block|,
name|BLTIN
block|}
block|,
block|{
literal|"delete"
block|,
name|DELETE
block|,
name|DELETE
block|}
block|,
block|{
literal|"do"
block|,
name|DO
block|,
name|DO
block|}
block|,
block|{
literal|"else"
block|,
name|ELSE
block|,
name|ELSE
block|}
block|,
block|{
literal|"exit"
block|,
name|EXIT
block|,
name|EXIT
block|}
block|,
block|{
literal|"exp"
block|,
name|FEXP
block|,
name|BLTIN
block|}
block|,
block|{
literal|"fflush"
block|,
name|FFLUSH
block|,
name|BLTIN
block|}
block|,
block|{
literal|"for"
block|,
name|FOR
block|,
name|FOR
block|}
block|,
block|{
literal|"func"
block|,
name|FUNC
block|,
name|FUNC
block|}
block|,
block|{
literal|"function"
block|,
name|FUNC
block|,
name|FUNC
block|}
block|,
block|{
literal|"getline"
block|,
name|GETLINE
block|,
name|GETLINE
block|}
block|,
block|{
literal|"gsub"
block|,
name|GSUB
block|,
name|GSUB
block|}
block|,
block|{
literal|"if"
block|,
name|IF
block|,
name|IF
block|}
block|,
block|{
literal|"in"
block|,
name|IN
block|,
name|IN
block|}
block|,
block|{
literal|"index"
block|,
name|INDEX
block|,
name|INDEX
block|}
block|,
block|{
literal|"int"
block|,
name|FINT
block|,
name|BLTIN
block|}
block|,
block|{
literal|"length"
block|,
name|FLENGTH
block|,
name|BLTIN
block|}
block|,
block|{
literal|"log"
block|,
name|FLOG
block|,
name|BLTIN
block|}
block|,
block|{
literal|"match"
block|,
name|MATCHFCN
block|,
name|MATCHFCN
block|}
block|,
block|{
literal|"next"
block|,
name|NEXT
block|,
name|NEXT
block|}
block|,
block|{
literal|"nextfile"
block|,
name|NEXTFILE
block|,
name|NEXTFILE
block|}
block|,
block|{
literal|"print"
block|,
name|PRINT
block|,
name|PRINT
block|}
block|,
block|{
literal|"printf"
block|,
name|PRINTF
block|,
name|PRINTF
block|}
block|,
block|{
literal|"rand"
block|,
name|FRAND
block|,
name|BLTIN
block|}
block|,
block|{
literal|"return"
block|,
name|RETURN
block|,
name|RETURN
block|}
block|,
block|{
literal|"sin"
block|,
name|FSIN
block|,
name|BLTIN
block|}
block|,
block|{
literal|"split"
block|,
name|SPLIT
block|,
name|SPLIT
block|}
block|,
block|{
literal|"sprintf"
block|,
name|SPRINTF
block|,
name|SPRINTF
block|}
block|,
block|{
literal|"sqrt"
block|,
name|FSQRT
block|,
name|BLTIN
block|}
block|,
block|{
literal|"srand"
block|,
name|FSRAND
block|,
name|BLTIN
block|}
block|,
block|{
literal|"sub"
block|,
name|SUB
block|,
name|SUB
block|}
block|,
block|{
literal|"substr"
block|,
name|SUBSTR
block|,
name|SUBSTR
block|}
block|,
block|{
literal|"system"
block|,
name|FSYSTEM
block|,
name|BLTIN
block|}
block|,
block|{
literal|"tolower"
block|,
name|FTOLOWER
block|,
name|BLTIN
block|}
block|,
block|{
literal|"toupper"
block|,
name|FTOUPPER
block|,
name|BLTIN
block|}
block|,
block|{
literal|"while"
block|,
name|WHILE
block|,
name|WHILE
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEBUG
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|RET
parameter_list|(
name|x
parameter_list|)
value|{ if(dbg)printf("lex %s\n", tokname(x)); return(x); }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RET
parameter_list|(
name|x
parameter_list|)
value|return(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|peek
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
init|=
name|input
argument_list|()
decl_stmt|;
name|unput
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
name|int
name|gettok
parameter_list|(
name|char
modifier|*
modifier|*
name|pbuf
parameter_list|,
name|int
modifier|*
name|psz
parameter_list|)
comment|/* get next input token */
block|{
name|int
name|c
decl_stmt|,
name|retc
decl_stmt|;
name|char
modifier|*
name|buf
init|=
operator|*
name|pbuf
decl_stmt|;
name|int
name|sz
init|=
operator|*
name|psz
decl_stmt|;
name|char
modifier|*
name|bp
init|=
name|buf
decl_stmt|;
name|c
operator|=
name|input
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'.'
operator|&&
name|c
operator|!=
literal|'_'
condition|)
return|return
name|c
return|;
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
condition|)
block|{
comment|/* it's a varname */
for|for
control|(
init|;
operator|(
name|c
operator|=
name|input
argument_list|()
operator|)
operator|!=
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|bp
operator|-
name|buf
operator|>=
name|sz
condition|)
if|if
condition|(
operator|!
name|adjbuf
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|sz
argument_list|,
name|bp
operator|-
name|buf
operator|+
literal|2
argument_list|,
literal|100
argument_list|,
operator|&
name|bp
argument_list|,
literal|0
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"out of space for name %.10s..."
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|isalnum
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
condition|)
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
else|else
block|{
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
name|unput
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
name|retc
operator|=
literal|'a'
expr_stmt|;
comment|/* alphanumeric */
block|}
else|else
block|{
comment|/* it's a number */
name|char
modifier|*
name|rem
decl_stmt|;
comment|/* read input until can't be a number */
for|for
control|(
init|;
operator|(
name|c
operator|=
name|input
argument_list|()
operator|)
operator|!=
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|bp
operator|-
name|buf
operator|>=
name|sz
condition|)
if|if
condition|(
operator|!
name|adjbuf
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|sz
argument_list|,
name|bp
operator|-
name|buf
operator|+
literal|2
argument_list|,
literal|100
argument_list|,
operator|&
name|bp
argument_list|,
literal|0
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"out of space for number %.10s..."
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'-'
condition|)
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
else|else
block|{
name|unput
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
name|strtod
argument_list|(
name|buf
argument_list|,
operator|&
name|rem
argument_list|)
expr_stmt|;
comment|/* parse the number */
name|unputstr
argument_list|(
name|rem
argument_list|)
expr_stmt|;
comment|/* put rest back for later */
if|if
condition|(
name|rem
operator|==
name|buf
condition|)
block|{
comment|/* it wasn't a valid number at all */
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* so return one character as token */
name|retc
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
comment|/* character is its own type */
block|}
else|else
block|{
comment|/* some prefix was a number */
name|rem
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* so truncate where failure started */
name|retc
operator|=
literal|'0'
expr_stmt|;
comment|/* number */
block|}
block|}
operator|*
name|pbuf
operator|=
name|buf
expr_stmt|;
operator|*
name|psz
operator|=
name|sz
expr_stmt|;
return|return
name|retc
return|;
block|}
end_function

begin_function_decl
name|int
name|word
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|string
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|regexpr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|sc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => return a } right now */
end_comment

begin_decl_stmt
name|int
name|reg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => return a REGEXPR now */
end_comment

begin_function
name|int
name|yylex
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
specifier|static
name|char
modifier|*
name|buf
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|bufsize
init|=
literal|500
decl_stmt|;
if|if
condition|(
name|buf
operator|==
literal|0
operator|&&
operator|(
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bufsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"out of space in yylex"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
condition|)
block|{
name|sc
operator|=
literal|0
expr_stmt|;
name|RET
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg
condition|)
block|{
name|reg
operator|=
literal|0
expr_stmt|;
return|return
name|regexpr
argument_list|()
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|gettok
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
condition|)
return|return
name|word
argument_list|(
name|buf
argument_list|)
return|;
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|yylval
operator|.
name|cp
operator|=
name|setsymtab
argument_list|(
name|buf
argument_list|,
name|tostring
argument_list|(
name|buf
argument_list|)
argument_list|,
name|atof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|CON
operator||
name|NUM
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
comment|/* should this also have STR set? */
name|RET
argument_list|(
name|NUMBER
argument_list|)
expr_stmt|;
block|}
name|yylval
operator|.
name|i
operator|=
name|c
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* {EOL} */
name|RET
argument_list|(
name|NL
argument_list|)
expr_stmt|;
case|case
literal|'\r'
case|:
comment|/* assume \n is coming */
case|case
literal|' '
case|:
comment|/* {WS}+ */
case|case
literal|'\t'
case|:
break|break;
case|case
literal|'#'
case|:
comment|/* #.* strip comments */
while|while
condition|(
operator|(
name|c
operator|=
name|input
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|0
condition|)
empty_stmt|;
name|unput
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|';'
case|:
name|RET
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
case|case
literal|'\\'
case|:
if|if
condition|(
name|peek
argument_list|()
operator|==
literal|'\n'
condition|)
block|{
name|input
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peek
argument_list|()
operator|==
literal|'\r'
condition|)
block|{
name|input
argument_list|()
expr_stmt|;
name|input
argument_list|()
expr_stmt|;
comment|/* \n */
name|lineno
operator|++
expr_stmt|;
block|}
else|else
block|{
name|RET
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'&'
case|:
if|if
condition|(
name|peek
argument_list|()
operator|==
literal|'&'
condition|)
block|{
name|input
argument_list|()
expr_stmt|;
name|RET
argument_list|(
name|AND
argument_list|)
expr_stmt|;
block|}
else|else
name|RET
argument_list|(
literal|'&'
argument_list|)
expr_stmt|;
case|case
literal|'|'
case|:
if|if
condition|(
name|peek
argument_list|()
operator|==
literal|'|'
condition|)
block|{
name|input
argument_list|()
expr_stmt|;
name|RET
argument_list|(
name|BOR
argument_list|)
expr_stmt|;
block|}
else|else
name|RET
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
case|case
literal|'!'
case|:
if|if
condition|(
name|peek
argument_list|()
operator|==
literal|'='
condition|)
block|{
name|input
argument_list|()
expr_stmt|;
name|yylval
operator|.
name|i
operator|=
name|NE
expr_stmt|;
name|RET
argument_list|(
name|NE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peek
argument_list|()
operator|==
literal|'~'
condition|)
block|{
name|input
argument_list|()
expr_stmt|;
name|yylval
operator|.
name|i
operator|=
name|NOTMATCH
expr_stmt|;
name|RET
argument_list|(
name|MATCHOP
argument_list|)
expr_stmt|;
block|}
else|else
name|RET
argument_list|(
name|NOT
argument_list|)
expr_stmt|;
case|case
literal|'~'
case|:
name|yylval
operator|.
name|i
operator|=
name|MATCH
expr_stmt|;
name|RET
argument_list|(
name|MATCHOP
argument_list|)
expr_stmt|;
case|case
literal|'<'
case|:
if|if
condition|(
name|peek
argument_list|()
operator|==
literal|'='
condition|)
block|{
name|input
argument_list|()
expr_stmt|;
name|yylval
operator|.
name|i
operator|=
name|LE
expr_stmt|;
name|RET
argument_list|(
name|LE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|yylval
operator|.
name|i
operator|=
name|LT
expr_stmt|;
name|RET
argument_list|(
name|LT
argument_list|)
expr_stmt|;
block|}
case|case
literal|'='
case|:
if|if
condition|(
name|peek
argument_list|()
operator|==
literal|'='
condition|)
block|{
name|input
argument_list|()
expr_stmt|;
name|yylval
operator|.
name|i
operator|=
name|EQ
expr_stmt|;
name|RET
argument_list|(
name|EQ
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|yylval
operator|.
name|i
operator|=
name|ASSIGN
expr_stmt|;
name|RET
argument_list|(
name|ASGNOP
argument_list|)
expr_stmt|;
block|}
case|case
literal|'>'
case|:
if|if
condition|(
name|peek
argument_list|()
operator|==
literal|'='
condition|)
block|{
name|input
argument_list|()
expr_stmt|;
name|yylval
operator|.
name|i
operator|=
name|GE
expr_stmt|;
name|RET
argument_list|(
name|GE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peek
argument_list|()
operator|==
literal|'>'
condition|)
block|{
name|input
argument_list|()
expr_stmt|;
name|yylval
operator|.
name|i
operator|=
name|APPEND
expr_stmt|;
name|RET
argument_list|(
name|APPEND
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|yylval
operator|.
name|i
operator|=
name|GT
expr_stmt|;
name|RET
argument_list|(
name|GT
argument_list|)
expr_stmt|;
block|}
case|case
literal|'+'
case|:
if|if
condition|(
name|peek
argument_list|()
operator|==
literal|'+'
condition|)
block|{
name|input
argument_list|()
expr_stmt|;
name|yylval
operator|.
name|i
operator|=
name|INCR
expr_stmt|;
name|RET
argument_list|(
name|INCR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peek
argument_list|()
operator|==
literal|'='
condition|)
block|{
name|input
argument_list|()
expr_stmt|;
name|yylval
operator|.
name|i
operator|=
name|ADDEQ
expr_stmt|;
name|RET
argument_list|(
name|ASGNOP
argument_list|)
expr_stmt|;
block|}
else|else
name|RET
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
case|case
literal|'-'
case|:
if|if
condition|(
name|peek
argument_list|()
operator|==
literal|'-'
condition|)
block|{
name|input
argument_list|()
expr_stmt|;
name|yylval
operator|.
name|i
operator|=
name|DECR
expr_stmt|;
name|RET
argument_list|(
name|DECR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peek
argument_list|()
operator|==
literal|'='
condition|)
block|{
name|input
argument_list|()
expr_stmt|;
name|yylval
operator|.
name|i
operator|=
name|SUBEQ
expr_stmt|;
name|RET
argument_list|(
name|ASGNOP
argument_list|)
expr_stmt|;
block|}
else|else
name|RET
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
case|case
literal|'*'
case|:
if|if
condition|(
name|peek
argument_list|()
operator|==
literal|'='
condition|)
block|{
comment|/* *= */
name|input
argument_list|()
expr_stmt|;
name|yylval
operator|.
name|i
operator|=
name|MULTEQ
expr_stmt|;
name|RET
argument_list|(
name|ASGNOP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peek
argument_list|()
operator|==
literal|'*'
condition|)
block|{
comment|/* ** or **= */
name|input
argument_list|()
expr_stmt|;
comment|/* eat 2nd * */
if|if
condition|(
name|peek
argument_list|()
operator|==
literal|'='
condition|)
block|{
name|input
argument_list|()
expr_stmt|;
name|yylval
operator|.
name|i
operator|=
name|POWEQ
expr_stmt|;
name|RET
argument_list|(
name|ASGNOP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RET
argument_list|(
name|POWER
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|RET
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
case|case
literal|'/'
case|:
name|RET
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
case|case
literal|'%'
case|:
if|if
condition|(
name|peek
argument_list|()
operator|==
literal|'='
condition|)
block|{
name|input
argument_list|()
expr_stmt|;
name|yylval
operator|.
name|i
operator|=
name|MODEQ
expr_stmt|;
name|RET
argument_list|(
name|ASGNOP
argument_list|)
expr_stmt|;
block|}
else|else
name|RET
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
case|case
literal|'^'
case|:
if|if
condition|(
name|peek
argument_list|()
operator|==
literal|'='
condition|)
block|{
name|input
argument_list|()
expr_stmt|;
name|yylval
operator|.
name|i
operator|=
name|POWEQ
expr_stmt|;
name|RET
argument_list|(
name|ASGNOP
argument_list|)
expr_stmt|;
block|}
else|else
name|RET
argument_list|(
name|POWER
argument_list|)
expr_stmt|;
case|case
literal|'$'
case|:
comment|/* BUG: awkward, if not wrong */
name|c
operator|=
name|gettok
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"NF"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* very special */
name|unputstr
argument_list|(
literal|"(NF)"
argument_list|)
expr_stmt|;
name|RET
argument_list|(
name|INDIRECT
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|peek
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'('
operator|||
name|c
operator|==
literal|'['
operator|||
operator|(
name|infunc
operator|&&
name|isarg
argument_list|(
name|buf
argument_list|)
operator|>=
literal|0
operator|)
condition|)
block|{
name|unputstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|RET
argument_list|(
name|INDIRECT
argument_list|)
expr_stmt|;
block|}
name|yylval
operator|.
name|cp
operator|=
name|setsymtab
argument_list|(
name|buf
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|STR
operator||
name|NUM
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
name|RET
argument_list|(
name|IVAR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
comment|/*  */
name|SYNTAX
argument_list|(
literal|"unexpected end of input after $"
argument_list|)
expr_stmt|;
name|RET
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unputstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|RET
argument_list|(
name|INDIRECT
argument_list|)
expr_stmt|;
block|}
case|case
literal|'}'
case|:
if|if
condition|(
operator|--
name|bracecnt
operator|<
literal|0
condition|)
name|SYNTAX
argument_list|(
literal|"extra }"
argument_list|)
expr_stmt|;
name|sc
operator|=
literal|1
expr_stmt|;
name|RET
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
case|case
literal|']'
case|:
if|if
condition|(
operator|--
name|brackcnt
operator|<
literal|0
condition|)
name|SYNTAX
argument_list|(
literal|"extra ]"
argument_list|)
expr_stmt|;
name|RET
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
case|case
literal|')'
case|:
if|if
condition|(
operator|--
name|parencnt
operator|<
literal|0
condition|)
name|SYNTAX
argument_list|(
literal|"extra )"
argument_list|)
expr_stmt|;
name|RET
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
case|case
literal|'{'
case|:
name|bracecnt
operator|++
expr_stmt|;
name|RET
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
case|case
literal|'['
case|:
name|brackcnt
operator|++
expr_stmt|;
name|RET
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
case|case
literal|'('
case|:
name|parencnt
operator|++
expr_stmt|;
name|RET
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
case|case
literal|'"'
case|:
return|return
name|string
argument_list|()
return|;
comment|/* BUG: should be like tran.c ? */
default|default:
name|RET
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|string
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
specifier|static
name|char
modifier|*
name|buf
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|bufsz
init|=
literal|500
decl_stmt|;
if|if
condition|(
name|buf
operator|==
literal|0
operator|&&
operator|(
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bufsz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"out of space for strings"
argument_list|)
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|buf
init|;
operator|(
name|c
operator|=
name|input
argument_list|()
operator|)
operator|!=
literal|'"'
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|adjbuf
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsz
argument_list|,
name|bp
operator|-
name|buf
operator|+
literal|2
argument_list|,
literal|500
argument_list|,
operator|&
name|bp
argument_list|,
literal|0
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"out of space for string %.10s..."
argument_list|,
name|buf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
case|case
literal|0
case|:
name|SYNTAX
argument_list|(
literal|"non-terminated string %.10s..."
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
comment|/* hopeless */
name|FATAL
argument_list|(
literal|"giving up"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|c
operator|=
name|input
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'"'
case|:
operator|*
name|bp
operator|++
operator|=
literal|'"'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|bp
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|bp
operator|++
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|*
name|bp
operator|++
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|bp
operator|++
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
operator|*
name|bp
operator|++
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
operator|*
name|bp
operator|++
operator|=
literal|'\v'
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
operator|*
name|bp
operator|++
operator|=
literal|'\007'
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
operator|*
name|bp
operator|++
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
comment|/* octal: \d \dd \ddd */
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|n
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|peek
argument_list|()
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<
literal|'8'
condition|)
block|{
name|n
operator|=
literal|8
operator|*
name|n
operator|+
name|input
argument_list|()
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|peek
argument_list|()
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<
literal|'8'
condition|)
name|n
operator|=
literal|8
operator|*
name|n
operator|+
name|input
argument_list|()
operator|-
literal|'0'
expr_stmt|;
block|}
operator|*
name|bp
operator|++
operator|=
name|n
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* hex  \x0-9a-fA-F + */
block|{
name|char
name|xbuf
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|px
decl_stmt|;
for|for
control|(
name|px
operator|=
name|xbuf
init|;
operator|(
name|c
operator|=
name|input
argument_list|()
operator|)
operator|!=
literal|0
operator|&&
name|px
operator|-
name|xbuf
operator|<
literal|100
operator|-
literal|2
condition|;
control|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
operator|)
condition|)
operator|*
name|px
operator|++
operator|=
name|c
expr_stmt|;
else|else
break|break;
block|}
operator|*
name|px
operator|=
literal|0
expr_stmt|;
name|unput
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|sscanf
argument_list|(
name|xbuf
argument_list|,
literal|"%x"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
name|n
expr_stmt|;
break|break;
block|}
default|default:
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
break|break;
default|default:
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|tostring
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|0
expr_stmt|;
name|yylval
operator|.
name|cp
operator|=
name|setsymtab
argument_list|(
name|buf
argument_list|,
name|s
argument_list|,
literal|0.0
argument_list|,
name|CON
operator||
name|STR
operator||
name|DONTFREE
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
name|RET
argument_list|(
name|STRING
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|binsearch
parameter_list|(
name|char
modifier|*
name|w
parameter_list|,
name|Keyword
modifier|*
name|kp
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|cond
decl_stmt|,
name|low
decl_stmt|,
name|mid
decl_stmt|,
name|high
decl_stmt|;
name|low
operator|=
literal|0
expr_stmt|;
name|high
operator|=
name|n
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|low
operator|<=
name|high
condition|)
block|{
name|mid
operator|=
operator|(
name|low
operator|+
name|high
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|cond
operator|=
name|strcmp
argument_list|(
name|w
argument_list|,
name|kp
index|[
name|mid
index|]
operator|.
name|word
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|high
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cond
operator|>
literal|0
condition|)
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
return|return
name|mid
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|word
parameter_list|(
name|char
modifier|*
name|w
parameter_list|)
block|{
name|Keyword
modifier|*
name|kp
decl_stmt|;
name|int
name|c
decl_stmt|,
name|n
decl_stmt|;
name|n
operator|=
name|binsearch
argument_list|(
name|w
argument_list|,
name|keywords
argument_list|,
sizeof|sizeof
argument_list|(
name|keywords
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|keywords
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|kp
operator|=
name|keywords
operator|+
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* found in table */
name|yylval
operator|.
name|i
operator|=
name|kp
operator|->
name|sub
expr_stmt|;
switch|switch
condition|(
name|kp
operator|->
name|type
condition|)
block|{
comment|/* special handling */
case|case
name|FSYSTEM
case|:
if|if
condition|(
name|safe
condition|)
name|SYNTAX
argument_list|(
literal|"system is unsafe"
argument_list|)
expr_stmt|;
name|RET
argument_list|(
name|kp
operator|->
name|type
argument_list|)
expr_stmt|;
case|case
name|FUNC
case|:
if|if
condition|(
name|infunc
condition|)
name|SYNTAX
argument_list|(
literal|"illegal nested function"
argument_list|)
expr_stmt|;
name|RET
argument_list|(
name|kp
operator|->
name|type
argument_list|)
expr_stmt|;
case|case
name|RETURN
case|:
if|if
condition|(
operator|!
name|infunc
condition|)
name|SYNTAX
argument_list|(
literal|"return not in function"
argument_list|)
expr_stmt|;
name|RET
argument_list|(
name|kp
operator|->
name|type
argument_list|)
expr_stmt|;
case|case
name|VARNF
case|:
name|yylval
operator|.
name|cp
operator|=
name|setsymtab
argument_list|(
literal|"NF"
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|NUM
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
name|RET
argument_list|(
name|VARNF
argument_list|)
expr_stmt|;
default|default:
name|RET
argument_list|(
name|kp
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
block|}
name|c
operator|=
name|peek
argument_list|()
expr_stmt|;
comment|/* look for '(' */
if|if
condition|(
name|c
operator|!=
literal|'('
operator|&&
name|infunc
operator|&&
operator|(
name|n
operator|=
name|isarg
argument_list|(
name|w
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|yylval
operator|.
name|i
operator|=
name|n
expr_stmt|;
name|RET
argument_list|(
name|ARG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|yylval
operator|.
name|cp
operator|=
name|setsymtab
argument_list|(
name|w
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|STR
operator||
name|NUM
operator||
name|DONTFREE
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
block|{
name|RET
argument_list|(
name|CALL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RET
argument_list|(
name|VAR
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|startreg
parameter_list|(
name|void
parameter_list|)
comment|/* next call to yylex will return a regular expression */
block|{
name|reg
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|regexpr
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
specifier|static
name|char
modifier|*
name|buf
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|bufsz
init|=
literal|500
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|buf
operator|==
literal|0
operator|&&
operator|(
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bufsz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"out of space for rex expr"
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
for|for
control|(
init|;
operator|(
name|c
operator|=
name|input
argument_list|()
operator|)
operator|!=
literal|'/'
operator|&&
name|c
operator|!=
literal|0
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|adjbuf
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsz
argument_list|,
name|bp
operator|-
name|buf
operator|+
literal|3
argument_list|,
literal|500
argument_list|,
operator|&
name|bp
argument_list|,
literal|0
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"out of space for reg expr %.10s..."
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|SYNTAX
argument_list|(
literal|"newline in regular expression %.10s..."
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|unput
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
name|input
argument_list|()
expr_stmt|;
block|}
else|else
block|{
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|SYNTAX
argument_list|(
literal|"non-terminated regular expression %.10s..."
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|s
operator|=
name|tostring
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|unput
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|RET
argument_list|(
name|REGEXPR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* low-level lexical stuff, sort of inherited from lex */
end_comment

begin_decl_stmt
name|char
name|ebuf
index|[
literal|300
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ep
init|=
name|ebuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|yysbuf
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pushback buffer */
end_comment

begin_decl_stmt
name|char
modifier|*
name|yysptr
init|=
name|yysbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|yyin
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|input
parameter_list|(
name|void
parameter_list|)
comment|/* get next lexical input character */
block|{
name|int
name|c
decl_stmt|;
specifier|extern
name|char
modifier|*
name|lexprog
decl_stmt|;
if|if
condition|(
name|yysptr
operator|>
name|yysbuf
condition|)
name|c
operator|=
operator|*
operator|--
name|yysptr
expr_stmt|;
elseif|else
if|if
condition|(
name|lexprog
operator|!=
name|NULL
condition|)
block|{
comment|/* awk '...' */
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|lexprog
operator|)
operator|!=
literal|0
condition|)
name|lexprog
operator|++
expr_stmt|;
block|}
else|else
comment|/* awk -f ... */
name|c
operator|=
name|pgetc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ep
operator|>=
name|ebuf
operator|+
sizeof|sizeof
name|ebuf
condition|)
name|ep
operator|=
name|ebuf
expr_stmt|;
return|return
operator|*
name|ep
operator|++
operator|=
name|c
return|;
block|}
end_function

begin_function
name|void
name|unput
parameter_list|(
name|int
name|c
parameter_list|)
comment|/* put lexical character back on input */
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|--
expr_stmt|;
if|if
condition|(
name|yysptr
operator|>=
name|yysbuf
operator|+
sizeof|sizeof
argument_list|(
name|yysbuf
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"pushed back too much: %.20s..."
argument_list|,
name|yysbuf
argument_list|)
expr_stmt|;
operator|*
name|yysptr
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|--
name|ep
operator|<
name|ebuf
condition|)
name|ep
operator|=
name|ebuf
operator|+
sizeof|sizeof
argument_list|(
name|ebuf
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|unputstr
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
comment|/* put a string back on input */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|unput
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

