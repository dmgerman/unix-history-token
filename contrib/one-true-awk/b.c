begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright (C) Lucent Technologies 1997 All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the name Lucent Technologies or any of its entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ****************************************************************/
end_comment

begin_comment
comment|/* lasciate ogne speranza, voi ch'intrate. */
end_comment

begin_define
define|#
directive|define
name|DEBUG
end_define

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"awk.h"
end_include

begin_include
include|#
directive|include
file|"ytab.h"
end_include

begin_define
define|#
directive|define
name|HAT
value|(NCHARS+2)
end_define

begin_comment
comment|/* matches ^ in regular expr */
end_comment

begin_comment
comment|/* NCHARS is 2**n */
end_comment

begin_define
define|#
directive|define
name|MAXLIN
value|22
end_define

begin_define
define|#
directive|define
name|type
parameter_list|(
name|v
parameter_list|)
value|(v)->nobj
end_define

begin_comment
comment|/* badly overloaded here */
end_comment

begin_define
define|#
directive|define
name|info
parameter_list|(
name|v
parameter_list|)
value|(v)->ntype
end_define

begin_comment
comment|/* badly overloaded here */
end_comment

begin_define
define|#
directive|define
name|left
parameter_list|(
name|v
parameter_list|)
value|(v)->narg[0]
end_define

begin_define
define|#
directive|define
name|right
parameter_list|(
name|v
parameter_list|)
value|(v)->narg[1]
end_define

begin_define
define|#
directive|define
name|parent
parameter_list|(
name|v
parameter_list|)
value|(v)->nnext
end_define

begin_define
define|#
directive|define
name|LEAF
value|case CCL: case NCCL: case CHAR: case DOT: case FINAL: case ALL:
end_define

begin_define
define|#
directive|define
name|ELEAF
value|case EMPTYRE:
end_define

begin_comment
comment|/* empty string in regexp */
end_comment

begin_define
define|#
directive|define
name|UNARY
value|case STAR: case PLUS: case QUEST:
end_define

begin_comment
comment|/* encoding in tree Nodes: 	leaf (CCL, NCCL, CHAR, DOT, FINAL, ALL, EMPTYRE): 		left is index, right contains value or pointer to value 	unary (STAR, PLUS, QUEST): left is child, right is null 	binary (CAT, OR): left and right are children 	parent contains pointer to parent */
end_comment

begin_decl_stmt
name|int
modifier|*
name|setvec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|tmpset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxsetvec
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rtok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next token in current re */
end_comment

begin_decl_stmt
name|int
name|rlxval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uschar
modifier|*
name|rlxstr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uschar
modifier|*
name|prestr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current position in current re */
end_comment

begin_decl_stmt
specifier|static
name|uschar
modifier|*
name|lastre
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* origin of last re */
end_comment

begin_decl_stmt
specifier|static
name|int
name|setcnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|poscnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|patbeg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|patlen
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NFA
value|20
end_define

begin_comment
comment|/* cache this many dynamic fa's */
end_comment

begin_decl_stmt
name|fa
modifier|*
name|fatab
index|[
name|NFA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfatab
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* entries in fatab */
end_comment

begin_function
name|fa
modifier|*
name|makedfa
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|anchor
parameter_list|)
comment|/* returns dfa for reg expr s */
block|{
name|int
name|i
decl_stmt|,
name|use
decl_stmt|,
name|nuse
decl_stmt|;
name|fa
modifier|*
name|pfa
decl_stmt|;
specifier|static
name|int
name|now
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|setvec
operator|==
literal|0
condition|)
block|{
comment|/* first time through any RE */
name|maxsetvec
operator|=
name|MAXLIN
expr_stmt|;
name|setvec
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
name|maxsetvec
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|tmpset
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
name|maxsetvec
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|setvec
operator|==
literal|0
operator|||
name|tmpset
operator|==
literal|0
condition|)
name|overflo
argument_list|(
literal|"out of space initializing makedfa"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|compile_time
condition|)
comment|/* a constant for sure */
return|return
name|mkdfa
argument_list|(
name|s
argument_list|,
name|anchor
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfatab
condition|;
name|i
operator|++
control|)
comment|/* is it there already? */
if|if
condition|(
name|fatab
index|[
name|i
index|]
operator|->
name|anchor
operator|==
name|anchor
operator|&&
name|strcmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|fatab
index|[
name|i
index|]
operator|->
name|restr
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fatab
index|[
name|i
index|]
operator|->
name|use
operator|=
name|now
operator|++
expr_stmt|;
return|return
name|fatab
index|[
name|i
index|]
return|;
block|}
name|pfa
operator|=
name|mkdfa
argument_list|(
name|s
argument_list|,
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfatab
operator|<
name|NFA
condition|)
block|{
comment|/* room for another */
name|fatab
index|[
name|nfatab
index|]
operator|=
name|pfa
expr_stmt|;
name|fatab
index|[
name|nfatab
index|]
operator|->
name|use
operator|=
name|now
operator|++
expr_stmt|;
name|nfatab
operator|++
expr_stmt|;
return|return
name|pfa
return|;
block|}
name|use
operator|=
name|fatab
index|[
literal|0
index|]
operator|->
name|use
expr_stmt|;
comment|/* replace least-recently used */
name|nuse
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nfatab
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fatab
index|[
name|i
index|]
operator|->
name|use
operator|<
name|use
condition|)
block|{
name|use
operator|=
name|fatab
index|[
name|i
index|]
operator|->
name|use
expr_stmt|;
name|nuse
operator|=
name|i
expr_stmt|;
block|}
name|freefa
argument_list|(
name|fatab
index|[
name|nuse
index|]
argument_list|)
expr_stmt|;
name|fatab
index|[
name|nuse
index|]
operator|=
name|pfa
expr_stmt|;
name|pfa
operator|->
name|use
operator|=
name|now
operator|++
expr_stmt|;
return|return
name|pfa
return|;
block|}
end_function

begin_function
name|fa
modifier|*
name|mkdfa
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|anchor
parameter_list|)
comment|/* does the real work of making a dfa */
comment|/* anchor = 1 for anchored matches, else 0 */
block|{
name|Node
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|fa
modifier|*
name|f
decl_stmt|;
name|p
operator|=
name|reparse
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|p1
operator|=
name|op2
argument_list|(
name|CAT
argument_list|,
name|op2
argument_list|(
name|STAR
argument_list|,
name|op2
argument_list|(
name|ALL
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|)
argument_list|,
name|NIL
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* put ALL STAR in front of reg.  exp. */
name|p1
operator|=
name|op2
argument_list|(
name|CAT
argument_list|,
name|p1
argument_list|,
name|op2
argument_list|(
name|FINAL
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* put FINAL after reg.  exp. */
name|poscnt
operator|=
literal|0
expr_stmt|;
name|penter
argument_list|(
name|p1
argument_list|)
expr_stmt|;
comment|/* enter parent pointers and leaf indices */
if|if
condition|(
operator|(
name|f
operator|=
operator|(
name|fa
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|fa
argument_list|)
operator|+
name|poscnt
operator|*
sizeof|sizeof
argument_list|(
name|rrow
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|overflo
argument_list|(
literal|"out of space for fa"
argument_list|)
expr_stmt|;
name|f
operator|->
name|accept
operator|=
name|poscnt
operator|-
literal|1
expr_stmt|;
comment|/* penter has computed number of positions in re */
name|cfoll
argument_list|(
name|f
argument_list|,
name|p1
argument_list|)
expr_stmt|;
comment|/* set up follow sets */
name|freetr
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|->
name|posns
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
operator|*
operator|(
name|f
operator|->
name|re
index|[
literal|0
index|]
operator|.
name|lfollow
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|overflo
argument_list|(
literal|"out of space in makedfa"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|->
name|posns
index|[
literal|1
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|overflo
argument_list|(
literal|"out of space in makedfa"
argument_list|)
expr_stmt|;
operator|*
name|f
operator|->
name|posns
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|initstat
operator|=
name|makeinit
argument_list|(
name|f
argument_list|,
name|anchor
argument_list|)
expr_stmt|;
name|f
operator|->
name|anchor
operator|=
name|anchor
expr_stmt|;
name|f
operator|->
name|restr
operator|=
operator|(
name|uschar
operator|*
operator|)
name|tostring
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_function
name|int
name|makeinit
parameter_list|(
name|fa
modifier|*
name|f
parameter_list|,
name|int
name|anchor
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|f
operator|->
name|curstat
operator|=
literal|2
expr_stmt|;
name|f
operator|->
name|out
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|reset
operator|=
literal|0
expr_stmt|;
name|k
operator|=
operator|*
operator|(
name|f
operator|->
name|re
index|[
literal|0
index|]
operator|.
name|lfollow
operator|)
expr_stmt|;
name|xfree
argument_list|(
name|f
operator|->
name|posns
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|->
name|posns
index|[
literal|2
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
operator|(
name|k
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|overflo
argument_list|(
literal|"out of space in makeinit"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|k
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|f
operator|->
name|posns
index|[
literal|2
index|]
operator|)
index|[
name|i
index|]
operator|=
operator|(
name|f
operator|->
name|re
index|[
literal|0
index|]
operator|.
name|lfollow
operator|)
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|f
operator|->
name|posns
index|[
literal|2
index|]
operator|)
index|[
literal|1
index|]
operator|==
name|f
operator|->
name|accept
condition|)
name|f
operator|->
name|out
index|[
literal|2
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHARS
condition|;
name|i
operator|++
control|)
name|f
operator|->
name|gototab
index|[
literal|2
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|curstat
operator|=
name|cgoto
argument_list|(
name|f
argument_list|,
literal|2
argument_list|,
name|HAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|anchor
condition|)
block|{
operator|*
name|f
operator|->
name|posns
index|[
literal|2
index|]
operator|=
name|k
operator|-
literal|1
expr_stmt|;
comment|/* leave out position 0 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|k
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|f
operator|->
name|posns
index|[
literal|0
index|]
operator|)
index|[
name|i
index|]
operator|=
operator|(
name|f
operator|->
name|posns
index|[
literal|2
index|]
operator|)
index|[
name|i
index|]
expr_stmt|;
block|}
name|f
operator|->
name|out
index|[
literal|0
index|]
operator|=
name|f
operator|->
name|out
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|curstat
operator|!=
literal|2
condition|)
operator|--
operator|(
operator|*
name|f
operator|->
name|posns
index|[
name|f
operator|->
name|curstat
index|]
operator|)
expr_stmt|;
block|}
return|return
name|f
operator|->
name|curstat
return|;
block|}
end_function

begin_function
name|void
name|penter
parameter_list|(
name|Node
modifier|*
name|p
parameter_list|)
comment|/* set up parent pointers and leaf indices */
block|{
switch|switch
condition|(
name|type
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|ELEAF
name|LEAF
name|info
parameter_list|(
name|p
parameter_list|)
init|=
name|poscnt
function_decl|;
name|poscnt
operator|++
expr_stmt|;
break|break;
name|UNARY
name|penter
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|parent
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
operator|=
name|p
expr_stmt|;
break|break;
case|case
name|CAT
case|:
case|case
name|OR
case|:
name|penter
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|penter
argument_list|(
name|right
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|parent
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
operator|=
name|p
expr_stmt|;
name|parent
argument_list|(
name|right
argument_list|(
name|p
argument_list|)
argument_list|)
operator|=
name|p
expr_stmt|;
break|break;
default|default:
comment|/* can't happen */
name|FATAL
argument_list|(
literal|"can't happen: unknown type %d in penter"
argument_list|,
name|type
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|freetr
parameter_list|(
name|Node
modifier|*
name|p
parameter_list|)
comment|/* free parse tree */
block|{
switch|switch
condition|(
name|type
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|ELEAF
name|LEAF
name|xfree
argument_list|(
name|p
argument_list|)
decl_stmt|;
break|break;
name|UNARY
name|freetr
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|xfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAT
case|:
case|case
name|OR
case|:
name|freetr
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|freetr
argument_list|(
name|right
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* can't happen */
name|FATAL
argument_list|(
literal|"can't happen: unknown type %d in freetr"
argument_list|,
name|type
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* in the parsing of regular expressions, metacharacters like . have */
end_comment

begin_comment
comment|/* to be seen literally;  \056 is not a metacharacter. */
end_comment

begin_function
name|int
name|hexstr
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|)
comment|/* find and eval hex string at pp, return new p */
block|{
comment|/* only pick up one 8-bit byte (2 chars) */
name|uschar
modifier|*
name|p
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
operator|(
name|uschar
operator|*
operator|)
operator|*
name|pp
init|;
name|i
operator|<
literal|2
operator|&&
name|isxdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|n
operator|=
literal|16
operator|*
name|n
operator|+
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|>=
literal|'a'
operator|&&
operator|*
name|p
operator|<=
literal|'f'
condition|)
name|n
operator|=
literal|16
operator|*
name|n
operator|+
operator|*
name|p
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|>=
literal|'A'
operator|&&
operator|*
name|p
operator|<=
literal|'F'
condition|)
name|n
operator|=
literal|16
operator|*
name|n
operator|+
operator|*
name|p
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
block|}
operator|*
name|pp
operator|=
operator|(
name|char
operator|*
operator|)
name|p
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_define
define|#
directive|define
name|isoctdigit
parameter_list|(
name|c
parameter_list|)
value|((c)>= '0'&& (c)<= '7')
end_define

begin_comment
comment|/* multiple use of arg */
end_comment

begin_function
name|int
name|quoted
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|)
comment|/* pick up next thing after a \\ */
comment|/* and increment *pp */
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
literal|'t'
condition|)
name|c
operator|=
literal|'\t'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'n'
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'f'
condition|)
name|c
operator|=
literal|'\f'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'r'
condition|)
name|c
operator|=
literal|'\r'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'b'
condition|)
name|c
operator|=
literal|'\b'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
literal|'\\'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'x'
condition|)
block|{
comment|/* hexadecimal goo follows */
name|c
operator|=
name|hexstr
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* this adds a null if number is invalid */
block|}
elseif|else
if|if
condition|(
name|isoctdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* \d \dd \ddd */
name|int
name|n
init|=
name|c
operator|-
literal|'0'
decl_stmt|;
if|if
condition|(
name|isoctdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|n
operator|=
literal|8
operator|*
name|n
operator|+
operator|*
name|p
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|isoctdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|n
operator|=
literal|8
operator|*
name|n
operator|+
operator|*
name|p
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
name|c
operator|=
name|n
expr_stmt|;
block|}
comment|/* else */
comment|/* c = c; */
operator|*
name|pp
operator|=
name|p
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|cclenter
parameter_list|(
specifier|const
name|char
modifier|*
name|argp
parameter_list|)
comment|/* add a character class */
block|{
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|c2
decl_stmt|;
name|uschar
modifier|*
name|p
init|=
operator|(
name|uschar
operator|*
operator|)
name|argp
decl_stmt|;
name|uschar
modifier|*
name|op
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
specifier|static
name|uschar
modifier|*
name|buf
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|bufsz
init|=
literal|100
decl_stmt|;
name|op
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|buf
operator|==
literal|0
operator|&&
operator|(
name|buf
operator|=
operator|(
name|uschar
operator|*
operator|)
name|malloc
argument_list|(
name|bufsz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"out of space for character class [%.10s...] 1"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|quoted
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'-'
operator|&&
name|i
operator|>
literal|0
operator|&&
name|bp
index|[
operator|-
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
block|{
name|c
operator|=
name|bp
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|c2
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c2
operator|==
literal|'\\'
condition|)
name|c2
operator|=
name|quoted
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
name|c2
condition|)
block|{
comment|/* empty; ignore */
name|bp
operator|--
expr_stmt|;
name|i
operator|--
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
name|c
operator|<
name|c2
condition|)
block|{
if|if
condition|(
operator|!
name|adjbuf
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|buf
argument_list|,
operator|&
name|bufsz
argument_list|,
name|bp
operator|-
name|buf
operator|+
literal|2
argument_list|,
literal|100
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|bp
argument_list|,
literal|"cclenter1"
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"out of space for character class [%.10s...] 2"
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
operator|++
name|c
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
block|}
if|if
condition|(
operator|!
name|adjbuf
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|buf
argument_list|,
operator|&
name|bufsz
argument_list|,
name|bp
operator|-
name|buf
operator|+
literal|2
argument_list|,
literal|100
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|bp
argument_list|,
literal|"cclenter2"
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"out of space for character class [%.10s...] 3"
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"cclenter: in = |%s|, out = |%s|\n"
operator|,
name|op
operator|,
name|buf
operator|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|tostring
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|overflo
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|FATAL
argument_list|(
literal|"regular expression too big: %.30s..."
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cfoll
parameter_list|(
name|fa
modifier|*
name|f
parameter_list|,
name|Node
modifier|*
name|v
parameter_list|)
comment|/* enter follow set of each leaf of vertex v into lfollow[leaf] */
block|{
name|int
name|i
decl_stmt|;
name|int
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|type
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|ELEAF
name|LEAF
name|f
operator|->
name|re
index|[
name|info
argument_list|(
name|v
argument_list|)
index|]
operator|.
name|ltype
operator|=
name|type
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|f
operator|->
name|re
index|[
name|info
argument_list|(
name|v
argument_list|)
index|]
operator|.
name|lval
operator|.
name|np
operator|=
name|right
argument_list|(
name|v
argument_list|)
expr_stmt|;
while|while
condition|(
name|f
operator|->
name|accept
operator|>=
name|maxsetvec
condition|)
block|{
comment|/* guessing here! */
name|maxsetvec
operator|*=
literal|4
expr_stmt|;
name|setvec
operator|=
operator|(
name|int
operator|*
operator|)
name|realloc
argument_list|(
name|setvec
argument_list|,
name|maxsetvec
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|tmpset
operator|=
operator|(
name|int
operator|*
operator|)
name|realloc
argument_list|(
name|tmpset
argument_list|,
name|maxsetvec
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|setvec
operator|==
literal|0
operator|||
name|tmpset
operator|==
literal|0
condition|)
name|overflo
argument_list|(
literal|"out of space in cfoll()"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|f
operator|->
name|accept
condition|;
name|i
operator|++
control|)
name|setvec
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|setcnt
operator|=
literal|0
expr_stmt|;
name|follow
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/* computes setvec and setcnt */
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|int
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
operator|(
name|setcnt
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|overflo
argument_list|(
literal|"out of space building follow set"
argument_list|)
expr_stmt|;
name|f
operator|->
name|re
index|[
name|info
argument_list|(
name|v
argument_list|)
index|]
operator|.
name|lfollow
operator|=
name|p
expr_stmt|;
operator|*
name|p
operator|=
name|setcnt
expr_stmt|;
for|for
control|(
name|i
operator|=
name|f
operator|->
name|accept
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|setvec
index|[
name|i
index|]
operator|==
literal|1
condition|)
operator|*
operator|++
name|p
operator|=
name|i
expr_stmt|;
break|break;
name|UNARY
name|cfoll
argument_list|(
name|f
argument_list|,
name|left
argument_list|(
name|v
argument_list|)
argument_list|)
decl_stmt|;
break|break;
case|case
name|CAT
case|:
case|case
name|OR
case|:
name|cfoll
argument_list|(
name|f
argument_list|,
name|left
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|cfoll
argument_list|(
name|f
argument_list|,
name|right
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* can't happen */
name|FATAL
argument_list|(
literal|"can't happen: unknown type %d in cfoll"
argument_list|,
name|type
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|first
parameter_list|(
name|Node
modifier|*
name|p
parameter_list|)
comment|/* collects initially active leaves of p into setvec */
comment|/* returns 0 if p matches empty string */
block|{
name|int
name|b
decl_stmt|,
name|lp
decl_stmt|;
switch|switch
condition|(
name|type
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|ELEAF
name|LEAF
name|lp
init|=
name|info
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|/* look for high-water mark of subscripts */
while|while
condition|(
name|setcnt
operator|>=
name|maxsetvec
operator|||
name|lp
operator|>=
name|maxsetvec
condition|)
block|{
comment|/* guessing here! */
name|maxsetvec
operator|*=
literal|4
expr_stmt|;
name|setvec
operator|=
operator|(
name|int
operator|*
operator|)
name|realloc
argument_list|(
name|setvec
argument_list|,
name|maxsetvec
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|tmpset
operator|=
operator|(
name|int
operator|*
operator|)
name|realloc
argument_list|(
name|tmpset
argument_list|,
name|maxsetvec
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|setvec
operator|==
literal|0
operator|||
name|tmpset
operator|==
literal|0
condition|)
name|overflo
argument_list|(
literal|"out of space in first()"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
argument_list|(
name|p
argument_list|)
operator|==
name|EMPTYRE
condition|)
block|{
name|setvec
index|[
name|lp
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|setvec
index|[
name|lp
index|]
operator|!=
literal|1
condition|)
block|{
name|setvec
index|[
name|lp
index|]
operator|=
literal|1
expr_stmt|;
name|setcnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|type
argument_list|(
name|p
argument_list|)
operator|==
name|CCL
operator|&&
operator|(
operator|*
operator|(
name|char
operator|*
operator|)
name|right
argument_list|(
name|p
argument_list|)
operator|)
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* empty CCL */
else|else
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|PLUS
case|:
if|if
condition|(
name|first
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|STAR
case|:
case|case
name|QUEST
case|:
name|first
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CAT
case|:
if|if
condition|(
name|first
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|first
argument_list|(
name|right
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|OR
case|:
name|b
operator|=
name|first
argument_list|(
name|right
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|b
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|FATAL
argument_list|(
literal|"can't happen: unknown type %d in first"
argument_list|,
name|type
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* can't happen */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|follow
parameter_list|(
name|Node
modifier|*
name|v
parameter_list|)
comment|/* collects leaves that can follow v into setvec */
block|{
name|Node
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|type
argument_list|(
name|v
argument_list|)
operator|==
name|FINAL
condition|)
return|return;
name|p
operator|=
name|parent
argument_list|(
name|v
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|STAR
case|:
case|case
name|PLUS
case|:
name|first
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|follow
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|OR
case|:
case|case
name|QUEST
case|:
name|follow
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|CAT
case|:
if|if
condition|(
name|v
operator|==
name|left
argument_list|(
name|p
argument_list|)
condition|)
block|{
comment|/* v is left child of p */
if|if
condition|(
name|first
argument_list|(
name|right
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|follow
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
comment|/* v is right child */
name|follow
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
name|int
name|member
parameter_list|(
name|int
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|sarg
parameter_list|)
comment|/* is c in s? */
block|{
name|uschar
modifier|*
name|s
init|=
operator|(
name|uschar
operator|*
operator|)
name|sarg
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
if|if
condition|(
name|c
operator|==
operator|*
name|s
operator|++
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|match
parameter_list|(
name|fa
modifier|*
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|p0
parameter_list|)
comment|/* shortest match ? */
block|{
name|int
name|s
decl_stmt|,
name|ns
decl_stmt|;
name|uschar
modifier|*
name|p
init|=
operator|(
name|uschar
operator|*
operator|)
name|p0
decl_stmt|;
name|s
operator|=
name|f
operator|->
name|reset
condition|?
name|makeinit
argument_list|(
name|f
argument_list|,
literal|0
argument_list|)
else|:
name|f
operator|->
name|initstat
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|out
index|[
name|s
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
do|do
block|{
comment|/* assert(*p< NCHARS); */
if|if
condition|(
operator|(
name|ns
operator|=
name|f
operator|->
name|gototab
index|[
name|s
index|]
index|[
operator|*
name|p
index|]
operator|)
operator|!=
literal|0
condition|)
name|s
operator|=
name|ns
expr_stmt|;
else|else
name|s
operator|=
name|cgoto
argument_list|(
name|f
argument_list|,
name|s
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|out
index|[
name|s
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
do|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|0
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pmatch
parameter_list|(
name|fa
modifier|*
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|p0
parameter_list|)
comment|/* longest match, for sub */
block|{
name|int
name|s
decl_stmt|,
name|ns
decl_stmt|;
name|uschar
modifier|*
name|p
init|=
operator|(
name|uschar
operator|*
operator|)
name|p0
decl_stmt|;
name|uschar
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
comment|/* s = f->reset ? makeinit(f,1) : f->initstat; */
if|if
condition|(
name|f
operator|->
name|reset
condition|)
block|{
name|f
operator|->
name|initstat
operator|=
name|s
operator|=
name|makeinit
argument_list|(
name|f
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|f
operator|->
name|initstat
expr_stmt|;
block|}
name|patbeg
operator|=
operator|(
name|char
operator|*
operator|)
name|p
expr_stmt|;
name|patlen
operator|=
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|q
operator|=
name|p
expr_stmt|;
do|do
block|{
if|if
condition|(
name|f
operator|->
name|out
index|[
name|s
index|]
condition|)
comment|/* final state */
name|patlen
operator|=
name|q
operator|-
name|p
expr_stmt|;
comment|/* assert(*q< NCHARS); */
if|if
condition|(
operator|(
name|ns
operator|=
name|f
operator|->
name|gototab
index|[
name|s
index|]
index|[
operator|*
name|q
index|]
operator|)
operator|!=
literal|0
condition|)
name|s
operator|=
name|ns
expr_stmt|;
else|else
name|s
operator|=
name|cgoto
argument_list|(
name|f
argument_list|,
name|s
argument_list|,
operator|*
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|1
condition|)
block|{
comment|/* no transition */
if|if
condition|(
name|patlen
operator|>=
literal|0
condition|)
block|{
name|patbeg
operator|=
operator|(
name|char
operator|*
operator|)
name|p
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
goto|goto
name|nextin
goto|;
comment|/* no match */
block|}
block|}
do|while
condition|(
operator|*
name|q
operator|++
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|f
operator|->
name|out
index|[
name|s
index|]
condition|)
name|patlen
operator|=
name|q
operator|-
name|p
operator|-
literal|1
expr_stmt|;
comment|/* don't count $ */
if|if
condition|(
name|patlen
operator|>=
literal|0
condition|)
block|{
name|patbeg
operator|=
operator|(
name|char
operator|*
operator|)
name|p
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|nextin
label|:
name|s
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|reset
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<=
name|f
operator|->
name|curstat
condition|;
name|i
operator|++
control|)
name|xfree
argument_list|(
name|f
operator|->
name|posns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|k
operator|=
operator|*
name|f
operator|->
name|posns
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|->
name|posns
index|[
literal|2
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
operator|(
name|k
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|overflo
argument_list|(
literal|"out of space in pmatch"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|k
condition|;
name|i
operator|++
control|)
operator|(
name|f
operator|->
name|posns
index|[
literal|2
index|]
operator|)
index|[
name|i
index|]
operator|=
operator|(
name|f
operator|->
name|posns
index|[
literal|0
index|]
operator|)
index|[
name|i
index|]
expr_stmt|;
name|f
operator|->
name|initstat
operator|=
name|f
operator|->
name|curstat
operator|=
literal|2
expr_stmt|;
name|f
operator|->
name|out
index|[
literal|2
index|]
operator|=
name|f
operator|->
name|out
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHARS
condition|;
name|i
operator|++
control|)
name|f
operator|->
name|gototab
index|[
literal|2
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|0
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nematch
parameter_list|(
name|fa
modifier|*
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|p0
parameter_list|)
comment|/* non-empty match, for sub */
block|{
name|int
name|s
decl_stmt|,
name|ns
decl_stmt|;
name|uschar
modifier|*
name|p
init|=
operator|(
name|uschar
operator|*
operator|)
name|p0
decl_stmt|;
name|uschar
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
comment|/* s = f->reset ? makeinit(f,1) : f->initstat; */
if|if
condition|(
name|f
operator|->
name|reset
condition|)
block|{
name|f
operator|->
name|initstat
operator|=
name|s
operator|=
name|makeinit
argument_list|(
name|f
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|f
operator|->
name|initstat
expr_stmt|;
block|}
name|patlen
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|q
operator|=
name|p
expr_stmt|;
do|do
block|{
if|if
condition|(
name|f
operator|->
name|out
index|[
name|s
index|]
condition|)
comment|/* final state */
name|patlen
operator|=
name|q
operator|-
name|p
expr_stmt|;
comment|/* assert(*q< NCHARS); */
if|if
condition|(
operator|(
name|ns
operator|=
name|f
operator|->
name|gototab
index|[
name|s
index|]
index|[
operator|*
name|q
index|]
operator|)
operator|!=
literal|0
condition|)
name|s
operator|=
name|ns
expr_stmt|;
else|else
name|s
operator|=
name|cgoto
argument_list|(
name|f
argument_list|,
name|s
argument_list|,
operator|*
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|1
condition|)
block|{
comment|/* no transition */
if|if
condition|(
name|patlen
operator|>
literal|0
condition|)
block|{
name|patbeg
operator|=
operator|(
name|char
operator|*
operator|)
name|p
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
goto|goto
name|nnextin
goto|;
comment|/* no nonempty match */
block|}
block|}
do|while
condition|(
operator|*
name|q
operator|++
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|f
operator|->
name|out
index|[
name|s
index|]
condition|)
name|patlen
operator|=
name|q
operator|-
name|p
operator|-
literal|1
expr_stmt|;
comment|/* don't count $ */
if|if
condition|(
name|patlen
operator|>
literal|0
condition|)
block|{
name|patbeg
operator|=
operator|(
name|char
operator|*
operator|)
name|p
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|nnextin
label|:
name|s
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|reset
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<=
name|f
operator|->
name|curstat
condition|;
name|i
operator|++
control|)
name|xfree
argument_list|(
name|f
operator|->
name|posns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|k
operator|=
operator|*
name|f
operator|->
name|posns
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|->
name|posns
index|[
literal|2
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
operator|(
name|k
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|overflo
argument_list|(
literal|"out of state space"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|k
condition|;
name|i
operator|++
control|)
operator|(
name|f
operator|->
name|posns
index|[
literal|2
index|]
operator|)
index|[
name|i
index|]
operator|=
operator|(
name|f
operator|->
name|posns
index|[
literal|0
index|]
operator|)
index|[
name|i
index|]
expr_stmt|;
name|f
operator|->
name|initstat
operator|=
name|f
operator|->
name|curstat
operator|=
literal|2
expr_stmt|;
name|f
operator|->
name|out
index|[
literal|2
index|]
operator|=
name|f
operator|->
name|out
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHARS
condition|;
name|i
operator|++
control|)
name|f
operator|->
name|gototab
index|[
literal|2
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|Node
modifier|*
name|reparse
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
comment|/* parses regular expression pointed to by p */
block|{
comment|/* uses relex() to scan regular expression */
name|Node
modifier|*
name|np
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"reparse<%s>\n"
operator|,
name|p
operator|)
argument_list|)
expr_stmt|;
name|lastre
operator|=
name|prestr
operator|=
operator|(
name|uschar
operator|*
operator|)
name|p
expr_stmt|;
comment|/* prestr points to string to be parsed */
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
comment|/* GNU compatibility: an empty regexp matches anything */
if|if
condition|(
name|rtok
operator|==
literal|'\0'
condition|)
block|{
comment|/* FATAL("empty regular expression"); previous */
return|return
operator|(
name|op2
argument_list|(
name|EMPTYRE
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|)
operator|)
return|;
block|}
name|np
operator|=
name|regexp
argument_list|()
expr_stmt|;
if|if
condition|(
name|rtok
operator|!=
literal|'\0'
condition|)
name|FATAL
argument_list|(
literal|"syntax error in regular expression %s at %s"
argument_list|,
name|lastre
argument_list|,
name|prestr
argument_list|)
expr_stmt|;
return|return
operator|(
name|np
operator|)
return|;
block|}
end_function

begin_function
name|Node
modifier|*
name|regexp
parameter_list|(
name|void
parameter_list|)
comment|/* top-level parse of reg expr */
block|{
return|return
operator|(
name|alt
argument_list|(
name|concat
argument_list|(
name|primary
argument_list|()
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|Node
modifier|*
name|primary
parameter_list|(
name|void
parameter_list|)
block|{
name|Node
modifier|*
name|np
decl_stmt|;
switch|switch
condition|(
name|rtok
condition|)
block|{
case|case
name|CHAR
case|:
name|np
operator|=
name|op2
argument_list|(
name|CHAR
argument_list|,
name|NIL
argument_list|,
name|itonp
argument_list|(
name|rlxval
argument_list|)
argument_list|)
expr_stmt|;
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
return|return
operator|(
name|unary
argument_list|(
name|np
argument_list|)
operator|)
return|;
case|case
name|ALL
case|:
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
return|return
operator|(
name|unary
argument_list|(
name|op2
argument_list|(
name|ALL
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|EMPTYRE
case|:
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
return|return
operator|(
name|unary
argument_list|(
name|op2
argument_list|(
name|ALL
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|DOT
case|:
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
return|return
operator|(
name|unary
argument_list|(
name|op2
argument_list|(
name|DOT
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|CCL
case|:
name|np
operator|=
name|op2
argument_list|(
name|CCL
argument_list|,
name|NIL
argument_list|,
operator|(
name|Node
operator|*
operator|)
name|cclenter
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rlxstr
argument_list|)
argument_list|)
expr_stmt|;
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
return|return
operator|(
name|unary
argument_list|(
name|np
argument_list|)
operator|)
return|;
case|case
name|NCCL
case|:
name|np
operator|=
name|op2
argument_list|(
name|NCCL
argument_list|,
name|NIL
argument_list|,
operator|(
name|Node
operator|*
operator|)
name|cclenter
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rlxstr
argument_list|)
argument_list|)
expr_stmt|;
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
return|return
operator|(
name|unary
argument_list|(
name|np
argument_list|)
operator|)
return|;
case|case
literal|'^'
case|:
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
return|return
operator|(
name|unary
argument_list|(
name|op2
argument_list|(
name|CHAR
argument_list|,
name|NIL
argument_list|,
name|itonp
argument_list|(
name|HAT
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
case|case
literal|'$'
case|:
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
return|return
operator|(
name|unary
argument_list|(
name|op2
argument_list|(
name|CHAR
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|)
argument_list|)
operator|)
return|;
case|case
literal|'('
case|:
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
if|if
condition|(
name|rtok
operator|==
literal|')'
condition|)
block|{
comment|/* special pleading for () */
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
return|return
name|unary
argument_list|(
name|op2
argument_list|(
name|CCL
argument_list|,
name|NIL
argument_list|,
operator|(
name|Node
operator|*
operator|)
name|tostring
argument_list|(
literal|""
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|np
operator|=
name|regexp
argument_list|()
expr_stmt|;
if|if
condition|(
name|rtok
operator|==
literal|')'
condition|)
block|{
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
return|return
operator|(
name|unary
argument_list|(
name|np
argument_list|)
operator|)
return|;
block|}
else|else
name|FATAL
argument_list|(
literal|"syntax error in regular expression %s at %s"
argument_list|,
name|lastre
argument_list|,
name|prestr
argument_list|)
expr_stmt|;
default|default:
name|FATAL
argument_list|(
literal|"illegal primary in regular expression %s at %s"
argument_list|,
name|lastre
argument_list|,
name|prestr
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/*NOTREACHED*/
block|}
end_function

begin_function
name|Node
modifier|*
name|concat
parameter_list|(
name|Node
modifier|*
name|np
parameter_list|)
block|{
switch|switch
condition|(
name|rtok
condition|)
block|{
case|case
name|CHAR
case|:
case|case
name|DOT
case|:
case|case
name|ALL
case|:
case|case
name|EMPTYRE
case|:
case|case
name|CCL
case|:
case|case
name|NCCL
case|:
case|case
literal|'$'
case|:
case|case
literal|'('
case|:
return|return
operator|(
name|concat
argument_list|(
name|op2
argument_list|(
name|CAT
argument_list|,
name|np
argument_list|,
name|primary
argument_list|()
argument_list|)
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|np
operator|)
return|;
block|}
end_function

begin_function
name|Node
modifier|*
name|alt
parameter_list|(
name|Node
modifier|*
name|np
parameter_list|)
block|{
if|if
condition|(
name|rtok
operator|==
name|OR
condition|)
block|{
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
return|return
operator|(
name|alt
argument_list|(
name|op2
argument_list|(
name|OR
argument_list|,
name|np
argument_list|,
name|concat
argument_list|(
name|primary
argument_list|()
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|np
operator|)
return|;
block|}
end_function

begin_function
name|Node
modifier|*
name|unary
parameter_list|(
name|Node
modifier|*
name|np
parameter_list|)
block|{
switch|switch
condition|(
name|rtok
condition|)
block|{
case|case
name|STAR
case|:
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
return|return
operator|(
name|unary
argument_list|(
name|op2
argument_list|(
name|STAR
argument_list|,
name|np
argument_list|,
name|NIL
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|PLUS
case|:
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
return|return
operator|(
name|unary
argument_list|(
name|op2
argument_list|(
name|PLUS
argument_list|,
name|np
argument_list|,
name|NIL
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|QUEST
case|:
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
return|return
operator|(
name|unary
argument_list|(
name|op2
argument_list|(
name|QUEST
argument_list|,
name|np
argument_list|,
name|NIL
argument_list|)
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|np
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Character class definitions conformant to the POSIX locale as  * defined in IEEE P1003.1 draft 7 of June 2001, assuming the source  * and operating character sets are both ASCII (ISO646) or supersets  * thereof.  *  * Note that to avoid overflowing the temporary buffer used in  * relex(), the expanded character class (prior to range expansion)  * must be less than twice the size of their full name.  */
end_comment

begin_comment
comment|/* Because isblank doesn't show up in any of the header files on any  * system i use, it's defined here.  if some other locale has a richer  * definition of "blank", define HAS_ISBLANK and provide your own  * version.  * the parentheses here are an attempt to find a path through the maze  * of macro definition and/or function and/or version provided.  thanks  * to nelson beebe for the suggestion; let's see if it works everywhere.  */
end_comment

begin_comment
comment|/* #define HAS_ISBLANK */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAS_ISBLANK
end_ifndef

begin_function
name|int
function|(
name|isblank
function|)
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|charclass
block|{
specifier|const
name|char
modifier|*
name|cc_name
decl_stmt|;
name|int
name|cc_namelen
decl_stmt|;
name|int
function_decl|(
modifier|*
name|cc_func
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
block|}
name|charclasses
index|[]
init|=
block|{
block|{
literal|"alnum"
block|,
literal|5
block|,
name|isalnum
block|}
block|,
block|{
literal|"alpha"
block|,
literal|5
block|,
name|isalpha
block|}
block|,
block|{
literal|"blank"
block|,
literal|5
block|,
name|isblank
block|}
block|,
block|{
literal|"cntrl"
block|,
literal|5
block|,
name|iscntrl
block|}
block|,
block|{
literal|"digit"
block|,
literal|5
block|,
name|isdigit
block|}
block|,
block|{
literal|"graph"
block|,
literal|5
block|,
name|isgraph
block|}
block|,
block|{
literal|"lower"
block|,
literal|5
block|,
name|islower
block|}
block|,
block|{
literal|"print"
block|,
literal|5
block|,
name|isprint
block|}
block|,
block|{
literal|"punct"
block|,
literal|5
block|,
name|ispunct
block|}
block|,
block|{
literal|"space"
block|,
literal|5
block|,
name|isspace
block|}
block|,
block|{
literal|"upper"
block|,
literal|5
block|,
name|isupper
block|}
block|,
block|{
literal|"xdigit"
block|,
literal|6
block|,
name|isxdigit
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|, }
struct|;
end_struct

begin_function
name|int
name|relex
parameter_list|(
name|void
parameter_list|)
comment|/* lexical analyzer for reparse */
block|{
name|int
name|c
decl_stmt|,
name|n
decl_stmt|;
name|int
name|cflag
decl_stmt|;
specifier|static
name|uschar
modifier|*
name|buf
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|bufsz
init|=
literal|100
decl_stmt|;
name|uschar
modifier|*
name|bp
decl_stmt|;
name|struct
name|charclass
modifier|*
name|cc
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|c
operator|=
operator|*
name|prestr
operator|++
condition|)
block|{
case|case
literal|'|'
case|:
return|return
name|OR
return|;
case|case
literal|'*'
case|:
return|return
name|STAR
return|;
case|case
literal|'+'
case|:
return|return
name|PLUS
return|;
case|case
literal|'?'
case|:
return|return
name|QUEST
return|;
case|case
literal|'.'
case|:
return|return
name|DOT
return|;
case|case
literal|'\0'
case|:
name|prestr
operator|--
expr_stmt|;
return|return
literal|'\0'
return|;
case|case
literal|'^'
case|:
case|case
literal|'$'
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
return|return
name|c
return|;
case|case
literal|'\\'
case|:
name|rlxval
operator|=
name|quoted
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|prestr
argument_list|)
expr_stmt|;
return|return
name|CHAR
return|;
default|default:
name|rlxval
operator|=
name|c
expr_stmt|;
return|return
name|CHAR
return|;
case|case
literal|'['
case|:
if|if
condition|(
name|buf
operator|==
literal|0
operator|&&
operator|(
name|buf
operator|=
operator|(
name|uschar
operator|*
operator|)
name|malloc
argument_list|(
name|bufsz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"out of space in reg expr %.10s.."
argument_list|,
name|lastre
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|*
name|prestr
operator|==
literal|'^'
condition|)
block|{
name|cflag
operator|=
literal|1
expr_stmt|;
name|prestr
operator|++
expr_stmt|;
block|}
else|else
name|cflag
operator|=
literal|0
expr_stmt|;
name|n
operator|=
literal|2
operator|*
name|strlen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|prestr
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|adjbuf
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|buf
argument_list|,
operator|&
name|bufsz
argument_list|,
name|n
argument_list|,
name|n
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|bp
argument_list|,
literal|"relex1"
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"out of space for reg expr %.10s..."
argument_list|,
name|lastre
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|prestr
operator|++
operator|)
operator|==
literal|'\\'
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
literal|'\\'
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|prestr
operator|++
operator|)
operator|==
literal|'\0'
condition|)
name|FATAL
argument_list|(
literal|"nonterminated character class %.20s..."
argument_list|,
name|lastre
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
comment|/* } else if (c == '\n') { */
comment|/* 	FATAL("newline in character class %.20s...", lastre); */
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'['
operator|&&
operator|*
name|prestr
operator|==
literal|':'
condition|)
block|{
comment|/* POSIX char class names, Dag-Erling Smorgrav, des@ofug.org */
for|for
control|(
name|cc
operator|=
name|charclasses
init|;
name|cc
operator|->
name|cc_name
condition|;
name|cc
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|prestr
operator|+
literal|1
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|cc
operator|->
name|cc_name
argument_list|,
name|cc
operator|->
name|cc_namelen
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|cc
operator|->
name|cc_name
operator|!=
name|NULL
operator|&&
name|prestr
index|[
literal|1
operator|+
name|cc
operator|->
name|cc_namelen
index|]
operator|==
literal|':'
operator|&&
name|prestr
index|[
literal|2
operator|+
name|cc
operator|->
name|cc_namelen
index|]
operator|==
literal|']'
condition|)
block|{
name|prestr
operator|+=
name|cc
operator|->
name|cc_namelen
operator|+
literal|3
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHARS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|adjbuf
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|buf
argument_list|,
operator|&
name|bufsz
argument_list|,
name|bp
operator|-
name|buf
operator|+
literal|1
argument_list|,
literal|100
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|bp
argument_list|,
literal|"relex2"
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"out of space for reg expr %.10s..."
argument_list|,
name|lastre
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|->
name|cc_func
argument_list|(
name|i
argument_list|)
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
name|i
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|FATAL
argument_list|(
literal|"nonterminated character class %.20s"
argument_list|,
name|lastre
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bp
operator|==
name|buf
condition|)
block|{
comment|/* 1st char is special */
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|']'
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
literal|0
expr_stmt|;
name|rlxstr
operator|=
operator|(
name|uschar
operator|*
operator|)
name|tostring
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|cflag
operator|==
literal|0
condition|)
return|return
name|CCL
return|;
else|else
return|return
name|NCCL
return|;
block|}
else|else
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|cgoto
parameter_list|(
name|fa
modifier|*
name|f
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|assert
argument_list|(
name|c
operator|==
name|HAT
operator|||
name|c
operator|<
name|NCHARS
argument_list|)
expr_stmt|;
while|while
condition|(
name|f
operator|->
name|accept
operator|>=
name|maxsetvec
condition|)
block|{
comment|/* guessing here! */
name|maxsetvec
operator|*=
literal|4
expr_stmt|;
name|setvec
operator|=
operator|(
name|int
operator|*
operator|)
name|realloc
argument_list|(
name|setvec
argument_list|,
name|maxsetvec
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|tmpset
operator|=
operator|(
name|int
operator|*
operator|)
name|realloc
argument_list|(
name|tmpset
argument_list|,
name|maxsetvec
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|setvec
operator|==
literal|0
operator|||
name|tmpset
operator|==
literal|0
condition|)
name|overflo
argument_list|(
literal|"out of space in cgoto()"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|f
operator|->
name|accept
condition|;
name|i
operator|++
control|)
name|setvec
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|setcnt
operator|=
literal|0
expr_stmt|;
comment|/* compute positions of gototab[s,c] into setvec */
name|p
operator|=
name|f
operator|->
name|posns
index|[
name|s
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
operator|*
name|p
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|k
operator|=
name|f
operator|->
name|re
index|[
name|p
index|[
name|i
index|]
index|]
operator|.
name|ltype
operator|)
operator|!=
name|FINAL
condition|)
block|{
if|if
condition|(
operator|(
name|k
operator|==
name|CHAR
operator|&&
name|c
operator|==
name|ptoi
argument_list|(
name|f
operator|->
name|re
index|[
name|p
index|[
name|i
index|]
index|]
operator|.
name|lval
operator|.
name|np
argument_list|)
operator|)
operator|||
operator|(
name|k
operator|==
name|DOT
operator|&&
name|c
operator|!=
literal|0
operator|&&
name|c
operator|!=
name|HAT
operator|)
operator|||
operator|(
name|k
operator|==
name|ALL
operator|&&
name|c
operator|!=
literal|0
operator|)
operator|||
operator|(
name|k
operator|==
name|EMPTYRE
operator|&&
name|c
operator|!=
literal|0
operator|)
operator|||
operator|(
name|k
operator|==
name|CCL
operator|&&
name|member
argument_list|(
name|c
argument_list|,
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|re
index|[
name|p
index|[
name|i
index|]
index|]
operator|.
name|lval
operator|.
name|up
argument_list|)
operator|)
operator|||
operator|(
name|k
operator|==
name|NCCL
operator|&&
operator|!
name|member
argument_list|(
name|c
argument_list|,
operator|(
name|char
operator|*
operator|)
name|f
operator|->
name|re
index|[
name|p
index|[
name|i
index|]
index|]
operator|.
name|lval
operator|.
name|up
argument_list|)
operator|&&
name|c
operator|!=
literal|0
operator|&&
name|c
operator|!=
name|HAT
operator|)
condition|)
block|{
name|q
operator|=
name|f
operator|->
name|re
index|[
name|p
index|[
name|i
index|]
index|]
operator|.
name|lfollow
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
operator|*
name|q
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|q
index|[
name|j
index|]
operator|>=
name|maxsetvec
condition|)
block|{
name|maxsetvec
operator|*=
literal|4
expr_stmt|;
name|setvec
operator|=
operator|(
name|int
operator|*
operator|)
name|realloc
argument_list|(
name|setvec
argument_list|,
name|maxsetvec
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|tmpset
operator|=
operator|(
name|int
operator|*
operator|)
name|realloc
argument_list|(
name|tmpset
argument_list|,
name|maxsetvec
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|setvec
operator|==
literal|0
operator|||
name|tmpset
operator|==
literal|0
condition|)
name|overflo
argument_list|(
literal|"cgoto overflow"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setvec
index|[
name|q
index|[
name|j
index|]
index|]
operator|==
literal|0
condition|)
block|{
name|setcnt
operator|++
expr_stmt|;
name|setvec
index|[
name|q
index|[
name|j
index|]
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* determine if setvec is a previous state */
name|tmpset
index|[
literal|0
index|]
operator|=
name|setcnt
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|f
operator|->
name|accept
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|setvec
index|[
name|i
index|]
condition|)
block|{
name|tmpset
index|[
name|j
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
comment|/* tmpset == previous state? */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|f
operator|->
name|curstat
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|f
operator|->
name|posns
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|=
name|tmpset
index|[
literal|0
index|]
operator|)
operator|!=
name|p
index|[
literal|0
index|]
condition|)
goto|goto
name|different
goto|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|k
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|tmpset
index|[
name|j
index|]
operator|!=
name|p
index|[
name|j
index|]
condition|)
goto|goto
name|different
goto|;
comment|/* setvec is state i */
name|f
operator|->
name|gototab
index|[
name|s
index|]
index|[
name|c
index|]
operator|=
name|i
expr_stmt|;
return|return
name|i
return|;
name|different
label|:
empty_stmt|;
block|}
comment|/* add tmpset to current set of states */
if|if
condition|(
name|f
operator|->
name|curstat
operator|>=
name|NSTATES
operator|-
literal|1
condition|)
block|{
name|f
operator|->
name|curstat
operator|=
literal|2
expr_stmt|;
name|f
operator|->
name|reset
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|NSTATES
condition|;
name|i
operator|++
control|)
name|xfree
argument_list|(
name|f
operator|->
name|posns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
operator|++
operator|(
name|f
operator|->
name|curstat
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHARS
condition|;
name|i
operator|++
control|)
name|f
operator|->
name|gototab
index|[
name|f
operator|->
name|curstat
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|xfree
argument_list|(
name|f
operator|->
name|posns
index|[
name|f
operator|->
name|curstat
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|int
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
operator|(
name|setcnt
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|overflo
argument_list|(
literal|"out of space in cgoto"
argument_list|)
expr_stmt|;
name|f
operator|->
name|posns
index|[
name|f
operator|->
name|curstat
index|]
operator|=
name|p
expr_stmt|;
name|f
operator|->
name|gototab
index|[
name|s
index|]
index|[
name|c
index|]
operator|=
name|f
operator|->
name|curstat
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|setcnt
condition|;
name|i
operator|++
control|)
name|p
index|[
name|i
index|]
operator|=
name|tmpset
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|setvec
index|[
name|f
operator|->
name|accept
index|]
condition|)
name|f
operator|->
name|out
index|[
name|f
operator|->
name|curstat
index|]
operator|=
literal|1
expr_stmt|;
else|else
name|f
operator|->
name|out
index|[
name|f
operator|->
name|curstat
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|f
operator|->
name|curstat
return|;
block|}
end_function

begin_function
name|void
name|freefa
parameter_list|(
name|fa
modifier|*
name|f
parameter_list|)
comment|/* free a finite automaton */
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|f
operator|->
name|curstat
condition|;
name|i
operator|++
control|)
name|xfree
argument_list|(
name|f
operator|->
name|posns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|f
operator|->
name|accept
condition|;
name|i
operator|++
control|)
block|{
name|xfree
argument_list|(
name|f
operator|->
name|re
index|[
name|i
index|]
operator|.
name|lfollow
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|re
index|[
name|i
index|]
operator|.
name|ltype
operator|==
name|CCL
operator|||
name|f
operator|->
name|re
index|[
name|i
index|]
operator|.
name|ltype
operator|==
name|NCCL
condition|)
name|xfree
argument_list|(
operator|(
name|f
operator|->
name|re
index|[
name|i
index|]
operator|.
name|lval
operator|.
name|np
operator|)
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
name|f
operator|->
name|restr
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

