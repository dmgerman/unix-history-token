begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright (C) Lucent Technologies 1997 All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the name Lucent Technologies or any of its entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ****************************************************************/
end_comment

begin_define
define|#
directive|define
name|DEBUG
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"awk.h"
end_include

begin_include
include|#
directive|include
file|"ytab.h"
end_include

begin_define
define|#
directive|define
name|FULLTAB
value|2
end_define

begin_comment
comment|/* rehash when table gets this x full */
end_comment

begin_define
define|#
directive|define
name|GROWTAB
value|4
end_define

begin_comment
comment|/* grow table by this factor */
end_comment

begin_decl_stmt
name|Array
modifier|*
name|symtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* main symbol table */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|FS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initial field sep */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|RS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initial record sep */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|OFS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output field sep */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|ORS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output record sep */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|OFMT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output format for numbers */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|CONVFMT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* format for conversions in getsval */
end_comment

begin_decl_stmt
name|Awkfloat
modifier|*
name|NF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of fields in current record */
end_comment

begin_decl_stmt
name|Awkfloat
modifier|*
name|NR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of current record */
end_comment

begin_decl_stmt
name|Awkfloat
modifier|*
name|FNR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of current record in current file */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|FILENAME
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current filename argument */
end_comment

begin_decl_stmt
name|Awkfloat
modifier|*
name|ARGC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of arguments from command line */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|SUBSEP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* subscript separator for a[i,j,k]; default \034 */
end_comment

begin_decl_stmt
name|Awkfloat
modifier|*
name|RSTART
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start of re matched with ~; origin 1 (!) */
end_comment

begin_decl_stmt
name|Awkfloat
modifier|*
name|RLENGTH
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of same */
end_comment

begin_decl_stmt
name|Cell
modifier|*
name|nrloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NR */
end_comment

begin_decl_stmt
name|Cell
modifier|*
name|nfloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NF */
end_comment

begin_decl_stmt
name|Cell
modifier|*
name|fnrloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FNR */
end_comment

begin_decl_stmt
name|Array
modifier|*
name|ARGVtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* symbol table containing ARGV[...] */
end_comment

begin_decl_stmt
name|Array
modifier|*
name|ENVtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* symbol table containing ENVIRON[...] */
end_comment

begin_decl_stmt
name|Cell
modifier|*
name|rstartloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RSTART */
end_comment

begin_decl_stmt
name|Cell
modifier|*
name|rlengthloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RLENGTH */
end_comment

begin_decl_stmt
name|Cell
modifier|*
name|symtabloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SYMTAB */
end_comment

begin_decl_stmt
name|Cell
modifier|*
name|nullloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a guaranteed empty cell */
end_comment

begin_decl_stmt
name|Node
modifier|*
name|nullnode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* zero&null, converted into a node for comparisons */
end_comment

begin_decl_stmt
name|Cell
modifier|*
name|literal0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Cell
modifier|*
modifier|*
name|fldtab
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|syminit
parameter_list|(
name|void
parameter_list|)
comment|/* initialize symbol table with builtin vars */
block|{
name|literal0
operator|=
name|setsymtab
argument_list|(
literal|"0"
argument_list|,
literal|"0"
argument_list|,
literal|0.0
argument_list|,
name|NUM
operator||
name|STR
operator||
name|CON
operator||
name|DONTFREE
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
comment|/* this is used for if(x)... tests: */
name|nullloc
operator|=
name|setsymtab
argument_list|(
literal|"$zero&null"
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|NUM
operator||
name|STR
operator||
name|CON
operator||
name|DONTFREE
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
name|nullnode
operator|=
name|celltonode
argument_list|(
name|nullloc
argument_list|,
name|CCON
argument_list|)
expr_stmt|;
name|FS
operator|=
operator|&
name|setsymtab
argument_list|(
literal|"FS"
argument_list|,
literal|" "
argument_list|,
literal|0.0
argument_list|,
name|STR
operator||
name|DONTFREE
argument_list|,
name|symtab
argument_list|)
operator|->
name|sval
expr_stmt|;
name|RS
operator|=
operator|&
name|setsymtab
argument_list|(
literal|"RS"
argument_list|,
literal|"\n"
argument_list|,
literal|0.0
argument_list|,
name|STR
operator||
name|DONTFREE
argument_list|,
name|symtab
argument_list|)
operator|->
name|sval
expr_stmt|;
name|OFS
operator|=
operator|&
name|setsymtab
argument_list|(
literal|"OFS"
argument_list|,
literal|" "
argument_list|,
literal|0.0
argument_list|,
name|STR
operator||
name|DONTFREE
argument_list|,
name|symtab
argument_list|)
operator|->
name|sval
expr_stmt|;
name|ORS
operator|=
operator|&
name|setsymtab
argument_list|(
literal|"ORS"
argument_list|,
literal|"\n"
argument_list|,
literal|0.0
argument_list|,
name|STR
operator||
name|DONTFREE
argument_list|,
name|symtab
argument_list|)
operator|->
name|sval
expr_stmt|;
name|OFMT
operator|=
operator|&
name|setsymtab
argument_list|(
literal|"OFMT"
argument_list|,
literal|"%.6g"
argument_list|,
literal|0.0
argument_list|,
name|STR
operator||
name|DONTFREE
argument_list|,
name|symtab
argument_list|)
operator|->
name|sval
expr_stmt|;
name|CONVFMT
operator|=
operator|&
name|setsymtab
argument_list|(
literal|"CONVFMT"
argument_list|,
literal|"%.6g"
argument_list|,
literal|0.0
argument_list|,
name|STR
operator||
name|DONTFREE
argument_list|,
name|symtab
argument_list|)
operator|->
name|sval
expr_stmt|;
name|FILENAME
operator|=
operator|&
name|setsymtab
argument_list|(
literal|"FILENAME"
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|STR
operator||
name|DONTFREE
argument_list|,
name|symtab
argument_list|)
operator|->
name|sval
expr_stmt|;
name|nfloc
operator|=
name|setsymtab
argument_list|(
literal|"NF"
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|NUM
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
name|NF
operator|=
operator|&
name|nfloc
operator|->
name|fval
expr_stmt|;
name|nrloc
operator|=
name|setsymtab
argument_list|(
literal|"NR"
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|NUM
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
name|NR
operator|=
operator|&
name|nrloc
operator|->
name|fval
expr_stmt|;
name|fnrloc
operator|=
name|setsymtab
argument_list|(
literal|"FNR"
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|NUM
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
name|FNR
operator|=
operator|&
name|fnrloc
operator|->
name|fval
expr_stmt|;
name|SUBSEP
operator|=
operator|&
name|setsymtab
argument_list|(
literal|"SUBSEP"
argument_list|,
literal|"\034"
argument_list|,
literal|0.0
argument_list|,
name|STR
operator||
name|DONTFREE
argument_list|,
name|symtab
argument_list|)
operator|->
name|sval
expr_stmt|;
name|rstartloc
operator|=
name|setsymtab
argument_list|(
literal|"RSTART"
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|NUM
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
name|RSTART
operator|=
operator|&
name|rstartloc
operator|->
name|fval
expr_stmt|;
name|rlengthloc
operator|=
name|setsymtab
argument_list|(
literal|"RLENGTH"
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|NUM
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
name|RLENGTH
operator|=
operator|&
name|rlengthloc
operator|->
name|fval
expr_stmt|;
name|symtabloc
operator|=
name|setsymtab
argument_list|(
literal|"SYMTAB"
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|ARR
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
name|symtabloc
operator|->
name|sval
operator|=
operator|(
name|char
operator|*
operator|)
name|symtab
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arginit
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
comment|/* set up ARGV and ARGC */
block|{
name|Cell
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|temp
index|[
literal|50
index|]
decl_stmt|;
name|ARGC
operator|=
operator|&
name|setsymtab
argument_list|(
literal|"ARGC"
argument_list|,
literal|""
argument_list|,
operator|(
name|Awkfloat
operator|)
name|ac
argument_list|,
name|NUM
argument_list|,
name|symtab
argument_list|)
operator|->
name|fval
expr_stmt|;
name|cp
operator|=
name|setsymtab
argument_list|(
literal|"ARGV"
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|ARR
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
name|ARGVtab
operator|=
name|makesymtab
argument_list|(
name|NSYMTAB
argument_list|)
expr_stmt|;
comment|/* could be (int) ARGC as well */
name|cp
operator|->
name|sval
operator|=
operator|(
name|char
operator|*
operator|)
name|ARGVtab
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ac
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_number
argument_list|(
operator|*
name|av
argument_list|)
condition|)
name|setsymtab
argument_list|(
name|temp
argument_list|,
operator|*
name|av
argument_list|,
name|atof
argument_list|(
operator|*
name|av
argument_list|)
argument_list|,
name|STR
operator||
name|NUM
argument_list|,
name|ARGVtab
argument_list|)
expr_stmt|;
else|else
name|setsymtab
argument_list|(
name|temp
argument_list|,
operator|*
name|av
argument_list|,
literal|0.0
argument_list|,
name|STR
argument_list|,
name|ARGVtab
argument_list|)
expr_stmt|;
name|av
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|envinit
parameter_list|(
name|char
modifier|*
modifier|*
name|envp
parameter_list|)
comment|/* set up ENVIRON variable */
block|{
name|Cell
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|cp
operator|=
name|setsymtab
argument_list|(
literal|"ENVIRON"
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|ARR
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
name|ENVtab
operator|=
name|makesymtab
argument_list|(
name|NSYMTAB
argument_list|)
expr_stmt|;
name|cp
operator|->
name|sval
operator|=
operator|(
name|char
operator|*
operator|)
name|ENVtab
expr_stmt|;
for|for
control|(
init|;
operator|*
name|envp
condition|;
name|envp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
operator|*
name|envp
argument_list|,
literal|'='
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|p
operator|==
operator|*
name|envp
condition|)
comment|/* no left hand side name in env string */
continue|continue;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* split into two strings at = */
if|if
condition|(
name|is_number
argument_list|(
name|p
argument_list|)
condition|)
name|setsymtab
argument_list|(
operator|*
name|envp
argument_list|,
name|p
argument_list|,
name|atof
argument_list|(
name|p
argument_list|)
argument_list|,
name|STR
operator||
name|NUM
argument_list|,
name|ENVtab
argument_list|)
expr_stmt|;
else|else
name|setsymtab
argument_list|(
operator|*
name|envp
argument_list|,
name|p
argument_list|,
literal|0.0
argument_list|,
name|STR
argument_list|,
name|ENVtab
argument_list|)
expr_stmt|;
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|'='
expr_stmt|;
comment|/* restore in case env is passed down to a shell */
block|}
block|}
end_function

begin_function
name|Array
modifier|*
name|makesymtab
parameter_list|(
name|int
name|n
parameter_list|)
comment|/* make a new symbol table */
block|{
name|Array
modifier|*
name|ap
decl_stmt|;
name|Cell
modifier|*
modifier|*
name|tp
decl_stmt|;
name|ap
operator|=
operator|(
name|Array
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Array
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|(
name|Cell
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|Cell
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|==
name|NULL
operator|||
name|tp
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"out of space in makesymtab"
argument_list|)
expr_stmt|;
name|ap
operator|->
name|nelem
operator|=
literal|0
expr_stmt|;
name|ap
operator|->
name|size
operator|=
name|n
expr_stmt|;
name|ap
operator|->
name|tab
operator|=
name|tp
expr_stmt|;
return|return
operator|(
name|ap
operator|)
return|;
block|}
end_function

begin_function
name|void
name|freesymtab
parameter_list|(
name|Cell
modifier|*
name|ap
parameter_list|)
comment|/* free a symbol table */
block|{
name|Cell
modifier|*
name|cp
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|Array
modifier|*
name|tp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|isarr
argument_list|(
name|ap
argument_list|)
condition|)
return|return;
name|tp
operator|=
operator|(
name|Array
operator|*
operator|)
name|ap
operator|->
name|sval
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tp
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|tp
operator|->
name|tab
index|[
name|i
index|]
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|temp
control|)
block|{
name|xfree
argument_list|(
name|cp
operator|->
name|nval
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeable
argument_list|(
name|cp
argument_list|)
condition|)
name|xfree
argument_list|(
name|cp
operator|->
name|sval
argument_list|)
expr_stmt|;
name|temp
operator|=
name|cp
operator|->
name|cnext
expr_stmt|;
comment|/* avoids freeing then using */
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|nelem
operator|--
expr_stmt|;
block|}
name|tp
operator|->
name|tab
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|nelem
operator|!=
literal|0
condition|)
name|WARNING
argument_list|(
literal|"can't happen: inconsistent element count freeing %s"
argument_list|,
name|ap
operator|->
name|nval
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
operator|->
name|tab
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|freeelem
parameter_list|(
name|Cell
modifier|*
name|ap
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
comment|/* free elem s from ap (i.e., ap["s"] */
block|{
name|Array
modifier|*
name|tp
decl_stmt|;
name|Cell
modifier|*
name|p
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|int
name|h
decl_stmt|;
name|tp
operator|=
operator|(
name|Array
operator|*
operator|)
name|ap
operator|->
name|sval
expr_stmt|;
name|h
operator|=
name|hash
argument_list|(
name|s
argument_list|,
name|tp
operator|->
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|tp
operator|->
name|tab
index|[
name|h
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
name|prev
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|cnext
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|p
operator|->
name|nval
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
comment|/* 1st one */
name|tp
operator|->
name|tab
index|[
name|h
index|]
operator|=
name|p
operator|->
name|cnext
expr_stmt|;
else|else
comment|/* middle somewhere */
name|prev
operator|->
name|cnext
operator|=
name|p
operator|->
name|cnext
expr_stmt|;
if|if
condition|(
name|freeable
argument_list|(
name|p
argument_list|)
condition|)
name|xfree
argument_list|(
name|p
operator|->
name|sval
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|nval
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|tp
operator|->
name|nelem
operator|--
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
name|Cell
modifier|*
name|setsymtab
parameter_list|(
name|char
modifier|*
name|n
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|Awkfloat
name|f
parameter_list|,
name|unsigned
name|t
parameter_list|,
name|Array
modifier|*
name|tp
parameter_list|)
block|{
name|int
name|h
decl_stmt|;
name|Cell
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
operator|&&
operator|(
name|p
operator|=
name|lookup
argument_list|(
name|n
argument_list|,
name|tp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"setsymtab found %p: n=%s s=\"%s\" f=%g t=%o\n"
operator|,
name|p
operator|,
name|p
operator|->
name|nval
operator|,
name|p
operator|->
name|sval
operator|,
name|p
operator|->
name|fval
operator|,
name|p
operator|->
name|tval
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
name|p
operator|=
operator|(
name|Cell
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Cell
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"out of space for symbol table at %s"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
operator|->
name|nval
operator|=
name|tostring
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|p
operator|->
name|sval
operator|=
name|s
condition|?
name|tostring
argument_list|(
name|s
argument_list|)
else|:
name|tostring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|p
operator|->
name|fval
operator|=
name|f
expr_stmt|;
name|p
operator|->
name|tval
operator|=
name|t
expr_stmt|;
name|p
operator|->
name|csub
operator|=
name|CUNK
expr_stmt|;
name|p
operator|->
name|ctype
operator|=
name|OCELL
expr_stmt|;
name|tp
operator|->
name|nelem
operator|++
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|nelem
operator|>
name|FULLTAB
operator|*
name|tp
operator|->
name|size
condition|)
name|rehash
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|h
operator|=
name|hash
argument_list|(
name|n
argument_list|,
name|tp
operator|->
name|size
argument_list|)
expr_stmt|;
name|p
operator|->
name|cnext
operator|=
name|tp
operator|->
name|tab
index|[
name|h
index|]
expr_stmt|;
name|tp
operator|->
name|tab
index|[
name|h
index|]
operator|=
name|p
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"setsymtab set %p: n=%s s=\"%s\" f=%g t=%o\n"
operator|,
name|p
operator|,
name|p
operator|->
name|nval
operator|,
name|p
operator|->
name|sval
operator|,
name|p
operator|->
name|fval
operator|,
name|p
operator|->
name|tval
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|int
name|hash
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* form hash value for string s */
block|{
name|unsigned
name|hashval
decl_stmt|;
for|for
control|(
name|hashval
operator|=
literal|0
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
name|hashval
operator|=
operator|(
operator|*
name|s
operator|+
literal|31
operator|*
name|hashval
operator|)
expr_stmt|;
return|return
name|hashval
operator|%
name|n
return|;
block|}
end_function

begin_function
name|void
name|rehash
parameter_list|(
name|Array
modifier|*
name|tp
parameter_list|)
comment|/* rehash items in small table into big one */
block|{
name|int
name|i
decl_stmt|,
name|nh
decl_stmt|,
name|nsz
decl_stmt|;
name|Cell
modifier|*
name|cp
decl_stmt|,
modifier|*
name|op
decl_stmt|,
modifier|*
modifier|*
name|np
decl_stmt|;
name|nsz
operator|=
name|GROWTAB
operator|*
name|tp
operator|->
name|size
expr_stmt|;
name|np
operator|=
operator|(
name|Cell
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|nsz
argument_list|,
sizeof|sizeof
argument_list|(
name|Cell
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
comment|/* can't do it, but can keep running. */
return|return;
comment|/* someone else will run out later. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tp
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|tp
operator|->
name|tab
index|[
name|i
index|]
init|;
name|cp
condition|;
name|cp
operator|=
name|op
control|)
block|{
name|op
operator|=
name|cp
operator|->
name|cnext
expr_stmt|;
name|nh
operator|=
name|hash
argument_list|(
name|cp
operator|->
name|nval
argument_list|,
name|nsz
argument_list|)
expr_stmt|;
name|cp
operator|->
name|cnext
operator|=
name|np
index|[
name|nh
index|]
expr_stmt|;
name|np
index|[
name|nh
index|]
operator|=
name|cp
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|tp
operator|->
name|tab
argument_list|)
expr_stmt|;
name|tp
operator|->
name|tab
operator|=
name|np
expr_stmt|;
name|tp
operator|->
name|size
operator|=
name|nsz
expr_stmt|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|lookup
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|Array
modifier|*
name|tp
parameter_list|)
comment|/* look for s in tp */
block|{
name|Cell
modifier|*
name|p
decl_stmt|;
name|int
name|h
decl_stmt|;
name|h
operator|=
name|hash
argument_list|(
name|s
argument_list|,
name|tp
operator|->
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|tp
operator|->
name|tab
index|[
name|h
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|cnext
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|p
operator|->
name|nval
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|p
operator|)
return|;
comment|/* found it */
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* not found */
block|}
end_function

begin_function
name|Awkfloat
name|setfval
parameter_list|(
name|Cell
modifier|*
name|vp
parameter_list|,
name|Awkfloat
name|f
parameter_list|)
comment|/* set float val of a Cell */
block|{
name|int
name|fldno
decl_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|tval
operator|&
operator|(
name|NUM
operator||
name|STR
operator|)
operator|)
operator|==
literal|0
condition|)
name|funnyvar
argument_list|(
name|vp
argument_list|,
literal|"assign to"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfld
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|donerec
operator|=
literal|0
expr_stmt|;
comment|/* mark $0 invalid */
name|fldno
operator|=
name|atoi
argument_list|(
name|vp
operator|->
name|nval
argument_list|)
expr_stmt|;
if|if
condition|(
name|fldno
operator|>
operator|*
name|NF
condition|)
name|newfld
argument_list|(
name|fldno
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"setting field %d to %g\n"
operator|,
name|fldno
operator|,
name|f
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isrec
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|donefld
operator|=
literal|0
expr_stmt|;
comment|/* mark $1... invalid */
name|donerec
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|freeable
argument_list|(
name|vp
argument_list|)
condition|)
name|xfree
argument_list|(
name|vp
operator|->
name|sval
argument_list|)
expr_stmt|;
comment|/* free any previous string */
name|vp
operator|->
name|tval
operator|&=
operator|~
name|STR
expr_stmt|;
comment|/* mark string invalid */
name|vp
operator|->
name|tval
operator||=
name|NUM
expr_stmt|;
comment|/* mark number ok */
name|dprintf
argument_list|(
operator|(
literal|"setfval %p: %s = %g, t=%o\n"
operator|,
name|vp
operator|,
name|vp
operator|->
name|nval
operator|,
name|f
operator|,
name|vp
operator|->
name|tval
operator|)
argument_list|)
expr_stmt|;
return|return
name|vp
operator|->
name|fval
operator|=
name|f
return|;
block|}
end_function

begin_function
name|void
name|funnyvar
parameter_list|(
name|Cell
modifier|*
name|vp
parameter_list|,
name|char
modifier|*
name|rw
parameter_list|)
block|{
if|if
condition|(
name|isarr
argument_list|(
name|vp
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"can't %s %s; it's an array name."
argument_list|,
name|rw
argument_list|,
name|vp
operator|->
name|nval
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|tval
operator|&
name|FCN
condition|)
name|FATAL
argument_list|(
literal|"can't %s %s; it's a function."
argument_list|,
name|rw
argument_list|,
name|vp
operator|->
name|nval
argument_list|)
expr_stmt|;
name|WARNING
argument_list|(
literal|"funny variable %p: n=%s s=\"%s\" f=%g t=%o"
argument_list|,
name|vp
argument_list|,
name|vp
operator|->
name|nval
argument_list|,
name|vp
operator|->
name|sval
argument_list|,
name|vp
operator|->
name|fval
argument_list|,
name|vp
operator|->
name|tval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|setsval
parameter_list|(
name|Cell
modifier|*
name|vp
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
comment|/* set string val of a Cell */
block|{
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|fldno
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"starting setsval %p: %s = \"%s\", t=%o\n"
operator|,
name|vp
operator|,
name|vp
operator|->
name|nval
operator|,
name|s
operator|,
name|vp
operator|->
name|tval
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|tval
operator|&
operator|(
name|NUM
operator||
name|STR
operator|)
operator|)
operator|==
literal|0
condition|)
name|funnyvar
argument_list|(
name|vp
argument_list|,
literal|"assign to"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfld
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|donerec
operator|=
literal|0
expr_stmt|;
comment|/* mark $0 invalid */
name|fldno
operator|=
name|atoi
argument_list|(
name|vp
operator|->
name|nval
argument_list|)
expr_stmt|;
if|if
condition|(
name|fldno
operator|>
operator|*
name|NF
condition|)
name|newfld
argument_list|(
name|fldno
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"setting field %d to %s (%p)\n"
operator|,
name|fldno
operator|,
name|s
operator|,
name|s
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isrec
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|donefld
operator|=
literal|0
expr_stmt|;
comment|/* mark $1... invalid */
name|donerec
operator|=
literal|1
expr_stmt|;
block|}
name|t
operator|=
name|tostring
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* in case it's self-assign */
name|vp
operator|->
name|tval
operator|&=
operator|~
name|NUM
expr_stmt|;
name|vp
operator|->
name|tval
operator||=
name|STR
expr_stmt|;
if|if
condition|(
name|freeable
argument_list|(
name|vp
argument_list|)
condition|)
name|xfree
argument_list|(
name|vp
operator|->
name|sval
argument_list|)
expr_stmt|;
name|vp
operator|->
name|tval
operator|&=
operator|~
name|DONTFREE
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"setsval %p: %s = \"%s (%p)\", t=%o\n"
operator|,
name|vp
operator|,
name|vp
operator|->
name|nval
operator|,
name|t
operator|,
name|t
operator|,
name|vp
operator|->
name|tval
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|vp
operator|->
name|sval
operator|=
name|t
operator|)
return|;
block|}
end_function

begin_function
name|Awkfloat
name|getfval
parameter_list|(
name|Cell
modifier|*
name|vp
parameter_list|)
comment|/* get float val of a Cell */
block|{
if|if
condition|(
operator|(
name|vp
operator|->
name|tval
operator|&
operator|(
name|NUM
operator||
name|STR
operator|)
operator|)
operator|==
literal|0
condition|)
name|funnyvar
argument_list|(
name|vp
argument_list|,
literal|"read value of"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfld
argument_list|(
name|vp
argument_list|)
operator|&&
name|donefld
operator|==
literal|0
condition|)
name|fldbld
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|isrec
argument_list|(
name|vp
argument_list|)
operator|&&
name|donerec
operator|==
literal|0
condition|)
name|recbld
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isnum
argument_list|(
name|vp
argument_list|)
condition|)
block|{
comment|/* not a number */
name|vp
operator|->
name|fval
operator|=
name|atof
argument_list|(
name|vp
operator|->
name|sval
argument_list|)
expr_stmt|;
comment|/* best guess */
if|if
condition|(
name|is_number
argument_list|(
name|vp
operator|->
name|sval
argument_list|)
operator|&&
operator|!
operator|(
name|vp
operator|->
name|tval
operator|&
name|CON
operator|)
condition|)
name|vp
operator|->
name|tval
operator||=
name|NUM
expr_stmt|;
comment|/* make NUM only sparingly */
block|}
name|dprintf
argument_list|(
operator|(
literal|"getfval %p: %s = %g, t=%o\n"
operator|,
name|vp
operator|,
name|vp
operator|->
name|nval
operator|,
name|vp
operator|->
name|fval
operator|,
name|vp
operator|->
name|tval
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|vp
operator|->
name|fval
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|getsval
parameter_list|(
name|Cell
modifier|*
name|vp
parameter_list|)
comment|/* get string val of a Cell */
block|{
name|char
name|s
index|[
literal|100
index|]
decl_stmt|;
comment|/* BUG: unchecked */
name|double
name|dtemp
decl_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|tval
operator|&
operator|(
name|NUM
operator||
name|STR
operator|)
operator|)
operator|==
literal|0
condition|)
name|funnyvar
argument_list|(
name|vp
argument_list|,
literal|"read value of"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfld
argument_list|(
name|vp
argument_list|)
operator|&&
name|donefld
operator|==
literal|0
condition|)
name|fldbld
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|isrec
argument_list|(
name|vp
argument_list|)
operator|&&
name|donerec
operator|==
literal|0
condition|)
name|recbld
argument_list|()
expr_stmt|;
if|if
condition|(
name|isstr
argument_list|(
name|vp
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|freeable
argument_list|(
name|vp
argument_list|)
condition|)
name|xfree
argument_list|(
name|vp
operator|->
name|sval
argument_list|)
expr_stmt|;
if|if
condition|(
name|modf
argument_list|(
name|vp
operator|->
name|fval
argument_list|,
operator|&
name|dtemp
argument_list|)
operator|==
literal|0
condition|)
comment|/* it's integral */
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%.30g"
argument_list|,
name|vp
operator|->
name|fval
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|s
argument_list|,
operator|*
name|CONVFMT
argument_list|,
name|vp
operator|->
name|fval
argument_list|)
expr_stmt|;
name|vp
operator|->
name|sval
operator|=
name|tostring
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|vp
operator|->
name|tval
operator|&=
operator|~
name|DONTFREE
expr_stmt|;
name|vp
operator|->
name|tval
operator||=
name|STR
expr_stmt|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"getsval %p: %s = \"%s (%p)\", t=%o\n"
operator|,
name|vp
operator|,
name|vp
operator|->
name|nval
operator|,
name|vp
operator|->
name|sval
operator|,
name|vp
operator|->
name|sval
operator|,
name|vp
operator|->
name|tval
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|vp
operator|->
name|sval
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|tostring
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
comment|/* make a copy of string s */
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"out of space in tostring on %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|qstring
parameter_list|(
name|char
modifier|*
name|is
parameter_list|,
name|int
name|delim
parameter_list|)
comment|/* collect string up to next delim */
block|{
name|char
modifier|*
name|os
init|=
name|is
decl_stmt|;
name|int
name|c
decl_stmt|,
name|n
decl_stmt|;
name|uschar
modifier|*
name|s
init|=
operator|(
name|uschar
operator|*
operator|)
name|is
decl_stmt|;
name|uschar
modifier|*
name|buf
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
operator|(
name|uschar
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|is
argument_list|)
operator|+
literal|3
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"out of space in qstring(%s)"
argument_list|,
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|buf
init|;
operator|(
name|c
operator|=
operator|*
name|s
operator|)
operator|!=
name|delim
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|SYNTAX
argument_list|(
literal|"newline in string %.20s..."
argument_list|,
name|os
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'\\'
condition|)
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
else|else
block|{
comment|/* \something */
name|c
operator|=
operator|*
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
comment|/* \ at end */
operator|*
name|bp
operator|++
operator|=
literal|'\\'
expr_stmt|;
break|break;
comment|/* for loop */
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
operator|*
name|bp
operator|++
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|bp
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|bp
operator|++
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
operator|*
name|bp
operator|++
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|*
name|bp
operator|++
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|bp
operator|++
operator|=
literal|'\r'
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
name|n
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|n
operator|=
literal|8
operator|*
name|n
operator|+
operator|*
operator|++
name|s
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
name|n
operator|=
literal|8
operator|*
name|n
operator|+
operator|*
operator|++
name|s
operator|-
literal|'0'
expr_stmt|;
block|}
operator|*
name|bp
operator|++
operator|=
name|n
expr_stmt|;
break|break;
block|}
block|}
block|}
operator|*
name|bp
operator|++
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|buf
return|;
block|}
end_function

end_unit

