begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright (C) Lucent Technologies 1997 All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the name Lucent Technologies or any of its entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ****************************************************************/
end_comment

begin_comment
comment|/*  * this program makes the table to link function names  * and type indices that is used by execute() in run.c.  * it finds the indices in ytab.h, produced by yacc.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"awk.h"
end_include

begin_include
include|#
directive|include
file|"ytab.h"
end_include

begin_struct
struct|struct
name|xx
block|{
name|int
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|pname
decl_stmt|;
block|}
name|proc
index|[]
init|=
block|{
block|{
name|PROGRAM
block|,
literal|"program"
block|,
name|NULL
block|}
block|,
block|{
name|BOR
block|,
literal|"boolop"
block|,
literal|" || "
block|}
block|,
block|{
name|AND
block|,
literal|"boolop"
block|,
literal|"&& "
block|}
block|,
block|{
name|NOT
block|,
literal|"boolop"
block|,
literal|" !"
block|}
block|,
block|{
name|NE
block|,
literal|"relop"
block|,
literal|" != "
block|}
block|,
block|{
name|EQ
block|,
literal|"relop"
block|,
literal|" == "
block|}
block|,
block|{
name|LE
block|,
literal|"relop"
block|,
literal|"<= "
block|}
block|,
block|{
name|LT
block|,
literal|"relop"
block|,
literal|"< "
block|}
block|,
block|{
name|GE
block|,
literal|"relop"
block|,
literal|">= "
block|}
block|,
block|{
name|GT
block|,
literal|"relop"
block|,
literal|"> "
block|}
block|,
block|{
name|ARRAY
block|,
literal|"array"
block|,
name|NULL
block|}
block|,
block|{
name|INDIRECT
block|,
literal|"indirect"
block|,
literal|"$("
block|}
block|,
block|{
name|SUBSTR
block|,
literal|"substr"
block|,
literal|"substr"
block|}
block|,
block|{
name|SUB
block|,
literal|"sub"
block|,
literal|"sub"
block|}
block|,
block|{
name|GSUB
block|,
literal|"gsub"
block|,
literal|"gsub"
block|}
block|,
block|{
name|INDEX
block|,
literal|"sindex"
block|,
literal|"sindex"
block|}
block|,
block|{
name|SPRINTF
block|,
literal|"awksprintf"
block|,
literal|"sprintf "
block|}
block|,
block|{
name|ADD
block|,
literal|"arith"
block|,
literal|" + "
block|}
block|,
block|{
name|MINUS
block|,
literal|"arith"
block|,
literal|" - "
block|}
block|,
block|{
name|MULT
block|,
literal|"arith"
block|,
literal|" * "
block|}
block|,
block|{
name|DIVIDE
block|,
literal|"arith"
block|,
literal|" / "
block|}
block|,
block|{
name|MOD
block|,
literal|"arith"
block|,
literal|" % "
block|}
block|,
block|{
name|UMINUS
block|,
literal|"arith"
block|,
literal|" -"
block|}
block|,
block|{
name|POWER
block|,
literal|"arith"
block|,
literal|" **"
block|}
block|,
block|{
name|PREINCR
block|,
literal|"incrdecr"
block|,
literal|"++"
block|}
block|,
block|{
name|POSTINCR
block|,
literal|"incrdecr"
block|,
literal|"++"
block|}
block|,
block|{
name|PREDECR
block|,
literal|"incrdecr"
block|,
literal|"--"
block|}
block|,
block|{
name|POSTDECR
block|,
literal|"incrdecr"
block|,
literal|"--"
block|}
block|,
block|{
name|CAT
block|,
literal|"cat"
block|,
literal|" "
block|}
block|,
block|{
name|PASTAT
block|,
literal|"pastat"
block|,
name|NULL
block|}
block|,
block|{
name|PASTAT2
block|,
literal|"dopa2"
block|,
name|NULL
block|}
block|,
block|{
name|MATCH
block|,
literal|"matchop"
block|,
literal|" ~ "
block|}
block|,
block|{
name|NOTMATCH
block|,
literal|"matchop"
block|,
literal|" !~ "
block|}
block|,
block|{
name|MATCHFCN
block|,
literal|"matchop"
block|,
literal|"matchop"
block|}
block|,
block|{
name|INTEST
block|,
literal|"intest"
block|,
literal|"intest"
block|}
block|,
block|{
name|PRINTF
block|,
literal|"awkprintf"
block|,
literal|"printf"
block|}
block|,
block|{
name|PRINT
block|,
literal|"printstat"
block|,
literal|"print"
block|}
block|,
block|{
name|CLOSE
block|,
literal|"closefile"
block|,
literal|"closefile"
block|}
block|,
block|{
name|DELETE
block|,
literal|"awkdelete"
block|,
literal|"awkdelete"
block|}
block|,
block|{
name|SPLIT
block|,
literal|"split"
block|,
literal|"split"
block|}
block|,
block|{
name|ASSIGN
block|,
literal|"assign"
block|,
literal|" = "
block|}
block|,
block|{
name|ADDEQ
block|,
literal|"assign"
block|,
literal|" += "
block|}
block|,
block|{
name|SUBEQ
block|,
literal|"assign"
block|,
literal|" -= "
block|}
block|,
block|{
name|MULTEQ
block|,
literal|"assign"
block|,
literal|" *= "
block|}
block|,
block|{
name|DIVEQ
block|,
literal|"assign"
block|,
literal|" /= "
block|}
block|,
block|{
name|MODEQ
block|,
literal|"assign"
block|,
literal|" %= "
block|}
block|,
block|{
name|POWEQ
block|,
literal|"assign"
block|,
literal|" ^= "
block|}
block|,
block|{
name|CONDEXPR
block|,
literal|"condexpr"
block|,
literal|" ?: "
block|}
block|,
block|{
name|IF
block|,
literal|"ifstat"
block|,
literal|"if("
block|}
block|,
block|{
name|WHILE
block|,
literal|"whilestat"
block|,
literal|"while("
block|}
block|,
block|{
name|FOR
block|,
literal|"forstat"
block|,
literal|"for("
block|}
block|,
block|{
name|DO
block|,
literal|"dostat"
block|,
literal|"do"
block|}
block|,
block|{
name|IN
block|,
literal|"instat"
block|,
literal|"instat"
block|}
block|,
block|{
name|NEXT
block|,
literal|"jump"
block|,
literal|"next"
block|}
block|,
block|{
name|NEXTFILE
block|,
literal|"jump"
block|,
literal|"nextfile"
block|}
block|,
block|{
name|EXIT
block|,
literal|"jump"
block|,
literal|"exit"
block|}
block|,
block|{
name|BREAK
block|,
literal|"jump"
block|,
literal|"break"
block|}
block|,
block|{
name|CONTINUE
block|,
literal|"jump"
block|,
literal|"continue"
block|}
block|,
block|{
name|RETURN
block|,
literal|"jump"
block|,
literal|"ret"
block|}
block|,
block|{
name|BLTIN
block|,
literal|"bltin"
block|,
literal|"bltin"
block|}
block|,
block|{
name|CALL
block|,
literal|"call"
block|,
literal|"call"
block|}
block|,
block|{
name|ARG
block|,
literal|"arg"
block|,
literal|"arg"
block|}
block|,
block|{
name|VARNF
block|,
literal|"getnf"
block|,
literal|"NF"
block|}
block|,
block|{
name|GETLINE
block|,
literal|"awkgetline"
block|,
literal|"getline"
block|}
block|,
block|{
literal|0
block|,
literal|""
block|,
literal|""
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|SIZE
value|(LASTTOKEN - FIRSTTOKEN + 1)
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
name|table
index|[
name|SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|names
index|[
name|SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
specifier|const
name|struct
name|xx
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|tok
decl_stmt|;
name|char
name|c
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|,
name|name
index|[
literal|200
index|]
decl_stmt|,
name|def
index|[
literal|200
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"#include<stdio.h>\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"awk.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"ytab.h\"\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|SIZE
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|names
index|[
name|i
index|]
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
literal|"ytab.h"
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"maketab can't open ytab.h!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"static char *printname[%d] = {\n"
argument_list|,
name|SIZE
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|n
operator|=
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%1c %s %s %d"
argument_list|,
operator|&
name|c
argument_list|,
name|def
argument_list|,
name|name
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'#'
operator|||
operator|(
name|n
operator|!=
literal|4
operator|&&
name|strcmp
argument_list|(
name|def
argument_list|,
literal|"define"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
comment|/* not a valid #define */
continue|continue;
if|if
condition|(
name|tok
operator|<
name|FIRSTTOKEN
operator|||
name|tok
operator|>
name|LASTTOKEN
condition|)
block|{
comment|/* fprintf(stderr, "maketab funny token %d %s ignored\n", tok, buf); */
continue|continue;
block|}
name|names
index|[
name|tok
operator|-
name|FIRSTTOKEN
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|names
index|[
name|tok
operator|-
name|FIRSTTOKEN
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t(char *) \"%s\",\t/* %d */\n"
argument_list|,
name|name
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"};\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|proc
init|;
name|p
operator|->
name|token
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
name|table
index|[
name|p
operator|->
name|token
operator|-
name|FIRSTTOKEN
index|]
operator|=
name|p
operator|->
name|name
expr_stmt|;
name|printf
argument_list|(
literal|"\nCell *(*proctab[%d])(Node **, int) = {\n"
argument_list|,
name|SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|table
index|[
name|i
index|]
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"\tnullproc,\t/* %s */\n"
argument_list|,
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\t%s,\t/* %s */\n"
argument_list|,
name|table
index|[
name|i
index|]
argument_list|,
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"};\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"char *tokname(int n)\n"
argument_list|)
expr_stmt|;
comment|/* print a tokname() function */
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	static char buf[100];\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	if (n< FIRSTTOKEN || n> LASTTOKEN) {\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"		sprintf(buf, \"token %%d\", n);\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"		return buf;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	}\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	return printname[n-FIRSTTOKEN];\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

