begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright (C) Lucent Technologies 1997 All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the name Lucent Technologies or any of its entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ****************************************************************/
end_comment

begin_decl_stmt
name|char
modifier|*
name|version
init|=
literal|"version 20020101"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEBUG
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"awk.h"
end_include

begin_include
include|#
directive|include
file|"ytab.h"
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfields
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dbg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cmdname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* gets argv[0] for error messages */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|yyin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lex input file */
end_comment

begin_decl_stmt
name|char
modifier|*
name|lexprog
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* points to program argument if it exists */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|errorflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* non-zero if any syntax errors; set by yyerror */
end_comment

begin_decl_stmt
name|int
name|compile_time
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for error printing: */
end_comment

begin_comment
comment|/* 2 = cmdline, 1 = compile, 0 = running */
end_comment

begin_decl_stmt
name|char
modifier|*
name|pfile
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* program filenames from -f's */
end_comment

begin_decl_stmt
name|int
name|npfile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of filenames */
end_comment

begin_decl_stmt
name|int
name|curpfile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current filename */
end_comment

begin_decl_stmt
name|int
name|safe
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => "safe" mode */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
modifier|*
name|fs
init|=
name|NULL
decl_stmt|;
name|cmdname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [-f programfile | 'program'] [-Ffieldsep] [-v var=value] [files]\n"
argument_list|,
name|cmdname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|fpecatch
argument_list|)
expr_stmt|;
name|yyin
operator|=
name|NULL
expr_stmt|;
name|symtab
operator|=
name|makesymtab
argument_list|(
name|NSYMTAB
argument_list|)
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"--"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* explicit end of args */
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-safe"
argument_list|)
operator|==
literal|0
condition|)
name|safe
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* next argument is program filename */
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|FATAL
argument_list|(
literal|"no program filename"
argument_list|)
expr_stmt|;
name|pfile
index|[
name|npfile
operator|++
index|]
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* set field separator */
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* arg is -Fsomething */
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|==
literal|'t'
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|3
index|]
operator|==
literal|0
condition|)
comment|/* wart: t=>\t */
name|fs
operator|=
literal|"\t"
expr_stmt|;
elseif|else
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|fs
operator|=
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* arg is -F something */
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'t'
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|0
condition|)
comment|/* wart: t=>\t */
name|fs
operator|=
literal|"\t"
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
name|fs
operator|=
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
name|fs
operator|==
name|NULL
operator|||
operator|*
name|fs
operator|==
literal|'\0'
condition|)
name|WARNING
argument_list|(
literal|"field separator FS is empty"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* -v a=1 to be done NOW.  one -v for each */
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|&&
operator|--
name|argc
operator|>
literal|1
operator|&&
name|isclvar
argument_list|(
operator|(
operator|++
name|argv
operator|)
index|[
literal|1
index|]
argument_list|)
condition|)
name|setclvar
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* more memory: -mr=record, -mf=fields */
comment|/* no longer supported */
name|WARNING
argument_list|(
literal|"obsolete option %s ignored"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|dbg
operator|=
name|atoi
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg
operator|==
literal|0
condition|)
name|dbg
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"awk %s\n"
argument_list|,
name|version
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
comment|/* added for exptools "standard" */
name|printf
argument_list|(
literal|"awk %s\n"
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|WARNING
argument_list|(
literal|"unknown option %s ignored"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
comment|/* argv[1] is now the first argument */
if|if
condition|(
name|npfile
operator|==
literal|0
condition|)
block|{
comment|/* no -f; first argument is program */
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|dbg
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|FATAL
argument_list|(
literal|"no program given"
argument_list|)
expr_stmt|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"program = |%s|\n"
operator|,
name|argv
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|lexprog
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
name|recinit
argument_list|(
name|recsize
argument_list|)
expr_stmt|;
name|syminit
argument_list|()
expr_stmt|;
name|compile_time
operator|=
literal|1
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|cmdname
expr_stmt|;
comment|/* put prog name at front of arglist */
name|dprintf
argument_list|(
operator|(
literal|"argc=%d, argv[0]=%s\n"
operator|,
name|argc
operator|,
name|argv
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
name|arginit
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|safe
condition|)
name|envinit
argument_list|(
name|environ
argument_list|)
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
if|if
condition|(
name|fs
condition|)
operator|*
name|FS
operator|=
name|qstring
argument_list|(
name|fs
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"errorflag=%d\n"
operator|,
name|errorflag
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorflag
operator|==
literal|0
condition|)
block|{
name|compile_time
operator|=
literal|0
expr_stmt|;
name|run
argument_list|(
name|winner
argument_list|)
expr_stmt|;
block|}
else|else
name|bracecheck
argument_list|()
expr_stmt|;
return|return
operator|(
name|errorflag
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pgetc
parameter_list|(
name|void
parameter_list|)
comment|/* get 1 character from awk program */
block|{
name|int
name|c
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|yyin
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|curpfile
operator|>=
name|npfile
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|pfile
index|[
name|curpfile
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|yyin
operator|=
name|stdin
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|yyin
operator|=
name|fopen
argument_list|(
name|pfile
index|[
name|curpfile
index|]
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"can't open file %s"
argument_list|,
name|pfile
index|[
name|curpfile
index|]
argument_list|)
expr_stmt|;
name|lineno
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|yyin
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
return|return
name|c
return|;
if|if
condition|(
name|yyin
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|yyin
argument_list|)
expr_stmt|;
name|yyin
operator|=
name|NULL
expr_stmt|;
name|curpfile
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|cursource
parameter_list|(
name|void
parameter_list|)
comment|/* current source file name */
block|{
if|if
condition|(
name|npfile
operator|>
literal|0
condition|)
return|return
name|pfile
index|[
name|curpfile
index|]
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

end_unit

