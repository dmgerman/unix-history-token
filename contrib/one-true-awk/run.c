begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright (C) Lucent Technologies 1997 All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the name Lucent Technologies or any of its entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ****************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|DEBUG
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"awk.h"
end_include

begin_include
include|#
directive|include
file|"ytab.h"
end_include

begin_define
define|#
directive|define
name|tempfree
parameter_list|(
name|x
parameter_list|)
value|if (istemp(x)) tfree(x); else
end_define

begin_comment
comment|/* #undef tempfree  void tempfree(Cell *p) { 	if (p->ctype == OCELL&& (p->csub< CUNK || p->csub> CFREE)) { 		WARNING("bad csub %d in Cell %d %s", 			p->csub, p->ctype, p->sval); 	} 	if (istemp(p)) 		tfree(p); } */
end_comment

begin_comment
comment|/* do we really need these? */
end_comment

begin_comment
comment|/* #ifdef _NFILE */
end_comment

begin_comment
comment|/* #ifndef FOPEN_MAX */
end_comment

begin_comment
comment|/* #define FOPEN_MAX _NFILE */
end_comment

begin_comment
comment|/* #endif */
end_comment

begin_comment
comment|/* #endif */
end_comment

begin_comment
comment|/*  */
end_comment

begin_comment
comment|/* #ifndef	FOPEN_MAX */
end_comment

begin_comment
comment|/* #define	FOPEN_MAX	40 */
end_comment

begin_comment
comment|/* max number of open files */
end_comment

begin_comment
comment|/* #endif */
end_comment

begin_comment
comment|/*  */
end_comment

begin_comment
comment|/* #ifndef RAND_MAX */
end_comment

begin_comment
comment|/* #define RAND_MAX	32767 */
end_comment

begin_comment
comment|/* all that ansi guarantees */
end_comment

begin_comment
comment|/* #endif */
end_comment

begin_decl_stmt
name|jmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|pairstack
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Awkfloat
name|srand_seed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Node
modifier|*
name|winner
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* root of parse tree */
end_comment

begin_decl_stmt
name|Cell
modifier|*
name|tmps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* free temporary cells for execution */
end_comment

begin_decl_stmt
specifier|static
name|Cell
name|truecell
init|=
block|{
name|OBOOL
block|,
name|BTRUE
block|,
literal|0
block|,
literal|0
block|,
literal|1.0
block|,
name|NUM
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Cell
modifier|*
name|True
init|=
operator|&
name|truecell
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Cell
name|falsecell
init|=
block|{
name|OBOOL
block|,
name|BFALSE
block|,
literal|0
block|,
literal|0
block|,
literal|0.0
block|,
name|NUM
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Cell
modifier|*
name|False
init|=
operator|&
name|falsecell
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Cell
name|breakcell
init|=
block|{
name|OJUMP
block|,
name|JBREAK
block|,
literal|0
block|,
literal|0
block|,
literal|0.0
block|,
name|NUM
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Cell
modifier|*
name|jbreak
init|=
operator|&
name|breakcell
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Cell
name|contcell
init|=
block|{
name|OJUMP
block|,
name|JCONT
block|,
literal|0
block|,
literal|0
block|,
literal|0.0
block|,
name|NUM
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Cell
modifier|*
name|jcont
init|=
operator|&
name|contcell
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Cell
name|nextcell
init|=
block|{
name|OJUMP
block|,
name|JNEXT
block|,
literal|0
block|,
literal|0
block|,
literal|0.0
block|,
name|NUM
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Cell
modifier|*
name|jnext
init|=
operator|&
name|nextcell
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Cell
name|nextfilecell
init|=
block|{
name|OJUMP
block|,
name|JNEXTFILE
block|,
literal|0
block|,
literal|0
block|,
literal|0.0
block|,
name|NUM
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Cell
modifier|*
name|jnextfile
init|=
operator|&
name|nextfilecell
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Cell
name|exitcell
init|=
block|{
name|OJUMP
block|,
name|JEXIT
block|,
literal|0
block|,
literal|0
block|,
literal|0.0
block|,
name|NUM
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Cell
modifier|*
name|jexit
init|=
operator|&
name|exitcell
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Cell
name|retcell
init|=
block|{
name|OJUMP
block|,
name|JRET
block|,
literal|0
block|,
literal|0
block|,
literal|0.0
block|,
name|NUM
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Cell
modifier|*
name|jret
init|=
operator|&
name|retcell
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Cell
name|tempcell
init|=
block|{
name|OCELL
block|,
name|CTEMP
block|,
literal|0
block|,
literal|""
block|,
literal|0.0
block|,
name|NUM
operator||
name|STR
operator||
name|DONTFREE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Node
modifier|*
name|curnode
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the node being executed, for debugging */
end_comment

begin_comment
comment|/* buffer memory management */
end_comment

begin_function
name|int
name|adjbuf
parameter_list|(
name|char
modifier|*
modifier|*
name|pbuf
parameter_list|,
name|int
modifier|*
name|psiz
parameter_list|,
name|int
name|minlen
parameter_list|,
name|int
name|quantum
parameter_list|,
name|char
modifier|*
modifier|*
name|pbptr
parameter_list|,
specifier|const
name|char
modifier|*
name|whatrtn
parameter_list|)
comment|/* pbuf:    address of pointer to buffer being managed  * psiz:    address of buffer size variable  * minlen:  minimum length of buffer needed  * quantum: buffer size quantum  * pbptr:   address of movable pointer into buffer, or 0 if none  * whatrtn: name of the calling routine if failure should cause fatal error  *  * return   0 for realloc failure, !=0 for success  */
block|{
if|if
condition|(
name|minlen
operator|>
operator|*
name|psiz
condition|)
block|{
name|char
modifier|*
name|tbuf
decl_stmt|;
name|int
name|rminlen
init|=
name|quantum
condition|?
name|minlen
operator|%
name|quantum
else|:
literal|0
decl_stmt|;
name|int
name|boff
init|=
name|pbptr
condition|?
operator|*
name|pbptr
operator|-
operator|*
name|pbuf
else|:
literal|0
decl_stmt|;
comment|/* round up to next multiple of quantum */
if|if
condition|(
name|rminlen
condition|)
name|minlen
operator|+=
name|quantum
operator|-
name|rminlen
expr_stmt|;
name|tbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
operator|*
name|pbuf
argument_list|,
name|minlen
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"adjbuf %s: %d %d (pbuf=%p, tbuf=%p)\n"
operator|,
name|whatrtn
operator|,
operator|*
name|psiz
operator|,
name|minlen
operator|,
operator|*
name|pbuf
operator|,
name|tbuf
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tbuf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|whatrtn
condition|)
name|FATAL
argument_list|(
literal|"out of memory in %s"
argument_list|,
name|whatrtn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|pbuf
operator|=
name|tbuf
expr_stmt|;
operator|*
name|psiz
operator|=
name|minlen
expr_stmt|;
if|if
condition|(
name|pbptr
condition|)
operator|*
name|pbptr
operator|=
name|tbuf
operator|+
name|boff
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|run
parameter_list|(
name|Node
modifier|*
name|a
parameter_list|)
comment|/* execution of parse tree starts here */
block|{
specifier|extern
name|void
name|stdinit
argument_list|(
name|void
argument_list|)
decl_stmt|;
name|stdinit
argument_list|()
expr_stmt|;
name|execute
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|closeall
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|execute
parameter_list|(
name|Node
modifier|*
name|u
parameter_list|)
comment|/* execute a node of the parse tree */
block|{
name|Cell
modifier|*
function_decl|(
modifier|*
name|proc
function_decl|)
parameter_list|(
name|Node
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|Cell
modifier|*
name|x
decl_stmt|;
name|Node
modifier|*
name|a
decl_stmt|;
if|if
condition|(
name|u
operator|==
name|NULL
condition|)
return|return
operator|(
name|True
operator|)
return|;
for|for
control|(
name|a
operator|=
name|u
init|;
condition|;
name|a
operator|=
name|a
operator|->
name|nnext
control|)
block|{
name|curnode
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|isvalue
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|x
operator|=
operator|(
name|Cell
operator|*
operator|)
operator|(
name|a
operator|->
name|narg
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|isfld
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|donefld
condition|)
name|fldbld
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|isrec
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|donerec
condition|)
name|recbld
argument_list|()
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
if|if
condition|(
name|notlegal
argument_list|(
name|a
operator|->
name|nobj
argument_list|)
condition|)
comment|/* probably a Cell* but too risky to print */
name|FATAL
argument_list|(
literal|"illegal statement"
argument_list|)
expr_stmt|;
name|proc
operator|=
name|proctab
index|[
name|a
operator|->
name|nobj
operator|-
name|FIRSTTOKEN
index|]
expr_stmt|;
name|x
operator|=
call|(
modifier|*
name|proc
call|)
argument_list|(
name|a
operator|->
name|narg
argument_list|,
name|a
operator|->
name|nobj
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfld
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|donefld
condition|)
name|fldbld
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|isrec
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|donerec
condition|)
name|recbld
argument_list|()
expr_stmt|;
if|if
condition|(
name|isexpr
argument_list|(
name|a
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
name|isjump
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|nnext
operator|==
name|NULL
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Cell
modifier|*
name|program
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* execute an awk program */
block|{
comment|/* a[0] = BEGIN, a[1] = body, a[2] = END */
name|Cell
modifier|*
name|x
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|env
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|ex
goto|;
if|if
condition|(
name|a
index|[
literal|0
index|]
condition|)
block|{
comment|/* BEGIN */
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|isexit
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|True
operator|)
return|;
if|if
condition|(
name|isjump
argument_list|(
name|x
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"illegal break, continue, next or nextfile from BEGIN"
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a
index|[
literal|1
index|]
operator|||
name|a
index|[
literal|2
index|]
condition|)
while|while
condition|(
name|getrec
argument_list|(
operator|&
name|record
argument_list|,
operator|&
name|recsize
argument_list|,
literal|1
argument_list|)
operator|>
literal|0
condition|)
block|{
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|isexit
argument_list|(
name|x
argument_list|)
condition|)
break|break;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|ex
label|:
if|if
condition|(
name|setjmp
argument_list|(
name|env
argument_list|)
operator|!=
literal|0
condition|)
comment|/* handles exit within END */
goto|goto
name|ex1
goto|;
if|if
condition|(
name|a
index|[
literal|2
index|]
condition|)
block|{
comment|/* END */
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|isbreak
argument_list|(
name|x
argument_list|)
operator|||
name|isnext
argument_list|(
name|x
argument_list|)
operator|||
name|iscont
argument_list|(
name|x
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"illegal break, continue, next or nextfile from END"
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|ex1
label|:
return|return
operator|(
name|True
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|Frame
block|{
comment|/* stack frame for awk function calls */
name|int
name|nargs
decl_stmt|;
comment|/* number of arguments in this call */
name|Cell
modifier|*
name|fcncell
decl_stmt|;
comment|/* pointer to Cell for function */
name|Cell
modifier|*
modifier|*
name|args
decl_stmt|;
comment|/* pointer to array of arguments after execute */
name|Cell
modifier|*
name|retval
decl_stmt|;
comment|/* return value */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NARGS
value|50
end_define

begin_comment
comment|/* max args in a call */
end_comment

begin_decl_stmt
name|struct
name|Frame
modifier|*
name|frame
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* base of stack frames; dynamically allocated */
end_comment

begin_decl_stmt
name|int
name|nframe
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of frames allocated */
end_comment

begin_decl_stmt
name|struct
name|Frame
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* frame pointer. bottom level unused */
end_comment

begin_function
name|Cell
modifier|*
name|call
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* function call.  very kludgy and fragile */
block|{
specifier|static
name|Cell
name|newcopycell
init|=
block|{
name|OCELL
block|,
name|CCOPY
block|,
literal|0
block|,
literal|""
block|,
literal|0.0
block|,
name|NUM
operator||
name|STR
operator||
name|DONTFREE
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ncall
decl_stmt|,
name|ndef
decl_stmt|;
name|int
name|freed
init|=
literal|0
decl_stmt|;
comment|/* handles potential double freeing when fcn& param share a tempcell */
name|Node
modifier|*
name|x
decl_stmt|;
name|Cell
modifier|*
name|args
index|[
name|NARGS
index|]
decl_stmt|,
modifier|*
name|oargs
index|[
name|NARGS
index|]
decl_stmt|;
comment|/* BUG: fixed size arrays */
name|Cell
modifier|*
name|y
decl_stmt|,
modifier|*
name|z
decl_stmt|,
modifier|*
name|fcn
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|fcn
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* the function itself */
name|s
operator|=
name|fcn
operator|->
name|nval
expr_stmt|;
if|if
condition|(
operator|!
name|isfcn
argument_list|(
name|fcn
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"calling undefined function %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|==
name|NULL
condition|)
block|{
name|fp
operator|=
name|frame
operator|=
operator|(
expr|struct
name|Frame
operator|*
operator|)
name|calloc
argument_list|(
name|nframe
operator|+=
literal|100
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|Frame
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"out of space for stack frames calling %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ncall
operator|=
literal|0
operator|,
name|x
operator|=
name|a
index|[
literal|1
index|]
init|;
name|x
operator|!=
name|NULL
condition|;
name|x
operator|=
name|x
operator|->
name|nnext
control|)
comment|/* args in call */
name|ncall
operator|++
expr_stmt|;
name|ndef
operator|=
operator|(
name|int
operator|)
name|fcn
operator|->
name|fval
expr_stmt|;
comment|/* args in defn */
name|dprintf
argument_list|(
operator|(
literal|"calling %s, %d args (%d in defn), fp=%d\n"
operator|,
name|s
operator|,
name|ncall
operator|,
name|ndef
operator|,
call|(
name|int
call|)
argument_list|(
name|fp
operator|-
name|frame
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncall
operator|>
name|ndef
condition|)
name|WARNING
argument_list|(
literal|"function %s called with %d args, uses only %d"
argument_list|,
name|s
argument_list|,
name|ncall
argument_list|,
name|ndef
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncall
operator|+
name|ndef
operator|>
name|NARGS
condition|)
name|FATAL
argument_list|(
literal|"function %s has %d arguments, limit %d"
argument_list|,
name|s
argument_list|,
name|ncall
operator|+
name|ndef
argument_list|,
name|NARGS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|x
operator|=
name|a
index|[
literal|1
index|]
init|;
name|x
operator|!=
name|NULL
condition|;
name|i
operator|++
operator|,
name|x
operator|=
name|x
operator|->
name|nnext
control|)
block|{
comment|/* get call args */
name|dprintf
argument_list|(
operator|(
literal|"evaluate args[%d], fp=%d:\n"
operator|,
name|i
operator|,
call|(
name|int
call|)
argument_list|(
name|fp
operator|-
name|frame
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|y
operator|=
name|execute
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|oargs
index|[
name|i
index|]
operator|=
name|y
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"args[%d]: %s %f<%s>, t=%o\n"
operator|,
name|i
operator|,
name|NN
argument_list|(
name|y
operator|->
name|nval
argument_list|)
operator|,
name|y
operator|->
name|fval
operator|,
name|isarr
argument_list|(
name|y
argument_list|)
condition|?
literal|"(array)"
else|:
name|NN
argument_list|(
name|y
operator|->
name|sval
argument_list|)
operator|,
name|y
operator|->
name|tval
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfcn
argument_list|(
name|y
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"can't use function %s as argument in %s"
argument_list|,
name|y
operator|->
name|nval
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|isarr
argument_list|(
name|y
argument_list|)
condition|)
name|args
index|[
name|i
index|]
operator|=
name|y
expr_stmt|;
comment|/* arrays by ref */
else|else
name|args
index|[
name|i
index|]
operator|=
name|copycell
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|ndef
condition|;
name|i
operator|++
control|)
block|{
comment|/* add null args for ones not provided */
name|args
index|[
name|i
index|]
operator|=
name|gettemp
argument_list|()
expr_stmt|;
operator|*
name|args
index|[
name|i
index|]
operator|=
name|newcopycell
expr_stmt|;
block|}
name|fp
operator|++
expr_stmt|;
comment|/* now ok to up frame */
if|if
condition|(
name|fp
operator|>=
name|frame
operator|+
name|nframe
condition|)
block|{
name|int
name|dfp
init|=
name|fp
operator|-
name|frame
decl_stmt|;
comment|/* old index */
name|frame
operator|=
operator|(
expr|struct
name|Frame
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|frame
argument_list|,
operator|(
name|nframe
operator|+=
literal|100
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|Frame
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"out of space for stack frames in %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|fp
operator|=
name|frame
operator|+
name|dfp
expr_stmt|;
block|}
name|fp
operator|->
name|fcncell
operator|=
name|fcn
expr_stmt|;
name|fp
operator|->
name|args
operator|=
name|args
expr_stmt|;
name|fp
operator|->
name|nargs
operator|=
name|ndef
expr_stmt|;
comment|/* number defined with (excess are locals) */
name|fp
operator|->
name|retval
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"start exec of %s, fp=%d\n"
operator|,
name|s
operator|,
call|(
name|int
call|)
argument_list|(
name|fp
operator|-
name|frame
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|y
operator|=
name|execute
argument_list|(
operator|(
name|Node
operator|*
operator|)
operator|(
name|fcn
operator|->
name|sval
operator|)
argument_list|)
expr_stmt|;
comment|/* execute body */
name|dprintf
argument_list|(
operator|(
literal|"finished exec of %s, fp=%d\n"
operator|,
name|s
operator|,
call|(
name|int
call|)
argument_list|(
name|fp
operator|-
name|frame
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndef
condition|;
name|i
operator|++
control|)
block|{
name|Cell
modifier|*
name|t
init|=
name|fp
operator|->
name|args
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|isarr
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|csub
operator|==
name|CCOPY
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|ncall
condition|)
block|{
name|freesymtab
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|->
name|csub
operator|=
name|CTEMP
expr_stmt|;
name|tempfree
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|oargs
index|[
name|i
index|]
operator|->
name|tval
operator|=
name|t
operator|->
name|tval
expr_stmt|;
name|oargs
index|[
name|i
index|]
operator|->
name|tval
operator|&=
operator|~
operator|(
name|STR
operator||
name|NUM
operator||
name|DONTFREE
operator|)
expr_stmt|;
name|oargs
index|[
name|i
index|]
operator|->
name|sval
operator|=
name|t
operator|->
name|sval
expr_stmt|;
name|tempfree
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|t
operator|!=
name|y
condition|)
block|{
comment|/* kludge to prevent freeing twice */
name|t
operator|->
name|csub
operator|=
name|CTEMP
expr_stmt|;
name|tempfree
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|y
operator|&&
name|t
operator|->
name|csub
operator|==
name|CCOPY
condition|)
block|{
name|t
operator|->
name|csub
operator|=
name|CTEMP
expr_stmt|;
name|tempfree
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|freed
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|tempfree
argument_list|(
name|fcn
argument_list|)
expr_stmt|;
if|if
condition|(
name|isexit
argument_list|(
name|y
argument_list|)
operator|||
name|isnext
argument_list|(
name|y
argument_list|)
condition|)
return|return
name|y
return|;
if|if
condition|(
name|freed
operator|==
literal|0
condition|)
block|{
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* don't free twice! */
block|}
name|z
operator|=
name|fp
operator|->
name|retval
expr_stmt|;
comment|/* return value */
name|dprintf
argument_list|(
operator|(
literal|"%s returns %g |%s| %o\n"
operator|,
name|s
operator|,
name|getfval
argument_list|(
name|z
argument_list|)
operator|,
name|getsval
argument_list|(
name|z
argument_list|)
operator|,
name|z
operator|->
name|tval
operator|)
argument_list|)
expr_stmt|;
name|fp
operator|--
expr_stmt|;
return|return
operator|(
name|z
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|copycell
parameter_list|(
name|Cell
modifier|*
name|x
parameter_list|)
comment|/* make a copy of a cell in a temp */
block|{
name|Cell
modifier|*
name|y
decl_stmt|;
name|y
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|y
operator|->
name|csub
operator|=
name|CCOPY
expr_stmt|;
comment|/* prevents freeing until call is over */
name|y
operator|->
name|nval
operator|=
name|x
operator|->
name|nval
expr_stmt|;
comment|/* BUG? */
if|if
condition|(
name|isstr
argument_list|(
name|x
argument_list|)
condition|)
name|y
operator|->
name|sval
operator|=
name|tostring
argument_list|(
name|x
operator|->
name|sval
argument_list|)
expr_stmt|;
name|y
operator|->
name|fval
operator|=
name|x
operator|->
name|fval
expr_stmt|;
name|y
operator|->
name|tval
operator|=
name|x
operator|->
name|tval
operator|&
operator|~
operator|(
name|CON
operator||
name|FLD
operator||
name|REC
operator||
name|DONTFREE
operator|)
expr_stmt|;
comment|/* copy is not constant or field */
comment|/* is DONTFREE right? */
return|return
name|y
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|arg
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* nth argument of a function */
block|{
name|n
operator|=
name|ptoi
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* argument number, counting from 0 */
name|dprintf
argument_list|(
operator|(
literal|"arg(%d), fp->nargs=%d\n"
operator|,
name|n
operator|,
name|fp
operator|->
name|nargs
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|+
literal|1
operator|>
name|fp
operator|->
name|nargs
condition|)
name|FATAL
argument_list|(
literal|"argument #%d of function %s was not supplied"
argument_list|,
name|n
operator|+
literal|1
argument_list|,
name|fp
operator|->
name|fcncell
operator|->
name|nval
argument_list|)
expr_stmt|;
return|return
name|fp
operator|->
name|args
index|[
name|n
index|]
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|jump
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* break, continue, next, nextfile, return */
block|{
name|Cell
modifier|*
name|y
decl_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|EXIT
case|:
if|if
condition|(
name|a
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|errorflag
operator|=
operator|(
name|int
operator|)
name|getfval
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
name|longjmp
argument_list|(
name|env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
case|case
name|RETURN
case|:
if|if
condition|(
name|a
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|->
name|tval
operator|&
operator|(
name|STR
operator||
name|NUM
operator|)
operator|)
operator|==
operator|(
name|STR
operator||
name|NUM
operator|)
condition|)
block|{
name|setsval
argument_list|(
name|fp
operator|->
name|retval
argument_list|,
name|getsval
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|retval
operator|->
name|fval
operator|=
name|getfval
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|fp
operator|->
name|retval
operator|->
name|tval
operator||=
name|NUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y
operator|->
name|tval
operator|&
name|STR
condition|)
name|setsval
argument_list|(
name|fp
operator|->
name|retval
argument_list|,
name|getsval
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|y
operator|->
name|tval
operator|&
name|NUM
condition|)
name|setfval
argument_list|(
name|fp
operator|->
name|retval
argument_list|,
name|getfval
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* can't happen */
name|FATAL
argument_list|(
literal|"bad type variable %d"
argument_list|,
name|y
operator|->
name|tval
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|jret
operator|)
return|;
case|case
name|NEXT
case|:
return|return
operator|(
name|jnext
operator|)
return|;
case|case
name|NEXTFILE
case|:
name|nextfile
argument_list|()
expr_stmt|;
return|return
operator|(
name|jnextfile
operator|)
return|;
case|case
name|BREAK
case|:
return|return
operator|(
name|jbreak
operator|)
return|;
case|case
name|CONTINUE
case|:
return|return
operator|(
name|jcont
operator|)
return|;
default|default:
comment|/* can't happen */
name|FATAL
argument_list|(
literal|"illegal jump type %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* not reached */
block|}
end_function

begin_function
name|Cell
modifier|*
name|awkgetline
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* get next line from specific input */
block|{
comment|/* a[0] is variable, a[1] is operator, a[2] is filename */
name|Cell
modifier|*
name|r
decl_stmt|,
modifier|*
name|x
decl_stmt|;
specifier|extern
name|Cell
modifier|*
modifier|*
name|fldtab
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|bufsize
init|=
name|recsize
decl_stmt|;
name|int
name|mode
decl_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bufsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"out of memory in getline"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* in case someone is waiting for a prompt */
name|r
operator|=
name|gettemp
argument_list|()
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
comment|/* getline< file */
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* filename */
name|mode
operator|=
name|ptoi
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|'|'
condition|)
comment|/* input pipe */
name|mode
operator|=
name|LE
expr_stmt|;
comment|/* arbitrary flag */
name|fp
operator|=
name|openfile
argument_list|(
name|mode
argument_list|,
name|getsval
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|n
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|n
operator|=
name|readrec
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsize
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
comment|/* getline var<file */
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|setsval
argument_list|(
name|x
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* getline<file */
name|setsval
argument_list|(
name|fldtab
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_number
argument_list|(
name|fldtab
index|[
literal|0
index|]
operator|->
name|sval
argument_list|)
condition|)
block|{
name|fldtab
index|[
literal|0
index|]
operator|->
name|fval
operator|=
name|atof
argument_list|(
name|fldtab
index|[
literal|0
index|]
operator|->
name|sval
argument_list|)
expr_stmt|;
name|fldtab
index|[
literal|0
index|]
operator|->
name|tval
operator||=
name|NUM
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* bare getline; use current input */
if|if
condition|(
name|a
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
comment|/* getline */
name|n
operator|=
name|getrec
argument_list|(
operator|&
name|record
argument_list|,
operator|&
name|recsize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* getline var */
name|n
operator|=
name|getrec
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|setsval
argument_list|(
name|x
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
name|setfval
argument_list|(
name|r
argument_list|,
operator|(
name|Awkfloat
operator|)
name|n
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|getnf
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* get NF */
block|{
if|if
condition|(
name|donefld
operator|==
literal|0
condition|)
name|fldbld
argument_list|()
expr_stmt|;
return|return
operator|(
name|Cell
operator|*
operator|)
name|a
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|array
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* a[0] is symtab, a[1] is list of subscripts */
block|{
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|,
modifier|*
name|z
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|Node
modifier|*
name|np
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|bufsz
init|=
name|recsize
decl_stmt|;
name|int
name|nsub
init|=
name|strlen
argument_list|(
operator|*
name|SUBSEP
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bufsz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"out of memory in array"
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Cell* for symbol table */
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|np
operator|=
name|a
index|[
literal|1
index|]
init|;
name|np
condition|;
name|np
operator|=
name|np
operator|->
name|nnext
control|)
block|{
name|y
operator|=
name|execute
argument_list|(
name|np
argument_list|)
expr_stmt|;
comment|/* subscript */
name|s
operator|=
name|getsval
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|adjbuf
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsz
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
name|nsub
operator|+
literal|1
argument_list|,
name|recsize
argument_list|,
literal|0
argument_list|,
literal|"array"
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"out of memory for %s[%s...]"
argument_list|,
name|x
operator|->
name|nval
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|nnext
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
operator|*
name|SUBSEP
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isarr
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"making %s into an array\n"
operator|,
name|NN
argument_list|(
name|x
operator|->
name|nval
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeable
argument_list|(
name|x
argument_list|)
condition|)
name|xfree
argument_list|(
name|x
operator|->
name|sval
argument_list|)
expr_stmt|;
name|x
operator|->
name|tval
operator|&=
operator|~
operator|(
name|STR
operator||
name|NUM
operator||
name|DONTFREE
operator|)
expr_stmt|;
name|x
operator|->
name|tval
operator||=
name|ARR
expr_stmt|;
name|x
operator|->
name|sval
operator|=
operator|(
name|char
operator|*
operator|)
name|makesymtab
argument_list|(
name|NSYMTAB
argument_list|)
expr_stmt|;
block|}
name|z
operator|=
name|setsymtab
argument_list|(
name|buf
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|STR
operator||
name|NUM
argument_list|,
operator|(
name|Array
operator|*
operator|)
name|x
operator|->
name|sval
argument_list|)
expr_stmt|;
name|z
operator|->
name|ctype
operator|=
name|OCELL
expr_stmt|;
name|z
operator|->
name|csub
operator|=
name|CVAR
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|z
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|awkdelete
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* a[0] is symtab, a[1] is list of subscripts */
block|{
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
name|Node
modifier|*
name|np
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|nsub
init|=
name|strlen
argument_list|(
operator|*
name|SUBSEP
argument_list|)
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Cell* for symbol table */
if|if
condition|(
operator|!
name|isarr
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|True
return|;
if|if
condition|(
name|a
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* delete the elements, not the table */
name|freesymtab
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|->
name|tval
operator|&=
operator|~
name|STR
expr_stmt|;
name|x
operator|->
name|tval
operator||=
name|ARR
expr_stmt|;
name|x
operator|->
name|sval
operator|=
operator|(
name|char
operator|*
operator|)
name|makesymtab
argument_list|(
name|NSYMTAB
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|bufsz
init|=
name|recsize
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bufsz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"out of memory in adelete"
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|np
operator|=
name|a
index|[
literal|1
index|]
init|;
name|np
condition|;
name|np
operator|=
name|np
operator|->
name|nnext
control|)
block|{
name|y
operator|=
name|execute
argument_list|(
name|np
argument_list|)
expr_stmt|;
comment|/* subscript */
name|s
operator|=
name|getsval
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|adjbuf
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsz
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
name|nsub
operator|+
literal|1
argument_list|,
name|recsize
argument_list|,
literal|0
argument_list|,
literal|"awkdelete"
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"out of memory deleting %s[%s...]"
argument_list|,
name|x
operator|->
name|nval
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|nnext
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
operator|*
name|SUBSEP
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
name|freeelem
argument_list|(
name|x
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|True
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|intest
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* a[0] is index (list), a[1] is symtab */
block|{
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|ap
decl_stmt|,
modifier|*
name|k
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|bufsz
init|=
name|recsize
decl_stmt|;
name|int
name|nsub
init|=
name|strlen
argument_list|(
operator|*
name|SUBSEP
argument_list|)
decl_stmt|;
name|ap
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* array name */
if|if
condition|(
operator|!
name|isarr
argument_list|(
name|ap
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"making %s into an array\n"
operator|,
name|ap
operator|->
name|nval
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeable
argument_list|(
name|ap
argument_list|)
condition|)
name|xfree
argument_list|(
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
name|ap
operator|->
name|tval
operator|&=
operator|~
operator|(
name|STR
operator||
name|NUM
operator||
name|DONTFREE
operator|)
expr_stmt|;
name|ap
operator|->
name|tval
operator||=
name|ARR
expr_stmt|;
name|ap
operator|->
name|sval
operator|=
operator|(
name|char
operator|*
operator|)
name|makesymtab
argument_list|(
name|NSYMTAB
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bufsz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|FATAL
argument_list|(
literal|"out of memory in intest"
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|a
index|[
literal|0
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nnext
control|)
block|{
name|x
operator|=
name|execute
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* expr */
name|s
operator|=
name|getsval
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|adjbuf
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsz
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
name|nsub
operator|+
literal|1
argument_list|,
name|recsize
argument_list|,
literal|0
argument_list|,
literal|"intest"
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"out of memory deleting %s[%s...]"
argument_list|,
name|x
operator|->
name|nval
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|nnext
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
operator|*
name|SUBSEP
argument_list|)
expr_stmt|;
block|}
name|k
operator|=
name|lookup
argument_list|(
name|buf
argument_list|,
operator|(
name|Array
operator|*
operator|)
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|NULL
condition|)
return|return
operator|(
name|False
operator|)
return|;
else|else
return|return
operator|(
name|True
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|matchop
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* ~ and match() */
block|{
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fa
modifier|*
name|pfa
decl_stmt|;
name|int
function_decl|(
modifier|*
name|mf
function_decl|)
parameter_list|(
name|fa
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
init|=
name|match
operator|,
function_decl|mode
init|=
literal|0
function_decl|;
if|if
condition|(
name|n
operator|==
name|MATCHFCN
condition|)
block|{
name|mf
operator|=
name|pmatch
expr_stmt|;
name|mode
operator|=
literal|1
expr_stmt|;
block|}
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* a[1] = target text */
name|s
operator|=
name|getsval
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
comment|/* a[1] == 0: already-compiled reg expr */
name|i
operator|=
call|(
modifier|*
name|mf
call|)
argument_list|(
operator|(
name|fa
operator|*
operator|)
name|a
index|[
literal|2
index|]
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
block|{
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* a[2] = regular expr */
name|t
operator|=
name|getsval
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|pfa
operator|=
name|makedfa
argument_list|(
name|t
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|i
operator|=
call|(
modifier|*
name|mf
call|)
argument_list|(
name|pfa
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|MATCHFCN
condition|)
block|{
name|int
name|start
init|=
name|patbeg
operator|-
name|s
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|patlen
operator|<
literal|0
condition|)
name|start
operator|=
literal|0
expr_stmt|;
name|setfval
argument_list|(
name|rstartloc
argument_list|,
operator|(
name|Awkfloat
operator|)
name|start
argument_list|)
expr_stmt|;
name|setfval
argument_list|(
name|rlengthloc
argument_list|,
operator|(
name|Awkfloat
operator|)
name|patlen
argument_list|)
expr_stmt|;
name|x
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|x
operator|->
name|tval
operator|=
name|NUM
expr_stmt|;
name|x
operator|->
name|fval
operator|=
name|start
expr_stmt|;
return|return
name|x
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|n
operator|==
name|MATCH
operator|&&
name|i
operator|==
literal|1
operator|)
operator|||
operator|(
name|n
operator|==
name|NOTMATCH
operator|&&
name|i
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|True
operator|)
return|;
else|else
return|return
operator|(
name|False
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|boolop
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* a[0] || a[1], a[0]&& a[1], !a[0] */
block|{
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
name|int
name|i
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
name|istrue
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|BOR
case|:
if|if
condition|(
name|i
condition|)
return|return
operator|(
name|True
operator|)
return|;
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
name|istrue
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
operator|(
name|True
operator|)
return|;
else|else
return|return
operator|(
name|False
operator|)
return|;
case|case
name|AND
case|:
if|if
condition|(
operator|!
name|i
condition|)
return|return
operator|(
name|False
operator|)
return|;
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
name|istrue
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
operator|(
name|True
operator|)
return|;
else|else
return|return
operator|(
name|False
operator|)
return|;
case|case
name|NOT
case|:
if|if
condition|(
name|i
condition|)
return|return
operator|(
name|False
operator|)
return|;
else|else
return|return
operator|(
name|True
operator|)
return|;
default|default:
comment|/* can't happen */
name|FATAL
argument_list|(
literal|"unknown boolean operator %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/*NOTREACHED*/
block|}
end_function

begin_function
name|Cell
modifier|*
name|relop
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* a[0< a[1], etc. */
block|{
name|int
name|i
decl_stmt|;
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
name|Awkfloat
name|j
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|tval
operator|&
name|NUM
operator|&&
name|y
operator|->
name|tval
operator|&
name|NUM
condition|)
block|{
name|j
operator|=
name|x
operator|->
name|fval
operator|-
name|y
operator|->
name|fval
expr_stmt|;
name|i
operator|=
name|j
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
operator|(
name|j
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|strcoll
argument_list|(
name|getsval
argument_list|(
name|x
argument_list|)
argument_list|,
name|getsval
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|LT
case|:
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|(
name|True
operator|)
return|;
else|else
return|return
operator|(
name|False
operator|)
return|;
case|case
name|LE
case|:
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
return|return
operator|(
name|True
operator|)
return|;
else|else
return|return
operator|(
name|False
operator|)
return|;
case|case
name|NE
case|:
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
operator|(
name|True
operator|)
return|;
else|else
return|return
operator|(
name|False
operator|)
return|;
case|case
name|EQ
case|:
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
name|True
operator|)
return|;
else|else
return|return
operator|(
name|False
operator|)
return|;
case|case
name|GE
case|:
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
return|return
operator|(
name|True
operator|)
return|;
else|else
return|return
operator|(
name|False
operator|)
return|;
case|case
name|GT
case|:
if|if
condition|(
name|i
operator|>
literal|0
condition|)
return|return
operator|(
name|True
operator|)
return|;
else|else
return|return
operator|(
name|False
operator|)
return|;
default|default:
comment|/* can't happen */
name|FATAL
argument_list|(
literal|"unknown relational operator %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/*NOTREACHED*/
block|}
end_function

begin_function
name|void
name|tfree
parameter_list|(
name|Cell
modifier|*
name|a
parameter_list|)
comment|/* free a tempcell */
block|{
if|if
condition|(
name|freeable
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"freeing %s %s %o\n"
operator|,
name|NN
argument_list|(
name|a
operator|->
name|nval
argument_list|)
operator|,
name|NN
argument_list|(
name|a
operator|->
name|sval
argument_list|)
operator|,
name|a
operator|->
name|tval
operator|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|a
operator|->
name|sval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|==
name|tmps
condition|)
name|FATAL
argument_list|(
literal|"tempcell list is curdled"
argument_list|)
expr_stmt|;
name|a
operator|->
name|cnext
operator|=
name|tmps
expr_stmt|;
name|tmps
operator|=
name|a
expr_stmt|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|gettemp
parameter_list|(
name|void
parameter_list|)
comment|/* get a tempcell */
block|{
name|int
name|i
decl_stmt|;
name|Cell
modifier|*
name|x
decl_stmt|;
if|if
condition|(
operator|!
name|tmps
condition|)
block|{
name|tmps
operator|=
operator|(
name|Cell
operator|*
operator|)
name|calloc
argument_list|(
literal|100
argument_list|,
sizeof|sizeof
argument_list|(
name|Cell
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmps
condition|)
name|FATAL
argument_list|(
literal|"out of space for temporaries"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
name|tmps
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|cnext
operator|=
operator|&
name|tmps
index|[
name|i
index|]
expr_stmt|;
name|tmps
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|cnext
operator|=
name|NULL
expr_stmt|;
block|}
name|x
operator|=
name|tmps
expr_stmt|;
name|tmps
operator|=
name|x
operator|->
name|cnext
expr_stmt|;
operator|*
name|x
operator|=
name|tempcell
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|indirect
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* $( a[0] ) */
block|{
name|Awkfloat
name|val
decl_stmt|;
name|Cell
modifier|*
name|x
decl_stmt|;
name|int
name|m
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|val
operator|=
name|getfval
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* freebsd: defend against super large field numbers */
if|if
condition|(
operator|(
name|Awkfloat
operator|)
name|INT_MAX
operator|<
name|val
condition|)
name|FATAL
argument_list|(
literal|"trying to access out of range field %s"
argument_list|,
name|x
operator|->
name|nval
argument_list|)
expr_stmt|;
name|m
operator|=
operator|(
name|int
operator|)
name|val
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
operator|&&
operator|!
name|is_number
argument_list|(
name|s
operator|=
name|getsval
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
comment|/* suspicion! */
name|FATAL
argument_list|(
literal|"illegal field $(%s), name \"%s\""
argument_list|,
name|s
argument_list|,
name|x
operator|->
name|nval
argument_list|)
expr_stmt|;
comment|/* BUG: can x->nval ever be null??? */
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|fieldadr
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|x
operator|->
name|ctype
operator|=
name|OCELL
expr_stmt|;
comment|/* BUG?  why are these needed? */
name|x
operator|->
name|csub
operator|=
name|CFLD
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|substr
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|nnn
parameter_list|)
comment|/* substr(a[0], a[1], a[2]) */
block|{
name|int
name|k
decl_stmt|,
name|m
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|,
modifier|*
name|z
init|=
name|NULL
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|2
index|]
operator|!=
name|NULL
condition|)
name|z
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|s
operator|=
name|getsval
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|k
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|k
operator|<=
literal|1
condition|)
block|{
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|2
index|]
operator|!=
name|NULL
condition|)
block|{
name|tempfree
argument_list|(
name|z
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|setsval
argument_list|(
name|x
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
name|m
operator|=
operator|(
name|int
operator|)
name|getfval
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|<=
literal|0
condition|)
name|m
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|>
name|k
condition|)
name|m
operator|=
name|k
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|2
index|]
operator|!=
name|NULL
condition|)
block|{
name|n
operator|=
operator|(
name|int
operator|)
name|getfval
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|z
argument_list|)
expr_stmt|;
block|}
else|else
name|n
operator|=
name|k
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|n
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|>
name|k
operator|-
name|m
condition|)
name|n
operator|=
name|k
operator|-
name|m
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"substr: m=%d, n=%d, s=%s\n"
operator|,
name|m
operator|,
name|n
operator|,
name|s
operator|)
argument_list|)
expr_stmt|;
name|y
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|temp
operator|=
name|s
index|[
name|n
operator|+
name|m
operator|-
literal|1
index|]
expr_stmt|;
comment|/* with thanks to John Linderman */
name|s
index|[
name|n
operator|+
name|m
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|setsval
argument_list|(
name|y
argument_list|,
name|s
operator|+
name|m
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s
index|[
name|n
operator|+
name|m
operator|-
literal|1
index|]
operator|=
name|temp
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|y
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|sindex
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|nnn
parameter_list|)
comment|/* index(a[0], a[1]) */
block|{
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|,
modifier|*
name|z
decl_stmt|;
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|Awkfloat
name|v
init|=
literal|0.0
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|s1
operator|=
name|getsval
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|s2
operator|=
name|getsval
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|z
operator|=
name|gettemp
argument_list|()
expr_stmt|;
for|for
control|(
name|p1
operator|=
name|s1
init|;
operator|*
name|p1
operator|!=
literal|'\0'
condition|;
name|p1
operator|++
control|)
block|{
for|for
control|(
name|q
operator|=
name|p1
operator|,
name|p2
operator|=
name|s2
init|;
operator|*
name|p2
operator|!=
literal|'\0'
operator|&&
operator|*
name|q
operator|==
operator|*
name|p2
condition|;
name|q
operator|++
operator|,
name|p2
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p2
operator|==
literal|'\0'
condition|)
block|{
name|v
operator|=
call|(
name|Awkfloat
call|)
argument_list|(
name|p1
operator|-
name|s1
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* origin 1 */
break|break;
block|}
block|}
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|setfval
argument_list|(
name|z
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
name|z
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAXNUMSIZE
value|50
end_define

begin_function
name|int
name|format
parameter_list|(
name|char
modifier|*
modifier|*
name|pbuf
parameter_list|,
name|int
modifier|*
name|pbufsize
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|Node
modifier|*
name|a
parameter_list|)
comment|/* printf-like conversions */
block|{
name|char
modifier|*
name|fmt
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
name|os
decl_stmt|;
name|Cell
modifier|*
name|x
decl_stmt|;
name|int
name|flag
init|=
literal|0
decl_stmt|,
name|n
decl_stmt|;
name|int
name|fmtwd
decl_stmt|;
comment|/* format width */
name|int
name|fmtsz
init|=
name|recsize
decl_stmt|;
name|char
modifier|*
name|buf
init|=
operator|*
name|pbuf
decl_stmt|;
name|int
name|bufsize
init|=
operator|*
name|pbufsize
decl_stmt|;
name|os
operator|=
name|s
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|(
name|fmt
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|fmtsz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"out of memory in format()"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|adjbuf
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsize
argument_list|,
name|MAXNUMSIZE
operator|+
literal|1
operator|+
name|p
operator|-
name|buf
argument_list|,
name|recsize
argument_list|,
operator|&
name|p
argument_list|,
literal|"format1"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'%'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'%'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'%'
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
comment|/* have to be real careful in case this is a huge number, eg, %100000d */
name|fmtwd
operator|=
name|atoi
argument_list|(
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmtwd
operator|<
literal|0
condition|)
name|fmtwd
operator|=
operator|-
name|fmtwd
expr_stmt|;
name|adjbuf
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsize
argument_list|,
name|fmtwd
operator|+
literal|1
operator|+
name|p
operator|-
name|buf
argument_list|,
name|recsize
argument_list|,
operator|&
name|p
argument_list|,
literal|"format2"
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|fmt
init|;
operator|(
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|)
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|adjbuf
argument_list|(
operator|&
name|fmt
argument_list|,
operator|&
name|fmtsz
argument_list|,
name|MAXNUMSIZE
operator|+
literal|1
operator|+
name|t
operator|-
name|fmt
argument_list|,
name|recsize
argument_list|,
operator|&
name|t
argument_list|,
literal|"format3"
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"format item %.30s... ran format() out of memory"
argument_list|,
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
operator|(
name|uschar
operator|)
operator|*
name|s
argument_list|)
operator|&&
operator|*
name|s
operator|!=
literal|'l'
operator|&&
operator|*
name|s
operator|!=
literal|'h'
operator|&&
operator|*
name|s
operator|!=
literal|'L'
condition|)
break|break;
comment|/* the ansi panoply */
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
condition|)
block|{
name|x
operator|=
name|execute
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|a
operator|=
name|a
operator|->
name|nnext
expr_stmt|;
name|sprintf
argument_list|(
name|t
operator|-
literal|1
argument_list|,
literal|"%d"
argument_list|,
name|fmtwd
operator|=
operator|(
name|int
operator|)
name|getfval
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmtwd
operator|<
literal|0
condition|)
name|fmtwd
operator|=
operator|-
name|fmtwd
expr_stmt|;
name|adjbuf
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsize
argument_list|,
name|fmtwd
operator|+
literal|1
operator|+
name|p
operator|-
name|buf
argument_list|,
name|recsize
argument_list|,
operator|&
name|p
argument_list|,
literal|"format"
argument_list|)
expr_stmt|;
name|t
operator|=
name|fmt
operator|+
name|strlen
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|fmtwd
operator|<
literal|0
condition|)
name|fmtwd
operator|=
operator|-
name|fmtwd
expr_stmt|;
name|adjbuf
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsize
argument_list|,
name|fmtwd
operator|+
literal|1
operator|+
name|p
operator|-
name|buf
argument_list|,
name|recsize
argument_list|,
operator|&
name|p
argument_list|,
literal|"format4"
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'e'
case|:
case|case
literal|'g'
case|:
case|case
literal|'E'
case|:
case|case
literal|'G'
case|:
name|flag
operator|=
literal|'f'
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
name|flag
operator|=
literal|'d'
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|==
literal|'l'
condition|)
break|break;
operator|*
operator|(
name|t
operator|-
literal|1
operator|)
operator|=
literal|'l'
expr_stmt|;
operator|*
name|t
operator|=
literal|'d'
expr_stmt|;
operator|*
operator|++
name|t
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
case|case
literal|'u'
case|:
name|flag
operator|=
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|==
literal|'l'
condition|?
literal|'d'
else|:
literal|'u'
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|flag
operator|=
literal|'s'
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|flag
operator|=
literal|'c'
expr_stmt|;
break|break;
default|default:
name|WARNING
argument_list|(
literal|"weird printf conversion %s"
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|flag
operator|=
literal|'?'
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"not enough args in printf(%s)"
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|a
operator|=
name|a
operator|->
name|nnext
expr_stmt|;
name|n
operator|=
name|MAXNUMSIZE
expr_stmt|;
if|if
condition|(
name|fmtwd
operator|>
name|n
condition|)
name|n
operator|=
name|fmtwd
expr_stmt|;
name|adjbuf
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsize
argument_list|,
literal|1
operator|+
name|n
operator|+
name|p
operator|-
name|buf
argument_list|,
name|recsize
argument_list|,
operator|&
name|p
argument_list|,
literal|"format5"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
literal|'?'
case|:
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s"
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
comment|/* unknown, so dump it too */
name|t
operator|=
name|getsval
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmtwd
operator|>
name|n
condition|)
name|n
operator|=
name|fmtwd
expr_stmt|;
name|adjbuf
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsize
argument_list|,
literal|1
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
name|n
operator|+
name|p
operator|-
name|buf
argument_list|,
name|recsize
argument_list|,
operator|&
name|p
argument_list|,
literal|"format6"
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|sprintf
argument_list|(
name|p
argument_list|,
name|fmt
argument_list|,
name|getfval
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|sprintf
argument_list|(
name|p
argument_list|,
name|fmt
argument_list|,
operator|(
name|long
operator|)
name|getfval
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|sprintf
argument_list|(
name|p
argument_list|,
name|fmt
argument_list|,
operator|(
name|int
operator|)
name|getfval
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|t
operator|=
name|getsval
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmtwd
operator|>
name|n
condition|)
name|n
operator|=
name|fmtwd
expr_stmt|;
if|if
condition|(
operator|!
name|adjbuf
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsize
argument_list|,
literal|1
operator|+
name|n
operator|+
name|p
operator|-
name|buf
argument_list|,
name|recsize
argument_list|,
operator|&
name|p
argument_list|,
literal|"format7"
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"huge string/format (%d chars) in printf %.30s... ran format() out of memory"
argument_list|,
name|n
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
name|fmt
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|isnum
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|getfval
argument_list|(
name|x
argument_list|)
condition|)
name|sprintf
argument_list|(
name|p
argument_list|,
name|fmt
argument_list|,
operator|(
name|int
operator|)
name|getfval
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* explicit null byte */
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* next output will start here */
block|}
block|}
else|else
name|sprintf
argument_list|(
name|p
argument_list|,
name|fmt
argument_list|,
name|getsval
argument_list|(
name|x
argument_list|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|FATAL
argument_list|(
literal|"can't happen: bad conversion %c in format()"
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|free
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|a
condition|;
name|a
operator|=
name|a
operator|->
name|nnext
control|)
comment|/* evaluate any remaining args */
name|execute
argument_list|(
name|a
argument_list|)
expr_stmt|;
operator|*
name|pbuf
operator|=
name|buf
expr_stmt|;
operator|*
name|pbufsize
operator|=
name|bufsize
expr_stmt|;
return|return
name|p
operator|-
name|buf
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|awksprintf
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* sprintf(a[0]) */
block|{
name|Cell
modifier|*
name|x
decl_stmt|;
name|Node
modifier|*
name|y
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|bufsz
init|=
literal|3
operator|*
name|recsize
decl_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bufsz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"out of memory in awksprintf"
argument_list|)
expr_stmt|;
name|y
operator|=
name|a
index|[
literal|0
index|]
operator|->
name|nnext
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsz
argument_list|,
name|getsval
argument_list|(
name|x
argument_list|)
argument_list|,
name|y
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|FATAL
argument_list|(
literal|"sprintf string %.30s... too long.  can't happen."
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|x
operator|->
name|sval
operator|=
name|buf
expr_stmt|;
name|x
operator|->
name|tval
operator|=
name|STR
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|awkprintf
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* printf */
block|{
comment|/* a[0] is list of args, starting with format string */
comment|/* a[1] is redirection operator, a[2] is redirection file */
name|FILE
modifier|*
name|fp
decl_stmt|;
name|Cell
modifier|*
name|x
decl_stmt|;
name|Node
modifier|*
name|y
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|bufsz
init|=
literal|3
operator|*
name|recsize
decl_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bufsz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"out of memory in awkprintf"
argument_list|)
expr_stmt|;
name|y
operator|=
name|a
index|[
literal|0
index|]
operator|->
name|nnext
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|format
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsz
argument_list|,
name|getsval
argument_list|(
name|x
argument_list|)
argument_list|,
name|y
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|FATAL
argument_list|(
literal|"printf string %.30s... too long.  can't happen."
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* fputs(buf, stdout); */
name|fwrite
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"write error on stdout"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|=
name|redirect
argument_list|(
name|ptoi
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* fputs(buf, fp); */
name|fwrite
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"write error on %s"
argument_list|,
name|filename
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|True
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|arith
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* a[0] + a[1], etc.  also -a[0] */
block|{
name|Awkfloat
name|i
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|double
name|v
decl_stmt|;
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|,
modifier|*
name|z
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
name|getfval
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|UMINUS
condition|)
block|{
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
name|getfval
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
name|z
operator|=
name|gettemp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|ADD
case|:
name|i
operator|+=
name|j
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|i
operator|-=
name|j
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|i
operator|*=
name|j
expr_stmt|;
break|break;
case|case
name|DIVIDE
case|:
if|if
condition|(
name|j
operator|==
literal|0
condition|)
name|FATAL
argument_list|(
literal|"division by zero"
argument_list|)
expr_stmt|;
name|i
operator|/=
name|j
expr_stmt|;
break|break;
case|case
name|MOD
case|:
if|if
condition|(
name|j
operator|==
literal|0
condition|)
name|FATAL
argument_list|(
literal|"division by zero in mod"
argument_list|)
expr_stmt|;
name|modf
argument_list|(
name|i
operator|/
name|j
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|i
operator|=
name|i
operator|-
name|j
operator|*
name|v
expr_stmt|;
break|break;
case|case
name|UMINUS
case|:
name|i
operator|=
operator|-
name|i
expr_stmt|;
break|break;
case|case
name|POWER
case|:
if|if
condition|(
name|j
operator|>=
literal|0
operator|&&
name|modf
argument_list|(
name|j
argument_list|,
operator|&
name|v
argument_list|)
operator|==
literal|0.0
condition|)
comment|/* pos integer exponent */
name|i
operator|=
name|ipow
argument_list|(
name|i
argument_list|,
operator|(
name|int
operator|)
name|j
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|errcheck
argument_list|(
name|pow
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
literal|"pow"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* can't happen */
name|FATAL
argument_list|(
literal|"illegal arithmetic operator %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|setfval
argument_list|(
name|z
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|z
operator|)
return|;
block|}
end_function

begin_function
name|double
name|ipow
parameter_list|(
name|double
name|x
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* x**n.  ought to be done by pow, but isn't always */
block|{
name|double
name|v
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
name|v
operator|=
name|ipow
argument_list|(
name|x
argument_list|,
name|n
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|%
literal|2
operator|==
literal|0
condition|)
return|return
name|v
operator|*
name|v
return|;
else|else
return|return
name|x
operator|*
name|v
operator|*
name|v
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|incrdecr
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* a[0]++, etc. */
block|{
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|z
decl_stmt|;
name|int
name|k
decl_stmt|;
name|Awkfloat
name|xf
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|xf
operator|=
name|getfval
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|k
operator|=
operator|(
name|n
operator|==
name|PREINCR
operator|||
name|n
operator|==
name|POSTINCR
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|PREINCR
operator|||
name|n
operator|==
name|PREDECR
condition|)
block|{
name|setfval
argument_list|(
name|x
argument_list|,
name|xf
operator|+
name|k
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
name|z
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|setfval
argument_list|(
name|z
argument_list|,
name|xf
argument_list|)
expr_stmt|;
name|setfval
argument_list|(
name|x
argument_list|,
name|xf
operator|+
name|k
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|z
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|assign
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* a[0] = a[1], a[0] += a[1], etc. */
block|{
comment|/* this is subtle; don't muck with it. */
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
name|Awkfloat
name|xf
decl_stmt|,
name|yf
decl_stmt|;
name|double
name|v
decl_stmt|;
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|ASSIGN
condition|)
block|{
comment|/* ordinary assignment */
if|if
condition|(
name|x
operator|==
name|y
operator|&&
operator|!
operator|(
name|x
operator|->
name|tval
operator|&
operator|(
name|FLD
operator||
name|REC
operator|)
operator|)
condition|)
comment|/* self-assignment: */
empty_stmt|;
comment|/* leave alone unless it's a field */
elseif|else
if|if
condition|(
operator|(
name|y
operator|->
name|tval
operator|&
operator|(
name|STR
operator||
name|NUM
operator|)
operator|)
operator|==
operator|(
name|STR
operator||
name|NUM
operator|)
condition|)
block|{
name|setsval
argument_list|(
name|x
argument_list|,
name|getsval
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|->
name|fval
operator|=
name|getfval
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|x
operator|->
name|tval
operator||=
name|NUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isstr
argument_list|(
name|y
argument_list|)
condition|)
name|setsval
argument_list|(
name|x
argument_list|,
name|getsval
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isnum
argument_list|(
name|y
argument_list|)
condition|)
name|setfval
argument_list|(
name|x
argument_list|,
name|getfval
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|funnyvar
argument_list|(
name|y
argument_list|,
literal|"read value of"
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
name|xf
operator|=
name|getfval
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|yf
operator|=
name|getfval
argument_list|(
name|y
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|ADDEQ
case|:
name|xf
operator|+=
name|yf
expr_stmt|;
break|break;
case|case
name|SUBEQ
case|:
name|xf
operator|-=
name|yf
expr_stmt|;
break|break;
case|case
name|MULTEQ
case|:
name|xf
operator|*=
name|yf
expr_stmt|;
break|break;
case|case
name|DIVEQ
case|:
if|if
condition|(
name|yf
operator|==
literal|0
condition|)
name|FATAL
argument_list|(
literal|"division by zero in /="
argument_list|)
expr_stmt|;
name|xf
operator|/=
name|yf
expr_stmt|;
break|break;
case|case
name|MODEQ
case|:
if|if
condition|(
name|yf
operator|==
literal|0
condition|)
name|FATAL
argument_list|(
literal|"division by zero in %%="
argument_list|)
expr_stmt|;
name|modf
argument_list|(
name|xf
operator|/
name|yf
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|xf
operator|=
name|xf
operator|-
name|yf
operator|*
name|v
expr_stmt|;
break|break;
case|case
name|POWEQ
case|:
if|if
condition|(
name|yf
operator|>=
literal|0
operator|&&
name|modf
argument_list|(
name|yf
argument_list|,
operator|&
name|v
argument_list|)
operator|==
literal|0.0
condition|)
comment|/* pos integer exponent */
name|xf
operator|=
name|ipow
argument_list|(
name|xf
argument_list|,
operator|(
name|int
operator|)
name|yf
argument_list|)
expr_stmt|;
else|else
name|xf
operator|=
name|errcheck
argument_list|(
name|pow
argument_list|(
name|xf
argument_list|,
name|yf
argument_list|)
argument_list|,
literal|"pow"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|FATAL
argument_list|(
literal|"illegal assignment operator %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
block|}
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|setfval
argument_list|(
name|x
argument_list|,
name|xf
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|cat
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|q
parameter_list|)
comment|/* a[0] cat a[1] */
block|{
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|,
modifier|*
name|z
decl_stmt|;
name|int
name|n1
decl_stmt|,
name|n2
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|getsval
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|getsval
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|n1
operator|=
name|strlen
argument_list|(
name|x
operator|->
name|sval
argument_list|)
expr_stmt|;
name|n2
operator|=
name|strlen
argument_list|(
name|y
operator|->
name|sval
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|n1
operator|+
name|n2
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"out of space concatenating %.15s... and %.15s..."
argument_list|,
name|x
operator|->
name|sval
argument_list|,
name|y
operator|->
name|sval
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|x
operator|->
name|sval
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
operator|+
name|n1
argument_list|,
name|y
operator|->
name|sval
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|z
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|z
operator|->
name|sval
operator|=
name|s
expr_stmt|;
name|z
operator|->
name|tval
operator|=
name|STR
expr_stmt|;
return|return
operator|(
name|z
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|pastat
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* a[0] { a[1] } */
block|{
name|Cell
modifier|*
name|x
decl_stmt|;
if|if
condition|(
name|a
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|istrue
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|dopa2
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* a[0], a[1] { a[2] } */
block|{
name|Cell
modifier|*
name|x
decl_stmt|;
name|int
name|pair
decl_stmt|;
name|pair
operator|=
name|ptoi
argument_list|(
name|a
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pairstack
index|[
name|pair
index|]
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|istrue
argument_list|(
name|x
argument_list|)
condition|)
name|pairstack
index|[
name|pair
index|]
operator|=
literal|1
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pairstack
index|[
name|pair
index|]
operator|==
literal|1
condition|)
block|{
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|istrue
argument_list|(
name|x
argument_list|)
condition|)
name|pairstack
index|[
name|pair
index|]
operator|=
literal|0
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
return|return
operator|(
name|False
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|split
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|nnn
parameter_list|)
comment|/* split(a[0], a[1], a[2]); a[3] is type */
block|{
name|Cell
modifier|*
name|x
init|=
name|NULL
decl_stmt|,
modifier|*
name|y
decl_stmt|,
modifier|*
name|ap
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|origs
decl_stmt|;
name|int
name|sep
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|,
name|temp
decl_stmt|,
name|num
index|[
literal|50
index|]
decl_stmt|,
modifier|*
name|fs
init|=
name|NULL
decl_stmt|;
name|int
name|n
decl_stmt|,
name|tempstat
decl_stmt|,
name|arg3type
decl_stmt|;
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* source string */
name|origs
operator|=
name|s
operator|=
name|strdup
argument_list|(
name|getsval
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|arg3type
operator|=
name|ptoi
argument_list|(
name|a
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|2
index|]
operator|==
name|NULL
condition|)
comment|/* fs string */
name|fs
operator|=
operator|*
name|FS
expr_stmt|;
elseif|else
if|if
condition|(
name|arg3type
operator|==
name|STRING
condition|)
block|{
comment|/* split(str,arr,"string") */
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|fs
operator|=
name|getsval
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg3type
operator|==
name|REGEXPR
condition|)
name|fs
operator|=
literal|"(regexpr)"
expr_stmt|;
comment|/* split(str,arr,/regexpr/) */
else|else
name|FATAL
argument_list|(
literal|"illegal type of split"
argument_list|)
expr_stmt|;
name|sep
operator|=
operator|*
name|fs
expr_stmt|;
name|ap
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* array name */
name|freesymtab
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"split: s=|%s|, a=%s, sep=|%s|\n"
operator|,
name|s
operator|,
name|NN
argument_list|(
name|ap
operator|->
name|nval
argument_list|)
operator|,
name|fs
operator|)
argument_list|)
expr_stmt|;
name|ap
operator|->
name|tval
operator|&=
operator|~
name|STR
expr_stmt|;
name|ap
operator|->
name|tval
operator||=
name|ARR
expr_stmt|;
name|ap
operator|->
name|sval
operator|=
operator|(
name|char
operator|*
operator|)
name|makesymtab
argument_list|(
name|NSYMTAB
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arg3type
operator|==
name|REGEXPR
operator|&&
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|fa
operator|*
operator|)
name|a
index|[
literal|2
index|]
operator|)
operator|->
name|restr
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* split(s, a, //); have to arrange that it looks like empty sep */
name|arg3type
operator|=
literal|0
expr_stmt|;
name|fs
operator|=
literal|""
expr_stmt|;
name|sep
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
operator|(
name|strlen
argument_list|(
name|fs
argument_list|)
operator|>
literal|1
operator|||
name|arg3type
operator|==
name|REGEXPR
operator|)
condition|)
block|{
comment|/* reg expr */
name|fa
modifier|*
name|pfa
decl_stmt|;
if|if
condition|(
name|arg3type
operator|==
name|REGEXPR
condition|)
block|{
comment|/* it's ready already */
name|pfa
operator|=
operator|(
name|fa
operator|*
operator|)
name|a
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
name|pfa
operator|=
name|makedfa
argument_list|(
name|fs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nematch
argument_list|(
name|pfa
argument_list|,
name|s
argument_list|)
condition|)
block|{
name|tempstat
operator|=
name|pfa
operator|->
name|initstat
expr_stmt|;
name|pfa
operator|->
name|initstat
operator|=
literal|2
expr_stmt|;
do|do
block|{
name|n
operator|++
expr_stmt|;
name|sprintf
argument_list|(
name|num
argument_list|,
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|*
name|patbeg
expr_stmt|;
operator|*
name|patbeg
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|is_number
argument_list|(
name|s
argument_list|)
condition|)
name|setsymtab
argument_list|(
name|num
argument_list|,
name|s
argument_list|,
name|atof
argument_list|(
name|s
argument_list|)
argument_list|,
name|STR
operator||
name|NUM
argument_list|,
operator|(
name|Array
operator|*
operator|)
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
else|else
name|setsymtab
argument_list|(
name|num
argument_list|,
name|s
argument_list|,
literal|0.0
argument_list|,
name|STR
argument_list|,
operator|(
name|Array
operator|*
operator|)
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
operator|*
name|patbeg
operator|=
name|temp
expr_stmt|;
name|s
operator|=
name|patbeg
operator|+
name|patlen
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|patbeg
operator|+
name|patlen
operator|-
literal|1
operator|)
operator|==
literal|0
operator|||
operator|*
name|s
operator|==
literal|0
condition|)
block|{
name|n
operator|++
expr_stmt|;
name|sprintf
argument_list|(
name|num
argument_list|,
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|setsymtab
argument_list|(
name|num
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|STR
argument_list|,
operator|(
name|Array
operator|*
operator|)
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
name|pfa
operator|->
name|initstat
operator|=
name|tempstat
expr_stmt|;
goto|goto
name|spdone
goto|;
block|}
block|}
do|while
condition|(
name|nematch
argument_list|(
name|pfa
argument_list|,
name|s
argument_list|)
condition|)
do|;
name|pfa
operator|->
name|initstat
operator|=
name|tempstat
expr_stmt|;
comment|/* bwk: has to be here to reset */
comment|/* cf gsub and refldbld */
block|}
name|n
operator|++
expr_stmt|;
name|sprintf
argument_list|(
name|num
argument_list|,
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_number
argument_list|(
name|s
argument_list|)
condition|)
name|setsymtab
argument_list|(
name|num
argument_list|,
name|s
argument_list|,
name|atof
argument_list|(
name|s
argument_list|)
argument_list|,
name|STR
operator||
name|NUM
argument_list|,
operator|(
name|Array
operator|*
operator|)
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
else|else
name|setsymtab
argument_list|(
name|num
argument_list|,
name|s
argument_list|,
literal|0.0
argument_list|,
name|STR
argument_list|,
operator|(
name|Array
operator|*
operator|)
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
name|spdone
label|:
name|pfa
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sep
operator|==
literal|' '
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
operator|||
operator|*
name|s
operator|==
literal|'\n'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|0
condition|)
break|break;
name|n
operator|++
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
do|do
name|s
operator|++
expr_stmt|;
do|while
condition|(
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
name|s
operator|!=
literal|'\t'
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|)
do|;
name|temp
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
name|num
argument_list|,
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_number
argument_list|(
name|t
argument_list|)
condition|)
name|setsymtab
argument_list|(
name|num
argument_list|,
name|t
argument_list|,
name|atof
argument_list|(
name|t
argument_list|)
argument_list|,
name|STR
operator||
name|NUM
argument_list|,
operator|(
name|Array
operator|*
operator|)
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
else|else
name|setsymtab
argument_list|(
name|num
argument_list|,
name|t
argument_list|,
literal|0.0
argument_list|,
name|STR
argument_list|,
operator|(
name|Array
operator|*
operator|)
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|temp
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|0
condition|)
name|s
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sep
operator|==
literal|0
condition|)
block|{
comment|/* new: split(s, a, "") => 1 char/elem */
for|for
control|(
name|n
operator|=
literal|0
init|;
operator|*
name|s
operator|!=
literal|0
condition|;
name|s
operator|++
control|)
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|n
operator|++
expr_stmt|;
name|sprintf
argument_list|(
name|num
argument_list|,
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
operator|*
name|s
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|uschar
operator|)
name|buf
index|[
literal|0
index|]
argument_list|)
condition|)
name|setsymtab
argument_list|(
name|num
argument_list|,
name|buf
argument_list|,
name|atof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|STR
operator||
name|NUM
argument_list|,
operator|(
name|Array
operator|*
operator|)
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
else|else
name|setsymtab
argument_list|(
name|num
argument_list|,
name|buf
argument_list|,
literal|0.0
argument_list|,
name|STR
argument_list|,
operator|(
name|Array
operator|*
operator|)
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|!=
literal|0
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|n
operator|++
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
name|sep
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|s
operator|++
expr_stmt|;
name|temp
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
name|num
argument_list|,
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_number
argument_list|(
name|t
argument_list|)
condition|)
name|setsymtab
argument_list|(
name|num
argument_list|,
name|t
argument_list|,
name|atof
argument_list|(
name|t
argument_list|)
argument_list|,
name|STR
operator||
name|NUM
argument_list|,
operator|(
name|Array
operator|*
operator|)
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
else|else
name|setsymtab
argument_list|(
name|num
argument_list|,
name|t
argument_list|,
literal|0.0
argument_list|,
name|STR
argument_list|,
operator|(
name|Array
operator|*
operator|)
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|temp
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|0
condition|)
break|break;
block|}
block|}
name|tempfree
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|origs
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|2
index|]
operator|!=
name|NULL
operator|&&
name|arg3type
operator|==
name|STRING
condition|)
block|{
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|x
operator|->
name|tval
operator|=
name|NUM
expr_stmt|;
name|x
operator|->
name|fval
operator|=
name|n
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|condexpr
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* a[0] ? a[1] : a[2] */
block|{
name|Cell
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|istrue
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|ifstat
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* if (a[0]) a[1]; else a[2] */
block|{
name|Cell
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|istrue
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
index|[
literal|2
index|]
operator|!=
name|NULL
condition|)
block|{
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|whilestat
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* while (a[0]) a[1] */
block|{
name|Cell
modifier|*
name|x
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|istrue
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|isbreak
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|x
operator|=
name|True
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
if|if
condition|(
name|isnext
argument_list|(
name|x
argument_list|)
operator|||
name|isexit
argument_list|(
name|x
argument_list|)
operator|||
name|isret
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Cell
modifier|*
name|dostat
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* do a[0]; while(a[1]) */
block|{
name|Cell
modifier|*
name|x
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|isbreak
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|True
return|;
if|if
condition|(
name|isnext
argument_list|(
name|x
argument_list|)
operator|||
name|isexit
argument_list|(
name|x
argument_list|)
operator|||
name|isret
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|istrue
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Cell
modifier|*
name|forstat
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* for (a[0]; a[1]; a[2]) a[3] */
block|{
name|Cell
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|a
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|istrue
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
else|else
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|isbreak
argument_list|(
name|x
argument_list|)
condition|)
comment|/* turn off break */
return|return
name|True
return|;
if|if
condition|(
name|isnext
argument_list|(
name|x
argument_list|)
operator|||
name|isexit
argument_list|(
name|x
argument_list|)
operator|||
name|isret
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Cell
modifier|*
name|instat
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* for (a[0] in a[1]) a[2] */
block|{
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|vp
decl_stmt|,
modifier|*
name|arrayp
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ncp
decl_stmt|;
name|Array
modifier|*
name|tp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vp
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|arrayp
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isarr
argument_list|(
name|arrayp
argument_list|)
condition|)
block|{
return|return
name|True
return|;
block|}
name|tp
operator|=
operator|(
name|Array
operator|*
operator|)
name|arrayp
operator|->
name|sval
expr_stmt|;
name|tempfree
argument_list|(
name|arrayp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tp
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
comment|/* this routine knows too much */
for|for
control|(
name|cp
operator|=
name|tp
operator|->
name|tab
index|[
name|i
index|]
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|ncp
control|)
block|{
name|setsval
argument_list|(
name|vp
argument_list|,
name|cp
operator|->
name|nval
argument_list|)
expr_stmt|;
name|ncp
operator|=
name|cp
operator|->
name|cnext
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|isbreak
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|tempfree
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
name|True
return|;
block|}
if|if
condition|(
name|isnext
argument_list|(
name|x
argument_list|)
operator|||
name|isexit
argument_list|(
name|x
argument_list|)
operator|||
name|isret
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|tempfree
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|True
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|bltin
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* builtin functions. a[0] is type, a[1] is arg list */
block|{
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
name|Awkfloat
name|u
decl_stmt|;
name|int
name|t
decl_stmt|,
name|i
decl_stmt|;
name|Awkfloat
name|tmp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|Node
modifier|*
name|nextarg
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|void
name|flush_all
argument_list|(
name|void
argument_list|)
decl_stmt|;
name|t
operator|=
name|ptoi
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|nextarg
operator|=
name|a
index|[
literal|1
index|]
operator|->
name|nnext
expr_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|FLENGTH
case|:
if|if
condition|(
name|isarr
argument_list|(
name|x
argument_list|)
condition|)
name|u
operator|=
operator|(
operator|(
name|Array
operator|*
operator|)
name|x
operator|->
name|sval
operator|)
operator|->
name|nelem
expr_stmt|;
comment|/* GROT.  should be function*/
else|else
name|u
operator|=
name|strlen
argument_list|(
name|getsval
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOG
case|:
name|u
operator|=
name|errcheck
argument_list|(
name|log
argument_list|(
name|getfval
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
literal|"log"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FINT
case|:
name|modf
argument_list|(
name|getfval
argument_list|(
name|x
argument_list|)
argument_list|,
operator|&
name|u
argument_list|)
expr_stmt|;
break|break;
case|case
name|FEXP
case|:
name|u
operator|=
name|errcheck
argument_list|(
name|exp
argument_list|(
name|getfval
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
literal|"exp"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSQRT
case|:
name|u
operator|=
name|errcheck
argument_list|(
name|sqrt
argument_list|(
name|getfval
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
literal|"sqrt"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSIN
case|:
name|u
operator|=
name|sin
argument_list|(
name|getfval
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FCOS
case|:
name|u
operator|=
name|cos
argument_list|(
name|getfval
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FATAN
case|:
if|if
condition|(
name|nextarg
operator|==
name|NULL
condition|)
block|{
name|WARNING
argument_list|(
literal|"atan2 requires two arguments; returning 1.0"
argument_list|)
expr_stmt|;
name|u
operator|=
literal|1.0
expr_stmt|;
block|}
else|else
block|{
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
operator|->
name|nnext
argument_list|)
expr_stmt|;
name|u
operator|=
name|atan2
argument_list|(
name|getfval
argument_list|(
name|x
argument_list|)
argument_list|,
name|getfval
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|nextarg
operator|=
name|nextarg
operator|->
name|nnext
expr_stmt|;
block|}
break|break;
case|case
name|FCOMPL
case|:
name|u
operator|=
operator|~
operator|(
operator|(
name|int
operator|)
name|getfval
argument_list|(
name|x
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|FAND
case|:
if|if
condition|(
name|nextarg
operator|==
name|NULL
condition|)
block|{
name|WARNING
argument_list|(
literal|"and requires two arguments; returning 0"
argument_list|)
expr_stmt|;
name|u
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|i
operator|=
operator|(
operator|(
name|int
operator|)
name|getfval
argument_list|(
name|x
argument_list|)
operator|)
expr_stmt|;
while|while
condition|(
name|nextarg
operator|!=
name|NULL
condition|)
block|{
name|y
operator|=
name|execute
argument_list|(
name|nextarg
argument_list|)
expr_stmt|;
name|i
operator|&=
operator|(
name|int
operator|)
name|getfval
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|nextarg
operator|=
name|nextarg
operator|->
name|nnext
expr_stmt|;
block|}
name|u
operator|=
name|i
expr_stmt|;
break|break;
case|case
name|FFOR
case|:
if|if
condition|(
name|nextarg
operator|==
name|NULL
condition|)
block|{
name|WARNING
argument_list|(
literal|"or requires two arguments; returning 0"
argument_list|)
expr_stmt|;
name|u
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|i
operator|=
operator|(
operator|(
name|int
operator|)
name|getfval
argument_list|(
name|x
argument_list|)
operator|)
expr_stmt|;
while|while
condition|(
name|nextarg
operator|!=
name|NULL
condition|)
block|{
name|y
operator|=
name|execute
argument_list|(
name|nextarg
argument_list|)
expr_stmt|;
name|i
operator||=
operator|(
name|int
operator|)
name|getfval
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|nextarg
operator|=
name|nextarg
operator|->
name|nnext
expr_stmt|;
block|}
name|u
operator|=
name|i
expr_stmt|;
break|break;
case|case
name|FXOR
case|:
if|if
condition|(
name|nextarg
operator|==
name|NULL
condition|)
block|{
name|WARNING
argument_list|(
literal|"xor requires two arguments; returning 0"
argument_list|)
expr_stmt|;
name|u
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|i
operator|=
operator|(
operator|(
name|int
operator|)
name|getfval
argument_list|(
name|x
argument_list|)
operator|)
expr_stmt|;
while|while
condition|(
name|nextarg
operator|!=
name|NULL
condition|)
block|{
name|y
operator|=
name|execute
argument_list|(
name|nextarg
argument_list|)
expr_stmt|;
name|i
operator|^=
operator|(
name|int
operator|)
name|getfval
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|nextarg
operator|=
name|nextarg
operator|->
name|nnext
expr_stmt|;
block|}
name|u
operator|=
name|i
expr_stmt|;
break|break;
case|case
name|FLSHIFT
case|:
if|if
condition|(
name|nextarg
operator|==
name|NULL
condition|)
block|{
name|WARNING
argument_list|(
literal|"lshift requires two arguments; returning 0"
argument_list|)
expr_stmt|;
name|u
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
operator|->
name|nnext
argument_list|)
expr_stmt|;
name|u
operator|=
operator|(
operator|(
name|int
operator|)
name|getfval
argument_list|(
name|x
argument_list|)
operator|)
operator|<<
operator|(
operator|(
name|int
operator|)
name|getfval
argument_list|(
name|y
argument_list|)
operator|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|nextarg
operator|=
name|nextarg
operator|->
name|nnext
expr_stmt|;
break|break;
case|case
name|FRSHIFT
case|:
if|if
condition|(
name|nextarg
operator|==
name|NULL
condition|)
block|{
name|WARNING
argument_list|(
literal|"rshift requires two arguments; returning 0"
argument_list|)
expr_stmt|;
name|u
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
operator|->
name|nnext
argument_list|)
expr_stmt|;
name|u
operator|=
operator|(
operator|(
name|int
operator|)
name|getfval
argument_list|(
name|x
argument_list|)
operator|)
operator|>>
operator|(
operator|(
name|int
operator|)
name|getfval
argument_list|(
name|y
argument_list|)
operator|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|nextarg
operator|=
name|nextarg
operator|->
name|nnext
expr_stmt|;
break|break;
case|case
name|FSYSTEM
case|:
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* in case something is buffered already */
name|u
operator|=
operator|(
name|Awkfloat
operator|)
name|system
argument_list|(
name|getsval
argument_list|(
name|x
argument_list|)
argument_list|)
operator|/
literal|256
expr_stmt|;
comment|/* 256 is unix-dep */
break|break;
case|case
name|FRAND
case|:
comment|/* random() returns numbers in [0..2^31-1] 		 * in order to get a number in [0, 1), divide it by 2^31 		 */
name|u
operator|=
operator|(
name|Awkfloat
operator|)
name|random
argument_list|()
operator|/
operator|(
literal|0x7fffffffL
operator|+
literal|0x1UL
operator|)
expr_stmt|;
break|break;
case|case
name|FSRAND
case|:
if|if
condition|(
name|isrec
argument_list|(
name|x
argument_list|)
condition|)
comment|/* no argument provided */
name|u
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|u
operator|=
name|getfval
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|u
expr_stmt|;
name|srandom
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|u
argument_list|)
expr_stmt|;
name|u
operator|=
name|srand_seed
expr_stmt|;
name|srand_seed
operator|=
name|tmp
expr_stmt|;
break|break;
case|case
name|FTOUPPER
case|:
case|case
name|FTOLOWER
case|:
name|buf
operator|=
name|tostring
argument_list|(
name|getsval
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|FTOUPPER
condition|)
block|{
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|islower
argument_list|(
operator|(
name|uschar
operator|)
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
name|toupper
argument_list|(
operator|(
name|uschar
operator|)
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|(
name|uschar
operator|)
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
name|tolower
argument_list|(
operator|(
name|uschar
operator|)
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|setsval
argument_list|(
name|x
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|x
return|;
case|case
name|FFLUSH
case|:
if|if
condition|(
name|isrec
argument_list|(
name|x
argument_list|)
operator|||
name|strlen
argument_list|(
name|getsval
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|flush_all
argument_list|()
expr_stmt|;
comment|/* fflush() or fflush("") -> all */
name|u
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fp
operator|=
name|openfile
argument_list|(
name|FFLUSH
argument_list|,
name|getsval
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|u
operator|=
name|EOF
expr_stmt|;
else|else
name|u
operator|=
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* can't happen */
name|FATAL
argument_list|(
literal|"illegal function type %d"
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|setfval
argument_list|(
name|x
argument_list|,
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextarg
operator|!=
name|NULL
condition|)
block|{
name|WARNING
argument_list|(
literal|"warning: function has too many arguments"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|nextarg
condition|;
name|nextarg
operator|=
name|nextarg
operator|->
name|nnext
control|)
name|execute
argument_list|(
name|nextarg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|printstat
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* print a[0] */
block|{
name|Node
modifier|*
name|x
decl_stmt|;
name|Cell
modifier|*
name|y
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|a
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
comment|/* a[1] is redirection operator, a[2] is file */
name|fp
operator|=
name|stdout
expr_stmt|;
else|else
name|fp
operator|=
name|redirect
argument_list|(
name|ptoi
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|a
index|[
literal|0
index|]
init|;
name|x
operator|!=
name|NULL
condition|;
name|x
operator|=
name|x
operator|->
name|nnext
control|)
block|{
name|y
operator|=
name|execute
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|getpssval
argument_list|(
name|y
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|nnext
operator|==
name|NULL
condition|)
name|fputs
argument_list|(
operator|*
name|ORS
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
operator|*
name|OFS
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"write error on %s"
argument_list|,
name|filename
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|True
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|nullproc
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|n
operator|=
name|n
expr_stmt|;
name|a
operator|=
name|a
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|redirect
parameter_list|(
name|int
name|a
parameter_list|,
name|Node
modifier|*
name|b
parameter_list|)
comment|/* set up all i/o redirections */
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|Cell
modifier|*
name|x
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|fname
operator|=
name|getsval
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|fp
operator|=
name|openfile
argument_list|(
name|a
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"can't open file %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_struct
struct|struct
name|files
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|mode
decl_stmt|;
comment|/* '|', 'a', 'w' => LE/LT, GT */
block|}
modifier|*
name|files
struct|;
end_struct

begin_decl_stmt
name|int
name|nfiles
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|stdinit
parameter_list|(
name|void
parameter_list|)
comment|/* in case stdin, etc., are not constants */
block|{
name|nfiles
operator|=
name|FOPEN_MAX
expr_stmt|;
name|files
operator|=
name|calloc
argument_list|(
name|nfiles
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|files
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|files
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"can't allocate file memory for %u files"
argument_list|,
name|nfiles
argument_list|)
expr_stmt|;
name|files
index|[
literal|0
index|]
operator|.
name|fp
operator|=
name|stdin
expr_stmt|;
name|files
index|[
literal|0
index|]
operator|.
name|fname
operator|=
literal|"/dev/stdin"
expr_stmt|;
name|files
index|[
literal|0
index|]
operator|.
name|mode
operator|=
name|LT
expr_stmt|;
name|files
index|[
literal|1
index|]
operator|.
name|fp
operator|=
name|stdout
expr_stmt|;
name|files
index|[
literal|1
index|]
operator|.
name|fname
operator|=
literal|"/dev/stdout"
expr_stmt|;
name|files
index|[
literal|1
index|]
operator|.
name|mode
operator|=
name|GT
expr_stmt|;
name|files
index|[
literal|2
index|]
operator|.
name|fp
operator|=
name|stderr
expr_stmt|;
name|files
index|[
literal|2
index|]
operator|.
name|fname
operator|=
literal|"/dev/stderr"
expr_stmt|;
name|files
index|[
literal|2
index|]
operator|.
name|mode
operator|=
name|GT
expr_stmt|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|openfile
parameter_list|(
name|int
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|us
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
name|us
decl_stmt|;
name|int
name|i
decl_stmt|,
name|m
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
name|FATAL
argument_list|(
literal|"null file name in print or getline"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|files
index|[
name|i
index|]
operator|.
name|fname
operator|&&
name|strcmp
argument_list|(
name|s
argument_list|,
name|files
index|[
name|i
index|]
operator|.
name|fname
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|a
operator|==
name|files
index|[
name|i
index|]
operator|.
name|mode
operator|||
operator|(
name|a
operator|==
name|APPEND
operator|&&
name|files
index|[
name|i
index|]
operator|.
name|mode
operator|==
name|GT
operator|)
condition|)
return|return
name|files
index|[
name|i
index|]
operator|.
name|fp
return|;
if|if
condition|(
name|a
operator|==
name|FFLUSH
condition|)
return|return
name|files
index|[
name|i
index|]
operator|.
name|fp
return|;
block|}
if|if
condition|(
name|a
operator|==
name|FFLUSH
condition|)
comment|/* didn't find it, so don't create it! */
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|files
index|[
name|i
index|]
operator|.
name|fp
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|nfiles
condition|)
block|{
name|struct
name|files
modifier|*
name|nf
decl_stmt|;
name|int
name|nnf
init|=
name|nfiles
operator|+
name|FOPEN_MAX
decl_stmt|;
name|nf
operator|=
name|realloc
argument_list|(
name|files
argument_list|,
name|nnf
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|nf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"cannot grow files for %s and %d files"
argument_list|,
name|s
argument_list|,
name|nnf
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|nf
index|[
name|nfiles
index|]
argument_list|,
literal|0
argument_list|,
name|FOPEN_MAX
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|nf
argument_list|)
argument_list|)
expr_stmt|;
name|nfiles
operator|=
name|nnf
expr_stmt|;
name|files
operator|=
name|nf
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* force a semblance of order */
name|m
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|GT
condition|)
block|{
name|fp
operator|=
name|fopen
argument_list|(
name|s
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|==
name|APPEND
condition|)
block|{
name|fp
operator|=
name|fopen
argument_list|(
name|s
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|m
operator|=
name|GT
expr_stmt|;
comment|/* so can mix> and>> */
block|}
elseif|else
if|if
condition|(
name|a
operator|==
literal|'|'
condition|)
block|{
comment|/* output pipe */
name|fp
operator|=
name|popen
argument_list|(
name|s
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|==
name|LE
condition|)
block|{
comment|/* input pipe */
name|fp
operator|=
name|popen
argument_list|(
name|s
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|==
name|LT
condition|)
block|{
comment|/* getline<file */
name|fp
operator|=
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|?
name|stdin
else|:
name|fopen
argument_list|(
name|s
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
comment|/* "-" is stdin */
block|}
else|else
comment|/* can't happen */
name|FATAL
argument_list|(
literal|"illegal redirection %d"
argument_list|,
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
name|files
index|[
name|i
index|]
operator|.
name|fname
operator|=
name|tostring
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|files
index|[
name|i
index|]
operator|.
name|fp
operator|=
name|fp
expr_stmt|;
name|files
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|m
expr_stmt|;
block|}
return|return
name|fp
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|filename
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fp
operator|==
name|files
index|[
name|i
index|]
operator|.
name|fp
condition|)
return|return
name|files
index|[
name|i
index|]
operator|.
name|fname
return|;
return|return
literal|"???"
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|closefile
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|Cell
modifier|*
name|x
decl_stmt|;
name|int
name|i
decl_stmt|,
name|stat
decl_stmt|;
name|n
operator|=
name|n
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|getsval
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|stat
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|files
index|[
name|i
index|]
operator|.
name|fname
operator|&&
name|strcmp
argument_list|(
name|x
operator|->
name|sval
argument_list|,
name|files
index|[
name|i
index|]
operator|.
name|fname
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|files
index|[
name|i
index|]
operator|.
name|fp
argument_list|)
condition|)
name|WARNING
argument_list|(
literal|"i/o error occurred on %s"
argument_list|,
name|files
index|[
name|i
index|]
operator|.
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|files
index|[
name|i
index|]
operator|.
name|mode
operator|==
literal|'|'
operator|||
name|files
index|[
name|i
index|]
operator|.
name|mode
operator|==
name|LE
condition|)
name|stat
operator|=
name|pclose
argument_list|(
name|files
index|[
name|i
index|]
operator|.
name|fp
argument_list|)
expr_stmt|;
else|else
name|stat
operator|=
name|fclose
argument_list|(
name|files
index|[
name|i
index|]
operator|.
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
name|EOF
condition|)
name|WARNING
argument_list|(
literal|"i/o error occurred closing %s"
argument_list|,
name|files
index|[
name|i
index|]
operator|.
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|2
condition|)
comment|/* don't do /dev/std... */
name|xfree
argument_list|(
name|files
index|[
name|i
index|]
operator|.
name|fname
argument_list|)
expr_stmt|;
name|files
index|[
name|i
index|]
operator|.
name|fname
operator|=
name|NULL
expr_stmt|;
comment|/* watch out for ref thru this */
name|files
index|[
name|i
index|]
operator|.
name|fp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|setfval
argument_list|(
name|x
argument_list|,
operator|(
name|Awkfloat
operator|)
name|stat
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|void
name|closeall
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|stat
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FOPEN_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|files
index|[
name|i
index|]
operator|.
name|fp
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|files
index|[
name|i
index|]
operator|.
name|fp
argument_list|)
condition|)
name|WARNING
argument_list|(
literal|"i/o error occurred on %s"
argument_list|,
name|files
index|[
name|i
index|]
operator|.
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|files
index|[
name|i
index|]
operator|.
name|mode
operator|==
literal|'|'
operator|||
name|files
index|[
name|i
index|]
operator|.
name|mode
operator|==
name|LE
condition|)
name|stat
operator|=
name|pclose
argument_list|(
name|files
index|[
name|i
index|]
operator|.
name|fp
argument_list|)
expr_stmt|;
else|else
name|stat
operator|=
name|fclose
argument_list|(
name|files
index|[
name|i
index|]
operator|.
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
name|EOF
condition|)
name|WARNING
argument_list|(
literal|"i/o error occurred while closing %s"
argument_list|,
name|files
index|[
name|i
index|]
operator|.
name|fname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|flush_all
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|files
index|[
name|i
index|]
operator|.
name|fp
condition|)
name|fflush
argument_list|(
name|files
index|[
name|i
index|]
operator|.
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|void
name|backsub
parameter_list|(
name|char
modifier|*
modifier|*
name|pb_ptr
parameter_list|,
name|char
modifier|*
modifier|*
name|sptr_ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|Cell
modifier|*
name|sub
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|nnn
parameter_list|)
comment|/* substitute command */
block|{
name|char
modifier|*
name|sptr
decl_stmt|,
modifier|*
name|pb
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|,
modifier|*
name|result
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|fa
modifier|*
name|pfa
decl_stmt|;
name|int
name|bufsz
init|=
name|recsize
decl_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bufsz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"out of memory in sub"
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* target string */
name|t
operator|=
name|getsval
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
comment|/* 0 => a[1] is already-compiled regexpr */
name|pfa
operator|=
operator|(
name|fa
operator|*
operator|)
name|a
index|[
literal|1
index|]
expr_stmt|;
comment|/* regular expression */
else|else
block|{
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pfa
operator|=
name|makedfa
argument_list|(
name|getsval
argument_list|(
name|y
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* replacement string */
name|result
operator|=
name|False
expr_stmt|;
if|if
condition|(
name|pmatch
argument_list|(
name|pfa
argument_list|,
name|t
argument_list|)
condition|)
block|{
name|sptr
operator|=
name|t
expr_stmt|;
name|adjbuf
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsz
argument_list|,
literal|1
operator|+
name|patbeg
operator|-
name|sptr
argument_list|,
name|recsize
argument_list|,
literal|0
argument_list|,
literal|"sub"
argument_list|)
expr_stmt|;
name|pb
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|sptr
operator|<
name|patbeg
condition|)
operator|*
name|pb
operator|++
operator|=
operator|*
name|sptr
operator|++
expr_stmt|;
name|sptr
operator|=
name|getsval
argument_list|(
name|y
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|sptr
operator|!=
literal|0
condition|)
block|{
name|adjbuf
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsz
argument_list|,
literal|5
operator|+
name|pb
operator|-
name|buf
argument_list|,
name|recsize
argument_list|,
operator|&
name|pb
argument_list|,
literal|"sub"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sptr
operator|==
literal|'\\'
condition|)
block|{
name|backsub
argument_list|(
operator|&
name|pb
argument_list|,
operator|&
name|sptr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|sptr
operator|==
literal|'&'
condition|)
block|{
name|sptr
operator|++
expr_stmt|;
name|adjbuf
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsz
argument_list|,
literal|1
operator|+
name|patlen
operator|+
name|pb
operator|-
name|buf
argument_list|,
name|recsize
argument_list|,
operator|&
name|pb
argument_list|,
literal|"sub"
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|patbeg
init|;
name|q
operator|<
name|patbeg
operator|+
name|patlen
condition|;
control|)
operator|*
name|pb
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|pb
operator|++
operator|=
operator|*
name|sptr
operator|++
expr_stmt|;
block|}
operator|*
name|pb
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|pb
operator|>
name|buf
operator|+
name|bufsz
condition|)
name|FATAL
argument_list|(
literal|"sub result1 %.30s too big; can't happen"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|sptr
operator|=
name|patbeg
operator|+
name|patlen
expr_stmt|;
if|if
condition|(
operator|(
name|patlen
operator|==
literal|0
operator|&&
operator|*
name|patbeg
operator|)
operator|||
operator|(
name|patlen
operator|&&
operator|*
operator|(
name|sptr
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|adjbuf
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsz
argument_list|,
literal|1
operator|+
name|strlen
argument_list|(
name|sptr
argument_list|)
operator|+
name|pb
operator|-
name|buf
argument_list|,
literal|0
argument_list|,
operator|&
name|pb
argument_list|,
literal|"sub"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|pb
operator|++
operator|=
operator|*
name|sptr
operator|++
operator|)
operator|!=
literal|0
condition|)
empty_stmt|;
block|}
if|if
condition|(
name|pb
operator|>
name|buf
operator|+
name|bufsz
condition|)
name|FATAL
argument_list|(
literal|"sub result2 %.30s too big; can't happen"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|setsval
argument_list|(
name|x
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* BUG: should be able to avoid copy */
name|result
operator|=
name|True
expr_stmt|;
block|}
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|gsub
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|nnn
parameter_list|)
comment|/* global substitute */
block|{
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
name|char
modifier|*
name|rptr
decl_stmt|,
modifier|*
name|sptr
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|pb
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|fa
modifier|*
name|pfa
decl_stmt|;
name|int
name|mflag
decl_stmt|,
name|tempstat
decl_stmt|,
name|num
decl_stmt|;
name|int
name|bufsz
init|=
name|recsize
decl_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bufsz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"out of memory in gsub"
argument_list|)
expr_stmt|;
name|mflag
operator|=
literal|0
expr_stmt|;
comment|/* if mflag == 0, can replace empty string */
name|num
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* target string */
name|t
operator|=
name|getsval
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
comment|/* 0 => a[1] is already-compiled regexpr */
name|pfa
operator|=
operator|(
name|fa
operator|*
operator|)
name|a
index|[
literal|1
index|]
expr_stmt|;
comment|/* regular expression */
else|else
block|{
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pfa
operator|=
name|makedfa
argument_list|(
name|getsval
argument_list|(
name|y
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* replacement string */
if|if
condition|(
name|pmatch
argument_list|(
name|pfa
argument_list|,
name|t
argument_list|)
condition|)
block|{
name|tempstat
operator|=
name|pfa
operator|->
name|initstat
expr_stmt|;
name|pfa
operator|->
name|initstat
operator|=
literal|2
expr_stmt|;
name|pb
operator|=
name|buf
expr_stmt|;
name|rptr
operator|=
name|getsval
argument_list|(
name|y
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|patlen
operator|==
literal|0
operator|&&
operator|*
name|patbeg
operator|!=
literal|0
condition|)
block|{
comment|/* matched empty string */
if|if
condition|(
name|mflag
operator|==
literal|0
condition|)
block|{
comment|/* can replace empty */
name|num
operator|++
expr_stmt|;
name|sptr
operator|=
name|rptr
expr_stmt|;
while|while
condition|(
operator|*
name|sptr
operator|!=
literal|0
condition|)
block|{
name|adjbuf
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsz
argument_list|,
literal|5
operator|+
name|pb
operator|-
name|buf
argument_list|,
name|recsize
argument_list|,
operator|&
name|pb
argument_list|,
literal|"gsub"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sptr
operator|==
literal|'\\'
condition|)
block|{
name|backsub
argument_list|(
operator|&
name|pb
argument_list|,
operator|&
name|sptr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|sptr
operator|==
literal|'&'
condition|)
block|{
name|sptr
operator|++
expr_stmt|;
name|adjbuf
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsz
argument_list|,
literal|1
operator|+
name|patlen
operator|+
name|pb
operator|-
name|buf
argument_list|,
name|recsize
argument_list|,
operator|&
name|pb
argument_list|,
literal|"gsub"
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|patbeg
init|;
name|q
operator|<
name|patbeg
operator|+
name|patlen
condition|;
control|)
operator|*
name|pb
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|pb
operator|++
operator|=
operator|*
name|sptr
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|t
operator|==
literal|0
condition|)
comment|/* at end */
goto|goto
name|done
goto|;
name|adjbuf
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsz
argument_list|,
literal|2
operator|+
name|pb
operator|-
name|buf
argument_list|,
name|recsize
argument_list|,
operator|&
name|pb
argument_list|,
literal|"gsub"
argument_list|)
expr_stmt|;
operator|*
name|pb
operator|++
operator|=
operator|*
name|t
operator|++
expr_stmt|;
if|if
condition|(
name|pb
operator|>
name|buf
operator|+
name|bufsz
condition|)
comment|/* BUG: not sure of this test */
name|FATAL
argument_list|(
literal|"gsub result0 %.30s too big; can't happen"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|mflag
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* matched nonempty string */
name|num
operator|++
expr_stmt|;
name|sptr
operator|=
name|t
expr_stmt|;
name|adjbuf
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsz
argument_list|,
literal|1
operator|+
operator|(
name|patbeg
operator|-
name|sptr
operator|)
operator|+
name|pb
operator|-
name|buf
argument_list|,
name|recsize
argument_list|,
operator|&
name|pb
argument_list|,
literal|"gsub"
argument_list|)
expr_stmt|;
while|while
condition|(
name|sptr
operator|<
name|patbeg
condition|)
operator|*
name|pb
operator|++
operator|=
operator|*
name|sptr
operator|++
expr_stmt|;
name|sptr
operator|=
name|rptr
expr_stmt|;
while|while
condition|(
operator|*
name|sptr
operator|!=
literal|0
condition|)
block|{
name|adjbuf
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsz
argument_list|,
literal|5
operator|+
name|pb
operator|-
name|buf
argument_list|,
name|recsize
argument_list|,
operator|&
name|pb
argument_list|,
literal|"gsub"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sptr
operator|==
literal|'\\'
condition|)
block|{
name|backsub
argument_list|(
operator|&
name|pb
argument_list|,
operator|&
name|sptr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|sptr
operator|==
literal|'&'
condition|)
block|{
name|sptr
operator|++
expr_stmt|;
name|adjbuf
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsz
argument_list|,
literal|1
operator|+
name|patlen
operator|+
name|pb
operator|-
name|buf
argument_list|,
name|recsize
argument_list|,
operator|&
name|pb
argument_list|,
literal|"gsub"
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|patbeg
init|;
name|q
operator|<
name|patbeg
operator|+
name|patlen
condition|;
control|)
operator|*
name|pb
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|pb
operator|++
operator|=
operator|*
name|sptr
operator|++
expr_stmt|;
block|}
name|t
operator|=
name|patbeg
operator|+
name|patlen
expr_stmt|;
if|if
condition|(
name|patlen
operator|==
literal|0
operator|||
operator|*
name|t
operator|==
literal|0
operator|||
operator|*
operator|(
name|t
operator|-
literal|1
operator|)
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|pb
operator|>
name|buf
operator|+
name|bufsz
condition|)
name|FATAL
argument_list|(
literal|"gsub result1 %.30s too big; can't happen"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|mflag
operator|=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|pmatch
argument_list|(
name|pfa
argument_list|,
name|t
argument_list|)
condition|)
do|;
name|sptr
operator|=
name|t
expr_stmt|;
name|adjbuf
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsz
argument_list|,
literal|1
operator|+
name|strlen
argument_list|(
name|sptr
argument_list|)
operator|+
name|pb
operator|-
name|buf
argument_list|,
literal|0
argument_list|,
operator|&
name|pb
argument_list|,
literal|"gsub"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|pb
operator|++
operator|=
operator|*
name|sptr
operator|++
operator|)
operator|!=
literal|0
condition|)
empty_stmt|;
name|done
label|:
if|if
condition|(
name|pb
operator|<
name|buf
operator|+
name|bufsz
condition|)
operator|*
name|pb
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|(
name|pb
operator|-
literal|1
operator|)
operator|!=
literal|'\0'
condition|)
name|FATAL
argument_list|(
literal|"gsub result2 %.30s truncated; can't happen"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|setsval
argument_list|(
name|x
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* BUG: should be able to avoid copy + free */
name|pfa
operator|->
name|initstat
operator|=
name|tempstat
expr_stmt|;
block|}
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|x
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|x
operator|->
name|tval
operator|=
name|NUM
expr_stmt|;
name|x
operator|->
name|fval
operator|=
name|num
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|void
name|backsub
parameter_list|(
name|char
modifier|*
modifier|*
name|pb_ptr
parameter_list|,
name|char
modifier|*
modifier|*
name|sptr_ptr
parameter_list|)
comment|/* handle \\& variations */
block|{
comment|/* sptr[0] == '\\' */
name|char
modifier|*
name|pb
init|=
operator|*
name|pb_ptr
decl_stmt|,
modifier|*
name|sptr
init|=
operator|*
name|sptr_ptr
decl_stmt|;
if|if
condition|(
name|sptr
index|[
literal|1
index|]
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|sptr
index|[
literal|2
index|]
operator|==
literal|'\\'
operator|&&
name|sptr
index|[
literal|3
index|]
operator|==
literal|'&'
condition|)
block|{
comment|/* \\\& -> \& */
operator|*
name|pb
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|pb
operator|++
operator|=
literal|'&'
expr_stmt|;
name|sptr
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sptr
index|[
literal|2
index|]
operator|==
literal|'&'
condition|)
block|{
comment|/* \\& -> \ + matched */
operator|*
name|pb
operator|++
operator|=
literal|'\\'
expr_stmt|;
name|sptr
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* \\x -> \\x */
operator|*
name|pb
operator|++
operator|=
operator|*
name|sptr
operator|++
expr_stmt|;
operator|*
name|pb
operator|++
operator|=
operator|*
name|sptr
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sptr
index|[
literal|1
index|]
operator|==
literal|'&'
condition|)
block|{
comment|/* literal& */
name|sptr
operator|++
expr_stmt|;
operator|*
name|pb
operator|++
operator|=
operator|*
name|sptr
operator|++
expr_stmt|;
block|}
else|else
comment|/* literal \ */
operator|*
name|pb
operator|++
operator|=
operator|*
name|sptr
operator|++
expr_stmt|;
operator|*
name|pb_ptr
operator|=
name|pb
expr_stmt|;
operator|*
name|sptr_ptr
operator|=
name|sptr
expr_stmt|;
block|}
end_function

end_unit

