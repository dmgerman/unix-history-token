begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright (C) Lucent Technologies 1997 All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the name Lucent Technologies or any of its entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ****************************************************************/
end_comment

begin_define
define|#
directive|define
name|DEBUG
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|"awk.h"
end_include

begin_include
include|#
directive|include
file|"ytab.h"
end_include

begin_decl_stmt
name|FILE
modifier|*
name|infile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|file
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|record
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|recsize
init|=
name|RECSIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fields
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fieldssize
init|=
name|RECSIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Cell
modifier|*
modifier|*
name|fldtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointers to Cells */
end_comment

begin_decl_stmt
name|char
name|inputFS
index|[
literal|100
index|]
init|=
literal|" "
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAXFLD
value|2
end_define

begin_decl_stmt
name|int
name|nfields
init|=
name|MAXFLD
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last allocated slot for $i */
end_comment

begin_decl_stmt
name|int
name|donefld
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 = implies rec broken into fields */
end_comment

begin_decl_stmt
name|int
name|donerec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 = record is valid (no flds have changed) */
end_comment

begin_decl_stmt
name|int
name|lastfld
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last used field */
end_comment

begin_decl_stmt
name|int
name|argno
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current input argument number */
end_comment

begin_decl_stmt
specifier|extern
name|Awkfloat
modifier|*
name|ARGC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Cell
name|dollar0
init|=
block|{
name|OCELL
block|,
name|CFLD
block|,
name|NULL
block|,
literal|""
block|,
literal|0.0
block|,
name|REC
operator||
name|STR
operator||
name|DONTFREE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Cell
name|dollar1
init|=
block|{
name|OCELL
block|,
name|CFLD
block|,
name|NULL
block|,
literal|""
block|,
literal|0.0
block|,
name|FLD
operator||
name|STR
operator||
name|DONTFREE
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|recinit
parameter_list|(
name|unsigned
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
operator|(
name|record
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|n
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|fields
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|n
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|fldtab
operator|=
operator|(
name|Cell
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|nfields
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Cell
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|fldtab
index|[
literal|0
index|]
operator|=
operator|(
name|Cell
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Cell
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"out of space for $0 and fields"
argument_list|)
expr_stmt|;
operator|*
name|fldtab
index|[
literal|0
index|]
operator|=
name|dollar0
expr_stmt|;
name|fldtab
index|[
literal|0
index|]
operator|->
name|sval
operator|=
name|record
expr_stmt|;
name|fldtab
index|[
literal|0
index|]
operator|->
name|nval
operator|=
name|tostring
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
name|makefields
argument_list|(
literal|1
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|makefields
parameter_list|(
name|int
name|n1
parameter_list|,
name|int
name|n2
parameter_list|)
comment|/* create $n1..$n2 inclusive */
block|{
name|char
name|temp
index|[
literal|50
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n1
init|;
name|i
operator|<=
name|n2
condition|;
name|i
operator|++
control|)
block|{
name|fldtab
index|[
name|i
index|]
operator|=
operator|(
name|Cell
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|Cell
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fldtab
index|[
name|i
index|]
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"out of space in makefields %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|*
name|fldtab
index|[
name|i
index|]
operator|=
name|dollar1
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fldtab
index|[
name|i
index|]
operator|->
name|nval
operator|=
name|tostring
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|initgetrec
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|*
name|ARGC
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isclvar
argument_list|(
name|p
operator|=
name|getargv
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
comment|/* find 1st real filename */
name|setsval
argument_list|(
name|lookup
argument_list|(
literal|"FILENAME"
argument_list|,
name|symtab
argument_list|)
argument_list|,
name|getargv
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|setclvar
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* a commandline assignment before filename */
name|argno
operator|++
expr_stmt|;
block|}
name|infile
operator|=
name|stdin
expr_stmt|;
comment|/* no filenames, so use stdin */
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|firsttime
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|getrec
parameter_list|(
name|char
modifier|*
modifier|*
name|pbuf
parameter_list|,
name|int
modifier|*
name|pbufsize
parameter_list|,
name|int
name|isrecord
parameter_list|)
comment|/* get next input record */
block|{
comment|/* note: cares whether buf == record */
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|buf
init|=
operator|*
name|pbuf
decl_stmt|;
name|uschar
name|saveb0
decl_stmt|;
name|int
name|bufsize
init|=
operator|*
name|pbufsize
decl_stmt|,
name|savebufsize
init|=
name|bufsize
decl_stmt|;
if|if
condition|(
name|firsttime
condition|)
block|{
name|firsttime
operator|=
literal|0
expr_stmt|;
name|initgetrec
argument_list|()
expr_stmt|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"RS=<%s>, FS=<%s>, ARGC=%g, FILENAME=%s\n"
operator|,
operator|*
name|RS
operator|,
operator|*
name|FS
operator|,
operator|*
name|ARGC
operator|,
operator|*
name|FILENAME
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isrecord
condition|)
block|{
name|donefld
operator|=
literal|0
expr_stmt|;
name|donerec
operator|=
literal|1
expr_stmt|;
block|}
name|saveb0
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|argno
operator|<
operator|*
name|ARGC
operator|||
name|infile
operator|==
name|stdin
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"argno=%d, file=|%s|\n"
operator|,
name|argno
operator|,
name|file
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|infile
operator|==
name|NULL
condition|)
block|{
comment|/* have to open a new file */
name|file
operator|=
name|getargv
argument_list|(
name|argno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|file
operator|==
literal|'\0'
condition|)
block|{
comment|/* it's been zapped */
name|argno
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|isclvar
argument_list|(
name|file
argument_list|)
condition|)
block|{
comment|/* a var=value arg */
name|setclvar
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|argno
operator|++
expr_stmt|;
continue|continue;
block|}
operator|*
name|FILENAME
operator|=
name|file
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"opening file %s\n"
operator|,
name|file
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|file
operator|==
literal|'-'
operator|&&
operator|*
operator|(
name|file
operator|+
literal|1
operator|)
operator|==
literal|'\0'
condition|)
name|infile
operator|=
name|stdin
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|infile
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"can't open file %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|setfval
argument_list|(
name|fnrloc
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|readrec
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsize
argument_list|,
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
operator|||
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* normal record */
if|if
condition|(
name|isrecord
condition|)
block|{
if|if
condition|(
name|freeable
argument_list|(
name|fldtab
index|[
literal|0
index|]
argument_list|)
condition|)
name|xfree
argument_list|(
name|fldtab
index|[
literal|0
index|]
operator|->
name|sval
argument_list|)
expr_stmt|;
name|fldtab
index|[
literal|0
index|]
operator|->
name|sval
operator|=
name|buf
expr_stmt|;
comment|/* buf == record */
name|fldtab
index|[
literal|0
index|]
operator|->
name|tval
operator|=
name|REC
operator||
name|STR
operator||
name|DONTFREE
expr_stmt|;
if|if
condition|(
name|is_number
argument_list|(
name|fldtab
index|[
literal|0
index|]
operator|->
name|sval
argument_list|)
condition|)
block|{
name|fldtab
index|[
literal|0
index|]
operator|->
name|fval
operator|=
name|atof
argument_list|(
name|fldtab
index|[
literal|0
index|]
operator|->
name|sval
argument_list|)
expr_stmt|;
name|fldtab
index|[
literal|0
index|]
operator|->
name|tval
operator||=
name|NUM
expr_stmt|;
block|}
block|}
name|setfval
argument_list|(
name|nrloc
argument_list|,
name|nrloc
operator|->
name|fval
operator|+
literal|1
argument_list|)
expr_stmt|;
name|setfval
argument_list|(
name|fnrloc
argument_list|,
name|fnrloc
operator|->
name|fval
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|pbuf
operator|=
name|buf
expr_stmt|;
operator|*
name|pbufsize
operator|=
name|bufsize
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* EOF arrived on this file; set up next */
if|if
condition|(
name|infile
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|infile
operator|=
name|NULL
expr_stmt|;
name|argno
operator|++
expr_stmt|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
name|saveb0
expr_stmt|;
operator|*
name|pbuf
operator|=
name|buf
expr_stmt|;
operator|*
name|pbufsize
operator|=
name|savebufsize
expr_stmt|;
return|return
literal|0
return|;
comment|/* true end of file */
block|}
end_function

begin_function
name|void
name|nextfile
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|infile
operator|!=
name|NULL
operator|&&
name|infile
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|infile
operator|=
name|NULL
expr_stmt|;
name|argno
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|int
name|readrec
parameter_list|(
name|char
modifier|*
modifier|*
name|pbuf
parameter_list|,
name|int
modifier|*
name|pbufsize
parameter_list|,
name|FILE
modifier|*
name|inf
parameter_list|)
comment|/* read one record into buf */
block|{
name|int
name|sep
decl_stmt|,
name|c
decl_stmt|;
name|char
modifier|*
name|rr
decl_stmt|,
modifier|*
name|buf
init|=
operator|*
name|pbuf
decl_stmt|;
name|int
name|bufsize
init|=
operator|*
name|pbufsize
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
operator|*
name|FS
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|inputFS
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"field separator %.10s... is too long"
argument_list|,
operator|*
name|FS
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|inputFS
argument_list|,
operator|*
name|FS
argument_list|)
expr_stmt|;
comment|/* for subsequent field splitting */
if|if
condition|(
operator|(
name|sep
operator|=
operator|*
operator|*
name|RS
operator|)
operator|==
literal|0
condition|)
block|{
name|sep
operator|=
literal|'\n'
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|==
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
comment|/* skip leading \n's */
empty_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|inf
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|rr
operator|=
name|buf
init|;
condition|;
control|)
block|{
for|for
control|(
init|;
operator|(
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|!=
name|sep
operator|&&
name|c
operator|!=
name|EOF
condition|;
control|)
block|{
if|if
condition|(
name|rr
operator|-
name|buf
operator|+
literal|1
operator|>
name|bufsize
condition|)
if|if
condition|(
operator|!
name|adjbuf
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsize
argument_list|,
literal|1
operator|+
name|rr
operator|-
name|buf
argument_list|,
name|recsize
argument_list|,
operator|&
name|rr
argument_list|,
literal|"readrec 1"
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"input record `%.30s...' too long"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|*
name|rr
operator|++
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|RS
operator|==
name|sep
operator|||
name|c
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOF
condition|)
comment|/* 2 in a row */
break|break;
if|if
condition|(
operator|!
name|adjbuf
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsize
argument_list|,
literal|2
operator|+
name|rr
operator|-
name|buf
argument_list|,
name|recsize
argument_list|,
operator|&
name|rr
argument_list|,
literal|"readrec 2"
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"input record `%.30s...' too long"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|*
name|rr
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|rr
operator|++
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|adjbuf
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsize
argument_list|,
literal|1
operator|+
name|rr
operator|-
name|buf
argument_list|,
name|recsize
argument_list|,
operator|&
name|rr
argument_list|,
literal|"readrec 3"
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"input record `%.30s...' too long"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|*
name|rr
operator|=
literal|0
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"readrec saw<%s>, returns %d\n"
operator|,
name|buf
operator|,
name|c
operator|==
name|EOF
operator|&&
name|rr
operator|==
name|buf
condition|?
literal|0
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
operator|*
name|pbuf
operator|=
name|buf
expr_stmt|;
operator|*
name|pbufsize
operator|=
name|bufsize
expr_stmt|;
return|return
name|c
operator|==
name|EOF
operator|&&
name|rr
operator|==
name|buf
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|getargv
parameter_list|(
name|int
name|n
parameter_list|)
comment|/* get ARGV[n] */
block|{
name|Cell
modifier|*
name|x
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
name|temp
index|[
literal|50
index|]
decl_stmt|;
specifier|extern
name|Array
modifier|*
name|ARGVtab
decl_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|x
operator|=
name|setsymtab
argument_list|(
name|temp
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|STR
argument_list|,
name|ARGVtab
argument_list|)
expr_stmt|;
name|s
operator|=
name|getsval
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"getargv(%d) returns |%s|\n"
operator|,
name|n
operator|,
name|s
operator|)
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|void
name|setclvar
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
comment|/* set var=value from s */
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|Cell
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|p
operator|=
name|s
init|;
operator|*
name|p
operator|!=
literal|'='
condition|;
name|p
operator|++
control|)
empty_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|qstring
argument_list|(
name|p
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|q
operator|=
name|setsymtab
argument_list|(
name|s
argument_list|,
name|p
argument_list|,
literal|0.0
argument_list|,
name|STR
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
name|setsval
argument_list|(
name|q
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_number
argument_list|(
name|q
operator|->
name|sval
argument_list|)
condition|)
block|{
name|q
operator|->
name|fval
operator|=
name|atof
argument_list|(
name|q
operator|->
name|sval
argument_list|)
expr_stmt|;
name|q
operator|->
name|tval
operator||=
name|NUM
expr_stmt|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"command line set %s to |%s|\n"
operator|,
name|s
operator|,
name|p
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fldbld
parameter_list|(
name|void
parameter_list|)
comment|/* create fields from current record */
block|{
comment|/* this relies on having fields[] the same length as $0 */
comment|/* the fields are all stored in this one array with \0's */
name|char
modifier|*
name|r
decl_stmt|,
modifier|*
name|fr
decl_stmt|,
name|sep
decl_stmt|;
name|Cell
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
name|donefld
condition|)
return|return;
if|if
condition|(
operator|!
name|isstr
argument_list|(
name|fldtab
index|[
literal|0
index|]
argument_list|)
condition|)
name|getsval
argument_list|(
name|fldtab
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|r
operator|=
name|fldtab
index|[
literal|0
index|]
operator|->
name|sval
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|fieldssize
condition|)
block|{
name|xfree
argument_list|(
name|fields
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fields
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|n
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"out of space for fields in fldbld %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|fieldssize
operator|=
name|n
expr_stmt|;
block|}
name|fr
operator|=
name|fields
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* number of fields accumulated here */
name|strcpy
argument_list|(
name|inputFS
argument_list|,
operator|*
name|FS
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|inputFS
argument_list|)
operator|>
literal|1
condition|)
block|{
comment|/* it's a regular expression */
name|i
operator|=
name|refldbld
argument_list|(
name|r
argument_list|,
name|inputFS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sep
operator|=
operator|*
name|inputFS
operator|)
operator|==
literal|' '
condition|)
block|{
comment|/* default whitespace */
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|r
operator|==
literal|' '
operator|||
operator|*
name|r
operator|==
literal|'\t'
operator|||
operator|*
name|r
operator|==
literal|'\n'
condition|)
name|r
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|r
operator|==
literal|0
condition|)
break|break;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|nfields
condition|)
name|growfldtab
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeable
argument_list|(
name|fldtab
index|[
name|i
index|]
argument_list|)
condition|)
name|xfree
argument_list|(
name|fldtab
index|[
name|i
index|]
operator|->
name|sval
argument_list|)
expr_stmt|;
name|fldtab
index|[
name|i
index|]
operator|->
name|sval
operator|=
name|fr
expr_stmt|;
name|fldtab
index|[
name|i
index|]
operator|->
name|tval
operator|=
name|FLD
operator||
name|STR
operator||
name|DONTFREE
expr_stmt|;
do|do
operator|*
name|fr
operator|++
operator|=
operator|*
name|r
operator|++
expr_stmt|;
do|while
condition|(
operator|*
name|r
operator|!=
literal|' '
operator|&&
operator|*
name|r
operator|!=
literal|'\t'
operator|&&
operator|*
name|r
operator|!=
literal|'\n'
operator|&&
operator|*
name|r
operator|!=
literal|'\0'
condition|)
do|;
operator|*
name|fr
operator|++
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|fr
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sep
operator|=
operator|*
name|inputFS
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* new: FS="" => 1 char/field */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|r
operator|!=
literal|0
condition|;
name|r
operator|++
control|)
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|nfields
condition|)
name|growfldtab
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeable
argument_list|(
name|fldtab
index|[
name|i
index|]
argument_list|)
condition|)
name|xfree
argument_list|(
name|fldtab
index|[
name|i
index|]
operator|->
name|sval
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
operator|*
name|r
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|fldtab
index|[
name|i
index|]
operator|->
name|sval
operator|=
name|tostring
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|fldtab
index|[
name|i
index|]
operator|->
name|tval
operator|=
name|FLD
operator||
name|STR
expr_stmt|;
block|}
operator|*
name|fr
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|r
operator|!=
literal|0
condition|)
block|{
comment|/* if 0, it's a null field */
comment|/* subtlecase : if length(FS) == 1&& length(RS> 0) 		 * \n is NOT a field separator (cf awk book 61,84). 		 * this variable is tested in the inner while loop. 		 */
name|int
name|rtest
init|=
literal|'\n'
decl_stmt|;
comment|/* normal case */
if|if
condition|(
name|strlen
argument_list|(
operator|*
name|RS
argument_list|)
operator|>
literal|0
condition|)
name|rtest
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|nfields
condition|)
name|growfldtab
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeable
argument_list|(
name|fldtab
index|[
name|i
index|]
argument_list|)
condition|)
name|xfree
argument_list|(
name|fldtab
index|[
name|i
index|]
operator|->
name|sval
argument_list|)
expr_stmt|;
name|fldtab
index|[
name|i
index|]
operator|->
name|sval
operator|=
name|fr
expr_stmt|;
name|fldtab
index|[
name|i
index|]
operator|->
name|tval
operator|=
name|FLD
operator||
name|STR
operator||
name|DONTFREE
expr_stmt|;
while|while
condition|(
operator|*
name|r
operator|!=
name|sep
operator|&&
operator|*
name|r
operator|!=
name|rtest
operator|&&
operator|*
name|r
operator|!=
literal|'\0'
condition|)
comment|/* \n is always a separator */
operator|*
name|fr
operator|++
operator|=
operator|*
name|r
operator|++
expr_stmt|;
operator|*
name|fr
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|r
operator|++
operator|==
literal|0
condition|)
break|break;
block|}
operator|*
name|fr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
name|nfields
condition|)
name|FATAL
argument_list|(
literal|"record `%.30s...' has too many fields; can't happen"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|cleanfld
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|lastfld
argument_list|)
expr_stmt|;
comment|/* clean out junk from previous record */
name|lastfld
operator|=
name|i
expr_stmt|;
name|donefld
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|lastfld
condition|;
name|j
operator|++
control|)
block|{
name|p
operator|=
name|fldtab
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|is_number
argument_list|(
name|p
operator|->
name|sval
argument_list|)
condition|)
block|{
name|p
operator|->
name|fval
operator|=
name|atof
argument_list|(
name|p
operator|->
name|sval
argument_list|)
expr_stmt|;
name|p
operator|->
name|tval
operator||=
name|NUM
expr_stmt|;
block|}
block|}
name|setfval
argument_list|(
name|nfloc
argument_list|,
operator|(
name|Awkfloat
operator|)
name|lastfld
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|lastfld
condition|;
name|j
operator|++
control|)
block|{
name|p
operator|=
name|fldtab
index|[
name|j
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"field %d (%s): |%s|\n"
argument_list|,
name|j
argument_list|,
name|p
operator|->
name|nval
argument_list|,
name|p
operator|->
name|sval
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|cleanfld
parameter_list|(
name|int
name|n1
parameter_list|,
name|int
name|n2
parameter_list|)
comment|/* clean out fields n1 .. n2 inclusive */
block|{
comment|/* nvals remain intact */
name|Cell
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n1
init|;
name|i
operator|<=
name|n2
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|fldtab
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|freeable
argument_list|(
name|p
argument_list|)
condition|)
name|xfree
argument_list|(
name|p
operator|->
name|sval
argument_list|)
expr_stmt|;
name|p
operator|->
name|sval
operator|=
literal|""
expr_stmt|;
name|p
operator|->
name|tval
operator|=
name|FLD
operator||
name|STR
operator||
name|DONTFREE
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|newfld
parameter_list|(
name|int
name|n
parameter_list|)
comment|/* add field n after end of existing lastfld */
block|{
if|if
condition|(
name|n
operator|>
name|nfields
condition|)
name|growfldtab
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|cleanfld
argument_list|(
name|lastfld
operator|+
literal|1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|lastfld
operator|=
name|n
expr_stmt|;
name|setfval
argument_list|(
name|nfloc
argument_list|,
operator|(
name|Awkfloat
operator|)
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|fieldadr
parameter_list|(
name|int
name|n
parameter_list|)
comment|/* get nth field */
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|FATAL
argument_list|(
literal|"trying to access out of range field %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|nfields
condition|)
comment|/* fields after NF are empty */
name|growfldtab
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* but does not increase NF */
return|return
operator|(
name|fldtab
index|[
name|n
index|]
operator|)
return|;
block|}
end_function

begin_function
name|void
name|growfldtab
parameter_list|(
name|int
name|n
parameter_list|)
comment|/* make new fields up to at least $n */
block|{
name|int
name|nf
init|=
literal|2
operator|*
name|nfields
decl_stmt|;
name|size_t
name|s
decl_stmt|;
if|if
condition|(
name|n
operator|>
name|nf
condition|)
name|nf
operator|=
name|n
expr_stmt|;
name|s
operator|=
operator|(
name|nf
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|Cell
operator|*
argument_list|)
operator|)
expr_stmt|;
comment|/* freebsd: how much do we need? */
if|if
condition|(
name|s
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|Cell
operator|*
argument_list|)
operator|-
literal|1
operator|==
name|nf
condition|)
comment|/* didn't overflow */
name|fldtab
operator|=
operator|(
name|Cell
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|fldtab
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
comment|/* overflow sizeof int */
name|xfree
argument_list|(
name|fldtab
argument_list|)
expr_stmt|;
comment|/* make it null */
if|if
condition|(
name|fldtab
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"out of space creating %d fields"
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|makefields
argument_list|(
name|nfields
operator|+
literal|1
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|nfields
operator|=
name|nf
expr_stmt|;
block|}
end_function

begin_function
name|int
name|refldbld
parameter_list|(
specifier|const
name|char
modifier|*
name|rec
parameter_list|,
specifier|const
name|char
modifier|*
name|fs
parameter_list|)
comment|/* build fields from reg expr in FS */
block|{
comment|/* this relies on having fields[] the same length as $0 */
comment|/* the fields are all stored in this one array with \0's */
name|char
modifier|*
name|fr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|tempstat
decl_stmt|,
name|n
decl_stmt|;
name|fa
modifier|*
name|pfa
decl_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|rec
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|fieldssize
condition|)
block|{
name|xfree
argument_list|(
name|fields
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fields
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|n
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"out of space for fields in refldbld %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|fieldssize
operator|=
name|n
expr_stmt|;
block|}
name|fr
operator|=
name|fields
expr_stmt|;
operator|*
name|fr
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|rec
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
name|pfa
operator|=
name|makedfa
argument_list|(
name|fs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"into refldbld, rec =<%s>, pat =<%s>\n"
operator|,
name|rec
operator|,
name|fs
operator|)
argument_list|)
expr_stmt|;
name|tempstat
operator|=
name|pfa
operator|->
name|initstat
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
name|nfields
condition|)
name|growfldtab
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeable
argument_list|(
name|fldtab
index|[
name|i
index|]
argument_list|)
condition|)
name|xfree
argument_list|(
name|fldtab
index|[
name|i
index|]
operator|->
name|sval
argument_list|)
expr_stmt|;
name|fldtab
index|[
name|i
index|]
operator|->
name|tval
operator|=
name|FLD
operator||
name|STR
operator||
name|DONTFREE
expr_stmt|;
name|fldtab
index|[
name|i
index|]
operator|->
name|sval
operator|=
name|fr
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"refldbld: i=%d\n"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nematch
argument_list|(
name|pfa
argument_list|,
name|rec
argument_list|)
condition|)
block|{
name|pfa
operator|->
name|initstat
operator|=
literal|2
expr_stmt|;
comment|/* horrible coupling to b.c */
name|dprintf
argument_list|(
operator|(
literal|"match %s (%d chars)\n"
operator|,
name|patbeg
operator|,
name|patlen
operator|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|fr
argument_list|,
name|rec
argument_list|,
name|patbeg
operator|-
name|rec
argument_list|)
expr_stmt|;
name|fr
operator|+=
name|patbeg
operator|-
name|rec
operator|+
literal|1
expr_stmt|;
operator|*
operator|(
name|fr
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|rec
operator|=
name|patbeg
operator|+
name|patlen
expr_stmt|;
block|}
else|else
block|{
name|dprintf
argument_list|(
operator|(
literal|"no match %s\n"
operator|,
name|rec
operator|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|fr
argument_list|,
name|rec
argument_list|)
expr_stmt|;
name|pfa
operator|->
name|initstat
operator|=
name|tempstat
expr_stmt|;
break|break;
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
name|void
name|recbld
parameter_list|(
name|void
parameter_list|)
comment|/* create $0 from $1..$NF if necessary */
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|r
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|donerec
operator|==
literal|1
condition|)
return|return;
name|r
operator|=
name|record
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
operator|*
name|NF
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|getsval
argument_list|(
name|fldtab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|adjbuf
argument_list|(
operator|&
name|record
argument_list|,
operator|&
name|recsize
argument_list|,
literal|1
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
name|r
operator|-
name|record
argument_list|,
name|recsize
argument_list|,
operator|&
name|r
argument_list|,
literal|"recbld 1"
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"created $0 `%.30s...' too long"
argument_list|,
name|record
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|r
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|0
condition|)
name|r
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|*
name|NF
condition|)
block|{
if|if
condition|(
operator|!
name|adjbuf
argument_list|(
operator|&
name|record
argument_list|,
operator|&
name|recsize
argument_list|,
literal|2
operator|+
name|strlen
argument_list|(
operator|*
name|OFS
argument_list|)
operator|+
name|r
operator|-
name|record
argument_list|,
name|recsize
argument_list|,
operator|&
name|r
argument_list|,
literal|"recbld 2"
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"created $0 `%.30s...' too long"
argument_list|,
name|record
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|OFS
init|;
operator|(
operator|*
name|r
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|0
condition|;
control|)
name|r
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|adjbuf
argument_list|(
operator|&
name|record
argument_list|,
operator|&
name|recsize
argument_list|,
literal|2
operator|+
name|r
operator|-
name|record
argument_list|,
name|recsize
argument_list|,
operator|&
name|r
argument_list|,
literal|"recbld 3"
argument_list|)
condition|)
name|FATAL
argument_list|(
literal|"built giant record `%.30s...'"
argument_list|,
name|record
argument_list|)
expr_stmt|;
operator|*
name|r
operator|=
literal|'\0'
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"in recbld inputFS=%s, fldtab[0]=%p\n"
operator|,
name|inputFS
operator|,
name|fldtab
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeable
argument_list|(
name|fldtab
index|[
literal|0
index|]
argument_list|)
condition|)
name|xfree
argument_list|(
name|fldtab
index|[
literal|0
index|]
operator|->
name|sval
argument_list|)
expr_stmt|;
name|fldtab
index|[
literal|0
index|]
operator|->
name|tval
operator|=
name|REC
operator||
name|STR
operator||
name|DONTFREE
expr_stmt|;
name|fldtab
index|[
literal|0
index|]
operator|->
name|sval
operator|=
name|record
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"in recbld inputFS=%s, fldtab[0]=%p\n"
operator|,
name|inputFS
operator|,
name|fldtab
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"recbld = |%s|\n"
operator|,
name|record
operator|)
argument_list|)
expr_stmt|;
name|donerec
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|errorflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|yyerror
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|SYNTAX
argument_list|(
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SYNTAX
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
specifier|extern
name|char
modifier|*
name|cmdname
decl_stmt|,
modifier|*
name|curfname
decl_stmt|;
specifier|static
name|int
name|been_here
init|=
literal|0
decl_stmt|;
name|va_list
name|varg
decl_stmt|;
if|if
condition|(
name|been_here
operator|++
operator|>
literal|2
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|cmdname
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|varg
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|varg
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|varg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" at source line %d"
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|curfname
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" in function %s"
argument_list|,
name|curfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|compile_time
operator|==
literal|1
operator|&&
name|cursource
argument_list|()
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" source file %s"
argument_list|,
name|cursource
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|errorflag
operator|=
literal|2
expr_stmt|;
name|eprint
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fpecatch
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|FATAL
argument_list|(
literal|"floating point exception %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
name|bracecnt
decl_stmt|,
name|brackcnt
decl_stmt|,
name|parencnt
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|bracecheck
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
specifier|static
name|int
name|beenhere
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|beenhere
operator|++
condition|)
return|return;
while|while
condition|(
operator|(
name|c
operator|=
name|input
argument_list|()
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
name|bclass
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|bcheck2
argument_list|(
name|bracecnt
argument_list|,
literal|'{'
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
name|bcheck2
argument_list|(
name|brackcnt
argument_list|,
literal|'['
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
name|bcheck2
argument_list|(
name|parencnt
argument_list|,
literal|'('
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bcheck2
parameter_list|(
name|int
name|n
parameter_list|,
name|int
name|c1
parameter_list|,
name|int
name|c2
parameter_list|)
block|{
if|if
condition|(
name|n
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmissing %c\n"
argument_list|,
name|c2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%d missing %c's\n"
argument_list|,
name|n
argument_list|,
name|c2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\textra %c\n"
argument_list|,
name|c2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|<
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%d extra %c's\n"
argument_list|,
operator|-
name|n
argument_list|,
name|c2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|FATAL
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
specifier|extern
name|char
modifier|*
name|cmdname
decl_stmt|;
name|va_list
name|varg
decl_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|cmdname
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|varg
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|varg
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|varg
argument_list|)
expr_stmt|;
name|error
argument_list|()
expr_stmt|;
if|if
condition|(
name|dbg
operator|>
literal|1
condition|)
comment|/* core dump if serious debugging on */
name|abort
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|WARNING
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
specifier|extern
name|char
modifier|*
name|cmdname
decl_stmt|;
name|va_list
name|varg
decl_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|cmdname
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|varg
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|varg
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|varg
argument_list|)
expr_stmt|;
name|error
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|error
parameter_list|()
block|{
specifier|extern
name|Node
modifier|*
name|curnode
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|compile_time
operator|!=
literal|2
operator|&&
name|NR
operator|&&
operator|*
name|NR
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" input record number %d"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|*
name|FNR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|FILENAME
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", file %s"
argument_list|,
operator|*
name|FILENAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|compile_time
operator|!=
literal|2
operator|&&
name|curnode
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" source line number %d"
argument_list|,
name|curnode
operator|->
name|lineno
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|compile_time
operator|!=
literal|2
operator|&&
name|lineno
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" source line number %d"
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|compile_time
operator|==
literal|1
operator|&&
name|cursource
argument_list|()
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" source file %s"
argument_list|,
name|cursource
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|eprint
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|eprint
parameter_list|(
name|void
parameter_list|)
comment|/* try to print context around error */
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|c
decl_stmt|;
specifier|static
name|int
name|been_here
init|=
literal|0
decl_stmt|;
specifier|extern
name|char
name|ebuf
index|[]
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|compile_time
operator|==
literal|2
operator|||
name|compile_time
operator|==
literal|0
operator|||
name|been_here
operator|++
operator|>
literal|0
condition|)
return|return;
name|p
operator|=
name|ep
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|>
name|ebuf
operator|&&
operator|*
name|p
operator|==
literal|'\n'
condition|)
name|p
operator|--
expr_stmt|;
for|for
control|(
init|;
name|p
operator|>
name|ebuf
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|--
control|)
empty_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" context is\n\t"
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|ep
operator|-
literal|1
init|;
name|q
operator|>=
name|p
operator|&&
operator|*
name|q
operator|!=
literal|' '
operator|&&
operator|*
name|q
operator|!=
literal|'\t'
operator|&&
operator|*
name|q
operator|!=
literal|'\n'
condition|;
name|q
operator|--
control|)
empty_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|q
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
condition|)
name|putc
argument_list|(
operator|*
name|p
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|">>> "
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|ep
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
condition|)
name|putc
argument_list|(
operator|*
name|p
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<<< "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ep
condition|)
while|while
condition|(
operator|(
name|c
operator|=
name|input
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
name|EOF
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|bclass
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|ep
operator|=
name|ebuf
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bclass
parameter_list|(
name|int
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'{'
case|:
name|bracecnt
operator|++
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|bracecnt
operator|--
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|brackcnt
operator|++
expr_stmt|;
break|break;
case|case
literal|']'
case|:
name|brackcnt
operator|--
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|parencnt
operator|++
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|parencnt
operator|--
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|double
name|errcheck
parameter_list|(
name|double
name|x
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|errno
operator|==
name|EDOM
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|WARNING
argument_list|(
literal|"%s argument out of domain"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|x
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|ERANGE
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|WARNING
argument_list|(
literal|"%s result out of range"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|x
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_function
name|int
name|isclvar
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
comment|/* is s of form var=something ? */
block|{
specifier|const
name|char
modifier|*
name|os
init|=
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
operator|(
name|uschar
operator|)
operator|*
name|s
argument_list|)
operator|&&
operator|*
name|s
operator|!=
literal|'_'
condition|)
return|return
literal|0
return|;
for|for
control|(
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|isalnum
argument_list|(
operator|(
name|uschar
operator|)
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'_'
operator|)
condition|)
break|break;
return|return
operator|*
name|s
operator|==
literal|'='
operator|&&
name|s
operator|>
name|os
operator|&&
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|!=
literal|'='
return|;
block|}
end_function

begin_comment
comment|/* strtod is supposed to be a proper test of what's a valid number */
end_comment

begin_comment
comment|/* appears to be broken in gcc on linux: thinks 0x123 is a valid FP number */
end_comment

begin_comment
comment|/* wrong: violates 4.10.1.4 of ansi C standard */
end_comment

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_function
name|int
name|is_number
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|double
name|r
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|strtod
argument_list|(
name|s
argument_list|,
operator|&
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|s
operator|||
name|r
operator|==
name|HUGE_VAL
operator|||
name|errno
operator|==
name|ERANGE
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|*
name|ep
operator|==
literal|' '
operator|||
operator|*
name|ep
operator|==
literal|'\t'
operator|||
operator|*
name|ep
operator|==
literal|'\n'
condition|)
name|ep
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|==
literal|'\0'
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

end_unit

