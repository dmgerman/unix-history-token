begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright (C) Lucent Technologies 1997 All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the name Lucent Technologies or any of its entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ****************************************************************/
end_comment

begin_define
define|#
directive|define
name|DEBUG
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"awk.h"
end_include

begin_include
include|#
directive|include
file|"ytab.h"
end_include

begin_function
name|Node
modifier|*
name|nodealloc
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|Node
modifier|*
name|x
decl_stmt|;
name|x
operator|=
operator|(
name|Node
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Node
argument_list|)
operator|+
operator|(
name|n
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Node
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL
condition|)
name|FATAL
argument_list|(
literal|"out of space in nodealloc"
argument_list|)
expr_stmt|;
name|x
operator|->
name|nnext
operator|=
name|NULL
expr_stmt|;
name|x
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Node
modifier|*
name|exptostat
parameter_list|(
name|Node
modifier|*
name|a
parameter_list|)
block|{
name|a
operator|->
name|ntype
operator|=
name|NSTAT
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_function
name|Node
modifier|*
name|node1
parameter_list|(
name|int
name|a
parameter_list|,
name|Node
modifier|*
name|b
parameter_list|)
block|{
name|Node
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|nodealloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|x
operator|->
name|nobj
operator|=
name|a
expr_stmt|;
name|x
operator|->
name|narg
index|[
literal|0
index|]
operator|=
name|b
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Node
modifier|*
name|node2
parameter_list|(
name|int
name|a
parameter_list|,
name|Node
modifier|*
name|b
parameter_list|,
name|Node
modifier|*
name|c
parameter_list|)
block|{
name|Node
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|nodealloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|x
operator|->
name|nobj
operator|=
name|a
expr_stmt|;
name|x
operator|->
name|narg
index|[
literal|0
index|]
operator|=
name|b
expr_stmt|;
name|x
operator|->
name|narg
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Node
modifier|*
name|node3
parameter_list|(
name|int
name|a
parameter_list|,
name|Node
modifier|*
name|b
parameter_list|,
name|Node
modifier|*
name|c
parameter_list|,
name|Node
modifier|*
name|d
parameter_list|)
block|{
name|Node
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|nodealloc
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|x
operator|->
name|nobj
operator|=
name|a
expr_stmt|;
name|x
operator|->
name|narg
index|[
literal|0
index|]
operator|=
name|b
expr_stmt|;
name|x
operator|->
name|narg
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|x
operator|->
name|narg
index|[
literal|2
index|]
operator|=
name|d
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Node
modifier|*
name|node4
parameter_list|(
name|int
name|a
parameter_list|,
name|Node
modifier|*
name|b
parameter_list|,
name|Node
modifier|*
name|c
parameter_list|,
name|Node
modifier|*
name|d
parameter_list|,
name|Node
modifier|*
name|e
parameter_list|)
block|{
name|Node
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|nodealloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|x
operator|->
name|nobj
operator|=
name|a
expr_stmt|;
name|x
operator|->
name|narg
index|[
literal|0
index|]
operator|=
name|b
expr_stmt|;
name|x
operator|->
name|narg
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|x
operator|->
name|narg
index|[
literal|2
index|]
operator|=
name|d
expr_stmt|;
name|x
operator|->
name|narg
index|[
literal|3
index|]
operator|=
name|e
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Node
modifier|*
name|stat1
parameter_list|(
name|int
name|a
parameter_list|,
name|Node
modifier|*
name|b
parameter_list|)
block|{
name|Node
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|node1
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|x
operator|->
name|ntype
operator|=
name|NSTAT
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Node
modifier|*
name|stat2
parameter_list|(
name|int
name|a
parameter_list|,
name|Node
modifier|*
name|b
parameter_list|,
name|Node
modifier|*
name|c
parameter_list|)
block|{
name|Node
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|node2
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|x
operator|->
name|ntype
operator|=
name|NSTAT
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Node
modifier|*
name|stat3
parameter_list|(
name|int
name|a
parameter_list|,
name|Node
modifier|*
name|b
parameter_list|,
name|Node
modifier|*
name|c
parameter_list|,
name|Node
modifier|*
name|d
parameter_list|)
block|{
name|Node
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|node3
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|x
operator|->
name|ntype
operator|=
name|NSTAT
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Node
modifier|*
name|stat4
parameter_list|(
name|int
name|a
parameter_list|,
name|Node
modifier|*
name|b
parameter_list|,
name|Node
modifier|*
name|c
parameter_list|,
name|Node
modifier|*
name|d
parameter_list|,
name|Node
modifier|*
name|e
parameter_list|)
block|{
name|Node
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|node4
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|x
operator|->
name|ntype
operator|=
name|NSTAT
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Node
modifier|*
name|op1
parameter_list|(
name|int
name|a
parameter_list|,
name|Node
modifier|*
name|b
parameter_list|)
block|{
name|Node
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|node1
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|x
operator|->
name|ntype
operator|=
name|NEXPR
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Node
modifier|*
name|op2
parameter_list|(
name|int
name|a
parameter_list|,
name|Node
modifier|*
name|b
parameter_list|,
name|Node
modifier|*
name|c
parameter_list|)
block|{
name|Node
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|node2
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|x
operator|->
name|ntype
operator|=
name|NEXPR
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Node
modifier|*
name|op3
parameter_list|(
name|int
name|a
parameter_list|,
name|Node
modifier|*
name|b
parameter_list|,
name|Node
modifier|*
name|c
parameter_list|,
name|Node
modifier|*
name|d
parameter_list|)
block|{
name|Node
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|node3
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|x
operator|->
name|ntype
operator|=
name|NEXPR
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Node
modifier|*
name|op4
parameter_list|(
name|int
name|a
parameter_list|,
name|Node
modifier|*
name|b
parameter_list|,
name|Node
modifier|*
name|c
parameter_list|,
name|Node
modifier|*
name|d
parameter_list|,
name|Node
modifier|*
name|e
parameter_list|)
block|{
name|Node
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|node4
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|x
operator|->
name|ntype
operator|=
name|NEXPR
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Node
modifier|*
name|celltonode
parameter_list|(
name|Cell
modifier|*
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
name|Node
modifier|*
name|x
decl_stmt|;
name|a
operator|->
name|ctype
operator|=
name|OCELL
expr_stmt|;
name|a
operator|->
name|csub
operator|=
name|b
expr_stmt|;
name|x
operator|=
name|node1
argument_list|(
literal|0
argument_list|,
operator|(
name|Node
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
name|x
operator|->
name|ntype
operator|=
name|NVALUE
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Node
modifier|*
name|rectonode
parameter_list|(
name|void
parameter_list|)
comment|/* make $0 into a Node */
block|{
specifier|extern
name|Cell
modifier|*
name|literal0
decl_stmt|;
return|return
name|op1
argument_list|(
name|INDIRECT
argument_list|,
name|celltonode
argument_list|(
name|literal0
argument_list|,
name|CUNK
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|Node
modifier|*
name|makearr
parameter_list|(
name|Node
modifier|*
name|p
parameter_list|)
block|{
name|Cell
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|isvalue
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|cp
operator|=
operator|(
name|Cell
operator|*
operator|)
operator|(
name|p
operator|->
name|narg
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|isfcn
argument_list|(
name|cp
argument_list|)
condition|)
name|SYNTAX
argument_list|(
literal|"%s is a function, not an array"
argument_list|,
name|cp
operator|->
name|nval
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|isarr
argument_list|(
name|cp
argument_list|)
condition|)
block|{
name|xfree
argument_list|(
name|cp
operator|->
name|sval
argument_list|)
expr_stmt|;
name|cp
operator|->
name|sval
operator|=
operator|(
name|char
operator|*
operator|)
name|makesymtab
argument_list|(
name|NSYMTAB
argument_list|)
expr_stmt|;
name|cp
operator|->
name|tval
operator|=
name|ARR
expr_stmt|;
block|}
block|}
return|return
name|p
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PA2NUM
value|50
end_define

begin_comment
comment|/* max number of pat,pat patterns allowed */
end_comment

begin_decl_stmt
name|int
name|paircnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of them in use */
end_comment

begin_decl_stmt
name|int
name|pairstack
index|[
name|PA2NUM
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* state of each pat,pat */
end_comment

begin_function
name|Node
modifier|*
name|pa2stat
parameter_list|(
name|Node
modifier|*
name|a
parameter_list|,
name|Node
modifier|*
name|b
parameter_list|,
name|Node
modifier|*
name|c
parameter_list|)
comment|/* pat, pat {...} */
block|{
name|Node
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|node4
argument_list|(
name|PASTAT2
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|itonp
argument_list|(
name|paircnt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|paircnt
operator|++
operator|>=
name|PA2NUM
condition|)
name|SYNTAX
argument_list|(
literal|"limited to %d pat,pat statements"
argument_list|,
name|PA2NUM
argument_list|)
expr_stmt|;
name|x
operator|->
name|ntype
operator|=
name|NSTAT
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Node
modifier|*
name|linkum
parameter_list|(
name|Node
modifier|*
name|a
parameter_list|,
name|Node
modifier|*
name|b
parameter_list|)
block|{
name|Node
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|errorflag
condition|)
comment|/* don't link things that are wrong */
return|return
name|a
return|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
return|return
operator|(
name|b
operator|)
return|;
elseif|else
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
return|return
operator|(
name|a
operator|)
return|;
for|for
control|(
name|c
operator|=
name|a
init|;
name|c
operator|->
name|nnext
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|nnext
control|)
empty_stmt|;
name|c
operator|->
name|nnext
operator|=
name|b
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_function
name|void
name|defn
parameter_list|(
name|Cell
modifier|*
name|v
parameter_list|,
name|Node
modifier|*
name|vl
parameter_list|,
name|Node
modifier|*
name|st
parameter_list|)
comment|/* turn on FCN bit in definition, */
block|{
comment|/*   body of function, arglist */
name|Node
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|isarr
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|SYNTAX
argument_list|(
literal|"`%s' is an array name and a function name"
argument_list|,
name|v
operator|->
name|nval
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|isarg
argument_list|(
name|v
operator|->
name|nval
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|SYNTAX
argument_list|(
literal|"`%s' is both function name and argument name"
argument_list|,
name|v
operator|->
name|nval
argument_list|)
expr_stmt|;
return|return;
block|}
name|v
operator|->
name|tval
operator|=
name|FCN
expr_stmt|;
name|v
operator|->
name|sval
operator|=
operator|(
name|char
operator|*
operator|)
name|st
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
comment|/* count arguments */
for|for
control|(
name|p
operator|=
name|vl
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nnext
control|)
name|n
operator|++
expr_stmt|;
name|v
operator|->
name|fval
operator|=
name|n
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"defining func %s (%d args)\n"
operator|,
name|v
operator|->
name|nval
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|isarg
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
comment|/* is s in argument list for current function? */
block|{
comment|/* return -1 if not, otherwise arg # */
specifier|extern
name|Node
modifier|*
name|arglist
decl_stmt|;
name|Node
modifier|*
name|p
init|=
name|arglist
decl_stmt|;
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|nnext
operator|,
name|n
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|(
name|Cell
operator|*
operator|)
operator|(
name|p
operator|->
name|narg
index|[
literal|0
index|]
operator|)
operator|)
operator|->
name|nval
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
return|return
name|n
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ptoi
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
comment|/* convert pointer to integer */
block|{
return|return
operator|(
name|int
operator|)
operator|(
name|long
operator|)
name|p
return|;
comment|/* swearing that p fits, of course */
block|}
end_function

begin_function
name|Node
modifier|*
name|itonp
parameter_list|(
name|int
name|i
parameter_list|)
comment|/* and vice versa */
block|{
return|return
operator|(
name|Node
operator|*
operator|)
operator|(
name|long
operator|)
name|i
return|;
block|}
end_function

end_unit

