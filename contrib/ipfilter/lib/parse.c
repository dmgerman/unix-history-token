begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD$	*/
end_comment

begin_comment
comment|/*  * Copyright (C) 1993-2001 by Darren Reed.  *  * See the IPFILTER.LICENCE file for details on licencing.  *  * Id: parse.c,v 1.34.2.1 2004/12/09 19:41:21 darrenr Exp  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"ipf.h"
end_include

begin_include
include|#
directive|include
file|"opts.h"
end_include

begin_decl_stmt
specifier|static
name|frentry_t
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* parse()  *  * parse a line read from the input filter rule file  */
end_comment

begin_function
name|struct
name|frentry
modifier|*
name|parse
parameter_list|(
name|line
parameter_list|,
name|linenum
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|linenum
decl_stmt|;
block|{
specifier|static
name|fripf_t
name|fip
decl_stmt|;
name|char
modifier|*
name|cps
index|[
literal|31
index|]
decl_stmt|,
modifier|*
modifier|*
name|cpp
decl_stmt|,
modifier|*
name|endptr
decl_stmt|,
modifier|*
name|proto
init|=
name|NULL
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|struct
name|protoent
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cnt
init|=
literal|1
decl_stmt|,
name|j
decl_stmt|;
name|u_int
name|k
decl_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|fp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|fp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
while|while
condition|(
operator|*
name|line
operator|&&
name|ISSPACE
argument_list|(
operator|*
name|line
argument_list|)
condition|)
name|line
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|line
condition|)
return|return
name|NULL
return|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fp
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|fip
argument_list|,
sizeof|sizeof
argument_list|(
name|fip
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fr_v
operator|=
name|use_inet6
condition|?
literal|6
else|:
literal|4
expr_stmt|;
name|fp
operator|->
name|fr_ipf
operator|=
operator|&
name|fip
expr_stmt|;
name|fp
operator|->
name|fr_dsize
operator|=
sizeof|sizeof
argument_list|(
name|fip
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fr_ip
operator|.
name|fi_v
operator|=
name|fp
operator|->
name|fr_v
expr_stmt|;
name|fp
operator|->
name|fr_mip
operator|.
name|fi_v
operator|=
literal|0xf
expr_stmt|;
name|fp
operator|->
name|fr_type
operator|=
name|FR_T_NONE
expr_stmt|;
name|fp
operator|->
name|fr_loglevel
operator|=
literal|0xffff
expr_stmt|;
name|fp
operator|->
name|fr_isc
operator|=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
name|fp
operator|->
name|fr_tag
operator|=
name|FR_NOTAG
expr_stmt|;
comment|/* 	 * break line up into max of 20 segments 	 */
if|if
condition|(
name|opts
operator|&
name|OPT_DEBUG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"parse [%s]\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
operator|*
name|cps
operator|=
name|strtok
argument_list|(
name|line
argument_list|,
literal|" \b\t\r\n"
argument_list|)
init|;
name|cps
index|[
name|i
index|]
operator|&&
name|i
operator|<
literal|30
condition|;
name|cnt
operator|++
control|)
name|cps
index|[
operator|++
name|i
index|]
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" \b\t\r\n"
argument_list|)
expr_stmt|;
name|cps
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cnt
operator|<
literal|3
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: not enough segments in line\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|cpp
operator|=
name|cps
expr_stmt|;
comment|/* 	 * The presence of an '@' followed by a number gives the position in 	 * the current rule list to insert this one. 	 */
if|if
condition|(
operator|*
operator|*
name|cpp
operator|==
literal|'@'
condition|)
name|fp
operator|->
name|fr_hits
operator|=
operator|(
name|U_QUAD_T
operator|)
name|atoi
argument_list|(
operator|*
name|cpp
operator|++
operator|+
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* 	 * Check the first keyword in the rule and any options that are 	 * expected to follow it. 	 */
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
literal|"block"
argument_list|,
operator|*
name|cpp
argument_list|)
condition|)
block|{
name|fp
operator|->
name|fr_flags
operator||=
name|FR_BLOCK
expr_stmt|;
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
operator|*
operator|(
name|cpp
operator|+
literal|1
operator|)
argument_list|,
literal|"return-icmp-as-dest"
argument_list|,
literal|19
argument_list|)
operator|&&
operator|(
name|i
operator|=
literal|19
operator|)
condition|)
name|fp
operator|->
name|fr_flags
operator||=
name|FR_FAKEICMP
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
operator|*
operator|(
name|cpp
operator|+
literal|1
operator|)
argument_list|,
literal|"return-icmp"
argument_list|,
literal|11
argument_list|)
operator|&&
operator|(
name|i
operator|=
literal|11
operator|)
condition|)
name|fp
operator|->
name|fr_flags
operator||=
name|FR_RETICMP
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|fr_flags
operator|&
name|FR_RETICMP
condition|)
block|{
name|cpp
operator|++
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
operator|*
name|cpp
argument_list|)
operator|==
name|i
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|cpp
operator|+
literal|1
operator|)
operator|&&
operator|*
operator|*
operator|(
name|cpp
operator|+
literal|1
operator|)
operator|==
literal|'('
condition|)
block|{
name|cpp
operator|++
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 			 * The ICMP code is not required to follow in ()'s 			 */
if|if
condition|(
operator|(
name|i
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|*
operator|(
operator|*
name|cpp
operator|+
name|i
operator|)
operator|==
literal|'('
operator|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|j
operator|=
name|icmpcode
argument_list|(
operator|*
name|cpp
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: unrecognised icmp code %s\n"
argument_list|,
name|linenum
argument_list|,
operator|*
name|cpp
operator|+
literal|20
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|fp
operator|->
name|fr_icode
operator|=
name|j
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
operator|*
operator|(
name|cpp
operator|+
literal|1
operator|)
argument_list|,
literal|"return-rst"
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|fp
operator|->
name|fr_flags
operator||=
name|FR_RETRST
expr_stmt|;
name|cpp
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
literal|"count"
argument_list|,
operator|*
name|cpp
argument_list|)
condition|)
block|{
name|fp
operator|->
name|fr_flags
operator||=
name|FR_ACCOUNT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
literal|"pass"
argument_list|,
operator|*
name|cpp
argument_list|)
condition|)
block|{
name|fp
operator|->
name|fr_flags
operator||=
name|FR_PASS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
literal|"auth"
argument_list|,
operator|*
name|cpp
argument_list|)
condition|)
block|{
name|fp
operator|->
name|fr_flags
operator||=
name|FR_AUTH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fp
operator|->
name|fr_arg
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"skip %u"
argument_list|,
name|fp
operator|->
name|fr_arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
literal|"preauth"
argument_list|,
operator|*
name|cpp
argument_list|)
condition|)
block|{
name|fp
operator|->
name|fr_flags
operator||=
name|FR_PREAUTH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
literal|"nomatch"
argument_list|,
operator|*
name|cpp
argument_list|)
condition|)
block|{
name|fp
operator|->
name|fr_flags
operator||=
name|FR_NOMATCH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
literal|"skip"
argument_list|,
operator|*
name|cpp
argument_list|)
condition|)
block|{
name|cpp
operator|++
expr_stmt|;
if|if
condition|(
name|ratoui
argument_list|(
operator|*
name|cpp
argument_list|,
operator|&
name|k
argument_list|,
literal|0
argument_list|,
name|UINT_MAX
argument_list|)
condition|)
name|fp
operator|->
name|fr_arg
operator|=
name|k
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: integer must follow skip\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
literal|"log"
argument_list|,
operator|*
name|cpp
argument_list|)
condition|)
block|{
name|fp
operator|->
name|fr_flags
operator||=
name|FR_LOG
expr_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
operator|*
operator|(
name|cpp
operator|+
literal|1
operator|)
argument_list|,
literal|"body"
argument_list|)
condition|)
block|{
name|fp
operator|->
name|fr_flags
operator||=
name|FR_LOGBODY
expr_stmt|;
name|cpp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
operator|*
operator|(
name|cpp
operator|+
literal|1
operator|)
argument_list|,
literal|"first"
argument_list|)
condition|)
block|{
name|fp
operator|->
name|fr_flags
operator||=
name|FR_LOGFIRST
expr_stmt|;
name|cpp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cpp
operator|&&
operator|!
name|strcasecmp
argument_list|(
operator|*
operator|(
name|cpp
operator|+
literal|1
operator|)
argument_list|,
literal|"or-block"
argument_list|)
condition|)
block|{
name|fp
operator|->
name|fr_flags
operator||=
name|FR_LOGORBLOCK
expr_stmt|;
name|cpp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
operator|*
operator|(
name|cpp
operator|+
literal|1
operator|)
argument_list|,
literal|"level"
argument_list|)
condition|)
block|{
name|cpp
operator|++
expr_stmt|;
if|if
condition|(
name|loglevel
argument_list|(
name|cpp
argument_list|,
operator|&
name|fp
operator|->
name|fr_loglevel
argument_list|,
name|linenum
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
name|cpp
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Doesn't start with one of the action words 		 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: unknown keyword (%s)\n"
argument_list|,
name|linenum
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
operator|*
operator|++
name|cpp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: missing 'in'/'out' keyword\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 	 * Get the direction for filtering.  Impose restrictions on direction 	 * if blocking with returning ICMP or an RST has been requested. 	 */
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
literal|"in"
argument_list|,
operator|*
name|cpp
argument_list|)
condition|)
name|fp
operator|->
name|fr_flags
operator||=
name|FR_INQUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
literal|"out"
argument_list|,
operator|*
name|cpp
argument_list|)
condition|)
block|{
name|fp
operator|->
name|fr_flags
operator||=
name|FR_OUTQUE
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|fr_flags
operator|&
name|FR_RETICMP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: Can only use return-icmp with 'in'\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|fp
operator|->
name|fr_flags
operator|&
name|FR_RETRST
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: Can only use return-rst with 'in'\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
operator|!
operator|*
operator|++
name|cpp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: missing source specification\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
literal|"log"
argument_list|,
operator|*
name|cpp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
operator|++
name|cpp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: missing source specification\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|FR_ISPASS
argument_list|(
name|fp
operator|->
name|fr_flags
argument_list|)
condition|)
name|fp
operator|->
name|fr_flags
operator||=
name|FR_LOGP
expr_stmt|;
elseif|else
if|if
condition|(
name|FR_ISBLOCK
argument_list|(
name|fp
operator|->
name|fr_flags
argument_list|)
condition|)
name|fp
operator|->
name|fr_flags
operator||=
name|FR_LOGB
expr_stmt|;
if|if
condition|(
operator|*
name|cpp
operator|&&
operator|!
name|strcasecmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"body"
argument_list|)
condition|)
block|{
name|fp
operator|->
name|fr_flags
operator||=
name|FR_LOGBODY
expr_stmt|;
name|cpp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cpp
operator|&&
operator|!
name|strcasecmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"first"
argument_list|)
condition|)
block|{
name|fp
operator|->
name|fr_flags
operator||=
name|FR_LOGFIRST
expr_stmt|;
name|cpp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cpp
operator|&&
operator|!
name|strcasecmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"or-block"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|FR_ISPASS
argument_list|(
name|fp
operator|->
name|fr_flags
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: or-block must be used with pass\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|fp
operator|->
name|fr_flags
operator||=
name|FR_LOGORBLOCK
expr_stmt|;
name|cpp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cpp
operator|&&
operator|!
name|strcasecmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"level"
argument_list|)
condition|)
block|{
if|if
condition|(
name|loglevel
argument_list|(
name|cpp
argument_list|,
operator|&
name|fp
operator|->
name|fr_loglevel
argument_list|,
name|linenum
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
name|cpp
operator|++
expr_stmt|;
name|cpp
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|cpp
operator|&&
operator|!
name|strcasecmp
argument_list|(
literal|"quick"
argument_list|,
operator|*
name|cpp
argument_list|)
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|fr_arg
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: cannot use skip with quick\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|cpp
operator|++
expr_stmt|;
name|fp
operator|->
name|fr_flags
operator||=
name|FR_QUICK
expr_stmt|;
block|}
comment|/* 	 * Parse rule options that are available if a rule is tied to an 	 * interface. 	 */
operator|*
name|fp
operator|->
name|fr_ifname
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|fp
operator|->
name|fr_oifname
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|cpp
operator|&&
operator|!
name|strcasecmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"on"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
operator|++
name|cpp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: interface name missing\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|fp
operator|->
name|fr_ifname
argument_list|,
operator|*
name|cpp
argument_list|,
name|IFNAMSIZ
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fr_ifname
index|[
name|IFNAMSIZ
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cpp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|cpp
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|->
name|fr_flags
operator|&
name|FR_RETMASK
operator|)
operator|==
name|FR_RETRST
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: %s can only be used with TCP\n"
argument_list|,
name|linenum
argument_list|,
literal|"return-rst"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|fp
return|;
block|}
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"out-via"
argument_list|)
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|fr_flags
operator|&
name|FR_OUTQUE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"out-via must be used with in\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|cpp
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|fp
operator|->
name|fr_oifname
argument_list|,
operator|*
name|cpp
argument_list|,
name|IFNAMSIZ
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fr_oifname
index|[
name|IFNAMSIZ
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cpp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"in-via"
argument_list|)
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|fr_flags
operator|&
name|FR_INQUE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"in-via must be used with out\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|cpp
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|fp
operator|->
name|fr_oifname
argument_list|,
operator|*
name|cpp
argument_list|,
name|IFNAMSIZ
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fr_oifname
index|[
name|IFNAMSIZ
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cpp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"dup-to"
argument_list|)
operator|&&
operator|*
operator|(
name|cpp
operator|+
literal|1
operator|)
condition|)
block|{
name|cpp
operator|++
expr_stmt|;
if|if
condition|(
name|to_interface
argument_list|(
operator|&
name|fp
operator|->
name|fr_dif
argument_list|,
operator|*
name|cpp
argument_list|,
name|linenum
argument_list|)
condition|)
return|return
name|NULL
return|;
name|cpp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cpp
operator|&&
operator|!
name|strcasecmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"to"
argument_list|)
operator|&&
operator|*
operator|(
name|cpp
operator|+
literal|1
operator|)
condition|)
block|{
name|cpp
operator|++
expr_stmt|;
if|if
condition|(
name|to_interface
argument_list|(
operator|&
name|fp
operator|->
name|fr_tif
argument_list|,
operator|*
name|cpp
argument_list|,
name|linenum
argument_list|)
condition|)
return|return
name|NULL
return|;
name|cpp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cpp
operator|&&
operator|!
name|strcasecmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"fastroute"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|fp
operator|->
name|fr_flags
operator|&
name|FR_INQUE
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can only use %s with 'in'\n"
argument_list|,
literal|"fastroute"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|fp
operator|->
name|fr_flags
operator||=
name|FR_FASTROUTE
expr_stmt|;
name|cpp
operator|++
expr_stmt|;
block|}
comment|/* 		 * Set the "other" interface name.  Lets you specify both 		 * inbound and outbound interfaces for state rules.  Do not 		 * prevent both interfaces from being the same. 		 */
name|strcpy
argument_list|(
name|fp
operator|->
name|fr_ifnames
index|[
literal|3
index|]
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cpp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
operator|(
name|cpp
operator|+
literal|1
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
operator|(
operator|(
name|fp
operator|->
name|fr_flags
operator|&
name|FR_INQUE
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcasecmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"out-via"
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
operator|(
name|fp
operator|->
name|fr_flags
operator|&
name|FR_OUTQUE
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcasecmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"in-via"
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
name|cpp
operator|++
expr_stmt|;
name|s
operator|=
name|strchr
argument_list|(
operator|*
name|cpp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|fp
operator|->
name|fr_ifnames
index|[
literal|3
index|]
argument_list|,
name|s
argument_list|,
name|IFNAMSIZ
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fr_ifnames
index|[
literal|3
index|]
index|[
name|IFNAMSIZ
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|fp
operator|->
name|fr_ifnames
index|[
literal|2
index|]
argument_list|,
operator|*
name|cpp
argument_list|,
name|IFNAMSIZ
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fr_ifnames
index|[
literal|2
index|]
index|[
name|IFNAMSIZ
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cpp
operator|++
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|fp
operator|->
name|fr_ifnames
index|[
literal|2
index|]
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cpp
operator|&&
operator|!
name|strcasecmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"tos"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
operator|++
name|cpp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: tos missing value\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|fp
operator|->
name|fr_tos
operator|=
name|strtol
argument_list|(
operator|*
name|cpp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fr_mip
operator|.
name|fi_tos
operator|=
literal|0xff
expr_stmt|;
name|cpp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cpp
operator|&&
operator|!
name|strcasecmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"ttl"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
operator|++
name|cpp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: ttl missing hopcount value\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|ratoi
argument_list|(
operator|*
name|cpp
argument_list|,
operator|&
name|i
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
condition|)
name|fp
operator|->
name|fr_ttl
operator|=
name|i
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: invalid ttl (%s)\n"
argument_list|,
name|linenum
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|fp
operator|->
name|fr_mip
operator|.
name|fi_ttl
operator|=
literal|0xff
expr_stmt|;
name|cpp
operator|++
expr_stmt|;
block|}
comment|/* 	 * check for "proto<protoname>" only decode udp/tcp/icmp as protoname 	 */
if|if
condition|(
operator|*
name|cpp
operator|&&
operator|!
name|strcasecmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"proto"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
operator|++
name|cpp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: protocol name missing\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|fp
operator|->
name|fr_type
operator|=
name|FR_T_IPF
expr_stmt|;
name|proto
operator|=
operator|*
name|cpp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|proto
argument_list|,
literal|"tcp/udp"
argument_list|)
condition|)
block|{
name|fp
operator|->
name|fr_flx
operator||=
name|FI_TCPUDP
expr_stmt|;
name|fp
operator|->
name|fr_mflx
operator||=
name|FI_TCPUDP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|use_inet6
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|proto
argument_list|,
literal|"icmp"
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: use proto ipv6-icmp with IPv6 (or use proto 1 if you really mean icmp)\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
block|{
name|fp
operator|->
name|fr_proto
operator|=
name|getproto
argument_list|(
name|proto
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fr_mip
operator|.
name|fi_p
operator|=
literal|0xff
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|fp
operator|->
name|fr_proto
operator|!=
name|IPPROTO_TCP
operator|)
operator|&&
operator|(
operator|(
name|fp
operator|->
name|fr_flags
operator|&
name|FR_RETMASK
operator|)
operator|==
name|FR_RETRST
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: %s can only be used with TCP\n"
argument_list|,
name|linenum
argument_list|,
literal|"return-rst"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 	 * get the from host and bit mask to use against packets 	 */
if|if
condition|(
operator|!
operator|*
name|cpp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: missing source specification\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"all"
argument_list|)
condition|)
block|{
name|cpp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|cpp
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|fr_type
operator|==
name|FR_T_NONE
condition|)
block|{
name|fp
operator|->
name|fr_dsize
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|fr_data
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|fp
return|;
block|}
name|fp
operator|->
name|fr_type
operator|=
name|FR_T_IPF
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFILTER_BPF
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"{"
argument_list|)
condition|)
block|{
name|struct
name|bpf_program
name|bpf
decl_stmt|;
name|struct
name|pcap
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
modifier|*
name|cp
decl_stmt|;
name|u_32_t
name|l
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|fr_type
operator|!=
name|FR_T_NONE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: cannot mix BPF/ipf matching\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|fp
operator|->
name|fr_type
operator|=
name|FR_T_BPFOPC
expr_stmt|;
name|cpp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"0x"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|fp
operator|->
name|fr_data
operator|=
name|malloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|cpp
operator|,
name|i
operator|=
literal|0
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|cp
argument_list|,
literal|"}"
argument_list|)
condition|)
break|break;
name|fp
operator|->
name|fr_data
operator|=
name|realloc
argument_list|(
name|fp
operator|->
name|fr_data
argument_list|,
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
literal|4
argument_list|)
expr_stmt|;
name|l
operator|=
name|strtoul
argument_list|(
operator|*
name|cp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
operator|(
name|u_32_t
operator|*
operator|)
name|fp
operator|->
name|fr_data
operator|)
index|[
name|i
index|]
operator|=
name|l
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|cp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Missing closing '}'\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|fp
operator|->
name|fr_dsize
operator|=
name|i
operator|*
sizeof|sizeof
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|bpf
operator|.
name|bf_insns
operator|=
name|fp
operator|->
name|fr_data
expr_stmt|;
name|bpf
operator|.
name|bf_len
operator|=
name|fp
operator|->
name|fr_dsize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|bpf_insn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|cp
operator|=
name|cpp
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|cp
argument_list|,
literal|"}"
argument_list|)
condition|)
break|break;
operator|(
operator|*
name|cp
operator|)
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|cp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Missing closing '}'\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|bpf
argument_list|,
sizeof|sizeof
argument_list|(
name|bpf
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|pcap_open_dead
argument_list|(
name|DLT_RAW
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pcap_open_dead failed\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|pcap_compile
argument_list|(
name|p
argument_list|,
operator|&
name|bpf
argument_list|,
operator|*
name|cpp
argument_list|,
literal|1
argument_list|,
literal|0xffffffff
argument_list|)
condition|)
block|{
name|pcap_perror
argument_list|(
name|p
argument_list|,
literal|"ipf"
argument_list|)
expr_stmt|;
name|pcap_close
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pcap parsing failed\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|pcap_close
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fr_dsize
operator|=
name|bpf
operator|.
name|bf_len
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|bpf_insn
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fr_data
operator|=
name|bpf
operator|.
name|bf_insns
expr_stmt|;
if|if
condition|(
operator|!
name|bpf_validate
argument_list|(
name|fp
operator|->
name|fr_data
argument_list|,
name|bpf
operator|.
name|bf_len
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"BPF validation failed\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|opts
operator|&
name|OPT_DEBUG
condition|)
name|bpf_dump
argument_list|(
operator|&
name|bpf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|cpp
operator|=
name|cp
expr_stmt|;
operator|(
operator|*
name|cpp
operator|)
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|fp
operator|->
name|fr_type
operator|=
name|FR_T_IPF
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"from"
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: unexpected keyword (%s) - from\n"
argument_list|,
name|linenum
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
operator|*
operator|++
name|cpp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: missing host after from\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|*
operator|*
name|cpp
operator|==
literal|'!'
condition|)
block|{
name|fp
operator|->
name|fr_flags
operator||=
name|FR_NOTSRCIP
expr_stmt|;
operator|(
operator|*
name|cpp
operator|)
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"!"
argument_list|)
condition|)
block|{
name|fp
operator|->
name|fr_flags
operator||=
name|FR_NOTSRCIP
expr_stmt|;
name|cpp
operator|++
expr_stmt|;
block|}
name|s
operator|=
operator|*
name|cpp
expr_stmt|;
name|i
operator|=
name|hostmask
argument_list|(
operator|&
name|cpp
argument_list|,
name|proto
argument_list|,
name|fp
operator|->
name|fr_ifname
argument_list|,
operator|(
name|u_32_t
operator|*
operator|)
operator|&
name|fp
operator|->
name|fr_src
argument_list|,
operator|(
name|u_32_t
operator|*
operator|)
operator|&
name|fp
operator|->
name|fr_smsk
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|*
name|fp
operator|->
name|fr_ifname
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|s
argument_list|,
name|fp
operator|->
name|fr_ifname
argument_list|)
condition|)
name|fp
operator|->
name|fr_satype
operator|=
name|FRI_DYNAMIC
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|fr_v
operator|==
literal|6
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can only use pools with ipv4\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|fp
operator|->
name|fr_satype
operator|=
name|FRI_LOOKUP
expr_stmt|;
block|}
if|if
condition|(
name|ports
argument_list|(
operator|&
name|cpp
argument_list|,
name|proto
argument_list|,
operator|&
name|fp
operator|->
name|fr_sport
argument_list|,
operator|&
name|fp
operator|->
name|fr_scmp
argument_list|,
operator|&
name|fp
operator|->
name|fr_stop
argument_list|,
name|linenum
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
operator|*
name|cpp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: missing to fields\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 		 * do the same for the to field (destination host) 		 */
if|if
condition|(
name|strcasecmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"to"
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: unexpected keyword (%s) - to\n"
argument_list|,
name|linenum
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
operator|*
operator|++
name|cpp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: missing host after to\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|*
operator|*
name|cpp
operator|==
literal|'!'
condition|)
block|{
name|fp
operator|->
name|fr_flags
operator||=
name|FR_NOTDSTIP
expr_stmt|;
operator|(
operator|*
name|cpp
operator|)
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"!"
argument_list|)
condition|)
block|{
name|fp
operator|->
name|fr_flags
operator||=
name|FR_NOTDSTIP
expr_stmt|;
name|cpp
operator|++
expr_stmt|;
block|}
name|s
operator|=
operator|*
name|cpp
expr_stmt|;
name|i
operator|=
name|hostmask
argument_list|(
operator|&
name|cpp
argument_list|,
name|proto
argument_list|,
name|fp
operator|->
name|fr_ifname
argument_list|,
operator|(
name|u_32_t
operator|*
operator|)
operator|&
name|fp
operator|->
name|fr_dst
argument_list|,
operator|(
name|u_32_t
operator|*
operator|)
operator|&
name|fp
operator|->
name|fr_dmsk
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|*
name|fp
operator|->
name|fr_ifname
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|s
argument_list|,
name|fp
operator|->
name|fr_ifname
argument_list|)
condition|)
name|fp
operator|->
name|fr_datype
operator|=
name|FRI_DYNAMIC
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|fr_v
operator|==
literal|6
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can only use pools with ipv4\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|fp
operator|->
name|fr_datype
operator|=
name|FRI_LOOKUP
expr_stmt|;
block|}
if|if
condition|(
name|ports
argument_list|(
operator|&
name|cpp
argument_list|,
name|proto
argument_list|,
operator|&
name|fp
operator|->
name|fr_dport
argument_list|,
operator|&
name|fp
operator|->
name|fr_dcmp
argument_list|,
operator|&
name|fp
operator|->
name|fr_dtop
argument_list|,
name|linenum
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|fp
operator|->
name|fr_type
operator|==
name|FR_T_IPF
condition|)
block|{
comment|/* 		 * check some sanity, make sure we don't have icmp checks 		 * with tcp or udp or visa versa. 		 */
if|if
condition|(
name|fp
operator|->
name|fr_proto
operator|&&
operator|(
name|fp
operator|->
name|fr_dcmp
operator|||
name|fp
operator|->
name|fr_scmp
operator|)
operator|&&
name|fp
operator|->
name|fr_proto
operator|!=
name|IPPROTO_TCP
operator|&&
name|fp
operator|->
name|fr_proto
operator|!=
name|IPPROTO_UDP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: port operation on non tcp/udp\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|fp
operator|->
name|fr_icmp
operator|&&
name|fp
operator|->
name|fr_proto
operator|!=
name|IPPROTO_ICMP
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: icmp comparisons on wrong protocol\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
operator|*
name|cpp
condition|)
return|return
name|fp
return|;
if|if
condition|(
operator|*
name|cpp
operator|&&
operator|(
name|fp
operator|->
name|fr_type
operator|==
name|FR_T_IPF
operator|)
operator|&&
operator|!
name|strcasecmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"flags"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
operator|++
name|cpp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: no flags present\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|fp
operator|->
name|fr_tcpf
operator|=
name|tcp_flags
argument_list|(
operator|*
name|cpp
argument_list|,
operator|&
name|fp
operator|->
name|fr_tcpfm
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
name|cpp
operator|++
expr_stmt|;
block|}
comment|/* 		 * extras... 		 */
if|if
condition|(
operator|(
name|fp
operator|->
name|fr_v
operator|==
literal|4
operator|)
operator|&&
operator|*
name|cpp
operator|&&
operator|(
operator|!
name|strcasecmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"with"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"and"
argument_list|)
operator|)
condition|)
if|if
condition|(
name|extras
argument_list|(
operator|&
name|cpp
argument_list|,
name|fp
argument_list|,
name|linenum
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* 		 * icmp types for use with the icmp protocol 		 */
if|if
condition|(
operator|*
name|cpp
operator|&&
operator|!
name|strcasecmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"icmp-type"
argument_list|)
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|fr_proto
operator|!=
name|IPPROTO_ICMP
operator|&&
name|fp
operator|->
name|fr_proto
operator|!=
name|IPPROTO_ICMPV6
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: icmp with wrong protocol (%d)\n"
argument_list|,
name|linenum
argument_list|,
name|fp
operator|->
name|fr_proto
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|addicmp
argument_list|(
operator|&
name|cpp
argument_list|,
name|fp
argument_list|,
name|linenum
argument_list|)
condition|)
return|return
name|NULL
return|;
name|fp
operator|->
name|fr_icmp
operator|=
name|htons
argument_list|(
name|fp
operator|->
name|fr_icmp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fr_icmpm
operator|=
name|htons
argument_list|(
name|fp
operator|->
name|fr_icmpm
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Keep something... 	 */
while|while
condition|(
operator|*
name|cpp
operator|&&
operator|!
name|strcasecmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"keep"
argument_list|)
condition|)
if|if
condition|(
name|addkeep
argument_list|(
operator|&
name|cpp
argument_list|,
name|fp
argument_list|,
name|linenum
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* 	* This is here to enforce the old interface binding behaviour. 	* That is, "on X" is equivalent to "<dir> on X<!dir>-via -,X" 	*/
if|if
condition|(
name|fp
operator|->
name|fr_flags
operator|&
name|FR_KEEPSTATE
condition|)
block|{
if|if
condition|(
operator|*
name|fp
operator|->
name|fr_ifnames
index|[
literal|0
index|]
operator|&&
operator|!
operator|*
name|fp
operator|->
name|fr_ifnames
index|[
literal|3
index|]
condition|)
block|{
name|bcopy
argument_list|(
name|fp
operator|->
name|fr_ifnames
index|[
literal|0
index|]
argument_list|,
name|fp
operator|->
name|fr_ifnames
index|[
literal|3
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
operator|->
name|fr_ifnames
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|fp
operator|->
name|fr_ifnames
index|[
literal|2
index|]
argument_list|,
literal|"*"
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
operator|->
name|fr_ifnames
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * head of a new group ? 	 */
if|if
condition|(
operator|*
name|cpp
operator|&&
operator|!
name|strcasecmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"head"
argument_list|)
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|fr_arg
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: cannot use skip with head\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
operator|*
operator|++
name|cpp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: head without group #\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|strlen
argument_list|(
operator|*
name|cpp
argument_list|)
operator|>
name|FR_GROUPLEN
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: head name too long #\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|strncpy
argument_list|(
name|fp
operator|->
name|fr_grhead
argument_list|,
operator|*
name|cpp
argument_list|,
name|FR_GROUPLEN
argument_list|)
expr_stmt|;
name|cpp
operator|++
expr_stmt|;
block|}
comment|/* 	 * reference to an already existing group ? 	 */
if|if
condition|(
operator|*
name|cpp
operator|&&
operator|!
name|strcasecmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"group"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
operator|++
name|cpp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: group without group #\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|strlen
argument_list|(
operator|*
name|cpp
argument_list|)
operator|>
name|FR_GROUPLEN
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: group name too long #\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|strncpy
argument_list|(
name|fp
operator|->
name|fr_group
argument_list|,
operator|*
name|cpp
argument_list|,
name|FR_GROUPLEN
argument_list|)
expr_stmt|;
name|cpp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cpp
operator|&&
operator|!
name|strcasecmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"tag"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
operator|++
name|cpp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: tag id missing value\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|fp
operator|->
name|fr_tag
operator|=
name|strtol
argument_list|(
operator|*
name|cpp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cpp
operator|++
expr_stmt|;
block|}
comment|/* 	 * pps counter 	 */
if|if
condition|(
operator|*
name|cpp
operator|&&
operator|!
name|strcasecmp
argument_list|(
operator|*
name|cpp
argument_list|,
literal|"pps"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|*
operator|++
name|cpp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: pps without rate\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|ratoui
argument_list|(
operator|*
name|cpp
argument_list|,
operator|&
name|k
argument_list|,
literal|0
argument_list|,
name|INT_MAX
argument_list|)
condition|)
name|fp
operator|->
name|fr_pps
operator|=
name|k
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: invalid pps rate (%s)\n"
argument_list|,
name|linenum
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|cpp
operator|++
expr_stmt|;
block|}
comment|/* 	 * leftovers...yuck 	 */
if|if
condition|(
operator|*
name|cpp
operator|&&
operator|*
operator|*
name|cpp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: unknown words at end: ["
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|cpp
condition|;
name|cpp
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s "
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"]\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 	 * lazy users... 	 */
if|if
condition|(
name|fp
operator|->
name|fr_type
operator|==
name|FR_T_IPF
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|->
name|fr_tcpf
operator|||
name|fp
operator|->
name|fr_tcpfm
operator|)
operator|&&
operator|(
name|fp
operator|->
name|fr_proto
operator|!=
name|IPPROTO_TCP
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: TCP protocol not specified\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|fp
operator|->
name|fr_flx
operator|&
name|FI_TCPUDP
operator|)
operator|&&
operator|(
name|fp
operator|->
name|fr_proto
operator|!=
name|IPPROTO_TCP
operator|)
operator|&&
operator|(
name|fp
operator|->
name|fr_proto
operator|!=
name|IPPROTO_UDP
operator|)
operator|&&
operator|(
name|fp
operator|->
name|fr_dcmp
operator|||
name|fp
operator|->
name|fr_scmp
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|fp
operator|->
name|fr_proto
condition|)
block|{
name|fp
operator|->
name|fr_flx
operator||=
name|FI_TCPUDP
expr_stmt|;
name|fp
operator|->
name|fr_mflx
operator||=
name|FI_TCPUDP
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: port check for non-TCP/UDP\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
if|if
condition|(
operator|*
name|fp
operator|->
name|fr_oifname
operator|&&
name|strcmp
argument_list|(
name|fp
operator|->
name|fr_oifname
argument_list|,
literal|"*"
argument_list|)
operator|&&
operator|!
operator|(
name|fp
operator|->
name|fr_flags
operator|&
name|FR_KEEPSTATE
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d: *-via<if> must be used %s\n"
argument_list|,
name|linenum
argument_list|,
literal|"with keep-state"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|fp
return|;
block|}
end_function

end_unit

