begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1993-1998 by Darren Reed.  *  * Redistribution and use in source and binary forms are permitted  * provided that this notice is preserved and due credit is given  * to the original author and the contributors.  */
end_comment

begin_comment
comment|/* #pragma ident   "@(#)solaris.c	1.12 6/5/96 (C) 1995 Darren Reed"*/
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"@(#)$Id: solaris.c,v 2.1.2.11 1999/12/04 03:33:59 darrenr Exp $"
end_pragma

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/modctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/open.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/cred.h>
end_include

begin_include
include|#
directive|include
file|<sys/dditypes.h>
end_include

begin_include
include|#
directive|include
file|<sys/stream.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/autoconf.h>
end_include

begin_include
include|#
directive|include
file|<sys/byteorder.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/dlpi.h>
end_include

begin_include
include|#
directive|include
file|<sys/stropts.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_if
if|#
directive|if
name|SOLARIS2
operator|>=
literal|6
end_if

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/af.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcpip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/ddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_include
include|#
directive|include
file|"ip_compat.h"
end_include

begin_include
include|#
directive|include
file|"ipl.h"
end_include

begin_include
include|#
directive|include
file|"ip_fil.h"
end_include

begin_include
include|#
directive|include
file|"ip_nat.h"
end_include

begin_decl_stmt
name|char
name|_depends_on
index|[]
init|=
literal|"drv/ip"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|solipdrvattach
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|solipdrvdetach
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|solattach
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|soldetach
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|filterstats
name|frstats
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|KRWLOCK_T
name|ipf_mutex
decl_stmt|,
name|ipfs_mutex
decl_stmt|,
name|ipf_nat
decl_stmt|,
name|ipf_solaris
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|kmutex_t
name|ipf_rw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|fr_running
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|fr_flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|ipnat_t
modifier|*
name|nat_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|qif_t
modifier|*
name|qif_head
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_getinfo
name|__P
argument_list|(
operator|(
name|dev_info_t
operator|*
operator|,
name|ddi_info_cmd_t
operator|,
name|void
operator|*
operator|,
name|void
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_probe
name|__P
argument_list|(
operator|(
name|dev_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_identify
name|__P
argument_list|(
operator|(
name|dev_info_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_attach
name|__P
argument_list|(
operator|(
name|dev_info_t
operator|*
operator|,
name|ddi_attach_cmd_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipf_detach
name|__P
argument_list|(
operator|(
name|dev_info_t
operator|*
operator|,
name|ddi_detach_cmd_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|qif_t
modifier|*
name|qif_from_queue
name|__P
argument_list|(
operator|(
name|queue_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fr_donotip
name|__P
argument_list|(
operator|(
name|int
operator|,
name|qif_t
operator|*
operator|,
name|queue_t
operator|*
operator|,
name|mblk_t
operator|*
operator|,
name|mblk_t
operator|*
operator|,
name|ip_t
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ipf_devfiles
index|[]
init|=
block|{
name|IPL_NAME
block|,
name|IPL_NAT
block|,
name|IPL_STATE
block|,
name|IPL_AUTH
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|int
argument_list|(
argument|*ipf_ip_inp
argument_list|)
name|__P
argument_list|(
operator|(
name|queue_t
operator|*
operator|,
name|mblk_t
operator|*
operator|)
argument_list|)
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|SOLARIS2
operator|>=
literal|7
end_if

begin_decl_stmt
specifier|extern
name|void
name|ipfr_slowtimer
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|timeout_id_t
name|ipfr_timer_id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|timeout_id_t
name|synctimeoutid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|void
name|ipfr_slowtimer
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ipfr_timer_id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|synctimeoutid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IPFDEBUG
end_ifdef

begin_decl_stmt
name|void
name|printire
name|__P
argument_list|(
operator|(
name|ire_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|fr_precheck
name|__P
argument_list|(
operator|(
name|mblk_t
operator|*
operator|*
operator|,
name|queue_t
operator|*
operator|,
name|qif_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cb_ops
name|ipf_cb_ops
init|=
block|{
name|iplopen
block|,
name|iplclose
block|,
name|nodev
block|,
comment|/* strategy */
name|nodev
block|,
comment|/* print */
name|nodev
block|,
comment|/* dump */
name|iplread
block|,
name|nodev
block|,
comment|/* write */
name|iplioctl
block|,
comment|/* ioctl */
name|nodev
block|,
comment|/* devmap */
name|nodev
block|,
comment|/* mmap */
name|nodev
block|,
comment|/* segmap */
name|nochpoll
block|,
comment|/* poll */
name|ddi_prop_op
block|,
name|NULL
block|,
name|D_MTSAFE
block|,
if|#
directive|if
name|SOLARIS2
operator|>
literal|4
name|CB_REV
block|,
name|nodev
block|,
comment|/* aread */
name|nodev
block|,
comment|/* awrite */
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dev_ops
name|ipf_ops
init|=
block|{
name|DEVO_REV
block|,
literal|0
block|,
name|ipf_getinfo
block|,
name|ipf_identify
block|,
name|ipf_probe
block|,
name|ipf_attach
block|,
name|ipf_detach
block|,
name|nodev
block|,
comment|/* reset */
operator|&
name|ipf_cb_ops
block|,
operator|(
expr|struct
name|bus_ops
operator|*
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|mod_ops
name|mod_driverops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|modldrv
name|iplmod
init|=
block|{
operator|&
name|mod_driverops
block|,
name|IPL_VERSION
block|,
operator|&
name|ipf_ops
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|modlinkage
name|modlink1
init|=
block|{
name|MODREV_1
block|,
operator|&
name|iplmod
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|SOLARIS2
operator|>=
literal|6
end_if

begin_decl_stmt
specifier|static
name|size_t
name|hdrsizes
index|[
literal|57
index|]
index|[
literal|2
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
name|IFT_OTHER
block|,
literal|0
block|}
block|,
block|{
name|IFT_1822
block|,
literal|0
block|}
block|,
block|{
name|IFT_HDH1822
block|,
literal|0
block|}
block|,
block|{
name|IFT_X25DDN
block|,
literal|0
block|}
block|,
block|{
name|IFT_X25
block|,
literal|0
block|}
block|,
block|{
name|IFT_ETHER
block|,
literal|14
block|}
block|,
block|{
name|IFT_ISO88023
block|,
literal|0
block|}
block|,
block|{
name|IFT_ISO88024
block|,
literal|0
block|}
block|,
block|{
name|IFT_ISO88025
block|,
literal|0
block|}
block|,
block|{
name|IFT_ISO88026
block|,
literal|0
block|}
block|,
block|{
name|IFT_STARLAN
block|,
literal|0
block|}
block|,
block|{
name|IFT_P10
block|,
literal|0
block|}
block|,
block|{
name|IFT_P80
block|,
literal|0
block|}
block|,
block|{
name|IFT_HY
block|,
literal|0
block|}
block|,
block|{
name|IFT_FDDI
block|,
literal|24
block|}
block|,
block|{
name|IFT_LAPB
block|,
literal|0
block|}
block|,
block|{
name|IFT_SDLC
block|,
literal|0
block|}
block|,
block|{
name|IFT_T1
block|,
literal|0
block|}
block|,
block|{
name|IFT_CEPT
block|,
literal|0
block|}
block|,
block|{
name|IFT_ISDNBASIC
block|,
literal|0
block|}
block|,
block|{
name|IFT_ISDNPRIMARY
block|,
literal|0
block|}
block|,
block|{
name|IFT_PTPSERIAL
block|,
literal|0
block|}
block|,
block|{
name|IFT_PPP
block|,
literal|0
block|}
block|,
block|{
name|IFT_LOOP
block|,
literal|0
block|}
block|,
block|{
name|IFT_EON
block|,
literal|0
block|}
block|,
block|{
name|IFT_XETHER
block|,
literal|0
block|}
block|,
block|{
name|IFT_NSIP
block|,
literal|0
block|}
block|,
block|{
name|IFT_SLIP
block|,
literal|0
block|}
block|,
block|{
name|IFT_ULTRA
block|,
literal|0
block|}
block|,
block|{
name|IFT_DS3
block|,
literal|0
block|}
block|,
block|{
name|IFT_SIP
block|,
literal|0
block|}
block|,
block|{
name|IFT_FRELAY
block|,
literal|0
block|}
block|,
block|{
name|IFT_RS232
block|,
literal|0
block|}
block|,
block|{
name|IFT_PARA
block|,
literal|0
block|}
block|,
block|{
name|IFT_ARCNET
block|,
literal|0
block|}
block|,
block|{
name|IFT_ARCNETPLUS
block|,
literal|0
block|}
block|,
block|{
name|IFT_ATM
block|,
literal|0
block|}
block|,
block|{
name|IFT_MIOX25
block|,
literal|0
block|}
block|,
block|{
name|IFT_SONET
block|,
literal|0
block|}
block|,
block|{
name|IFT_X25PLE
block|,
literal|0
block|}
block|,
block|{
name|IFT_ISO88022LLC
block|,
literal|0
block|}
block|,
block|{
name|IFT_LOCALTALK
block|,
literal|0
block|}
block|,
block|{
name|IFT_SMDSDXI
block|,
literal|0
block|}
block|,
block|{
name|IFT_FRELAYDCE
block|,
literal|0
block|}
block|,
block|{
name|IFT_V35
block|,
literal|0
block|}
block|,
block|{
name|IFT_HSSI
block|,
literal|0
block|}
block|,
block|{
name|IFT_HIPPI
block|,
literal|0
block|}
block|,
block|{
name|IFT_MODEM
block|,
literal|0
block|}
block|,
block|{
name|IFT_AAL5
block|,
literal|0
block|}
block|,
block|{
name|IFT_SONETPATH
block|,
literal|0
block|}
block|,
block|{
name|IFT_SONETVT
block|,
literal|0
block|}
block|,
block|{
name|IFT_SMDSICIP
block|,
literal|0
block|}
block|,
block|{
name|IFT_PROPVIRTUAL
block|,
literal|0
block|}
block|,
block|{
name|IFT_PROPMUX
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SOLARIS2>= 6 */
end_comment

begin_decl_stmt
specifier|static
name|dev_info_t
modifier|*
name|ipf_dev_info
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|_init
parameter_list|()
block|{
name|int
name|ipfinst
decl_stmt|;
if|if
condition|(
name|fr_running
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|ipfinst
operator|=
name|mod_install
argument_list|(
operator|&
name|modlink1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: _init() = %d\n"
argument_list|,
name|ipfinst
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ipfinst
return|;
block|}
end_function

begin_function
name|int
name|_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ipfinst
decl_stmt|;
if|if
condition|(
name|fr_running
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|ipfinst
operator|=
name|mod_remove
argument_list|(
operator|&
name|modlink1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: _fini() = %d\n"
argument_list|,
name|ipfinst
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ipfinst
return|;
block|}
end_function

begin_function
name|int
name|_info
parameter_list|(
name|modinfop
parameter_list|)
name|struct
name|modinfo
modifier|*
name|modinfop
decl_stmt|;
block|{
name|int
name|ipfinst
decl_stmt|;
if|if
condition|(
name|fr_running
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|ipfinst
operator|=
name|mod_info
argument_list|(
operator|&
name|modlink1
argument_list|,
name|modinfop
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: _info(%x) = %x\n"
argument_list|,
name|modinfop
argument_list|,
name|ipfinst
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fr_running
operator|>
literal|0
condition|)
name|ipfsync
argument_list|()
expr_stmt|;
return|return
name|ipfinst
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ipf_probe
parameter_list|(
name|dip
parameter_list|)
name|dev_info_t
modifier|*
name|dip
decl_stmt|;
block|{
if|if
condition|(
name|fr_running
operator|<
literal|0
condition|)
return|return
name|DDI_PROBE_FAILURE
return|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: ipf_probe(%x)"
argument_list|,
name|dip
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|DDI_PROBE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ipf_identify
parameter_list|(
name|dip
parameter_list|)
name|dev_info_t
modifier|*
name|dip
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: ipf_identify(%x)"
argument_list|,
name|dip
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|strcmp
argument_list|(
name|ddi_get_name
argument_list|(
name|dip
argument_list|)
argument_list|,
literal|"ipf"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|DDI_IDENTIFIED
operator|)
return|;
return|return
operator|(
name|DDI_NOT_IDENTIFIED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ipf_attach
parameter_list|(
name|dip
parameter_list|,
name|cmd
parameter_list|)
name|dev_info_t
modifier|*
name|dip
decl_stmt|;
name|ddi_attach_cmd_t
name|cmd
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|IPFDEBUG
name|int
name|instance
decl_stmt|;
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: ipf_attach(%x,%x)"
argument_list|,
name|dip
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DDI_ATTACH
case|:
if|if
condition|(
name|fr_running
operator|<
literal|0
condition|)
break|break;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|instance
operator|=
name|ddi_get_instance
argument_list|(
name|dip
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: attach ipf instance %d"
argument_list|,
name|instance
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ddi_create_minor_node
argument_list|(
name|dip
argument_list|,
literal|"ipf"
argument_list|,
name|S_IFCHR
argument_list|,
name|IPL_LOGIPF
argument_list|,
name|DDI_PSEUDO
argument_list|,
literal|0
argument_list|)
operator|==
name|DDI_FAILURE
condition|)
block|{
name|ddi_remove_minor_node
argument_list|(
name|dip
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|attach_failed
goto|;
block|}
if|if
condition|(
name|ddi_create_minor_node
argument_list|(
name|dip
argument_list|,
literal|"ipnat"
argument_list|,
name|S_IFCHR
argument_list|,
name|IPL_LOGNAT
argument_list|,
name|DDI_PSEUDO
argument_list|,
literal|0
argument_list|)
operator|==
name|DDI_FAILURE
condition|)
block|{
name|ddi_remove_minor_node
argument_list|(
name|dip
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|attach_failed
goto|;
block|}
if|if
condition|(
name|ddi_create_minor_node
argument_list|(
name|dip
argument_list|,
literal|"ipstate"
argument_list|,
name|S_IFCHR
argument_list|,
name|IPL_LOGSTATE
argument_list|,
name|DDI_PSEUDO
argument_list|,
literal|0
argument_list|)
operator|==
name|DDI_FAILURE
condition|)
block|{
name|ddi_remove_minor_node
argument_list|(
name|dip
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|attach_failed
goto|;
block|}
if|if
condition|(
name|ddi_create_minor_node
argument_list|(
name|dip
argument_list|,
literal|"ipauth"
argument_list|,
name|S_IFCHR
argument_list|,
name|IPL_LOGAUTH
argument_list|,
name|DDI_PSEUDO
argument_list|,
literal|0
argument_list|)
operator|==
name|DDI_FAILURE
condition|)
block|{
name|ddi_remove_minor_node
argument_list|(
name|dip
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|attach_failed
goto|;
block|}
name|ipf_dev_info
operator|=
name|dip
expr_stmt|;
name|sync
argument_list|()
expr_stmt|;
comment|/* 		 * Initialize mutex's 		 */
if|if
condition|(
name|iplattach
argument_list|()
operator|==
operator|-
literal|1
condition|)
goto|goto
name|attach_failed
goto|;
comment|/* 		 * Lock people out while we set things up. 		 */
name|WRITE_ENTER
argument_list|(
operator|&
name|ipf_solaris
argument_list|)
expr_stmt|;
name|solattach
argument_list|()
expr_stmt|;
name|solipdrvattach
argument_list|()
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_solaris
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"%s, attaching complete.\n"
argument_list|,
name|ipfilter_version
argument_list|)
expr_stmt|;
name|sync
argument_list|()
expr_stmt|;
if|if
condition|(
name|fr_running
operator|==
literal|0
condition|)
name|fr_running
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ipfr_timer_id
operator|==
literal|0
condition|)
name|ipfr_timer_id
operator|=
name|timeout
argument_list|(
name|ipfr_slowtimer
argument_list|,
name|NULL
argument_list|,
name|drv_usectohz
argument_list|(
literal|500000
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr_running
operator|==
literal|1
condition|)
return|return
name|DDI_SUCCESS
return|;
default|default:
return|return
name|DDI_FAILURE
return|;
block|}
name|attach_failed
label|:
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: failed to attach\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Use our own detach routine to toss 	 * away any stuff we allocated above. 	 */
operator|(
name|void
operator|)
name|ipf_detach
argument_list|(
name|dip
argument_list|,
name|DDI_DETACH
argument_list|)
expr_stmt|;
return|return
name|DDI_FAILURE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ipf_detach
parameter_list|(
name|dip
parameter_list|,
name|cmd
parameter_list|)
name|dev_info_t
modifier|*
name|dip
decl_stmt|;
name|ddi_detach_cmd_t
name|cmd
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: ipf_detach(%x,%x)"
argument_list|,
name|dip
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DDI_DETACH
case|:
if|if
condition|(
name|fr_running
operator|<=
literal|0
condition|)
break|break;
comment|/* 		 * Make sure we're the only one's modifying things.  With 		 * this lock others should just fall out of the loop. 		 */
name|mutex_enter
argument_list|(
operator|&
name|ipf_rw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipfr_timer_id
operator|!=
literal|0
condition|)
block|{
name|untimeout
argument_list|(
name|ipfr_timer_id
argument_list|)
expr_stmt|;
name|ipfr_timer_id
operator|=
literal|0
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|ipf_rw
argument_list|)
expr_stmt|;
name|WRITE_ENTER
argument_list|(
operator|&
name|ipf_solaris
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ipf_rw
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr_running
operator|<=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|ipf_rw
argument_list|)
expr_stmt|;
return|return
name|DDI_FAILURE
return|;
block|}
name|fr_running
operator|=
operator|-
literal|1
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ipf_rw
argument_list|)
expr_stmt|;
comment|/* NOTE: ipf_solaris rwlock is released in ipldetach */
comment|/* 		 * Undo what we did in ipf_attach, freeing resources 		 * and removing things we installed.  The system 		 * framework guarantees we are not active with this devinfo 		 * node in any other entry points at this time. 		 */
name|ddi_prop_remove_all
argument_list|(
name|dip
argument_list|)
expr_stmt|;
name|i
operator|=
name|ddi_get_instance
argument_list|(
name|dip
argument_list|)
expr_stmt|;
name|ddi_remove_minor_node
argument_list|(
name|dip
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sync
argument_list|()
expr_stmt|;
name|i
operator|=
name|solipdrvdetach
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"IP Filter: still attached (%d)\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|DDI_FAILURE
return|;
block|}
if|if
condition|(
operator|!
name|soldetach
argument_list|()
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"IP Filter: detached\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DDI_SUCCESS
operator|)
return|;
block|}
default|default:
return|return
operator|(
name|DDI_FAILURE
operator|)
return|;
block|}
return|return
name|DDI_FAILURE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ipf_getinfo
parameter_list|(
name|dip
parameter_list|,
name|infocmd
parameter_list|,
name|arg
parameter_list|,
name|result
parameter_list|)
name|dev_info_t
modifier|*
name|dip
decl_stmt|;
name|ddi_info_cmd_t
name|infocmd
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|,
decl|*
modifier|*
name|result
decl_stmt|;
end_function

begin_block
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|fr_running
operator|<=
literal|0
condition|)
return|return
name|DDI_FAILURE
return|;
name|error
operator|=
name|DDI_FAILURE
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: ipf_getinfo(%x,%x,%x)"
argument_list|,
name|dip
argument_list|,
name|infocmd
argument_list|,
name|arg
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|infocmd
condition|)
block|{
case|case
name|DDI_INFO_DEVT2DEVINFO
case|:
operator|*
name|result
operator|=
name|ipf_dev_info
expr_stmt|;
name|error
operator|=
name|DDI_SUCCESS
expr_stmt|;
break|break;
case|case
name|DDI_INFO_DEVT2INSTANCE
case|:
operator|*
name|result
operator|=
operator|(
name|void
operator|*
operator|)
name|getminor
argument_list|(
operator|(
name|dev_t
operator|)
name|arg
argument_list|)
expr_stmt|;
name|error
operator|=
name|DDI_SUCCESS
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * find the filter structure setup for this queue  */
end_comment

begin_function
specifier|static
name|qif_t
modifier|*
name|qif_from_queue
parameter_list|(
name|q
parameter_list|)
name|queue_t
modifier|*
name|q
decl_stmt|;
block|{
name|qif_t
modifier|*
name|qif
decl_stmt|;
for|for
control|(
name|qif
operator|=
name|qif_head
init|;
name|qif
condition|;
name|qif
operator|=
name|qif
operator|->
name|qf_next
control|)
if|if
condition|(
operator|(
name|qif
operator|->
name|qf_iptr
operator|==
name|q
operator|->
name|q_ptr
operator|)
operator|||
operator|(
name|qif
operator|->
name|qf_optr
operator|==
name|q
operator|->
name|q_ptr
operator|)
condition|)
break|break;
return|return
name|qif
return|;
block|}
end_function

begin_comment
comment|/*  * OK, this is pretty scrappy code, but then it's essentially just here for  * debug purposes and that's it.  Packets should not normally come through  * here, and if they do, well, we would like to see as much information as  * possible about them and what they claim to hold.  */
end_comment

begin_function
name|void
name|fr_donotip
parameter_list|(
name|out
parameter_list|,
name|qif
parameter_list|,
name|q
parameter_list|,
name|m
parameter_list|,
name|mt
parameter_list|,
name|ip
parameter_list|,
name|off
parameter_list|)
name|int
name|out
decl_stmt|;
name|qif_t
modifier|*
name|qif
decl_stmt|;
name|queue_t
modifier|*
name|q
decl_stmt|;
name|mblk_t
modifier|*
name|m
decl_stmt|,
decl|*
name|mt
decl_stmt|;
end_function

begin_decl_stmt
name|ip_t
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|off
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u_char
modifier|*
name|s
decl_stmt|,
name|outb
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
name|outb
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|outb
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|outb
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|outb
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|ip
condition|?
operator|(
name|u_char
operator|*
operator|)
name|ip
else|:
name|outb
expr_stmt|;
if|if
condition|(
operator|!
name|ip
operator|&&
operator|(
name|m
operator|==
name|mt
operator|)
operator|&&
name|m
operator|->
name|b_cont
operator|&&
operator|(
name|MTYPE
argument_list|(
name|m
argument_list|)
operator|!=
name|M_DATA
operator|)
condition|)
name|m
operator|=
name|m
operator|->
name|b_cont
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|" !IP %s:%d %d %p %p %p %d %p/%d %p/%d %p %d %d %p\n"
argument_list|,
name|qif
condition|?
name|qif
operator|->
name|qf_name
else|:
literal|"?"
argument_list|,
name|out
argument_list|,
name|qif
operator|->
name|qf_hl
argument_list|,
name|q
argument_list|,
name|q
condition|?
name|q
operator|->
name|q_ptr
else|:
name|NULL
argument_list|,
name|q
condition|?
name|q
operator|->
name|q_qinfo
else|:
name|NULL
argument_list|,
name|mt
operator|->
name|b_wptr
operator|-
name|mt
operator|->
name|b_rptr
argument_list|,
name|m
argument_list|,
name|MTYPE
argument_list|(
name|m
argument_list|)
argument_list|,
name|mt
argument_list|,
name|MTYPE
argument_list|(
name|mt
argument_list|)
argument_list|,
name|m
operator|->
name|b_rptr
argument_list|,
name|m
operator|->
name|b_wptr
operator|-
name|m
operator|->
name|b_rptr
argument_list|,
name|off
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"%02x%02x%02x%02x\n"
argument_list|,
operator|*
name|s
argument_list|,
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
argument_list|,
operator|*
operator|(
name|s
operator|+
literal|2
operator|)
argument_list|,
operator|*
operator|(
name|s
operator|+
literal|3
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|mt
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|outb
expr_stmt|;
name|s
operator|=
name|mt
operator|->
name|b_rptr
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|,
literal|"%d:"
argument_list|,
name|MTYPE
argument_list|(
name|mt
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|i
operator|<
literal|100
operator|)
operator|&&
operator|(
name|s
operator|<
name|mt
operator|->
name|b_wptr
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|,
literal|"%02x%s"
argument_list|,
operator|*
name|s
operator|++
argument_list|,
operator|(
operator|(
name|i
operator|&
literal|3
operator|)
operator|==
literal|3
operator|)
condition|?
literal|" "
else|:
literal|""
argument_list|)
expr_stmt|;
name|t
operator|+=
operator|(
operator|(
name|i
operator|&
literal|3
operator|)
operator|==
literal|3
operator|)
condition|?
literal|3
else|:
literal|2
expr_stmt|;
block|}
operator|*
name|t
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"%s"
argument_list|,
name|outb
argument_list|)
expr_stmt|;
name|mt
operator|=
name|mt
operator|->
name|b_cont
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|outb
expr_stmt|;
name|s
operator|=
name|m
operator|->
name|b_rptr
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|,
literal|"%d:"
argument_list|,
name|MTYPE
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|i
operator|<
literal|100
operator|)
operator|&&
operator|(
name|s
operator|<
name|m
operator|->
name|b_wptr
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|,
literal|"%02x%s"
argument_list|,
operator|*
name|s
operator|++
argument_list|,
operator|(
operator|(
name|i
operator|&
literal|3
operator|)
operator|==
literal|3
operator|)
condition|?
literal|" "
else|:
literal|""
argument_list|)
expr_stmt|;
name|t
operator|+=
operator|(
operator|(
name|i
operator|&
literal|3
operator|)
operator|==
literal|3
operator|)
condition|?
literal|3
else|:
literal|2
expr_stmt|;
block|}
operator|*
name|t
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"%s"
argument_list|,
name|outb
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * find the first data mblk, if present, in the chain we're processing.  Also  * make a few sanity checks to try prevent the filter from causing a panic -  * none of the nice IP sanity checks (including checksumming) should have been  * done yet (for incoming packets) - dangerous!  */
end_comment

begin_function
specifier|static
name|int
name|fr_precheck
parameter_list|(
name|mp
parameter_list|,
name|q
parameter_list|,
name|qif
parameter_list|,
name|out
parameter_list|)
name|mblk_t
modifier|*
modifier|*
name|mp
decl_stmt|;
name|queue_t
modifier|*
name|q
decl_stmt|;
name|qif_t
modifier|*
name|qif
decl_stmt|;
name|int
name|out
decl_stmt|;
block|{
specifier|register
name|mblk_t
modifier|*
name|m
decl_stmt|,
modifier|*
name|mt
init|=
operator|*
name|mp
decl_stmt|;
specifier|register
name|ip_t
modifier|*
name|ip
decl_stmt|;
name|size_t
name|hlen
decl_stmt|,
name|len
decl_stmt|,
name|off
decl_stmt|,
name|mlen
decl_stmt|,
name|iphlen
decl_stmt|;
name|int
name|err
decl_stmt|,
name|synced
init|=
literal|0
decl_stmt|;
name|u_char
modifier|*
name|bp
decl_stmt|;
ifndef|#
directive|ifndef
name|sparc
name|u_short
name|__iplen
decl_stmt|,
name|__ipoff
decl_stmt|;
endif|#
directive|endif
name|tryagain
label|:
comment|/* 	 * If there is only M_DATA for a packet going out, then any header 	 * information (which would otherwise appear in an M_PROTO mblk before 	 * the M_DATA) is prepended before the IP header.  We need to set the 	 * offset to account for this. - see MMM 	 */
name|off
operator|=
operator|(
name|out
operator|)
condition|?
name|qif
operator|->
name|qf_hl
else|:
literal|0
expr_stmt|;
comment|/* 	 * If the message protocol block indicates that there isn't a data 	 * block following it, just return back. 	 */
name|bp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|ALIGN32
argument_list|(
name|mt
operator|->
name|b_rptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|MTYPE
argument_list|(
name|mt
argument_list|)
operator|==
name|M_PROTO
operator|||
name|MTYPE
argument_list|(
name|mt
argument_list|)
operator|==
name|M_PCPROTO
condition|)
block|{
name|dl_unitdata_ind_t
modifier|*
name|dl
init|=
operator|(
name|dl_unitdata_ind_t
operator|*
operator|)
name|bp
decl_stmt|;
if|if
condition|(
name|dl
operator|->
name|dl_primitive
operator|!=
name|DL_UNITDATA_IND
operator|&&
name|dl
operator|->
name|dl_primitive
operator|!=
name|DL_UNITDATA_REQ
condition|)
block|{
name|frstats
index|[
name|out
index|]
operator|.
name|fr_notdata
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* 	 * Find the first data block, count the data blocks in this chain and 	 * the total amount of data. 	 */
for|for
control|(
name|m
operator|=
name|mt
init|;
name|m
operator|&&
operator|(
name|MTYPE
argument_list|(
name|m
argument_list|)
operator|!=
name|M_DATA
operator|)
condition|;
name|m
operator|=
name|m
operator|->
name|b_cont
control|)
name|off
operator|=
literal|0
expr_stmt|;
comment|/* Any non-M_DATA cancels the offset */
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|frstats
index|[
name|out
index|]
operator|.
name|fr_nodata
operator|++
expr_stmt|;
return|return
literal|0
return|;
comment|/* No data blocks */
block|}
comment|/* 	 * This is a complete kludge to try and work around some bizarre 	 * packets which drop through into fr_donotip. 	 */
if|if
condition|(
operator|(
name|mt
operator|!=
name|m
operator|)
operator|&&
operator|(
name|MTYPE
argument_list|(
name|mt
argument_list|)
operator|==
name|M_PROTO
operator|||
name|MTYPE
argument_list|(
name|mt
argument_list|)
operator|==
name|M_PCPROTO
operator|)
condition|)
block|{
name|dl_unitdata_ind_t
modifier|*
name|dl
init|=
operator|(
name|dl_unitdata_ind_t
operator|*
operator|)
name|bp
decl_stmt|;
if|if
condition|(
operator|(
name|dl
operator|->
name|dl_primitive
operator|==
name|DL_UNITDATA_IND
operator|)
operator|&&
operator|(
name|dl
operator|->
name|dl_group_address
operator|==
literal|1
operator|)
condition|)
if|if
condition|(
operator|(
operator|(
operator|*
operator|(
operator|(
name|u_char
operator|*
operator|)
name|m
operator|->
name|b_rptr
operator|)
operator|==
literal|0x0
operator|)
operator|&&
operator|(
operator|(
operator|*
operator|(
operator|(
name|u_char
operator|*
operator|)
name|m
operator|->
name|b_rptr
operator|+
literal|2
operator|)
operator|==
literal|0x45
operator|)
operator|)
operator|)
condition|)
name|off
operator|+=
literal|2
expr_stmt|;
block|}
name|ip
operator|=
operator|(
name|ip_t
operator|*
operator|)
operator|(
name|m
operator|->
name|b_rptr
operator|+
name|off
operator|)
expr_stmt|;
comment|/* MMM */
comment|/* 	 * We might have a 1st data block which is really M_PROTO, i.e. it is 	 * only big enough for the link layer header 	 */
while|while
condition|(
operator|(
name|u_char
operator|*
operator|)
name|ip
operator|>=
name|m
operator|->
name|b_wptr
condition|)
block|{
name|len
operator|=
operator|(
name|u_char
operator|*
operator|)
name|ip
operator|-
name|m
operator|->
name|b_wptr
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|b_cont
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* not enough data for IP */
name|ip
operator|=
operator|(
name|ip_t
operator|*
operator|)
operator|(
name|m
operator|->
name|b_rptr
operator|+
name|len
operator|)
expr_stmt|;
block|}
name|off
operator|=
operator|(
name|u_char
operator|*
operator|)
name|ip
operator|-
name|m
operator|->
name|b_rptr
expr_stmt|;
if|if
condition|(
name|off
operator|!=
literal|0
condition|)
name|m
operator|->
name|b_rptr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|ip
expr_stmt|;
name|mlen
operator|=
name|msgdsize
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|len
operator|=
name|m
operator|->
name|b_wptr
operator|-
name|m
operator|->
name|b_rptr
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|b_wptr
operator|<
name|m
operator|->
name|b_rptr
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"!IP Filter: Bad packet: wptr %p< rptr %p"
argument_list|,
name|m
operator|->
name|b_wptr
argument_list|,
name|m
operator|->
name|b_rptr
argument_list|)
expr_stmt|;
name|frstats
index|[
name|out
index|]
operator|.
name|fr_bad
operator|++
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * Ok, the IP header isn't on a 32bit aligned address so junk it. 	 */
if|if
condition|(
operator|(
operator|(
name|u_int
operator|)
name|ip
operator|&
literal|0x3
operator|)
operator|||
operator|(
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * We have link layer header and IP header in the same mbuf, 		 * problem being that a pullup without adjusting b_rptr will 		 * bring us back here again as it's likely that the start of 		 * the databuffer (b_datab->db_base) is already aligned.  Hmm, 		 * should we pull it all up (length of -1 to pullupmsg) if we 		 * can, now ? 		 */
name|fixalign
label|:
if|if
condition|(
operator|!
name|pullupmsg
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|ip_t
argument_list|)
argument_list|)
condition|)
block|{
name|frstats
index|[
name|out
index|]
operator|.
name|fr_pull
index|[
literal|1
index|]
operator|++
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|frstats
index|[
name|out
index|]
operator|.
name|fr_pull
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|synced
operator|=
literal|1
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
if|if
condition|(
name|ip
operator|->
name|ip_v
operator|!=
name|IPVERSION
condition|)
block|{
name|m
operator|->
name|b_rptr
operator|-=
name|off
expr_stmt|;
if|if
condition|(
operator|!
name|synced
condition|)
block|{
name|synced
operator|=
literal|1
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
name|ipfsync
argument_list|()
expr_stmt|;
name|READ_ENTER
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
name|frstats
index|[
name|out
index|]
operator|.
name|fr_notip
operator|++
expr_stmt|;
return|return
operator|(
name|fr_flags
operator|&
name|FF_BLOCKNONIP
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
ifndef|#
directive|ifndef
name|sparc
name|__iplen
operator|=
operator|(
name|u_short
operator|)
name|ip
operator|->
name|ip_len
operator|,
name|__ipoff
operator|=
operator|(
name|u_short
operator|)
name|ip
operator|->
name|ip_off
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|ntohs
argument_list|(
name|__iplen
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
name|ntohs
argument_list|(
name|__ipoff
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hlen
operator|=
name|iphlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|iphlen
operator|<
sizeof|sizeof
argument_list|(
name|ip_t
argument_list|)
operator|)
operator|||
operator|(
name|iphlen
operator|>
operator|(
name|u_short
operator|)
name|ip
operator|->
name|ip_len
operator|)
operator|||
operator|(
name|mlen
operator|<
operator|(
name|u_short
operator|)
name|ip
operator|->
name|ip_len
operator|)
condition|)
block|{
comment|/* 		 * Bad IP packet or not enough data/data length mismatches 		 */
ifndef|#
directive|ifndef
name|sparc
name|__iplen
operator|=
operator|(
name|u_short
operator|)
name|ip
operator|->
name|ip_len
operator|,
name|__ipoff
operator|=
operator|(
name|u_short
operator|)
name|ip
operator|->
name|ip_off
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|__iplen
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
name|__ipoff
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m
operator|->
name|b_rptr
operator|-=
name|off
expr_stmt|;
name|frstats
index|[
name|out
index|]
operator|.
name|fr_bad
operator|++
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * Make hlen the total size of the IP header plus TCP/UDP/ICMP header 	 * (if it is one of these three). 	 */
if|if
condition|(
operator|(
name|ip
operator|->
name|ip_off
operator|&
name|IP_OFFMASK
operator|)
operator|==
literal|0
condition|)
switch|switch
condition|(
name|ip
operator|->
name|ip_p
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|hlen
operator|+=
sizeof|sizeof
argument_list|(
name|tcphdr_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|hlen
operator|+=
sizeof|sizeof
argument_list|(
name|udphdr_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_ICMP
case|:
comment|/* 76 bytes is enough for a complete ICMP error. */
name|hlen
operator|+=
literal|76
operator|+
sizeof|sizeof
argument_list|(
name|icmphdr_t
argument_list|)
expr_stmt|;
break|break;
default|default :
break|break;
block|}
if|if
condition|(
name|hlen
operator|>
name|mlen
condition|)
name|hlen
operator|=
name|mlen
expr_stmt|;
comment|/* 	 * If we don't have enough data in the mblk or we haven't yet copied 	 * enough (above), then copy some more. 	 */
if|if
condition|(
operator|(
name|hlen
operator|>
name|len
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|pullupmsg
argument_list|(
name|m
argument_list|,
operator|(
name|int
operator|)
name|hlen
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"pullupmsg failed\n"
argument_list|)
expr_stmt|;
name|frstats
index|[
name|out
index|]
operator|.
name|fr_pull
index|[
literal|1
index|]
operator|++
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|frstats
index|[
name|out
index|]
operator|.
name|fr_pull
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|ip
operator|=
operator|(
name|ip_t
operator|*
operator|)
name|ALIGN32
argument_list|(
name|m
operator|->
name|b_rptr
argument_list|)
expr_stmt|;
block|}
name|qif
operator|->
name|qf_m
operator|=
name|m
expr_stmt|;
name|qif
operator|->
name|qf_q
operator|=
name|q
expr_stmt|;
name|qif
operator|->
name|qf_off
operator|=
name|off
expr_stmt|;
name|qif
operator|->
name|qf_len
operator|=
name|len
expr_stmt|;
name|err
operator|=
name|fr_check
argument_list|(
name|ip
argument_list|,
name|iphlen
argument_list|,
name|qif
operator|->
name|qf_ill
argument_list|,
name|out
argument_list|,
name|qif
argument_list|,
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|2
condition|)
goto|goto
name|fixalign
goto|;
comment|/* 	 * Copy back the ip header data if it was changed, we haven't yet 	 * freed the message and we aren't going to drop the packet. 	 * BUT only do this if there were no changes to the buffer, else 	 * we can't be sure that the ip pointer is still correct! 	 */
if|if
condition|(
operator|*
name|mp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|mp
operator|==
name|mt
condition|)
block|{
name|m
operator|->
name|b_rptr
operator|-=
name|off
expr_stmt|;
ifndef|#
directive|ifndef
name|sparc
name|__iplen
operator|=
operator|(
name|u_short
operator|)
name|ip
operator|->
name|ip_len
operator|,
name|__ipoff
operator|=
operator|(
name|u_short
operator|)
name|ip
operator|->
name|ip_off
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|__iplen
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
name|__ipoff
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"!IP Filter: *mp %p mt %p %s\n"
argument_list|,
operator|*
name|mp
argument_list|,
name|mt
argument_list|,
literal|"mblk changed, cannot revert ip_len, ip_off"
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|fr_qin
parameter_list|(
name|q
parameter_list|,
name|mb
parameter_list|)
name|queue_t
modifier|*
name|q
decl_stmt|;
name|mblk_t
modifier|*
name|mb
decl_stmt|;
block|{
name|int
argument_list|(
argument|*pnext
argument_list|)
name|__P
argument_list|(
operator|(
name|queue_t
operator|*
operator|,
name|mblk_t
operator|*
operator|)
argument_list|)
operator|,
name|type
operator|,
name|synced
operator|=
literal|0
operator|,
name|err
operator|=
literal|0
expr_stmt|;
name|qif_t
name|qf
decl_stmt|,
modifier|*
name|qif
decl_stmt|;
if|if
condition|(
name|fr_running
operator|<=
literal|0
condition|)
block|{
name|mb
operator|->
name|b_prev
operator|=
name|NULL
expr_stmt|;
name|freemsg
argument_list|(
name|mb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|READ_ENTER
argument_list|(
operator|&
name|ipf_solaris
argument_list|)
expr_stmt|;
name|again
label|:
if|if
condition|(
name|fr_running
operator|<=
literal|0
condition|)
block|{
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_solaris
argument_list|)
expr_stmt|;
name|mb
operator|->
name|b_prev
operator|=
name|NULL
expr_stmt|;
name|freemsg
argument_list|(
name|mb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|READ_ENTER
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|qif
operator|=
name|qif_from_queue
argument_list|(
name|q
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|qif
operator|=
name|qif_head
init|;
name|qif
condition|;
name|qif
operator|=
name|qif
operator|->
name|qf_next
control|)
if|if
condition|(
operator|&
name|qif
operator|->
name|qf_rqinit
operator|==
name|q
operator|->
name|q_qinfo
operator|&&
name|qif
operator|->
name|qf_rqinfo
operator|&&
name|qif
operator|->
name|qf_rqinfo
operator|->
name|qi_putp
condition|)
block|{
name|pnext
operator|=
name|qif
operator|->
name|qf_rqinfo
operator|->
name|qi_putp
expr_stmt|;
name|frstats
index|[
literal|0
index|]
operator|.
name|fr_notip
operator|++
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|synced
condition|)
block|{
name|ipfsync
argument_list|()
expr_stmt|;
name|synced
operator|=
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_solaris
argument_list|)
expr_stmt|;
comment|/* fr_donotip(0, NULL, q, mb, mb, NULL, 0); */
return|return
call|(
modifier|*
name|pnext
call|)
argument_list|(
name|q
argument_list|,
name|mb
argument_list|)
return|;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|synced
condition|)
block|{
name|ipfsync
argument_list|()
expr_stmt|;
name|synced
operator|=
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"!IP Filter: dropped: fr_qin(%x,%x): type %x qif %x"
argument_list|,
name|q
argument_list|,
name|mb
argument_list|,
name|MTYPE
argument_list|(
name|mb
argument_list|)
argument_list|,
name|qif
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"!IP Filter: info %x next %x ptr %x fsrv %x bsrv %x\n"
argument_list|,
name|q
operator|->
name|q_qinfo
argument_list|,
name|q
operator|->
name|q_next
argument_list|,
name|q
operator|->
name|q_ptr
argument_list|,
name|q
operator|->
name|q_nfsrv
argument_list|,
name|q
operator|->
name|q_nbsrv
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"!IP Filter: info: putp %x srvp %x info %x\n"
argument_list|,
name|q
operator|->
name|q_qinfo
operator|->
name|qi_putp
argument_list|,
name|q
operator|->
name|q_qinfo
operator|->
name|qi_srvp
argument_list|,
if|#
directive|if
name|SOLARIS
operator|>
literal|3
name|q
operator|->
name|q_qinfo
operator|->
name|qi_infop
else|#
directive|else
literal|0
endif|#
directive|endif
argument_list|)
expr_stmt|;
name|frstats
index|[
literal|0
index|]
operator|.
name|fr_drop
operator|++
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_solaris
argument_list|)
expr_stmt|;
name|mb
operator|->
name|b_prev
operator|=
name|NULL
expr_stmt|;
name|freemsg
argument_list|(
name|mb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qif
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|qf
argument_list|,
sizeof|sizeof
argument_list|(
name|qf
argument_list|)
argument_list|)
expr_stmt|;
name|qif
operator|=
operator|&
name|qf
expr_stmt|;
name|type
operator|=
name|MTYPE
argument_list|(
name|mb
argument_list|)
expr_stmt|;
name|pnext
operator|=
name|qif
operator|->
name|qf_rqinfo
operator|->
name|qi_putp
expr_stmt|;
if|if
condition|(
name|datamsg
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|type
operator|==
name|M_BREAK
operator|)
condition|)
name|err
operator|=
name|fr_precheck
argument_list|(
operator|&
name|mb
argument_list|,
name|q
argument_list|,
name|qif
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_solaris
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|==
literal|0
operator|)
operator|&&
operator|(
name|mb
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|pnext
condition|)
return|return
call|(
modifier|*
name|pnext
call|)
argument_list|(
name|q
argument_list|,
name|mb
argument_list|)
return|;
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"!IP Filter: inp NULL: qif %x q %x info %x"
argument_list|,
name|qif
argument_list|,
name|q
argument_list|,
name|q
operator|->
name|q_qinfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mb
condition|)
block|{
name|mb
operator|->
name|b_prev
operator|=
name|NULL
expr_stmt|;
name|freemsg
argument_list|(
name|mb
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|fr_qout
parameter_list|(
name|q
parameter_list|,
name|mb
parameter_list|)
name|queue_t
modifier|*
name|q
decl_stmt|;
name|mblk_t
modifier|*
name|mb
decl_stmt|;
block|{
name|int
argument_list|(
argument|*pnext
argument_list|)
name|__P
argument_list|(
operator|(
name|queue_t
operator|*
operator|,
name|mblk_t
operator|*
operator|)
argument_list|)
operator|,
name|type
operator|,
name|synced
operator|=
literal|0
operator|,
name|err
operator|=
literal|0
expr_stmt|;
name|qif_t
name|qf
decl_stmt|,
modifier|*
name|qif
decl_stmt|;
if|if
condition|(
name|fr_running
operator|<=
literal|0
condition|)
block|{
name|mb
operator|->
name|b_prev
operator|=
name|NULL
expr_stmt|;
name|freemsg
argument_list|(
name|mb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|READ_ENTER
argument_list|(
operator|&
name|ipf_solaris
argument_list|)
expr_stmt|;
name|again
label|:
if|if
condition|(
name|fr_running
operator|<=
literal|0
condition|)
block|{
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_solaris
argument_list|)
expr_stmt|;
name|mb
operator|->
name|b_prev
operator|=
name|NULL
expr_stmt|;
name|freemsg
argument_list|(
name|mb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|READ_ENTER
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|qif
operator|=
name|qif_from_queue
argument_list|(
name|q
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|qif
operator|=
name|qif_head
init|;
name|qif
condition|;
name|qif
operator|=
name|qif
operator|->
name|qf_next
control|)
if|if
condition|(
operator|&
name|qif
operator|->
name|qf_wqinit
operator|==
name|q
operator|->
name|q_qinfo
operator|&&
name|qif
operator|->
name|qf_wqinfo
operator|&&
name|qif
operator|->
name|qf_wqinfo
operator|->
name|qi_putp
condition|)
block|{
name|pnext
operator|=
name|qif
operator|->
name|qf_wqinfo
operator|->
name|qi_putp
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
name|frstats
index|[
literal|1
index|]
operator|.
name|fr_notip
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|synced
condition|)
block|{
name|ipfsync
argument_list|()
expr_stmt|;
name|synced
operator|=
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* fr_donotip(0, NULL, q, mb, mb, NULL, 0); */
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_solaris
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|pnext
call|)
argument_list|(
name|q
argument_list|,
name|mb
argument_list|)
return|;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|synced
condition|)
block|{
name|ipfsync
argument_list|()
expr_stmt|;
name|synced
operator|=
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"!IP Filter: dropped: fr_qout(%x,%x): type %x: qif %x"
argument_list|,
name|q
argument_list|,
name|mb
argument_list|,
name|MTYPE
argument_list|(
name|mb
argument_list|)
argument_list|,
name|qif
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"!IP Filter: info %x next %x ptr %x fsrv %x bsrv %x\n"
argument_list|,
name|q
operator|->
name|q_qinfo
argument_list|,
name|q
operator|->
name|q_next
argument_list|,
name|q
operator|->
name|q_ptr
argument_list|,
name|q
operator|->
name|q_nfsrv
argument_list|,
name|q
operator|->
name|q_nbsrv
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"!IP Filter: info: putp %x srvp %x info %x\n"
argument_list|,
name|q
operator|->
name|q_qinfo
operator|->
name|qi_putp
argument_list|,
name|q
operator|->
name|q_qinfo
operator|->
name|qi_srvp
argument_list|,
if|#
directive|if
name|SOLARIS
operator|>
literal|3
name|q
operator|->
name|q_qinfo
operator|->
name|qi_infop
else|#
directive|else
literal|0
endif|#
directive|endif
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|q_nfsrv
condition|)
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"!IP Filter: nfsrv: info %x next %x ptr %x\n"
argument_list|,
name|q
operator|->
name|q_nfsrv
operator|->
name|q_qinfo
argument_list|,
name|q
operator|->
name|q_nfsrv
operator|->
name|q_next
argument_list|,
name|q
operator|->
name|q_nfsrv
operator|->
name|q_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|q_nbsrv
condition|)
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"!IP Filter: nbsrv: info %x next %x ptr %x\n"
argument_list|,
name|q
operator|->
name|q_nbsrv
operator|->
name|q_qinfo
argument_list|,
name|q
operator|->
name|q_nbsrv
operator|->
name|q_next
argument_list|,
name|q
operator|->
name|q_nbsrv
operator|->
name|q_ptr
argument_list|)
expr_stmt|;
name|frstats
index|[
literal|1
index|]
operator|.
name|fr_drop
operator|++
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_solaris
argument_list|)
expr_stmt|;
name|mb
operator|->
name|b_prev
operator|=
name|NULL
expr_stmt|;
name|freemsg
argument_list|(
name|mb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qif
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|qf
argument_list|,
sizeof|sizeof
argument_list|(
name|qf
argument_list|)
argument_list|)
expr_stmt|;
name|qif
operator|=
operator|&
name|qf
expr_stmt|;
name|type
operator|=
name|MTYPE
argument_list|(
name|mb
argument_list|)
expr_stmt|;
name|pnext
operator|=
name|qif
operator|->
name|qf_wqinfo
operator|->
name|qi_putp
expr_stmt|;
if|if
condition|(
name|datamsg
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|type
operator|==
name|M_BREAK
operator|)
condition|)
name|err
operator|=
name|fr_precheck
argument_list|(
operator|&
name|mb
argument_list|,
name|q
argument_list|,
name|qif
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_solaris
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|==
literal|0
operator|)
operator|&&
operator|(
name|mb
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|pnext
condition|)
return|return
call|(
modifier|*
name|pnext
call|)
argument_list|(
name|q
argument_list|,
name|mb
argument_list|)
return|;
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"!IP Filter: outp NULL: qif %x %s q %x info %x"
argument_list|,
name|qif
argument_list|,
name|qif
operator|->
name|qf_name
argument_list|,
name|q
argument_list|,
name|q
operator|->
name|q_qinfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mb
condition|)
block|{
name|mb
operator|->
name|b_prev
operator|=
name|NULL
expr_stmt|;
name|freemsg
argument_list|(
name|mb
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ipf_synctimeout
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|READ_ENTER
argument_list|(
operator|&
name|ipf_solaris
argument_list|)
expr_stmt|;
name|ipfsync
argument_list|()
expr_stmt|;
name|WRITE_ENTER
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
name|synctimeoutid
operator|=
literal|0
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_solaris
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ipf_ip_qin
parameter_list|(
name|q
parameter_list|,
name|mb
parameter_list|)
name|queue_t
modifier|*
name|q
decl_stmt|;
name|mblk_t
modifier|*
name|mb
decl_stmt|;
block|{
name|struct
name|iocblk
modifier|*
name|ioc
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|fr_running
operator|<=
literal|0
condition|)
block|{
name|mb
operator|->
name|b_prev
operator|=
name|NULL
expr_stmt|;
name|freemsg
argument_list|(
name|mb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|MTYPE
argument_list|(
name|mb
argument_list|)
operator|!=
name|M_IOCTL
condition|)
return|return
call|(
modifier|*
name|ipf_ip_inp
call|)
argument_list|(
name|q
argument_list|,
name|mb
argument_list|)
return|;
name|READ_ENTER
argument_list|(
operator|&
name|ipf_solaris
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr_running
operator|<=
literal|0
condition|)
block|{
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_solaris
argument_list|)
expr_stmt|;
name|mb
operator|->
name|b_prev
operator|=
name|NULL
expr_stmt|;
name|freemsg
argument_list|(
name|mb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ioc
operator|=
operator|(
expr|struct
name|iocblk
operator|*
operator|)
name|mb
operator|->
name|b_rptr
expr_stmt|;
switch|switch
condition|(
name|ioc
operator|->
name|ioc_cmd
condition|)
block|{
case|case
name|I_LINK
case|:
case|case
name|I_UNLINK
case|:
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCSIFFLAGS
case|:
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: ipf_ip_qin() M_IOCTL type=0x%x\n"
argument_list|,
name|ioc
operator|->
name|ioc_cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|WRITE_ENTER
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|synctimeoutid
operator|==
literal|0
condition|)
block|{
name|synctimeoutid
operator|=
name|timeout
argument_list|(
name|ipf_synctimeout
argument_list|,
name|NULL
argument_list|,
name|drv_usectohz
argument_list|(
literal|1000000
argument_list|)
comment|/*1 sec*/
argument_list|)
expr_stmt|;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_solaris
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|ipf_ip_inp
call|)
argument_list|(
name|q
argument_list|,
name|mb
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|ipdrvattcnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|streamtab
name|ipinfo
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|solipdrvattach
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: solipdrvattach() %d ipinfo=0x%lx\n"
argument_list|,
name|ipdrvattcnt
argument_list|,
operator|&
name|ipinfo
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|++
name|ipdrvattcnt
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|ipf_ip_inp
operator|==
name|NULL
condition|)
block|{
name|ipf_ip_inp
operator|=
name|ipinfo
operator|.
name|st_wrinit
operator|->
name|qi_putp
expr_stmt|;
name|ipinfo
operator|.
name|st_wrinit
operator|->
name|qi_putp
operator|=
name|ipf_ip_qin
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|solipdrvdetach
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: solipdrvdetach() %d ipinfo=0x%lx\n"
argument_list|,
name|ipdrvattcnt
argument_list|,
operator|&
name|ipinfo
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|WRITE_ENTER
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|ipdrvattcnt
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|ipf_ip_inp
operator|&&
operator|(
name|ipinfo
operator|.
name|st_wrinit
operator|->
name|qi_putp
operator|==
name|ipf_ip_qin
operator|)
condition|)
block|{
name|ipinfo
operator|.
name|st_wrinit
operator|->
name|qi_putp
operator|=
name|ipf_ip_inp
expr_stmt|;
name|ipf_ip_inp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|synctimeoutid
condition|)
block|{
name|untimeout
argument_list|(
name|synctimeoutid
argument_list|)
expr_stmt|;
name|synctimeoutid
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
return|return
name|ipdrvattcnt
return|;
block|}
end_function

begin_comment
comment|/*  * attach the packet filter to each interface that is defined as having an  * IP address associated with it and save some of the info. for that struct  * so we're not out of date as soon as the ill disappears - but we must sync  * to be correct!  */
end_comment

begin_function
name|void
name|solattach
parameter_list|()
block|{
name|queue_t
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|;
name|struct
name|frentry
modifier|*
name|f
decl_stmt|;
name|qif_t
modifier|*
name|qif
decl_stmt|,
modifier|*
name|qf2
decl_stmt|;
name|ipnat_t
modifier|*
name|np
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|ill_t
modifier|*
name|il
decl_stmt|;
for|for
control|(
name|il
operator|=
name|ill_g_head
init|;
name|il
condition|;
name|il
operator|=
name|il
operator|->
name|ill_next
control|)
block|{
name|in
operator|=
name|il
operator|->
name|ill_rq
expr_stmt|;
if|if
condition|(
operator|!
name|in
operator|||
operator|!
name|il
operator|->
name|ill_wq
condition|)
continue|continue;
if|#
directive|if
name|SOLARIS2
operator|>=
literal|8
if|if
condition|(
name|il
operator|->
name|ill_isv6
condition|)
continue|continue;
endif|#
directive|endif
name|out
operator|=
name|il
operator|->
name|ill_wq
operator|->
name|q_next
expr_stmt|;
name|WRITE_ENTER
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
comment|/* 		 * Look for entry already setup for this device 		 */
for|for
control|(
name|qif
operator|=
name|qif_head
init|;
name|qif
condition|;
name|qif
operator|=
name|qif
operator|->
name|qf_next
control|)
if|if
condition|(
name|qif
operator|->
name|qf_iptr
operator|==
name|in
operator|->
name|q_ptr
operator|&&
name|qif
operator|->
name|qf_optr
operator|==
name|out
operator|->
name|q_ptr
condition|)
break|break;
if|if
condition|(
name|qif
condition|)
block|{
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: il %x ipt %x opt %x ipu %x opu %x i %x/%x"
argument_list|,
name|il
argument_list|,
name|in
operator|->
name|q_ptr
argument_list|,
name|out
operator|->
name|q_ptr
argument_list|,
name|in
operator|->
name|q_qinfo
operator|->
name|qi_putp
argument_list|,
name|out
operator|->
name|q_qinfo
operator|->
name|qi_putp
argument_list|,
name|out
operator|->
name|q_qinfo
argument_list|,
name|in
operator|->
name|q_qinfo
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KMALLOC
argument_list|(
name|qif
argument_list|,
name|qif_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qif
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"IP Filter: malloc(%d) for qif_t failed\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|qif_t
argument_list|)
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|in
operator|->
name|q_qinfo
operator|->
name|qi_putp
operator|==
name|fr_qin
condition|)
block|{
for|for
control|(
name|qf2
operator|=
name|qif_head
init|;
name|qf2
condition|;
name|qf2
operator|=
name|qf2
operator|->
name|qf_next
control|)
if|if
condition|(
operator|&
name|qf2
operator|->
name|qf_rqinit
operator|==
name|in
operator|->
name|q_qinfo
condition|)
block|{
name|qif
operator|->
name|qf_rqinfo
operator|=
name|qf2
operator|->
name|qf_rqinfo
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|qf2
condition|)
block|{
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"IP Filter: rq:%s put %x qi %x"
argument_list|,
name|il
operator|->
name|ill_name
argument_list|,
name|in
operator|->
name|q_qinfo
operator|->
name|qi_putp
argument_list|,
name|in
operator|->
name|q_qinfo
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|qif
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
name|qif
operator|->
name|qf_rqinfo
operator|=
name|in
operator|->
name|q_qinfo
expr_stmt|;
if|if
condition|(
name|out
operator|->
name|q_qinfo
operator|->
name|qi_putp
operator|==
name|fr_qout
condition|)
block|{
for|for
control|(
name|qf2
operator|=
name|qif_head
init|;
name|qf2
condition|;
name|qf2
operator|=
name|qf2
operator|->
name|qf_next
control|)
if|if
condition|(
operator|&
name|qf2
operator|->
name|qf_wqinit
operator|==
name|out
operator|->
name|q_qinfo
condition|)
block|{
name|qif
operator|->
name|qf_wqinfo
operator|=
name|qf2
operator|->
name|qf_wqinfo
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|qf2
condition|)
block|{
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"IP Filter: wq:%s put %x qi %x"
argument_list|,
name|il
operator|->
name|ill_name
argument_list|,
name|out
operator|->
name|q_qinfo
operator|->
name|qi_putp
argument_list|,
name|out
operator|->
name|q_qinfo
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|qif
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
name|qif
operator|->
name|qf_wqinfo
operator|=
name|out
operator|->
name|q_qinfo
expr_stmt|;
name|qif
operator|->
name|qf_ill
operator|=
name|il
expr_stmt|;
name|qif
operator|->
name|qf_in
operator|=
name|in
expr_stmt|;
name|qif
operator|->
name|qf_out
operator|=
name|out
expr_stmt|;
name|qif
operator|->
name|qf_iptr
operator|=
name|in
operator|->
name|q_ptr
expr_stmt|;
name|qif
operator|->
name|qf_optr
operator|=
name|out
operator|->
name|q_ptr
expr_stmt|;
if|#
directive|if
name|SOLARIS2
operator|<
literal|8
name|qif
operator|->
name|qf_hl
operator|=
name|il
operator|->
name|ill_hdr_length
expr_stmt|;
else|#
directive|else
block|{
name|ire_t
modifier|*
name|ire
decl_stmt|;
name|mblk_t
modifier|*
name|m
decl_stmt|;
name|qif
operator|->
name|qf_hl
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 		 * Can't seem to lookup a route for the IP address on the 		 * interface itself. 		 */
block|ire = ire_route_lookup(il->ill_ipif->ipif_lcl_addr, 0xffffffff, 					0, 0, NULL, NULL, NULL, 					MATCH_IRE_DSTONLY|MATCH_IRE_RECURSIVE); 		if ((ire != NULL)&& (m = ire->ire_fp_mp)) 			qif->qf_hl = m->b_wptr - m->b_rptr;
endif|#
directive|endif
if|if
condition|(
operator|(
name|qif
operator|->
name|qf_hl
operator|==
literal|0
operator|)
operator|&&
operator|(
name|il
operator|->
name|ill_type
operator|>
literal|0
operator|)
operator|&&
operator|(
name|il
operator|->
name|ill_type
operator|<
literal|0x37
operator|)
operator|&&
operator|(
name|hdrsizes
index|[
name|il
operator|->
name|ill_type
index|]
index|[
literal|0
index|]
operator|==
name|il
operator|->
name|ill_type
operator|)
condition|)
name|qif
operator|->
name|qf_hl
operator|=
name|hdrsizes
index|[
name|il
operator|->
name|ill_type
index|]
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|qif
operator|->
name|qf_hl
operator|==
literal|0
condition|)
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"Unknown layer 2 header size for %s type %d\n"
argument_list|,
name|qif
operator|->
name|qf_name
argument_list|,
name|il
operator|->
name|ill_type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|strncpy
argument_list|(
name|qif
operator|->
name|qf_name
argument_list|,
name|il
operator|->
name|ill_name
argument_list|,
sizeof|sizeof
argument_list|(
name|qif
operator|->
name|qf_name
argument_list|)
argument_list|)
expr_stmt|;
name|qif
operator|->
name|qf_name
index|[
sizeof|sizeof
argument_list|(
name|qif
operator|->
name|qf_name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|qif
operator|->
name|qf_next
operator|=
name|qif_head
expr_stmt|;
name|qif_head
operator|=
name|qif
expr_stmt|;
comment|/* 		 * Activate any rules directly associated with this interface 		 */
name|WRITE_ENTER
argument_list|(
operator|&
name|ipf_mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
name|ipfilter
index|[
literal|0
index|]
index|[
name|fr_active
index|]
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
operator|(
name|f
operator|->
name|fr_ifa
operator|==
operator|(
expr|struct
name|ifnet
operator|*
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|f
operator|->
name|fr_ifname
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|len
operator|==
operator|(
name|size_t
operator|)
name|il
operator|->
name|ill_name_length
operator|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|il
operator|->
name|ill_name
argument_list|,
name|f
operator|->
name|fr_ifname
argument_list|,
name|len
argument_list|)
condition|)
name|f
operator|->
name|fr_ifa
operator|=
name|il
expr_stmt|;
block|}
block|}
for|for
control|(
name|f
operator|=
name|ipfilter
index|[
literal|1
index|]
index|[
name|fr_active
index|]
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
operator|(
name|f
operator|->
name|fr_ifa
operator|==
operator|(
expr|struct
name|ifnet
operator|*
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|f
operator|->
name|fr_ifname
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|len
operator|==
operator|(
name|size_t
operator|)
name|il
operator|->
name|ill_name_length
operator|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|il
operator|->
name|ill_name
argument_list|,
name|f
operator|->
name|fr_ifname
argument_list|,
name|len
argument_list|)
condition|)
name|f
operator|->
name|fr_ifa
operator|=
name|il
expr_stmt|;
block|}
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_mutex
argument_list|)
expr_stmt|;
name|WRITE_ENTER
argument_list|(
operator|&
name|ipf_nat
argument_list|)
expr_stmt|;
for|for
control|(
name|np
operator|=
name|nat_list
init|;
name|np
condition|;
name|np
operator|=
name|np
operator|->
name|in_next
control|)
block|{
if|if
condition|(
operator|(
name|np
operator|->
name|in_ifp
operator|==
operator|(
expr|struct
name|ifnet
operator|*
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|np
operator|->
name|in_ifname
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|len
operator|==
operator|(
name|size_t
operator|)
name|il
operator|->
name|ill_name_length
operator|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|il
operator|->
name|ill_name
argument_list|,
name|np
operator|->
name|in_ifname
argument_list|,
name|len
argument_list|)
condition|)
name|np
operator|->
name|in_ifp
operator|=
name|il
expr_stmt|;
block|}
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_nat
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|qif
operator|->
name|qf_rqinfo
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|qif
operator|->
name|qf_rqinit
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|qinit
argument_list|)
argument_list|)
expr_stmt|;
name|qif
operator|->
name|qf_rqinit
operator|.
name|qi_putp
operator|=
name|fr_qin
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: solattach: in queue(%lx)->q_qinfo FROM %lx TO %lx"
argument_list|,
name|in
argument_list|,
name|in
operator|->
name|q_qinfo
argument_list|,
operator|&
name|qif
operator|->
name|qf_rqinit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|in
operator|->
name|q_qinfo
operator|=
operator|&
name|qif
operator|->
name|qf_rqinit
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|qif
operator|->
name|qf_wqinfo
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|qif
operator|->
name|qf_wqinit
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|qinit
argument_list|)
argument_list|)
expr_stmt|;
name|qif
operator|->
name|qf_wqinit
operator|.
name|qi_putp
operator|=
name|fr_qout
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: solattach: out queue(%lx)->q_qinfo FROM %lx TO %lx"
argument_list|,
name|out
argument_list|,
name|out
operator|->
name|q_qinfo
argument_list|,
operator|&
name|qif
operator|->
name|qf_wqinit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|out
operator|->
name|q_qinfo
operator|=
operator|&
name|qif
operator|->
name|qf_wqinit
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"IP Filter: attach to [%s,%d]\n"
argument_list|,
name|qif
operator|->
name|qf_name
argument_list|,
name|il
operator|->
name|ill_ppa
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|qif_head
condition|)
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"IP Filter: not attached to any interfaces\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * look for bad consistancies between the list of interfaces the filter knows  * about and those which are currently configured.  */
end_comment

begin_function
name|int
name|ipfsync
parameter_list|()
block|{
specifier|register
name|struct
name|frentry
modifier|*
name|f
decl_stmt|;
specifier|register
name|ipnat_t
modifier|*
name|np
decl_stmt|;
specifier|register
name|qif_t
modifier|*
name|qif
decl_stmt|,
modifier|*
modifier|*
name|qp
decl_stmt|;
specifier|register
name|ill_t
modifier|*
name|il
decl_stmt|;
name|queue_t
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|;
name|WRITE_ENTER
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|qp
operator|=
operator|&
name|qif_head
init|;
operator|(
name|qif
operator|=
operator|*
name|qp
operator|)
condition|;
control|)
block|{
for|for
control|(
name|il
operator|=
name|ill_g_head
init|;
name|il
condition|;
name|il
operator|=
name|il
operator|->
name|ill_next
control|)
if|if
condition|(
operator|(
name|qif
operator|->
name|qf_ill
operator|==
name|il
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|qif
operator|->
name|qf_name
argument_list|,
name|il
operator|->
name|ill_name
argument_list|)
condition|)
block|{
if|#
directive|if
name|SOLARIS2
operator|<
literal|8
name|mblk_t
modifier|*
name|m
init|=
name|il
operator|->
name|ill_hdr_mp
decl_stmt|;
name|qif
operator|->
name|qf_hl
operator|=
name|il
operator|->
name|ill_hdr_length
expr_stmt|;
if|if
condition|(
name|m
operator|&&
name|qif
operator|->
name|qf_hl
operator|!=
operator|(
name|m
operator|->
name|b_wptr
operator|-
name|m
operator|->
name|b_rptr
operator|)
condition|)
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: ILL Header Length Mismatch\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|il
condition|)
block|{
name|qp
operator|=
operator|&
name|qif
operator|->
name|qf_next
expr_stmt|;
continue|continue;
block|}
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"IP Filter: detaching [%s]\n"
argument_list|,
name|qif
operator|->
name|qf_name
argument_list|)
expr_stmt|;
operator|*
name|qp
operator|=
name|qif
operator|->
name|qf_next
expr_stmt|;
comment|/* 		 * Disable any rules directly associated with this interface 		 */
name|WRITE_ENTER
argument_list|(
operator|&
name|ipf_nat
argument_list|)
expr_stmt|;
for|for
control|(
name|np
operator|=
name|nat_list
init|;
name|np
condition|;
name|np
operator|=
name|np
operator|->
name|in_next
control|)
if|if
condition|(
name|np
operator|->
name|in_ifp
operator|==
operator|(
name|void
operator|*
operator|)
name|qif
operator|->
name|qf_ill
condition|)
name|np
operator|->
name|in_ifp
operator|=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_nat
argument_list|)
expr_stmt|;
name|WRITE_ENTER
argument_list|(
operator|&
name|ipf_mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
name|ipfilter
index|[
literal|0
index|]
index|[
name|fr_active
index|]
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|fr_next
control|)
if|if
condition|(
name|f
operator|->
name|fr_ifa
operator|==
operator|(
name|void
operator|*
operator|)
name|qif
operator|->
name|qf_ill
condition|)
name|f
operator|->
name|fr_ifa
operator|=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|f
operator|=
name|ipfilter
index|[
literal|1
index|]
index|[
name|fr_active
index|]
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|fr_next
control|)
if|if
condition|(
name|f
operator|->
name|fr_ifa
operator|==
operator|(
name|void
operator|*
operator|)
name|qif
operator|->
name|qf_ill
condition|)
name|f
operator|->
name|fr_ifa
operator|=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX */
comment|/* 		 * As well as the ill disappearing when a device is unplumb'd, 		 * it also appears that the associated queue structures also 		 * disappear - at least in the case of ppp, which is the most 		 * volatile here.  Thanks to Greg for finding this problem. 		 */
comment|/* 		 * Restore q_qinfo pointers in interface queues 		 */
block|out = qif->qf_out; 		in = qif->qf_in; 		if (in) {
ifdef|#
directive|ifdef
name|IPFDEBUG
block|cmn_err(CE_NOTE, 				"IP Filter: ipfsync: in queue(%lx)->q_qinfo FROM %lx TO %lx", 				in, in->q_qinfo, qif->qf_rqinfo 				);
endif|#
directive|endif
block|in->q_qinfo = qif->qf_rqinfo; 		} 		if (out) {
ifdef|#
directive|ifdef
name|IPFDEBUG
block|cmn_err(CE_NOTE, 				"IP Filter: ipfsync: out queue(%lx)->q_qinfo FROM %lx TO %lx", 				out, out->q_qinfo, qif->qf_wqinfo 				);
endif|#
directive|endif
block|out->q_qinfo = qif->qf_wqinfo; 		}
endif|#
directive|endif
comment|/* XXX */
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_mutex
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|qif
argument_list|)
expr_stmt|;
name|qif
operator|=
operator|*
name|qp
expr_stmt|;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
name|solattach
argument_list|()
expr_stmt|;
name|frsync
argument_list|()
expr_stmt|;
comment|/* 	 * Resync. any NAT `connections' using this interface and its IP #. 	 */
for|for
control|(
name|il
operator|=
name|ill_g_head
init|;
name|il
condition|;
name|il
operator|=
name|il
operator|->
name|ill_next
control|)
name|ip_natsync
argument_list|(
operator|(
name|void
operator|*
operator|)
name|il
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * unhook the IP filter from all defined interfaces with IP addresses  */
end_comment

begin_function
name|int
name|soldetach
parameter_list|()
block|{
name|queue_t
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|;
name|qif_t
modifier|*
name|qif
decl_stmt|,
modifier|*
modifier|*
name|qp
decl_stmt|;
name|ill_t
modifier|*
name|il
decl_stmt|;
name|WRITE_ENTER
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
comment|/* 	 * Make two passes, first get rid of all the unknown devices, next 	 * unlink known devices. 	 */
for|for
control|(
name|qp
operator|=
operator|&
name|qif_head
init|;
operator|(
name|qif
operator|=
operator|*
name|qp
operator|)
condition|;
control|)
block|{
for|for
control|(
name|il
operator|=
name|ill_g_head
init|;
name|il
condition|;
name|il
operator|=
name|il
operator|->
name|ill_next
control|)
if|if
condition|(
name|qif
operator|->
name|qf_ill
operator|==
name|il
condition|)
break|break;
if|if
condition|(
name|il
condition|)
block|{
name|qp
operator|=
operator|&
name|qif
operator|->
name|qf_next
expr_stmt|;
continue|continue;
block|}
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"IP Filter: removing [%s]\n"
argument_list|,
name|qif
operator|->
name|qf_name
argument_list|)
expr_stmt|;
operator|*
name|qp
operator|=
name|qif
operator|->
name|qf_next
expr_stmt|;
name|KFREE
argument_list|(
name|qif
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|qif
operator|=
name|qif_head
operator|)
condition|)
block|{
name|qif_head
operator|=
name|qif
operator|->
name|qf_next
expr_stmt|;
for|for
control|(
name|il
operator|=
name|ill_g_head
init|;
name|il
condition|;
name|il
operator|=
name|il
operator|->
name|ill_next
control|)
if|if
condition|(
name|qif
operator|->
name|qf_ill
operator|==
name|il
condition|)
break|break;
if|if
condition|(
name|il
condition|)
block|{
name|in
operator|=
name|qif
operator|->
name|qf_in
expr_stmt|;
name|out
operator|=
name|qif
operator|->
name|qf_out
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"IP Filter: detaching [%s,%d]\n"
argument_list|,
name|qif
operator|->
name|qf_name
argument_list|,
name|il
operator|->
name|ill_ppa
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: soldetach: in queue(%lx)->q_qinfo FROM %lx TO %lx"
argument_list|,
name|in
argument_list|,
name|in
operator|->
name|q_qinfo
argument_list|,
name|qif
operator|->
name|qf_rqinfo
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|in
operator|->
name|q_qinfo
operator|=
name|qif
operator|->
name|qf_rqinfo
expr_stmt|;
comment|/* 			 * and the write queue... 			 */
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: soldetach: out queue(%lx)->q_qinfo FROM %lx TO %lx"
argument_list|,
name|out
argument_list|,
name|out
operator|->
name|q_qinfo
argument_list|,
name|qif
operator|->
name|qf_wqinfo
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|out
operator|->
name|q_qinfo
operator|=
name|qif
operator|->
name|qf_wqinfo
expr_stmt|;
block|}
name|KFREE
argument_list|(
name|qif
argument_list|)
expr_stmt|;
block|}
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
return|return
name|ipldetach
argument_list|()
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IPFDEBUG
end_ifdef

begin_function
name|void
name|printire
parameter_list|(
name|ire
parameter_list|)
name|ire_t
modifier|*
name|ire
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"ire: ll_hdr_mp %p rfq %p stq %p src_addr %x max_frag %d\n"
argument_list|,
name|ire
operator|->
name|ire_ll_hdr_mp
argument_list|,
name|ire
operator|->
name|ire_rfq
argument_list|,
name|ire
operator|->
name|ire_stq
argument_list|,
name|ire
operator|->
name|ire_src_addr
argument_list|,
name|ire
operator|->
name|ire_max_frag
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ire: mask %x addr %x gateway_addr %x type %d\n"
argument_list|,
name|ire
operator|->
name|ire_mask
argument_list|,
name|ire
operator|->
name|ire_addr
argument_list|,
name|ire
operator|->
name|ire_gateway_addr
argument_list|,
name|ire
operator|->
name|ire_type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ire: ll_hdr_length %d ll_hdr_saved_mp %p\n"
argument_list|,
name|ire
operator|->
name|ire_ll_hdr_length
argument_list|,
name|ire
operator|->
name|ire_ll_hdr_saved_mp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|ipfr_fastroute
parameter_list|(
name|qf
parameter_list|,
name|ip
parameter_list|,
name|mb
parameter_list|,
name|mpp
parameter_list|,
name|fin
parameter_list|,
name|fdp
parameter_list|)
name|qif_t
modifier|*
name|qf
decl_stmt|;
name|ip_t
modifier|*
name|ip
decl_stmt|;
name|mblk_t
modifier|*
name|mb
decl_stmt|,
decl|*
modifier|*
name|mpp
decl_stmt|;
end_function

begin_decl_stmt
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|frdest_t
modifier|*
name|fdp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ire_t
modifier|*
name|ir
decl_stmt|,
modifier|*
name|dir
decl_stmt|,
modifier|*
name|gw
decl_stmt|;
name|struct
name|in_addr
name|dst
decl_stmt|;
name|queue_t
modifier|*
name|q
init|=
name|NULL
decl_stmt|;
name|mblk_t
modifier|*
name|mp
init|=
name|NULL
decl_stmt|;
name|size_t
name|hlen
init|=
literal|0
decl_stmt|;
name|frentry_t
modifier|*
name|fr
decl_stmt|;
name|ill_t
modifier|*
name|ifp
decl_stmt|;
name|u_char
modifier|*
name|s
decl_stmt|;
ifndef|#
directive|ifndef
name|sparc
name|u_short
name|__iplen
decl_stmt|,
name|__ipoff
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * If this is a duplicate mblk then we want ip to point at that 	 * data, not the original, if and only if it is already pointing at 	 * the current mblk data. 	 */
if|if
condition|(
name|ip
operator|==
operator|(
name|ip_t
operator|*
operator|)
name|qf
operator|->
name|qf_m
operator|->
name|b_rptr
operator|&&
name|qf
operator|->
name|qf_m
operator|!=
name|mb
condition|)
name|ip
operator|=
operator|(
name|ip_t
operator|*
operator|)
name|mb
operator|->
name|b_rptr
expr_stmt|;
comment|/* 	 * If there is another M_PROTO, we don't want it 	 */
if|if
condition|(
operator|*
name|mpp
operator|!=
name|mb
condition|)
block|{
operator|(
operator|*
name|mpp
operator|)
operator|->
name|b_cont
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|mpp
operator|)
operator|->
name|b_prev
operator|=
name|NULL
expr_stmt|;
name|freemsg
argument_list|(
operator|*
name|mpp
argument_list|)
expr_stmt|;
block|}
name|ir
operator|=
operator|(
name|ire_t
operator|*
operator|)
name|fdp
operator|->
name|fd_ifp
expr_stmt|;
if|if
condition|(
name|fdp
operator|->
name|fd_ip
operator|.
name|s_addr
condition|)
name|dst
operator|=
name|fdp
operator|->
name|fd_ip
expr_stmt|;
else|else
name|dst
operator|=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_dst
expr_stmt|;
if|#
directive|if
name|SOLARIS2
operator|>=
literal|6
name|gw
operator|=
name|NULL
expr_stmt|;
name|dir
operator|=
name|ire_route_lookup
argument_list|(
name|dst
operator|.
name|s_addr
argument_list|,
literal|0xffffffff
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|gw
argument_list|,
name|NULL
argument_list|,
name|MATCH_IRE_DSTONLY
operator||
name|MATCH_IRE_DEFAULT
operator||
name|MATCH_IRE_RECURSIVE
argument_list|)
expr_stmt|;
else|#
directive|else
name|dir
operator|=
name|ire_lookup
argument_list|(
name|dst
operator|.
name|s_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|SOLARIS2
operator|<
literal|8
if|if
condition|(
name|dir
condition|)
if|if
condition|(
operator|!
name|dir
operator|->
name|ire_ll_hdr_mp
operator|||
operator|!
name|dir
operator|->
name|ire_ll_hdr_length
condition|)
name|dir
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|dir
condition|)
if|if
condition|(
operator|!
name|dir
operator|->
name|ire_fp_mp
operator|||
operator|!
name|dir
operator|->
name|ire_dlureq_mp
condition|)
name|dir
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ir
condition|)
name|ir
operator|=
name|dir
expr_stmt|;
if|if
condition|(
name|ir
operator|&&
name|dir
condition|)
block|{
name|ifp
operator|=
name|ire_to_ill
argument_list|(
name|ir
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
goto|goto
name|bad_fastroute
goto|;
name|fr
operator|=
name|fin
operator|->
name|fin_fr
expr_stmt|;
comment|/* 		 * In case we're here due to "to<if>" being used with 		 * "keep state", check that we're going in the correct 		 * direction. 		 */
if|if
condition|(
operator|(
name|fr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|fdp
operator|->
name|fd_ifp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|fin
operator|->
name|fin_rev
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|fdp
operator|==
operator|&
name|fr
operator|->
name|fr_tif
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|fin
operator|->
name|fin_ifp
operator|=
name|ifp
expr_stmt|;
if|if
condition|(
name|fin
operator|->
name|fin_out
operator|==
literal|0
condition|)
block|{
name|fin
operator|->
name|fin_fr
operator|=
name|ipacct
index|[
literal|1
index|]
index|[
name|fr_active
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|->
name|fin_fr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|fr_scanlist
argument_list|(
name|FR_NOMATCH
argument_list|,
name|ip
argument_list|,
name|fin
argument_list|,
name|mb
argument_list|)
operator|&
name|FR_ACCOUNT
operator|)
condition|)
block|{
name|ATOMIC_INC
argument_list|(
name|frstats
index|[
literal|1
index|]
operator|.
name|fr_acct
argument_list|)
expr_stmt|;
block|}
name|fin
operator|->
name|fin_fr
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|fr_checkstate
argument_list|(
name|ip
argument_list|,
name|fin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ip_natout
argument_list|(
name|ip
argument_list|,
name|fin
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|sparc
name|__iplen
operator|=
operator|(
name|u_short
operator|)
name|ip
operator|->
name|ip_len
operator|,
name|__ipoff
operator|=
operator|(
name|u_short
operator|)
name|ip
operator|->
name|ip_off
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|__iplen
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
name|__ipoff
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|SOLARIS2
operator|<
literal|8
name|mp
operator|=
name|dir
operator|->
name|ire_ll_hdr_mp
expr_stmt|;
name|hlen
operator|=
name|dir
operator|->
name|ire_ll_hdr_length
expr_stmt|;
else|#
directive|else
name|mp
operator|=
name|dir
operator|->
name|ire_fp_mp
expr_stmt|;
name|hlen
operator|=
name|mp
condition|?
name|mp
operator|->
name|b_wptr
operator|-
name|mp
operator|->
name|b_rptr
else|:
literal|0
expr_stmt|;
name|mp
operator|=
name|dir
operator|->
name|ire_dlureq_mp
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mp
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
name|mb
operator|->
name|b_rptr
expr_stmt|;
if|if
condition|(
if|#
directive|if
name|SOLARIS2
operator|>=
literal|6
operator|(
name|dohwcksum
operator|&&
name|ifp
operator|->
name|ill_ick
operator|.
name|ick_magic
operator|==
name|ICK_M_CTL_MAGIC
operator|)
operator|||
endif|#
directive|endif
operator|(
name|hlen
operator|&&
operator|(
name|s
operator|-
name|mb
operator|->
name|b_datap
operator|->
name|db_base
operator|)
operator|>=
name|hlen
operator|)
condition|)
block|{
name|s
operator|-=
name|hlen
expr_stmt|;
name|mb
operator|->
name|b_rptr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|s
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mp
operator|->
name|b_rptr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|s
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mblk_t
modifier|*
name|mp2
decl_stmt|;
name|mp2
operator|=
name|copyb
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mp2
condition|)
goto|goto
name|bad_fastroute
goto|;
name|mp2
operator|->
name|b_cont
operator|=
name|mb
expr_stmt|;
name|mb
operator|=
name|mp2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ir
operator|->
name|ire_stq
condition|)
name|q
operator|=
name|ir
operator|->
name|ire_stq
expr_stmt|;
elseif|else
if|if
condition|(
name|ir
operator|->
name|ire_rfq
condition|)
name|q
operator|=
name|WR
argument_list|(
name|ir
operator|->
name|ire_rfq
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
block|{
name|mb
operator|->
name|b_prev
operator|=
name|NULL
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
name|RWLOCK_EXIT
argument_list|(
operator|&
name|ipf_solaris
argument_list|)
expr_stmt|;
if|#
directive|if
name|SOLARIS2
operator|>=
literal|6
if|if
condition|(
operator|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_TCP
operator|)
operator|&&
name|dohwcksum
operator|&&
operator|(
name|ifp
operator|->
name|ill_ick
operator|.
name|ick_magic
operator|==
name|ICK_M_CTL_MAGIC
operator|)
condition|)
block|{
name|tcphdr_t
modifier|*
name|tcp
decl_stmt|;
name|u_32_t
name|t
decl_stmt|;
name|tcp
operator|=
operator|(
name|tcphdr_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ip
operator|+
name|fin
operator|->
name|fin_hlen
operator|)
expr_stmt|;
name|t
operator|=
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
name|t
operator|+=
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
name|t
operator|+=
literal|30
expr_stmt|;
name|t
operator|=
operator|(
name|t
operator|&
literal|0xffff
operator|)
operator|+
operator|(
name|t
operator|>>
literal|16
operator|)
expr_stmt|;
name|tcp
operator|->
name|th_sum
operator|=
name|t
operator|&
literal|0xffff
expr_stmt|;
block|}
endif|#
directive|endif
name|putnext
argument_list|(
name|q
argument_list|,
name|mb
argument_list|)
expr_stmt|;
name|READ_ENTER
argument_list|(
operator|&
name|ipf_solaris
argument_list|)
expr_stmt|;
name|READ_ENTER
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
name|ipl_frouteok
index|[
literal|0
index|]
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|bad_fastroute
label|:
name|mb
operator|->
name|b_prev
operator|=
name|NULL
expr_stmt|;
name|freemsg
argument_list|(
name|mb
argument_list|)
expr_stmt|;
name|ipl_frouteok
index|[
literal|1
index|]
operator|++
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_function
name|void
name|copyout_mblk
parameter_list|(
name|m
parameter_list|,
name|off
parameter_list|,
name|len
parameter_list|,
name|buf
parameter_list|)
name|mblk_t
modifier|*
name|m
decl_stmt|;
name|size_t
name|off
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|u_char
modifier|*
name|s
decl_stmt|,
modifier|*
name|bp
init|=
operator|(
name|u_char
operator|*
operator|)
name|buf
decl_stmt|;
name|size_t
name|mlen
decl_stmt|,
name|olen
decl_stmt|,
name|clen
decl_stmt|;
for|for
control|(
init|;
name|m
operator|&&
name|len
condition|;
name|m
operator|=
name|m
operator|->
name|b_cont
control|)
block|{
if|if
condition|(
name|MTYPE
argument_list|(
name|m
argument_list|)
operator|!=
name|M_DATA
condition|)
continue|continue;
name|s
operator|=
name|m
operator|->
name|b_rptr
expr_stmt|;
name|mlen
operator|=
name|m
operator|->
name|b_wptr
operator|-
name|s
expr_stmt|;
name|olen
operator|=
name|MIN
argument_list|(
name|off
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|olen
operator|==
name|mlen
operator|)
operator|||
operator|(
name|olen
operator|<
name|off
operator|)
condition|)
block|{
name|off
operator|-=
name|olen
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|olen
condition|)
block|{
name|off
operator|-=
name|olen
expr_stmt|;
name|s
operator|+=
name|olen
expr_stmt|;
name|mlen
operator|-=
name|olen
expr_stmt|;
block|}
name|clen
operator|=
name|MIN
argument_list|(
name|mlen
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|s
argument_list|,
name|bp
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|len
operator|-=
name|clen
expr_stmt|;
name|bp
operator|+=
name|clen
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|copyin_mblk
parameter_list|(
name|m
parameter_list|,
name|off
parameter_list|,
name|len
parameter_list|,
name|buf
parameter_list|)
name|mblk_t
modifier|*
name|m
decl_stmt|;
name|size_t
name|off
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|u_char
modifier|*
name|s
decl_stmt|,
modifier|*
name|bp
init|=
operator|(
name|u_char
operator|*
operator|)
name|buf
decl_stmt|;
name|size_t
name|mlen
decl_stmt|,
name|olen
decl_stmt|,
name|clen
decl_stmt|;
for|for
control|(
init|;
name|m
operator|&&
name|len
condition|;
name|m
operator|=
name|m
operator|->
name|b_cont
control|)
block|{
if|if
condition|(
name|MTYPE
argument_list|(
name|m
argument_list|)
operator|!=
name|M_DATA
condition|)
continue|continue;
name|s
operator|=
name|m
operator|->
name|b_rptr
expr_stmt|;
name|mlen
operator|=
name|m
operator|->
name|b_wptr
operator|-
name|s
expr_stmt|;
name|olen
operator|=
name|MIN
argument_list|(
name|off
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|olen
operator|==
name|mlen
operator|)
operator|||
operator|(
name|olen
operator|<
name|off
operator|)
condition|)
block|{
name|off
operator|-=
name|olen
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|olen
condition|)
block|{
name|off
operator|-=
name|olen
expr_stmt|;
name|s
operator|+=
name|olen
expr_stmt|;
name|mlen
operator|-=
name|olen
expr_stmt|;
block|}
name|clen
operator|=
name|MIN
argument_list|(
name|mlen
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bp
argument_list|,
name|s
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|len
operator|-=
name|clen
expr_stmt|;
name|bp
operator|+=
name|clen
expr_stmt|;
block|}
block|}
end_function

end_unit

