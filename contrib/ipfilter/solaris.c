begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * (C)opyright 1993,1994,1995 by Darren Reed.  *  * Redistribution and use in source and binary forms are permitted  * provided that this notice is preserved and due credit is given  * to the original author and the contributors.  */
end_comment

begin_comment
comment|/* #pragma ident   "@(#)solaris.c	1.12 6/5/96 (C) 1995 Darren Reed"*/
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"$Id: solaris.c,v 2.0.1.4 1997/02/08 06:38:30 darrenr Exp $"
name|;
end_pragma

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/modctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/open.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/cred.h>
end_include

begin_include
include|#
directive|include
file|<sys/dditypes.h>
end_include

begin_include
include|#
directive|include
file|<sys/stream.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/autoconf.h>
end_include

begin_include
include|#
directive|include
file|<sys/byteorder.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/af.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcpip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_include
include|#
directive|include
file|"ipl.h"
end_include

begin_include
include|#
directive|include
file|"ip_fil.h"
end_include

begin_include
include|#
directive|include
file|"ip_compat.h"
end_include

begin_include
include|#
directive|include
file|<sys/ddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_include
include|#
directive|include
file|<inet/ip_ire.h>
end_include

begin_decl_stmt
name|char
name|_depends_on
index|[]
init|=
literal|"drv/ip"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|iplopen
argument_list|()
decl_stmt|,
name|iplclose
argument_list|()
decl_stmt|,
name|iplread
argument_list|()
decl_stmt|,
name|iplioctl
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|iplattach
argument_list|()
decl_stmt|,
name|ipldetach
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|copyout_mblk
argument_list|()
decl_stmt|,
name|copyin_mblk
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|solattach
argument_list|()
decl_stmt|,
name|soldetach
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|filterstats
name|frstats
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|kmutex_t
name|ipl_mutex
decl_stmt|,
name|ipf_mutex
decl_stmt|,
name|ipfs_mutex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|fr_flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|qif_t
modifier|*
name|qif_head
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipl_getinfo
argument_list|()
decl_stmt|,
name|ipl_probe
argument_list|()
decl_stmt|,
name|ipl_identify
argument_list|()
decl_stmt|,
name|ipl_attach
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|ipl_detach
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|cb_ops
name|ipl_cb_ops
init|=
block|{
name|iplopen
block|,
name|iplclose
block|,
name|nodev
block|,
comment|/* strategy */
name|nodev
block|,
comment|/* print */
name|nodev
block|,
comment|/* dump */
name|iplread
block|,
name|nodev
block|,
comment|/* write */
name|iplioctl
block|,
comment|/* ioctl */
name|nodev
block|,
comment|/* devmap */
name|nodev
block|,
comment|/* mmap */
name|nodev
block|,
comment|/* segmap */
name|nochpoll
block|,
comment|/* poll */
name|ddi_prop_op
block|,
name|NULL
block|,
name|D_MTSAFE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dev_ops
name|ipl_ops
init|=
block|{
name|DEVO_REV
block|,
literal|0
block|,
name|ipl_getinfo
block|,
name|ipl_identify
block|,
name|ipl_probe
block|,
name|ipl_attach
block|,
name|ipl_detach
block|,
name|nodev
block|,
comment|/* reset */
operator|&
name|ipl_cb_ops
block|,
operator|(
expr|struct
name|bus_ops
operator|*
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|mod_ops
name|mod_driverops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|modldrv
name|iplmod
init|=
block|{
operator|&
name|mod_driverops
block|,
name|IPL_VERSION
block|,
operator|&
name|ipl_ops
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|modlinkage
name|modlink1
init|=
block|{
name|MODREV_1
block|,
operator|&
name|iplmod
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dev_info_t
modifier|*
name|ipf_dev_info
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|_init
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: ipf_init()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|mod_install
argument_list|(
operator|&
name|modlink1
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|_fini
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: ipf_fini()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|mod_remove
argument_list|(
operator|&
name|modlink1
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|_info
parameter_list|(
name|struct
name|modinfo
modifier|*
name|modinfop
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: ipf_info(%x)"
argument_list|,
name|modinfop
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|mod_info
argument_list|(
operator|&
name|modlink1
argument_list|,
name|modinfop
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ipl_probe
parameter_list|(
name|dev_info_t
modifier|*
name|dip
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: ipl_probe(%x)"
argument_list|,
name|dip
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|DDI_PROBE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ipl_identify
parameter_list|(
name|dev_info_t
modifier|*
name|dip
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: ipl_identify(%x)"
argument_list|,
name|dip
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|strcmp
argument_list|(
name|ddi_get_name
argument_list|(
name|dip
argument_list|)
argument_list|,
literal|"ipf"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|DDI_IDENTIFIED
operator|)
return|;
return|return
operator|(
name|DDI_NOT_IDENTIFIED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ipl_attach
parameter_list|(
name|dev_info_t
modifier|*
name|dip
parameter_list|,
name|ddi_attach_cmd_t
name|cmd
parameter_list|)
block|{
name|int
name|instance
decl_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: ipl_attach(%x,%x)"
argument_list|,
name|dip
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DDI_ATTACH
case|:
name|instance
operator|=
name|ddi_get_instance
argument_list|(
name|dip
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: attach ipf instace %d"
argument_list|,
name|instance
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ddi_create_minor_node
argument_list|(
name|dip
argument_list|,
literal|"ipf"
argument_list|,
name|S_IFCHR
argument_list|,
name|instance
argument_list|,
name|DDI_PSEUDO
argument_list|,
literal|0
argument_list|)
operator|==
name|DDI_FAILURE
condition|)
block|{
name|ddi_remove_minor_node
argument_list|(
name|dip
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|attach_failed
goto|;
block|}
name|ipf_dev_info
operator|=
name|dip
expr_stmt|;
name|sync
argument_list|()
expr_stmt|;
comment|/* 		 * Initialize mutex's 		 */
name|iplattach
argument_list|()
expr_stmt|;
name|solattach
argument_list|()
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"IP Filter: attaching complete.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DDI_SUCCESS
operator|)
return|;
default|default:
return|return
operator|(
name|DDI_FAILURE
operator|)
return|;
block|}
name|attach_failed
label|:
comment|/* 	 * Use our own detach routine to toss 	 * away any stuff we allocated above. 	 */
operator|(
name|void
operator|)
name|ipl_detach
argument_list|(
name|dip
argument_list|,
name|DDI_DETACH
argument_list|)
expr_stmt|;
return|return
operator|(
name|DDI_FAILURE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ipl_detach
parameter_list|(
name|dip
parameter_list|,
name|cmd
parameter_list|)
name|dev_info_t
modifier|*
name|dip
decl_stmt|;
name|ddi_detach_cmd_t
name|cmd
decl_stmt|;
block|{
name|int
name|instance
decl_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: ipl_detach(%x,%x)"
argument_list|,
name|dip
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DDI_DETACH
case|:
comment|/* 		 * Undo what we did in ipl_attach, freeing resources 		 * and removing things we installed.  The system 		 * framework guarantees we are not active with this devinfo 		 * node in any other entry points at this time. 		 */
name|ddi_prop_remove_all
argument_list|(
name|dip
argument_list|)
expr_stmt|;
name|instance
operator|=
name|ddi_get_instance
argument_list|(
name|dip
argument_list|)
expr_stmt|;
name|ddi_remove_minor_node
argument_list|(
name|dip
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sync
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|soldetach
argument_list|()
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"IP Filter: detached\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DDI_SUCCESS
operator|)
return|;
block|}
default|default:
return|return
operator|(
name|DDI_FAILURE
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ipl_getinfo
parameter_list|(
name|dip
parameter_list|,
name|infocmd
parameter_list|,
name|arg
parameter_list|,
name|result
parameter_list|)
name|dev_info_t
modifier|*
name|dip
decl_stmt|;
name|ddi_info_cmd_t
name|infocmd
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|,
decl|*
modifier|*
name|result
decl_stmt|;
end_function

begin_block
block|{
name|int
name|error
init|=
name|DDI_FAILURE
decl_stmt|;
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: ipl_getinfo(%x,%x)"
argument_list|,
name|dip
argument_list|,
name|infocmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|infocmd
condition|)
block|{
case|case
name|DDI_INFO_DEVT2DEVINFO
case|:
operator|*
name|result
operator|=
name|ipf_dev_info
expr_stmt|;
name|error
operator|=
name|DDI_SUCCESS
expr_stmt|;
break|break;
case|case
name|DDI_INFO_DEVT2INSTANCE
case|:
operator|*
name|result
operator|=
operator|(
name|void
operator|*
operator|)
name|getminor
argument_list|(
operator|(
name|dev_t
operator|)
name|arg
argument_list|)
expr_stmt|;
name|error
operator|=
name|DDI_SUCCESS
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * find the filter structure setup for this queue  */
end_comment

begin_function
name|qif_t
modifier|*
name|qif_from_queue
parameter_list|(
name|q
parameter_list|)
name|queue_t
modifier|*
name|q
decl_stmt|;
block|{
name|qif_t
modifier|*
name|qif
decl_stmt|;
for|for
control|(
name|qif
operator|=
name|qif_head
init|;
name|qif
condition|;
name|qif
operator|=
name|qif
operator|->
name|qf_next
control|)
if|if
condition|(
operator|(
name|qif
operator|->
name|qf_iptr
operator|==
name|q
operator|->
name|q_ptr
operator|)
operator|||
operator|(
name|qif
operator|->
name|qf_optr
operator|==
name|q
operator|->
name|q_ptr
operator|)
condition|)
break|break;
return|return
name|qif
return|;
block|}
end_function

begin_comment
comment|/*  * OK, this is pretty scrappy code, but then it's essentially just here for  * debug purposes and that's it.  Packets should not normally come through  * here, and if they do, well, we would like to see as much information as  * possible about them and what they claim to hold.  */
end_comment

begin_function
name|void
name|fr_donotip
parameter_list|(
name|out
parameter_list|,
name|qif
parameter_list|,
name|q
parameter_list|,
name|m
parameter_list|,
name|mt
parameter_list|,
name|ip
parameter_list|,
name|off
parameter_list|)
name|int
name|out
decl_stmt|;
name|qif_t
modifier|*
name|qif
decl_stmt|;
name|queue_t
modifier|*
name|q
decl_stmt|;
name|mblk_t
modifier|*
name|m
decl_stmt|,
decl|*
name|mt
decl_stmt|;
end_function

begin_decl_stmt
name|ip_t
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|off
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u_char
modifier|*
name|s
decl_stmt|,
name|outb
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
name|outb
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|outb
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|outb
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|outb
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|ip
condition|?
operator|(
name|u_char
operator|*
operator|)
name|ip
else|:
name|outb
expr_stmt|;
if|if
condition|(
operator|!
name|ip
operator|&&
operator|(
name|m
operator|==
name|mt
operator|)
operator|&&
name|m
operator|->
name|b_cont
operator|&&
operator|(
name|MTYPE
argument_list|(
name|m
argument_list|)
operator|!=
name|M_DATA
operator|)
condition|)
name|m
operator|=
name|m
operator|->
name|b_cont
expr_stmt|;
name|printf
argument_list|(
literal|"!IP %s:%d %x %x %x %d %x %x %x %d %d %x\n%02x%02x%02x%02x\n"
argument_list|,
name|qif
condition|?
name|qif
operator|->
name|qf_name
else|:
literal|"?"
argument_list|,
name|out
argument_list|,
name|q
argument_list|,
name|q
condition|?
name|q
operator|->
name|q_ptr
else|:
name|NULL
argument_list|,
name|q
condition|?
name|q
operator|->
name|q_qinfo
else|:
name|NULL
argument_list|,
name|mt
operator|->
name|b_wptr
operator|-
name|mt
operator|->
name|b_rptr
argument_list|,
name|m
argument_list|,
name|mt
argument_list|,
name|m
operator|->
name|b_rptr
argument_list|,
name|m
operator|->
name|b_wptr
operator|-
name|m
operator|->
name|b_rptr
argument_list|,
name|off
argument_list|,
name|ip
argument_list|,
operator|*
name|s
argument_list|,
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
argument_list|,
operator|*
operator|(
name|s
operator|+
literal|2
operator|)
argument_list|,
operator|*
operator|(
name|s
operator|+
literal|3
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|mt
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|outb
expr_stmt|;
name|s
operator|=
name|mt
operator|->
name|b_rptr
expr_stmt|;
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%d:"
argument_list|,
name|MTYPE
argument_list|(
name|mt
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|+=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|i
operator|<
literal|100
operator|)
operator|&&
operator|(
name|s
operator|<
name|mt
operator|->
name|b_wptr
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%02x%s"
argument_list|,
operator|*
name|s
operator|++
argument_list|,
operator|(
operator|(
name|i
operator|&
literal|3
operator|)
operator|==
literal|3
operator|)
condition|?
literal|" "
else|:
literal|""
argument_list|)
expr_stmt|;
name|t
operator|+=
operator|(
operator|(
name|i
operator|&
literal|3
operator|)
operator|==
literal|3
operator|)
condition|?
literal|3
else|:
literal|2
expr_stmt|;
block|}
operator|*
name|t
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|outb
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|outb
expr_stmt|;
name|s
operator|=
name|m
operator|->
name|b_rptr
expr_stmt|;
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%d:"
argument_list|,
name|MTYPE
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|+=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|i
operator|<
literal|100
operator|)
operator|&&
operator|(
name|s
operator|<
name|m
operator|->
name|b_wptr
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%02x%s"
argument_list|,
operator|*
name|s
operator|++
argument_list|,
operator|(
operator|(
name|i
operator|&
literal|3
operator|)
operator|==
literal|3
operator|)
condition|?
literal|" "
else|:
literal|""
argument_list|)
expr_stmt|;
name|t
operator|+=
operator|(
operator|(
name|i
operator|&
literal|3
operator|)
operator|==
literal|3
operator|)
condition|?
literal|3
else|:
literal|2
expr_stmt|;
block|}
operator|*
name|t
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|outb
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * find the first data mblk, if present, in the chain we're processing.  Also  * make a few sanity checks to try prevent the filter from causing a panic -  * none of the nice IP sanity checks (including checksumming) should have been  * done yet - dangerous!  */
end_comment

begin_function
name|int
name|fr_precheck
parameter_list|(
name|mp
parameter_list|,
name|q
parameter_list|,
name|qif
parameter_list|,
name|out
parameter_list|)
name|mblk_t
modifier|*
modifier|*
name|mp
decl_stmt|;
name|queue_t
modifier|*
name|q
decl_stmt|;
name|qif_t
modifier|*
name|qif
decl_stmt|;
name|int
name|out
decl_stmt|;
block|{
name|u_long
name|lbuf
index|[
literal|48
index|]
decl_stmt|;
name|mblk_t
modifier|*
name|m
decl_stmt|,
modifier|*
name|mp1
decl_stmt|,
modifier|*
name|mt
init|=
operator|*
name|mp
decl_stmt|;
specifier|register
name|ip_t
modifier|*
name|ip
decl_stmt|;
name|int
name|iphlen
decl_stmt|,
name|hlen
decl_stmt|,
name|len
decl_stmt|,
name|err
decl_stmt|,
name|mlen
decl_stmt|,
name|off
decl_stmt|,
name|synced
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|sparc
name|u_short
name|__iplen
decl_stmt|,
name|__ipoff
decl_stmt|;
endif|#
directive|endif
name|tryagain
label|:
comment|/* 	 * If there is only M_DATA for a packet going out, then any header 	 * information (which would otherwise appear in an M_PROTO mblk before 	 * the M_DATA) is prepended before the IP header.  We need to set the 	 * offset to account for this. - see MMM 	 */
name|off
operator|=
operator|(
name|out
operator|)
condition|?
name|qif
operator|->
name|qf_hl
else|:
literal|0
expr_stmt|;
comment|/* 	 * Find the first data block, count the data blocks in this chain and 	 * the total amount of data. 	 */
for|for
control|(
name|m
operator|=
name|mt
init|;
name|m
operator|&&
operator|(
name|MTYPE
argument_list|(
name|m
argument_list|)
operator|!=
name|M_DATA
operator|)
condition|;
name|m
operator|=
name|m
operator|->
name|b_cont
control|)
name|off
operator|=
literal|0
expr_stmt|;
comment|/* Any non-M_DATA cancels the offset */
if|if
condition|(
operator|!
name|m
condition|)
return|return
literal|0
return|;
comment|/* No data blocks */
name|ip
operator|=
operator|(
name|ip_t
operator|*
operator|)
operator|(
name|m
operator|->
name|b_rptr
operator|+
name|off
operator|)
expr_stmt|;
comment|/* MMM */
comment|/* 	 * We might have a 1st data block which is really M_PROTO, i.e. it is 	 * only big enough for the link layer header 	 */
while|while
condition|(
operator|(
name|u_char
operator|*
operator|)
name|ip
operator|>=
name|m
operator|->
name|b_wptr
condition|)
block|{
name|len
operator|=
operator|(
name|u_char
operator|*
operator|)
name|ip
operator|-
name|m
operator|->
name|b_wptr
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|=
name|m
operator|->
name|b_cont
operator|)
condition|)
return|return
literal|0
return|;
comment|/* not enough data for IP */
name|ip
operator|=
operator|(
name|ip_t
operator|*
operator|)
operator|(
name|m
operator|->
name|b_rptr
operator|+
name|len
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|off
operator|=
operator|(
name|u_char
operator|*
operator|)
name|ip
operator|-
name|m
operator|->
name|b_rptr
operator|)
condition|)
name|m
operator|->
name|b_rptr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|ip
expr_stmt|;
name|mlen
operator|=
name|msgdsize
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Ok, the IP header isn't on a 32bit aligned address.  To get around 	 * this, we copy the data to an aligned buffer and work with that. 	 */
if|if
condition|(
operator|!
name|OK_32PTR
argument_list|(
name|ip
argument_list|)
condition|)
block|{
name|len
operator|=
name|MIN
argument_list|(
name|mlen
argument_list|,
sizeof|sizeof
argument_list|(
name|ip_t
argument_list|)
argument_list|)
expr_stmt|;
name|copyout_mblk
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|lbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|frstats
index|[
name|out
index|]
operator|.
name|fr_pull
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|ip
operator|=
operator|(
name|ip_t
operator|*
operator|)
name|lbuf
expr_stmt|;
block|}
else|else
name|len
operator|=
name|m
operator|->
name|b_wptr
operator|-
operator|(
name|u_char
operator|*
operator|)
name|ip
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_v
operator|!=
name|IPVERSION
condition|)
block|{
name|m
operator|->
name|b_rptr
operator|-=
name|off
expr_stmt|;
if|if
condition|(
operator|!
name|synced
condition|)
block|{
name|synced
operator|=
literal|1
expr_stmt|;
name|ipfsync
argument_list|()
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
name|fr_donotip
argument_list|(
name|out
argument_list|,
name|qif
argument_list|,
name|q
argument_list|,
name|m
argument_list|,
name|mt
argument_list|,
name|ip
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|frstats
index|[
name|out
index|]
operator|.
name|fr_notip
operator|++
expr_stmt|;
return|return
operator|(
name|fr_flags
operator|&
name|FF_BLOCKNONIP
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
name|hlen
operator|=
name|iphlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
comment|/* 	 * Make hlen the total size of the IP header plus TCP/UDP/ICMP header 	 * (if it is one of these three). 	 */
if|if
condition|(
operator|!
operator|(
name|ip
operator|->
name|ip_off
operator|&
literal|0x1fff
operator|)
condition|)
switch|switch
condition|(
name|ip
operator|->
name|ip_p
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|hlen
operator|+=
sizeof|sizeof
argument_list|(
name|tcphdr_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|hlen
operator|+=
sizeof|sizeof
argument_list|(
name|udphdr_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_ICMP
case|:
name|hlen
operator|+=
sizeof|sizeof
argument_list|(
name|icmphdr_t
argument_list|)
expr_stmt|;
break|break;
default|default :
break|break;
block|}
comment|/* 	 * If we don't have enough data in the mblk or we haven't yet copied 	 * enough (above), then copy some more. 	 */
if|if
condition|(
operator|(
name|hlen
operator|>
name|len
operator|)
condition|)
block|{
name|len
operator|=
name|MIN
argument_list|(
name|hlen
argument_list|,
sizeof|sizeof
argument_list|(
name|lbuf
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|MIN
argument_list|(
name|mlen
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|copyout_mblk
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|lbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|frstats
index|[
name|out
index|]
operator|.
name|fr_pull
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|ip
operator|=
operator|(
name|ip_t
operator|*
operator|)
name|lbuf
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|sparc
name|__iplen
operator|=
name|ip
operator|->
name|ip_len
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|ntohs
argument_list|(
name|__iplen
argument_list|)
expr_stmt|;
name|__ipoff
operator|=
name|ip
operator|->
name|ip_off
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
name|ntohs
argument_list|(
name|__ipoff
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|iphlen
operator|<
sizeof|sizeof
argument_list|(
name|ip_t
argument_list|)
operator|)
operator|||
operator|(
name|iphlen
operator|>
operator|(
name|u_short
operator|)
name|ip
operator|->
name|ip_len
operator|)
operator|||
operator|(
name|mlen
operator|<
operator|(
name|u_short
operator|)
name|ip
operator|->
name|ip_len
operator|)
condition|)
block|{
comment|/* 		 * Bad IP packet or not enough data/data length mismatches 		 */
name|m
operator|->
name|b_rptr
operator|-=
name|off
expr_stmt|;
name|frstats
index|[
name|out
index|]
operator|.
name|fr_bad
operator|++
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|qif
operator|->
name|qf_m
operator|=
name|m
expr_stmt|;
name|qif
operator|->
name|qf_len
operator|=
name|len
expr_stmt|;
name|err
operator|=
name|fr_check
argument_list|(
name|ip
argument_list|,
name|iphlen
argument_list|,
name|qif
operator|->
name|qf_ill
argument_list|,
name|out
argument_list|,
name|qif
argument_list|,
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
comment|/* 	 * Copy back the ip header data if it was changed, we haven't yet 	 * freed the message and we aren't going to drop the packet. 	 */
ifndef|#
directive|ifndef
name|sparc
if|if
condition|(
operator|*
name|mp
condition|)
block|{
name|ip
operator|->
name|ip_len
operator|=
name|__iplen
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
name|__ipoff
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|err
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|mp
operator|&&
operator|(
name|ip
operator|==
operator|(
name|ip_t
operator|*
operator|)
name|lbuf
operator|)
condition|)
block|{
name|copyin_mblk
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|lbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|frstats
index|[
name|out
index|]
operator|.
name|fr_pull
index|[
literal|1
index|]
operator|++
expr_stmt|;
block|}
name|err
operator|=
literal|0
expr_stmt|;
block|}
name|m
operator|->
name|b_rptr
operator|-=
name|off
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|fr_qin
parameter_list|(
name|q
parameter_list|,
name|mb
parameter_list|)
name|queue_t
modifier|*
name|q
decl_stmt|;
name|mblk_t
modifier|*
name|mb
decl_stmt|;
block|{
name|int
argument_list|(
operator|*
name|pnext
argument_list|)
argument_list|()
decl_stmt|,
name|type
decl_stmt|,
name|synced
init|=
literal|0
decl_stmt|;
name|qif_t
name|qfb
decl_stmt|,
modifier|*
name|qif
decl_stmt|;
name|again
label|:
name|mutex_enter
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|qif
operator|=
name|qif_from_queue
argument_list|(
name|q
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|qif
operator|=
name|qif_head
init|;
name|qif
condition|;
name|qif
operator|=
name|qif
operator|->
name|qf_next
control|)
if|if
condition|(
name|qif
operator|->
name|qf_rqinfo
operator|==
name|q
operator|->
name|q_qinfo
operator|&&
name|qif
operator|->
name|qf_inp
condition|)
block|{
name|pnext
operator|=
name|qif
operator|->
name|qf_inp
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
name|frstats
index|[
literal|0
index|]
operator|.
name|fr_notip
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|synced
condition|)
block|{
name|ipfsync
argument_list|()
expr_stmt|;
name|synced
operator|=
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* fr_donotip(0, NULL, q, mb, mb, NULL, 0); */
return|return
call|(
modifier|*
name|pnext
call|)
argument_list|(
name|q
argument_list|,
name|mb
argument_list|)
return|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|synced
condition|)
block|{
name|ipfsync
argument_list|()
expr_stmt|;
name|synced
operator|=
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"IP Filter: dropped: fr_qin(%x,%x): type %x qif %x"
argument_list|,
name|q
argument_list|,
name|mb
argument_list|,
name|MTYPE
argument_list|(
name|mb
argument_list|)
argument_list|,
name|qif
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"info %x next %x ptr %x fsrv %x bsrv %x\n"
argument_list|,
name|q
operator|->
name|q_qinfo
argument_list|,
name|q
operator|->
name|q_next
argument_list|,
name|q
operator|->
name|q_ptr
argument_list|,
name|q
operator|->
name|q_nfsrv
argument_list|,
name|q
operator|->
name|q_nbsrv
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"IP Filter: info: putp %x srvp %x info %x\n"
argument_list|,
name|q
operator|->
name|q_qinfo
operator|->
name|qi_putp
argument_list|,
name|q
operator|->
name|q_qinfo
operator|->
name|qi_srvp
argument_list|,
name|q
operator|->
name|q_qinfo
operator|->
name|qi_infop
argument_list|)
expr_stmt|;
name|frstats
index|[
literal|0
index|]
operator|.
name|fr_drop
operator|++
expr_stmt|;
name|freemsg
argument_list|(
name|mb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * So we can be more re-entrant. 	 */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qif
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|qfb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|qif
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
name|qif
operator|=
operator|&
name|qfb
expr_stmt|;
name|pnext
operator|=
name|qif
operator|->
name|qf_inp
expr_stmt|;
name|type
operator|=
name|MTYPE
argument_list|(
name|mb
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|M_DATA
operator|||
name|type
operator|==
name|M_PROTO
operator|||
name|type
operator|==
name|M_PCPROTO
condition|)
if|if
condition|(
name|fr_precheck
argument_list|(
operator|&
name|mb
argument_list|,
name|q
argument_list|,
name|qif
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|mb
condition|)
name|freemsg
argument_list|(
name|mb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|mb
condition|)
block|{
if|if
condition|(
name|pnext
condition|)
return|return
call|(
modifier|*
name|pnext
call|)
argument_list|(
name|q
argument_list|,
name|mb
argument_list|)
return|;
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"IP Filter: inp NULL: qif %x %s q %x info %x"
argument_list|,
name|qif
argument_list|,
name|qif
operator|->
name|qf_name
argument_list|,
name|q
argument_list|,
name|q
operator|->
name|q_qinfo
argument_list|)
expr_stmt|;
name|freemsg
argument_list|(
name|mb
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|fr_qout
parameter_list|(
name|q
parameter_list|,
name|mb
parameter_list|)
name|queue_t
modifier|*
name|q
decl_stmt|;
name|mblk_t
modifier|*
name|mb
decl_stmt|;
block|{
name|int
argument_list|(
operator|*
name|pnext
argument_list|)
argument_list|()
decl_stmt|,
name|type
decl_stmt|,
name|synced
init|=
literal|0
decl_stmt|;
name|qif_t
name|qfb
decl_stmt|,
modifier|*
name|qif
decl_stmt|;
name|again
label|:
name|mutex_enter
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|qif
operator|=
name|qif_from_queue
argument_list|(
name|q
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|qif
operator|=
name|qif_head
init|;
name|qif
condition|;
name|qif
operator|=
name|qif
operator|->
name|qf_next
control|)
if|if
condition|(
name|qif
operator|->
name|qf_wqinfo
operator|==
name|q
operator|->
name|q_qinfo
operator|&&
name|qif
operator|->
name|qf_outp
condition|)
block|{
name|pnext
operator|=
name|qif
operator|->
name|qf_outp
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
name|frstats
index|[
literal|1
index|]
operator|.
name|fr_notip
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|synced
condition|)
block|{
name|ipfsync
argument_list|()
expr_stmt|;
name|synced
operator|=
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* fr_donotip(0, NULL, q, mb, mb, NULL, 0); */
return|return
call|(
modifier|*
name|pnext
call|)
argument_list|(
name|q
argument_list|,
name|mb
argument_list|)
return|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|synced
condition|)
block|{
name|ipfsync
argument_list|()
expr_stmt|;
name|synced
operator|=
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"IP Filter: dropped: fr_qout(%x,%x): type %x: qif %x"
argument_list|,
name|q
argument_list|,
name|mb
argument_list|,
name|MTYPE
argument_list|(
name|mb
argument_list|)
argument_list|,
name|qif
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"info %x next %x ptr %x fsrv %x bsrv %x\n"
argument_list|,
name|q
operator|->
name|q_qinfo
argument_list|,
name|q
operator|->
name|q_next
argument_list|,
name|q
operator|->
name|q_ptr
argument_list|,
name|q
operator|->
name|q_nfsrv
argument_list|,
name|q
operator|->
name|q_nbsrv
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"IP Filter: info: putp %x srvp %x info %x\n"
argument_list|,
name|q
operator|->
name|q_qinfo
operator|->
name|qi_putp
argument_list|,
name|q
operator|->
name|q_qinfo
operator|->
name|qi_srvp
argument_list|,
name|q
operator|->
name|q_qinfo
operator|->
name|qi_infop
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|q_nfsrv
condition|)
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"nfsrv: info %x next %x ptr %x\n"
argument_list|,
name|q
operator|->
name|q_nfsrv
operator|->
name|q_qinfo
argument_list|,
name|q
operator|->
name|q_nfsrv
operator|->
name|q_next
argument_list|,
name|q
operator|->
name|q_nfsrv
operator|->
name|q_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|q_nbsrv
condition|)
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"nbsrv: info %x next %x ptr %x\n"
argument_list|,
name|q
operator|->
name|q_nbsrv
operator|->
name|q_qinfo
argument_list|,
name|q
operator|->
name|q_nbsrv
operator|->
name|q_next
argument_list|,
name|q
operator|->
name|q_nbsrv
operator|->
name|q_ptr
argument_list|)
expr_stmt|;
name|frstats
index|[
literal|1
index|]
operator|.
name|fr_drop
operator|++
expr_stmt|;
name|freemsg
argument_list|(
name|mb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * So we can be more re-entrant. 	 */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qif
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|qfb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|qif
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
name|qif
operator|=
operator|&
name|qfb
expr_stmt|;
name|pnext
operator|=
name|qif
operator|->
name|qf_outp
expr_stmt|;
name|type
operator|=
name|MTYPE
argument_list|(
name|mb
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|M_DATA
operator|||
name|type
operator|==
name|M_PROTO
operator|||
name|type
operator|==
name|M_PCPROTO
condition|)
if|if
condition|(
name|fr_precheck
argument_list|(
operator|&
name|mb
argument_list|,
name|q
argument_list|,
name|qif
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|mb
condition|)
name|freemsg
argument_list|(
name|mb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|mb
condition|)
block|{
if|if
condition|(
name|pnext
condition|)
return|return
call|(
modifier|*
name|pnext
call|)
argument_list|(
name|q
argument_list|,
name|mb
argument_list|)
return|;
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"IP Filter: outp NULL: qif %x %s q %x info %x"
argument_list|,
name|qif
argument_list|,
name|qif
operator|->
name|qf_name
argument_list|,
name|q
argument_list|,
name|q
operator|->
name|q_qinfo
argument_list|)
expr_stmt|;
name|freemsg
argument_list|(
name|mb
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * attach the packet filter to each interface that is defined as having an  * IP address associated with it and save some of the info. for that struct  * so we're not out of date as soon as te ill disappears - but we must sync  * to be correct!  */
end_comment

begin_function
name|int
name|solattach
parameter_list|()
block|{
name|queue_t
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|;
name|qif_t
modifier|*
name|qif
decl_stmt|,
modifier|*
name|qf2
decl_stmt|;
name|ill_t
modifier|*
name|il
decl_stmt|;
for|for
control|(
name|il
operator|=
name|ill_g_head
init|;
name|il
condition|;
name|il
operator|=
name|il
operator|->
name|ill_next
control|)
block|{
name|in
operator|=
name|il
operator|->
name|ill_rq
expr_stmt|;
if|if
condition|(
operator|!
name|in
operator|||
operator|!
name|il
operator|->
name|ill_wq
condition|)
continue|continue;
name|out
operator|=
name|il
operator|->
name|ill_wq
operator|->
name|q_next
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
comment|/* 		 * Look for entry already setup for this device 		 */
for|for
control|(
name|qif
operator|=
name|qif_head
init|;
name|qif
condition|;
name|qif
operator|=
name|qif
operator|->
name|qf_next
control|)
if|if
condition|(
name|qif
operator|->
name|qf_iptr
operator|==
name|in
operator|->
name|q_ptr
operator|&&
name|qif
operator|->
name|qf_optr
operator|==
name|out
operator|->
name|q_ptr
condition|)
break|break;
if|if
condition|(
name|qif
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"IP Filter: il %x ipt %x opt %x ipu %x opu %x i %x/%x"
argument_list|,
name|il
argument_list|,
name|in
operator|->
name|q_ptr
argument_list|,
name|out
operator|->
name|q_ptr
argument_list|,
name|in
operator|->
name|q_qinfo
operator|->
name|qi_putp
argument_list|,
name|out
operator|->
name|q_qinfo
operator|->
name|qi_putp
argument_list|,
name|out
operator|->
name|q_qinfo
argument_list|,
name|in
operator|->
name|q_qinfo
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qif
operator|=
operator|(
name|qif_t
operator|*
operator|)
name|KMALLOC
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|qif
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|->
name|q_qinfo
operator|->
name|qi_putp
operator|==
name|fr_qin
condition|)
block|{
for|for
control|(
name|qf2
operator|=
name|qif_head
init|;
name|qf2
condition|;
name|qf2
operator|=
name|qf2
operator|->
name|qf_next
control|)
if|if
condition|(
name|qf2
operator|->
name|qf_rqinfo
operator|==
name|in
operator|->
name|q_qinfo
condition|)
block|{
name|qif
operator|->
name|qf_inp
operator|=
name|qf2
operator|->
name|qf_inp
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|qf2
condition|)
block|{
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"IP Filter: rq:%s put %x qi %x"
argument_list|,
name|il
operator|->
name|ill_name
argument_list|,
name|in
operator|->
name|q_qinfo
operator|->
name|qi_putp
argument_list|,
name|in
operator|->
name|q_qinfo
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mutex_exit
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|qif
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
name|qif
operator|->
name|qf_inp
operator|=
name|in
operator|->
name|q_qinfo
operator|->
name|qi_putp
expr_stmt|;
if|if
condition|(
name|out
operator|->
name|q_qinfo
operator|->
name|qi_putp
operator|==
name|fr_qout
condition|)
block|{
for|for
control|(
name|qf2
operator|=
name|qif_head
init|;
name|qf2
condition|;
name|qf2
operator|=
name|qf2
operator|->
name|qf_next
control|)
if|if
condition|(
name|qf2
operator|->
name|qf_wqinfo
operator|==
name|out
operator|->
name|q_qinfo
condition|)
block|{
name|qif
operator|->
name|qf_outp
operator|=
name|qf2
operator|->
name|qf_outp
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|qf2
condition|)
block|{
ifdef|#
directive|ifdef
name|IPFDEBUG
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"IP Filter: wq:%s put %x qi %x"
argument_list|,
name|il
operator|->
name|ill_name
argument_list|,
name|out
operator|->
name|q_qinfo
operator|->
name|qi_putp
argument_list|,
name|out
operator|->
name|q_qinfo
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mutex_exit
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|qif
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
name|qif
operator|->
name|qf_outp
operator|=
name|out
operator|->
name|q_qinfo
operator|->
name|qi_putp
expr_stmt|;
name|qif
operator|->
name|qf_ill
operator|=
name|il
expr_stmt|;
name|qif
operator|->
name|qf_iptr
operator|=
name|in
operator|->
name|q_ptr
expr_stmt|;
name|qif
operator|->
name|qf_optr
operator|=
name|out
operator|->
name|q_ptr
expr_stmt|;
name|qif
operator|->
name|qf_hl
operator|=
name|il
operator|->
name|ill_hdr_length
expr_stmt|;
name|strncpy
argument_list|(
name|qif
operator|->
name|qf_name
argument_list|,
name|il
operator|->
name|ill_name
argument_list|,
sizeof|sizeof
argument_list|(
name|qif
operator|->
name|qf_name
argument_list|)
argument_list|)
expr_stmt|;
name|qif
operator|->
name|qf_name
index|[
sizeof|sizeof
argument_list|(
name|qif
operator|->
name|qf_name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|qif
operator|->
name|qf_wqinfo
operator|=
name|out
operator|->
name|q_qinfo
expr_stmt|;
name|qif
operator|->
name|qf_rqinfo
operator|=
name|in
operator|->
name|q_qinfo
expr_stmt|;
name|qif
operator|->
name|qf_next
operator|=
name|qif_head
expr_stmt|;
name|qif_head
operator|=
name|qif
expr_stmt|;
name|in
operator|->
name|q_qinfo
operator|->
name|qi_putp
operator|=
name|fr_qin
expr_stmt|;
name|out
operator|->
name|q_qinfo
operator|->
name|qi_putp
operator|=
name|fr_qout
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"IP Filter: attach to [%s,%d]\n"
argument_list|,
name|qif
operator|->
name|qf_name
argument_list|,
name|il
operator|->
name|ill_ppa
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|qif_head
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"IP Filter: not attached to any interfaces\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * look for bad consistancies between the list of interfaces the filter knows  * about and those which are currently configured.  */
end_comment

begin_function
name|int
name|ipfsync
parameter_list|()
block|{
specifier|register
name|struct
name|frentry
modifier|*
name|f
decl_stmt|,
modifier|*
modifier|*
name|fp
decl_stmt|;
specifier|register
name|qif_t
modifier|*
name|qif
decl_stmt|,
modifier|*
modifier|*
name|qp
decl_stmt|;
specifier|register
name|ill_t
modifier|*
name|il
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|qp
operator|=
operator|&
name|qif_head
init|;
operator|(
name|qif
operator|=
operator|*
name|qp
operator|)
condition|;
control|)
block|{
for|for
control|(
name|il
operator|=
name|ill_g_head
init|;
name|il
condition|;
name|il
operator|=
name|il
operator|->
name|ill_next
control|)
if|if
condition|(
operator|(
name|qif
operator|->
name|qf_ill
operator|==
name|il
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|qif
operator|->
name|qf_name
argument_list|,
name|il
operator|->
name|ill_name
argument_list|)
condition|)
block|{
name|mblk_t
modifier|*
name|m
init|=
name|il
operator|->
name|ill_hdr_mp
decl_stmt|;
name|qif
operator|->
name|qf_hl
operator|=
name|il
operator|->
name|ill_hdr_length
expr_stmt|;
if|if
condition|(
name|m
operator|&&
name|qif
operator|->
name|qf_hl
operator|!=
operator|(
name|m
operator|->
name|b_wptr
operator|-
name|m
operator|->
name|b_rptr
operator|)
condition|)
name|printf
argument_list|(
literal|"ILL Header Length Mismatch\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|il
condition|)
block|{
name|qp
operator|=
operator|&
name|qif
operator|->
name|qf_next
expr_stmt|;
continue|continue;
block|}
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"IP Filter: detaching [%s]\n"
argument_list|,
name|qif
operator|->
name|qf_name
argument_list|)
expr_stmt|;
operator|*
name|qp
operator|=
name|qif
operator|->
name|qf_next
expr_stmt|;
comment|/* 		 * Delete any rules directly associated with this interface 		 */
name|mutex_enter
argument_list|(
operator|&
name|ipf_mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|fp
operator|=
operator|&
name|ipfilter
index|[
literal|0
index|]
index|[
literal|0
index|]
init|;
operator|(
name|f
operator|=
operator|*
name|fp
operator|)
condition|;
control|)
if|if
condition|(
operator|(
name|void
operator|*
operator|)
name|f
operator|->
name|fr_ifa
operator|==
operator|(
name|void
operator|*
operator|)
name|qif
operator|->
name|qf_ill
condition|)
block|{
operator|*
name|fp
operator|=
name|f
operator|->
name|fr_next
expr_stmt|;
name|KFREE
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
else|else
name|fp
operator|=
operator|&
name|f
operator|->
name|fr_next
expr_stmt|;
for|for
control|(
name|fp
operator|=
operator|&
name|ipfilter
index|[
literal|1
index|]
index|[
literal|0
index|]
init|;
operator|(
name|f
operator|=
operator|*
name|fp
operator|)
condition|;
control|)
if|if
condition|(
operator|(
name|void
operator|*
operator|)
name|f
operator|->
name|fr_ifa
operator|==
operator|(
name|void
operator|*
operator|)
name|qif
operator|->
name|qf_ill
condition|)
block|{
operator|*
name|fp
operator|=
name|f
operator|->
name|fr_next
expr_stmt|;
name|KFREE
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
else|else
name|fp
operator|=
operator|&
name|f
operator|->
name|fr_next
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ipf_mutex
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|qif
argument_list|)
expr_stmt|;
name|qif
operator|=
operator|*
name|qp
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
return|return
name|solattach
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/*  * unhook the IP filter from all defined interfaces with IP addresses  */
end_comment

begin_function
name|int
name|soldetach
parameter_list|()
block|{
name|queue_t
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|;
name|qif_t
modifier|*
name|qif
decl_stmt|,
modifier|*
name|qf2
decl_stmt|,
modifier|*
modifier|*
name|qp
decl_stmt|;
name|ill_t
modifier|*
name|il
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
comment|/* 	 * Make two passes, first get rid of all the unknown devices, next 	 * unlink known devices. 	 */
for|for
control|(
name|qp
operator|=
operator|&
name|qif_head
init|;
operator|(
name|qif
operator|=
operator|*
name|qp
operator|)
condition|;
control|)
block|{
for|for
control|(
name|il
operator|=
name|ill_g_head
init|;
name|il
condition|;
name|il
operator|=
name|il
operator|->
name|ill_next
control|)
if|if
condition|(
name|qif
operator|->
name|qf_ill
operator|==
name|il
condition|)
break|break;
if|if
condition|(
name|il
condition|)
block|{
name|qp
operator|=
operator|&
name|qif
operator|->
name|qf_next
expr_stmt|;
continue|continue;
block|}
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"IP Filter: removing [%s]\n"
argument_list|,
name|qif
operator|->
name|qf_name
argument_list|)
expr_stmt|;
operator|*
name|qp
operator|=
name|qif
operator|->
name|qf_next
expr_stmt|;
name|KFREE
argument_list|(
name|qif
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|qif
operator|=
name|qif_head
operator|)
condition|)
block|{
name|qif_head
operator|=
name|qif
operator|->
name|qf_next
expr_stmt|;
for|for
control|(
name|il
operator|=
name|ill_g_head
init|;
name|il
condition|;
name|il
operator|=
name|il
operator|->
name|ill_next
control|)
if|if
condition|(
name|qif
operator|->
name|qf_ill
operator|==
name|il
condition|)
break|break;
if|if
condition|(
name|il
condition|)
block|{
name|in
operator|=
name|il
operator|->
name|ill_rq
expr_stmt|;
name|out
operator|=
name|il
operator|->
name|ill_wq
operator|->
name|q_next
expr_stmt|;
name|printf
argument_list|(
literal|"IP Filter: detaching [%s,%d]\n"
argument_list|,
name|qif
operator|->
name|qf_name
argument_list|,
name|il
operator|->
name|ill_ppa
argument_list|)
expr_stmt|;
name|in
operator|->
name|q_qinfo
operator|->
name|qi_putp
operator|=
name|qif
operator|->
name|qf_inp
expr_stmt|;
comment|/* 			 * and change back if something is still interested 			 * in filtering (read side) on this interface. 			 */
for|for
control|(
name|qf2
operator|=
name|qif_head
init|;
name|qf2
condition|;
name|qf2
operator|=
name|qf2
operator|->
name|qf_next
control|)
if|if
condition|(
name|qf2
operator|->
name|qf_rqinfo
operator|==
name|in
operator|->
name|q_qinfo
condition|)
block|{
name|in
operator|->
name|q_qinfo
operator|->
name|qi_putp
operator|=
name|fr_qin
expr_stmt|;
break|break;
block|}
comment|/* 			 * and the write queue... 			 */
name|out
operator|->
name|q_qinfo
operator|->
name|qi_putp
operator|=
name|qif
operator|->
name|qf_outp
expr_stmt|;
for|for
control|(
name|qf2
operator|=
name|qif_head
init|;
name|qf2
condition|;
name|qf2
operator|=
name|qf2
operator|->
name|qf_next
control|)
if|if
condition|(
name|qf2
operator|->
name|qf_wqinfo
operator|==
name|out
operator|->
name|q_qinfo
condition|)
block|{
name|out
operator|->
name|q_qinfo
operator|->
name|qi_putp
operator|=
name|fr_qout
expr_stmt|;
break|break;
block|}
block|}
name|KFREE
argument_list|(
name|qif
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|ipfs_mutex
argument_list|)
expr_stmt|;
return|return
name|ipldetach
argument_list|()
return|;
block|}
end_function

begin_macro
name|printire
argument_list|(
argument|ire
argument_list|)
end_macro

begin_decl_stmt
name|ire_t
modifier|*
name|ire
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"ire: ll_hdr_mp %x rfq %x stq %x src_addr %x max_frag %d\n"
argument_list|,
name|ire
operator|->
name|ire_ll_hdr_mp
argument_list|,
name|ire
operator|->
name|ire_rfq
argument_list|,
name|ire
operator|->
name|ire_stq
argument_list|,
name|ire
operator|->
name|ire_src_addr
argument_list|,
name|ire
operator|->
name|ire_max_frag
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ire: mask %x addr %x gateway_addr %x type %d\n"
argument_list|,
name|ire
operator|->
name|ire_mask
argument_list|,
name|ire
operator|->
name|ire_addr
argument_list|,
name|ire
operator|->
name|ire_gateway_addr
argument_list|,
name|ire
operator|->
name|ire_type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ire: ll_hdr_length %d ll_hdr_saved_mp %x\n"
argument_list|,
name|ire
operator|->
name|ire_ll_hdr_length
argument_list|,
name|ire
operator|->
name|ire_ll_hdr_saved_mp
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|ipfr_fastroute
parameter_list|(
name|qf
parameter_list|,
name|ip
parameter_list|,
name|mb
parameter_list|,
name|mpp
parameter_list|,
name|fin
parameter_list|,
name|fdp
parameter_list|)
name|qif_t
modifier|*
name|qf
decl_stmt|;
name|ip_t
modifier|*
name|ip
decl_stmt|;
name|mblk_t
modifier|*
name|mb
decl_stmt|,
decl|*
modifier|*
name|mpp
decl_stmt|;
end_function

begin_decl_stmt
name|fr_info_t
modifier|*
name|fin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|frdest_t
modifier|*
name|fdp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|mblk_t
modifier|*
name|mp
init|=
name|NULL
decl_stmt|;
name|struct
name|in_addr
name|dst
decl_stmt|;
name|ire_t
modifier|*
name|ir
decl_stmt|,
modifier|*
name|dir
decl_stmt|;
name|int
name|hlen
init|=
literal|0
decl_stmt|;
name|u_char
modifier|*
name|s
decl_stmt|;
name|queue_t
modifier|*
name|q
init|=
name|NULL
decl_stmt|;
ifndef|#
directive|ifndef
name|sparc
name|u_short
name|__iplen
decl_stmt|,
name|__ipoff
decl_stmt|;
comment|/* 	 * If this is a duplicate mblk then we want ip to point at that 	 * data, not the original, if and only if it is already pointing at 	 * the current mblk data. 	 */
if|if
condition|(
name|ip
operator|==
operator|(
name|ip_t
operator|*
operator|)
name|qf
operator|->
name|qf_m
operator|->
name|b_rptr
operator|&&
name|qf
operator|->
name|qf_m
operator|!=
name|mb
condition|)
name|ip
operator|=
operator|(
name|ip_t
operator|*
operator|)
name|mb
operator|->
name|b_rptr
expr_stmt|;
comment|/* 	 * In fr_precheck(), we modify ip_len and ip_off in an aligned data 	 * area.  However, we only need to change it back if we didn't copy 	 * the IP header data out. 	 */
name|__iplen
operator|=
operator|(
name|u_short
operator|)
name|ip
operator|->
name|ip_len
operator|,
name|__ipoff
operator|=
operator|(
name|u_short
operator|)
name|ip
operator|->
name|ip_off
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|__iplen
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
name|__ipoff
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ip
operator|!=
operator|(
name|ip_t
operator|*
operator|)
name|mb
operator|->
name|b_rptr
condition|)
block|{
name|copyin_mblk
argument_list|(
name|mb
argument_list|,
literal|0
argument_list|,
name|ip
argument_list|,
name|qf
operator|->
name|qf_len
argument_list|)
expr_stmt|;
name|frstats
index|[
name|fin
operator|->
name|fin_out
index|]
operator|.
name|fr_pull
index|[
literal|1
index|]
operator|++
expr_stmt|;
block|}
comment|/* 	 * If there is another M_PROTO, we don't want it 	 */
if|if
condition|(
operator|*
name|mpp
operator|!=
name|mb
condition|)
block|{
operator|(
operator|*
name|mpp
operator|)
operator|->
name|b_cont
operator|=
name|NULL
expr_stmt|;
name|freemsg
argument_list|(
operator|*
name|mpp
argument_list|)
expr_stmt|;
block|}
name|ir
operator|=
operator|(
name|ire_t
operator|*
operator|)
name|fdp
operator|->
name|fd_ifp
expr_stmt|;
if|if
condition|(
name|fdp
operator|->
name|fd_ip
operator|.
name|s_addr
condition|)
name|dst
operator|=
name|fdp
operator|->
name|fd_ip
expr_stmt|;
else|else
name|dst
operator|=
name|fin
operator|->
name|fin_fi
operator|.
name|fi_dst
expr_stmt|;
if|if
condition|(
name|dir
operator|=
name|ire_lookup
argument_list|(
name|dst
operator|.
name|s_addr
argument_list|)
condition|)
if|if
condition|(
operator|!
name|dir
operator|->
name|ire_ll_hdr_mp
operator|||
operator|!
name|dir
operator|->
name|ire_ll_hdr_length
condition|)
name|dir
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|ir
condition|)
name|ir
operator|=
name|dir
expr_stmt|;
if|if
condition|(
name|ir
operator|&&
name|dir
condition|)
block|{
if|if
condition|(
operator|(
name|mp
operator|=
name|dir
operator|->
name|ire_ll_hdr_mp
operator|)
condition|)
block|{
name|hlen
operator|=
name|dir
operator|->
name|ire_ll_hdr_length
expr_stmt|;
name|s
operator|=
name|mb
operator|->
name|b_rptr
expr_stmt|;
if|if
condition|(
name|hlen
operator|&&
operator|(
name|s
operator|-
name|mb
operator|->
name|b_datap
operator|->
name|db_base
operator|)
operator|>=
name|hlen
condition|)
block|{
name|s
operator|-=
name|hlen
expr_stmt|;
name|mb
operator|->
name|b_rptr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|s
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mp
operator|->
name|b_rptr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|s
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mblk_t
modifier|*
name|mp2
decl_stmt|;
name|mp2
operator|=
name|copyb
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mp2
condition|)
goto|goto
name|bad_fastroute
goto|;
name|mp2
operator|->
name|b_cont
operator|=
name|mb
expr_stmt|;
name|mb
operator|=
name|mp2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ir
operator|->
name|ire_stq
condition|)
name|q
operator|=
name|ir
operator|->
name|ire_stq
expr_stmt|;
elseif|else
if|if
condition|(
name|ir
operator|->
name|ire_rfq
condition|)
name|q
operator|=
name|WR
argument_list|(
name|ir
operator|->
name|ire_rfq
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
block|{
name|putnext
argument_list|(
name|q
argument_list|,
name|mb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|bad_fastroute
label|:
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_function
name|void
name|copyout_mblk
parameter_list|(
name|m
parameter_list|,
name|off
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|mblk_t
modifier|*
name|m
decl_stmt|;
name|int
name|off
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|bp
init|=
name|buf
decl_stmt|;
name|int
name|mlen
decl_stmt|,
name|olen
decl_stmt|,
name|clen
decl_stmt|;
for|for
control|(
init|;
name|m
operator|&&
name|len
condition|;
name|m
operator|=
name|m
operator|->
name|b_cont
control|)
block|{
if|if
condition|(
name|MTYPE
argument_list|(
name|m
argument_list|)
operator|!=
name|M_DATA
condition|)
continue|continue;
name|s
operator|=
name|m
operator|->
name|b_rptr
expr_stmt|;
name|mlen
operator|=
operator|(
name|char
operator|*
operator|)
name|m
operator|->
name|b_wptr
operator|-
name|s
expr_stmt|;
name|olen
operator|=
name|MIN
argument_list|(
name|off
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|olen
operator|==
name|mlen
operator|)
operator|||
operator|(
name|olen
operator|<
name|off
operator|)
condition|)
block|{
name|off
operator|-=
name|olen
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|olen
condition|)
block|{
name|off
operator|-=
name|olen
expr_stmt|;
name|s
operator|+=
name|olen
expr_stmt|;
name|mlen
operator|-=
name|olen
expr_stmt|;
block|}
name|clen
operator|=
name|MIN
argument_list|(
name|mlen
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|s
argument_list|,
name|bp
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|len
operator|-=
name|clen
expr_stmt|;
name|bp
operator|+=
name|clen
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|copyin_mblk
parameter_list|(
name|m
parameter_list|,
name|off
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|mblk_t
modifier|*
name|m
decl_stmt|;
name|int
name|off
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|bp
init|=
name|buf
decl_stmt|;
name|int
name|mlen
decl_stmt|,
name|olen
decl_stmt|,
name|clen
decl_stmt|;
for|for
control|(
init|;
name|m
operator|&&
name|len
condition|;
name|m
operator|=
name|m
operator|->
name|b_cont
control|)
block|{
if|if
condition|(
name|MTYPE
argument_list|(
name|m
argument_list|)
operator|!=
name|M_DATA
condition|)
continue|continue;
name|s
operator|=
name|m
operator|->
name|b_rptr
expr_stmt|;
name|mlen
operator|=
operator|(
name|char
operator|*
operator|)
name|m
operator|->
name|b_wptr
operator|-
name|s
expr_stmt|;
name|olen
operator|=
name|MIN
argument_list|(
name|off
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|olen
operator|==
name|mlen
operator|)
operator|||
operator|(
name|olen
operator|<
name|off
operator|)
condition|)
block|{
name|off
operator|-=
name|olen
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|olen
condition|)
block|{
name|off
operator|-=
name|olen
expr_stmt|;
name|s
operator|+=
name|olen
expr_stmt|;
name|mlen
operator|-=
name|olen
expr_stmt|;
block|}
name|clen
operator|=
name|MIN
argument_list|(
name|mlen
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bp
argument_list|,
name|s
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|len
operator|-=
name|clen
expr_stmt|;
name|bp
operator|+=
name|clen
expr_stmt|;
block|}
block|}
end_function

end_unit

