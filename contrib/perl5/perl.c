begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    perl.c  *  *    Copyright (c) 1987-2000 Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * "A ship then new they built for him/of mithril and of elven glass" --Bilbo  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_define
define|#
directive|define
name|PERL_IN_PERL_C
end_define

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_include
include|#
directive|include
file|"patchlevel.h"
end_include

begin_comment
comment|/* for local_patches */
end_comment

begin_comment
comment|/* XXX If this causes problems, set i_unistd=undef in the hint file.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|I_UNISTD
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|STANDARD_C
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAS_GETENV_PROTOTYPE
argument_list|)
end_if

begin_function_decl
name|char
modifier|*
name|getenv
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Usually in<stdlib.h> */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|I32
name|read_e_script
parameter_list|(
name|pTHXo_
name|int
name|idx
parameter_list|,
name|SV
modifier|*
name|buf_sv
parameter_list|,
name|int
name|maxlen
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|IAMSUID
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|DOSUID
end_ifndef

begin_define
define|#
directive|define
name|DOSUID
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SETUID_SCRIPTS_ARE_SECURE_NOW
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|DOSUID
end_ifdef

begin_undef
undef|#
directive|undef
name|DOSUID
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_OBJECT
end_ifdef

begin_define
define|#
directive|define
name|perl_construct
value|Perl_construct
end_define

begin_define
define|#
directive|define
name|perl_parse
value|Perl_parse
end_define

begin_define
define|#
directive|define
name|perl_run
value|Perl_run
end_define

begin_define
define|#
directive|define
name|perl_destruct
value|Perl_destruct
end_define

begin_define
define|#
directive|define
name|perl_free
value|Perl_free
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_THREADS
argument_list|)
end_if

begin_define
define|#
directive|define
name|INIT_TLS_AND_INTERP
define|\
value|STMT_START {				\ 	if (!PL_curinterp) {			\ 	    PERL_SET_INTERP(my_perl);		\ 	    INIT_THREADS;			\ 	    ALLOC_THREAD_KEY;			\ 	}					\     } STMT_END
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_ITHREADS
argument_list|)
end_if

begin_define
define|#
directive|define
name|INIT_TLS_AND_INTERP
define|\
value|STMT_START {				\ 	if (!PL_curinterp) {			\ 	    PERL_SET_INTERP(my_perl);		\ 	    INIT_THREADS;			\ 	    ALLOC_THREAD_KEY;			\ 	    PERL_SET_THX(my_perl);		\ 	    OP_REFCNT_INIT;			\ 	}					\ 	else {					\ 	    PERL_SET_THX(my_perl);		\ 	}					\     } STMT_END
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INIT_TLS_AND_INTERP
define|\
value|STMT_START {				\ 	if (!PL_curinterp) {			\ 	    PERL_SET_INTERP(my_perl);		\ 	}					\ 	PERL_SET_THX(my_perl);			\     } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_IMPLICIT_SYS
end_ifdef

begin_function
name|PerlInterpreter
modifier|*
name|perl_alloc_using
parameter_list|(
name|struct
name|IPerlMem
modifier|*
name|ipM
parameter_list|,
name|struct
name|IPerlMem
modifier|*
name|ipMS
parameter_list|,
name|struct
name|IPerlMem
modifier|*
name|ipMP
parameter_list|,
name|struct
name|IPerlEnv
modifier|*
name|ipE
parameter_list|,
name|struct
name|IPerlStdIO
modifier|*
name|ipStd
parameter_list|,
name|struct
name|IPerlLIO
modifier|*
name|ipLIO
parameter_list|,
name|struct
name|IPerlDir
modifier|*
name|ipD
parameter_list|,
name|struct
name|IPerlSock
modifier|*
name|ipS
parameter_list|,
name|struct
name|IPerlProc
modifier|*
name|ipP
parameter_list|)
block|{
name|PerlInterpreter
modifier|*
name|my_perl
decl_stmt|;
ifdef|#
directive|ifdef
name|PERL_OBJECT
name|my_perl
operator|=
operator|(
name|PerlInterpreter
operator|*
operator|)
name|new
argument_list|(
argument|ipM
argument_list|)
name|CPerlObj
argument_list|(
name|ipM
argument_list|,
name|ipMS
argument_list|,
name|ipMP
argument_list|,
name|ipE
argument_list|,
name|ipStd
argument_list|,
name|ipLIO
argument_list|,
name|ipD
argument_list|,
name|ipS
argument_list|,
name|ipP
argument_list|)
expr_stmt|;
name|INIT_TLS_AND_INTERP
expr_stmt|;
else|#
directive|else
comment|/* New() needs interpreter, so call malloc() instead */
name|my_perl
operator|=
operator|(
name|PerlInterpreter
operator|*
operator|)
call|(
modifier|*
name|ipM
operator|->
name|pMalloc
call|)
argument_list|(
name|ipM
argument_list|,
sizeof|sizeof
argument_list|(
name|PerlInterpreter
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_TLS_AND_INTERP
expr_stmt|;
name|Zero
argument_list|(
name|my_perl
argument_list|,
literal|1
argument_list|,
name|PerlInterpreter
argument_list|)
expr_stmt|;
name|PL_Mem
operator|=
name|ipM
expr_stmt|;
name|PL_MemShared
operator|=
name|ipMS
expr_stmt|;
name|PL_MemParse
operator|=
name|ipMP
expr_stmt|;
name|PL_Env
operator|=
name|ipE
expr_stmt|;
name|PL_StdIO
operator|=
name|ipStd
expr_stmt|;
name|PL_LIO
operator|=
name|ipLIO
expr_stmt|;
name|PL_Dir
operator|=
name|ipD
expr_stmt|;
name|PL_Sock
operator|=
name|ipS
expr_stmt|;
name|PL_Proc
operator|=
name|ipP
expr_stmt|;
endif|#
directive|endif
return|return
name|my_perl
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* =for apidoc perl_alloc  Allocates a new Perl interpreter.  See L<perlembed>.  =cut */
end_comment

begin_function
name|PerlInterpreter
modifier|*
name|perl_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|PerlInterpreter
modifier|*
name|my_perl
decl_stmt|;
comment|/* New() needs interpreter, so call malloc() instead */
name|my_perl
operator|=
operator|(
name|PerlInterpreter
operator|*
operator|)
name|PerlMem_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|PerlInterpreter
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_TLS_AND_INTERP
expr_stmt|;
name|Zero
argument_list|(
name|my_perl
argument_list|,
literal|1
argument_list|,
name|PerlInterpreter
argument_list|)
expr_stmt|;
return|return
name|my_perl
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PERL_IMPLICIT_SYS */
end_comment

begin_comment
comment|/* =for apidoc perl_construct  Initializes a new Perl interpreter.  See L<perlembed>.  =cut */
end_comment

begin_function
name|void
name|perl_construct
parameter_list|(
name|pTHXx
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_THREADS
name|int
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|FAKE_THREADS
name|struct
name|perl_thread
modifier|*
name|thr
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* FAKE_THREADS */
endif|#
directive|endif
comment|/* USE_THREADS */
ifdef|#
directive|ifdef
name|MULTIPLICITY
name|init_interp
argument_list|()
expr_stmt|;
name|PL_perl_destruct_level
operator|=
literal|1
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|PL_perl_destruct_level
operator|>
literal|0
condition|)
name|init_interp
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Init the real globals (and main thread)? */
if|if
condition|(
operator|!
name|PL_linestr
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_THREADS
name|MUTEX_INIT
argument_list|(
operator|&
name|PL_sv_mutex
argument_list|)
expr_stmt|;
comment|/* 	 * Safe to use basic SV functions from now on (though 	 * not things like mortals or tainting yet). 	 */
name|MUTEX_INIT
argument_list|(
operator|&
name|PL_eval_mutex
argument_list|)
expr_stmt|;
name|COND_INIT
argument_list|(
operator|&
name|PL_eval_cond
argument_list|)
expr_stmt|;
name|MUTEX_INIT
argument_list|(
operator|&
name|PL_threads_mutex
argument_list|)
expr_stmt|;
name|COND_INIT
argument_list|(
operator|&
name|PL_nthreads_cond
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EMULATE_ATOMIC_REFCOUNTS
name|MUTEX_INIT
argument_list|(
operator|&
name|PL_svref_mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EMULATE_ATOMIC_REFCOUNTS */
name|MUTEX_INIT
argument_list|(
operator|&
name|PL_cred_mutex
argument_list|)
expr_stmt|;
name|thr
operator|=
name|init_main_thread
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
ifdef|#
directive|ifdef
name|PERL_FLEXIBLE_EXCEPTIONS
name|PL_protect
operator|=
name|MEMBER_TO_FPTR
argument_list|(
name|Perl_default_protect
argument_list|)
expr_stmt|;
comment|/* for exceptions */
endif|#
directive|endif
name|PL_curcop
operator|=
operator|&
name|PL_compiling
expr_stmt|;
comment|/* needed by ckWARN, right away */
name|PL_linestr
operator|=
name|NEWSV
argument_list|(
literal|65
argument_list|,
literal|79
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
name|PL_linestr
argument_list|,
name|SVt_PVIV
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvREADONLY
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
condition|)
block|{
comment|/* set read-only and try to insure than we wont see REFCNT==0 	       very often */
name|SvREADONLY_on
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
name|SvREFCNT
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
operator|=
operator|(
operator|~
operator|(
name|U32
operator|)
literal|0
operator|)
operator|/
literal|2
expr_stmt|;
name|sv_setpv
argument_list|(
operator|&
name|PL_sv_no
argument_list|,
name|PL_No
argument_list|)
expr_stmt|;
name|SvNV
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
expr_stmt|;
name|SvREADONLY_on
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
expr_stmt|;
name|SvREFCNT
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
operator|=
operator|(
operator|~
operator|(
name|U32
operator|)
literal|0
operator|)
operator|/
literal|2
expr_stmt|;
name|sv_setpv
argument_list|(
operator|&
name|PL_sv_yes
argument_list|,
name|PL_Yes
argument_list|)
expr_stmt|;
name|SvNV
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
expr_stmt|;
name|SvREADONLY_on
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
expr_stmt|;
name|SvREFCNT
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
operator|=
operator|(
operator|~
operator|(
name|U32
operator|)
literal|0
operator|)
operator|/
literal|2
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PERL_OBJECT
comment|/* TODO: */
comment|/* PL_sighandlerp = sighandler; */
else|#
directive|else
name|PL_sighandlerp
operator|=
name|Perl_sighandler
expr_stmt|;
endif|#
directive|endif
name|PL_pidstatus
operator|=
name|newHV
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|MSDOS
comment|/* 	 * There is no way we can refer to them from Perl so close them to save 	 * space.  The other alternative would be to provide STDAUX and STDPRN 	 * filehandles. 	 */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|stdaux
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|stdprn
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|PL_nrs
operator|=
name|newSVpvn
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PL_rs
operator|=
name|SvREFCNT_inc
argument_list|(
name|PL_nrs
argument_list|)
expr_stmt|;
name|init_stacks
argument_list|()
expr_stmt|;
name|init_ids
argument_list|()
expr_stmt|;
name|PL_lex_state
operator|=
name|LEX_NOTPARSING
expr_stmt|;
name|JMPENV_BOOTSTRAP
expr_stmt|;
name|STATUS_ALL_SUCCESS
expr_stmt|;
name|init_i18nl10n
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|SET_NUMERIC_STANDARD
argument_list|()
expr_stmt|;
block|{
name|U8
modifier|*
name|s
decl_stmt|;
name|PL_patchlevel
operator|=
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|PL_patchlevel
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
if|if
condition|(
name|PERL_REVISION
operator|>
literal|127
operator|||
name|PERL_VERSION
operator|>
literal|127
operator|||
name|PERL_SUBVERSION
operator|>
literal|127
condition|)
name|SvGROW
argument_list|(
name|PL_patchlevel
argument_list|,
name|UTF8_MAXLEN
operator|*
literal|3
operator|+
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|U8
operator|*
operator|)
name|SvPVX
argument_list|(
name|PL_patchlevel
argument_list|)
expr_stmt|;
name|s
operator|=
name|uv_to_utf8
argument_list|(
name|s
argument_list|,
operator|(
name|UV
operator|)
name|PERL_REVISION
argument_list|)
expr_stmt|;
name|s
operator|=
name|uv_to_utf8
argument_list|(
name|s
argument_list|,
operator|(
name|UV
operator|)
name|PERL_VERSION
argument_list|)
expr_stmt|;
name|s
operator|=
name|uv_to_utf8
argument_list|(
name|s
argument_list|,
operator|(
name|UV
operator|)
name|PERL_SUBVERSION
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR_set
argument_list|(
name|PL_patchlevel
argument_list|,
name|s
operator|-
operator|(
name|U8
operator|*
operator|)
name|SvPVX
argument_list|(
name|PL_patchlevel
argument_list|)
argument_list|)
expr_stmt|;
name|SvPOK_on
argument_list|(
name|PL_patchlevel
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|PL_patchlevel
argument_list|)
operator|=
operator|(
name|NV
operator|)
name|PERL_REVISION
operator|+
operator|(
operator|(
name|NV
operator|)
name|PERL_VERSION
operator|/
operator|(
name|NV
operator|)
literal|1000
operator|)
if|#
directive|if
name|defined
argument_list|(
name|PERL_SUBVERSION
argument_list|)
operator|&&
name|PERL_SUBVERSION
operator|>
literal|0
operator|+
operator|(
operator|(
name|NV
operator|)
name|PERL_SUBVERSION
operator|/
operator|(
name|NV
operator|)
literal|1000000
operator|)
endif|#
directive|endif
expr_stmt|;
name|SvNOK_on
argument_list|(
name|PL_patchlevel
argument_list|)
expr_stmt|;
comment|/* dual valued */
name|SvUTF8_on
argument_list|(
name|PL_patchlevel
argument_list|)
expr_stmt|;
name|SvREADONLY_on
argument_list|(
name|PL_patchlevel
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|LOCAL_PATCH_COUNT
argument_list|)
name|PL_localpatches
operator|=
name|local_patches
expr_stmt|;
comment|/* For possible -v */
endif|#
directive|endif
name|PerlIO_init
argument_list|()
expr_stmt|;
comment|/* Hook to IO system */
name|PL_fdpid
operator|=
name|newAV
argument_list|()
expr_stmt|;
comment|/* for remembering popen pids by fd */
name|PL_modglobal
operator|=
name|newHV
argument_list|()
expr_stmt|;
comment|/* pointers to per-interpreter module globals */
name|ENTER
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc perl_destruct  Shuts down a Perl interpreter.  See L<perlembed>.  =cut */
end_comment

begin_function
name|void
name|perl_destruct
parameter_list|(
name|pTHXx
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|int
name|destruct_level
decl_stmt|;
comment|/* 0=none, 1=full, 2=full with checks */
name|I32
name|last_sv_count
decl_stmt|;
name|HV
modifier|*
name|hv
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|Thread
name|t
decl_stmt|;
name|dTHX
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
comment|/* wait for all pseudo-forked children to finish */
name|PERL_WAIT_FOR_CHILDREN
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
ifndef|#
directive|ifndef
name|FAKE_THREADS
comment|/* Pass 1 on any remaining threads: detach joinables, join zombies */
name|retry_cleanup
label|:
name|MUTEX_LOCK
argument_list|(
operator|&
name|PL_threads_mutex
argument_list|)
expr_stmt|;
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"perl_destruct: waiting for %d threads...\n"
argument_list|,
name|PL_nthreads
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|thr
operator|->
name|next
init|;
name|t
operator|!=
name|thr
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
name|MUTEX_LOCK
argument_list|(
operator|&
name|t
operator|->
name|mutex
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ThrSTATE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|AV
modifier|*
name|av
decl_stmt|;
case|case
name|THRf_ZOMBIE
case|:
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"perl_destruct: joining zombie %p\n"
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ThrSETSTATE
argument_list|(
name|t
argument_list|,
name|THRf_DEAD
argument_list|)
expr_stmt|;
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|t
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|PL_nthreads
operator|--
expr_stmt|;
comment|/* 	     * The SvREFCNT_dec below may take a long time (e.g. av 	     * may contain an object scalar whose destructor gets 	     * called) so we have to unlock threads_mutex and start 	     * all over again. 	     */
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|PL_threads_mutex
argument_list|)
expr_stmt|;
name|JOIN
argument_list|(
name|t
argument_list|,
operator|&
name|av
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|)
expr_stmt|;
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"perl_destruct: joined zombie %p OK\n"
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|retry_cleanup
goto|;
case|case
name|THRf_R_JOINABLE
case|:
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"perl_destruct: detaching thread %p\n"
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ThrSETSTATE
argument_list|(
name|t
argument_list|,
name|THRf_R_DETACHED
argument_list|)
expr_stmt|;
comment|/*  	     * We unlock threads_mutex and t->mutex in the opposite order 	     * from which we locked them just so that DETACH won't 	     * deadlock if it panics. It's only a breach of good style 	     * not a bug since they are unlocks not locks. 	     */
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|PL_threads_mutex
argument_list|)
expr_stmt|;
name|DETACH
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|t
operator|->
name|mutex
argument_list|)
expr_stmt|;
goto|goto
name|retry_cleanup
goto|;
default|default:
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"perl_destruct: ignoring %p (state %u)\n"
argument_list|,
name|t
argument_list|,
name|ThrSTATE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|t
operator|->
name|mutex
argument_list|)
expr_stmt|;
comment|/* fall through and out */
block|}
block|}
comment|/* We leave the above "Pass 1" loop with threads_mutex still locked */
comment|/* Pass 2 on remaining threads: wait for the thread count to drop to one */
while|while
condition|(
name|PL_nthreads
operator|>
literal|1
condition|)
block|{
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"perl_destruct: final wait for %d threads\n"
argument_list|,
name|PL_nthreads
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|COND_WAIT
argument_list|(
operator|&
name|PL_nthreads_cond
argument_list|,
operator|&
name|PL_threads_mutex
argument_list|)
expr_stmt|;
block|}
comment|/* At this point, we're the last thread */
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|PL_threads_mutex
argument_list|)
expr_stmt|;
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"perl_destruct: armageddon has arrived\n"
argument_list|)
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|PL_threads_mutex
argument_list|)
expr_stmt|;
name|COND_DESTROY
argument_list|(
operator|&
name|PL_nthreads_cond
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(FAKE_THREADS) */
endif|#
directive|endif
comment|/* USE_THREADS */
name|destruct_level
operator|=
name|PL_perl_destruct_level
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|PerlEnv_getenv
argument_list|(
literal|"PERL_DESTRUCT_LEVEL"
argument_list|)
operator|)
condition|)
block|{
name|int
name|i
init|=
name|atoi
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|destruct_level
operator|<
name|i
condition|)
name|destruct_level
operator|=
name|i
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|LEAVE
expr_stmt|;
name|FREETMPS
expr_stmt|;
comment|/* We must account for everything.  */
comment|/* Destroy the main CV and syntax tree */
if|if
condition|(
name|PL_main_root
condition|)
block|{
name|PL_curpad
operator|=
name|AvARRAY
argument_list|(
name|PL_comppad
argument_list|)
expr_stmt|;
name|op_free
argument_list|(
name|PL_main_root
argument_list|)
expr_stmt|;
name|PL_main_root
operator|=
name|Nullop
expr_stmt|;
block|}
name|PL_curcop
operator|=
operator|&
name|PL_compiling
expr_stmt|;
name|PL_main_start
operator|=
name|Nullop
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_main_cv
argument_list|)
expr_stmt|;
name|PL_main_cv
operator|=
name|Nullcv
expr_stmt|;
name|PL_dirty
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|PL_sv_objcount
condition|)
block|{
comment|/* 	 * Try to destruct global references.  We do this first so that the 	 * destructors and destructees still exist.  Some sv's might remain. 	 * Non-referenced objects are on their own. 	 */
name|sv_clean_objs
argument_list|()
expr_stmt|;
block|}
comment|/* unhook hooks which will soon be, or use, destroyed data */
name|SvREFCNT_dec
argument_list|(
name|PL_warnhook
argument_list|)
expr_stmt|;
name|PL_warnhook
operator|=
name|Nullsv
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_diehook
argument_list|)
expr_stmt|;
name|PL_diehook
operator|=
name|Nullsv
expr_stmt|;
comment|/* call exit list functions */
while|while
condition|(
name|PL_exitlistlen
operator|--
operator|>
literal|0
condition|)
name|PL_exitlist
index|[
name|PL_exitlistlen
index|]
operator|.
name|fn
argument_list|(
argument|aTHXo_ PL_exitlist[PL_exitlistlen].ptr
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|PL_exitlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|destruct_level
operator|==
literal|0
condition|)
block|{
name|DEBUG_P
argument_list|(
name|debprofdump
argument_list|()
argument_list|)
expr_stmt|;
comment|/* The exit() function will do everything that needs doing. */
return|return;
block|}
comment|/* loosen bonds of global variables */
if|if
condition|(
name|PL_rsfp
condition|)
block|{
operator|(
name|void
operator|)
name|PerlIO_close
argument_list|(
name|PL_rsfp
argument_list|)
expr_stmt|;
name|PL_rsfp
operator|=
name|Nullfp
expr_stmt|;
block|}
comment|/* Filters for program text */
name|SvREFCNT_dec
argument_list|(
name|PL_rsfp_filters
argument_list|)
expr_stmt|;
name|PL_rsfp_filters
operator|=
name|Nullav
expr_stmt|;
comment|/* switches */
name|PL_preprocess
operator|=
name|FALSE
expr_stmt|;
name|PL_minus_n
operator|=
name|FALSE
expr_stmt|;
name|PL_minus_p
operator|=
name|FALSE
expr_stmt|;
name|PL_minus_l
operator|=
name|FALSE
expr_stmt|;
name|PL_minus_a
operator|=
name|FALSE
expr_stmt|;
name|PL_minus_F
operator|=
name|FALSE
expr_stmt|;
name|PL_doswitches
operator|=
name|FALSE
expr_stmt|;
name|PL_dowarn
operator|=
name|G_WARN_OFF
expr_stmt|;
name|PL_doextract
operator|=
name|FALSE
expr_stmt|;
name|PL_sawampersand
operator|=
name|FALSE
expr_stmt|;
comment|/* must save all match strings */
name|PL_unsafe
operator|=
name|FALSE
expr_stmt|;
name|Safefree
argument_list|(
name|PL_inplace
argument_list|)
expr_stmt|;
name|PL_inplace
operator|=
name|Nullch
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_patchlevel
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_e_script
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|PL_e_script
argument_list|)
expr_stmt|;
name|PL_e_script
operator|=
name|Nullsv
expr_stmt|;
block|}
comment|/* magical thingies */
name|Safefree
argument_list|(
name|PL_ofs
argument_list|)
expr_stmt|;
comment|/* $, */
name|PL_ofs
operator|=
name|Nullch
expr_stmt|;
name|Safefree
argument_list|(
name|PL_ors
argument_list|)
expr_stmt|;
comment|/* $\ */
name|PL_ors
operator|=
name|Nullch
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_rs
argument_list|)
expr_stmt|;
comment|/* $/ */
name|PL_rs
operator|=
name|Nullsv
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_nrs
argument_list|)
expr_stmt|;
comment|/* $/ helper */
name|PL_nrs
operator|=
name|Nullsv
expr_stmt|;
name|PL_multiline
operator|=
literal|0
expr_stmt|;
comment|/* $* */
name|Safefree
argument_list|(
name|PL_osname
argument_list|)
expr_stmt|;
comment|/* $^O */
name|PL_osname
operator|=
name|Nullch
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_statname
argument_list|)
expr_stmt|;
name|PL_statname
operator|=
name|Nullsv
expr_stmt|;
name|PL_statgv
operator|=
name|Nullgv
expr_stmt|;
comment|/* defgv, aka *_ should be taken care of elsewhere */
comment|/* clean up after study() */
name|SvREFCNT_dec
argument_list|(
name|PL_lastscream
argument_list|)
expr_stmt|;
name|PL_lastscream
operator|=
name|Nullsv
expr_stmt|;
name|Safefree
argument_list|(
name|PL_screamfirst
argument_list|)
expr_stmt|;
name|PL_screamfirst
operator|=
literal|0
expr_stmt|;
name|Safefree
argument_list|(
name|PL_screamnext
argument_list|)
expr_stmt|;
name|PL_screamnext
operator|=
literal|0
expr_stmt|;
comment|/* float buffer */
name|Safefree
argument_list|(
name|PL_efloatbuf
argument_list|)
expr_stmt|;
name|PL_efloatbuf
operator|=
name|Nullch
expr_stmt|;
name|PL_efloatsize
operator|=
literal|0
expr_stmt|;
comment|/* startup and shutdown function lists */
name|SvREFCNT_dec
argument_list|(
name|PL_beginav
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_endav
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_checkav
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_initav
argument_list|)
expr_stmt|;
name|PL_beginav
operator|=
name|Nullav
expr_stmt|;
name|PL_endav
operator|=
name|Nullav
expr_stmt|;
name|PL_checkav
operator|=
name|Nullav
expr_stmt|;
name|PL_initav
operator|=
name|Nullav
expr_stmt|;
comment|/* shortcuts just get cleared */
name|PL_envgv
operator|=
name|Nullgv
expr_stmt|;
name|PL_incgv
operator|=
name|Nullgv
expr_stmt|;
name|PL_hintgv
operator|=
name|Nullgv
expr_stmt|;
name|PL_errgv
operator|=
name|Nullgv
expr_stmt|;
name|PL_argvgv
operator|=
name|Nullgv
expr_stmt|;
name|PL_argvoutgv
operator|=
name|Nullgv
expr_stmt|;
name|PL_stdingv
operator|=
name|Nullgv
expr_stmt|;
name|PL_stderrgv
operator|=
name|Nullgv
expr_stmt|;
name|PL_last_in_gv
operator|=
name|Nullgv
expr_stmt|;
name|PL_replgv
operator|=
name|Nullgv
expr_stmt|;
name|PL_debstash
operator|=
name|Nullhv
expr_stmt|;
comment|/* reset so print() ends up where we expect */
name|setdefout
argument_list|(
name|Nullgv
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_argvout_stack
argument_list|)
expr_stmt|;
name|PL_argvout_stack
operator|=
name|Nullav
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_modglobal
argument_list|)
expr_stmt|;
name|PL_modglobal
operator|=
name|Nullhv
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_preambleav
argument_list|)
expr_stmt|;
name|PL_preambleav
operator|=
name|Nullav
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_subname
argument_list|)
expr_stmt|;
name|PL_subname
operator|=
name|Nullsv
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_linestr
operator|=
name|Nullsv
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_pidstatus
argument_list|)
expr_stmt|;
name|PL_pidstatus
operator|=
name|Nullhv
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_toptarget
argument_list|)
expr_stmt|;
name|PL_toptarget
operator|=
name|Nullsv
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_bodytarget
argument_list|)
expr_stmt|;
name|PL_bodytarget
operator|=
name|Nullsv
expr_stmt|;
name|PL_formtarget
operator|=
name|Nullsv
expr_stmt|;
comment|/* free locale stuff */
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
name|Safefree
argument_list|(
name|PL_collation_name
argument_list|)
expr_stmt|;
name|PL_collation_name
operator|=
name|Nullch
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
name|Safefree
argument_list|(
name|PL_numeric_name
argument_list|)
expr_stmt|;
name|PL_numeric_name
operator|=
name|Nullch
expr_stmt|;
endif|#
directive|endif
comment|/* clear utf8 character classes */
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_alnum
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_alnumc
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_ascii
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_alpha
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_space
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_cntrl
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_graph
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_digit
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_upper
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_lower
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_print
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_punct
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_xdigit
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_mark
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_toupper
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_tolower
argument_list|)
expr_stmt|;
name|PL_utf8_alnum
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_alnumc
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_ascii
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_alpha
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_space
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_cntrl
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_graph
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_digit
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_upper
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_lower
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_print
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_punct
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_xdigit
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_mark
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_toupper
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_totitle
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_tolower
operator|=
name|Nullsv
expr_stmt|;
if|if
condition|(
operator|!
name|specialWARN
argument_list|(
name|PL_compiling
operator|.
name|cop_warnings
argument_list|)
condition|)
name|SvREFCNT_dec
argument_list|(
name|PL_compiling
operator|.
name|cop_warnings
argument_list|)
expr_stmt|;
name|PL_compiling
operator|.
name|cop_warnings
operator|=
name|Nullsv
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_ITHREADS
name|SvREFCNT_dec
argument_list|(
name|CopFILEGV
argument_list|(
operator|&
name|PL_compiling
argument_list|)
argument_list|)
expr_stmt|;
name|CopFILEGV_set
argument_list|(
operator|&
name|PL_compiling
argument_list|,
name|Nullgv
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Prepare to destruct main symbol table.  */
name|hv
operator|=
name|PL_defstash
expr_stmt|;
name|PL_defstash
operator|=
literal|0
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_curstname
argument_list|)
expr_stmt|;
name|PL_curstname
operator|=
name|Nullsv
expr_stmt|;
comment|/* clear queued errors */
name|SvREFCNT_dec
argument_list|(
name|PL_errors
argument_list|)
expr_stmt|;
name|PL_errors
operator|=
name|Nullsv
expr_stmt|;
name|FREETMPS
expr_stmt|;
if|if
condition|(
name|destruct_level
operator|>=
literal|2
operator|&&
name|ckWARN_d
argument_list|(
name|WARN_INTERNAL
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_scopestack_ix
operator|!=
literal|0
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INTERNAL
argument_list|,
literal|"Unbalanced scopes: %ld more ENTERs than LEAVEs\n"
argument_list|,
argument|(long)PL_scopestack_ix
argument_list|)
empty_stmt|;
if|if
condition|(
name|PL_savestack_ix
operator|!=
literal|0
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INTERNAL
argument_list|,
literal|"Unbalanced saves: %ld more saves than restores\n"
argument_list|,
argument|(long)PL_savestack_ix
argument_list|)
empty_stmt|;
if|if
condition|(
name|PL_tmps_floor
operator|!=
operator|-
literal|1
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INTERNAL
argument_list|,
literal|"Unbalanced tmps: %ld more allocs than frees\n"
argument_list|,
argument|(long)PL_tmps_floor +
literal|1
argument_list|)
empty_stmt|;
if|if
condition|(
name|cxstack_ix
operator|!=
operator|-
literal|1
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INTERNAL
argument_list|,
literal|"Unbalanced context: %ld more PUSHes than POPs\n"
argument_list|,
argument|(long)cxstack_ix +
literal|1
argument_list|)
empty_stmt|;
block|}
comment|/* Now absolutely destruct everything, somehow or other, loops or no. */
name|last_sv_count
operator|=
literal|0
expr_stmt|;
name|SvFLAGS
argument_list|(
name|PL_fdpid
argument_list|)
operator||=
name|SVTYPEMASK
expr_stmt|;
comment|/* don't clean out pid table now */
name|SvFLAGS
argument_list|(
name|PL_strtab
argument_list|)
operator||=
name|SVTYPEMASK
expr_stmt|;
comment|/* don't clean out strtab now */
while|while
condition|(
name|PL_sv_count
operator|!=
literal|0
operator|&&
name|PL_sv_count
operator|!=
name|last_sv_count
condition|)
block|{
name|last_sv_count
operator|=
name|PL_sv_count
expr_stmt|;
name|sv_clean_all
argument_list|()
expr_stmt|;
block|}
name|SvFLAGS
argument_list|(
name|PL_fdpid
argument_list|)
operator|&=
operator|~
name|SVTYPEMASK
expr_stmt|;
name|SvFLAGS
argument_list|(
name|PL_fdpid
argument_list|)
operator||=
name|SVt_PVAV
expr_stmt|;
name|SvFLAGS
argument_list|(
name|PL_strtab
argument_list|)
operator|&=
operator|~
name|SVTYPEMASK
expr_stmt|;
name|SvFLAGS
argument_list|(
name|PL_strtab
argument_list|)
operator||=
name|SVt_PVHV
expr_stmt|;
name|AvREAL_off
argument_list|(
name|PL_fdpid
argument_list|)
expr_stmt|;
comment|/* no surviving entries */
name|SvREFCNT_dec
argument_list|(
name|PL_fdpid
argument_list|)
expr_stmt|;
comment|/* needed in io_close() */
name|PL_fdpid
operator|=
name|Nullav
expr_stmt|;
comment|/* Destruct the global string table. */
block|{
comment|/* Yell and reset the HeVAL() slots that are still holding refcounts, 	 * so that sv_free() won't fail on them. 	 */
name|I32
name|riter
decl_stmt|;
name|I32
name|max
decl_stmt|;
name|HE
modifier|*
name|hent
decl_stmt|;
name|HE
modifier|*
modifier|*
name|array
decl_stmt|;
name|riter
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|HvMAX
argument_list|(
name|PL_strtab
argument_list|)
expr_stmt|;
name|array
operator|=
name|HvARRAY
argument_list|(
name|PL_strtab
argument_list|)
expr_stmt|;
name|hent
operator|=
name|array
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|hent
operator|&&
name|ckWARN_d
argument_list|(
name|WARN_INTERNAL
argument_list|)
condition|)
block|{
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INTERNAL
argument_list|,
literal|"Unbalanced string table refcount: (%d) for \"%s\""
argument_list|,
argument|HeVAL(hent) - Nullsv
argument_list|,
argument|HeKEY(hent)
argument_list|)
empty_stmt|;
name|HeVAL
argument_list|(
name|hent
argument_list|)
operator|=
name|Nullsv
expr_stmt|;
name|hent
operator|=
name|HeNEXT
argument_list|(
name|hent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hent
condition|)
block|{
if|if
condition|(
operator|++
name|riter
operator|>
name|max
condition|)
break|break;
name|hent
operator|=
name|array
index|[
name|riter
index|]
expr_stmt|;
block|}
block|}
block|}
name|SvREFCNT_dec
argument_list|(
name|PL_strtab
argument_list|)
expr_stmt|;
comment|/* free special SVs */
name|SvREFCNT
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
operator|=
literal|0
expr_stmt|;
name|sv_clear
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
expr_stmt|;
name|SvANY
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|SvFLAGS
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvREFCNT
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
operator|=
literal|0
expr_stmt|;
name|sv_clear
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
expr_stmt|;
name|SvANY
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|SvFLAGS
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvREFCNT
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvREADONLY_off
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_sv_count
operator|!=
literal|0
operator|&&
name|ckWARN_d
argument_list|(
name|WARN_INTERNAL
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INTERNAL
argument_list|,
literal|"Scalars leaked: %ld\n"
argument_list|,
argument|(long)PL_sv_count
argument_list|)
empty_stmt|;
name|sv_free_arenas
argument_list|()
expr_stmt|;
comment|/* No SVs have survived, need to clean out */
name|Safefree
argument_list|(
name|PL_origfilename
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|PL_reg_start_tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_reg_curpm
condition|)
name|Safefree
argument_list|(
name|PL_reg_curpm
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|PL_reg_poscache
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|HeKEY_hek
argument_list|(
operator|&
name|PL_hv_fetch_ent_mh
argument_list|)
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|PL_op_mask
argument_list|)
expr_stmt|;
name|nuke_stacks
argument_list|()
expr_stmt|;
name|PL_hints
operator|=
literal|0
expr_stmt|;
comment|/* Reset hints. Should hints be per-interpreter ? */
name|DEBUG_P
argument_list|(
name|debprofdump
argument_list|()
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|MUTEX_DESTROY
argument_list|(
operator|&
name|PL_strtab_mutex
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|PL_sv_mutex
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|PL_eval_mutex
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|PL_cred_mutex
argument_list|)
expr_stmt|;
name|COND_DESTROY
argument_list|(
operator|&
name|PL_eval_cond
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EMULATE_ATOMIC_REFCOUNTS
name|MUTEX_DESTROY
argument_list|(
operator|&
name|PL_svref_mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EMULATE_ATOMIC_REFCOUNTS */
comment|/* As the penultimate thing, free the non-arena SV for thrsv */
name|Safefree
argument_list|(
name|SvPVX
argument_list|(
name|PL_thrsv
argument_list|)
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|SvANY
argument_list|(
name|PL_thrsv
argument_list|)
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|PL_thrsv
argument_list|)
expr_stmt|;
name|PL_thrsv
operator|=
name|Nullsv
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
comment|/* As the absolutely last thing, free the non-arena SV for mess() */
if|if
condition|(
name|PL_mess_sv
condition|)
block|{
comment|/* it could have accumulated taint magic */
if|if
condition|(
name|SvTYPE
argument_list|(
name|PL_mess_sv
argument_list|)
operator|>=
name|SVt_PVMG
condition|)
block|{
name|MAGIC
modifier|*
name|mg
decl_stmt|;
name|MAGIC
modifier|*
name|moremagic
decl_stmt|;
for|for
control|(
name|mg
operator|=
name|SvMAGIC
argument_list|(
name|PL_mess_sv
argument_list|)
init|;
name|mg
condition|;
name|mg
operator|=
name|moremagic
control|)
block|{
name|moremagic
operator|=
name|mg
operator|->
name|mg_moremagic
expr_stmt|;
if|if
condition|(
name|mg
operator|->
name|mg_ptr
operator|&&
name|mg
operator|->
name|mg_type
operator|!=
literal|'g'
operator|&&
name|mg
operator|->
name|mg_len
operator|>=
literal|0
condition|)
name|Safefree
argument_list|(
name|mg
operator|->
name|mg_ptr
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|mg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* we know that type>= SVt_PV */
operator|(
name|void
operator|)
name|SvOOK_off
argument_list|(
name|PL_mess_sv
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|SvPVX
argument_list|(
name|PL_mess_sv
argument_list|)
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|SvANY
argument_list|(
name|PL_mess_sv
argument_list|)
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|PL_mess_sv
argument_list|)
expr_stmt|;
name|PL_mess_sv
operator|=
name|Nullsv
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* =for apidoc perl_free  Releases a Perl interpreter.  See L<perlembed>.  =cut */
end_comment

begin_function
name|void
name|perl_free
parameter_list|(
name|pTHXx
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|PERL_OBJECT
argument_list|)
name|PerlMem_free
argument_list|(
name|this
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|PERL_IMPLICIT_SYS
argument_list|)
operator|&&
name|defined
argument_list|(
name|WIN32
argument_list|)
name|void
modifier|*
name|host
init|=
name|w32_internal_host
decl_stmt|;
name|PerlMem_free
argument_list|(
name|aTHXx
argument_list|)
expr_stmt|;
name|win32_delete_internal_host
argument_list|(
name|host
argument_list|)
expr_stmt|;
else|#
directive|else
name|PerlMem_free
argument_list|(
name|aTHXx
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|Perl_call_atexit
parameter_list|(
name|pTHX_
name|ATEXIT_t
name|fn
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|Renew
argument_list|(
name|PL_exitlist
argument_list|,
name|PL_exitlistlen
operator|+
literal|1
argument_list|,
name|PerlExitListEntry
argument_list|)
expr_stmt|;
name|PL_exitlist
index|[
name|PL_exitlistlen
index|]
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|PL_exitlist
index|[
name|PL_exitlistlen
index|]
operator|.
name|ptr
operator|=
name|ptr
expr_stmt|;
operator|++
name|PL_exitlistlen
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc perl_parse  Tells a Perl interpreter to parse a Perl script.  See L<perlembed>.  =cut */
end_comment

begin_function
name|int
name|perl_parse
parameter_list|(
name|pTHXx_
name|XSINIT_t
name|xsinit
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|I32
name|oldscope
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|dJMPENV
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|dTHX
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SETUID_SCRIPTS_ARE_SECURE_NOW
ifdef|#
directive|ifdef
name|IAMSUID
undef|#
directive|undef
name|IAMSUID
name|Perl_croak
argument_list|(
name|aTHX_
literal|"suidperl is no longer needed since the kernel can now execute\n\ setuid perl scripts securely.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__DYNAMIC__
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|NeXT
argument_list|)
operator|||
name|defined
argument_list|(
name|__NeXT__
argument_list|)
operator|)
name|_dyld_lookup_and_bind
argument_list|(
literal|"__environ"
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|&
name|environ_pointer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* environ */
name|PL_origargv
operator|=
name|argv
expr_stmt|;
name|PL_origargc
operator|=
name|argc
expr_stmt|;
ifndef|#
directive|ifndef
name|VMS
comment|/* VMS doesn't have environ array */
name|PL_origenviron
operator|=
name|environ
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|PL_do_undump
condition|)
block|{
comment|/* Come here if running an undumped a.out. */
name|PL_origfilename
operator|=
name|savepv
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|PL_do_undump
operator|=
name|FALSE
expr_stmt|;
name|cxstack_ix
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* start label stack again */
name|init_ids
argument_list|()
expr_stmt|;
name|init_postdump_symbols
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|env
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|PL_main_root
condition|)
block|{
name|PL_curpad
operator|=
name|AvARRAY
argument_list|(
name|PL_comppad
argument_list|)
expr_stmt|;
name|op_free
argument_list|(
name|PL_main_root
argument_list|)
expr_stmt|;
name|PL_main_root
operator|=
name|Nullop
expr_stmt|;
block|}
name|PL_main_start
operator|=
name|Nullop
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_main_cv
argument_list|)
expr_stmt|;
name|PL_main_cv
operator|=
name|Nullcv
expr_stmt|;
name|time
argument_list|(
operator|&
name|PL_basetime
argument_list|)
expr_stmt|;
name|oldscope
operator|=
name|PL_scopestack_ix
expr_stmt|;
name|PL_dowarn
operator|=
name|G_WARN_OFF
expr_stmt|;
ifdef|#
directive|ifdef
name|PERL_FLEXIBLE_EXCEPTIONS
name|CALLPROTECT
argument_list|(
argument|aTHX_ pcur_env
argument_list|,
argument|&ret
argument_list|,
argument|MEMBER_TO_FPTR(S_vparse_body)
argument_list|,
argument|env
argument_list|,
argument|xsinit
argument_list|)
empty_stmt|;
else|#
directive|else
name|JMPENV_PUSH
argument_list|(
name|ret
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
literal|0
case|:
ifndef|#
directive|ifndef
name|PERL_FLEXIBLE_EXCEPTIONS
name|parse_body
argument_list|(
name|env
argument_list|,
name|xsinit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|PL_checkav
condition|)
name|call_list
argument_list|(
name|oldscope
argument_list|,
name|PL_checkav
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|STATUS_ALL_FAILURE
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|2
case|:
comment|/* my_exit() was called */
while|while
condition|(
name|PL_scopestack_ix
operator|>
name|oldscope
condition|)
name|LEAVE
expr_stmt|;
name|FREETMPS
expr_stmt|;
name|PL_curstash
operator|=
name|PL_defstash
expr_stmt|;
if|if
condition|(
name|PL_checkav
condition|)
name|call_list
argument_list|(
name|oldscope
argument_list|,
name|PL_checkav
argument_list|)
expr_stmt|;
name|ret
operator|=
name|STATUS_NATIVE_EXPORT
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"panic: top_env\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|JMPENV_POP
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_FLEXIBLE_EXCEPTIONS
end_ifdef

begin_function
name|STATIC
name|void
modifier|*
name|S_vparse_body
parameter_list|(
name|pTHX_
name|va_list
name|args
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|env
init|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
operator|*
argument_list|)
decl_stmt|;
name|XSINIT_t
name|xsinit
init|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|XSINIT_t
argument_list|)
decl_stmt|;
return|return
name|parse_body
argument_list|(
name|env
argument_list|,
name|xsinit
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|STATIC
name|void
modifier|*
name|S_parse_body
parameter_list|(
name|pTHX_
name|char
modifier|*
modifier|*
name|env
parameter_list|,
name|XSINIT_t
name|xsinit
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|int
name|argc
init|=
name|PL_origargc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
init|=
name|PL_origargv
decl_stmt|;
name|char
modifier|*
name|scriptname
init|=
name|NULL
decl_stmt|;
name|int
name|fdscript
init|=
operator|-
literal|1
decl_stmt|;
name|VOL
name|bool
name|dosearch
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|validarg
init|=
literal|""
decl_stmt|;
name|AV
modifier|*
name|comppadlist
decl_stmt|;
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|cddir
init|=
name|Nullch
decl_stmt|;
name|sv_setpvn
argument_list|(
name|PL_linestr
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv
operator|=
name|newSVpvn
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* first used for -I flags */
name|SAVEFREESV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|init_main_stash
argument_list|()
expr_stmt|;
for|for
control|(
name|argc
operator|--
operator|,
name|argv
operator|++
init|;
name|argc
operator|>
literal|0
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
operator|!
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|)
break|break;
ifdef|#
directive|ifdef
name|DOSUID
if|if
condition|(
operator|*
name|validarg
condition|)
name|validarg
operator|=
literal|" PHOOEY "
expr_stmt|;
else|else
name|validarg
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|argv
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
name|reswitch
label|:
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'C'
case|:
ifdef|#
directive|ifdef
name|WIN32
name|win32_argv2utf8
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
endif|#
directive|endif
ifndef|#
directive|ifndef
name|PERL_STRICT_CR
case|case
literal|'\r'
case|:
endif|#
directive|endif
case|case
literal|' '
case|:
case|case
literal|'0'
case|:
case|case
literal|'F'
case|:
case|case
literal|'a'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'l'
case|:
case|case
literal|'M'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'p'
case|:
case|case
literal|'s'
case|:
case|case
literal|'u'
case|:
case|case
literal|'U'
case|:
case|case
literal|'v'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'w'
case|:
if|if
condition|(
operator|(
name|s
operator|=
name|moreswitches
argument_list|(
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|reswitch
goto|;
break|break;
case|case
literal|'T'
case|:
name|PL_tainting
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
literal|'e'
case|:
if|if
condition|(
name|PL_euid
operator|!=
name|PL_uid
operator|||
name|PL_egid
operator|!=
name|PL_gid
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"No -e allowed in setuid scripts"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PL_e_script
condition|)
block|{
name|PL_e_script
operator|=
name|newSVpvn
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|filter_add
argument_list|(
name|read_e_script
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|++
name|s
condition|)
name|sv_catpv
argument_list|(
name|PL_e_script
argument_list|,
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|argv
index|[
literal|1
index|]
condition|)
block|{
name|sv_catpv
argument_list|(
name|PL_e_script
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
block|}
else|else
name|Perl_croak
argument_list|(
name|aTHX_
literal|"No code specified for -e"
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|PL_e_script
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* -I handled both here and in moreswitches() */
name|forbid_setid
argument_list|(
literal|"-I"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
operator|++
name|s
operator|&&
operator|(
name|s
operator|=
name|argv
index|[
literal|1
index|]
operator|)
operator|!=
name|Nullch
condition|)
block|{
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|&&
operator|*
name|s
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|STRLEN
name|len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|p
operator|=
name|savepvn
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|incpush
argument_list|(
name|p
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
literal|"-I"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|Perl_croak
argument_list|(
name|aTHX_
literal|"No directory specified for -I"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|forbid_setid
argument_list|(
literal|"-P"
argument_list|)
expr_stmt|;
name|PL_preprocess
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
literal|'S'
case|:
name|forbid_setid
argument_list|(
literal|"-S"
argument_list|)
expr_stmt|;
name|dosearch
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
literal|'V'
case|:
if|if
condition|(
operator|!
name|PL_preambleav
condition|)
name|PL_preambleav
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|av_push
argument_list|(
name|PL_preambleav
argument_list|,
name|newSVpv
argument_list|(
literal|"use Config qw(myconfig config_vars)"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|s
operator|!=
literal|':'
condition|)
block|{
name|PL_Sv
operator|=
name|newSVpv
argument_list|(
literal|"print myconfig();"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|"print \"\\nCharacteristics of this PERLSHR image: \\n\","
argument_list|)
expr_stmt|;
else|#
directive|else
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|"print \"\\nCharacteristics of this binary (from libperl): \\n\","
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|"\"  Compile-time options:"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|" DEBUGGING"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MULTIPLICITY
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|" MULTIPLICITY"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_THREADS
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|" USE_THREADS"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_ITHREADS
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|" USE_ITHREADS"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_64_BIT_INT
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|" USE_64_BIT_INT"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_64_BIT_ALL
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|" USE_64_BIT_ALL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_LONG_DOUBLE
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|" USE_LONG_DOUBLE"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_LARGE_FILES
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|" USE_LARGE_FILES"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_SOCKS
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|" USE_SOCKS"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PERL_OBJECT
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|" PERL_OBJECT"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PERL_IMPLICIT_CONTEXT
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|" PERL_IMPLICIT_CONTEXT"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PERL_IMPLICIT_SYS
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|" PERL_IMPLICIT_SYS"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|"\\n\","
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LOCAL_PATCH_COUNT
argument_list|)
if|if
condition|(
name|LOCAL_PATCH_COUNT
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|"\"  Locally applied patches:\\n\","
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|LOCAL_PATCH_COUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|PL_localpatches
index|[
name|i
index|]
condition|)
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ PL_Sv
argument_list|,
literal|"q\"  \t%s\n\","
argument_list|,
argument|PL_localpatches[i]
argument_list|)
empty_stmt|;
block|}
block|}
endif|#
directive|endif
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ PL_Sv
argument_list|,
literal|"\"  Built under %s\\n\""
argument_list|,
argument|OSNAME
argument_list|)
empty_stmt|;
ifdef|#
directive|ifdef
name|__DATE__
ifdef|#
directive|ifdef
name|__TIME__
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ PL_Sv
argument_list|,
literal|",\"  Compiled at %s %s\\n\""
argument_list|,
argument|__DATE__
argument_list|,
argument|__TIME__
argument_list|)
empty_stmt|;
else|#
directive|else
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ PL_Sv
argument_list|,
literal|",\"  Compiled on %s\\n\""
argument_list|,
argument|__DATE__
argument_list|)
empty_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|"; \ $\"=\"\\n    \"; \ @env = map { \"$_=\\\"$ENV{$_}\\\"\" } sort grep {/^PERL/} keys %ENV; \ print \"  \\%ENV:\\n    @env\\n\" if @env; \ print \"  \\@INC:\\n    @INC\\n\";"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PL_Sv
operator|=
name|newSVpv
argument_list|(
literal|"config_vars(qw("
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
operator|++
name|s
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|"))"
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|av_push
argument_list|(
name|PL_preambleav
argument_list|,
name|PL_Sv
argument_list|)
expr_stmt|;
name|scriptname
operator|=
name|BIT_BUCKET
expr_stmt|;
comment|/* don't look for script or read stdin */
goto|goto
name|reswitch
goto|;
case|case
literal|'x'
case|:
name|PL_doextract
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
name|cddir
operator|=
name|s
expr_stmt|;
break|break;
case|case
literal|0
case|:
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
operator|!
operator|*
operator|++
name|s
operator|||
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
goto|goto
name|switch_end
goto|;
block|}
comment|/* catch use of gnu style long options */
if|if
condition|(
name|strEQ
argument_list|(
name|s
argument_list|,
literal|"version"
argument_list|)
condition|)
block|{
name|s
operator|=
literal|"v"
expr_stmt|;
goto|goto
name|reswitch
goto|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|s
argument_list|,
literal|"help"
argument_list|)
condition|)
block|{
name|s
operator|=
literal|"h"
expr_stmt|;
goto|goto
name|reswitch
goto|;
block|}
name|s
operator|--
expr_stmt|;
comment|/* FALL THROUGH */
default|default:
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Unrecognized switch: -%s  (-h will show valid options)"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|switch_end
label|:
if|if
condition|(
ifndef|#
directive|ifndef
name|SECURE_INTERNAL_GETENV
operator|!
name|PL_tainting
operator|&&
endif|#
directive|endif
operator|(
name|s
operator|=
name|PerlEnv_getenv
argument_list|(
literal|"PERL5OPT"
argument_list|)
operator|)
condition|)
block|{
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
operator|&&
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'T'
condition|)
name|PL_tainting
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
while|while
condition|(
name|s
operator|&&
operator|*
name|s
condition|)
block|{
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
continue|continue;
block|}
if|if
condition|(
operator|!
operator|*
name|s
condition|)
break|break;
if|if
condition|(
operator|!
name|strchr
argument_list|(
literal|"DIMUdmw"
argument_list|,
operator|*
name|s
argument_list|)
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Illegal switch in PERL5OPT: -%c"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|moreswitches
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|scriptname
condition|)
name|scriptname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|PL_e_script
condition|)
block|{
name|argc
operator|++
operator|,
name|argv
operator|--
expr_stmt|;
name|scriptname
operator|=
name|BIT_BUCKET
expr_stmt|;
comment|/* don't look for script or read stdin */
block|}
elseif|else
if|if
condition|(
name|scriptname
operator|==
name|Nullch
condition|)
block|{
ifdef|#
directive|ifdef
name|MSDOS
if|if
condition|(
name|PerlLIO_isatty
argument_list|(
name|PerlIO_fileno
argument_list|(
name|PerlIO_stdin
argument_list|()
argument_list|)
argument_list|)
condition|)
name|moreswitches
argument_list|(
literal|"h"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scriptname
operator|=
literal|"-"
expr_stmt|;
block|}
name|init_perllib
argument_list|()
expr_stmt|;
name|open_script
argument_list|(
name|scriptname
argument_list|,
name|dosearch
argument_list|,
name|sv
argument_list|,
operator|&
name|fdscript
argument_list|)
expr_stmt|;
name|validate_suid
argument_list|(
name|validarg
argument_list|,
name|scriptname
argument_list|,
name|fdscript
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIGCHLD
argument_list|)
operator|||
name|defined
argument_list|(
name|SIGCLD
argument_list|)
block|{
ifndef|#
directive|ifndef
name|SIGCHLD
define|#
directive|define
name|SIGCHLD
value|SIGCLD
endif|#
directive|endif
name|Sighandler_t
name|sigstate
init|=
name|rsignal_state
argument_list|(
name|SIGCHLD
argument_list|)
decl_stmt|;
if|if
condition|(
name|sigstate
operator|==
name|SIG_IGN
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_SIGNAL
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_SIGNAL
argument_list|,
literal|"Can't ignore signal CHLD, forcing to default"
argument_list|)
empty_stmt|;
operator|(
name|void
operator|)
name|rsignal
argument_list|(
name|SIGCHLD
argument_list|,
operator|(
name|Sighandler_t
operator|)
name|SIG_DFL
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|PL_doextract
condition|)
block|{
name|find_beginning
argument_list|()
expr_stmt|;
if|if
condition|(
name|cddir
operator|&&
name|PerlDir_chdir
argument_list|(
name|cddir
argument_list|)
operator|<
literal|0
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't chdir to %s"
argument_list|,
name|cddir
argument_list|)
expr_stmt|;
block|}
name|PL_main_cv
operator|=
name|PL_compcv
operator|=
operator|(
name|CV
operator|*
operator|)
name|NEWSV
argument_list|(
literal|1104
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|PL_compcv
argument_list|,
name|SVt_PVCV
argument_list|)
expr_stmt|;
name|CvUNIQUE_on
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
name|PL_comppad
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|av_push
argument_list|(
name|PL_comppad
argument_list|,
name|Nullsv
argument_list|)
expr_stmt|;
name|PL_curpad
operator|=
name|AvARRAY
argument_list|(
name|PL_comppad
argument_list|)
expr_stmt|;
name|PL_comppad_name
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|PL_comppad_name_fill
operator|=
literal|0
expr_stmt|;
name|PL_min_intro_pending
operator|=
literal|0
expr_stmt|;
name|PL_padix
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|av_store
argument_list|(
name|PL_comppad_name
argument_list|,
literal|0
argument_list|,
name|newSVpvn
argument_list|(
literal|"@_"
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|PL_curpad
index|[
literal|0
index|]
operator|=
operator|(
name|SV
operator|*
operator|)
name|newAV
argument_list|()
expr_stmt|;
name|SvPADMY_on
argument_list|(
name|PL_curpad
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* XXX Needed? */
name|CvOWNER
argument_list|(
name|PL_compcv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|New
argument_list|(
literal|666
argument_list|,
name|CvMUTEXP
argument_list|(
name|PL_compcv
argument_list|)
argument_list|,
literal|1
argument_list|,
name|perl_mutex
argument_list|)
expr_stmt|;
name|MUTEX_INIT
argument_list|(
name|CvMUTEXP
argument_list|(
name|PL_compcv
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
name|comppadlist
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|AvREAL_off
argument_list|(
name|comppadlist
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|comppadlist
argument_list|,
literal|0
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|PL_comppad_name
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|comppadlist
argument_list|,
literal|1
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|PL_comppad
argument_list|)
expr_stmt|;
name|CvPADLIST
argument_list|(
name|PL_compcv
argument_list|)
operator|=
name|comppadlist
expr_stmt|;
name|boot_core_UNIVERSAL
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|PERL_MICRO
name|boot_core_xsutils
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|xsinit
condition|)
call|(
modifier|*
name|xsinit
call|)
argument_list|(
name|aTHXo
argument_list|)
expr_stmt|;
comment|/* in case linked C routines want magical variables */
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|DJGPP
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
name|init_os_extras
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_SOCKS
name|SOCKSinit
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|init_predump_symbols
argument_list|()
expr_stmt|;
comment|/* init_postdump_symbols not currently designed to be called */
comment|/* more than once (ENV isn't cleared first, for example)	 */
comment|/* But running with -u leaves %ENV& @ARGV undefined!    XXX */
if|if
condition|(
operator|!
name|PL_do_undump
condition|)
name|init_postdump_symbols
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|init_lexer
argument_list|()
expr_stmt|;
comment|/* now parse the script */
name|SETERRNO
argument_list|(
literal|0
argument_list|,
name|SS$_NORMAL
argument_list|)
expr_stmt|;
name|PL_error_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|yyparse
argument_list|()
operator|||
name|PL_error_count
condition|)
block|{
if|if
condition|(
name|PL_minus_c
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"%s had compilation errors.\n"
argument_list|,
name|PL_origfilename
argument_list|)
expr_stmt|;
else|else
block|{
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Execution of %s aborted due to compilation errors.\n"
argument_list|,
name|PL_origfilename
argument_list|)
expr_stmt|;
block|}
block|}
name|CopLINE_set
argument_list|(
name|PL_curcop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PL_curstash
operator|=
name|PL_defstash
expr_stmt|;
name|PL_preprocess
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|PL_e_script
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|PL_e_script
argument_list|)
expr_stmt|;
name|PL_e_script
operator|=
name|Nullsv
expr_stmt|;
block|}
comment|/* now that script is parsed, we can modify record separator */
name|SvREFCNT_dec
argument_list|(
name|PL_rs
argument_list|)
expr_stmt|;
name|PL_rs
operator|=
name|SvREFCNT_inc
argument_list|(
name|PL_nrs
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
name|get_sv
argument_list|(
literal|"/"
argument_list|,
name|TRUE
argument_list|)
argument_list|,
name|PL_rs
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_do_undump
condition|)
name|my_unexec
argument_list|()
expr_stmt|;
if|if
condition|(
name|isWARN_ONCE
condition|)
block|{
name|SAVECOPFILE
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
name|SAVECOPLINE
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
name|gv_check
argument_list|(
name|PL_defstash
argument_list|)
expr_stmt|;
block|}
name|LEAVE
expr_stmt|;
name|FREETMPS
expr_stmt|;
ifdef|#
directive|ifdef
name|MYMALLOC
if|if
condition|(
operator|(
name|s
operator|=
name|PerlEnv_getenv
argument_list|(
literal|"PERL_DEBUG_MSTATS"
argument_list|)
operator|)
operator|&&
name|atoi
argument_list|(
name|s
argument_list|)
operator|>=
literal|2
condition|)
name|dump_mstats
argument_list|(
literal|"after compilation:"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ENTER
expr_stmt|;
name|PL_restartop
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc perl_run  Tells a Perl interpreter to run.  See L<perlembed>.  =cut */
end_comment

begin_function
name|int
name|perl_run
parameter_list|(
name|pTHXx
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|I32
name|oldscope
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|dJMPENV
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|dTHX
expr_stmt|;
endif|#
directive|endif
name|oldscope
operator|=
name|PL_scopestack_ix
expr_stmt|;
ifdef|#
directive|ifdef
name|PERL_FLEXIBLE_EXCEPTIONS
name|redo_body
label|:
name|CALLPROTECT
argument_list|(
argument|aTHX_ pcur_env
argument_list|,
argument|&ret
argument_list|,
argument|MEMBER_TO_FPTR(S_vrun_body)
argument_list|,
argument|oldscope
argument_list|)
empty_stmt|;
else|#
directive|else
name|JMPENV_PUSH
argument_list|(
name|ret
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
literal|1
case|:
name|cxstack_ix
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* start context stack again */
goto|goto
name|redo_body
goto|;
case|case
literal|0
case|:
comment|/* normal completion */
ifndef|#
directive|ifndef
name|PERL_FLEXIBLE_EXCEPTIONS
name|redo_body
label|:
name|run_body
argument_list|(
name|oldscope
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FALL THROUGH */
case|case
literal|2
case|:
comment|/* my_exit() */
while|while
condition|(
name|PL_scopestack_ix
operator|>
name|oldscope
condition|)
name|LEAVE
expr_stmt|;
name|FREETMPS
expr_stmt|;
name|PL_curstash
operator|=
name|PL_defstash
expr_stmt|;
if|if
condition|(
name|PL_endav
operator|&&
operator|!
name|PL_minus_c
condition|)
name|call_list
argument_list|(
name|oldscope
argument_list|,
name|PL_endav
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MYMALLOC
if|if
condition|(
name|PerlEnv_getenv
argument_list|(
literal|"PERL_DEBUG_MSTATS"
argument_list|)
condition|)
name|dump_mstats
argument_list|(
literal|"after execution:  "
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ret
operator|=
name|STATUS_NATIVE_EXPORT
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|PL_restartop
condition|)
block|{
name|POPSTACK_TO
argument_list|(
name|PL_mainstack
argument_list|)
expr_stmt|;
goto|goto
name|redo_body
goto|;
block|}
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"panic: restartop\n"
argument_list|)
expr_stmt|;
name|FREETMPS
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|JMPENV_POP
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_FLEXIBLE_EXCEPTIONS
end_ifdef

begin_function
name|STATIC
name|void
modifier|*
name|S_vrun_body
parameter_list|(
name|pTHX_
name|va_list
name|args
parameter_list|)
block|{
name|I32
name|oldscope
init|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|I32
argument_list|)
decl_stmt|;
return|return
name|run_body
argument_list|(
name|oldscope
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|STATIC
name|void
modifier|*
name|S_run_body
parameter_list|(
name|pTHX_
name|I32
name|oldscope
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%s $` $& $' support.\n"
argument_list|,
name|PL_sawampersand
condition|?
literal|"Enabling"
else|:
literal|"Omitting"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PL_restartop
condition|)
block|{
name|DEBUG_x
argument_list|(
name|dump_all
argument_list|()
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"\nEXECUTING...\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"main thread is 0x%"
name|UVxf
literal|"\n"
argument_list|,
name|PTR2UV
argument_list|(
name|thr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_minus_c
condition|)
block|{
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"%s syntax OK\n"
argument_list|,
name|PL_origfilename
argument_list|)
expr_stmt|;
name|my_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PERLDB_SINGLE
operator|&&
name|PL_DBsingle
condition|)
name|sv_setiv
argument_list|(
name|PL_DBsingle
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_initav
condition|)
name|call_list
argument_list|(
name|oldscope
argument_list|,
name|PL_initav
argument_list|)
expr_stmt|;
block|}
comment|/* do it */
if|if
condition|(
name|PL_restartop
condition|)
block|{
name|PL_op
operator|=
name|PL_restartop
expr_stmt|;
name|PL_restartop
operator|=
literal|0
expr_stmt|;
name|CALLRUNOPS
argument_list|(
name|aTHX
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PL_main_start
condition|)
block|{
name|CvDEPTH
argument_list|(
name|PL_main_cv
argument_list|)
operator|=
literal|1
expr_stmt|;
name|PL_op
operator|=
name|PL_main_start
expr_stmt|;
name|CALLRUNOPS
argument_list|(
name|aTHX
argument_list|)
expr_stmt|;
block|}
name|my_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc p||get_sv  Returns the SV of the specified Perl scalar.  If C<create> is set and the Perl variable does not exist then it will be created.  If C<create> is not set and the variable does not exist then NULL is returned.  =cut */
end_comment

begin_function
name|SV
modifier|*
name|Perl_get_sv
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|I32
name|create
parameter_list|)
block|{
name|GV
modifier|*
name|gv
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|&&
operator|!
name|isALPHA
argument_list|(
name|name
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|PADOFFSET
name|tmp
init|=
name|find_threadsv
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NOT_IN_PAD
condition|)
block|{
name|dTHR
expr_stmt|;
return|return
name|THREADSV
argument_list|(
name|tmp
argument_list|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/* USE_THREADS */
name|gv
operator|=
name|gv_fetchpv
argument_list|(
name|name
argument_list|,
name|create
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
if|if
condition|(
name|gv
condition|)
return|return
name|GvSV
argument_list|(
name|gv
argument_list|)
return|;
return|return
name|Nullsv
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc p||get_av  Returns the AV of the specified Perl array.  If C<create> is set and the Perl variable does not exist then it will be created.  If C<create> is not set and the variable does not exist then NULL is returned.  =cut */
end_comment

begin_function
name|AV
modifier|*
name|Perl_get_av
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|I32
name|create
parameter_list|)
block|{
name|GV
modifier|*
name|gv
init|=
name|gv_fetchpv
argument_list|(
name|name
argument_list|,
name|create
argument_list|,
name|SVt_PVAV
argument_list|)
decl_stmt|;
if|if
condition|(
name|create
condition|)
return|return
name|GvAVn
argument_list|(
name|gv
argument_list|)
return|;
if|if
condition|(
name|gv
condition|)
return|return
name|GvAV
argument_list|(
name|gv
argument_list|)
return|;
return|return
name|Nullav
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc p||get_hv  Returns the HV of the specified Perl hash.  If C<create> is set and the Perl variable does not exist then it will be created.  If C<create> is not set and the variable does not exist then NULL is returned.  =cut */
end_comment

begin_function
name|HV
modifier|*
name|Perl_get_hv
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|I32
name|create
parameter_list|)
block|{
name|GV
modifier|*
name|gv
init|=
name|gv_fetchpv
argument_list|(
name|name
argument_list|,
name|create
argument_list|,
name|SVt_PVHV
argument_list|)
decl_stmt|;
if|if
condition|(
name|create
condition|)
return|return
name|GvHVn
argument_list|(
name|gv
argument_list|)
return|;
if|if
condition|(
name|gv
condition|)
return|return
name|GvHV
argument_list|(
name|gv
argument_list|)
return|;
return|return
name|Nullhv
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc p||get_cv  Returns the CV of the specified Perl subroutine.  If C<create> is set and the Perl subroutine does not exist then it will be declared (which has the same effect as saying C<sub name;>).  If C<create> is not set and the subroutine does not exist then NULL is returned.  =cut */
end_comment

begin_function
name|CV
modifier|*
name|Perl_get_cv
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|I32
name|create
parameter_list|)
block|{
name|GV
modifier|*
name|gv
init|=
name|gv_fetchpv
argument_list|(
name|name
argument_list|,
name|create
argument_list|,
name|SVt_PVCV
argument_list|)
decl_stmt|;
comment|/* XXX unsafe for threads if eval_owner isn't held */
comment|/* XXX this is probably not what they think they're getting.      * It has the same effect as "sub name;", i.e. just a forward      * declaration! */
if|if
condition|(
name|create
operator|&&
operator|!
name|GvCVu
argument_list|(
name|gv
argument_list|)
condition|)
return|return
name|newSUB
argument_list|(
name|start_subparse
argument_list|(
name|FALSE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVpv
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|Nullop
argument_list|,
name|Nullop
argument_list|)
return|;
if|if
condition|(
name|gv
condition|)
return|return
name|GvCVu
argument_list|(
name|gv
argument_list|)
return|;
return|return
name|Nullcv
return|;
block|}
end_function

begin_comment
comment|/* Be sure to refetch the stack pointer after calling these routines. */
end_comment

begin_comment
comment|/* =for apidoc p||call_argv  Performs a callback to the specified Perl sub.  See L<perlcall>.  =cut */
end_comment

begin_function
name|I32
name|Perl_call_argv
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|sub_name
parameter_list|,
name|I32
name|flags
parameter_list|,
specifier|register
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
comment|/* See G_* flags in cop.h */
comment|/* null terminated arg list */
block|{
name|dSP
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
condition|)
block|{
while|while
condition|(
operator|*
name|argv
condition|)
block|{
name|XPUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
operator|*
name|argv
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
name|PUTBACK
expr_stmt|;
block|}
return|return
name|call_pv
argument_list|(
name|sub_name
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc p||call_pv  Performs a callback to the specified Perl sub.  See L<perlcall>.  =cut */
end_comment

begin_function
name|I32
name|Perl_call_pv
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|sub_name
parameter_list|,
name|I32
name|flags
parameter_list|)
comment|/* name of the subroutine */
comment|/* See G_* flags in cop.h */
block|{
return|return
name|call_sv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|get_cv
argument_list|(
name|sub_name
argument_list|,
name|TRUE
argument_list|)
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc p||call_method  Performs a callback to the specified Perl method.  The blessed object must be on the stack.  See L<perlcall>.  =cut */
end_comment

begin_function
name|I32
name|Perl_call_method
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|methname
parameter_list|,
name|I32
name|flags
parameter_list|)
comment|/* name of the subroutine */
comment|/* See G_* flags in cop.h */
block|{
name|dSP
expr_stmt|;
name|OP
name|myop
decl_stmt|;
if|if
condition|(
operator|!
name|PL_op
condition|)
block|{
name|Zero
argument_list|(
operator|&
name|myop
argument_list|,
literal|1
argument_list|,
name|OP
argument_list|)
expr_stmt|;
name|PL_op
operator|=
operator|&
name|myop
expr_stmt|;
block|}
name|XPUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
name|methname
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|pp_method
argument_list|()
expr_stmt|;
if|if
condition|(
name|PL_op
operator|==
operator|&
name|myop
condition|)
name|PL_op
operator|=
name|Nullop
expr_stmt|;
return|return
name|call_sv
argument_list|(
operator|*
name|PL_stack_sp
operator|--
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* May be called with any of a CV, a GV, or an SV containing the name. */
end_comment

begin_comment
comment|/* =for apidoc p||call_sv  Performs a callback to the Perl sub whose name is in the SV.  See L<perlcall>.  =cut */
end_comment

begin_function
name|I32
name|Perl_call_sv
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|I32
name|flags
parameter_list|)
comment|/* See G_* flags in cop.h */
block|{
name|dSP
expr_stmt|;
name|LOGOP
name|myop
decl_stmt|;
comment|/* fake syntax tree node */
name|I32
name|oldmark
decl_stmt|;
name|I32
name|retval
decl_stmt|;
name|I32
name|oldscope
decl_stmt|;
name|bool
name|oldcatch
init|=
name|CATCH_GET
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|OP
modifier|*
name|oldop
init|=
name|PL_op
decl_stmt|;
name|dJMPENV
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|G_DISCARD
condition|)
block|{
name|ENTER
expr_stmt|;
name|SAVETMPS
expr_stmt|;
block|}
name|Zero
argument_list|(
operator|&
name|myop
argument_list|,
literal|1
argument_list|,
name|LOGOP
argument_list|)
expr_stmt|;
name|myop
operator|.
name|op_next
operator|=
name|Nullop
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|G_NOARGS
operator|)
condition|)
name|myop
operator|.
name|op_flags
operator||=
name|OPf_STACKED
expr_stmt|;
name|myop
operator|.
name|op_flags
operator||=
operator|(
operator|(
name|flags
operator|&
name|G_VOID
operator|)
condition|?
name|OPf_WANT_VOID
else|:
operator|(
name|flags
operator|&
name|G_ARRAY
operator|)
condition|?
name|OPf_WANT_LIST
else|:
name|OPf_WANT_SCALAR
operator|)
expr_stmt|;
name|SAVEOP
argument_list|()
expr_stmt|;
name|PL_op
operator|=
operator|(
name|OP
operator|*
operator|)
operator|&
name|myop
expr_stmt|;
name|EXTEND
argument_list|(
name|PL_stack_sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
operator|++
name|PL_stack_sp
operator|=
name|sv
expr_stmt|;
name|oldmark
operator|=
name|TOPMARK
expr_stmt|;
name|oldscope
operator|=
name|PL_scopestack_ix
expr_stmt|;
if|if
condition|(
name|PERLDB_SUB
operator|&&
name|PL_curstash
operator|!=
name|PL_debstash
comment|/* Handle first BEGIN of -d. */
operator|&&
operator|(
name|PL_DBcv
operator|||
operator|(
name|PL_DBcv
operator|=
name|GvCV
argument_list|(
name|PL_DBsub
argument_list|)
operator|)
operator|)
comment|/* Try harder, since this may have been a sighandler, thus 	    * curstash may be meaningless. */
operator|&&
operator|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|!=
name|SVt_PVCV
operator|||
name|CvSTASH
argument_list|(
operator|(
name|CV
operator|*
operator|)
name|sv
argument_list|)
operator|!=
name|PL_debstash
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|G_NODEBUG
operator|)
condition|)
name|PL_op
operator|->
name|op_private
operator||=
name|OPpENTERSUB_DB
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|G_EVAL
operator|)
condition|)
block|{
name|CATCH_SET
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|call_body
argument_list|(
operator|(
name|OP
operator|*
operator|)
operator|&
name|myop
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|retval
operator|=
name|PL_stack_sp
operator|-
operator|(
name|PL_stack_base
operator|+
name|oldmark
operator|)
expr_stmt|;
name|CATCH_SET
argument_list|(
name|oldcatch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cLOGOP
operator|->
name|op_other
operator|=
name|PL_op
expr_stmt|;
name|PL_markstack_ptr
operator|--
expr_stmt|;
comment|/* we're trying to emulate pp_entertry() here */
block|{
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|I32
name|gimme
init|=
name|GIMME_V
decl_stmt|;
name|ENTER
expr_stmt|;
name|SAVETMPS
expr_stmt|;
name|push_return
argument_list|(
name|PL_op
operator|->
name|op_next
argument_list|)
expr_stmt|;
name|PUSHBLOCK
argument_list|(
name|cx
argument_list|,
operator|(
name|CXt_EVAL
operator||
name|CXp_TRYBLOCK
operator|)
argument_list|,
name|PL_stack_sp
argument_list|)
expr_stmt|;
name|PUSHEVAL
argument_list|(
name|cx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PL_eval_root
operator|=
name|PL_op
expr_stmt|;
comment|/* Only needed so that goto works right. */
name|PL_in_eval
operator|=
name|EVAL_INEVAL
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|G_KEEPERR
condition|)
name|PL_in_eval
operator||=
name|EVAL_KEEPERR
expr_stmt|;
else|else
name|sv_setpv
argument_list|(
name|ERRSV
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|PL_markstack_ptr
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|PERL_FLEXIBLE_EXCEPTIONS
name|redo_body
label|:
name|CALLPROTECT
argument_list|(
argument|aTHX_ pcur_env
argument_list|,
argument|&ret
argument_list|,
argument|MEMBER_TO_FPTR(S_vcall_body)
argument_list|,
argument|(OP*)&myop
argument_list|,
argument|FALSE
argument_list|)
empty_stmt|;
else|#
directive|else
name|JMPENV_PUSH
argument_list|(
name|ret
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
literal|0
case|:
ifndef|#
directive|ifndef
name|PERL_FLEXIBLE_EXCEPTIONS
name|redo_body
label|:
name|call_body
argument_list|(
operator|(
name|OP
operator|*
operator|)
operator|&
name|myop
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|retval
operator|=
name|PL_stack_sp
operator|-
operator|(
name|PL_stack_base
operator|+
name|oldmark
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|G_KEEPERR
operator|)
condition|)
name|sv_setpv
argument_list|(
name|ERRSV
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|STATUS_ALL_FAILURE
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|2
case|:
comment|/* my_exit() was called */
name|PL_curstash
operator|=
name|PL_defstash
expr_stmt|;
name|FREETMPS
expr_stmt|;
name|JMPENV_POP
expr_stmt|;
if|if
condition|(
name|PL_statusvalue
operator|&&
operator|!
operator|(
name|PL_exit_flags
operator|&
name|PERL_EXIT_EXPECTED
operator|)
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Callback called exit"
argument_list|)
expr_stmt|;
name|my_exit_jump
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|3
case|:
if|if
condition|(
name|PL_restartop
condition|)
block|{
name|PL_op
operator|=
name|PL_restartop
expr_stmt|;
name|PL_restartop
operator|=
literal|0
expr_stmt|;
goto|goto
name|redo_body
goto|;
block|}
name|PL_stack_sp
operator|=
name|PL_stack_base
operator|+
name|oldmark
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|G_ARRAY
condition|)
name|retval
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|retval
operator|=
literal|1
expr_stmt|;
operator|*
operator|++
name|PL_stack_sp
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|PL_scopestack_ix
operator|>
name|oldscope
condition|)
block|{
name|SV
modifier|*
modifier|*
name|newsp
decl_stmt|;
name|PMOP
modifier|*
name|newpm
decl_stmt|;
name|I32
name|gimme
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|I32
name|optype
decl_stmt|;
name|POPBLOCK
argument_list|(
name|cx
argument_list|,
name|newpm
argument_list|)
expr_stmt|;
name|POPEVAL
argument_list|(
name|cx
argument_list|)
expr_stmt|;
name|pop_return
argument_list|()
expr_stmt|;
name|PL_curpm
operator|=
name|newpm
expr_stmt|;
name|LEAVE
expr_stmt|;
block|}
name|JMPENV_POP
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|G_DISCARD
condition|)
block|{
name|PL_stack_sp
operator|=
name|PL_stack_base
operator|+
name|oldmark
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|FREETMPS
expr_stmt|;
name|LEAVE
expr_stmt|;
block|}
name|PL_op
operator|=
name|oldop
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_FLEXIBLE_EXCEPTIONS
end_ifdef

begin_function
name|STATIC
name|void
modifier|*
name|S_vcall_body
parameter_list|(
name|pTHX_
name|va_list
name|args
parameter_list|)
block|{
name|OP
modifier|*
name|myop
init|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|OP
operator|*
argument_list|)
decl_stmt|;
name|int
name|is_eval
init|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
decl_stmt|;
name|call_body
argument_list|(
name|myop
argument_list|,
name|is_eval
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|STATIC
name|void
name|S_call_body
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|myop
parameter_list|,
name|int
name|is_eval
parameter_list|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
name|PL_op
operator|==
name|myop
condition|)
block|{
if|if
condition|(
name|is_eval
condition|)
name|PL_op
operator|=
name|Perl_pp_entereval
argument_list|(
name|aTHX
argument_list|)
expr_stmt|;
else|else
name|PL_op
operator|=
name|Perl_pp_entersub
argument_list|(
name|aTHX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_op
condition|)
name|CALLRUNOPS
argument_list|(
name|aTHX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Eval a string. The G_EVAL flag is always assumed. */
end_comment

begin_comment
comment|/* =for apidoc p||eval_sv  Tells Perl to C<eval> the string in the SV.  =cut */
end_comment

begin_function
name|I32
name|Perl_eval_sv
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|I32
name|flags
parameter_list|)
comment|/* See G_* flags in cop.h */
block|{
name|dSP
expr_stmt|;
name|UNOP
name|myop
decl_stmt|;
comment|/* fake syntax tree node */
name|I32
name|oldmark
init|=
name|SP
operator|-
name|PL_stack_base
decl_stmt|;
name|I32
name|retval
decl_stmt|;
name|I32
name|oldscope
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|OP
modifier|*
name|oldop
init|=
name|PL_op
decl_stmt|;
name|dJMPENV
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|G_DISCARD
condition|)
block|{
name|ENTER
expr_stmt|;
name|SAVETMPS
expr_stmt|;
block|}
name|SAVEOP
argument_list|()
expr_stmt|;
name|PL_op
operator|=
operator|(
name|OP
operator|*
operator|)
operator|&
name|myop
expr_stmt|;
name|Zero
argument_list|(
name|PL_op
argument_list|,
literal|1
argument_list|,
name|UNOP
argument_list|)
expr_stmt|;
name|EXTEND
argument_list|(
name|PL_stack_sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
operator|++
name|PL_stack_sp
operator|=
name|sv
expr_stmt|;
name|oldscope
operator|=
name|PL_scopestack_ix
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|G_NOARGS
operator|)
condition|)
name|myop
operator|.
name|op_flags
operator|=
name|OPf_STACKED
expr_stmt|;
name|myop
operator|.
name|op_next
operator|=
name|Nullop
expr_stmt|;
name|myop
operator|.
name|op_type
operator|=
name|OP_ENTEREVAL
expr_stmt|;
name|myop
operator|.
name|op_flags
operator||=
operator|(
operator|(
name|flags
operator|&
name|G_VOID
operator|)
condition|?
name|OPf_WANT_VOID
else|:
operator|(
name|flags
operator|&
name|G_ARRAY
operator|)
condition|?
name|OPf_WANT_LIST
else|:
name|OPf_WANT_SCALAR
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|G_KEEPERR
condition|)
name|myop
operator|.
name|op_flags
operator||=
name|OPf_SPECIAL
expr_stmt|;
ifdef|#
directive|ifdef
name|PERL_FLEXIBLE_EXCEPTIONS
name|redo_body
label|:
name|CALLPROTECT
argument_list|(
argument|aTHX_ pcur_env
argument_list|,
argument|&ret
argument_list|,
argument|MEMBER_TO_FPTR(S_vcall_body)
argument_list|,
argument|(OP*)&myop
argument_list|,
argument|TRUE
argument_list|)
empty_stmt|;
else|#
directive|else
name|JMPENV_PUSH
argument_list|(
name|ret
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
literal|0
case|:
ifndef|#
directive|ifndef
name|PERL_FLEXIBLE_EXCEPTIONS
name|redo_body
label|:
name|call_body
argument_list|(
operator|(
name|OP
operator|*
operator|)
operator|&
name|myop
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|retval
operator|=
name|PL_stack_sp
operator|-
operator|(
name|PL_stack_base
operator|+
name|oldmark
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|G_KEEPERR
operator|)
condition|)
name|sv_setpv
argument_list|(
name|ERRSV
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|STATUS_ALL_FAILURE
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|2
case|:
comment|/* my_exit() was called */
name|PL_curstash
operator|=
name|PL_defstash
expr_stmt|;
name|FREETMPS
expr_stmt|;
name|JMPENV_POP
expr_stmt|;
if|if
condition|(
name|PL_statusvalue
operator|&&
operator|!
operator|(
name|PL_exit_flags
operator|&
name|PERL_EXIT_EXPECTED
operator|)
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Callback called exit"
argument_list|)
expr_stmt|;
name|my_exit_jump
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|3
case|:
if|if
condition|(
name|PL_restartop
condition|)
block|{
name|PL_op
operator|=
name|PL_restartop
expr_stmt|;
name|PL_restartop
operator|=
literal|0
expr_stmt|;
goto|goto
name|redo_body
goto|;
block|}
name|PL_stack_sp
operator|=
name|PL_stack_base
operator|+
name|oldmark
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|G_ARRAY
condition|)
name|retval
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|retval
operator|=
literal|1
expr_stmt|;
operator|*
operator|++
name|PL_stack_sp
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
break|break;
block|}
name|JMPENV_POP
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|G_DISCARD
condition|)
block|{
name|PL_stack_sp
operator|=
name|PL_stack_base
operator|+
name|oldmark
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|FREETMPS
expr_stmt|;
name|LEAVE
expr_stmt|;
block|}
name|PL_op
operator|=
name|oldop
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* =for apidoc p||eval_pv  Tells Perl to C<eval> the given string and return an SV* result.  =cut */
end_comment

begin_function
name|SV
modifier|*
name|Perl_eval_pv
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|I32
name|croak_on_error
parameter_list|)
block|{
name|dSP
expr_stmt|;
name|SV
modifier|*
name|sv
init|=
name|newSVpv
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|eval_sv
argument_list|(
name|sv
argument_list|,
name|G_SCALAR
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SPAGAIN
expr_stmt|;
name|sv
operator|=
name|POPs
expr_stmt|;
name|PUTBACK
expr_stmt|;
if|if
condition|(
name|croak_on_error
operator|&&
name|SvTRUE
argument_list|(
name|ERRSV
argument_list|)
condition|)
block|{
name|STRLEN
name|n_a
decl_stmt|;
name|Perl_croak
argument_list|(
argument|aTHX_ SvPVx(ERRSV, n_a)
argument_list|)
empty_stmt|;
block|}
return|return
name|sv
return|;
block|}
end_function

begin_comment
comment|/* Require a module. */
end_comment

begin_comment
comment|/* =for apidoc p||require_pv  Tells Perl to C<require> a module.  =cut */
end_comment

begin_function
name|void
name|Perl_require_pv
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|pv
parameter_list|)
block|{
name|SV
modifier|*
name|sv
decl_stmt|;
name|dSP
expr_stmt|;
name|PUSHSTACKi
argument_list|(
name|PERLSI_REQUIRE
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|sv
operator|=
name|sv_newmortal
argument_list|()
expr_stmt|;
name|sv_setpv
argument_list|(
name|sv
argument_list|,
literal|"require '"
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|sv
argument_list|,
name|pv
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|sv
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
name|eval_sv
argument_list|(
name|sv
argument_list|,
name|G_DISCARD
argument_list|)
expr_stmt|;
name|SPAGAIN
expr_stmt|;
name|POPSTACK
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Perl_magicname
parameter_list|(
name|pTHX_
name|char
modifier|*
name|sym
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|I32
name|namlen
parameter_list|)
block|{
specifier|register
name|GV
modifier|*
name|gv
decl_stmt|;
if|if
condition|(
operator|(
name|gv
operator|=
name|gv_fetchpv
argument_list|(
name|sym
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
operator|)
condition|)
name|sv_magic
argument_list|(
name|GvSV
argument_list|(
name|gv
argument_list|)
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
name|namlen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_usage
parameter_list|(
name|pTHX_
name|char
modifier|*
name|name
parameter_list|)
comment|/* XXX move this out into a module ? */
block|{
comment|/* This message really ought to be max 23 lines.      * Removed -h because the user already knows that opton. Others? */
specifier|static
name|char
modifier|*
name|usage_msg
index|[]
init|=
block|{
literal|"-0[octal]       specify record separator (\\0, if no argument)"
block|,
literal|"-a              autosplit mode with -n or -p (splits $_ into @F)"
block|,
literal|"-C              enable native wide character system interfaces"
block|,
literal|"-c              check syntax only (runs BEGIN and END blocks)"
block|,
literal|"-d[:debugger]   run program under debugger"
block|,
literal|"-D[number/list] set debugging flags (argument is a bit mask or alphabets)"
block|,
literal|"-e 'command'    one line of program (several -e's allowed, omit programfile)"
block|,
literal|"-F/pattern/     split() pattern for -a switch (//'s are optional)"
block|,
literal|"-i[extension]   edit<> files in place (makes backup if extension supplied)"
block|,
literal|"-Idirectory     specify @INC/#include directory (several -I's allowed)"
block|,
literal|"-l[octal]       enable line ending processing, specifies line terminator"
block|,
literal|"-[mM][-]module  execute `use/no module...' before executing program"
block|,
literal|"-n              assume 'while (<>) { ... }' loop around program"
block|,
literal|"-p              assume loop like -n but print line also, like sed"
block|,
literal|"-P              run program through C preprocessor before compilation"
block|,
literal|"-s              enable rudimentary parsing for switches after programfile"
block|,
literal|"-S              look for programfile using PATH environment variable"
block|,
literal|"-T              enable tainting checks"
block|,
literal|"-u              dump core after parsing program"
block|,
literal|"-U              allow unsafe operations"
block|,
literal|"-v              print version, subversion (includes VERY IMPORTANT perl info)"
block|,
literal|"-V[:variable]   print configuration summary (or a single Config.pm variable)"
block|,
literal|"-w              enable many useful warnings (RECOMMENDED)"
block|,
literal|"-W              enable all warnings"
block|,
literal|"-X              disable all warnings"
block|,
literal|"-x[directory]   strip off text before #!perl line and perhaps cd to directory"
block|,
literal|"\n"
block|,
name|NULL
block|}
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
init|=
name|usage_msg
decl_stmt|;
name|printf
argument_list|(
literal|"\nUsage: %s [switches] [--] [programfile] [arguments]"
argument_list|,
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
name|printf
argument_list|(
literal|"\n  %s"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This routine handles any switches that can be given during run */
end_comment

begin_function
name|char
modifier|*
name|Perl_moreswitches
parameter_list|(
name|pTHX_
name|char
modifier|*
name|s
parameter_list|)
block|{
name|I32
name|numlen
decl_stmt|;
name|U32
name|rschar
decl_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'0'
case|:
block|{
name|dTHR
expr_stmt|;
name|rschar
operator|=
operator|(
name|U32
operator|)
name|scan_oct
argument_list|(
name|s
argument_list|,
literal|4
argument_list|,
operator|&
name|numlen
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_nrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rschar
operator|&
operator|~
operator|(
operator|(
name|U8
operator|)
operator|~
literal|0
operator|)
condition|)
name|PL_nrs
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|rschar
operator|&&
name|numlen
operator|>=
literal|2
condition|)
name|PL_nrs
operator|=
name|newSVpvn
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|ch
init|=
name|rschar
decl_stmt|;
name|PL_nrs
operator|=
name|newSVpvn
argument_list|(
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|s
operator|+
name|numlen
return|;
block|}
case|case
literal|'C'
case|:
name|PL_widesyscalls
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'F'
case|:
name|PL_minus_F
operator|=
name|TRUE
expr_stmt|;
name|PL_splitstr
operator|=
name|savepv
argument_list|(
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'a'
case|:
name|PL_minus_a
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'c'
case|:
name|PL_minus_c
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'d'
case|:
name|forbid_setid
argument_list|(
literal|"-d"
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
operator|||
operator|*
name|s
operator|==
literal|'='
condition|)
block|{
name|my_setenv
argument_list|(
literal|"PERL5DB"
argument_list|,
name|Perl_form
argument_list|(
name|aTHX_
literal|"use Devel::%s;"
argument_list|,
operator|++
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|PL_perldb
condition|)
block|{
name|PL_perldb
operator|=
name|PERLDB_ALL
expr_stmt|;
name|init_debugger
argument_list|()
expr_stmt|;
block|}
return|return
name|s
return|;
case|case
literal|'D'
case|:
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
name|forbid_setid
argument_list|(
literal|"-D"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isALPHA
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
specifier|static
name|char
name|debopts
index|[]
init|=
literal|"psltocPmfrxuLHXDS"
decl_stmt|;
name|char
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|s
operator|++
init|;
operator|*
name|s
operator|&&
operator|(
name|d
operator|=
name|strchr
argument_list|(
name|debopts
argument_list|,
operator|*
name|s
argument_list|)
operator|)
condition|;
name|s
operator|++
control|)
name|PL_debug
operator||=
literal|1
operator|<<
operator|(
name|d
operator|-
name|debopts
operator|)
expr_stmt|;
block|}
else|else
block|{
name|PL_debug
operator|=
name|atoi
argument_list|(
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|++
init|;
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
block|}
name|PL_debug
operator||=
literal|0x80000000
expr_stmt|;
else|#
directive|else
name|dTHR
expr_stmt|;
if|if
condition|(
name|ckWARN_d
argument_list|(
name|WARN_DEBUGGING
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_DEBUGGING
argument_list|,
literal|"Recompile perl with -DDEBUGGING to use -D switch\n"
argument_list|)
empty_stmt|;
for|for
control|(
name|s
operator|++
init|;
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
endif|#
directive|endif
comment|/*SUPPRESS 530*/
return|return
name|s
return|;
block|}
case|case
literal|'h'
case|:
name|usage
argument_list|(
name|PL_origargv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|PerlProc_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'i'
case|:
if|if
condition|(
name|PL_inplace
condition|)
name|Safefree
argument_list|(
name|PL_inplace
argument_list|)
expr_stmt|;
name|PL_inplace
operator|=
name|savepv
argument_list|(
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/*SUPPRESS 530*/
for|for
control|(
name|s
operator|=
name|PL_inplace
init|;
operator|*
name|s
operator|&&
operator|!
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
comment|/* Additional switches on #! line. */
name|s
operator|++
expr_stmt|;
block|}
return|return
name|s
return|;
case|case
literal|'I'
case|:
comment|/* -I handled both here and in parse_perl() */
name|forbid_setid
argument_list|(
literal|"-I"
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
block|{
name|char
modifier|*
name|e
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|s
expr_stmt|;
comment|/* ignore trailing spaces (possibly followed by other switches) */
do|do
block|{
for|for
control|(
name|e
operator|=
name|p
init|;
operator|*
name|e
operator|&&
operator|!
name|isSPACE
argument_list|(
operator|*
name|e
argument_list|)
condition|;
name|e
operator|++
control|)
empty_stmt|;
name|p
operator|=
name|e
expr_stmt|;
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'-'
condition|)
do|;
name|e
operator|=
name|savepvn
argument_list|(
name|s
argument_list|,
name|e
operator|-
name|s
argument_list|)
expr_stmt|;
name|incpush
argument_list|(
name|e
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|s
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
name|s
operator|++
expr_stmt|;
block|}
else|else
name|Perl_croak
argument_list|(
name|aTHX_
literal|"No directory specified for -I"
argument_list|)
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'l'
case|:
name|PL_minus_l
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|PL_ors
condition|)
name|Safefree
argument_list|(
name|PL_ors
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|PL_ors
operator|=
name|savepv
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|PL_orslen
operator|=
literal|1
expr_stmt|;
operator|*
name|PL_ors
operator|=
operator|(
name|char
operator|)
name|scan_oct
argument_list|(
name|s
argument_list|,
literal|3
operator|+
operator|(
operator|*
name|s
operator|==
literal|'0'
operator|)
argument_list|,
operator|&
name|numlen
argument_list|)
expr_stmt|;
name|s
operator|+=
name|numlen
expr_stmt|;
block|}
else|else
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
name|RsPARA
argument_list|(
name|PL_nrs
argument_list|)
condition|)
block|{
name|PL_ors
operator|=
literal|"\n\n"
expr_stmt|;
name|PL_orslen
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|PL_ors
operator|=
name|SvPV
argument_list|(
name|PL_nrs
argument_list|,
name|PL_orslen
argument_list|)
expr_stmt|;
name|PL_ors
operator|=
name|savepvn
argument_list|(
name|PL_ors
argument_list|,
name|PL_orslen
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
case|case
literal|'M'
case|:
name|forbid_setid
argument_list|(
literal|"-M"
argument_list|)
expr_stmt|;
comment|/* XXX ? */
comment|/* FALL THROUGH */
case|case
literal|'m'
case|:
name|forbid_setid
argument_list|(
literal|"-m"
argument_list|)
expr_stmt|;
comment|/* XXX ? */
if|if
condition|(
operator|*
operator|++
name|s
condition|)
block|{
name|char
modifier|*
name|start
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|char
modifier|*
name|use
init|=
literal|"use "
decl_stmt|;
comment|/* -M-foo == 'no foo'	*/
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|use
operator|=
literal|"no "
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
name|sv
operator|=
name|newSVpv
argument_list|(
name|use
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|start
operator|=
name|s
expr_stmt|;
comment|/* We allow -M'Module qw(Foo Bar)'	*/
while|while
condition|(
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|':'
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'='
condition|)
block|{
name|sv_catpv
argument_list|(
name|sv
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|start
operator|-
literal|1
operator|)
operator|==
literal|'m'
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't use '%c' after -mname"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|sv
argument_list|,
literal|" ()"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
name|start
argument_list|,
name|s
operator|-
name|start
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|sv
argument_list|,
literal|" split(/,/,q{"
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|sv
argument_list|,
operator|++
name|s
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|sv
argument_list|,
literal|"})"
argument_list|)
expr_stmt|;
block|}
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PL_preambleav
condition|)
name|PL_preambleav
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|av_push
argument_list|(
name|PL_preambleav
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
else|else
name|Perl_croak
argument_list|(
name|aTHX_
literal|"No space allowed after -%c"
argument_list|,
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'n'
case|:
name|PL_minus_n
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'p'
case|:
name|PL_minus_p
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'s'
case|:
name|forbid_setid
argument_list|(
literal|"-s"
argument_list|)
expr_stmt|;
name|PL_doswitches
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'T'
case|:
if|if
condition|(
operator|!
name|PL_tainting
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Too late for \"-T\" option"
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'u'
case|:
name|PL_do_undump
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'U'
case|:
name|PL_unsafe
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'v'
case|:
name|printf
argument_list|(
name|Perl_form
argument_list|(
name|aTHX_
literal|"\nThis is perl, v%vd built for %s"
argument_list|,
name|PL_patchlevel
argument_list|,
name|ARCHNAME
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LOCAL_PATCH_COUNT
argument_list|)
if|if
condition|(
name|LOCAL_PATCH_COUNT
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"\n(with %d registered patch%s, see perl -V for more detail)"
argument_list|,
operator|(
name|int
operator|)
name|LOCAL_PATCH_COUNT
argument_list|,
operator|(
name|LOCAL_PATCH_COUNT
operator|!=
literal|1
operator|)
condition|?
literal|"es"
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"\n\nCopyright 1987-2000, Larry Wall\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MSDOS
name|printf
argument_list|(
literal|"\nMS-DOS port Copyright (c) 1989, 1990, Diomidis Spinellis\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DJGPP
name|printf
argument_list|(
literal|"djgpp v2 port (jpl5003c) by Hirofumi Watanabe, 1996\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"djgpp v2 port (perl5004+) by Laszlo Molnar, 1997-1999\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OS2
name|printf
argument_list|(
literal|"\n\nOS/2 port Copyright (c) 1990, 1991, Raymond Chen, Kai Uwe Rommel\n"
literal|"Version 5 port Copyright (c) 1994-1999, Andreas Kaiser, Ilya Zakharevich\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|atarist
name|printf
argument_list|(
literal|"atariST series port, ++jrb  bammi@cadence.com\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__BEOS__
name|printf
argument_list|(
literal|"BeOS port Copyright Tom Spindler, 1997-1999\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MPE
name|printf
argument_list|(
literal|"MPE/iX port Copyright by Mark Klein and Mark Bixby, 1996-1999\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OEMVS
name|printf
argument_list|(
literal|"MVS (OS390) port by Mortice Kern Systems, 1997-1999\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__VOS__
name|printf
argument_list|(
literal|"Stratus VOS port by Paul_Green@stratus.com, 1997-1999\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__OPEN_VM
name|printf
argument_list|(
literal|"VM/ESA port by Neale Ferguson, 1998-1999\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|POSIX_BC
name|printf
argument_list|(
literal|"BS2000 (POSIX) port by Start Amadeus GmbH, 1998-1999\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__MINT__
name|printf
argument_list|(
literal|"MiNT port by Guido Flohr, 1997-1999\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EPOC
name|printf
argument_list|(
literal|"EPOC port by Olaf Flebbe, 1999-2000\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BINARY_BUILD_NOTICE
name|BINARY_BUILD_NOTICE
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"\n\ Perl may be copied only under the terms of either the Artistic License or the\n\ GNU General Public License, which may be found in the Perl 5.0 source kit.\n\n\ Complete documentation for Perl, including FAQ lists, should be found on\n\ this system using `man perl' or `perldoc perl'.  If you have access to the\n\ Internet, point your browser at http://www.perl.com/, the Perl Home Page.\n\n"
argument_list|)
expr_stmt|;
name|PerlProc_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'w'
case|:
if|if
condition|(
operator|!
operator|(
name|PL_dowarn
operator|&
name|G_WARN_ALL_MASK
operator|)
condition|)
name|PL_dowarn
operator||=
name|G_WARN_ON
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'W'
case|:
name|PL_dowarn
operator|=
name|G_WARN_ALL_ON
operator||
name|G_WARN_ON
expr_stmt|;
name|PL_compiling
operator|.
name|cop_warnings
operator|=
name|pWARN_ALL
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'X'
case|:
name|PL_dowarn
operator|=
name|G_WARN_ALL_OFF
expr_stmt|;
name|PL_compiling
operator|.
name|cop_warnings
operator|=
name|pWARN_NONE
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'*'
case|:
case|case
literal|' '
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
comment|/* Additional switches on #! line. */
return|return
name|s
operator|+
literal|2
return|;
break|break;
case|case
literal|'-'
case|:
case|case
literal|0
case|:
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|PERL_STRICT_CR
argument_list|)
case|case
literal|'\r'
case|:
endif|#
directive|endif
case|case
literal|'\n'
case|:
case|case
literal|'\t'
case|:
break|break;
ifdef|#
directive|ifdef
name|ALTERNATE_SHEBANG
case|case
literal|'S'
case|:
comment|/* OS/2 needs -S on "extproc" line. */
break|break;
endif|#
directive|endif
case|case
literal|'P'
case|:
if|if
condition|(
name|PL_preprocess
condition|)
return|return
name|s
operator|+
literal|1
return|;
comment|/* FALL THROUGH */
default|default:
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't emulate -%.1s on #! line"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|Nullch
return|;
block|}
end_function

begin_comment
comment|/* compliments of Tom Christiansen */
end_comment

begin_comment
comment|/* unexec() can be found in the Gnu emacs distribution */
end_comment

begin_comment
comment|/* Known to work with -DUNEXEC and using unexelf.c from GNU emacs-20.2 */
end_comment

begin_function
name|void
name|Perl_my_unexec
parameter_list|(
name|pTHX
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|UNEXEC
name|SV
modifier|*
name|prog
decl_stmt|;
name|SV
modifier|*
name|file
decl_stmt|;
name|int
name|status
init|=
literal|1
decl_stmt|;
specifier|extern
name|int
name|etext
decl_stmt|;
name|prog
operator|=
name|newSVpv
argument_list|(
name|BIN_EXP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|prog
argument_list|,
literal|"/perl"
argument_list|)
expr_stmt|;
name|file
operator|=
name|newSVpv
argument_list|(
name|PL_origfilename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|file
argument_list|,
literal|".perldump"
argument_list|)
expr_stmt|;
name|unexec
argument_list|(
name|SvPVX
argument_list|(
name|file
argument_list|)
argument_list|,
name|SvPVX
argument_list|(
name|prog
argument_list|)
argument_list|,
operator|&
name|etext
argument_list|,
name|sbrk
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* unexec prints msg to stderr in case of failure */
name|PerlProc_exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|VMS
include|#
directive|include
file|<lib$routines.h>
name|lib$signal
argument_list|(
name|SS$_DEBUG
argument_list|)
expr_stmt|;
comment|/* ssdef.h #included from vmsish.h */
else|#
directive|else
name|ABORT
argument_list|()
expr_stmt|;
comment|/* for use with undump */
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* initialize curinterp */
end_comment

begin_function
name|STATIC
name|void
name|S_init_interp
parameter_list|(
name|pTHX
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PERL_OBJECT
comment|/* XXX kludge */
define|#
directive|define
name|I_REINIT
define|\
value|STMT_START {				\     PL_chopset		= " \n-";	\     PL_copline		= NOLINE;	\     PL_curcop		=&PL_compiling;\     PL_curcopdb		= NULL;		\     PL_dbargs		= 0;		\     PL_dumpindent	= 4;		\     PL_laststatval	= -1;		\     PL_laststype	= OP_STAT;	\     PL_maxscream	= -1;		\     PL_maxsysfd		= MAXSYSFD;	\     PL_statname		= Nullsv;	\     PL_tmps_floor	= -1;		\     PL_tmps_ix		= -1;		\     PL_op_mask		= NULL;		\     PL_laststatval	= -1;		\     PL_laststype	= OP_STAT;	\     PL_mess_sv		= Nullsv;	\     PL_splitstr		= " ";		\     PL_generation	= 100;		\     PL_exitlist		= NULL;		\     PL_exitlistlen	= 0;		\     PL_regindent	= 0;		\     PL_in_clean_objs	= FALSE;	\     PL_in_clean_all	= FALSE;	\     PL_profiledata	= NULL;		\     PL_rsfp		= Nullfp;	\     PL_rsfp_filters	= Nullav;	\     PL_dirty		= FALSE;	\   } STMT_END
name|I_REINIT
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|MULTIPLICITY
define|#
directive|define
name|PERLVAR
parameter_list|(
name|var
parameter_list|,
name|type
parameter_list|)
define|#
directive|define
name|PERLVARA
parameter_list|(
name|var
parameter_list|,
name|n
parameter_list|,
name|type
parameter_list|)
if|#
directive|if
name|defined
argument_list|(
name|PERL_IMPLICIT_CONTEXT
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|USE_THREADS
argument_list|)
define|#
directive|define
name|PERLVARI
parameter_list|(
name|var
parameter_list|,
name|type
parameter_list|,
name|init
parameter_list|)
value|PERL_GET_INTERP->var = init;
define|#
directive|define
name|PERLVARIC
parameter_list|(
name|var
parameter_list|,
name|type
parameter_list|,
name|init
parameter_list|)
value|PERL_GET_INTERP->var = init;
else|#
directive|else
comment|/* !USE_THREADS */
define|#
directive|define
name|PERLVARI
parameter_list|(
name|var
parameter_list|,
name|type
parameter_list|,
name|init
parameter_list|)
value|aTHX->var = init;
define|#
directive|define
name|PERLVARIC
parameter_list|(
name|var
parameter_list|,
name|type
parameter_list|,
name|init
parameter_list|)
value|aTHX->var = init;
endif|#
directive|endif
comment|/* USE_THREADS */
else|#
directive|else
define|#
directive|define
name|PERLVARI
parameter_list|(
name|var
parameter_list|,
name|type
parameter_list|,
name|init
parameter_list|)
value|PERL_GET_INTERP->var = init;
define|#
directive|define
name|PERLVARIC
parameter_list|(
name|var
parameter_list|,
name|type
parameter_list|,
name|init
parameter_list|)
value|PERL_GET_INTERP->var = init;
endif|#
directive|endif
include|#
directive|include
file|"intrpvar.h"
ifndef|#
directive|ifndef
name|USE_THREADS
include|#
directive|include
file|"thrdvar.h"
endif|#
directive|endif
undef|#
directive|undef
name|PERLVAR
undef|#
directive|undef
name|PERLVARA
undef|#
directive|undef
name|PERLVARI
undef|#
directive|undef
name|PERLVARIC
else|#
directive|else
define|#
directive|define
name|PERLVAR
parameter_list|(
name|var
parameter_list|,
name|type
parameter_list|)
define|#
directive|define
name|PERLVARA
parameter_list|(
name|var
parameter_list|,
name|n
parameter_list|,
name|type
parameter_list|)
define|#
directive|define
name|PERLVARI
parameter_list|(
name|var
parameter_list|,
name|type
parameter_list|,
name|init
parameter_list|)
value|PL_##var = init;
define|#
directive|define
name|PERLVARIC
parameter_list|(
name|var
parameter_list|,
name|type
parameter_list|,
name|init
parameter_list|)
value|PL_##var = init;
include|#
directive|include
file|"intrpvar.h"
ifndef|#
directive|ifndef
name|USE_THREADS
include|#
directive|include
file|"thrdvar.h"
endif|#
directive|endif
undef|#
directive|undef
name|PERLVAR
undef|#
directive|undef
name|PERLVARA
undef|#
directive|undef
name|PERLVARI
undef|#
directive|undef
name|PERLVARIC
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_function
name|STATIC
name|void
name|S_init_main_stash
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
comment|/* Note that strtab is a rather special HV.  Assumptions are made        about not iterating on it, and not adding tie magic to it.        It is properly deallocated in perl_destruct() */
name|PL_strtab
operator|=
name|newHV
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|MUTEX_INIT
argument_list|(
operator|&
name|PL_strtab_mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|HvSHAREKEYS_off
argument_list|(
name|PL_strtab
argument_list|)
expr_stmt|;
comment|/* mandatory */
name|hv_ksplit
argument_list|(
name|PL_strtab
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|PL_curstash
operator|=
name|PL_defstash
operator|=
name|newHV
argument_list|()
expr_stmt|;
name|PL_curstname
operator|=
name|newSVpvn
argument_list|(
literal|"main"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gv
operator|=
name|gv_fetchpv
argument_list|(
literal|"main::"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVHV
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|GvHV
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
name|GvHV
argument_list|(
name|gv
argument_list|)
operator|=
operator|(
name|HV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|PL_defstash
argument_list|)
expr_stmt|;
name|SvREADONLY_on
argument_list|(
name|gv
argument_list|)
expr_stmt|;
name|HvNAME
argument_list|(
name|PL_defstash
argument_list|)
operator|=
name|savepv
argument_list|(
literal|"main"
argument_list|)
expr_stmt|;
name|PL_incgv
operator|=
name|gv_HVadd
argument_list|(
name|gv_AVadd
argument_list|(
name|gv_fetchpv
argument_list|(
literal|"INC"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVAV
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|GvMULTI_on
argument_list|(
name|PL_incgv
argument_list|)
expr_stmt|;
name|PL_hintgv
operator|=
name|gv_fetchpv
argument_list|(
literal|"\010"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
comment|/* ^H */
name|GvMULTI_on
argument_list|(
name|PL_hintgv
argument_list|)
expr_stmt|;
name|PL_defgv
operator|=
name|gv_fetchpv
argument_list|(
literal|"_"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVAV
argument_list|)
expr_stmt|;
name|PL_errgv
operator|=
name|gv_HVadd
argument_list|(
name|gv_fetchpv
argument_list|(
literal|"@"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
argument_list|)
expr_stmt|;
name|GvMULTI_on
argument_list|(
name|PL_errgv
argument_list|)
expr_stmt|;
name|PL_replgv
operator|=
name|gv_fetchpv
argument_list|(
literal|"\022"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
comment|/* ^R */
name|GvMULTI_on
argument_list|(
name|PL_replgv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Perl_form
argument_list|(
name|aTHX_
literal|"%240s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Preallocate temp - for immediate signals. */
name|sv_grow
argument_list|(
name|ERRSV
argument_list|,
literal|240
argument_list|)
expr_stmt|;
comment|/* Preallocate - for immediate signals. */
name|sv_setpvn
argument_list|(
name|ERRSV
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PL_curstash
operator|=
name|PL_defstash
expr_stmt|;
name|CopSTASH_set
argument_list|(
operator|&
name|PL_compiling
argument_list|,
name|PL_defstash
argument_list|)
expr_stmt|;
name|PL_debstash
operator|=
name|GvHV
argument_list|(
name|gv_fetchpv
argument_list|(
literal|"DB::"
argument_list|,
name|GV_ADDMULTI
argument_list|,
name|SVt_PVHV
argument_list|)
argument_list|)
expr_stmt|;
name|PL_globalstash
operator|=
name|GvHV
argument_list|(
name|gv_fetchpv
argument_list|(
literal|"CORE::GLOBAL::"
argument_list|,
name|GV_ADDMULTI
argument_list|,
name|SVt_PVHV
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We must init $/ before switches are processed. */
name|sv_setpvn
argument_list|(
name|get_sv
argument_list|(
literal|"/"
argument_list|,
name|TRUE
argument_list|)
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|S_open_script
parameter_list|(
name|pTHX_
name|char
modifier|*
name|scriptname
parameter_list|,
name|bool
name|dosearch
parameter_list|,
name|SV
modifier|*
name|sv
parameter_list|,
name|int
modifier|*
name|fdscript
parameter_list|)
block|{
name|dTHR
expr_stmt|;
operator|*
name|fdscript
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|PL_e_script
condition|)
block|{
name|PL_origfilename
operator|=
name|savepv
argument_list|(
literal|"-e"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* if find_script() returns, it returns a malloc()-ed value */
name|PL_origfilename
operator|=
name|scriptname
operator|=
name|find_script
argument_list|(
name|scriptname
argument_list|,
name|dosearch
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
name|scriptname
argument_list|,
literal|"/dev/fd/"
argument_list|,
literal|8
argument_list|)
operator|&&
name|isDIGIT
argument_list|(
name|scriptname
index|[
literal|8
index|]
argument_list|)
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|scriptname
operator|+
literal|8
decl_stmt|;
operator|*
name|fdscript
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
block|{
name|scriptname
operator|=
name|savepv
argument_list|(
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|PL_origfilename
argument_list|)
expr_stmt|;
name|PL_origfilename
operator|=
name|scriptname
expr_stmt|;
block|}
block|}
block|}
name|CopFILE_set
argument_list|(
name|PL_curcop
argument_list|,
name|PL_origfilename
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|PL_origfilename
argument_list|,
literal|"-"
argument_list|)
condition|)
name|scriptname
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|*
name|fdscript
operator|>=
literal|0
condition|)
block|{
name|PL_rsfp
operator|=
name|PerlIO_fdopen
argument_list|(
operator|*
name|fdscript
argument_list|,
name|PERL_SCRIPT_MODE
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAS_FCNTL
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_SETFD
argument_list|)
if|if
condition|(
name|PL_rsfp
condition|)
name|fcntl
argument_list|(
name|PerlIO_fileno
argument_list|(
name|PL_rsfp
argument_list|)
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* ensure close-on-exec */
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|PL_preprocess
condition|)
block|{
name|char
modifier|*
name|cpp_cfg
init|=
name|CPPSTDIN
decl_stmt|;
name|SV
modifier|*
name|cpp
init|=
name|newSVpvn
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|SV
modifier|*
name|cmd
init|=
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|cpp_cfg
argument_list|,
literal|"cppstdin"
argument_list|)
condition|)
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ cpp
argument_list|,
literal|"%s/"
argument_list|,
argument|BIN_EXP
argument_list|)
empty_stmt|;
name|sv_catpv
argument_list|(
name|cpp
argument_list|,
name|cpp_cfg
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
literal|"-I"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|sv
argument_list|,
name|PRIVLIB_EXP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MSDOS
name|Perl_sv_setpvf
argument_list|(
argument|aTHX_ cmd
argument_list|,
literal|"\ sed %s -e \"/^[^#]/b\" \  -e \"/^#[ 	]*include[ 	]/b\" \  -e \"/^#[ 	]*define[ 	]/b\" \  -e \"/^#[ 	]*if[ 	]/b\" \  -e \"/^#[ 	]*ifdef[ 	]/b\" \  -e \"/^#[ 	]*ifndef[ 	]/b\" \  -e \"/^#[ 	]*else/b\" \  -e \"/^#[ 	]*elif[ 	]/b\" \  -e \"/^#[ 	]*undef[ 	]/b\" \  -e \"/^#[ 	]*endif/b\" \  -e \"s/^#.*//\" \  %s | %"
argument|SVf
literal|" -C %"
argument|SVf
literal|" %s"
argument_list|,
argument|(PL_doextract ?
literal|"-e \"1,/^#/d\n\""
argument|:
literal|""
argument|)
argument_list|,
else|#
directive|else
ifdef|#
directive|ifdef
name|__OPEN_VM
argument|Perl_sv_setpvf(aTHX_ cmd,
literal|"\ %s %s -e '/^[^#]/b' \  -e '/^#[ 	]*include[ 	]/b' \  -e '/^#[ 	]*define[ 	]/b' \  -e '/^#[ 	]*if[ 	]/b' \  -e '/^#[ 	]*ifdef[ 	]/b' \  -e '/^#[ 	]*ifndef[ 	]/b' \  -e '/^#[ 	]*else/b' \  -e '/^#[ 	]*elif[ 	]/b' \  -e '/^#[ 	]*undef[ 	]/b' \  -e '/^#[ 	]*endif/b' \  -e 's/^[ 	]*#.*//' \  %s | %"
argument|SVf
literal|" %"
argument|SVf
literal|" %s"
argument|,
else|#
directive|else
argument|Perl_sv_setpvf(aTHX_ cmd,
literal|"\ %s %s -e '/^[^#]/b' \  -e '/^#[ 	]*include[ 	]/b' \  -e '/^#[ 	]*define[ 	]/b' \  -e '/^#[ 	]*if[ 	]/b' \  -e '/^#[ 	]*ifdef[ 	]/b' \  -e '/^#[ 	]*ifndef[ 	]/b' \  -e '/^#[ 	]*else/b' \  -e '/^#[ 	]*elif[ 	]/b' \  -e '/^#[ 	]*undef[ 	]/b' \  -e '/^#[ 	]*endif/b' \  -e 's/^[ 	]*#.*//' \  %s | %"
argument|SVf
literal|" -C %"
argument|SVf
literal|" %s"
argument|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOC_SED
argument|LOC_SED,
else|#
directive|else
literal|"sed"
argument|,
endif|#
directive|endif
argument|(PL_doextract ?
literal|"-e '1,/^#/d\n'"
argument|:
literal|""
argument|),
endif|#
directive|endif
argument|scriptname, cpp, sv, CPPMINUS); 	PL_doextract = FALSE;
ifdef|#
directive|ifdef
name|IAMSUID
comment|/* actually, this is caught earlier */
argument|if (PL_euid != PL_uid&& !PL_euid) {
comment|/* if running suidperl */
ifdef|#
directive|ifdef
name|HAS_SETEUID
argument|(void)seteuid(PL_uid);
comment|/* musn't stay setuid root */
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETREUID
argument|(void)setreuid((Uid_t)-
literal|1
argument|, PL_uid);
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETRESUID
argument|(void)setresuid((Uid_t)-
literal|1
argument|, PL_uid, (Uid_t)-
literal|1
argument|);
else|#
directive|else
argument|PerlProc_setuid(PL_uid);
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
argument|if (PerlProc_geteuid() != PL_uid) 		Perl_croak(aTHX_
literal|"Can't do seteuid!\n"
argument|); 	}
endif|#
directive|endif
comment|/* IAMSUID */
argument|PL_rsfp = PerlProc_popen(SvPVX(cmd),
literal|"r"
argument|); 	SvREFCNT_dec(cmd); 	SvREFCNT_dec(cpp);     }     else if (!*scriptname) { 	forbid_setid(
literal|"program input from stdin"
argument|); 	PL_rsfp = PerlIO_stdin();     }     else { 	PL_rsfp = PerlIO_open(scriptname,PERL_SCRIPT_MODE);
if|#
directive|if
name|defined
argument_list|(
name|HAS_FCNTL
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_SETFD
argument_list|)
argument|if (PL_rsfp) 	    fcntl(PerlIO_fileno(PL_rsfp),F_SETFD,
literal|1
argument|);
comment|/* ensure close-on-exec */
endif|#
directive|endif
argument|}     if (!PL_rsfp) {
ifdef|#
directive|ifdef
name|DOSUID
ifndef|#
directive|ifndef
name|IAMSUID
comment|/* in case script is not readable before setuid */
argument|if (PL_euid&& 	    PerlLIO_stat(CopFILE(PL_curcop),&PL_statbuf)>=
literal|0
argument|&& 	    PL_statbuf.st_mode& (S_ISUID|S_ISGID)) 	{
comment|/* try again */
argument|PerlProc_execv(Perl_form(aTHX_
literal|"%s/sperl"
argument|PERL_FS_VER_FMT, BIN_EXP, 				     (int)PERL_REVISION, (int)PERL_VERSION, 				     (int)PERL_SUBVERSION), PL_origargv); 	    Perl_croak(aTHX_
literal|"Can't do setuid; ensure that the setuid bit is set on suidperl\n"
argument|); 	}
endif|#
directive|endif
endif|#
directive|endif
argument|Perl_croak(aTHX_
literal|"Can't open perl script \"%s\": %s\n"
argument|, 		   CopFILE(PL_curcop), Strerror(errno));     } }
comment|/* Mention  * I_SYSSTATVFS	HAS_FSTATVFS  * I_SYSMOUNT  * I_STATFS	HAS_FSTATFS	HAS_GETFSSTAT  * I_MNTENT	HAS_GETMNTENT	HAS_HASMNTOPT  * here so that metaconfig picks them up. */
ifdef|#
directive|ifdef
name|IAMSUID
argument|STATIC int S_fd_on_nosuid_fs(pTHX_ int fd) {     int check_okay =
literal|0
argument|;
comment|/* able to do all the required sys/libcalls */
argument|int on_nosuid  =
literal|0
argument|;
comment|/* the fd is on a nosuid fs */
comment|/*  * Preferred order: fstatvfs(), fstatfs(), ustat()+getmnt(), getmntent().  * fstatvfs() is UNIX98.  * fstatfs() is 4.3 BSD.  * ustat()+getmnt() is pre-4.3 BSD.  * getmntent() is O(number-of-mounted-filesystems) and can hang on  * an irrelevant filesystem while trying to reach the right one.  */
ifdef|#
directive|ifdef
name|HAS_FSTATVFS
argument|struct statvfs stfs;     check_okay = fstatvfs(fd,&stfs) ==
literal|0
argument|;     on_nosuid  = check_okay&& (stfs.f_flag& ST_NOSUID);
else|#
directive|else
ifdef|#
directive|ifdef
name|PERL_MOUNT_NOSUID
if|#
directive|if
name|defined
argument_list|(
name|HAS_FSTATFS
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAS_STRUCT_STATFS
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAS_STRUCT_STATFS_F_FLAGS
argument_list|)
argument|struct statfs  stfs;     check_okay = fstatfs(fd,&stfs)  ==
literal|0
argument|;     on_nosuid  = check_okay&& (stfs.f_flags& PERL_MOUNT_NOSUID);
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|HAS_FSTAT
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAS_USTAT
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAS_GETMNT
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAS_STRUCT_FS_DATA
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|NOSTAT_ONE
argument_list|)
argument|struct stat fdst;     if (fstat(fd,&fdst) ==
literal|0
argument|) { 	struct ustat us; 	if (ustat(fdst.st_dev,&us) ==
literal|0
argument|) { 	    struct fs_data fsd;
comment|/* NOSTAT_ONE here because we're not examining fields which 	     * vary between that case and STAT_ONE. */
argument|if (getmnt((int*)
literal|0
argument|,&fsd, (int)
literal|0
argument|, NOSTAT_ONE, us.f_fname) ==
literal|0
argument|) { 		size_t cmplen = sizeof(us.f_fname); 		if (sizeof(fsd.fd_req.path)< cmplen) 		    cmplen = sizeof(fsd.fd_req.path); 		if (strnEQ(fsd.fd_req.path, us.f_fname, cmplen)&& 		    fdst.st_dev == fsd.fd_req.dev) { 			check_okay =
literal|1
argument|; 			on_nosuid = fsd.fd_req.flags& PERL_MOUNT_NOSUID; 		    } 		} 	    } 	}     }
endif|#
directive|endif
comment|/* fstat+ustat+getmnt */
endif|#
directive|endif
comment|/* fstatfs */
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|HAS_GETMNTENT
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAS_HASMNTOPT
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|MNTOPT_NOSUID
argument_list|)
argument|FILE		*mtab = fopen(
literal|"/etc/mtab"
argument|,
literal|"r"
argument|);     struct mntent	*entry;     struct stat		stb, fsb;      if (mtab&& (fstat(fd,&stb) ==
literal|0
argument|)) { 	while (entry = getmntent(mtab)) { 	    if (stat(entry->mnt_dir,&fsb) ==
literal|0
argument|&& fsb.st_dev == stb.st_dev) 	    {
comment|/* found the filesystem */
argument|check_okay =
literal|1
argument|; 		if (hasmntopt(entry, MNTOPT_NOSUID)) 		    on_nosuid =
literal|1
argument|; 		break; 	    }
comment|/* A single fs may well fail its stat(). */
argument|}     }     if (mtab) 	fclose(mtab);
endif|#
directive|endif
comment|/* getmntent+hasmntopt */
endif|#
directive|endif
comment|/* PERL_MOUNT_NOSUID: fstatfs or fstat+ustat+statfs */
endif|#
directive|endif
comment|/* statvfs */
argument|if (!check_okay)  	Perl_croak(aTHX_
literal|"Can't check filesystem of script \"%s\" for nosuid"
argument|, PL_origfilename);     return on_nosuid; }
endif|#
directive|endif
comment|/* IAMSUID */
argument|STATIC void S_validate_suid(pTHX_ char *validarg, char *scriptname, int fdscript) {
ifdef|#
directive|ifdef
name|IAMSUID
argument|int which;
endif|#
directive|endif
comment|/* do we need to emulate setuid on scripts? */
comment|/* This code is for those BSD systems that have setuid #! scripts disabled      * in the kernel because of a security problem.  Merely defining DOSUID      * in perl will not fix that problem, but if you have disabled setuid      * scripts in the kernel, this will attempt to emulate setuid and setgid      * on scripts that have those now-otherwise-useless bits set.  The setuid      * root version must be called suidperl or sperlN.NNN.  If regular perl      * discovers that it has opened a setuid script, it calls suidperl with      * the same argv that it had.  If suidperl finds that the script it has      * just opened is NOT setuid root, it sets the effective uid back to the      * uid.  We don't just make perl setuid root because that loses the      * effective uid we had before invoking perl, if it was different from the      * uid.      *      * DOSUID must be defined in both perl and suidperl, and IAMSUID must      * be defined in suidperl only.  suidperl must be setuid root.  The      * Configure script will set this up for you if you want it.      */
ifdef|#
directive|ifdef
name|DOSUID
argument|dTHR;     char *s, *s2;      if (PerlLIO_fstat(PerlIO_fileno(PL_rsfp),&PL_statbuf)<
literal|0
argument|)
comment|/* normal stat is insecure */
argument|Perl_croak(aTHX_
literal|"Can't stat script \"%s\""
argument|,PL_origfilename);     if (fdscript<
literal|0
argument|&& PL_statbuf.st_mode& (S_ISUID|S_ISGID)) { 	I32 len; 	STRLEN n_a;
ifdef|#
directive|ifdef
name|IAMSUID
ifndef|#
directive|ifndef
name|HAS_SETREUID
comment|/* On this access check to make sure the directories are readable, 	 * there is actually a small window that the user could use to make 	 * filename point to an accessible directory.  So there is a faint 	 * chance that someone could execute a setuid script down in a 	 * non-accessible directory.  I don't know what to do about that. 	 * But I don't think it's too important.  The manual lies when 	 * it says access() is useful in setuid programs. 	 */
argument|if (PerlLIO_access(CopFILE(PL_curcop),
literal|1
argument|))
comment|/*double check*/
argument|Perl_croak(aTHX_
literal|"Permission denied"
argument|);
else|#
directive|else
comment|/* If we can swap euid and uid, then we can determine access rights 	 * with a simple stat of the file, and then compare device and 	 * inode to make sure we did stat() on the same file we opened. 	 * Then we just have to make sure he or she can execute it. 	 */
argument|{ 	    struct stat tmpstatbuf;  	    if (
ifdef|#
directive|ifdef
name|HAS_SETREUID
argument|setreuid(PL_euid,PL_uid)<
literal|0
else|#
directive|else
if|#
directive|if
name|HAS_SETRESUID
argument|setresuid(PL_euid,PL_uid,(Uid_t)-
literal|1
argument|)<
literal|0
endif|#
directive|endif
endif|#
directive|endif
argument||| PerlProc_getuid() != PL_euid || PerlProc_geteuid() != PL_uid) 		Perl_croak(aTHX_
literal|"Can't swap uid and euid"
argument|);
comment|/* really paranoid */
argument|if (PerlLIO_stat(CopFILE(PL_curcop),&tmpstatbuf)<
literal|0
argument|) 		Perl_croak(aTHX_
literal|"Permission denied"
argument|);
comment|/* testing full pathname here */
if|#
directive|if
name|defined
argument_list|(
name|IAMSUID
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_NOSUID_CHECK
argument_list|)
argument|if (fd_on_nosuid_fs(PerlIO_fileno(PL_rsfp))) 		Perl_croak(aTHX_
literal|"Permission denied"
argument|);
endif|#
directive|endif
argument|if (tmpstatbuf.st_dev != PL_statbuf.st_dev || 		tmpstatbuf.st_ino != PL_statbuf.st_ino) { 		(void)PerlIO_close(PL_rsfp); 		Perl_croak(aTHX_
literal|"Permission denied\n"
argument|); 	    } 	    if (
ifdef|#
directive|ifdef
name|HAS_SETREUID
argument|setreuid(PL_uid,PL_euid)<
literal|0
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|HAS_SETRESUID
argument_list|)
argument|setresuid(PL_uid,PL_euid,(Uid_t)-
literal|1
argument|)<
literal|0
endif|#
directive|endif
endif|#
directive|endif
argument||| PerlProc_getuid() != PL_uid || PerlProc_geteuid() != PL_euid) 		Perl_croak(aTHX_
literal|"Can't reswap uid and euid"
argument|); 	    if (!cando(S_IXUSR,FALSE,&PL_statbuf))
comment|/* can real uid exec? */
argument|Perl_croak(aTHX_
literal|"Permission denied\n"
argument|); 	}
endif|#
directive|endif
comment|/* HAS_SETREUID */
endif|#
directive|endif
comment|/* IAMSUID */
argument|if (!S_ISREG(PL_statbuf.st_mode)) 	    Perl_croak(aTHX_
literal|"Permission denied"
argument|); 	if (PL_statbuf.st_mode& S_IWOTH) 	    Perl_croak(aTHX_
literal|"Setuid/gid script is writable by world"
argument|); 	PL_doswitches = FALSE;
comment|/* -s is insecure in suid */
argument|CopLINE_inc(PL_curcop); 	if (sv_gets(PL_linestr, PL_rsfp,
literal|0
argument|) == Nullch || 	  strnNE(SvPV(PL_linestr,n_a),
literal|"#!"
argument|,
literal|2
argument|) )
comment|/* required even on Sys V */
argument|Perl_croak(aTHX_
literal|"No #! line"
argument|); 	s = SvPV(PL_linestr,n_a)+
literal|2
argument|; 	if (*s ==
literal|' '
argument|) s++; 	while (!isSPACE(*s)) s++; 	for (s2 = s;  (s2> SvPV(PL_linestr,n_a)+
literal|2
argument|&& 		       (isDIGIT(s2[-
literal|1
argument|]) || strchr(
literal|"._-"
argument|, s2[-
literal|1
argument|])));  s2--) ; 	if (strnNE(s2-
literal|4
argument|,
literal|"perl"
argument|,
literal|4
argument|)&& strnNE(s-
literal|9
argument|,
literal|"perl"
argument|,
literal|4
argument|))
comment|/* sanity check */
argument|Perl_croak(aTHX_
literal|"Not a perl script"
argument|); 	while (*s ==
literal|' '
argument||| *s ==
literal|'\t'
argument|) s++;
comment|/* 	 * #! arg must be what we saw above.  They can invoke it by 	 * mentioning suidperl explicitly, but they may not add any strange 	 * arguments beyond what #! says if they do invoke suidperl that way. 	 */
argument|len = strlen(validarg); 	if (strEQ(validarg,
literal|" PHOOEY "
argument|) || 	    strnNE(s,validarg,len) || !isSPACE(s[len])) 	    Perl_croak(aTHX_
literal|"Args must match #! line"
argument|);
ifndef|#
directive|ifndef
name|IAMSUID
argument|if (PL_euid != PL_uid&& (PL_statbuf.st_mode& S_ISUID)&& 	    PL_euid == PL_statbuf.st_uid) 	    if (!PL_do_undump) 		Perl_croak(aTHX_
literal|"YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET!\n\ FIX YOUR KERNEL, PUT A C WRAPPER AROUND THIS SCRIPT, OR USE -u AND UNDUMP!\n"
argument|);
endif|#
directive|endif
comment|/* IAMSUID */
argument|if (PL_euid) {
comment|/* oops, we're not the setuid root perl */
argument|(void)PerlIO_close(PL_rsfp);
ifndef|#
directive|ifndef
name|IAMSUID
comment|/* try again */
argument|PerlProc_execv(Perl_form(aTHX_
literal|"%s/sperl"
argument|PERL_FS_VER_FMT, BIN_EXP, 				     (int)PERL_REVISION, (int)PERL_VERSION, 				     (int)PERL_SUBVERSION), PL_origargv);
endif|#
directive|endif
argument|Perl_croak(aTHX_
literal|"Can't do setuid; ensure that the setuid bit is set on suidperl\n"
argument|); 	}  	if (PL_statbuf.st_mode& S_ISGID&& PL_statbuf.st_gid != PL_egid) {
ifdef|#
directive|ifdef
name|HAS_SETEGID
argument|(void)setegid(PL_statbuf.st_gid);
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETREGID
argument|(void)setregid((Gid_t)-
literal|1
argument|,PL_statbuf.st_gid);
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETRESGID
argument|(void)setresgid((Gid_t)-
literal|1
argument|,PL_statbuf.st_gid,(Gid_t)-
literal|1
argument|);
else|#
directive|else
argument|PerlProc_setgid(PL_statbuf.st_gid);
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
argument|if (PerlProc_getegid() != PL_statbuf.st_gid) 		Perl_croak(aTHX_
literal|"Can't do setegid!\n"
argument|); 	} 	if (PL_statbuf.st_mode& S_ISUID) { 	    if (PL_statbuf.st_uid != PL_euid)
ifdef|#
directive|ifdef
name|HAS_SETEUID
argument|(void)seteuid(PL_statbuf.st_uid);
comment|/* all that for this */
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETREUID
argument|(void)setreuid((Uid_t)-
literal|1
argument|,PL_statbuf.st_uid);
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETRESUID
argument|(void)setresuid((Uid_t)-
literal|1
argument|,PL_statbuf.st_uid,(Uid_t)-
literal|1
argument|);
else|#
directive|else
argument|PerlProc_setuid(PL_statbuf.st_uid);
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
argument|if (PerlProc_geteuid() != PL_statbuf.st_uid) 		Perl_croak(aTHX_
literal|"Can't do seteuid!\n"
argument|); 	} 	else if (PL_uid) {
comment|/* oops, mustn't run as root */
ifdef|#
directive|ifdef
name|HAS_SETEUID
argument|(void)seteuid((Uid_t)PL_uid);
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETREUID
argument|(void)setreuid((Uid_t)-
literal|1
argument|,(Uid_t)PL_uid);
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETRESUID
argument|(void)setresuid((Uid_t)-
literal|1
argument|,(Uid_t)PL_uid,(Uid_t)-
literal|1
argument|);
else|#
directive|else
argument|PerlProc_setuid((Uid_t)PL_uid);
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
argument|if (PerlProc_geteuid() != PL_uid) 		Perl_croak(aTHX_
literal|"Can't do seteuid!\n"
argument|); 	} 	init_ids(); 	if (!cando(S_IXUSR,TRUE,&PL_statbuf)) 	    Perl_croak(aTHX_
literal|"Permission denied\n"
argument|);
comment|/* they can't do this */
argument|}
ifdef|#
directive|ifdef
name|IAMSUID
argument|else if (PL_preprocess) 	Perl_croak(aTHX_
literal|"-P not allowed for setuid/setgid script\n"
argument|);     else if (fdscript>=
literal|0
argument|) 	Perl_croak(aTHX_
literal|"fd script not allowed in suidperl\n"
argument|);     else 	Perl_croak(aTHX_
literal|"Script is not setuid/setgid in suidperl\n"
argument|);
comment|/* We absolutely must clear out any saved ids here, so we */
comment|/* exec the real perl, substituting fd script for scriptname. */
comment|/* (We pass script name as "subdir" of fd, which perl will grok.) */
argument|PerlIO_rewind(PL_rsfp);     PerlLIO_lseek(PerlIO_fileno(PL_rsfp),(Off_t)
literal|0
argument|,
literal|0
argument|);
comment|/* just in case rewind didn't */
argument|for (which =
literal|1
argument|; PL_origargv[which]&& PL_origargv[which] != scriptname; which++) ;     if (!PL_origargv[which]) 	Perl_croak(aTHX_
literal|"Permission denied"
argument|);     PL_origargv[which] = savepv(Perl_form(aTHX_
literal|"/dev/fd/%d/%s"
argument|, 				  PerlIO_fileno(PL_rsfp), PL_origargv[which]));
if|#
directive|if
name|defined
argument_list|(
name|HAS_FCNTL
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_SETFD
argument_list|)
argument|fcntl(PerlIO_fileno(PL_rsfp),F_SETFD,
literal|0
argument|);
comment|/* ensure no close-on-exec */
endif|#
directive|endif
argument|PerlProc_execv(Perl_form(aTHX_
literal|"%s/perl"
argument|PERL_FS_VER_FMT, BIN_EXP, 			     (int)PERL_REVISION, (int)PERL_VERSION, 			     (int)PERL_SUBVERSION), PL_origargv);
comment|/* try again */
argument|Perl_croak(aTHX_
literal|"Can't do setuid; ensure that the setuid bit is set on suidperl\n"
argument|);
endif|#
directive|endif
comment|/* IAMSUID */
else|#
directive|else
comment|/* !DOSUID */
argument|if (PL_euid != PL_uid || PL_egid != PL_gid) {
comment|/* (suidperl doesn't exist, in fact) */
ifndef|#
directive|ifndef
name|SETUID_SCRIPTS_ARE_SECURE_NOW
argument|dTHR; 	PerlLIO_fstat(PerlIO_fileno(PL_rsfp),&PL_statbuf);
comment|/* may be either wrapped or real suid */
argument|if ((PL_euid != PL_uid&& PL_euid == PL_statbuf.st_uid&& PL_statbuf.st_mode& S_ISUID) 	    || 	    (PL_egid != PL_gid&& PL_egid == PL_statbuf.st_gid&& PL_statbuf.st_mode& S_ISGID) 	   ) 	    if (!PL_do_undump) 		Perl_croak(aTHX_
literal|"YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET!\n\ FIX YOUR KERNEL, PUT A C WRAPPER AROUND THIS SCRIPT, OR USE -u AND UNDUMP!\n"
argument|);
endif|#
directive|endif
comment|/* SETUID_SCRIPTS_ARE_SECURE_NOW */
comment|/* not set-id, must be wrapped */
argument|}
endif|#
directive|endif
comment|/* DOSUID */
argument|}  STATIC void S_find_beginning(pTHX) {     register char *s, *s2;
comment|/* skip forward in input to the real script? */
argument|forbid_setid(
literal|"-x"
argument|);     while (PL_doextract) { 	if ((s = sv_gets(PL_linestr, PL_rsfp,
literal|0
argument|)) == Nullch) 	    Perl_croak(aTHX_
literal|"No Perl script found in input\n"
argument|); 	if (*s ==
literal|'#'
argument|&& s[
literal|1
argument|] ==
literal|'!'
argument|&& (s = instr(s,
literal|"perl"
argument|))) { 	    PerlIO_ungetc(PL_rsfp,
literal|'\n'
argument|);
comment|/* to keep line count right */
argument|PL_doextract = FALSE; 	    while (*s&& !(isSPACE (*s) || *s ==
literal|'#'
argument|)) s++; 	    s2 = s; 	    while (*s ==
literal|' '
argument||| *s ==
literal|'\t'
argument|) s++; 	    if (*s++ ==
literal|'-'
argument|) { 		while (isDIGIT(s2[-
literal|1
argument|]) || strchr(
literal|"-._"
argument|, s2[-
literal|1
argument|])) s2--; 		if (strnEQ(s2-
literal|4
argument|,
literal|"perl"
argument|,
literal|4
argument|))
comment|/*SUPPRESS 530*/
argument|while ((s = moreswitches(s))) 			; 	    } 	}     } }   STATIC void S_init_ids(pTHX) {     PL_uid = PerlProc_getuid();     PL_euid = PerlProc_geteuid();     PL_gid = PerlProc_getgid();     PL_egid = PerlProc_getegid();
ifdef|#
directive|ifdef
name|VMS
argument|PL_uid |= PL_gid<<
literal|16
argument|;     PL_euid |= PL_egid<<
literal|16
argument|;
endif|#
directive|endif
argument|PL_tainting |= (PL_uid&& (PL_euid != PL_uid || PL_egid != PL_gid)); }  STATIC void S_forbid_setid(pTHX_ char *s) {     if (PL_euid != PL_uid)         Perl_croak(aTHX_
literal|"No %s allowed while running setuid"
argument|, s);     if (PL_egid != PL_gid)         Perl_croak(aTHX_
literal|"No %s allowed while running setgid"
argument|, s); }  void Perl_init_debugger(pTHX) {     dTHR;     HV *ostash = PL_curstash;      PL_curstash = PL_debstash;     PL_dbargs = GvAV(gv_AVadd((gv_fetchpv(
literal|"args"
argument|, GV_ADDMULTI, SVt_PVAV))));     AvREAL_off(PL_dbargs);     PL_DBgv = gv_fetchpv(
literal|"DB"
argument|, GV_ADDMULTI, SVt_PVGV);     PL_DBline = gv_fetchpv(
literal|"dbline"
argument|, GV_ADDMULTI, SVt_PVAV);     PL_DBsub = gv_HVadd(gv_fetchpv(
literal|"sub"
argument|, GV_ADDMULTI, SVt_PVHV));     sv_upgrade(GvSV(PL_DBsub), SVt_IV);
comment|/* IVX accessed if PERLDB_SUB_NN */
argument|PL_DBsingle = GvSV((gv_fetchpv(
literal|"single"
argument|, GV_ADDMULTI, SVt_PV)));     sv_setiv(PL_DBsingle,
literal|0
argument|);      PL_DBtrace = GvSV((gv_fetchpv(
literal|"trace"
argument|, GV_ADDMULTI, SVt_PV)));     sv_setiv(PL_DBtrace,
literal|0
argument|);      PL_DBsignal = GvSV((gv_fetchpv(
literal|"signal"
argument|, GV_ADDMULTI, SVt_PV)));     sv_setiv(PL_DBsignal,
literal|0
argument|);      PL_curstash = ostash; }
ifndef|#
directive|ifndef
name|STRESS_REALLOC
define|#
directive|define
name|REASONABLE
parameter_list|(
name|size
parameter_list|)
value|(size)
else|#
directive|else
define|#
directive|define
name|REASONABLE
parameter_list|(
name|size
parameter_list|)
value|(1)
comment|/* unreasonable */
endif|#
directive|endif
argument|void Perl_init_stacks(pTHX) {
comment|/* start with 128-item stack and 8K cxstack */
argument|PL_curstackinfo = new_stackinfo(REASONABLE(
literal|128
argument|), 				 REASONABLE(
literal|8192
argument|/sizeof(PERL_CONTEXT) -
literal|1
argument|));     PL_curstackinfo->si_type = PERLSI_MAIN;     PL_curstack = PL_curstackinfo->si_stack;     PL_mainstack = PL_curstack;
comment|/* remember in case we switch stacks */
argument|PL_stack_base = AvARRAY(PL_curstack);     PL_stack_sp = PL_stack_base;     PL_stack_max = PL_stack_base + AvMAX(PL_curstack);      New(
literal|50
argument|,PL_tmps_stack,REASONABLE(
literal|128
argument|),SV*);     PL_tmps_floor = -
literal|1
argument|;     PL_tmps_ix = -
literal|1
argument|;     PL_tmps_max = REASONABLE(
literal|128
argument|);      New(
literal|54
argument|,PL_markstack,REASONABLE(
literal|32
argument|),I32);     PL_markstack_ptr = PL_markstack;     PL_markstack_max = PL_markstack + REASONABLE(
literal|32
argument|);      SET_MARK_OFFSET;      New(
literal|54
argument|,PL_scopestack,REASONABLE(
literal|32
argument|),I32);     PL_scopestack_ix =
literal|0
argument|;     PL_scopestack_max = REASONABLE(
literal|32
argument|);      New(
literal|54
argument|,PL_savestack,REASONABLE(
literal|128
argument|),ANY);     PL_savestack_ix =
literal|0
argument|;     PL_savestack_max = REASONABLE(
literal|128
argument|);      New(
literal|54
argument|,PL_retstack,REASONABLE(
literal|16
argument|),OP*);     PL_retstack_ix =
literal|0
argument|;     PL_retstack_max = REASONABLE(
literal|16
argument|); }
undef|#
directive|undef
name|REASONABLE
argument|STATIC void S_nuke_stacks(pTHX) {     dTHR;     while (PL_curstackinfo->si_next) 	PL_curstackinfo = PL_curstackinfo->si_next;     while (PL_curstackinfo) { 	PERL_SI *p = PL_curstackinfo->si_prev;
comment|/* curstackinfo->si_stack got nuked by sv_free_arenas() */
argument|Safefree(PL_curstackinfo->si_cxstack); 	Safefree(PL_curstackinfo); 	PL_curstackinfo = p;     }     Safefree(PL_tmps_stack);     Safefree(PL_markstack);     Safefree(PL_scopestack);     Safefree(PL_savestack);     Safefree(PL_retstack); }
ifndef|#
directive|ifndef
name|PERL_OBJECT
argument|static PerlIO *tmpfp;
comment|/* moved outside init_lexer() because of UNICOS bug */
endif|#
directive|endif
argument|STATIC void S_init_lexer(pTHX) {
ifdef|#
directive|ifdef
name|PERL_OBJECT
argument|PerlIO *tmpfp;
endif|#
directive|endif
argument|tmpfp = PL_rsfp;     PL_rsfp = Nullfp;     lex_start(PL_linestr);     PL_rsfp = tmpfp;     PL_subname = newSVpvn(
literal|"main"
argument|,
literal|4
argument|); }  STATIC void S_init_predump_symbols(pTHX) {     dTHR;     GV *tmpgv;     IO *io;      sv_setpvn(get_sv(
literal|"\""
argument|, TRUE),
literal|" "
argument|,
literal|1
argument|);     PL_stdingv = gv_fetchpv(
literal|"STDIN"
argument|,TRUE, SVt_PVIO);     GvMULTI_on(PL_stdingv);     io = GvIOp(PL_stdingv);     IoIFP(io) = PerlIO_stdin();     tmpgv = gv_fetchpv(
literal|"stdin"
argument|,TRUE, SVt_PV);     GvMULTI_on(tmpgv);     GvIOp(tmpgv) = (IO*)SvREFCNT_inc(io);      tmpgv = gv_fetchpv(
literal|"STDOUT"
argument|,TRUE, SVt_PVIO);     GvMULTI_on(tmpgv);     io = GvIOp(tmpgv);     IoOFP(io) = IoIFP(io) = PerlIO_stdout();     setdefout(tmpgv);     tmpgv = gv_fetchpv(
literal|"stdout"
argument|,TRUE, SVt_PV);     GvMULTI_on(tmpgv);     GvIOp(tmpgv) = (IO*)SvREFCNT_inc(io);      PL_stderrgv = gv_fetchpv(
literal|"STDERR"
argument|,TRUE, SVt_PVIO);     GvMULTI_on(PL_stderrgv);     io = GvIOp(PL_stderrgv);     IoOFP(io) = IoIFP(io) = PerlIO_stderr();     tmpgv = gv_fetchpv(
literal|"stderr"
argument|,TRUE, SVt_PV);     GvMULTI_on(tmpgv);     GvIOp(tmpgv) = (IO*)SvREFCNT_inc(io);      PL_statname = NEWSV(
literal|66
argument|,
literal|0
argument|);
comment|/* last filename we did stat on */
argument|if (!PL_osname) 	PL_osname = savepv(OSNAME); }  STATIC void S_init_postdump_symbols(pTHX_ register int argc, register char **argv, register char **env) {     dTHR;     char *s;     SV *sv;     GV* tmpgv;      argc--,argv++;
comment|/* skip name of script */
argument|if (PL_doswitches) { 	for (; argc>
literal|0
argument|&& **argv ==
literal|'-'
argument|; argc--,argv++) { 	    if (!argv[
literal|0
argument|][
literal|1
argument|]) 		break; 	    if (argv[
literal|0
argument|][
literal|1
argument|] ==
literal|'-'
argument|&& !argv[
literal|0
argument|][
literal|2
argument|]) { 		argc--,argv++; 		break; 	    } 	    if ((s = strchr(argv[
literal|0
argument|],
literal|'='
argument|))) { 		*s++ =
literal|'\0'
argument|; 		sv_setpv(GvSV(gv_fetchpv(argv[
literal|0
argument|]+
literal|1
argument|,TRUE, SVt_PV)),s); 	    } 	    else 		sv_setiv(GvSV(gv_fetchpv(argv[
literal|0
argument|]+
literal|1
argument|,TRUE, SVt_PV)),
literal|1
argument|); 	}     }     PL_toptarget = NEWSV(
literal|0
argument|,
literal|0
argument|);     sv_upgrade(PL_toptarget, SVt_PVFM);     sv_setpvn(PL_toptarget,
literal|""
argument|,
literal|0
argument|);     PL_bodytarget = NEWSV(
literal|0
argument|,
literal|0
argument|);     sv_upgrade(PL_bodytarget, SVt_PVFM);     sv_setpvn(PL_bodytarget,
literal|""
argument|,
literal|0
argument|);     PL_formtarget = PL_bodytarget;      TAINT;     if ((tmpgv = gv_fetchpv(
literal|"0"
argument|,TRUE, SVt_PV))) { 	sv_setpv(GvSV(tmpgv),PL_origfilename); 	magicname(
literal|"0"
argument|,
literal|"0"
argument|,
literal|1
argument|);     }     if ((tmpgv = gv_fetchpv(
literal|"\030"
argument|,TRUE, SVt_PV)))
ifdef|#
directive|ifdef
name|OS2
argument|sv_setpv(GvSV(tmpgv), os2_execname());
else|#
directive|else
argument|sv_setpv(GvSV(tmpgv),PL_origargv[
literal|0
argument|]);
endif|#
directive|endif
argument|if ((PL_argvgv = gv_fetchpv(
literal|"ARGV"
argument|,TRUE, SVt_PVAV))) { 	GvMULTI_on(PL_argvgv); 	(void)gv_AVadd(PL_argvgv); 	av_clear(GvAVn(PL_argvgv)); 	for (; argc>
literal|0
argument|; argc--,argv++) { 	    SV *sv = newSVpv(argv[
literal|0
argument|],
literal|0
argument|); 	    av_push(GvAVn(PL_argvgv),sv); 	    if (PL_widesyscalls) 		sv_utf8_upgrade(sv); 	}     }     if ((PL_envgv = gv_fetchpv(
literal|"ENV"
argument|,TRUE, SVt_PVHV))) { 	HV *hv; 	GvMULTI_on(PL_envgv); 	hv = GvHVn(PL_envgv); 	hv_magic(hv, PL_envgv,
literal|'E'
argument|);
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|EPOC
argument_list|)
comment|/* VMS doesn't have environ array */
comment|/* Note that if the supplied env parameter is actually a copy 	   of the global environ then it may now point to free'd memory 	   if the environment has been modified since. To avoid this 	   problem we treat env==NULL as meaning 'use the default' 	*/
argument|if (!env) 	    env = environ; 	if (env != environ) 	    environ[
literal|0
argument|] = Nullch; 	for (; *env; env++) { 	    if (!(s = strchr(*env,
literal|'='
argument|))) 		continue; 	    *s++ =
literal|'\0'
argument|;
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
argument|(void)strupr(*env);
endif|#
directive|endif
argument|sv = newSVpv(s--,
literal|0
argument|); 	    (void)hv_store(hv, *env, s - *env, sv,
literal|0
argument|); 	    *s =
literal|'='
argument|;
if|#
directive|if
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_WIN32_RTL_ENV
argument_list|)
comment|/* Sins of the RTL. See note in my_setenv(). */
argument|(void)PerlEnv_putenv(savepv(*env));
endif|#
directive|endif
argument|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DYNAMIC_ENV_FETCH
argument|HvNAME(hv) = savepv(ENV_HV_NAME);
endif|#
directive|endif
argument|}     TAINT_NOT;     if ((tmpgv = gv_fetchpv(
literal|"$"
argument|,TRUE, SVt_PV))) 	sv_setiv(GvSV(tmpgv), (IV)PerlProc_getpid()); }  STATIC void S_init_perllib(pTHX) {     char *s;     if (!PL_tainting) {
ifndef|#
directive|ifndef
name|VMS
argument|s = PerlEnv_getenv(
literal|"PERL5LIB"
argument|); 	if (s) 	    incpush(s, TRUE, TRUE); 	else 	    incpush(PerlEnv_getenv(
literal|"PERLLIB"
argument|), FALSE, FALSE);
else|#
directive|else
comment|/* VMS */
comment|/* Treat PERL5?LIB as a possible search list logical name -- the 	 * "natural" VMS idiom for a Unix path string.  We allow each 	 * element to be a set of |-separated directories for compatibility. 	 */
argument|char buf[
literal|256
argument|]; 	int idx =
literal|0
argument|; 	if (my_trnlnm(
literal|"PERL5LIB"
argument|,buf,
literal|0
argument|)) 	    do { incpush(buf,TRUE,TRUE); } while (my_trnlnm(
literal|"PERL5LIB"
argument|,buf,++idx)); 	else 	    while (my_trnlnm(
literal|"PERLLIB"
argument|,buf,idx++)) incpush(buf,FALSE,FALSE);
endif|#
directive|endif
comment|/* VMS */
argument|}
comment|/* Use the ~-expanded versions of APPLLIB (undocumented),     ARCHLIB PRIVLIB SITEARCH SITELIB VENDORARCH and VENDORLIB */
ifdef|#
directive|ifdef
name|APPLLIB_EXP
argument|incpush(APPLLIB_EXP, TRUE, TRUE);
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHLIB_EXP
argument|incpush(ARCHLIB_EXP, FALSE, FALSE);
endif|#
directive|endif
ifndef|#
directive|ifndef
name|PRIVLIB_EXP
define|#
directive|define
name|PRIVLIB_EXP
value|"/usr/local/lib/perl5:/usr/local/lib/perl"
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
argument|incpush(PRIVLIB_EXP, TRUE, FALSE);
else|#
directive|else
argument|incpush(PRIVLIB_EXP, FALSE, FALSE);
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SITEARCH_EXP
comment|/* sitearch is always relative to sitelib on Windows for      * DLL-based path intuition to work correctly */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
argument|incpush(SITEARCH_EXP, FALSE, FALSE);
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SITELIB_EXP
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
argument|incpush(SITELIB_EXP, TRUE, FALSE);
comment|/* this picks up sitearch as well */
else|#
directive|else
argument|incpush(SITELIB_EXP, FALSE, FALSE);
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SITELIB_STEM
comment|/* Search for version-specific dirs below here */
argument|incpush(SITELIB_STEM, FALSE, TRUE);
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PERL_VENDORARCH_EXP
comment|/* vendorarch is always relative to vendorlib on Windows for      * DLL-based path intuition to work correctly */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
argument|incpush(PERL_VENDORARCH_EXP, FALSE, FALSE);
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PERL_VENDORLIB_EXP
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
argument|incpush(PERL_VENDORLIB_EXP, TRUE, FALSE);
comment|/* this picks up vendorarch as well */
else|#
directive|else
argument|incpush(PERL_VENDORLIB_EXP, FALSE, FALSE);
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PERL_VENDORLIB_STEM
comment|/* Search for version-specific dirs below here */
argument|incpush(PERL_VENDORLIB_STEM, FALSE, TRUE);
endif|#
directive|endif
argument|if (!PL_tainting) 	incpush(
literal|"."
argument|, FALSE, FALSE); }
if|#
directive|if
name|defined
argument_list|(
name|DOSISH
argument_list|)
define|#
directive|define
name|PERLLIB_SEP
value|';'
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
define|#
directive|define
name|PERLLIB_SEP
value|'|'
else|#
directive|else
define|#
directive|define
name|PERLLIB_SEP
value|':'
endif|#
directive|endif
endif|#
directive|endif
ifndef|#
directive|ifndef
name|PERLLIB_MANGLE
define|#
directive|define
name|PERLLIB_MANGLE
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
value|(s)
endif|#
directive|endif
argument|STATIC void S_incpush(pTHX_ char *p, int addsubdirs, int addoldvers) {     SV *subdir = Nullsv;      if (!p || !*p) 	return;      if (addsubdirs || addoldvers) { 	subdir = sv_newmortal();     }
comment|/* Break at all separators */
argument|while (p&& *p) { 	SV *libdir = NEWSV(
literal|55
argument|,
literal|0
argument|); 	char *s;
comment|/* skip any consecutive separators */
argument|while ( *p == PERLLIB_SEP ) {
comment|/* Uncomment the next line for PATH semantics */
comment|/* av_push(GvAVn(PL_incgv), newSVpvn(".", 1)); */
argument|p++; 	}  	if ( (s = strchr(p, PERLLIB_SEP)) != Nullch ) { 	    sv_setpvn(libdir, PERLLIB_MANGLE(p, (STRLEN)(s - p)), 		      (STRLEN)(s - p)); 	    p = s +
literal|1
argument|; 	} 	else { 	    sv_setpv(libdir, PERLLIB_MANGLE(p,
literal|0
argument|)); 	    p = Nullch;
comment|/* break out */
argument|}
comment|/* 	 * BEFORE pushing libdir onto @INC we may first push version- and 	 * archname-specific sub-directories. 	 */
argument|if (addsubdirs || addoldvers) {
ifdef|#
directive|ifdef
name|PERL_INC_VERSION_LIST
comment|/* Configure terminates PERL_INC_VERSION_LIST with a NULL */
argument|const char *incverlist[] = { PERL_INC_VERSION_LIST }; 	    const char **incver;
endif|#
directive|endif
argument|struct stat tmpstatbuf;
ifdef|#
directive|ifdef
name|VMS
argument|char *unix; 	    STRLEN len;  	    if ((unix = tounixspec_ts(SvPV(libdir,len),Nullch)) != Nullch) { 		len = strlen(unix); 		while (unix[len-
literal|1
argument|] ==
literal|'/'
argument|) len--;
comment|/* Cosmetic */
argument|sv_usepvn(libdir,unix,len); 	    } 	    else 		PerlIO_printf(Perl_error_log,
literal|"Failed to unixify @INC element \"%s\"\n"
argument|, 			      SvPV(libdir,len));
endif|#
directive|endif
argument|if (addsubdirs) {
comment|/* .../version/archname if -d .../version/archname */
argument|Perl_sv_setpvf(aTHX_ subdir,
literal|"%"
argument|SVf
literal|"/"
argument|PERL_FS_VER_FMT
literal|"/%s"
argument|,  				libdir, 			       (int)PERL_REVISION, (int)PERL_VERSION, 			       (int)PERL_SUBVERSION, ARCHNAME); 		if (PerlLIO_stat(SvPVX(subdir),&tmpstatbuf)>=
literal|0
argument|&& 		      S_ISDIR(tmpstatbuf.st_mode)) 		    av_push(GvAVn(PL_incgv), newSVsv(subdir));
comment|/* .../version if -d .../version */
argument|Perl_sv_setpvf(aTHX_ subdir,
literal|"%"
argument|SVf
literal|"/"
argument|PERL_FS_VER_FMT, libdir, 			       (int)PERL_REVISION, (int)PERL_VERSION, 			       (int)PERL_SUBVERSION); 		if (PerlLIO_stat(SvPVX(subdir),&tmpstatbuf)>=
literal|0
argument|&& 		      S_ISDIR(tmpstatbuf.st_mode)) 		    av_push(GvAVn(PL_incgv), newSVsv(subdir));
comment|/* .../archname if -d .../archname */
argument|Perl_sv_setpvf(aTHX_ subdir,
literal|"%"
argument|SVf
literal|"/%s"
argument|, libdir, ARCHNAME); 		if (PerlLIO_stat(SvPVX(subdir),&tmpstatbuf)>=
literal|0
argument|&& 		      S_ISDIR(tmpstatbuf.st_mode)) 		    av_push(GvAVn(PL_incgv), newSVsv(subdir)); 	    }
ifdef|#
directive|ifdef
name|PERL_INC_VERSION_LIST
argument|if (addoldvers) { 		for (incver = incverlist; *incver; incver++) {
comment|/* .../xxx if -d .../xxx */
argument|Perl_sv_setpvf(aTHX_ subdir,
literal|"%"
argument|SVf
literal|"/%s"
argument|, libdir, *incver); 		    if (PerlLIO_stat(SvPVX(subdir),&tmpstatbuf)>=
literal|0
argument|&& 			  S_ISDIR(tmpstatbuf.st_mode)) 			av_push(GvAVn(PL_incgv), newSVsv(subdir)); 		} 	    }
endif|#
directive|endif
argument|}
comment|/* finally push this lib directory on the end of @INC */
argument|av_push(GvAVn(PL_incgv), libdir);     } }
ifdef|#
directive|ifdef
name|USE_THREADS
argument|STATIC struct perl_thread * S_init_main_thread(pTHX) {
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PERL_IMPLICIT_CONTEXT
argument_list|)
argument|struct perl_thread *thr;
endif|#
directive|endif
argument|XPV *xpv;      Newz(
literal|53
argument|, thr,
literal|1
argument|, struct perl_thread);     PL_curcop =&PL_compiling;     thr->interp = PERL_GET_INTERP;     thr->cvcache = newHV();     thr->threadsv = newAV();
comment|/* thr->threadsvp is set when find_threadsv is called */
argument|thr->specific = newAV();     thr->flags = THRf_R_JOINABLE;     MUTEX_INIT(&thr->mutex);
comment|/* Handcraft thrsv similarly to mess_sv */
argument|New(
literal|53
argument|, PL_thrsv,
literal|1
argument|, SV);     Newz(
literal|53
argument|, xpv,
literal|1
argument|, XPV);     SvFLAGS(PL_thrsv) = SVt_PV;     SvANY(PL_thrsv) = (void*)xpv;     SvREFCNT(PL_thrsv) =
literal|1
argument|<<
literal|30
argument|;
comment|/* practically infinite */
argument|SvPVX(PL_thrsv) = (char*)thr;     SvCUR_set(PL_thrsv, sizeof(thr));     SvLEN_set(PL_thrsv, sizeof(thr));     *SvEND(PL_thrsv) =
literal|'\0'
argument|;
comment|/* in the trailing_nul field */
argument|thr->oursv = PL_thrsv;     PL_chopset =
literal|" \n-"
argument|;     PL_dumpindent =
literal|4
argument|;      MUTEX_LOCK(&PL_threads_mutex);     PL_nthreads++;     thr->tid =
literal|0
argument|;     thr->next = thr;     thr->prev = thr;     MUTEX_UNLOCK(&PL_threads_mutex);
ifdef|#
directive|ifdef
name|HAVE_THREAD_INTERN
argument|Perl_init_thread_intern(thr);
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SET_THREAD_SELF
argument|SET_THREAD_SELF(thr);
else|#
directive|else
argument|thr->self = pthread_self();
endif|#
directive|endif
comment|/* SET_THREAD_SELF */
argument|PERL_SET_THX(thr);
comment|/*      * These must come after the SET_THR because sv_setpvn does      * SvTAINT and the taint fields require dTHR.      */
argument|PL_toptarget = NEWSV(
literal|0
argument|,
literal|0
argument|);     sv_upgrade(PL_toptarget, SVt_PVFM);     sv_setpvn(PL_toptarget,
literal|""
argument|,
literal|0
argument|);     PL_bodytarget = NEWSV(
literal|0
argument|,
literal|0
argument|);     sv_upgrade(PL_bodytarget, SVt_PVFM);     sv_setpvn(PL_bodytarget,
literal|""
argument|,
literal|0
argument|);     PL_formtarget = PL_bodytarget;     thr->errsv = newSVpvn(
literal|""
argument|,
literal|0
argument|);     (void) find_threadsv(
literal|"@"
argument|);
comment|/* Ensure $@ is initialised early */
argument|PL_maxscream = -
literal|1
argument|;     PL_regcompp = MEMBER_TO_FPTR(Perl_pregcomp);     PL_regexecp = MEMBER_TO_FPTR(Perl_regexec_flags);     PL_regint_start = MEMBER_TO_FPTR(Perl_re_intuit_start);     PL_regint_string = MEMBER_TO_FPTR(Perl_re_intuit_string);     PL_regfree = MEMBER_TO_FPTR(Perl_pregfree);     PL_regindent =
literal|0
argument|;     PL_reginterp_cnt =
literal|0
argument|;      return thr; }
endif|#
directive|endif
comment|/* USE_THREADS */
argument|void Perl_call_list(pTHX_ I32 oldscope, AV *paramList) {     dTHR;     SV *atsv;     line_t oldline = CopLINE(PL_curcop);     CV *cv;     STRLEN len;     int ret;     dJMPENV;      while (AvFILL(paramList)>=
literal|0
argument|) { 	cv = (CV*)av_shift(paramList); 	SAVEFREESV(cv);
ifdef|#
directive|ifdef
name|PERL_FLEXIBLE_EXCEPTIONS
argument|CALLPROTECT(aTHX_ pcur_env,&ret, MEMBER_TO_FPTR(S_vcall_list_body), cv);
else|#
directive|else
argument|JMPENV_PUSH(ret);
endif|#
directive|endif
argument|switch (ret) { 	case
literal|0
argument|:
ifndef|#
directive|ifndef
name|PERL_FLEXIBLE_EXCEPTIONS
argument|call_list_body(cv);
endif|#
directive|endif
argument|atsv = ERRSV; 	    (void)SvPV(atsv, len); 	    if (len) { 		STRLEN n_a; 		PL_curcop =&PL_compiling; 		CopLINE_set(PL_curcop, oldline); 		if (paramList == PL_beginav) 		    sv_catpv(atsv,
literal|"BEGIN failed--compilation aborted"
argument|); 		else 		    Perl_sv_catpvf(aTHX_ atsv,
literal|"%s failed--call queue aborted"
argument|, 				   paramList == PL_checkav ?
literal|"CHECK"
argument|: paramList == PL_initav ?
literal|"INIT"
argument|:
literal|"END"
argument|); 		while (PL_scopestack_ix> oldscope) 		    LEAVE; 		JMPENV_POP; 		Perl_croak(aTHX_
literal|"%s"
argument|, SvPVx(atsv, n_a)); 	    } 	    break; 	case
literal|1
argument|: 	    STATUS_ALL_FAILURE;
comment|/* FALL THROUGH */
argument|case
literal|2
argument|:
comment|/* my_exit() was called */
argument|while (PL_scopestack_ix> oldscope) 		LEAVE; 	    FREETMPS; 	    PL_curstash = PL_defstash; 	    PL_curcop =&PL_compiling; 	    CopLINE_set(PL_curcop, oldline); 	    JMPENV_POP; 	    if (PL_statusvalue&& !(PL_exit_flags& PERL_EXIT_EXPECTED)) { 		if (paramList == PL_beginav) 		    Perl_croak(aTHX_
literal|"BEGIN failed--compilation aborted"
argument|); 		else 		    Perl_croak(aTHX_
literal|"%s failed--call queue aborted"
argument|, 			       paramList == PL_checkav ?
literal|"CHECK"
argument|: paramList == PL_initav ?
literal|"INIT"
argument|:
literal|"END"
argument|); 	    } 	    my_exit_jump();
comment|/* NOTREACHED */
argument|case
literal|3
argument|: 	    if (PL_restartop) { 		PL_curcop =&PL_compiling; 		CopLINE_set(PL_curcop, oldline); 		JMPENV_JUMP(
literal|3
argument|); 	    } 	    PerlIO_printf(Perl_error_log,
literal|"panic: restartop\n"
argument|); 	    FREETMPS; 	    break; 	} 	JMPENV_POP;     } }
ifdef|#
directive|ifdef
name|PERL_FLEXIBLE_EXCEPTIONS
argument|STATIC void * S_vcall_list_body(pTHX_ va_list args) {     CV *cv = va_arg(args, CV*);     return call_list_body(cv); }
endif|#
directive|endif
argument|STATIC void * S_call_list_body(pTHX_ CV *cv) {     PUSHMARK(PL_stack_sp);     call_sv((SV*)cv, G_EVAL|G_DISCARD);     return NULL; }  void Perl_my_exit(pTHX_ U32 status) {     dTHR;      DEBUG_S(PerlIO_printf(Perl_debug_log,
literal|"my_exit: thread %p, status %lu\n"
argument|, 			  thr, (unsigned long) status));     switch (status) {     case
literal|0
argument|: 	STATUS_ALL_SUCCESS; 	break;     case
literal|1
argument|: 	STATUS_ALL_FAILURE; 	break;     default: 	STATUS_NATIVE_SET(status); 	break;     }     my_exit_jump(); }  void Perl_my_failure_exit(pTHX) {
ifdef|#
directive|ifdef
name|VMS
argument|if (vaxc$errno&
literal|1
argument|) { 	if (STATUS_NATIVE&
literal|1
argument|)
comment|/* fortuitiously includes "-1" */
argument|STATUS_NATIVE_SET(
literal|44
argument|);     }     else { 	if (!vaxc$errno&& errno)
comment|/* unlikely */
argument|STATUS_NATIVE_SET(
literal|44
argument|); 	else 	    STATUS_NATIVE_SET(vaxc$errno);     }
else|#
directive|else
argument|int exitstatus;     if (errno&
literal|255
argument|) 	STATUS_POSIX_SET(errno);     else { 	exitstatus = STATUS_POSIX>>
literal|8
argument|;  	if (exitstatus&
literal|255
argument|) 	    STATUS_POSIX_SET(exitstatus); 	else 	    STATUS_POSIX_SET(
literal|255
argument|);     }
endif|#
directive|endif
argument|my_exit_jump(); }  STATIC void S_my_exit_jump(pTHX) {     dTHR;     register PERL_CONTEXT *cx;     I32 gimme;     SV **newsp;      if (PL_e_script) { 	SvREFCNT_dec(PL_e_script); 	PL_e_script = Nullsv;     }      POPSTACK_TO(PL_mainstack);     if (cxstack_ix>=
literal|0
argument|) { 	if (cxstack_ix>
literal|0
argument|) 	    dounwind(
literal|0
argument|); 	POPBLOCK(cx,PL_curpm); 	LEAVE;     }      JMPENV_JUMP(
literal|2
argument|); }
ifdef|#
directive|ifdef
name|PERL_OBJECT
include|#
directive|include
file|"XSUB.h"
endif|#
directive|endif
argument|static I32 read_e_script(pTHXo_ int idx, SV *buf_sv, int maxlen) {     char *p, *nl;     p  = SvPVX(PL_e_script);     nl = strchr(p,
literal|'\n'
argument|);     nl = (nl) ? nl+
literal|1
argument|: SvEND(PL_e_script);     if (nl-p ==
literal|0
argument|) { 	filter_del(read_e_script); 	return
literal|0
argument|;     }     sv_catpvn(buf_sv, p, nl-p);     sv_chop(PL_e_script, nl);     return
literal|1
argument|; }
end_function

end_unit

