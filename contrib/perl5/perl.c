begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    perl.c  *  *    Copyright (c) 1987-2001 Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * "A ship then new they built for him/of mithril and of elven glass" --Bilbo  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_define
define|#
directive|define
name|PERL_IN_PERL_C
end_define

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_include
include|#
directive|include
file|"patchlevel.h"
end_include

begin_comment
comment|/* for local_patches */
end_comment

begin_comment
comment|/* XXX If this causes problems, set i_unistd=undef in the hint file.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|I_UNISTD
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|STANDARD_C
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAS_GETENV_PROTOTYPE
argument_list|)
end_if

begin_function_decl
name|char
modifier|*
name|getenv
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Usually in<stdlib.h> */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|I32
name|read_e_script
parameter_list|(
name|pTHXo_
name|int
name|idx
parameter_list|,
name|SV
modifier|*
name|buf_sv
parameter_list|,
name|int
name|maxlen
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|IAMSUID
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|DOSUID
end_ifndef

begin_define
define|#
directive|define
name|DOSUID
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SETUID_SCRIPTS_ARE_SECURE_NOW
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|DOSUID
end_ifdef

begin_undef
undef|#
directive|undef
name|DOSUID
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_OBJECT
end_ifdef

begin_define
define|#
directive|define
name|perl_construct
value|Perl_construct
end_define

begin_define
define|#
directive|define
name|perl_parse
value|Perl_parse
end_define

begin_define
define|#
directive|define
name|perl_run
value|Perl_run
end_define

begin_define
define|#
directive|define
name|perl_destruct
value|Perl_destruct
end_define

begin_define
define|#
directive|define
name|perl_free
value|Perl_free
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_THREADS
argument_list|)
end_if

begin_define
define|#
directive|define
name|INIT_TLS_AND_INTERP
define|\
value|STMT_START {				\ 	if (!PL_curinterp) {			\ 	    PERL_SET_INTERP(my_perl);		\ 	    INIT_THREADS;			\ 	    ALLOC_THREAD_KEY;			\ 	}					\     } STMT_END
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_ITHREADS
argument_list|)
end_if

begin_define
define|#
directive|define
name|INIT_TLS_AND_INTERP
define|\
value|STMT_START {				\ 	if (!PL_curinterp) {			\ 	    PERL_SET_INTERP(my_perl);		\ 	    INIT_THREADS;			\ 	    ALLOC_THREAD_KEY;			\ 	    PERL_SET_THX(my_perl);		\ 	    OP_REFCNT_INIT;			\ 	}					\ 	else {					\ 	    PERL_SET_THX(my_perl);		\ 	}					\     } STMT_END
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INIT_TLS_AND_INTERP
define|\
value|STMT_START {				\ 	if (!PL_curinterp) {			\ 	    PERL_SET_INTERP(my_perl);		\ 	}					\ 	PERL_SET_THX(my_perl);			\     } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_IMPLICIT_SYS
end_ifdef

begin_function
name|PerlInterpreter
modifier|*
name|perl_alloc_using
parameter_list|(
name|struct
name|IPerlMem
modifier|*
name|ipM
parameter_list|,
name|struct
name|IPerlMem
modifier|*
name|ipMS
parameter_list|,
name|struct
name|IPerlMem
modifier|*
name|ipMP
parameter_list|,
name|struct
name|IPerlEnv
modifier|*
name|ipE
parameter_list|,
name|struct
name|IPerlStdIO
modifier|*
name|ipStd
parameter_list|,
name|struct
name|IPerlLIO
modifier|*
name|ipLIO
parameter_list|,
name|struct
name|IPerlDir
modifier|*
name|ipD
parameter_list|,
name|struct
name|IPerlSock
modifier|*
name|ipS
parameter_list|,
name|struct
name|IPerlProc
modifier|*
name|ipP
parameter_list|)
block|{
name|PerlInterpreter
modifier|*
name|my_perl
decl_stmt|;
ifdef|#
directive|ifdef
name|PERL_OBJECT
name|my_perl
operator|=
operator|(
name|PerlInterpreter
operator|*
operator|)
name|new
argument_list|(
argument|ipM
argument_list|)
name|CPerlObj
argument_list|(
name|ipM
argument_list|,
name|ipMS
argument_list|,
name|ipMP
argument_list|,
name|ipE
argument_list|,
name|ipStd
argument_list|,
name|ipLIO
argument_list|,
name|ipD
argument_list|,
name|ipS
argument_list|,
name|ipP
argument_list|)
expr_stmt|;
name|INIT_TLS_AND_INTERP
expr_stmt|;
else|#
directive|else
comment|/* New() needs interpreter, so call malloc() instead */
name|my_perl
operator|=
operator|(
name|PerlInterpreter
operator|*
operator|)
call|(
modifier|*
name|ipM
operator|->
name|pMalloc
call|)
argument_list|(
name|ipM
argument_list|,
sizeof|sizeof
argument_list|(
name|PerlInterpreter
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_TLS_AND_INTERP
expr_stmt|;
name|Zero
argument_list|(
name|my_perl
argument_list|,
literal|1
argument_list|,
name|PerlInterpreter
argument_list|)
expr_stmt|;
name|PL_Mem
operator|=
name|ipM
expr_stmt|;
name|PL_MemShared
operator|=
name|ipMS
expr_stmt|;
name|PL_MemParse
operator|=
name|ipMP
expr_stmt|;
name|PL_Env
operator|=
name|ipE
expr_stmt|;
name|PL_StdIO
operator|=
name|ipStd
expr_stmt|;
name|PL_LIO
operator|=
name|ipLIO
expr_stmt|;
name|PL_Dir
operator|=
name|ipD
expr_stmt|;
name|PL_Sock
operator|=
name|ipS
expr_stmt|;
name|PL_Proc
operator|=
name|ipP
expr_stmt|;
endif|#
directive|endif
return|return
name|my_perl
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* =for apidoc perl_alloc  Allocates a new Perl interpreter.  See L<perlembed>.  =cut */
end_comment

begin_function
name|PerlInterpreter
modifier|*
name|perl_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|PerlInterpreter
modifier|*
name|my_perl
decl_stmt|;
comment|/* New() needs interpreter, so call malloc() instead */
name|my_perl
operator|=
operator|(
name|PerlInterpreter
operator|*
operator|)
name|PerlMem_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|PerlInterpreter
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_TLS_AND_INTERP
expr_stmt|;
name|Zero
argument_list|(
name|my_perl
argument_list|,
literal|1
argument_list|,
name|PerlInterpreter
argument_list|)
expr_stmt|;
return|return
name|my_perl
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PERL_IMPLICIT_SYS */
end_comment

begin_comment
comment|/* =for apidoc perl_construct  Initializes a new Perl interpreter.  See L<perlembed>.  =cut */
end_comment

begin_function
name|void
name|perl_construct
parameter_list|(
name|pTHXx
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_THREADS
name|int
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|FAKE_THREADS
name|struct
name|perl_thread
modifier|*
name|thr
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* FAKE_THREADS */
endif|#
directive|endif
comment|/* USE_THREADS */
ifdef|#
directive|ifdef
name|MULTIPLICITY
name|init_interp
argument_list|()
expr_stmt|;
name|PL_perl_destruct_level
operator|=
literal|1
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|PL_perl_destruct_level
operator|>
literal|0
condition|)
name|init_interp
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Init the real globals (and main thread)? */
if|if
condition|(
operator|!
name|PL_linestr
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_THREADS
name|MUTEX_INIT
argument_list|(
operator|&
name|PL_sv_mutex
argument_list|)
expr_stmt|;
comment|/* 	 * Safe to use basic SV functions from now on (though 	 * not things like mortals or tainting yet). 	 */
name|MUTEX_INIT
argument_list|(
operator|&
name|PL_eval_mutex
argument_list|)
expr_stmt|;
name|COND_INIT
argument_list|(
operator|&
name|PL_eval_cond
argument_list|)
expr_stmt|;
name|MUTEX_INIT
argument_list|(
operator|&
name|PL_threads_mutex
argument_list|)
expr_stmt|;
name|COND_INIT
argument_list|(
operator|&
name|PL_nthreads_cond
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EMULATE_ATOMIC_REFCOUNTS
name|MUTEX_INIT
argument_list|(
operator|&
name|PL_svref_mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EMULATE_ATOMIC_REFCOUNTS */
name|MUTEX_INIT
argument_list|(
operator|&
name|PL_cred_mutex
argument_list|)
expr_stmt|;
name|MUTEX_INIT
argument_list|(
operator|&
name|PL_sv_lock_mutex
argument_list|)
expr_stmt|;
name|MUTEX_INIT
argument_list|(
operator|&
name|PL_fdpid_mutex
argument_list|)
expr_stmt|;
name|thr
operator|=
name|init_main_thread
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
ifdef|#
directive|ifdef
name|PERL_FLEXIBLE_EXCEPTIONS
name|PL_protect
operator|=
name|MEMBER_TO_FPTR
argument_list|(
name|Perl_default_protect
argument_list|)
expr_stmt|;
comment|/* for exceptions */
endif|#
directive|endif
name|PL_curcop
operator|=
operator|&
name|PL_compiling
expr_stmt|;
comment|/* needed by ckWARN, right away */
name|PL_linestr
operator|=
name|NEWSV
argument_list|(
literal|65
argument_list|,
literal|79
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
name|PL_linestr
argument_list|,
name|SVt_PVIV
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvREADONLY
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
condition|)
block|{
comment|/* set read-only and try to insure than we wont see REFCNT==0 	       very often */
name|SvREADONLY_on
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
name|SvREFCNT
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
operator|=
operator|(
operator|~
operator|(
name|U32
operator|)
literal|0
operator|)
operator|/
literal|2
expr_stmt|;
name|sv_setpv
argument_list|(
operator|&
name|PL_sv_no
argument_list|,
name|PL_No
argument_list|)
expr_stmt|;
name|SvNV
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
expr_stmt|;
name|SvREADONLY_on
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
expr_stmt|;
name|SvREFCNT
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
operator|=
operator|(
operator|~
operator|(
name|U32
operator|)
literal|0
operator|)
operator|/
literal|2
expr_stmt|;
name|sv_setpv
argument_list|(
operator|&
name|PL_sv_yes
argument_list|,
name|PL_Yes
argument_list|)
expr_stmt|;
name|SvNV
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
expr_stmt|;
name|SvREADONLY_on
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
expr_stmt|;
name|SvREFCNT
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
operator|=
operator|(
operator|~
operator|(
name|U32
operator|)
literal|0
operator|)
operator|/
literal|2
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PERL_OBJECT
comment|/* TODO: */
comment|/* PL_sighandlerp = sighandler; */
else|#
directive|else
name|PL_sighandlerp
operator|=
name|Perl_sighandler
expr_stmt|;
endif|#
directive|endif
name|PL_pidstatus
operator|=
name|newHV
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|MSDOS
comment|/* 	 * There is no way we can refer to them from Perl so close them to save 	 * space.  The other alternative would be to provide STDAUX and STDPRN 	 * filehandles. 	 */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|stdaux
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|stdprn
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|PL_nrs
operator|=
name|newSVpvn
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PL_rs
operator|=
name|SvREFCNT_inc
argument_list|(
name|PL_nrs
argument_list|)
expr_stmt|;
name|init_stacks
argument_list|()
expr_stmt|;
name|init_ids
argument_list|()
expr_stmt|;
name|PL_lex_state
operator|=
name|LEX_NOTPARSING
expr_stmt|;
name|JMPENV_BOOTSTRAP
expr_stmt|;
name|STATUS_ALL_SUCCESS
expr_stmt|;
name|init_i18nl10n
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|SET_NUMERIC_STANDARD
argument_list|()
expr_stmt|;
block|{
name|U8
modifier|*
name|s
decl_stmt|;
name|PL_patchlevel
operator|=
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|PL_patchlevel
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
if|if
condition|(
name|PERL_REVISION
operator|>
literal|127
operator|||
name|PERL_VERSION
operator|>
literal|127
operator|||
name|PERL_SUBVERSION
operator|>
literal|127
condition|)
name|SvGROW
argument_list|(
name|PL_patchlevel
argument_list|,
name|UTF8_MAXLEN
operator|*
literal|3
operator|+
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|U8
operator|*
operator|)
name|SvPVX
argument_list|(
name|PL_patchlevel
argument_list|)
expr_stmt|;
name|s
operator|=
name|uv_to_utf8
argument_list|(
name|s
argument_list|,
operator|(
name|UV
operator|)
name|PERL_REVISION
argument_list|)
expr_stmt|;
name|s
operator|=
name|uv_to_utf8
argument_list|(
name|s
argument_list|,
operator|(
name|UV
operator|)
name|PERL_VERSION
argument_list|)
expr_stmt|;
name|s
operator|=
name|uv_to_utf8
argument_list|(
name|s
argument_list|,
operator|(
name|UV
operator|)
name|PERL_SUBVERSION
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR_set
argument_list|(
name|PL_patchlevel
argument_list|,
name|s
operator|-
operator|(
name|U8
operator|*
operator|)
name|SvPVX
argument_list|(
name|PL_patchlevel
argument_list|)
argument_list|)
expr_stmt|;
name|SvPOK_on
argument_list|(
name|PL_patchlevel
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|PL_patchlevel
argument_list|)
operator|=
operator|(
name|NV
operator|)
name|PERL_REVISION
operator|+
operator|(
operator|(
name|NV
operator|)
name|PERL_VERSION
operator|/
operator|(
name|NV
operator|)
literal|1000
operator|)
if|#
directive|if
name|defined
argument_list|(
name|PERL_SUBVERSION
argument_list|)
operator|&&
name|PERL_SUBVERSION
operator|>
literal|0
operator|+
operator|(
operator|(
name|NV
operator|)
name|PERL_SUBVERSION
operator|/
operator|(
name|NV
operator|)
literal|1000000
operator|)
endif|#
directive|endif
expr_stmt|;
name|SvNOK_on
argument_list|(
name|PL_patchlevel
argument_list|)
expr_stmt|;
comment|/* dual valued */
name|SvUTF8_on
argument_list|(
name|PL_patchlevel
argument_list|)
expr_stmt|;
name|SvREADONLY_on
argument_list|(
name|PL_patchlevel
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|LOCAL_PATCH_COUNT
argument_list|)
name|PL_localpatches
operator|=
name|local_patches
expr_stmt|;
comment|/* For possible -v */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_INTERP_INTERN
name|sys_intern_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|PerlIO_init
argument_list|()
expr_stmt|;
comment|/* Hook to IO system */
name|PL_fdpid
operator|=
name|newAV
argument_list|()
expr_stmt|;
comment|/* for remembering popen pids by fd */
name|PL_modglobal
operator|=
name|newHV
argument_list|()
expr_stmt|;
comment|/* pointers to per-interpreter module globals */
name|PL_errors
operator|=
name|newSVpvn
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENTER
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc perl_destruct  Shuts down a Perl interpreter.  See L<perlembed>.  =cut */
end_comment

begin_function
name|void
name|perl_destruct
parameter_list|(
name|pTHXx
parameter_list|)
block|{
name|int
name|destruct_level
decl_stmt|;
comment|/* 0=none, 1=full, 2=full with checks */
name|HV
modifier|*
name|hv
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|Thread
name|t
decl_stmt|;
name|dTHX
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
comment|/* wait for all pseudo-forked children to finish */
name|PERL_WAIT_FOR_CHILDREN
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
ifndef|#
directive|ifndef
name|FAKE_THREADS
comment|/* Pass 1 on any remaining threads: detach joinables, join zombies */
name|retry_cleanup
label|:
name|MUTEX_LOCK
argument_list|(
operator|&
name|PL_threads_mutex
argument_list|)
expr_stmt|;
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"perl_destruct: waiting for %d threads...\n"
argument_list|,
name|PL_nthreads
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|thr
operator|->
name|next
init|;
name|t
operator|!=
name|thr
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
name|MUTEX_LOCK
argument_list|(
operator|&
name|t
operator|->
name|mutex
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ThrSTATE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|AV
modifier|*
name|av
decl_stmt|;
case|case
name|THRf_ZOMBIE
case|:
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"perl_destruct: joining zombie %p\n"
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ThrSETSTATE
argument_list|(
name|t
argument_list|,
name|THRf_DEAD
argument_list|)
expr_stmt|;
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|t
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|PL_nthreads
operator|--
expr_stmt|;
comment|/* 	     * The SvREFCNT_dec below may take a long time (e.g. av 	     * may contain an object scalar whose destructor gets 	     * called) so we have to unlock threads_mutex and start 	     * all over again. 	     */
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|PL_threads_mutex
argument_list|)
expr_stmt|;
name|JOIN
argument_list|(
name|t
argument_list|,
operator|&
name|av
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|av
argument_list|)
expr_stmt|;
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"perl_destruct: joined zombie %p OK\n"
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|retry_cleanup
goto|;
case|case
name|THRf_R_JOINABLE
case|:
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"perl_destruct: detaching thread %p\n"
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|ThrSETSTATE
argument_list|(
name|t
argument_list|,
name|THRf_R_DETACHED
argument_list|)
expr_stmt|;
comment|/*  	     * We unlock threads_mutex and t->mutex in the opposite order 	     * from which we locked them just so that DETACH won't 	     * deadlock if it panics. It's only a breach of good style 	     * not a bug since they are unlocks not locks. 	     */
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|PL_threads_mutex
argument_list|)
expr_stmt|;
name|DETACH
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|t
operator|->
name|mutex
argument_list|)
expr_stmt|;
goto|goto
name|retry_cleanup
goto|;
default|default:
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"perl_destruct: ignoring %p (state %u)\n"
argument_list|,
name|t
argument_list|,
name|ThrSTATE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|t
operator|->
name|mutex
argument_list|)
expr_stmt|;
comment|/* fall through and out */
block|}
block|}
comment|/* We leave the above "Pass 1" loop with threads_mutex still locked */
comment|/* Pass 2 on remaining threads: wait for the thread count to drop to one */
while|while
condition|(
name|PL_nthreads
operator|>
literal|1
condition|)
block|{
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"perl_destruct: final wait for %d threads\n"
argument_list|,
name|PL_nthreads
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|COND_WAIT
argument_list|(
operator|&
name|PL_nthreads_cond
argument_list|,
operator|&
name|PL_threads_mutex
argument_list|)
expr_stmt|;
block|}
comment|/* At this point, we're the last thread */
name|MUTEX_UNLOCK
argument_list|(
operator|&
name|PL_threads_mutex
argument_list|)
expr_stmt|;
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"perl_destruct: armageddon has arrived\n"
argument_list|)
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|PL_threads_mutex
argument_list|)
expr_stmt|;
name|COND_DESTROY
argument_list|(
operator|&
name|PL_nthreads_cond
argument_list|)
expr_stmt|;
name|PL_nthreads
operator|--
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(FAKE_THREADS) */
endif|#
directive|endif
comment|/* USE_THREADS */
name|destruct_level
operator|=
name|PL_perl_destruct_level
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|PerlEnv_getenv
argument_list|(
literal|"PERL_DESTRUCT_LEVEL"
argument_list|)
operator|)
condition|)
block|{
name|int
name|i
init|=
name|atoi
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|destruct_level
operator|<
name|i
condition|)
name|destruct_level
operator|=
name|i
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|LEAVE
expr_stmt|;
name|FREETMPS
expr_stmt|;
comment|/* We must account for everything.  */
comment|/* Destroy the main CV and syntax tree */
if|if
condition|(
name|PL_main_root
condition|)
block|{
name|PL_curpad
operator|=
name|AvARRAY
argument_list|(
name|PL_comppad
argument_list|)
expr_stmt|;
name|op_free
argument_list|(
name|PL_main_root
argument_list|)
expr_stmt|;
name|PL_main_root
operator|=
name|Nullop
expr_stmt|;
block|}
name|PL_curcop
operator|=
operator|&
name|PL_compiling
expr_stmt|;
name|PL_main_start
operator|=
name|Nullop
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_main_cv
argument_list|)
expr_stmt|;
name|PL_main_cv
operator|=
name|Nullcv
expr_stmt|;
name|PL_dirty
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|PL_sv_objcount
condition|)
block|{
comment|/* 	 * Try to destruct global references.  We do this first so that the 	 * destructors and destructees still exist.  Some sv's might remain. 	 * Non-referenced objects are on their own. 	 */
name|sv_clean_objs
argument_list|()
expr_stmt|;
block|}
comment|/* unhook hooks which will soon be, or use, destroyed data */
name|SvREFCNT_dec
argument_list|(
name|PL_warnhook
argument_list|)
expr_stmt|;
name|PL_warnhook
operator|=
name|Nullsv
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_diehook
argument_list|)
expr_stmt|;
name|PL_diehook
operator|=
name|Nullsv
expr_stmt|;
comment|/* call exit list functions */
while|while
condition|(
name|PL_exitlistlen
operator|--
operator|>
literal|0
condition|)
name|PL_exitlist
index|[
name|PL_exitlistlen
index|]
operator|.
name|fn
argument_list|(
argument|aTHXo_ PL_exitlist[PL_exitlistlen].ptr
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|PL_exitlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|destruct_level
operator|==
literal|0
condition|)
block|{
name|DEBUG_P
argument_list|(
name|debprofdump
argument_list|()
argument_list|)
expr_stmt|;
comment|/* The exit() function will do everything that needs doing. */
return|return;
block|}
comment|/* jettison our possibly duplicated environment */
ifdef|#
directive|ifdef
name|USE_ENVIRON_ARRAY
if|if
condition|(
name|environ
operator|!=
name|PL_origenviron
condition|)
block|{
name|I32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|environ
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|safesysfree
argument_list|(
name|environ
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Must use safesysfree() when working with environ. */
name|safesysfree
argument_list|(
name|environ
argument_list|)
expr_stmt|;
name|environ
operator|=
name|PL_origenviron
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* loosen bonds of global variables */
if|if
condition|(
name|PL_rsfp
condition|)
block|{
operator|(
name|void
operator|)
name|PerlIO_close
argument_list|(
name|PL_rsfp
argument_list|)
expr_stmt|;
name|PL_rsfp
operator|=
name|Nullfp
expr_stmt|;
block|}
comment|/* Filters for program text */
name|SvREFCNT_dec
argument_list|(
name|PL_rsfp_filters
argument_list|)
expr_stmt|;
name|PL_rsfp_filters
operator|=
name|Nullav
expr_stmt|;
comment|/* switches */
name|PL_preprocess
operator|=
name|FALSE
expr_stmt|;
name|PL_minus_n
operator|=
name|FALSE
expr_stmt|;
name|PL_minus_p
operator|=
name|FALSE
expr_stmt|;
name|PL_minus_l
operator|=
name|FALSE
expr_stmt|;
name|PL_minus_a
operator|=
name|FALSE
expr_stmt|;
name|PL_minus_F
operator|=
name|FALSE
expr_stmt|;
name|PL_doswitches
operator|=
name|FALSE
expr_stmt|;
name|PL_dowarn
operator|=
name|G_WARN_OFF
expr_stmt|;
name|PL_doextract
operator|=
name|FALSE
expr_stmt|;
name|PL_sawampersand
operator|=
name|FALSE
expr_stmt|;
comment|/* must save all match strings */
name|PL_unsafe
operator|=
name|FALSE
expr_stmt|;
name|Safefree
argument_list|(
name|PL_inplace
argument_list|)
expr_stmt|;
name|PL_inplace
operator|=
name|Nullch
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_patchlevel
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_e_script
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|PL_e_script
argument_list|)
expr_stmt|;
name|PL_e_script
operator|=
name|Nullsv
expr_stmt|;
block|}
comment|/* magical thingies */
name|Safefree
argument_list|(
name|PL_ofs
argument_list|)
expr_stmt|;
comment|/* $, */
name|PL_ofs
operator|=
name|Nullch
expr_stmt|;
name|Safefree
argument_list|(
name|PL_ors
argument_list|)
expr_stmt|;
comment|/* $\ */
name|PL_ors
operator|=
name|Nullch
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_rs
argument_list|)
expr_stmt|;
comment|/* $/ */
name|PL_rs
operator|=
name|Nullsv
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_nrs
argument_list|)
expr_stmt|;
comment|/* $/ helper */
name|PL_nrs
operator|=
name|Nullsv
expr_stmt|;
name|PL_multiline
operator|=
literal|0
expr_stmt|;
comment|/* $* */
name|Safefree
argument_list|(
name|PL_osname
argument_list|)
expr_stmt|;
comment|/* $^O */
name|PL_osname
operator|=
name|Nullch
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_statname
argument_list|)
expr_stmt|;
name|PL_statname
operator|=
name|Nullsv
expr_stmt|;
name|PL_statgv
operator|=
name|Nullgv
expr_stmt|;
comment|/* defgv, aka *_ should be taken care of elsewhere */
comment|/* clean up after study() */
name|SvREFCNT_dec
argument_list|(
name|PL_lastscream
argument_list|)
expr_stmt|;
name|PL_lastscream
operator|=
name|Nullsv
expr_stmt|;
name|Safefree
argument_list|(
name|PL_screamfirst
argument_list|)
expr_stmt|;
name|PL_screamfirst
operator|=
literal|0
expr_stmt|;
name|Safefree
argument_list|(
name|PL_screamnext
argument_list|)
expr_stmt|;
name|PL_screamnext
operator|=
literal|0
expr_stmt|;
comment|/* float buffer */
name|Safefree
argument_list|(
name|PL_efloatbuf
argument_list|)
expr_stmt|;
name|PL_efloatbuf
operator|=
name|Nullch
expr_stmt|;
name|PL_efloatsize
operator|=
literal|0
expr_stmt|;
comment|/* startup and shutdown function lists */
name|SvREFCNT_dec
argument_list|(
name|PL_beginav
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_endav
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_checkav
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_initav
argument_list|)
expr_stmt|;
name|PL_beginav
operator|=
name|Nullav
expr_stmt|;
name|PL_endav
operator|=
name|Nullav
expr_stmt|;
name|PL_checkav
operator|=
name|Nullav
expr_stmt|;
name|PL_initav
operator|=
name|Nullav
expr_stmt|;
comment|/* shortcuts just get cleared */
name|PL_envgv
operator|=
name|Nullgv
expr_stmt|;
name|PL_incgv
operator|=
name|Nullgv
expr_stmt|;
name|PL_hintgv
operator|=
name|Nullgv
expr_stmt|;
name|PL_errgv
operator|=
name|Nullgv
expr_stmt|;
name|PL_argvgv
operator|=
name|Nullgv
expr_stmt|;
name|PL_argvoutgv
operator|=
name|Nullgv
expr_stmt|;
name|PL_stdingv
operator|=
name|Nullgv
expr_stmt|;
name|PL_stderrgv
operator|=
name|Nullgv
expr_stmt|;
name|PL_last_in_gv
operator|=
name|Nullgv
expr_stmt|;
name|PL_replgv
operator|=
name|Nullgv
expr_stmt|;
name|PL_debstash
operator|=
name|Nullhv
expr_stmt|;
comment|/* reset so print() ends up where we expect */
name|setdefout
argument_list|(
name|Nullgv
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_argvout_stack
argument_list|)
expr_stmt|;
name|PL_argvout_stack
operator|=
name|Nullav
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_modglobal
argument_list|)
expr_stmt|;
name|PL_modglobal
operator|=
name|Nullhv
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_preambleav
argument_list|)
expr_stmt|;
name|PL_preambleav
operator|=
name|Nullav
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_subname
argument_list|)
expr_stmt|;
name|PL_subname
operator|=
name|Nullsv
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_linestr
argument_list|)
expr_stmt|;
name|PL_linestr
operator|=
name|Nullsv
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_pidstatus
argument_list|)
expr_stmt|;
name|PL_pidstatus
operator|=
name|Nullhv
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_toptarget
argument_list|)
expr_stmt|;
name|PL_toptarget
operator|=
name|Nullsv
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_bodytarget
argument_list|)
expr_stmt|;
name|PL_bodytarget
operator|=
name|Nullsv
expr_stmt|;
name|PL_formtarget
operator|=
name|Nullsv
expr_stmt|;
comment|/* free locale stuff */
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
name|Safefree
argument_list|(
name|PL_collation_name
argument_list|)
expr_stmt|;
name|PL_collation_name
operator|=
name|Nullch
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
name|Safefree
argument_list|(
name|PL_numeric_name
argument_list|)
expr_stmt|;
name|PL_numeric_name
operator|=
name|Nullch
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_numeric_radix_sv
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* clear utf8 character classes */
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_alnum
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_alnumc
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_ascii
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_alpha
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_space
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_cntrl
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_graph
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_digit
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_upper
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_lower
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_print
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_punct
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_xdigit
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_mark
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_toupper
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_utf8_tolower
argument_list|)
expr_stmt|;
name|PL_utf8_alnum
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_alnumc
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_ascii
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_alpha
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_space
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_cntrl
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_graph
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_digit
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_upper
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_lower
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_print
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_punct
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_xdigit
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_mark
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_toupper
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_totitle
operator|=
name|Nullsv
expr_stmt|;
name|PL_utf8_tolower
operator|=
name|Nullsv
expr_stmt|;
if|if
condition|(
operator|!
name|specialWARN
argument_list|(
name|PL_compiling
operator|.
name|cop_warnings
argument_list|)
condition|)
name|SvREFCNT_dec
argument_list|(
name|PL_compiling
operator|.
name|cop_warnings
argument_list|)
expr_stmt|;
name|PL_compiling
operator|.
name|cop_warnings
operator|=
name|Nullsv
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_ITHREADS
name|Safefree
argument_list|(
name|CopFILE
argument_list|(
operator|&
name|PL_compiling
argument_list|)
argument_list|)
expr_stmt|;
name|CopFILE
argument_list|(
operator|&
name|PL_compiling
argument_list|)
operator|=
name|Nullch
expr_stmt|;
name|Safefree
argument_list|(
name|CopSTASHPV
argument_list|(
operator|&
name|PL_compiling
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|SvREFCNT_dec
argument_list|(
name|CopFILEGV
argument_list|(
operator|&
name|PL_compiling
argument_list|)
argument_list|)
expr_stmt|;
name|CopFILEGV
argument_list|(
operator|&
name|PL_compiling
argument_list|)
operator|=
name|Nullgv
expr_stmt|;
comment|/* cop_stash is not refcounted */
endif|#
directive|endif
comment|/* Prepare to destruct main symbol table.  */
name|hv
operator|=
name|PL_defstash
expr_stmt|;
name|PL_defstash
operator|=
literal|0
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|hv
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_curstname
argument_list|)
expr_stmt|;
name|PL_curstname
operator|=
name|Nullsv
expr_stmt|;
comment|/* clear queued errors */
name|SvREFCNT_dec
argument_list|(
name|PL_errors
argument_list|)
expr_stmt|;
name|PL_errors
operator|=
name|Nullsv
expr_stmt|;
name|FREETMPS
expr_stmt|;
if|if
condition|(
name|destruct_level
operator|>=
literal|2
operator|&&
name|ckWARN_d
argument_list|(
name|WARN_INTERNAL
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_scopestack_ix
operator|!=
literal|0
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INTERNAL
argument_list|,
literal|"Unbalanced scopes: %ld more ENTERs than LEAVEs\n"
argument_list|,
argument|(long)PL_scopestack_ix
argument_list|)
empty_stmt|;
if|if
condition|(
name|PL_savestack_ix
operator|!=
literal|0
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INTERNAL
argument_list|,
literal|"Unbalanced saves: %ld more saves than restores\n"
argument_list|,
argument|(long)PL_savestack_ix
argument_list|)
empty_stmt|;
if|if
condition|(
name|PL_tmps_floor
operator|!=
operator|-
literal|1
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INTERNAL
argument_list|,
literal|"Unbalanced tmps: %ld more allocs than frees\n"
argument_list|,
argument|(long)PL_tmps_floor +
literal|1
argument_list|)
empty_stmt|;
if|if
condition|(
name|cxstack_ix
operator|!=
operator|-
literal|1
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INTERNAL
argument_list|,
literal|"Unbalanced context: %ld more PUSHes than POPs\n"
argument_list|,
argument|(long)cxstack_ix +
literal|1
argument_list|)
empty_stmt|;
block|}
comment|/* Now absolutely destruct everything, somehow or other, loops or no. */
name|SvFLAGS
argument_list|(
name|PL_fdpid
argument_list|)
operator||=
name|SVTYPEMASK
expr_stmt|;
comment|/* don't clean out pid table now */
name|SvFLAGS
argument_list|(
name|PL_strtab
argument_list|)
operator||=
name|SVTYPEMASK
expr_stmt|;
comment|/* don't clean out strtab now */
comment|/* the 2 is for PL_fdpid and PL_strtab */
while|while
condition|(
name|PL_sv_count
operator|>
literal|2
operator|&&
name|sv_clean_all
argument_list|()
condition|)
empty_stmt|;
name|SvFLAGS
argument_list|(
name|PL_fdpid
argument_list|)
operator|&=
operator|~
name|SVTYPEMASK
expr_stmt|;
name|SvFLAGS
argument_list|(
name|PL_fdpid
argument_list|)
operator||=
name|SVt_PVAV
expr_stmt|;
name|SvFLAGS
argument_list|(
name|PL_strtab
argument_list|)
operator|&=
operator|~
name|SVTYPEMASK
expr_stmt|;
name|SvFLAGS
argument_list|(
name|PL_strtab
argument_list|)
operator||=
name|SVt_PVHV
expr_stmt|;
name|AvREAL_off
argument_list|(
name|PL_fdpid
argument_list|)
expr_stmt|;
comment|/* no surviving entries */
name|SvREFCNT_dec
argument_list|(
name|PL_fdpid
argument_list|)
expr_stmt|;
comment|/* needed in io_close() */
name|PL_fdpid
operator|=
name|Nullav
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_INTERP_INTERN
name|sys_intern_clear
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Destruct the global string table. */
block|{
comment|/* Yell and reset the HeVAL() slots that are still holding refcounts, 	 * so that sv_free() won't fail on them. 	 */
name|I32
name|riter
decl_stmt|;
name|I32
name|max
decl_stmt|;
name|HE
modifier|*
name|hent
decl_stmt|;
name|HE
modifier|*
modifier|*
name|array
decl_stmt|;
name|riter
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|HvMAX
argument_list|(
name|PL_strtab
argument_list|)
expr_stmt|;
name|array
operator|=
name|HvARRAY
argument_list|(
name|PL_strtab
argument_list|)
expr_stmt|;
name|hent
operator|=
name|array
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|hent
operator|&&
name|ckWARN_d
argument_list|(
name|WARN_INTERNAL
argument_list|)
condition|)
block|{
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INTERNAL
argument_list|,
literal|"Unbalanced string table refcount: (%d) for \"%s\""
argument_list|,
argument|HeVAL(hent) - Nullsv
argument_list|,
argument|HeKEY(hent)
argument_list|)
empty_stmt|;
name|HeVAL
argument_list|(
name|hent
argument_list|)
operator|=
name|Nullsv
expr_stmt|;
name|hent
operator|=
name|HeNEXT
argument_list|(
name|hent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hent
condition|)
block|{
if|if
condition|(
operator|++
name|riter
operator|>
name|max
condition|)
break|break;
name|hent
operator|=
name|array
index|[
name|riter
index|]
expr_stmt|;
block|}
block|}
block|}
name|SvREFCNT_dec
argument_list|(
name|PL_strtab
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_ITHREADS
comment|/* free the pointer table used for cloning */
name|ptr_table_free
argument_list|(
name|PL_ptr_table
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* free special SVs */
name|SvREFCNT
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
operator|=
literal|0
expr_stmt|;
name|sv_clear
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
expr_stmt|;
name|SvANY
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|SvFLAGS
argument_list|(
operator|&
name|PL_sv_yes
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvREFCNT
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
operator|=
literal|0
expr_stmt|;
name|sv_clear
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
expr_stmt|;
name|SvANY
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|SvFLAGS
argument_list|(
operator|&
name|PL_sv_no
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvREFCNT
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvREADONLY_off
argument_list|(
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_sv_count
operator|!=
literal|0
operator|&&
name|ckWARN_d
argument_list|(
name|WARN_INTERNAL
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_INTERNAL
argument_list|,
literal|"Scalars leaked: %ld\n"
argument_list|,
argument|(long)PL_sv_count
argument_list|)
empty_stmt|;
name|Safefree
argument_list|(
name|PL_origfilename
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|PL_reg_start_tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_reg_curpm
condition|)
name|Safefree
argument_list|(
name|PL_reg_curpm
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|PL_reg_poscache
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|HeKEY_hek
argument_list|(
operator|&
name|PL_hv_fetch_ent_mh
argument_list|)
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|PL_op_mask
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|PL_psig_ptr
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|PL_psig_name
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|PL_bitcount
argument_list|)
expr_stmt|;
name|nuke_stacks
argument_list|()
expr_stmt|;
name|PL_hints
operator|=
literal|0
expr_stmt|;
comment|/* Reset hints. Should hints be per-interpreter ? */
name|DEBUG_P
argument_list|(
name|debprofdump
argument_list|()
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|MUTEX_DESTROY
argument_list|(
operator|&
name|PL_strtab_mutex
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|PL_sv_mutex
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|PL_eval_mutex
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|PL_cred_mutex
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
operator|&
name|PL_fdpid_mutex
argument_list|)
expr_stmt|;
name|COND_DESTROY
argument_list|(
operator|&
name|PL_eval_cond
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EMULATE_ATOMIC_REFCOUNTS
name|MUTEX_DESTROY
argument_list|(
operator|&
name|PL_svref_mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EMULATE_ATOMIC_REFCOUNTS */
comment|/* As the penultimate thing, free the non-arena SV for thrsv */
name|Safefree
argument_list|(
name|SvPVX
argument_list|(
name|PL_thrsv
argument_list|)
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|SvANY
argument_list|(
name|PL_thrsv
argument_list|)
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|PL_thrsv
argument_list|)
expr_stmt|;
name|PL_thrsv
operator|=
name|Nullsv
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
name|sv_free_arenas
argument_list|()
expr_stmt|;
comment|/* As the absolutely last thing, free the non-arena SV for mess() */
if|if
condition|(
name|PL_mess_sv
condition|)
block|{
comment|/* it could have accumulated taint magic */
if|if
condition|(
name|SvTYPE
argument_list|(
name|PL_mess_sv
argument_list|)
operator|>=
name|SVt_PVMG
condition|)
block|{
name|MAGIC
modifier|*
name|mg
decl_stmt|;
name|MAGIC
modifier|*
name|moremagic
decl_stmt|;
for|for
control|(
name|mg
operator|=
name|SvMAGIC
argument_list|(
name|PL_mess_sv
argument_list|)
init|;
name|mg
condition|;
name|mg
operator|=
name|moremagic
control|)
block|{
name|moremagic
operator|=
name|mg
operator|->
name|mg_moremagic
expr_stmt|;
if|if
condition|(
name|mg
operator|->
name|mg_ptr
operator|&&
name|mg
operator|->
name|mg_type
operator|!=
literal|'g'
operator|&&
name|mg
operator|->
name|mg_len
operator|>=
literal|0
condition|)
name|Safefree
argument_list|(
name|mg
operator|->
name|mg_ptr
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|mg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* we know that type>= SVt_PV */
operator|(
name|void
operator|)
name|SvOOK_off
argument_list|(
name|PL_mess_sv
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|SvPVX
argument_list|(
name|PL_mess_sv
argument_list|)
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|SvANY
argument_list|(
name|PL_mess_sv
argument_list|)
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|PL_mess_sv
argument_list|)
expr_stmt|;
name|PL_mess_sv
operator|=
name|Nullsv
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* =for apidoc perl_free  Releases a Perl interpreter.  See L<perlembed>.  =cut */
end_comment

begin_function
name|void
name|perl_free
parameter_list|(
name|pTHXx
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|PERL_OBJECT
argument_list|)
name|PerlMem_free
argument_list|(
name|this
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|PERL_IMPLICIT_SYS
argument_list|)
operator|&&
name|defined
argument_list|(
name|WIN32
argument_list|)
name|void
modifier|*
name|host
init|=
name|w32_internal_host
decl_stmt|;
name|PerlMem_free
argument_list|(
name|aTHXx
argument_list|)
expr_stmt|;
name|win32_delete_internal_host
argument_list|(
name|host
argument_list|)
expr_stmt|;
else|#
directive|else
name|PerlMem_free
argument_list|(
name|aTHXx
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|Perl_call_atexit
parameter_list|(
name|pTHX_
name|ATEXIT_t
name|fn
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|Renew
argument_list|(
name|PL_exitlist
argument_list|,
name|PL_exitlistlen
operator|+
literal|1
argument_list|,
name|PerlExitListEntry
argument_list|)
expr_stmt|;
name|PL_exitlist
index|[
name|PL_exitlistlen
index|]
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|PL_exitlist
index|[
name|PL_exitlistlen
index|]
operator|.
name|ptr
operator|=
name|ptr
expr_stmt|;
operator|++
name|PL_exitlistlen
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =for apidoc perl_parse  Tells a Perl interpreter to parse a Perl script.  See L<perlembed>.  =cut */
end_comment

begin_function
name|int
name|perl_parse
parameter_list|(
name|pTHXx_
name|XSINIT_t
name|xsinit
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
name|I32
name|oldscope
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|dJMPENV
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|dTHX
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SETUID_SCRIPTS_ARE_SECURE_NOW
ifdef|#
directive|ifdef
name|IAMSUID
undef|#
directive|undef
name|IAMSUID
name|Perl_croak
argument_list|(
name|aTHX_
literal|"suidperl is no longer needed since the kernel can now execute\n\ setuid perl scripts securely.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__DYNAMIC__
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|NeXT
argument_list|)
operator|||
name|defined
argument_list|(
name|__NeXT__
argument_list|)
operator|)
name|_dyld_lookup_and_bind
argument_list|(
literal|"__environ"
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|&
name|environ_pointer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* environ */
name|PL_origargv
operator|=
name|argv
expr_stmt|;
name|PL_origargc
operator|=
name|argc
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_ENVIRON_ARRAY
name|PL_origenviron
operator|=
name|environ
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|PL_do_undump
condition|)
block|{
comment|/* Come here if running an undumped a.out. */
name|PL_origfilename
operator|=
name|savepv
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|PL_do_undump
operator|=
name|FALSE
expr_stmt|;
name|cxstack_ix
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* start label stack again */
name|init_ids
argument_list|()
expr_stmt|;
name|init_postdump_symbols
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|env
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|PL_main_root
condition|)
block|{
name|PL_curpad
operator|=
name|AvARRAY
argument_list|(
name|PL_comppad
argument_list|)
expr_stmt|;
name|op_free
argument_list|(
name|PL_main_root
argument_list|)
expr_stmt|;
name|PL_main_root
operator|=
name|Nullop
expr_stmt|;
block|}
name|PL_main_start
operator|=
name|Nullop
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_main_cv
argument_list|)
expr_stmt|;
name|PL_main_cv
operator|=
name|Nullcv
expr_stmt|;
name|time
argument_list|(
operator|&
name|PL_basetime
argument_list|)
expr_stmt|;
name|oldscope
operator|=
name|PL_scopestack_ix
expr_stmt|;
name|PL_dowarn
operator|=
name|G_WARN_OFF
expr_stmt|;
ifdef|#
directive|ifdef
name|PERL_FLEXIBLE_EXCEPTIONS
name|CALLPROTECT
argument_list|(
argument|aTHX_ pcur_env
argument_list|,
argument|&ret
argument_list|,
argument|MEMBER_TO_FPTR(S_vparse_body)
argument_list|,
argument|env
argument_list|,
argument|xsinit
argument_list|)
empty_stmt|;
else|#
directive|else
name|JMPENV_PUSH
argument_list|(
name|ret
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
literal|0
case|:
ifndef|#
directive|ifndef
name|PERL_FLEXIBLE_EXCEPTIONS
name|parse_body
argument_list|(
name|env
argument_list|,
name|xsinit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|PL_checkav
condition|)
name|call_list
argument_list|(
name|oldscope
argument_list|,
name|PL_checkav
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|STATUS_ALL_FAILURE
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|2
case|:
comment|/* my_exit() was called */
while|while
condition|(
name|PL_scopestack_ix
operator|>
name|oldscope
condition|)
name|LEAVE
expr_stmt|;
name|FREETMPS
expr_stmt|;
name|PL_curstash
operator|=
name|PL_defstash
expr_stmt|;
if|if
condition|(
name|PL_checkav
condition|)
name|call_list
argument_list|(
name|oldscope
argument_list|,
name|PL_checkav
argument_list|)
expr_stmt|;
name|ret
operator|=
name|STATUS_NATIVE_EXPORT
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"panic: top_env\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|JMPENV_POP
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_FLEXIBLE_EXCEPTIONS
end_ifdef

begin_function
name|STATIC
name|void
modifier|*
name|S_vparse_body
parameter_list|(
name|pTHX_
name|va_list
name|args
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|env
init|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
operator|*
argument_list|)
decl_stmt|;
name|XSINIT_t
name|xsinit
init|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|XSINIT_t
argument_list|)
decl_stmt|;
return|return
name|parse_body
argument_list|(
name|env
argument_list|,
name|xsinit
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|STATIC
name|void
modifier|*
name|S_parse_body
parameter_list|(
name|pTHX_
name|char
modifier|*
modifier|*
name|env
parameter_list|,
name|XSINIT_t
name|xsinit
parameter_list|)
block|{
name|int
name|argc
init|=
name|PL_origargc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
init|=
name|PL_origargv
decl_stmt|;
name|char
modifier|*
name|scriptname
init|=
name|NULL
decl_stmt|;
name|int
name|fdscript
init|=
operator|-
literal|1
decl_stmt|;
name|VOL
name|bool
name|dosearch
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|validarg
init|=
literal|""
decl_stmt|;
name|AV
modifier|*
name|comppadlist
decl_stmt|;
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|cddir
init|=
name|Nullch
decl_stmt|;
name|sv_setpvn
argument_list|(
name|PL_linestr
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv
operator|=
name|newSVpvn
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* first used for -I flags */
name|SAVEFREESV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|init_main_stash
argument_list|()
expr_stmt|;
for|for
control|(
name|argc
operator|--
operator|,
name|argv
operator|++
init|;
name|argc
operator|>
literal|0
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
operator|!
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|)
break|break;
ifdef|#
directive|ifdef
name|DOSUID
if|if
condition|(
operator|*
name|validarg
condition|)
name|validarg
operator|=
literal|" PHOOEY "
expr_stmt|;
else|else
name|validarg
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|argv
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
name|reswitch
label|:
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'C'
case|:
ifdef|#
directive|ifdef
name|WIN32
name|win32_argv2utf8
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
endif|#
directive|endif
ifndef|#
directive|ifndef
name|PERL_STRICT_CR
case|case
literal|'\r'
case|:
endif|#
directive|endif
case|case
literal|' '
case|:
case|case
literal|'0'
case|:
case|case
literal|'F'
case|:
case|case
literal|'a'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'l'
case|:
case|case
literal|'M'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'p'
case|:
case|case
literal|'s'
case|:
case|case
literal|'u'
case|:
case|case
literal|'U'
case|:
case|case
literal|'v'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'w'
case|:
if|if
condition|(
operator|(
name|s
operator|=
name|moreswitches
argument_list|(
name|s
argument_list|)
operator|)
condition|)
goto|goto
name|reswitch
goto|;
break|break;
case|case
literal|'T'
case|:
name|PL_tainting
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
literal|'e'
case|:
ifdef|#
directive|ifdef
name|MACOS_TRADITIONAL
comment|/* ignore -e for Dev:Pseudo argument */
if|if
condition|(
name|argv
index|[
literal|1
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"Dev:Pseudo"
argument_list|)
condition|)
break|break;
endif|#
directive|endif
if|if
condition|(
name|PL_euid
operator|!=
name|PL_uid
operator|||
name|PL_egid
operator|!=
name|PL_gid
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"No -e allowed in setuid scripts"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PL_e_script
condition|)
block|{
name|PL_e_script
operator|=
name|newSVpvn
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|filter_add
argument_list|(
name|read_e_script
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|++
name|s
condition|)
name|sv_catpv
argument_list|(
name|PL_e_script
argument_list|,
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|argv
index|[
literal|1
index|]
condition|)
block|{
name|sv_catpv
argument_list|(
name|PL_e_script
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
block|}
else|else
name|Perl_croak
argument_list|(
name|aTHX_
literal|"No code specified for -e"
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|PL_e_script
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* -I handled both here and in moreswitches() */
name|forbid_setid
argument_list|(
literal|"-I"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
operator|++
name|s
operator|&&
operator|(
name|s
operator|=
name|argv
index|[
literal|1
index|]
operator|)
operator|!=
name|Nullch
condition|)
block|{
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|&&
operator|*
name|s
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|STRLEN
name|len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|p
operator|=
name|savepvn
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|incpush
argument_list|(
name|p
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
literal|"-I"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|Perl_croak
argument_list|(
name|aTHX_
literal|"No directory specified for -I"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|forbid_setid
argument_list|(
literal|"-P"
argument_list|)
expr_stmt|;
name|PL_preprocess
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
literal|'S'
case|:
name|forbid_setid
argument_list|(
literal|"-S"
argument_list|)
expr_stmt|;
name|dosearch
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
literal|'V'
case|:
if|if
condition|(
operator|!
name|PL_preambleav
condition|)
name|PL_preambleav
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|av_push
argument_list|(
name|PL_preambleav
argument_list|,
name|newSVpv
argument_list|(
literal|"use Config qw(myconfig config_vars)"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|s
operator|!=
literal|':'
condition|)
block|{
name|PL_Sv
operator|=
name|newSVpv
argument_list|(
literal|"print myconfig();"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|"print \"\\nCharacteristics of this PERLSHR image: \\n\","
argument_list|)
expr_stmt|;
else|#
directive|else
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|"print \"\\nCharacteristics of this binary (from libperl): \\n\","
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|"\"  Compile-time options:"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|" DEBUGGING"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MULTIPLICITY
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|" MULTIPLICITY"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_THREADS
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|" USE_THREADS"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_ITHREADS
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|" USE_ITHREADS"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_64_BIT_INT
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|" USE_64_BIT_INT"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_64_BIT_ALL
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|" USE_64_BIT_ALL"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_LONG_DOUBLE
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|" USE_LONG_DOUBLE"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_LARGE_FILES
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|" USE_LARGE_FILES"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_SOCKS
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|" USE_SOCKS"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PERL_OBJECT
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|" PERL_OBJECT"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PERL_IMPLICIT_CONTEXT
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|" PERL_IMPLICIT_CONTEXT"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PERL_IMPLICIT_SYS
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|" PERL_IMPLICIT_SYS"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|"\\n\","
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LOCAL_PATCH_COUNT
argument_list|)
if|if
condition|(
name|LOCAL_PATCH_COUNT
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|"\"  Locally applied patches:\\n\","
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|LOCAL_PATCH_COUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|PL_localpatches
index|[
name|i
index|]
condition|)
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ PL_Sv
argument_list|,
literal|"q\"  \t%s\n\","
argument_list|,
argument|PL_localpatches[i]
argument_list|)
empty_stmt|;
block|}
block|}
endif|#
directive|endif
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ PL_Sv
argument_list|,
literal|"\"  Built under %s\\n\""
argument_list|,
argument|OSNAME
argument_list|)
empty_stmt|;
ifdef|#
directive|ifdef
name|__DATE__
ifdef|#
directive|ifdef
name|__TIME__
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ PL_Sv
argument_list|,
literal|",\"  Compiled at %s %s\\n\""
argument_list|,
argument|__DATE__
argument_list|,
argument|__TIME__
argument_list|)
empty_stmt|;
else|#
directive|else
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ PL_Sv
argument_list|,
literal|",\"  Compiled on %s\\n\""
argument_list|,
argument|__DATE__
argument_list|)
empty_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|"; \ $\"=\"\\n    \"; \ @env = map { \"$_=\\\"$ENV{$_}\\\"\" } sort grep {/^PERL/} keys %ENV; \ print \"  \\%ENV:\\n    @env\\n\" if @env; \ print \"  \\@INC:\\n    @INC\\n\";"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PL_Sv
operator|=
name|newSVpv
argument_list|(
literal|"config_vars(qw("
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
operator|++
name|s
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|PL_Sv
argument_list|,
literal|"))"
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|av_push
argument_list|(
name|PL_preambleav
argument_list|,
name|PL_Sv
argument_list|)
expr_stmt|;
name|scriptname
operator|=
name|BIT_BUCKET
expr_stmt|;
comment|/* don't look for script or read stdin */
goto|goto
name|reswitch
goto|;
case|case
literal|'x'
case|:
name|PL_doextract
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
name|cddir
operator|=
name|s
expr_stmt|;
break|break;
case|case
literal|0
case|:
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
operator|!
operator|*
operator|++
name|s
operator|||
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
goto|goto
name|switch_end
goto|;
block|}
comment|/* catch use of gnu style long options */
if|if
condition|(
name|strEQ
argument_list|(
name|s
argument_list|,
literal|"version"
argument_list|)
condition|)
block|{
name|s
operator|=
literal|"v"
expr_stmt|;
goto|goto
name|reswitch
goto|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|s
argument_list|,
literal|"help"
argument_list|)
condition|)
block|{
name|s
operator|=
literal|"h"
expr_stmt|;
goto|goto
name|reswitch
goto|;
block|}
name|s
operator|--
expr_stmt|;
comment|/* FALL THROUGH */
default|default:
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Unrecognized switch: -%s  (-h will show valid options)"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|switch_end
label|:
if|if
condition|(
ifndef|#
directive|ifndef
name|SECURE_INTERNAL_GETENV
operator|!
name|PL_tainting
operator|&&
endif|#
directive|endif
operator|(
name|s
operator|=
name|PerlEnv_getenv
argument_list|(
literal|"PERL5OPT"
argument_list|)
operator|)
condition|)
block|{
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
operator|&&
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'T'
condition|)
name|PL_tainting
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
while|while
condition|(
name|s
operator|&&
operator|*
name|s
condition|)
block|{
name|char
modifier|*
name|d
decl_stmt|;
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
continue|continue;
block|}
name|d
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
break|break;
if|if
condition|(
operator|!
name|strchr
argument_list|(
literal|"DIMUdmw"
argument_list|,
operator|*
name|s
argument_list|)
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Illegal switch in PERL5OPT: -%c"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|++
name|s
operator|&&
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
name|moreswitches
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|scriptname
condition|)
name|scriptname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|PL_e_script
condition|)
block|{
name|argc
operator|++
operator|,
name|argv
operator|--
expr_stmt|;
name|scriptname
operator|=
name|BIT_BUCKET
expr_stmt|;
comment|/* don't look for script or read stdin */
block|}
elseif|else
if|if
condition|(
name|scriptname
operator|==
name|Nullch
condition|)
block|{
ifdef|#
directive|ifdef
name|MSDOS
if|if
condition|(
name|PerlLIO_isatty
argument_list|(
name|PerlIO_fileno
argument_list|(
name|PerlIO_stdin
argument_list|()
argument_list|)
argument_list|)
condition|)
name|moreswitches
argument_list|(
literal|"h"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scriptname
operator|=
literal|"-"
expr_stmt|;
block|}
name|init_perllib
argument_list|()
expr_stmt|;
name|open_script
argument_list|(
name|scriptname
argument_list|,
name|dosearch
argument_list|,
name|sv
argument_list|,
operator|&
name|fdscript
argument_list|)
expr_stmt|;
name|validate_suid
argument_list|(
name|validarg
argument_list|,
name|scriptname
argument_list|,
name|fdscript
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIGCHLD
argument_list|)
operator|||
name|defined
argument_list|(
name|SIGCLD
argument_list|)
block|{
ifndef|#
directive|ifndef
name|SIGCHLD
define|#
directive|define
name|SIGCHLD
value|SIGCLD
endif|#
directive|endif
name|Sighandler_t
name|sigstate
init|=
name|rsignal_state
argument_list|(
name|SIGCHLD
argument_list|)
decl_stmt|;
if|if
condition|(
name|sigstate
operator|==
name|SIG_IGN
condition|)
block|{
if|if
condition|(
name|ckWARN
argument_list|(
name|WARN_SIGNAL
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_SIGNAL
argument_list|,
literal|"Can't ignore signal CHLD, forcing to default"
argument_list|)
empty_stmt|;
operator|(
name|void
operator|)
name|rsignal
argument_list|(
name|SIGCHLD
argument_list|,
operator|(
name|Sighandler_t
operator|)
name|SIG_DFL
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MACOS_TRADITIONAL
if|if
condition|(
name|PL_doextract
operator|||
name|gMacPerl_AlwaysExtract
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|PL_doextract
condition|)
block|{
endif|#
directive|endif
name|find_beginning
argument_list|()
expr_stmt|;
if|if
condition|(
name|cddir
operator|&&
name|PerlDir_chdir
argument_list|(
name|cddir
argument_list|)
operator|<
literal|0
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't chdir to %s"
argument_list|,
name|cddir
argument_list|)
expr_stmt|;
block|}
name|PL_main_cv
operator|=
name|PL_compcv
operator|=
operator|(
name|CV
operator|*
operator|)
name|NEWSV
argument_list|(
literal|1104
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|PL_compcv
argument_list|,
name|SVt_PVCV
argument_list|)
expr_stmt|;
name|CvUNIQUE_on
argument_list|(
name|PL_compcv
argument_list|)
expr_stmt|;
name|PL_comppad
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|av_push
argument_list|(
name|PL_comppad
argument_list|,
name|Nullsv
argument_list|)
expr_stmt|;
name|PL_curpad
operator|=
name|AvARRAY
argument_list|(
name|PL_comppad
argument_list|)
expr_stmt|;
name|PL_comppad_name
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|PL_comppad_name_fill
operator|=
literal|0
expr_stmt|;
name|PL_min_intro_pending
operator|=
literal|0
expr_stmt|;
name|PL_padix
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|av_store
argument_list|(
name|PL_comppad_name
argument_list|,
literal|0
argument_list|,
name|newSVpvn
argument_list|(
literal|"@_"
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|PL_curpad
index|[
literal|0
index|]
operator|=
operator|(
name|SV
operator|*
operator|)
name|newAV
argument_list|()
expr_stmt|;
name|SvPADMY_on
argument_list|(
name|PL_curpad
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* XXX Needed? */
name|CvOWNER
argument_list|(
name|PL_compcv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|New
argument_list|(
literal|666
argument_list|,
name|CvMUTEXP
argument_list|(
name|PL_compcv
argument_list|)
argument_list|,
literal|1
argument_list|,
name|perl_mutex
argument_list|)
expr_stmt|;
name|MUTEX_INIT
argument_list|(
name|CvMUTEXP
argument_list|(
name|PL_compcv
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
name|comppadlist
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|AvREAL_off
argument_list|(
name|comppadlist
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|comppadlist
argument_list|,
literal|0
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|PL_comppad_name
argument_list|)
expr_stmt|;
name|av_store
argument_list|(
name|comppadlist
argument_list|,
literal|1
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|PL_comppad
argument_list|)
expr_stmt|;
name|CvPADLIST
argument_list|(
name|PL_compcv
argument_list|)
operator|=
name|comppadlist
expr_stmt|;
name|boot_core_UNIVERSAL
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|PERL_MICRO
name|boot_core_xsutils
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|xsinit
condition|)
call|(
modifier|*
name|xsinit
call|)
argument_list|(
name|aTHXo
argument_list|)
expr_stmt|;
comment|/* in case linked C routines want magical variables */
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|DJGPP
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|||
name|defined
argument_list|(
name|EPOC
argument_list|)
name|init_os_extras
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_SOCKS
ifdef|#
directive|ifdef
name|HAS_SOCKS5_INIT
name|socks5_init
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|SOCKSinit
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|init_predump_symbols
argument_list|()
expr_stmt|;
comment|/* init_postdump_symbols not currently designed to be called */
comment|/* more than once (ENV isn't cleared first, for example)	 */
comment|/* But running with -u leaves %ENV& @ARGV undefined!    XXX */
if|if
condition|(
operator|!
name|PL_do_undump
condition|)
name|init_postdump_symbols
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|init_lexer
argument_list|()
expr_stmt|;
comment|/* now parse the script */
name|SETERRNO
argument_list|(
literal|0
argument_list|,
name|SS$_NORMAL
argument_list|)
expr_stmt|;
name|PL_error_count
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|MACOS_TRADITIONAL
if|if
condition|(
name|gMacPerl_SyntaxError
operator|=
operator|(
name|yyparse
argument_list|()
operator|||
name|PL_error_count
operator|)
condition|)
block|{
if|if
condition|(
name|PL_minus_c
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"%s had compilation errors.\n"
argument_list|,
name|MacPerl_MPWFileName
argument_list|(
name|PL_origfilename
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Execution of %s aborted due to compilation errors.\n"
argument_list|,
name|MacPerl_MPWFileName
argument_list|(
name|PL_origfilename
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
if|if
condition|(
name|yyparse
argument_list|()
operator|||
name|PL_error_count
condition|)
block|{
if|if
condition|(
name|PL_minus_c
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"%s had compilation errors.\n"
argument_list|,
name|PL_origfilename
argument_list|)
expr_stmt|;
else|else
block|{
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Execution of %s aborted due to compilation errors.\n"
argument_list|,
name|PL_origfilename
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|CopLINE_set
argument_list|(
name|PL_curcop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PL_curstash
operator|=
name|PL_defstash
expr_stmt|;
name|PL_preprocess
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|PL_e_script
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|PL_e_script
argument_list|)
expr_stmt|;
name|PL_e_script
operator|=
name|Nullsv
expr_stmt|;
block|}
comment|/* now that script is parsed, we can modify record separator */
name|SvREFCNT_dec
argument_list|(
name|PL_rs
argument_list|)
expr_stmt|;
name|PL_rs
operator|=
name|SvREFCNT_inc
argument_list|(
name|PL_nrs
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
name|get_sv
argument_list|(
literal|"/"
argument_list|,
name|TRUE
argument_list|)
argument_list|,
name|PL_rs
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_do_undump
condition|)
name|my_unexec
argument_list|()
expr_stmt|;
if|if
condition|(
name|isWARN_ONCE
condition|)
block|{
name|SAVECOPFILE
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
name|SAVECOPLINE
argument_list|(
name|PL_curcop
argument_list|)
expr_stmt|;
name|gv_check
argument_list|(
name|PL_defstash
argument_list|)
expr_stmt|;
block|}
name|LEAVE
expr_stmt|;
name|FREETMPS
expr_stmt|;
ifdef|#
directive|ifdef
name|MYMALLOC
if|if
condition|(
operator|(
name|s
operator|=
name|PerlEnv_getenv
argument_list|(
literal|"PERL_DEBUG_MSTATS"
argument_list|)
operator|)
operator|&&
name|atoi
argument_list|(
name|s
argument_list|)
operator|>=
literal|2
condition|)
name|dump_mstats
argument_list|(
literal|"after compilation:"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ENTER
expr_stmt|;
name|PL_restartop
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* =for apidoc perl_run  Tells a Perl interpreter to run.  See L<perlembed>.  =cut */
name|int
name|perl_run
parameter_list|(
name|pTHXx
parameter_list|)
block|{
name|I32
name|oldscope
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|dJMPENV
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|dTHX
expr_stmt|;
endif|#
directive|endif
name|oldscope
operator|=
name|PL_scopestack_ix
expr_stmt|;
ifdef|#
directive|ifdef
name|PERL_FLEXIBLE_EXCEPTIONS
name|redo_body
label|:
name|CALLPROTECT
argument_list|(
argument|aTHX_ pcur_env
argument_list|,
argument|&ret
argument_list|,
argument|MEMBER_TO_FPTR(S_vrun_body)
argument_list|,
argument|oldscope
argument_list|)
empty_stmt|;
else|#
directive|else
name|JMPENV_PUSH
argument_list|(
name|ret
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
literal|1
case|:
name|cxstack_ix
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* start context stack again */
goto|goto
name|redo_body
goto|;
case|case
literal|0
case|:
comment|/* normal completion */
ifndef|#
directive|ifndef
name|PERL_FLEXIBLE_EXCEPTIONS
name|redo_body
label|:
name|run_body
argument_list|(
name|oldscope
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FALL THROUGH */
case|case
literal|2
case|:
comment|/* my_exit() */
while|while
condition|(
name|PL_scopestack_ix
operator|>
name|oldscope
condition|)
name|LEAVE
expr_stmt|;
name|FREETMPS
expr_stmt|;
name|PL_curstash
operator|=
name|PL_defstash
expr_stmt|;
if|if
condition|(
name|PL_endav
operator|&&
operator|!
name|PL_minus_c
condition|)
name|call_list
argument_list|(
name|oldscope
argument_list|,
name|PL_endav
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MYMALLOC
if|if
condition|(
name|PerlEnv_getenv
argument_list|(
literal|"PERL_DEBUG_MSTATS"
argument_list|)
condition|)
name|dump_mstats
argument_list|(
literal|"after execution:  "
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ret
operator|=
name|STATUS_NATIVE_EXPORT
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|PL_restartop
condition|)
block|{
name|POPSTACK_TO
argument_list|(
name|PL_mainstack
argument_list|)
expr_stmt|;
goto|goto
name|redo_body
goto|;
block|}
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"panic: restartop\n"
argument_list|)
expr_stmt|;
name|FREETMPS
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|JMPENV_POP
expr_stmt|;
return|return
name|ret
return|;
block|}
ifdef|#
directive|ifdef
name|PERL_FLEXIBLE_EXCEPTIONS
name|STATIC
name|void
modifier|*
name|S_vrun_body
parameter_list|(
name|pTHX_
name|va_list
name|args
parameter_list|)
block|{
name|I32
name|oldscope
init|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|I32
argument_list|)
decl_stmt|;
return|return
name|run_body
argument_list|(
name|oldscope
argument_list|)
return|;
block|}
endif|#
directive|endif
name|STATIC
name|void
modifier|*
name|S_run_body
parameter_list|(
name|pTHX_
name|I32
name|oldscope
parameter_list|)
block|{
name|DEBUG_r
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"%s $` $& $' support.\n"
argument_list|,
name|PL_sawampersand
condition|?
literal|"Enabling"
else|:
literal|"Omitting"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PL_restartop
condition|)
block|{
name|DEBUG_x
argument_list|(
name|dump_all
argument_list|()
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"\nEXECUTING...\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|DEBUG_S
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"main thread is 0x%"
name|UVxf
literal|"\n"
argument_list|,
name|PTR2UV
argument_list|(
name|thr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_minus_c
condition|)
block|{
ifdef|#
directive|ifdef
name|MACOS_TRADITIONAL
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"%s syntax OK\n"
argument_list|,
name|MacPerl_MPWFileName
argument_list|(
name|PL_origfilename
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|PerlIO_printf
argument_list|(
name|Perl_error_log
argument_list|,
literal|"%s syntax OK\n"
argument_list|,
name|PL_origfilename
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|my_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PERLDB_SINGLE
operator|&&
name|PL_DBsingle
condition|)
name|sv_setiv
argument_list|(
name|PL_DBsingle
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_initav
condition|)
name|call_list
argument_list|(
name|oldscope
argument_list|,
name|PL_initav
argument_list|)
expr_stmt|;
block|}
comment|/* do it */
if|if
condition|(
name|PL_restartop
condition|)
block|{
name|PL_op
operator|=
name|PL_restartop
expr_stmt|;
name|PL_restartop
operator|=
literal|0
expr_stmt|;
name|CALLRUNOPS
argument_list|(
name|aTHX
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PL_main_start
condition|)
block|{
name|CvDEPTH
argument_list|(
name|PL_main_cv
argument_list|)
operator|=
literal|1
expr_stmt|;
name|PL_op
operator|=
name|PL_main_start
expr_stmt|;
name|CALLRUNOPS
argument_list|(
name|aTHX
argument_list|)
expr_stmt|;
block|}
name|my_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|NULL
return|;
block|}
comment|/* =for apidoc p||get_sv  Returns the SV of the specified Perl scalar.  If C<create> is set and the Perl variable does not exist then it will be created.  If C<create> is not set and the variable does not exist then NULL is returned.  =cut */
name|SV
modifier|*
name|Perl_get_sv
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|I32
name|create
parameter_list|)
block|{
name|GV
modifier|*
name|gv
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|&&
operator|!
name|isALPHA
argument_list|(
name|name
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|PADOFFSET
name|tmp
init|=
name|find_threadsv
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NOT_IN_PAD
condition|)
return|return
name|THREADSV
argument_list|(
name|tmp
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* USE_THREADS */
name|gv
operator|=
name|gv_fetchpv
argument_list|(
name|name
argument_list|,
name|create
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
if|if
condition|(
name|gv
condition|)
return|return
name|GvSV
argument_list|(
name|gv
argument_list|)
return|;
return|return
name|Nullsv
return|;
block|}
comment|/* =for apidoc p||get_av  Returns the AV of the specified Perl array.  If C<create> is set and the Perl variable does not exist then it will be created.  If C<create> is not set and the variable does not exist then NULL is returned.  =cut */
name|AV
modifier|*
name|Perl_get_av
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|I32
name|create
parameter_list|)
block|{
name|GV
modifier|*
name|gv
init|=
name|gv_fetchpv
argument_list|(
name|name
argument_list|,
name|create
argument_list|,
name|SVt_PVAV
argument_list|)
decl_stmt|;
if|if
condition|(
name|create
condition|)
return|return
name|GvAVn
argument_list|(
name|gv
argument_list|)
return|;
if|if
condition|(
name|gv
condition|)
return|return
name|GvAV
argument_list|(
name|gv
argument_list|)
return|;
return|return
name|Nullav
return|;
block|}
comment|/* =for apidoc p||get_hv  Returns the HV of the specified Perl hash.  If C<create> is set and the Perl variable does not exist then it will be created.  If C<create> is not set and the variable does not exist then NULL is returned.  =cut */
name|HV
modifier|*
name|Perl_get_hv
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|I32
name|create
parameter_list|)
block|{
name|GV
modifier|*
name|gv
init|=
name|gv_fetchpv
argument_list|(
name|name
argument_list|,
name|create
argument_list|,
name|SVt_PVHV
argument_list|)
decl_stmt|;
if|if
condition|(
name|create
condition|)
return|return
name|GvHVn
argument_list|(
name|gv
argument_list|)
return|;
if|if
condition|(
name|gv
condition|)
return|return
name|GvHV
argument_list|(
name|gv
argument_list|)
return|;
return|return
name|Nullhv
return|;
block|}
comment|/* =for apidoc p||get_cv  Returns the CV of the specified Perl subroutine.  If C<create> is set and the Perl subroutine does not exist then it will be declared (which has the same effect as saying C<sub name;>).  If C<create> is not set and the subroutine does not exist then NULL is returned.  =cut */
name|CV
modifier|*
name|Perl_get_cv
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|I32
name|create
parameter_list|)
block|{
name|GV
modifier|*
name|gv
init|=
name|gv_fetchpv
argument_list|(
name|name
argument_list|,
name|create
argument_list|,
name|SVt_PVCV
argument_list|)
decl_stmt|;
comment|/* XXX unsafe for threads if eval_owner isn't held */
comment|/* XXX this is probably not what they think they're getting.      * It has the same effect as "sub name;", i.e. just a forward      * declaration! */
if|if
condition|(
name|create
operator|&&
operator|!
name|GvCVu
argument_list|(
name|gv
argument_list|)
condition|)
return|return
name|newSUB
argument_list|(
name|start_subparse
argument_list|(
name|FALSE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVpv
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|Nullop
argument_list|,
name|Nullop
argument_list|)
return|;
if|if
condition|(
name|gv
condition|)
return|return
name|GvCVu
argument_list|(
name|gv
argument_list|)
return|;
return|return
name|Nullcv
return|;
block|}
comment|/* Be sure to refetch the stack pointer after calling these routines. */
comment|/* =for apidoc p||call_argv  Performs a callback to the specified Perl sub.  See L<perlcall>.  =cut */
name|I32
name|Perl_call_argv
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|sub_name
parameter_list|,
name|I32
name|flags
parameter_list|,
specifier|register
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
comment|/* See G_* flags in cop.h */
comment|/* null terminated arg list */
block|{
name|dSP
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
condition|)
block|{
while|while
condition|(
operator|*
name|argv
condition|)
block|{
name|XPUSHs
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
operator|*
name|argv
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
name|PUTBACK
expr_stmt|;
block|}
return|return
name|call_pv
argument_list|(
name|sub_name
argument_list|,
name|flags
argument_list|)
return|;
block|}
comment|/* =for apidoc p||call_pv  Performs a callback to the specified Perl sub.  See L<perlcall>.  =cut */
name|I32
name|Perl_call_pv
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|sub_name
parameter_list|,
name|I32
name|flags
parameter_list|)
comment|/* name of the subroutine */
comment|/* See G_* flags in cop.h */
block|{
return|return
name|call_sv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|get_cv
argument_list|(
name|sub_name
argument_list|,
name|TRUE
argument_list|)
argument_list|,
name|flags
argument_list|)
return|;
block|}
comment|/* =for apidoc p||call_method  Performs a callback to the specified Perl method.  The blessed object must be on the stack.  See L<perlcall>.  =cut */
name|I32
name|Perl_call_method
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|methname
parameter_list|,
name|I32
name|flags
parameter_list|)
comment|/* name of the subroutine */
comment|/* See G_* flags in cop.h */
block|{
return|return
name|call_sv
argument_list|(
name|sv_2mortal
argument_list|(
name|newSVpv
argument_list|(
name|methname
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|flags
operator||
name|G_METHOD
argument_list|)
return|;
block|}
comment|/* May be called with any of a CV, a GV, or an SV containing the name. */
comment|/* =for apidoc p||call_sv  Performs a callback to the Perl sub whose name is in the SV.  See L<perlcall>.  =cut */
name|I32
name|Perl_call_sv
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|I32
name|flags
parameter_list|)
comment|/* See G_* flags in cop.h */
block|{
name|dSP
expr_stmt|;
name|LOGOP
name|myop
decl_stmt|;
comment|/* fake syntax tree node */
name|UNOP
name|method_op
decl_stmt|;
name|I32
name|oldmark
decl_stmt|;
name|I32
name|retval
decl_stmt|;
name|I32
name|oldscope
decl_stmt|;
name|bool
name|oldcatch
init|=
name|CATCH_GET
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|OP
modifier|*
name|oldop
init|=
name|PL_op
decl_stmt|;
name|dJMPENV
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|G_DISCARD
condition|)
block|{
name|ENTER
expr_stmt|;
name|SAVETMPS
expr_stmt|;
block|}
name|Zero
argument_list|(
operator|&
name|myop
argument_list|,
literal|1
argument_list|,
name|LOGOP
argument_list|)
expr_stmt|;
name|myop
operator|.
name|op_next
operator|=
name|Nullop
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|G_NOARGS
operator|)
condition|)
name|myop
operator|.
name|op_flags
operator||=
name|OPf_STACKED
expr_stmt|;
name|myop
operator|.
name|op_flags
operator||=
operator|(
operator|(
name|flags
operator|&
name|G_VOID
operator|)
condition|?
name|OPf_WANT_VOID
else|:
operator|(
name|flags
operator|&
name|G_ARRAY
operator|)
condition|?
name|OPf_WANT_LIST
else|:
name|OPf_WANT_SCALAR
operator|)
expr_stmt|;
name|SAVEOP
argument_list|()
expr_stmt|;
name|PL_op
operator|=
operator|(
name|OP
operator|*
operator|)
operator|&
name|myop
expr_stmt|;
name|EXTEND
argument_list|(
name|PL_stack_sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
operator|++
name|PL_stack_sp
operator|=
name|sv
expr_stmt|;
name|oldmark
operator|=
name|TOPMARK
expr_stmt|;
name|oldscope
operator|=
name|PL_scopestack_ix
expr_stmt|;
if|if
condition|(
name|PERLDB_SUB
operator|&&
name|PL_curstash
operator|!=
name|PL_debstash
comment|/* Handle first BEGIN of -d. */
operator|&&
operator|(
name|PL_DBcv
operator|||
operator|(
name|PL_DBcv
operator|=
name|GvCV
argument_list|(
name|PL_DBsub
argument_list|)
operator|)
operator|)
comment|/* Try harder, since this may have been a sighandler, thus 	    * curstash may be meaningless. */
operator|&&
operator|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|!=
name|SVt_PVCV
operator|||
name|CvSTASH
argument_list|(
operator|(
name|CV
operator|*
operator|)
name|sv
argument_list|)
operator|!=
name|PL_debstash
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|G_NODEBUG
operator|)
condition|)
name|PL_op
operator|->
name|op_private
operator||=
name|OPpENTERSUB_DB
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|G_METHOD
condition|)
block|{
name|Zero
argument_list|(
operator|&
name|method_op
argument_list|,
literal|1
argument_list|,
name|UNOP
argument_list|)
expr_stmt|;
name|method_op
operator|.
name|op_next
operator|=
name|PL_op
expr_stmt|;
name|method_op
operator|.
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_METHOD
index|]
expr_stmt|;
name|myop
operator|.
name|op_ppaddr
operator|=
name|PL_ppaddr
index|[
name|OP_ENTERSUB
index|]
expr_stmt|;
name|PL_op
operator|=
operator|(
name|OP
operator|*
operator|)
operator|&
name|method_op
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|G_EVAL
operator|)
condition|)
block|{
name|CATCH_SET
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|call_body
argument_list|(
operator|(
name|OP
operator|*
operator|)
operator|&
name|myop
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|retval
operator|=
name|PL_stack_sp
operator|-
operator|(
name|PL_stack_base
operator|+
name|oldmark
operator|)
expr_stmt|;
name|CATCH_SET
argument_list|(
name|oldcatch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|myop
operator|.
name|op_other
operator|=
operator|(
name|OP
operator|*
operator|)
operator|&
name|myop
expr_stmt|;
name|PL_markstack_ptr
operator|--
expr_stmt|;
comment|/* we're trying to emulate pp_entertry() here */
block|{
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|I32
name|gimme
init|=
name|GIMME_V
decl_stmt|;
name|ENTER
expr_stmt|;
name|SAVETMPS
expr_stmt|;
name|push_return
argument_list|(
name|Nullop
argument_list|)
expr_stmt|;
name|PUSHBLOCK
argument_list|(
name|cx
argument_list|,
operator|(
name|CXt_EVAL
operator||
name|CXp_TRYBLOCK
operator|)
argument_list|,
name|PL_stack_sp
argument_list|)
expr_stmt|;
name|PUSHEVAL
argument_list|(
name|cx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PL_eval_root
operator|=
name|PL_op
expr_stmt|;
comment|/* Only needed so that goto works right. */
name|PL_in_eval
operator|=
name|EVAL_INEVAL
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|G_KEEPERR
condition|)
name|PL_in_eval
operator||=
name|EVAL_KEEPERR
expr_stmt|;
else|else
name|sv_setpv
argument_list|(
name|ERRSV
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|PL_markstack_ptr
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|PERL_FLEXIBLE_EXCEPTIONS
name|redo_body
label|:
name|CALLPROTECT
argument_list|(
argument|aTHX_ pcur_env
argument_list|,
argument|&ret
argument_list|,
argument|MEMBER_TO_FPTR(S_vcall_body)
argument_list|,
argument|(OP*)&myop
argument_list|,
argument|FALSE
argument_list|)
empty_stmt|;
else|#
directive|else
name|JMPENV_PUSH
argument_list|(
name|ret
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
literal|0
case|:
ifndef|#
directive|ifndef
name|PERL_FLEXIBLE_EXCEPTIONS
name|redo_body
label|:
name|call_body
argument_list|(
operator|(
name|OP
operator|*
operator|)
operator|&
name|myop
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|retval
operator|=
name|PL_stack_sp
operator|-
operator|(
name|PL_stack_base
operator|+
name|oldmark
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|G_KEEPERR
operator|)
condition|)
name|sv_setpv
argument_list|(
name|ERRSV
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|STATUS_ALL_FAILURE
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|2
case|:
comment|/* my_exit() was called */
name|PL_curstash
operator|=
name|PL_defstash
expr_stmt|;
name|FREETMPS
expr_stmt|;
name|JMPENV_POP
expr_stmt|;
if|if
condition|(
name|PL_statusvalue
operator|&&
operator|!
operator|(
name|PL_exit_flags
operator|&
name|PERL_EXIT_EXPECTED
operator|)
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Callback called exit"
argument_list|)
expr_stmt|;
name|my_exit_jump
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|3
case|:
if|if
condition|(
name|PL_restartop
condition|)
block|{
name|PL_op
operator|=
name|PL_restartop
expr_stmt|;
name|PL_restartop
operator|=
literal|0
expr_stmt|;
goto|goto
name|redo_body
goto|;
block|}
name|PL_stack_sp
operator|=
name|PL_stack_base
operator|+
name|oldmark
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|G_ARRAY
condition|)
name|retval
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|retval
operator|=
literal|1
expr_stmt|;
operator|*
operator|++
name|PL_stack_sp
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|PL_scopestack_ix
operator|>
name|oldscope
condition|)
block|{
name|SV
modifier|*
modifier|*
name|newsp
decl_stmt|;
name|PMOP
modifier|*
name|newpm
decl_stmt|;
name|I32
name|gimme
decl_stmt|;
specifier|register
name|PERL_CONTEXT
modifier|*
name|cx
decl_stmt|;
name|I32
name|optype
decl_stmt|;
name|POPBLOCK
argument_list|(
name|cx
argument_list|,
name|newpm
argument_list|)
expr_stmt|;
name|POPEVAL
argument_list|(
name|cx
argument_list|)
expr_stmt|;
name|pop_return
argument_list|()
expr_stmt|;
name|PL_curpm
operator|=
name|newpm
expr_stmt|;
name|LEAVE
expr_stmt|;
block|}
name|JMPENV_POP
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|G_DISCARD
condition|)
block|{
name|PL_stack_sp
operator|=
name|PL_stack_base
operator|+
name|oldmark
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|FREETMPS
expr_stmt|;
name|LEAVE
expr_stmt|;
block|}
name|PL_op
operator|=
name|oldop
expr_stmt|;
return|return
name|retval
return|;
block|}
ifdef|#
directive|ifdef
name|PERL_FLEXIBLE_EXCEPTIONS
name|STATIC
name|void
modifier|*
name|S_vcall_body
parameter_list|(
name|pTHX_
name|va_list
name|args
parameter_list|)
block|{
name|OP
modifier|*
name|myop
init|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|OP
operator|*
argument_list|)
decl_stmt|;
name|int
name|is_eval
init|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
decl_stmt|;
name|call_body
argument_list|(
name|myop
argument_list|,
name|is_eval
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
name|STATIC
name|void
name|S_call_body
parameter_list|(
name|pTHX_
name|OP
modifier|*
name|myop
parameter_list|,
name|int
name|is_eval
parameter_list|)
block|{
if|if
condition|(
name|PL_op
operator|==
name|myop
condition|)
block|{
if|if
condition|(
name|is_eval
condition|)
name|PL_op
operator|=
name|Perl_pp_entereval
argument_list|(
name|aTHX
argument_list|)
expr_stmt|;
comment|/* this doesn't do a POPMARK */
else|else
name|PL_op
operator|=
name|Perl_pp_entersub
argument_list|(
name|aTHX
argument_list|)
expr_stmt|;
comment|/* this does */
block|}
if|if
condition|(
name|PL_op
condition|)
name|CALLRUNOPS
argument_list|(
name|aTHX
argument_list|)
expr_stmt|;
block|}
comment|/* Eval a string. The G_EVAL flag is always assumed. */
comment|/* =for apidoc p||eval_sv  Tells Perl to C<eval> the string in the SV.  =cut */
name|I32
name|Perl_eval_sv
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|I32
name|flags
parameter_list|)
comment|/* See G_* flags in cop.h */
block|{
name|dSP
expr_stmt|;
name|UNOP
name|myop
decl_stmt|;
comment|/* fake syntax tree node */
name|I32
name|oldmark
init|=
name|SP
operator|-
name|PL_stack_base
decl_stmt|;
name|I32
name|retval
decl_stmt|;
name|I32
name|oldscope
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|OP
modifier|*
name|oldop
init|=
name|PL_op
decl_stmt|;
name|dJMPENV
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|G_DISCARD
condition|)
block|{
name|ENTER
expr_stmt|;
name|SAVETMPS
expr_stmt|;
block|}
name|SAVEOP
argument_list|()
expr_stmt|;
name|PL_op
operator|=
operator|(
name|OP
operator|*
operator|)
operator|&
name|myop
expr_stmt|;
name|Zero
argument_list|(
name|PL_op
argument_list|,
literal|1
argument_list|,
name|UNOP
argument_list|)
expr_stmt|;
name|EXTEND
argument_list|(
name|PL_stack_sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
operator|++
name|PL_stack_sp
operator|=
name|sv
expr_stmt|;
name|oldscope
operator|=
name|PL_scopestack_ix
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|G_NOARGS
operator|)
condition|)
name|myop
operator|.
name|op_flags
operator|=
name|OPf_STACKED
expr_stmt|;
name|myop
operator|.
name|op_next
operator|=
name|Nullop
expr_stmt|;
name|myop
operator|.
name|op_type
operator|=
name|OP_ENTEREVAL
expr_stmt|;
name|myop
operator|.
name|op_flags
operator||=
operator|(
operator|(
name|flags
operator|&
name|G_VOID
operator|)
condition|?
name|OPf_WANT_VOID
else|:
operator|(
name|flags
operator|&
name|G_ARRAY
operator|)
condition|?
name|OPf_WANT_LIST
else|:
name|OPf_WANT_SCALAR
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|G_KEEPERR
condition|)
name|myop
operator|.
name|op_flags
operator||=
name|OPf_SPECIAL
expr_stmt|;
ifdef|#
directive|ifdef
name|PERL_FLEXIBLE_EXCEPTIONS
name|redo_body
label|:
name|CALLPROTECT
argument_list|(
argument|aTHX_ pcur_env
argument_list|,
argument|&ret
argument_list|,
argument|MEMBER_TO_FPTR(S_vcall_body)
argument_list|,
argument|(OP*)&myop
argument_list|,
argument|TRUE
argument_list|)
empty_stmt|;
else|#
directive|else
name|JMPENV_PUSH
argument_list|(
name|ret
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
literal|0
case|:
ifndef|#
directive|ifndef
name|PERL_FLEXIBLE_EXCEPTIONS
name|redo_body
label|:
name|call_body
argument_list|(
operator|(
name|OP
operator|*
operator|)
operator|&
name|myop
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|retval
operator|=
name|PL_stack_sp
operator|-
operator|(
name|PL_stack_base
operator|+
name|oldmark
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|G_KEEPERR
operator|)
condition|)
name|sv_setpv
argument_list|(
name|ERRSV
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|STATUS_ALL_FAILURE
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|2
case|:
comment|/* my_exit() was called */
name|PL_curstash
operator|=
name|PL_defstash
expr_stmt|;
name|FREETMPS
expr_stmt|;
name|JMPENV_POP
expr_stmt|;
if|if
condition|(
name|PL_statusvalue
operator|&&
operator|!
operator|(
name|PL_exit_flags
operator|&
name|PERL_EXIT_EXPECTED
operator|)
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Callback called exit"
argument_list|)
expr_stmt|;
name|my_exit_jump
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|3
case|:
if|if
condition|(
name|PL_restartop
condition|)
block|{
name|PL_op
operator|=
name|PL_restartop
expr_stmt|;
name|PL_restartop
operator|=
literal|0
expr_stmt|;
goto|goto
name|redo_body
goto|;
block|}
name|PL_stack_sp
operator|=
name|PL_stack_base
operator|+
name|oldmark
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|G_ARRAY
condition|)
name|retval
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|retval
operator|=
literal|1
expr_stmt|;
operator|*
operator|++
name|PL_stack_sp
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
block|}
break|break;
block|}
name|JMPENV_POP
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|G_DISCARD
condition|)
block|{
name|PL_stack_sp
operator|=
name|PL_stack_base
operator|+
name|oldmark
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|FREETMPS
expr_stmt|;
name|LEAVE
expr_stmt|;
block|}
name|PL_op
operator|=
name|oldop
expr_stmt|;
return|return
name|retval
return|;
block|}
comment|/* =for apidoc p||eval_pv  Tells Perl to C<eval> the given string and return an SV* result.  =cut */
name|SV
modifier|*
name|Perl_eval_pv
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|I32
name|croak_on_error
parameter_list|)
block|{
name|dSP
expr_stmt|;
name|SV
modifier|*
name|sv
init|=
name|newSVpv
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|eval_sv
argument_list|(
name|sv
argument_list|,
name|G_SCALAR
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SPAGAIN
expr_stmt|;
name|sv
operator|=
name|POPs
expr_stmt|;
name|PUTBACK
expr_stmt|;
if|if
condition|(
name|croak_on_error
operator|&&
name|SvTRUE
argument_list|(
name|ERRSV
argument_list|)
condition|)
block|{
name|STRLEN
name|n_a
decl_stmt|;
name|Perl_croak
argument_list|(
argument|aTHX_ SvPVx(ERRSV, n_a)
argument_list|)
empty_stmt|;
block|}
return|return
name|sv
return|;
block|}
comment|/* Require a module. */
comment|/* =for apidoc p||require_pv  Tells Perl to C<require> a module.  =cut */
name|void
name|Perl_require_pv
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|pv
parameter_list|)
block|{
name|SV
modifier|*
name|sv
decl_stmt|;
name|dSP
expr_stmt|;
name|PUSHSTACKi
argument_list|(
name|PERLSI_REQUIRE
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|sv
operator|=
name|sv_newmortal
argument_list|()
expr_stmt|;
name|sv_setpv
argument_list|(
name|sv
argument_list|,
literal|"require '"
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|sv
argument_list|,
name|pv
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|sv
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
name|eval_sv
argument_list|(
name|sv
argument_list|,
name|G_DISCARD
argument_list|)
expr_stmt|;
name|SPAGAIN
expr_stmt|;
name|POPSTACK
expr_stmt|;
block|}
name|void
name|Perl_magicname
parameter_list|(
name|pTHX_
name|char
modifier|*
name|sym
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|I32
name|namlen
parameter_list|)
block|{
specifier|register
name|GV
modifier|*
name|gv
decl_stmt|;
if|if
condition|(
operator|(
name|gv
operator|=
name|gv_fetchpv
argument_list|(
name|sym
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
operator|)
condition|)
name|sv_magic
argument_list|(
name|GvSV
argument_list|(
name|gv
argument_list|)
argument_list|,
operator|(
name|SV
operator|*
operator|)
name|gv
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
name|namlen
argument_list|)
expr_stmt|;
block|}
name|STATIC
name|void
name|S_usage
parameter_list|(
name|pTHX_
name|char
modifier|*
name|name
parameter_list|)
comment|/* XXX move this out into a module ? */
block|{
comment|/* This message really ought to be max 23 lines.      * Removed -h because the user already knows that opton. Others? */
specifier|static
name|char
modifier|*
name|usage_msg
index|[]
init|=
block|{
literal|"-0[octal]       specify record separator (\\0, if no argument)"
block|,
literal|"-a              autosplit mode with -n or -p (splits $_ into @F)"
block|,
literal|"-C              enable native wide character system interfaces"
block|,
literal|"-c              check syntax only (runs BEGIN and CHECK blocks)"
block|,
literal|"-d[:debugger]   run program under debugger"
block|,
literal|"-D[number/list] set debugging flags (argument is a bit mask or alphabets)"
block|,
literal|"-e 'command'    one line of program (several -e's allowed, omit programfile)"
block|,
literal|"-F/pattern/     split() pattern for -a switch (//'s are optional)"
block|,
literal|"-i[extension]   edit<> files in place (makes backup if extension supplied)"
block|,
literal|"-Idirectory     specify @INC/#include directory (several -I's allowed)"
block|,
literal|"-l[octal]       enable line ending processing, specifies line terminator"
block|,
literal|"-[mM][-]module  execute `use/no module...' before executing program"
block|,
literal|"-n              assume 'while (<>) { ... }' loop around program"
block|,
literal|"-p              assume loop like -n but print line also, like sed"
block|,
literal|"-P              run program through C preprocessor before compilation"
block|,
literal|"-s              enable rudimentary parsing for switches after programfile"
block|,
literal|"-S              look for programfile using PATH environment variable"
block|,
literal|"-T              enable tainting checks"
block|,
literal|"-u              dump core after parsing program"
block|,
literal|"-U              allow unsafe operations"
block|,
literal|"-v              print version, subversion (includes VERY IMPORTANT perl info)"
block|,
literal|"-V[:variable]   print configuration summary (or a single Config.pm variable)"
block|,
literal|"-w              enable many useful warnings (RECOMMENDED)"
block|,
literal|"-W              enable all warnings"
block|,
literal|"-X              disable all warnings"
block|,
literal|"-x[directory]   strip off text before #!perl line and perhaps cd to directory"
block|,
literal|"\n"
block|,
name|NULL
block|}
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
init|=
name|usage_msg
decl_stmt|;
name|PerlIO_printf
argument_list|(
name|PerlIO_stdout
argument_list|()
argument_list|,
literal|"\nUsage: %s [switches] [--] [programfile] [arguments]"
argument_list|,
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
name|PerlIO_printf
argument_list|(
name|PerlIO_stdout
argument_list|()
argument_list|,
literal|"\n  %s"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
comment|/* This routine handles any switches that can be given during run */
name|char
modifier|*
name|Perl_moreswitches
parameter_list|(
name|pTHX_
name|char
modifier|*
name|s
parameter_list|)
block|{
name|STRLEN
name|numlen
decl_stmt|;
name|U32
name|rschar
decl_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'0'
case|:
block|{
name|numlen
operator|=
literal|0
expr_stmt|;
comment|/* disallow underscores */
name|rschar
operator|=
operator|(
name|U32
operator|)
name|scan_oct
argument_list|(
name|s
argument_list|,
literal|4
argument_list|,
operator|&
name|numlen
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|PL_nrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rschar
operator|&
operator|~
operator|(
operator|(
name|U8
operator|)
operator|~
literal|0
operator|)
condition|)
name|PL_nrs
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|rschar
operator|&&
name|numlen
operator|>=
literal|2
condition|)
name|PL_nrs
operator|=
name|newSVpvn
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|ch
init|=
name|rschar
decl_stmt|;
name|PL_nrs
operator|=
name|newSVpvn
argument_list|(
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|s
operator|+
name|numlen
return|;
block|}
case|case
literal|'C'
case|:
name|PL_widesyscalls
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'F'
case|:
name|PL_minus_F
operator|=
name|TRUE
expr_stmt|;
name|PL_splitstr
operator|=
name|savepv
argument_list|(
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'a'
case|:
name|PL_minus_a
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'c'
case|:
name|PL_minus_c
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'d'
case|:
name|forbid_setid
argument_list|(
literal|"-d"
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
comment|/* The following permits -d:Mod to accepts arguments following an = 	   in the fashion that -MSome::Mod does. */
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
operator|||
operator|*
name|s
operator|==
literal|'='
condition|)
block|{
name|char
modifier|*
name|start
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|sv
operator|=
name|newSVpv
argument_list|(
literal|"use Devel::"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|start
operator|=
operator|++
name|s
expr_stmt|;
comment|/* We now allow -d:Module=Foo,Bar */
while|while
condition|(
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|':'
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'='
condition|)
name|sv_catpv
argument_list|(
name|sv
argument_list|,
name|start
argument_list|)
expr_stmt|;
else|else
block|{
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
name|start
argument_list|,
name|s
operator|-
name|start
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|sv
argument_list|,
literal|" split(/,/,q{"
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|sv
argument_list|,
operator|++
name|s
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|sv
argument_list|,
literal|"})"
argument_list|)
expr_stmt|;
block|}
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|my_setenv
argument_list|(
literal|"PERL5DB"
argument_list|,
name|SvPV
argument_list|(
name|sv
argument_list|,
name|PL_na
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|PL_perldb
condition|)
block|{
name|PL_perldb
operator|=
name|PERLDB_ALL
expr_stmt|;
name|init_debugger
argument_list|()
expr_stmt|;
block|}
return|return
name|s
return|;
case|case
literal|'D'
case|:
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
name|forbid_setid
argument_list|(
literal|"-D"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isALPHA
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
specifier|static
name|char
name|debopts
index|[]
init|=
literal|"psltocPmfrxuLHXDST"
decl_stmt|;
name|char
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|s
operator|++
init|;
operator|*
name|s
operator|&&
operator|(
name|d
operator|=
name|strchr
argument_list|(
name|debopts
argument_list|,
operator|*
name|s
argument_list|)
operator|)
condition|;
name|s
operator|++
control|)
name|PL_debug
operator||=
literal|1
operator|<<
operator|(
name|d
operator|-
name|debopts
operator|)
expr_stmt|;
block|}
else|else
block|{
name|PL_debug
operator|=
name|atoi
argument_list|(
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|++
init|;
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
block|}
name|PL_debug
operator||=
literal|0x80000000
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|ckWARN_d
argument_list|(
name|WARN_DEBUGGING
argument_list|)
condition|)
name|Perl_warner
argument_list|(
argument|aTHX_ WARN_DEBUGGING
argument_list|,
literal|"Recompile perl with -DDEBUGGING to use -D switch\n"
argument_list|)
empty_stmt|;
for|for
control|(
name|s
operator|++
init|;
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
endif|#
directive|endif
comment|/*SUPPRESS 530*/
return|return
name|s
return|;
block|}
case|case
literal|'h'
case|:
name|usage
argument_list|(
name|PL_origargv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|PerlProc_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'i'
case|:
if|if
condition|(
name|PL_inplace
condition|)
name|Safefree
argument_list|(
name|PL_inplace
argument_list|)
expr_stmt|;
name|PL_inplace
operator|=
name|savepv
argument_list|(
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/*SUPPRESS 530*/
for|for
control|(
name|s
operator|=
name|PL_inplace
init|;
operator|*
name|s
operator|&&
operator|!
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
comment|/* Additional switches on #! line. */
name|s
operator|++
expr_stmt|;
block|}
return|return
name|s
return|;
case|case
literal|'I'
case|:
comment|/* -I handled both here and in parse_perl() */
name|forbid_setid
argument_list|(
literal|"-I"
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
block|{
name|char
modifier|*
name|e
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|s
expr_stmt|;
comment|/* ignore trailing spaces (possibly followed by other switches) */
do|do
block|{
for|for
control|(
name|e
operator|=
name|p
init|;
operator|*
name|e
operator|&&
operator|!
name|isSPACE
argument_list|(
operator|*
name|e
argument_list|)
condition|;
name|e
operator|++
control|)
empty_stmt|;
name|p
operator|=
name|e
expr_stmt|;
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'-'
condition|)
do|;
name|e
operator|=
name|savepvn
argument_list|(
name|s
argument_list|,
name|e
operator|-
name|s
argument_list|)
expr_stmt|;
name|incpush
argument_list|(
name|e
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|s
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
name|s
operator|++
expr_stmt|;
block|}
else|else
name|Perl_croak
argument_list|(
name|aTHX_
literal|"No directory specified for -I"
argument_list|)
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'l'
case|:
name|PL_minus_l
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|PL_ors
condition|)
name|Safefree
argument_list|(
name|PL_ors
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|PL_ors
operator|=
name|savepv
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|PL_orslen
operator|=
literal|1
expr_stmt|;
name|numlen
operator|=
literal|0
expr_stmt|;
comment|/* disallow underscores */
operator|*
name|PL_ors
operator|=
operator|(
name|char
operator|)
name|scan_oct
argument_list|(
name|s
argument_list|,
literal|3
operator|+
operator|(
operator|*
name|s
operator|==
literal|'0'
operator|)
argument_list|,
operator|&
name|numlen
argument_list|)
expr_stmt|;
name|s
operator|+=
name|numlen
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|RsPARA
argument_list|(
name|PL_nrs
argument_list|)
condition|)
block|{
name|PL_ors
operator|=
literal|"\n\n"
expr_stmt|;
name|PL_orslen
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|PL_ors
operator|=
name|SvPV
argument_list|(
name|PL_nrs
argument_list|,
name|PL_orslen
argument_list|)
expr_stmt|;
name|PL_ors
operator|=
name|savepvn
argument_list|(
name|PL_ors
argument_list|,
name|PL_orslen
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
case|case
literal|'M'
case|:
name|forbid_setid
argument_list|(
literal|"-M"
argument_list|)
expr_stmt|;
comment|/* XXX ? */
comment|/* FALL THROUGH */
case|case
literal|'m'
case|:
name|forbid_setid
argument_list|(
literal|"-m"
argument_list|)
expr_stmt|;
comment|/* XXX ? */
if|if
condition|(
operator|*
operator|++
name|s
condition|)
block|{
name|char
modifier|*
name|start
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|char
modifier|*
name|use
init|=
literal|"use "
decl_stmt|;
comment|/* -M-foo == 'no foo'	*/
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|use
operator|=
literal|"no "
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
name|sv
operator|=
name|newSVpv
argument_list|(
name|use
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|start
operator|=
name|s
expr_stmt|;
comment|/* We allow -M'Module qw(Foo Bar)'	*/
while|while
condition|(
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|':'
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'='
condition|)
block|{
name|sv_catpv
argument_list|(
name|sv
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|start
operator|-
literal|1
operator|)
operator|==
literal|'m'
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't use '%c' after -mname"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|sv
argument_list|,
literal|" ()"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|s
operator|==
name|start
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Module name required with -%c option"
argument_list|,
name|s
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
name|start
argument_list|,
name|s
operator|-
name|start
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|sv
argument_list|,
literal|" split(/,/,q{"
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|sv
argument_list|,
operator|++
name|s
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|sv
argument_list|,
literal|"})"
argument_list|)
expr_stmt|;
block|}
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PL_preambleav
condition|)
name|PL_preambleav
operator|=
name|newAV
argument_list|()
expr_stmt|;
name|av_push
argument_list|(
name|PL_preambleav
argument_list|,
name|sv
argument_list|)
expr_stmt|;
block|}
else|else
name|Perl_croak
argument_list|(
name|aTHX_
literal|"No space allowed after -%c"
argument_list|,
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'n'
case|:
name|PL_minus_n
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'p'
case|:
name|PL_minus_p
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'s'
case|:
name|forbid_setid
argument_list|(
literal|"-s"
argument_list|)
expr_stmt|;
name|PL_doswitches
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'T'
case|:
if|if
condition|(
operator|!
name|PL_tainting
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Too late for \"-T\" option"
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'u'
case|:
ifdef|#
directive|ifdef
name|MACOS_TRADITIONAL
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Believe me, you don't want to use \"-u\" on a Macintosh"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PL_do_undump
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'U'
case|:
name|PL_unsafe
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'v'
case|:
name|PerlIO_printf
argument_list|(
name|PerlIO_stdout
argument_list|()
argument_list|,
name|Perl_form
argument_list|(
name|aTHX_
literal|"\nThis is perl, v%"
name|VDf
literal|" built for %s"
argument_list|,
name|PL_patchlevel
argument_list|,
name|ARCHNAME
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LOCAL_PATCH_COUNT
argument_list|)
if|if
condition|(
name|LOCAL_PATCH_COUNT
operator|>
literal|0
condition|)
name|PerlIO_printf
argument_list|(
name|PerlIO_stdout
argument_list|()
argument_list|,
literal|"\n(with %d registered patch%s, "
literal|"see perl -V for more detail)"
argument_list|,
operator|(
name|int
operator|)
name|LOCAL_PATCH_COUNT
argument_list|,
operator|(
name|LOCAL_PATCH_COUNT
operator|!=
literal|1
operator|)
condition|?
literal|"es"
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PerlIO_printf
argument_list|(
name|PerlIO_stdout
argument_list|()
argument_list|,
literal|"\n\nCopyright 1987-2001, Larry Wall\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MACOS_TRADITIONAL
name|PerlIO_printf
argument_list|(
name|PerlIO_stdout
argument_list|()
argument_list|,
literal|"\nMac OS port Copyright (c) 1991-2001, Matthias Neeracher\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MSDOS
name|PerlIO_printf
argument_list|(
name|PerlIO_stdout
argument_list|()
argument_list|,
literal|"\nMS-DOS port Copyright (c) 1989, 1990, Diomidis Spinellis\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DJGPP
name|PerlIO_printf
argument_list|(
name|PerlIO_stdout
argument_list|()
argument_list|,
literal|"djgpp v2 port (jpl5003c) by Hirofumi Watanabe, 1996\n"
literal|"djgpp v2 port (perl5004+) by Laszlo Molnar, 1997-1999\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OS2
name|PerlIO_printf
argument_list|(
name|PerlIO_stdout
argument_list|()
argument_list|,
literal|"\n\nOS/2 port Copyright (c) 1990, 1991, Raymond Chen, Kai Uwe Rommel\n"
literal|"Version 5 port Copyright (c) 1994-1999, Andreas Kaiser, Ilya Zakharevich\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|atarist
name|PerlIO_printf
argument_list|(
name|PerlIO_stdout
argument_list|()
argument_list|,
literal|"atariST series port, ++jrb  bammi@cadence.com\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__BEOS__
name|PerlIO_printf
argument_list|(
name|PerlIO_stdout
argument_list|()
argument_list|,
literal|"BeOS port Copyright Tom Spindler, 1997-1999\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MPE
name|PerlIO_printf
argument_list|(
name|PerlIO_stdout
argument_list|()
argument_list|,
literal|"MPE/iX port Copyright by Mark Klein and Mark Bixby, 1996-1999\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OEMVS
name|PerlIO_printf
argument_list|(
name|PerlIO_stdout
argument_list|()
argument_list|,
literal|"MVS (OS390) port by Mortice Kern Systems, 1997-1999\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__VOS__
name|PerlIO_printf
argument_list|(
name|PerlIO_stdout
argument_list|()
argument_list|,
literal|"Stratus VOS port by Paul_Green@stratus.com, 1997-1999\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__OPEN_VM
name|PerlIO_printf
argument_list|(
name|PerlIO_stdout
argument_list|()
argument_list|,
literal|"VM/ESA port by Neale Ferguson, 1998-1999\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|POSIX_BC
name|PerlIO_printf
argument_list|(
name|PerlIO_stdout
argument_list|()
argument_list|,
literal|"BS2000 (POSIX) port by Start Amadeus GmbH, 1998-1999\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__MINT__
name|PerlIO_printf
argument_list|(
name|PerlIO_stdout
argument_list|()
argument_list|,
literal|"MiNT port by Guido Flohr, 1997-1999\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EPOC
name|PerlIO_printf
argument_list|(
name|PerlIO_stdout
argument_list|()
argument_list|,
literal|"EPOC port by Olaf Flebbe, 1999-2000\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BINARY_BUILD_NOTICE
name|BINARY_BUILD_NOTICE
expr_stmt|;
endif|#
directive|endif
name|PerlIO_printf
argument_list|(
name|PerlIO_stdout
argument_list|()
argument_list|,
literal|"\n\ Perl may be copied only under the terms of either the Artistic License or the\n\ GNU General Public License, which may be found in the Perl 5 source kit.\n\n\ Complete documentation for Perl, including FAQ lists, should be found on\n\ this system using `man perl' or `perldoc perl'.  If you have access to the\n\ Internet, point your browser at http://www.perl.com/, the Perl Home Page.\n\n"
argument_list|)
expr_stmt|;
name|PerlProc_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'w'
case|:
if|if
condition|(
operator|!
operator|(
name|PL_dowarn
operator|&
name|G_WARN_ALL_MASK
operator|)
condition|)
name|PL_dowarn
operator||=
name|G_WARN_ON
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'W'
case|:
name|PL_dowarn
operator|=
name|G_WARN_ALL_ON
operator||
name|G_WARN_ON
expr_stmt|;
name|PL_compiling
operator|.
name|cop_warnings
operator|=
name|pWARN_ALL
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'X'
case|:
name|PL_dowarn
operator|=
name|G_WARN_ALL_OFF
expr_stmt|;
name|PL_compiling
operator|.
name|cop_warnings
operator|=
name|pWARN_NONE
expr_stmt|;
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
case|case
literal|'*'
case|:
case|case
literal|' '
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
comment|/* Additional switches on #! line. */
return|return
name|s
operator|+
literal|2
return|;
break|break;
case|case
literal|'-'
case|:
case|case
literal|0
case|:
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|PERL_STRICT_CR
argument_list|)
case|case
literal|'\r'
case|:
endif|#
directive|endif
case|case
literal|'\n'
case|:
case|case
literal|'\t'
case|:
break|break;
ifdef|#
directive|ifdef
name|ALTERNATE_SHEBANG
case|case
literal|'S'
case|:
comment|/* OS/2 needs -S on "extproc" line. */
break|break;
endif|#
directive|endif
case|case
literal|'P'
case|:
if|if
condition|(
name|PL_preprocess
condition|)
return|return
name|s
operator|+
literal|1
return|;
comment|/* FALL THROUGH */
default|default:
name|Perl_croak
argument_list|(
name|aTHX_
literal|"Can't emulate -%.1s on #! line"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|Nullch
return|;
block|}
comment|/* compliments of Tom Christiansen */
comment|/* unexec() can be found in the Gnu emacs distribution */
comment|/* Known to work with -DUNEXEC and using unexelf.c from GNU emacs-20.2 */
name|void
name|Perl_my_unexec
parameter_list|(
name|pTHX
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|UNEXEC
name|SV
modifier|*
name|prog
decl_stmt|;
name|SV
modifier|*
name|file
decl_stmt|;
name|int
name|status
init|=
literal|1
decl_stmt|;
specifier|extern
name|int
name|etext
decl_stmt|;
name|prog
operator|=
name|newSVpv
argument_list|(
name|BIN_EXP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|prog
argument_list|,
literal|"/perl"
argument_list|)
expr_stmt|;
name|file
operator|=
name|newSVpv
argument_list|(
name|PL_origfilename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|file
argument_list|,
literal|".perldump"
argument_list|)
expr_stmt|;
name|unexec
argument_list|(
name|SvPVX
argument_list|(
name|file
argument_list|)
argument_list|,
name|SvPVX
argument_list|(
name|prog
argument_list|)
argument_list|,
operator|&
name|etext
argument_list|,
name|sbrk
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* unexec prints msg to stderr in case of failure */
name|PerlProc_exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|VMS
include|#
directive|include
file|<lib$routines.h>
name|lib$signal
argument_list|(
name|SS$_DEBUG
argument_list|)
expr_stmt|;
comment|/* ssdef.h #included from vmsish.h */
else|#
directive|else
name|ABORT
argument_list|()
expr_stmt|;
comment|/* for use with undump */
endif|#
directive|endif
endif|#
directive|endif
block|}
comment|/* initialize curinterp */
name|STATIC
name|void
name|S_init_interp
parameter_list|(
name|pTHX
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PERL_OBJECT
comment|/* XXX kludge */
define|#
directive|define
name|I_REINIT
define|\
value|STMT_START {				\     PL_chopset		= " \n-";	\     PL_copline		= NOLINE;	\     PL_curcop		=&PL_compiling;\     PL_curcopdb		= NULL;		\     PL_dbargs		= 0;		\     PL_dumpindent	= 4;		\     PL_laststatval	= -1;		\     PL_laststype	= OP_STAT;	\     PL_maxscream	= -1;		\     PL_maxsysfd		= MAXSYSFD;	\     PL_statname		= Nullsv;	\     PL_tmps_floor	= -1;		\     PL_tmps_ix		= -1;		\     PL_op_mask		= NULL;		\     PL_laststatval	= -1;		\     PL_laststype	= OP_STAT;	\     PL_mess_sv		= Nullsv;	\     PL_splitstr		= " ";		\     PL_generation	= 100;		\     PL_exitlist		= NULL;		\     PL_exitlistlen	= 0;		\     PL_regindent	= 0;		\     PL_in_clean_objs	= FALSE;	\     PL_in_clean_all	= FALSE;	\     PL_profiledata	= NULL;		\     PL_rsfp		= Nullfp;	\     PL_rsfp_filters	= Nullav;	\     PL_dirty		= FALSE;	\   } STMT_END
name|I_REINIT
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|MULTIPLICITY
define|#
directive|define
name|PERLVAR
parameter_list|(
name|var
parameter_list|,
name|type
parameter_list|)
define|#
directive|define
name|PERLVARA
parameter_list|(
name|var
parameter_list|,
name|n
parameter_list|,
name|type
parameter_list|)
if|#
directive|if
name|defined
argument_list|(
name|PERL_IMPLICIT_CONTEXT
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|USE_THREADS
argument_list|)
define|#
directive|define
name|PERLVARI
parameter_list|(
name|var
parameter_list|,
name|type
parameter_list|,
name|init
parameter_list|)
value|PERL_GET_INTERP->var = init;
define|#
directive|define
name|PERLVARIC
parameter_list|(
name|var
parameter_list|,
name|type
parameter_list|,
name|init
parameter_list|)
value|PERL_GET_INTERP->var = init;
else|#
directive|else
comment|/* !USE_THREADS */
define|#
directive|define
name|PERLVARI
parameter_list|(
name|var
parameter_list|,
name|type
parameter_list|,
name|init
parameter_list|)
value|aTHX->var = init;
define|#
directive|define
name|PERLVARIC
parameter_list|(
name|var
parameter_list|,
name|type
parameter_list|,
name|init
parameter_list|)
value|aTHX->var = init;
endif|#
directive|endif
comment|/* USE_THREADS */
else|#
directive|else
define|#
directive|define
name|PERLVARI
parameter_list|(
name|var
parameter_list|,
name|type
parameter_list|,
name|init
parameter_list|)
value|PERL_GET_INTERP->var = init;
define|#
directive|define
name|PERLVARIC
parameter_list|(
name|var
parameter_list|,
name|type
parameter_list|,
name|init
parameter_list|)
value|PERL_GET_INTERP->var = init;
endif|#
directive|endif
include|#
directive|include
file|"intrpvar.h"
ifndef|#
directive|ifndef
name|USE_THREADS
include|#
directive|include
file|"thrdvar.h"
endif|#
directive|endif
undef|#
directive|undef
name|PERLVAR
undef|#
directive|undef
name|PERLVARA
undef|#
directive|undef
name|PERLVARI
undef|#
directive|undef
name|PERLVARIC
else|#
directive|else
define|#
directive|define
name|PERLVAR
parameter_list|(
name|var
parameter_list|,
name|type
parameter_list|)
define|#
directive|define
name|PERLVARA
parameter_list|(
name|var
parameter_list|,
name|n
parameter_list|,
name|type
parameter_list|)
define|#
directive|define
name|PERLVARI
parameter_list|(
name|var
parameter_list|,
name|type
parameter_list|,
name|init
parameter_list|)
value|PL_##var = init;
define|#
directive|define
name|PERLVARIC
parameter_list|(
name|var
parameter_list|,
name|type
parameter_list|,
name|init
parameter_list|)
value|PL_##var = init;
include|#
directive|include
file|"intrpvar.h"
ifndef|#
directive|ifndef
name|USE_THREADS
include|#
directive|include
file|"thrdvar.h"
endif|#
directive|endif
undef|#
directive|undef
name|PERLVAR
undef|#
directive|undef
name|PERLVARA
undef|#
directive|undef
name|PERLVARI
undef|#
directive|undef
name|PERLVARIC
endif|#
directive|endif
endif|#
directive|endif
block|}
name|STATIC
name|void
name|S_init_main_stash
parameter_list|(
name|pTHX
parameter_list|)
block|{
name|GV
modifier|*
name|gv
decl_stmt|;
comment|/* Note that strtab is a rather special HV.  Assumptions are made        about not iterating on it, and not adding tie magic to it.        It is properly deallocated in perl_destruct() */
name|PL_strtab
operator|=
name|newHV
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|MUTEX_INIT
argument_list|(
operator|&
name|PL_strtab_mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|HvSHAREKEYS_off
argument_list|(
name|PL_strtab
argument_list|)
expr_stmt|;
comment|/* mandatory */
name|hv_ksplit
argument_list|(
name|PL_strtab
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|PL_curstash
operator|=
name|PL_defstash
operator|=
name|newHV
argument_list|()
expr_stmt|;
name|PL_curstname
operator|=
name|newSVpvn
argument_list|(
literal|"main"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gv
operator|=
name|gv_fetchpv
argument_list|(
literal|"main::"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVHV
argument_list|)
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|GvHV
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
name|GvHV
argument_list|(
name|gv
argument_list|)
operator|=
operator|(
name|HV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|PL_defstash
argument_list|)
expr_stmt|;
name|SvREADONLY_on
argument_list|(
name|gv
argument_list|)
expr_stmt|;
name|HvNAME
argument_list|(
name|PL_defstash
argument_list|)
operator|=
name|savepv
argument_list|(
literal|"main"
argument_list|)
expr_stmt|;
name|PL_incgv
operator|=
name|gv_HVadd
argument_list|(
name|gv_AVadd
argument_list|(
name|gv_fetchpv
argument_list|(
literal|"INC"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVAV
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|GvMULTI_on
argument_list|(
name|PL_incgv
argument_list|)
expr_stmt|;
name|PL_hintgv
operator|=
name|gv_fetchpv
argument_list|(
literal|"\010"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
comment|/* ^H */
name|GvMULTI_on
argument_list|(
name|PL_hintgv
argument_list|)
expr_stmt|;
name|PL_defgv
operator|=
name|gv_fetchpv
argument_list|(
literal|"_"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PVAV
argument_list|)
expr_stmt|;
name|PL_errgv
operator|=
name|gv_HVadd
argument_list|(
name|gv_fetchpv
argument_list|(
literal|"@"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
argument_list|)
expr_stmt|;
name|GvMULTI_on
argument_list|(
name|PL_errgv
argument_list|)
expr_stmt|;
name|PL_replgv
operator|=
name|gv_fetchpv
argument_list|(
literal|"\022"
argument_list|,
name|TRUE
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
comment|/* ^R */
name|GvMULTI_on
argument_list|(
name|PL_replgv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Perl_form
argument_list|(
name|aTHX_
literal|"%240s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Preallocate temp - for immediate signals. */
name|sv_grow
argument_list|(
name|ERRSV
argument_list|,
literal|240
argument_list|)
expr_stmt|;
comment|/* Preallocate - for immediate signals. */
name|sv_setpvn
argument_list|(
name|ERRSV
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PL_curstash
operator|=
name|PL_defstash
expr_stmt|;
name|CopSTASH_set
argument_list|(
operator|&
name|PL_compiling
argument_list|,
name|PL_defstash
argument_list|)
expr_stmt|;
name|PL_debstash
operator|=
name|GvHV
argument_list|(
name|gv_fetchpv
argument_list|(
literal|"DB::"
argument_list|,
name|GV_ADDMULTI
argument_list|,
name|SVt_PVHV
argument_list|)
argument_list|)
expr_stmt|;
name|PL_globalstash
operator|=
name|GvHV
argument_list|(
name|gv_fetchpv
argument_list|(
literal|"CORE::GLOBAL::"
argument_list|,
name|GV_ADDMULTI
argument_list|,
name|SVt_PVHV
argument_list|)
argument_list|)
expr_stmt|;
name|PL_nullstash
operator|=
name|GvHV
argument_list|(
name|gv_fetchpv
argument_list|(
literal|"<none>::"
argument_list|,
name|GV_ADDMULTI
argument_list|,
name|SVt_PVHV
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We must init $/ before switches are processed. */
name|sv_setpvn
argument_list|(
name|get_sv
argument_list|(
literal|"/"
argument_list|,
name|TRUE
argument_list|)
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|STATIC
name|void
name|S_open_script
parameter_list|(
name|pTHX_
name|char
modifier|*
name|scriptname
parameter_list|,
name|bool
name|dosearch
parameter_list|,
name|SV
modifier|*
name|sv
parameter_list|,
name|int
modifier|*
name|fdscript
parameter_list|)
block|{
operator|*
name|fdscript
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|PL_e_script
condition|)
block|{
name|PL_origfilename
operator|=
name|savepv
argument_list|(
literal|"-e"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* if find_script() returns, it returns a malloc()-ed value */
name|PL_origfilename
operator|=
name|scriptname
operator|=
name|find_script
argument_list|(
name|scriptname
argument_list|,
name|dosearch
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
name|scriptname
argument_list|,
literal|"/dev/fd/"
argument_list|,
literal|8
argument_list|)
operator|&&
name|isDIGIT
argument_list|(
name|scriptname
index|[
literal|8
index|]
argument_list|)
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|scriptname
operator|+
literal|8
decl_stmt|;
operator|*
name|fdscript
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
block|{
name|scriptname
operator|=
name|savepv
argument_list|(
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|PL_origfilename
argument_list|)
expr_stmt|;
name|PL_origfilename
operator|=
name|scriptname
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|USE_ITHREADS
name|Safefree
argument_list|(
name|CopFILE
argument_list|(
name|PL_curcop
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|SvREFCNT_dec
argument_list|(
name|CopFILEGV
argument_list|(
name|PL_curcop
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CopFILE_set
argument_list|(
name|PL_curcop
argument_list|,
name|PL_origfilename
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|PL_origfilename
argument_list|,
literal|"-"
argument_list|)
condition|)
name|scriptname
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|*
name|fdscript
operator|>=
literal|0
condition|)
block|{
name|PL_rsfp
operator|=
name|PerlIO_fdopen
argument_list|(
operator|*
name|fdscript
argument_list|,
name|PERL_SCRIPT_MODE
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAS_FCNTL
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_SETFD
argument_list|)
if|if
condition|(
name|PL_rsfp
condition|)
name|fcntl
argument_list|(
name|PerlIO_fileno
argument_list|(
name|PL_rsfp
argument_list|)
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* ensure close-on-exec */
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|PL_preprocess
condition|)
block|{
name|char
modifier|*
name|cpp_cfg
init|=
name|CPPSTDIN
decl_stmt|;
name|SV
modifier|*
name|cpp
init|=
name|newSVpvn
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|SV
modifier|*
name|cmd
init|=
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|cpp_cfg
argument_list|,
literal|"cppstdin"
argument_list|)
condition|)
name|Perl_sv_catpvf
argument_list|(
argument|aTHX_ cpp
argument_list|,
literal|"%s/"
argument_list|,
argument|BIN_EXP
argument_list|)
empty_stmt|;
name|sv_catpv
argument_list|(
name|cpp
argument_list|,
name|cpp_cfg
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
literal|"-I"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|sv
argument_list|,
name|PRIVLIB_EXP
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
name|Perl_sv_setpvf
argument_list|(
argument|aTHX_ cmd
argument_list|,
literal|"\ sed %s -e \"/^[^#]/b\" \  -e \"/^#[ 	]*include[ 	]/b\" \  -e \"/^#[ 	]*define[ 	]/b\" \  -e \"/^#[ 	]*if[ 	]/b\" \  -e \"/^#[ 	]*ifdef[ 	]/b\" \  -e \"/^#[ 	]*ifndef[ 	]/b\" \  -e \"/^#[ 	]*else/b\" \  -e \"/^#[ 	]*elif[ 	]/b\" \  -e \"/^#[ 	]*undef[ 	]/b\" \  -e \"/^#[ 	]*endif/b\" \  -e \"s/^#.*//\" \  %s | %"
argument|SVf
literal|" -C %"
argument|SVf
literal|" %s"
argument_list|,
argument|(PL_doextract ?
literal|"-e \"1,/^#/d\n\""
argument|:
literal|""
argument|)
argument_list|,
else|#
directive|else
ifdef|#
directive|ifdef
name|__OPEN_VM
argument|Perl_sv_setpvf(aTHX_ cmd,
literal|"\ %s %s -e '/^[^#]/b' \  -e '/^#[ 	]*include[ 	]/b' \  -e '/^#[ 	]*define[ 	]/b' \  -e '/^#[ 	]*if[ 	]/b' \  -e '/^#[ 	]*ifdef[ 	]/b' \  -e '/^#[ 	]*ifndef[ 	]/b' \  -e '/^#[ 	]*else/b' \  -e '/^#[ 	]*elif[ 	]/b' \  -e '/^#[ 	]*undef[ 	]/b' \  -e '/^#[ 	]*endif/b' \  -e 's/^[ 	]*#.*//' \  %s | %"
argument|SVf
literal|" %"
argument|SVf
literal|" %s"
argument|,
else|#
directive|else
argument|Perl_sv_setpvf(aTHX_ cmd,
literal|"\ %s %s -e '/^[^#]/b' \  -e '/^#[ 	]*include[ 	]/b' \  -e '/^#[ 	]*define[ 	]/b' \  -e '/^#[ 	]*if[ 	]/b' \  -e '/^#[ 	]*ifdef[ 	]/b' \  -e '/^#[ 	]*ifndef[ 	]/b' \  -e '/^#[ 	]*else/b' \  -e '/^#[ 	]*elif[ 	]/b' \  -e '/^#[ 	]*undef[ 	]/b' \  -e '/^#[ 	]*endif/b' \  -e 's/^[ 	]*#.*//' \  %s | %"
argument|SVf
literal|" -C %"
argument|SVf
literal|" %s"
argument|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOC_SED
argument|LOC_SED,
else|#
directive|else
literal|"sed"
argument|,
endif|#
directive|endif
argument|(PL_doextract ?
literal|"-e '1,/^#/d\n'"
argument|:
literal|""
argument|),
endif|#
directive|endif
argument|scriptname, cpp, sv, CPPMINUS); 	PL_doextract = FALSE;
ifdef|#
directive|ifdef
name|IAMSUID
comment|/* actually, this is caught earlier */
argument|if (PL_euid != PL_uid&& !PL_euid) {
comment|/* if running suidperl */
ifdef|#
directive|ifdef
name|HAS_SETEUID
argument|(void)seteuid(PL_uid);
comment|/* musn't stay setuid root */
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETREUID
argument|(void)setreuid((Uid_t)-
literal|1
argument|, PL_uid);
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETRESUID
argument|(void)setresuid((Uid_t)-
literal|1
argument|, PL_uid, (Uid_t)-
literal|1
argument|);
else|#
directive|else
argument|PerlProc_setuid(PL_uid);
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
argument|if (PerlProc_geteuid() != PL_uid) 		Perl_croak(aTHX_
literal|"Can't do seteuid!\n"
argument|); 	}
endif|#
directive|endif
comment|/* IAMSUID */
argument|PL_rsfp = PerlProc_popen(SvPVX(cmd),
literal|"r"
argument|); 	SvREFCNT_dec(cmd); 	SvREFCNT_dec(cpp);     }     else if (!*scriptname) { 	forbid_setid(
literal|"program input from stdin"
argument|); 	PL_rsfp = PerlIO_stdin();     }     else { 	PL_rsfp = PerlIO_open(scriptname,PERL_SCRIPT_MODE);
if|#
directive|if
name|defined
argument_list|(
name|HAS_FCNTL
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_SETFD
argument_list|)
argument|if (PL_rsfp) 	    fcntl(PerlIO_fileno(PL_rsfp),F_SETFD,
literal|1
argument|);
comment|/* ensure close-on-exec */
endif|#
directive|endif
argument|}     if (!PL_rsfp) {
ifdef|#
directive|ifdef
name|DOSUID
ifndef|#
directive|ifndef
name|IAMSUID
comment|/* in case script is not readable before setuid */
argument|if (PL_euid&& 	    PerlLIO_stat(CopFILE(PL_curcop),&PL_statbuf)>=
literal|0
argument|&& 	    PL_statbuf.st_mode& (S_ISUID|S_ISGID)) 	{
comment|/* try again */
argument|PerlProc_execv(Perl_form(aTHX_
literal|"%s/sperl"
argument|PERL_FS_VER_FMT, BIN_EXP, 				     (int)PERL_REVISION, (int)PERL_VERSION, 				     (int)PERL_SUBVERSION), PL_origargv); 	    Perl_croak(aTHX_
literal|"Can't do setuid; ensure that the setuid bit is set on suidperl\n"
argument|); 	}
endif|#
directive|endif
endif|#
directive|endif
argument|Perl_croak(aTHX_
literal|"Can't open perl script \"%s\": %s\n"
argument|, 		   CopFILE(PL_curcop), Strerror(errno));     } }
comment|/* Mention  * I_SYSSTATVFS	HAS_FSTATVFS  * I_SYSMOUNT  * I_STATFS	HAS_FSTATFS	HAS_GETFSSTAT  * I_MNTENT	HAS_GETMNTENT	HAS_HASMNTOPT  * here so that metaconfig picks them up. */
ifdef|#
directive|ifdef
name|IAMSUID
argument|STATIC int S_fd_on_nosuid_fs(pTHX_ int fd) {     int check_okay =
literal|0
argument|;
comment|/* able to do all the required sys/libcalls */
argument|int on_nosuid  =
literal|0
argument|;
comment|/* the fd is on a nosuid fs */
comment|/*  * Preferred order: fstatvfs(), fstatfs(), ustat()+getmnt(), getmntent().  * fstatvfs() is UNIX98.  * fstatfs() is 4.3 BSD.  * ustat()+getmnt() is pre-4.3 BSD.  * getmntent() is O(number-of-mounted-filesystems) and can hang on  * an irrelevant filesystem while trying to reach the right one.  */
undef|#
directive|undef
name|FD_ON_NOSUID_CHECK_OKAY
comment|/* found the syscalls to do the check? */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FD_ON_NOSUID_CHECK_OKAY
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAS_FSTATVFS
argument_list|)
define|#
directive|define
name|FD_ON_NOSUID_CHECK_OKAY
argument|struct statvfs stfs;      check_okay = fstatvfs(fd,&stfs) ==
literal|0
argument|;     on_nosuid  = check_okay&& (stfs.f_flag& ST_NOSUID);
endif|#
directive|endif
comment|/* fstatvfs */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FD_ON_NOSUID_CHECK_OKAY
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|PERL_MOUNT_NOSUID
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAS_FSTATFS
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAS_STRUCT_STATFS
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAS_STRUCT_STATFS_F_FLAGS
argument_list|)
define|#
directive|define
name|FD_ON_NOSUID_CHECK_OKAY
argument|struct statfs  stfs;      check_okay = fstatfs(fd,&stfs)  ==
literal|0
argument|;     on_nosuid  = check_okay&& (stfs.f_flags& PERL_MOUNT_NOSUID);
endif|#
directive|endif
comment|/* fstatfs */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FD_ON_NOSUID_CHECK_OKAY
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|PERL_MOUNT_NOSUID
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAS_FSTAT
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAS_USTAT
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAS_GETMNT
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAS_STRUCT_FS_DATA
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|NOSTAT_ONE
argument_list|)
define|#
directive|define
name|FD_ON_NOSUID_CHECK_OKAY
argument|struct stat fdst;      if (fstat(fd,&fdst) ==
literal|0
argument|) {         struct ustat us;         if (ustat(fdst.st_dev,&us) ==
literal|0
argument|) {             struct fs_data fsd;
comment|/* NOSTAT_ONE here because we're not examining fields which              * vary between that case and STAT_ONE. */
argument|if (getmnt((int*)
literal|0
argument|,&fsd, (int)
literal|0
argument|, NOSTAT_ONE, us.f_fname) ==
literal|0
argument|) {                 size_t cmplen = sizeof(us.f_fname);                 if (sizeof(fsd.fd_req.path)< cmplen)                     cmplen = sizeof(fsd.fd_req.path);                 if (strnEQ(fsd.fd_req.path, us.f_fname, cmplen)&&                     fdst.st_dev == fsd.fd_req.dev) {                         check_okay =
literal|1
argument|;                         on_nosuid = fsd.fd_req.flags& PERL_MOUNT_NOSUID;                     }                 }             }         }     }
endif|#
directive|endif
comment|/* fstat+ustat+getmnt */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FD_ON_NOSUID_CHECK_OKAY
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAS_GETMNTENT
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|HAS_HASMNTOPT
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|MNTOPT_NOSUID
argument_list|)
define|#
directive|define
name|FD_ON_NOSUID_CHECK_OKAY
argument|FILE                *mtab = fopen(
literal|"/etc/mtab"
argument|,
literal|"r"
argument|);     struct mntent       *entry;     struct stat         stb, fsb;      if (mtab&& (fstat(fd,&stb) ==
literal|0
argument|)) {         while (entry = getmntent(mtab)) {             if (stat(entry->mnt_dir,&fsb) ==
literal|0
argument|&& fsb.st_dev == stb.st_dev)             {
comment|/* found the filesystem */
argument|check_okay =
literal|1
argument|;                 if (hasmntopt(entry, MNTOPT_NOSUID))                     on_nosuid =
literal|1
argument|;                 break;             }
comment|/* A single fs may well fail its stat(). */
argument|}     }     if (mtab)         fclose(mtab);
endif|#
directive|endif
comment|/* getmntent+hasmntopt */
argument|if (!check_okay)  	Perl_croak(aTHX_
literal|"Can't check filesystem of script \"%s\" for nosuid"
argument|, PL_origfilename);     return on_nosuid; }
endif|#
directive|endif
comment|/* IAMSUID */
argument|STATIC void S_validate_suid(pTHX_ char *validarg, char *scriptname, int fdscript) {
ifdef|#
directive|ifdef
name|IAMSUID
argument|int which;
endif|#
directive|endif
comment|/* do we need to emulate setuid on scripts? */
comment|/* This code is for those BSD systems that have setuid #! scripts disabled      * in the kernel because of a security problem.  Merely defining DOSUID      * in perl will not fix that problem, but if you have disabled setuid      * scripts in the kernel, this will attempt to emulate setuid and setgid      * on scripts that have those now-otherwise-useless bits set.  The setuid      * root version must be called suidperl or sperlN.NNN.  If regular perl      * discovers that it has opened a setuid script, it calls suidperl with      * the same argv that it had.  If suidperl finds that the script it has      * just opened is NOT setuid root, it sets the effective uid back to the      * uid.  We don't just make perl setuid root because that loses the      * effective uid we had before invoking perl, if it was different from the      * uid.      *      * DOSUID must be defined in both perl and suidperl, and IAMSUID must      * be defined in suidperl only.  suidperl must be setuid root.  The      * Configure script will set this up for you if you want it.      */
ifdef|#
directive|ifdef
name|DOSUID
argument|char *s, *s2;      if (PerlLIO_fstat(PerlIO_fileno(PL_rsfp),&PL_statbuf)<
literal|0
argument|)
comment|/* normal stat is insecure */
argument|Perl_croak(aTHX_
literal|"Can't stat script \"%s\""
argument|,PL_origfilename);     if (fdscript<
literal|0
argument|&& PL_statbuf.st_mode& (S_ISUID|S_ISGID)) { 	I32 len; 	STRLEN n_a;
ifdef|#
directive|ifdef
name|IAMSUID
ifndef|#
directive|ifndef
name|HAS_SETREUID
comment|/* On this access check to make sure the directories are readable, 	 * there is actually a small window that the user could use to make 	 * filename point to an accessible directory.  So there is a faint 	 * chance that someone could execute a setuid script down in a 	 * non-accessible directory.  I don't know what to do about that. 	 * But I don't think it's too important.  The manual lies when 	 * it says access() is useful in setuid programs. 	 */
argument|if (PerlLIO_access(CopFILE(PL_curcop),
literal|1
argument|))
comment|/*double check*/
argument|Perl_croak(aTHX_
literal|"Permission denied"
argument|);
else|#
directive|else
comment|/* If we can swap euid and uid, then we can determine access rights 	 * with a simple stat of the file, and then compare device and 	 * inode to make sure we did stat() on the same file we opened. 	 * Then we just have to make sure he or she can execute it. 	 */
argument|{ 	    struct stat tmpstatbuf;  	    if (
ifdef|#
directive|ifdef
name|HAS_SETREUID
argument|setreuid(PL_euid,PL_uid)<
literal|0
else|#
directive|else
if|#
directive|if
name|HAS_SETRESUID
argument|setresuid(PL_euid,PL_uid,(Uid_t)-
literal|1
argument|)<
literal|0
endif|#
directive|endif
endif|#
directive|endif
argument||| PerlProc_getuid() != PL_euid || PerlProc_geteuid() != PL_uid) 		Perl_croak(aTHX_
literal|"Can't swap uid and euid"
argument|);
comment|/* really paranoid */
argument|if (PerlLIO_stat(CopFILE(PL_curcop),&tmpstatbuf)<
literal|0
argument|) 		Perl_croak(aTHX_
literal|"Permission denied"
argument|);
comment|/* testing full pathname here */
if|#
directive|if
name|defined
argument_list|(
name|IAMSUID
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_NOSUID_CHECK
argument_list|)
argument|if (fd_on_nosuid_fs(PerlIO_fileno(PL_rsfp))) 		Perl_croak(aTHX_
literal|"Permission denied"
argument|);
endif|#
directive|endif
argument|if (tmpstatbuf.st_dev != PL_statbuf.st_dev || 		tmpstatbuf.st_ino != PL_statbuf.st_ino) { 		(void)PerlIO_close(PL_rsfp); 		Perl_croak(aTHX_
literal|"Permission denied\n"
argument|); 	    } 	    if (
ifdef|#
directive|ifdef
name|HAS_SETREUID
argument|setreuid(PL_uid,PL_euid)<
literal|0
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|HAS_SETRESUID
argument_list|)
argument|setresuid(PL_uid,PL_euid,(Uid_t)-
literal|1
argument|)<
literal|0
endif|#
directive|endif
endif|#
directive|endif
argument||| PerlProc_getuid() != PL_uid || PerlProc_geteuid() != PL_euid) 		Perl_croak(aTHX_
literal|"Can't reswap uid and euid"
argument|); 	    if (!cando(S_IXUSR,FALSE,&PL_statbuf))
comment|/* can real uid exec? */
argument|Perl_croak(aTHX_
literal|"Permission denied\n"
argument|); 	}
endif|#
directive|endif
comment|/* HAS_SETREUID */
endif|#
directive|endif
comment|/* IAMSUID */
argument|if (!S_ISREG(PL_statbuf.st_mode)) 	    Perl_croak(aTHX_
literal|"Permission denied"
argument|); 	if (PL_statbuf.st_mode& S_IWOTH) 	    Perl_croak(aTHX_
literal|"Setuid/gid script is writable by world"
argument|); 	PL_doswitches = FALSE;
comment|/* -s is insecure in suid */
argument|CopLINE_inc(PL_curcop); 	if (sv_gets(PL_linestr, PL_rsfp,
literal|0
argument|) == Nullch || 	  strnNE(SvPV(PL_linestr,n_a),
literal|"#!"
argument|,
literal|2
argument|) )
comment|/* required even on Sys V */
argument|Perl_croak(aTHX_
literal|"No #! line"
argument|); 	s = SvPV(PL_linestr,n_a)+
literal|2
argument|; 	if (*s ==
literal|' '
argument|) s++; 	while (!isSPACE(*s)) s++; 	for (s2 = s;  (s2> SvPV(PL_linestr,n_a)+
literal|2
argument|&& 		       (isDIGIT(s2[-
literal|1
argument|]) || strchr(
literal|"._-"
argument|, s2[-
literal|1
argument|])));  s2--) ; 	if (strnNE(s2-
literal|4
argument|,
literal|"perl"
argument|,
literal|4
argument|)&& strnNE(s-
literal|9
argument|,
literal|"perl"
argument|,
literal|4
argument|))
comment|/* sanity check */
argument|Perl_croak(aTHX_
literal|"Not a perl script"
argument|); 	while (*s ==
literal|' '
argument||| *s ==
literal|'\t'
argument|) s++;
comment|/* 	 * #! arg must be what we saw above.  They can invoke it by 	 * mentioning suidperl explicitly, but they may not add any strange 	 * arguments beyond what #! says if they do invoke suidperl that way. 	 */
argument|len = strlen(validarg); 	if (strEQ(validarg,
literal|" PHOOEY "
argument|) || 	    strnNE(s,validarg,len) || !isSPACE(s[len])) 	    Perl_croak(aTHX_
literal|"Args must match #! line"
argument|);
ifndef|#
directive|ifndef
name|IAMSUID
argument|if (PL_euid != PL_uid&& (PL_statbuf.st_mode& S_ISUID)&& 	    PL_euid == PL_statbuf.st_uid) 	    if (!PL_do_undump) 		Perl_croak(aTHX_
literal|"YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET!\n\ FIX YOUR KERNEL, PUT A C WRAPPER AROUND THIS SCRIPT, OR USE -u AND UNDUMP!\n"
argument|);
endif|#
directive|endif
comment|/* IAMSUID */
argument|if (PL_euid) {
comment|/* oops, we're not the setuid root perl */
argument|(void)PerlIO_close(PL_rsfp);
ifndef|#
directive|ifndef
name|IAMSUID
comment|/* try again */
argument|PerlProc_execv(Perl_form(aTHX_
literal|"%s/sperl"
argument|PERL_FS_VER_FMT, BIN_EXP, 				     (int)PERL_REVISION, (int)PERL_VERSION, 				     (int)PERL_SUBVERSION), PL_origargv);
endif|#
directive|endif
argument|Perl_croak(aTHX_
literal|"Can't do setuid; ensure that the setuid bit is set on suidperl\n"
argument|); 	}  	if (PL_statbuf.st_mode& S_ISGID&& PL_statbuf.st_gid != PL_egid) {
ifdef|#
directive|ifdef
name|HAS_SETEGID
argument|(void)setegid(PL_statbuf.st_gid);
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETREGID
argument|(void)setregid((Gid_t)-
literal|1
argument|,PL_statbuf.st_gid);
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETRESGID
argument|(void)setresgid((Gid_t)-
literal|1
argument|,PL_statbuf.st_gid,(Gid_t)-
literal|1
argument|);
else|#
directive|else
argument|PerlProc_setgid(PL_statbuf.st_gid);
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
argument|if (PerlProc_getegid() != PL_statbuf.st_gid) 		Perl_croak(aTHX_
literal|"Can't do setegid!\n"
argument|); 	} 	if (PL_statbuf.st_mode& S_ISUID) { 	    if (PL_statbuf.st_uid != PL_euid)
ifdef|#
directive|ifdef
name|HAS_SETEUID
argument|(void)seteuid(PL_statbuf.st_uid);
comment|/* all that for this */
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETREUID
argument|(void)setreuid((Uid_t)-
literal|1
argument|,PL_statbuf.st_uid);
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETRESUID
argument|(void)setresuid((Uid_t)-
literal|1
argument|,PL_statbuf.st_uid,(Uid_t)-
literal|1
argument|);
else|#
directive|else
argument|PerlProc_setuid(PL_statbuf.st_uid);
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
argument|if (PerlProc_geteuid() != PL_statbuf.st_uid) 		Perl_croak(aTHX_
literal|"Can't do seteuid!\n"
argument|); 	} 	else if (PL_uid) {
comment|/* oops, mustn't run as root */
ifdef|#
directive|ifdef
name|HAS_SETEUID
argument|(void)seteuid((Uid_t)PL_uid);
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETREUID
argument|(void)setreuid((Uid_t)-
literal|1
argument|,(Uid_t)PL_uid);
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETRESUID
argument|(void)setresuid((Uid_t)-
literal|1
argument|,(Uid_t)PL_uid,(Uid_t)-
literal|1
argument|);
else|#
directive|else
argument|PerlProc_setuid((Uid_t)PL_uid);
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
argument|if (PerlProc_geteuid() != PL_uid) 		Perl_croak(aTHX_
literal|"Can't do seteuid!\n"
argument|); 	} 	init_ids(); 	if (!cando(S_IXUSR,TRUE,&PL_statbuf)) 	    Perl_croak(aTHX_
literal|"Permission denied\n"
argument|);
comment|/* they can't do this */
argument|}
ifdef|#
directive|ifdef
name|IAMSUID
argument|else if (PL_preprocess) 	Perl_croak(aTHX_
literal|"-P not allowed for setuid/setgid script\n"
argument|);     else if (fdscript>=
literal|0
argument|) 	Perl_croak(aTHX_
literal|"fd script not allowed in suidperl\n"
argument|);     else 	Perl_croak(aTHX_
literal|"Script is not setuid/setgid in suidperl\n"
argument|);
comment|/* We absolutely must clear out any saved ids here, so we */
comment|/* exec the real perl, substituting fd script for scriptname. */
comment|/* (We pass script name as "subdir" of fd, which perl will grok.) */
argument|PerlIO_rewind(PL_rsfp);     PerlLIO_lseek(PerlIO_fileno(PL_rsfp),(Off_t)
literal|0
argument|,
literal|0
argument|);
comment|/* just in case rewind didn't */
argument|for (which =
literal|1
argument|; PL_origargv[which]&& PL_origargv[which] != scriptname; which++) ;     if (!PL_origargv[which]) 	Perl_croak(aTHX_
literal|"Permission denied"
argument|);     PL_origargv[which] = savepv(Perl_form(aTHX_
literal|"/dev/fd/%d/%s"
argument|, 				  PerlIO_fileno(PL_rsfp), PL_origargv[which]));
if|#
directive|if
name|defined
argument_list|(
name|HAS_FCNTL
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_SETFD
argument_list|)
argument|fcntl(PerlIO_fileno(PL_rsfp),F_SETFD,
literal|0
argument|);
comment|/* ensure no close-on-exec */
endif|#
directive|endif
argument|PerlProc_execv(Perl_form(aTHX_
literal|"%s/perl"
argument|PERL_FS_VER_FMT, BIN_EXP, 			     (int)PERL_REVISION, (int)PERL_VERSION, 			     (int)PERL_SUBVERSION), PL_origargv);
comment|/* try again */
argument|Perl_croak(aTHX_
literal|"Can't do setuid; ensure that the setuid bit is set on suidperl\n"
argument|);
endif|#
directive|endif
comment|/* IAMSUID */
else|#
directive|else
comment|/* !DOSUID */
argument|if (PL_euid != PL_uid || PL_egid != PL_gid) {
comment|/* (suidperl doesn't exist, in fact) */
ifndef|#
directive|ifndef
name|SETUID_SCRIPTS_ARE_SECURE_NOW
argument|PerlLIO_fstat(PerlIO_fileno(PL_rsfp),&PL_statbuf);
comment|/* may be either wrapped or real suid */
argument|if ((PL_euid != PL_uid&& PL_euid == PL_statbuf.st_uid&& PL_statbuf.st_mode& S_ISUID) 	    || 	    (PL_egid != PL_gid&& PL_egid == PL_statbuf.st_gid&& PL_statbuf.st_mode& S_ISGID) 	   ) 	    if (!PL_do_undump) 		Perl_croak(aTHX_
literal|"YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET!\n\ FIX YOUR KERNEL, PUT A C WRAPPER AROUND THIS SCRIPT, OR USE -u AND UNDUMP!\n"
argument|);
endif|#
directive|endif
comment|/* SETUID_SCRIPTS_ARE_SECURE_NOW */
comment|/* not set-id, must be wrapped */
argument|}
endif|#
directive|endif
comment|/* DOSUID */
argument|}  STATIC void S_find_beginning(pTHX) {     register char *s, *s2;
comment|/* skip forward in input to the real script? */
argument|forbid_setid(
literal|"-x"
argument|);
ifdef|#
directive|ifdef
name|MACOS_TRADITIONAL
comment|/* Since the Mac OS does not honor #! arguments for us, we do it ourselves */
argument|while (PL_doextract || gMacPerl_AlwaysExtract) { 	if ((s = sv_gets(PL_linestr, PL_rsfp,
literal|0
argument|)) == Nullch) { 	    if (!gMacPerl_AlwaysExtract) 		Perl_croak(aTHX_
literal|"No Perl script found in input\n"
argument|); 		 	    if (PL_doextract)
comment|/* require explicit override ? */
argument|if (!OverrideExtract(PL_origfilename)) 		    Perl_croak(aTHX_
literal|"User aborted script\n"
argument|); 		else 		    PL_doextract = FALSE;
comment|/* Pater peccavi, file does not have #! */
argument|PerlIO_rewind(PL_rsfp); 	     	    break; 	}
else|#
directive|else
argument|while (PL_doextract) { 	if ((s = sv_gets(PL_linestr, PL_rsfp,
literal|0
argument|)) == Nullch) 	    Perl_croak(aTHX_
literal|"No Perl script found in input\n"
argument|);
endif|#
directive|endif
argument|if (*s ==
literal|'#'
argument|&& s[
literal|1
argument|] ==
literal|'!'
argument|&& (s = instr(s,
literal|"perl"
argument|))) { 	    PerlIO_ungetc(PL_rsfp,
literal|'\n'
argument|);
comment|/* to keep line count right */
argument|PL_doextract = FALSE; 	    while (*s&& !(isSPACE (*s) || *s ==
literal|'#'
argument|)) s++; 	    s2 = s; 	    while (*s ==
literal|' '
argument||| *s ==
literal|'\t'
argument|) s++; 	    if (*s++ ==
literal|'-'
argument|) { 		while (isDIGIT(s2[-
literal|1
argument|]) || strchr(
literal|"-._"
argument|, s2[-
literal|1
argument|])) s2--; 		if (strnEQ(s2-
literal|4
argument|,
literal|"perl"
argument|,
literal|4
argument|))
comment|/*SUPPRESS 530*/
argument|while ((s = moreswitches(s))) 			; 	    } 	}     } }   STATIC void S_init_ids(pTHX) {     PL_uid = PerlProc_getuid();     PL_euid = PerlProc_geteuid();     PL_gid = PerlProc_getgid();     PL_egid = PerlProc_getegid();
ifdef|#
directive|ifdef
name|VMS
argument|PL_uid |= PL_gid<<
literal|16
argument|;     PL_euid |= PL_egid<<
literal|16
argument|;
endif|#
directive|endif
argument|PL_tainting |= (PL_uid&& (PL_euid != PL_uid || PL_egid != PL_gid)); }  STATIC void S_forbid_setid(pTHX_ char *s) {     if (PL_euid != PL_uid)         Perl_croak(aTHX_
literal|"No %s allowed while running setuid"
argument|, s);     if (PL_egid != PL_gid)         Perl_croak(aTHX_
literal|"No %s allowed while running setgid"
argument|, s); }  void Perl_init_debugger(pTHX) {     HV *ostash = PL_curstash;      PL_curstash = PL_debstash;     PL_dbargs = GvAV(gv_AVadd((gv_fetchpv(
literal|"args"
argument|, GV_ADDMULTI, SVt_PVAV))));     AvREAL_off(PL_dbargs);     PL_DBgv = gv_fetchpv(
literal|"DB"
argument|, GV_ADDMULTI, SVt_PVGV);     PL_DBline = gv_fetchpv(
literal|"dbline"
argument|, GV_ADDMULTI, SVt_PVAV);     PL_DBsub = gv_HVadd(gv_fetchpv(
literal|"sub"
argument|, GV_ADDMULTI, SVt_PVHV));     sv_upgrade(GvSV(PL_DBsub), SVt_IV);
comment|/* IVX accessed if PERLDB_SUB_NN */
argument|PL_DBsingle = GvSV((gv_fetchpv(
literal|"single"
argument|, GV_ADDMULTI, SVt_PV)));     sv_setiv(PL_DBsingle,
literal|0
argument|);      PL_DBtrace = GvSV((gv_fetchpv(
literal|"trace"
argument|, GV_ADDMULTI, SVt_PV)));     sv_setiv(PL_DBtrace,
literal|0
argument|);      PL_DBsignal = GvSV((gv_fetchpv(
literal|"signal"
argument|, GV_ADDMULTI, SVt_PV)));     sv_setiv(PL_DBsignal,
literal|0
argument|);      PL_curstash = ostash; }
ifndef|#
directive|ifndef
name|STRESS_REALLOC
define|#
directive|define
name|REASONABLE
parameter_list|(
name|size
parameter_list|)
value|(size)
else|#
directive|else
define|#
directive|define
name|REASONABLE
parameter_list|(
name|size
parameter_list|)
value|(1)
comment|/* unreasonable */
endif|#
directive|endif
argument|void Perl_init_stacks(pTHX) {
comment|/* start with 128-item stack and 8K cxstack */
argument|PL_curstackinfo = new_stackinfo(REASONABLE(
literal|128
argument|), 				 REASONABLE(
literal|8192
argument|/sizeof(PERL_CONTEXT) -
literal|1
argument|));     PL_curstackinfo->si_type = PERLSI_MAIN;     PL_curstack = PL_curstackinfo->si_stack;     PL_mainstack = PL_curstack;
comment|/* remember in case we switch stacks */
argument|PL_stack_base = AvARRAY(PL_curstack);     PL_stack_sp = PL_stack_base;     PL_stack_max = PL_stack_base + AvMAX(PL_curstack);      New(
literal|50
argument|,PL_tmps_stack,REASONABLE(
literal|128
argument|),SV*);     PL_tmps_floor = -
literal|1
argument|;     PL_tmps_ix = -
literal|1
argument|;     PL_tmps_max = REASONABLE(
literal|128
argument|);      New(
literal|54
argument|,PL_markstack,REASONABLE(
literal|32
argument|),I32);     PL_markstack_ptr = PL_markstack;     PL_markstack_max = PL_markstack + REASONABLE(
literal|32
argument|);      SET_MARK_OFFSET;      New(
literal|54
argument|,PL_scopestack,REASONABLE(
literal|32
argument|),I32);     PL_scopestack_ix =
literal|0
argument|;     PL_scopestack_max = REASONABLE(
literal|32
argument|);      New(
literal|54
argument|,PL_savestack,REASONABLE(
literal|128
argument|),ANY);     PL_savestack_ix =
literal|0
argument|;     PL_savestack_max = REASONABLE(
literal|128
argument|);      New(
literal|54
argument|,PL_retstack,REASONABLE(
literal|16
argument|),OP*);     PL_retstack_ix =
literal|0
argument|;     PL_retstack_max = REASONABLE(
literal|16
argument|); }
undef|#
directive|undef
name|REASONABLE
argument|STATIC void S_nuke_stacks(pTHX) {     while (PL_curstackinfo->si_next) 	PL_curstackinfo = PL_curstackinfo->si_next;     while (PL_curstackinfo) { 	PERL_SI *p = PL_curstackinfo->si_prev;
comment|/* curstackinfo->si_stack got nuked by sv_free_arenas() */
argument|Safefree(PL_curstackinfo->si_cxstack); 	Safefree(PL_curstackinfo); 	PL_curstackinfo = p;     }     Safefree(PL_tmps_stack);     Safefree(PL_markstack);     Safefree(PL_scopestack);     Safefree(PL_savestack);     Safefree(PL_retstack); }
ifndef|#
directive|ifndef
name|PERL_OBJECT
argument|static PerlIO *tmpfp;
comment|/* moved outside init_lexer() because of UNICOS bug */
endif|#
directive|endif
argument|STATIC void S_init_lexer(pTHX) {
ifdef|#
directive|ifdef
name|PERL_OBJECT
argument|PerlIO *tmpfp;
endif|#
directive|endif
argument|tmpfp = PL_rsfp;     PL_rsfp = Nullfp;     lex_start(PL_linestr);     PL_rsfp = tmpfp;     PL_subname = newSVpvn(
literal|"main"
argument|,
literal|4
argument|); }  STATIC void S_init_predump_symbols(pTHX) {     GV *tmpgv;     IO *io;      sv_setpvn(get_sv(
literal|"\""
argument|, TRUE),
literal|" "
argument|,
literal|1
argument|);     PL_stdingv = gv_fetchpv(
literal|"STDIN"
argument|,TRUE, SVt_PVIO);     GvMULTI_on(PL_stdingv);     io = GvIOp(PL_stdingv);     IoIFP(io) = PerlIO_stdin();     tmpgv = gv_fetchpv(
literal|"stdin"
argument|,TRUE, SVt_PV);     GvMULTI_on(tmpgv);     GvIOp(tmpgv) = (IO*)SvREFCNT_inc(io);      tmpgv = gv_fetchpv(
literal|"STDOUT"
argument|,TRUE, SVt_PVIO);     GvMULTI_on(tmpgv);     io = GvIOp(tmpgv);     IoOFP(io) = IoIFP(io) = PerlIO_stdout();     setdefout(tmpgv);     tmpgv = gv_fetchpv(
literal|"stdout"
argument|,TRUE, SVt_PV);     GvMULTI_on(tmpgv);     GvIOp(tmpgv) = (IO*)SvREFCNT_inc(io);      PL_stderrgv = gv_fetchpv(
literal|"STDERR"
argument|,TRUE, SVt_PVIO);     GvMULTI_on(PL_stderrgv);     io = GvIOp(PL_stderrgv);     IoOFP(io) = IoIFP(io) = PerlIO_stderr();     tmpgv = gv_fetchpv(
literal|"stderr"
argument|,TRUE, SVt_PV);     GvMULTI_on(tmpgv);     GvIOp(tmpgv) = (IO*)SvREFCNT_inc(io);      PL_statname = NEWSV(
literal|66
argument|,
literal|0
argument|);
comment|/* last filename we did stat on */
argument|if (PL_osname)     	Safefree(PL_osname);     PL_osname = savepv(OSNAME); }  STATIC void S_init_postdump_symbols(pTHX_ register int argc, register char **argv, register char **env) {     char *s;     SV *sv;     GV* tmpgv;     char **dup_env_base =
literal|0
argument|;     int dup_env_count =
literal|0
argument|;      argc--,argv++;
comment|/* skip name of script */
argument|if (PL_doswitches) { 	for (; argc>
literal|0
argument|&& **argv ==
literal|'-'
argument|; argc--,argv++) { 	    if (!argv[
literal|0
argument|][
literal|1
argument|]) 		break; 	    if (argv[
literal|0
argument|][
literal|1
argument|] ==
literal|'-'
argument|&& !argv[
literal|0
argument|][
literal|2
argument|]) { 		argc--,argv++; 		break; 	    } 	    if ((s = strchr(argv[
literal|0
argument|],
literal|'='
argument|))) { 		*s++ =
literal|'\0'
argument|; 		sv_setpv(GvSV(gv_fetchpv(argv[
literal|0
argument|]+
literal|1
argument|,TRUE, SVt_PV)),s); 	    } 	    else 		sv_setiv(GvSV(gv_fetchpv(argv[
literal|0
argument|]+
literal|1
argument|,TRUE, SVt_PV)),
literal|1
argument|); 	}     }     PL_toptarget = NEWSV(
literal|0
argument|,
literal|0
argument|);     sv_upgrade(PL_toptarget, SVt_PVFM);     sv_setpvn(PL_toptarget,
literal|""
argument|,
literal|0
argument|);     PL_bodytarget = NEWSV(
literal|0
argument|,
literal|0
argument|);     sv_upgrade(PL_bodytarget, SVt_PVFM);     sv_setpvn(PL_bodytarget,
literal|""
argument|,
literal|0
argument|);     PL_formtarget = PL_bodytarget;      TAINT;     if ((tmpgv = gv_fetchpv(
literal|"0"
argument|,TRUE, SVt_PV))) {
ifdef|#
directive|ifdef
name|MACOS_TRADITIONAL
comment|/* $0 is not majick on a Mac */
argument|sv_setpv(GvSV(tmpgv),MacPerl_MPWFileName(PL_origfilename));
else|#
directive|else
argument|sv_setpv(GvSV(tmpgv),PL_origfilename); 	magicname(
literal|"0"
argument|,
literal|"0"
argument|,
literal|1
argument|);
endif|#
directive|endif
argument|}     if ((tmpgv = gv_fetchpv(
literal|"\030"
argument|,TRUE, SVt_PV)))
ifdef|#
directive|ifdef
name|OS2
argument|sv_setpv(GvSV(tmpgv), os2_execname(aTHX));
else|#
directive|else
argument|sv_setpv(GvSV(tmpgv),PL_origargv[
literal|0
argument|]);
endif|#
directive|endif
argument|if ((PL_argvgv = gv_fetchpv(
literal|"ARGV"
argument|,TRUE, SVt_PVAV))) { 	GvMULTI_on(PL_argvgv); 	(void)gv_AVadd(PL_argvgv); 	av_clear(GvAVn(PL_argvgv)); 	for (; argc>
literal|0
argument|; argc--,argv++) { 	    SV *sv = newSVpv(argv[
literal|0
argument|],
literal|0
argument|); 	    av_push(GvAVn(PL_argvgv),sv); 	    if (PL_widesyscalls) 		(void)sv_utf8_decode(sv); 	}     }     if ((PL_envgv = gv_fetchpv(
literal|"ENV"
argument|,TRUE, SVt_PVHV))) { 	HV *hv; 	GvMULTI_on(PL_envgv); 	hv = GvHVn(PL_envgv); 	hv_magic(hv, Nullgv,
literal|'E'
argument|);
ifdef|#
directive|ifdef
name|USE_ENVIRON_ARRAY
comment|/* Note that if the supplied env parameter is actually a copy 	   of the global environ then it may now point to free'd memory 	   if the environment has been modified since. To avoid this 	   problem we treat env==NULL as meaning 'use the default' 	*/
argument|if (!env) 	    env = environ; 	if (env != environ) 	    environ[
literal|0
argument|] = Nullch;
ifdef|#
directive|ifdef
name|NEED_ENVIRON_DUP_FOR_MODIFY
argument|{ 	    char **env_base; 	    for (env_base = env; *env; env++)  		dup_env_count++; 	    if ((dup_env_base = (char **) 		 safesysmalloc( sizeof(char *) * (dup_env_count+
literal|1
argument|) ))) { 		char **dup_env; 		for (env = env_base, dup_env = dup_env_base; 		     *env; 		     env++, dup_env++) {
comment|/* With environ one needs to use safesysmalloc(). */
argument|*dup_env = safesysmalloc(strlen(*env) +
literal|1
argument|); 		    (void)strcpy(*dup_env, *env); 		} 		*dup_env = Nullch; 		env = dup_env_base; 	    }
comment|/* else what? */
argument|}
endif|#
directive|endif
comment|/* NEED_ENVIRON_DUP_FOR_MODIFY */
argument|for (; *env; env++) { 	    if (!(s = strchr(*env,
literal|'='
argument|))) 		continue; 	    *s++ =
literal|'\0'
argument|;
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
argument|(void)strupr(*env);
endif|#
directive|endif
argument|sv = newSVpv(s--,
literal|0
argument|); 	    (void)hv_store(hv, *env, s - *env, sv,
literal|0
argument|); 	    *s =
literal|'='
argument|; 	}
ifdef|#
directive|ifdef
name|NEED_ENVIRON_DUP_FOR_MODIFY
argument|if (dup_env_base) { 	    char **dup_env; 	    for (dup_env = dup_env_base; *dup_env; dup_env++) 		safesysfree(*dup_env); 	    safesysfree(dup_env_base); 	}
endif|#
directive|endif
comment|/* NEED_ENVIRON_DUP_FOR_MODIFY */
endif|#
directive|endif
comment|/* USE_ENVIRON_ARRAY */
ifdef|#
directive|ifdef
name|DYNAMIC_ENV_FETCH
argument|HvNAME(hv) = savepv(ENV_HV_NAME);
endif|#
directive|endif
argument|}     TAINT_NOT;     if ((tmpgv = gv_fetchpv(
literal|"$"
argument|,TRUE, SVt_PV))) 	sv_setiv(GvSV(tmpgv), (IV)PerlProc_getpid()); }  STATIC void S_init_perllib(pTHX) {     char *s;     if (!PL_tainting) {
ifndef|#
directive|ifndef
name|VMS
argument|s = PerlEnv_getenv(
literal|"PERL5LIB"
argument|); 	if (s) 	    incpush(s, TRUE, TRUE); 	else 	    incpush(PerlEnv_getenv(
literal|"PERLLIB"
argument|), FALSE, FALSE);
else|#
directive|else
comment|/* VMS */
comment|/* Treat PERL5?LIB as a possible search list logical name -- the 	 * "natural" VMS idiom for a Unix path string.  We allow each 	 * element to be a set of |-separated directories for compatibility. 	 */
argument|char buf[
literal|256
argument|]; 	int idx =
literal|0
argument|; 	if (my_trnlnm(
literal|"PERL5LIB"
argument|,buf,
literal|0
argument|)) 	    do { incpush(buf,TRUE,TRUE); } while (my_trnlnm(
literal|"PERL5LIB"
argument|,buf,++idx)); 	else 	    while (my_trnlnm(
literal|"PERLLIB"
argument|,buf,idx++)) incpush(buf,FALSE,FALSE);
endif|#
directive|endif
comment|/* VMS */
argument|}
comment|/* Use the ~-expanded versions of APPLLIB (undocumented),     ARCHLIB PRIVLIB SITEARCH SITELIB VENDORARCH and VENDORLIB */
ifdef|#
directive|ifdef
name|APPLLIB_EXP
argument|incpush(APPLLIB_EXP, TRUE, TRUE);
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHLIB_EXP
argument|incpush(ARCHLIB_EXP, FALSE, FALSE);
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MACOS_TRADITIONAL
argument|{ 	struct stat tmpstatbuf;     	SV * privdir = NEWSV(
literal|55
argument|,
literal|0
argument|); 	char * macperl = PerlEnv_getenv(
literal|"MACPERL"
argument|); 	 	if (!macperl) 	    macperl =
literal|""
argument|; 	 	Perl_sv_setpvf(aTHX_ privdir,
literal|"%slib:"
argument|, macperl); 	if (PerlLIO_stat(SvPVX(privdir),&tmpstatbuf)>=
literal|0
argument|&& S_ISDIR(tmpstatbuf.st_mode)) 	    incpush(SvPVX(privdir), TRUE, FALSE); 	Perl_sv_setpvf(aTHX_ privdir,
literal|"%ssite_perl:"
argument|, macperl); 	if (PerlLIO_stat(SvPVX(privdir),&tmpstatbuf)>=
literal|0
argument|&& S_ISDIR(tmpstatbuf.st_mode)) 	    incpush(SvPVX(privdir), TRUE, FALSE); 	        	SvREFCNT_dec(privdir);     }     if (!PL_tainting) 	incpush(
literal|":"
argument|, FALSE, FALSE);
else|#
directive|else
ifndef|#
directive|ifndef
name|PRIVLIB_EXP
define|#
directive|define
name|PRIVLIB_EXP
value|"/usr/local/lib/perl5:/usr/local/lib/perl"
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
argument|incpush(PRIVLIB_EXP, TRUE, FALSE);
else|#
directive|else
argument|incpush(PRIVLIB_EXP, FALSE, FALSE);
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SITEARCH_EXP
comment|/* sitearch is always relative to sitelib on Windows for      * DLL-based path intuition to work correctly */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
argument|incpush(SITEARCH_EXP, FALSE, FALSE);
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SITELIB_EXP
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
argument|incpush(SITELIB_EXP, TRUE, FALSE);
comment|/* this picks up sitearch as well */
else|#
directive|else
argument|incpush(SITELIB_EXP, FALSE, FALSE);
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SITELIB_STEM
comment|/* Search for version-specific dirs below here */
argument|incpush(SITELIB_STEM, FALSE, TRUE);
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PERL_VENDORARCH_EXP
comment|/* vendorarch is always relative to vendorlib on Windows for      * DLL-based path intuition to work correctly */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
argument|incpush(PERL_VENDORARCH_EXP, FALSE, FALSE);
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PERL_VENDORLIB_EXP
if|#
directive|if
name|defined
argument_list|(
name|WIN32
argument_list|)
argument|incpush(PERL_VENDORLIB_EXP, TRUE, FALSE);
comment|/* this picks up vendorarch as well */
else|#
directive|else
argument|incpush(PERL_VENDORLIB_EXP, FALSE, FALSE);
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PERL_VENDORLIB_STEM
comment|/* Search for version-specific dirs below here */
argument|incpush(PERL_VENDORLIB_STEM, FALSE, TRUE);
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PERL_OTHERLIBDIRS
argument|incpush(PERL_OTHERLIBDIRS, TRUE, TRUE);
endif|#
directive|endif
argument|if (!PL_tainting) 	incpush(
literal|"."
argument|, FALSE, FALSE);
endif|#
directive|endif
comment|/* MACOS_TRADITIONAL */
argument|}
if|#
directive|if
name|defined
argument_list|(
name|DOSISH
argument_list|)
operator|||
name|defined
argument_list|(
name|EPOC
argument_list|)
define|#
directive|define
name|PERLLIB_SEP
value|';'
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
define|#
directive|define
name|PERLLIB_SEP
value|'|'
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|MACOS_TRADITIONAL
argument_list|)
define|#
directive|define
name|PERLLIB_SEP
value|','
else|#
directive|else
define|#
directive|define
name|PERLLIB_SEP
value|':'
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
ifndef|#
directive|ifndef
name|PERLLIB_MANGLE
define|#
directive|define
name|PERLLIB_MANGLE
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
value|(s)
endif|#
directive|endif
argument|STATIC void S_incpush(pTHX_ char *p, int addsubdirs, int addoldvers) {     SV *subdir = Nullsv;      if (!p || !*p) 	return;      if (addsubdirs || addoldvers) { 	subdir = sv_newmortal();     }
comment|/* Break at all separators */
argument|while (p&& *p) { 	SV *libdir = NEWSV(
literal|55
argument|,
literal|0
argument|); 	char *s;
comment|/* skip any consecutive separators */
argument|while ( *p == PERLLIB_SEP ) {
comment|/* Uncomment the next line for PATH semantics */
comment|/* av_push(GvAVn(PL_incgv), newSVpvn(".", 1)); */
argument|p++; 	}  	if ( (s = strchr(p, PERLLIB_SEP)) != Nullch ) { 	    sv_setpvn(libdir, PERLLIB_MANGLE(p, (STRLEN)(s - p)), 		      (STRLEN)(s - p)); 	    p = s +
literal|1
argument|; 	} 	else { 	    sv_setpv(libdir, PERLLIB_MANGLE(p,
literal|0
argument|)); 	    p = Nullch;
comment|/* break out */
argument|}
ifdef|#
directive|ifdef
name|MACOS_TRADITIONAL
argument|if (!strchr(SvPVX(libdir),
literal|':'
argument|)) 	    sv_insert(libdir,
literal|0
argument|,
literal|0
argument|,
literal|":"
argument|,
literal|1
argument|); 	if (SvPVX(libdir)[SvCUR(libdir)-
literal|1
argument|] !=
literal|':'
argument|) 	    sv_catpv(libdir,
literal|":"
argument|);
endif|#
directive|endif
comment|/* 	 * BEFORE pushing libdir onto @INC we may first push version- and 	 * archname-specific sub-directories. 	 */
argument|if (addsubdirs || addoldvers) {
ifdef|#
directive|ifdef
name|PERL_INC_VERSION_LIST
comment|/* Configure terminates PERL_INC_VERSION_LIST with a NULL */
argument|const char *incverlist[] = { PERL_INC_VERSION_LIST }; 	    const char **incver;
endif|#
directive|endif
argument|struct stat tmpstatbuf;
ifdef|#
directive|ifdef
name|VMS
argument|char *unix; 	    STRLEN len;  	    if ((unix = tounixspec_ts(SvPV(libdir,len),Nullch)) != Nullch) { 		len = strlen(unix); 		while (unix[len-
literal|1
argument|] ==
literal|'/'
argument|) len--;
comment|/* Cosmetic */
argument|sv_usepvn(libdir,unix,len); 	    } 	    else 		PerlIO_printf(Perl_error_log,
literal|"Failed to unixify @INC element \"%s\"\n"
argument|, 			      SvPV(libdir,len));
endif|#
directive|endif
argument|if (addsubdirs) {
ifdef|#
directive|ifdef
name|MACOS_TRADITIONAL
define|#
directive|define
name|PERL_AV_SUFFIX_FMT
value|""
define|#
directive|define
name|PERL_ARCH_FMT
value|"%s:"
define|#
directive|define
name|PERL_ARCH_FMT_PATH
value|PERL_FS_VER_FMT PERL_AV_SUFFIX_FMT
else|#
directive|else
define|#
directive|define
name|PERL_AV_SUFFIX_FMT
value|"/"
define|#
directive|define
name|PERL_ARCH_FMT
value|"/%s"
define|#
directive|define
name|PERL_ARCH_FMT_PATH
value|PERL_AV_SUFFIX_FMT PERL_FS_VER_FMT
endif|#
directive|endif
comment|/* .../version/archname if -d .../version/archname */
argument|Perl_sv_setpvf(aTHX_ subdir,
literal|"%"
argument|SVf PERL_ARCH_FMT_PATH PERL_ARCH_FMT, 				libdir, 			       (int)PERL_REVISION, (int)PERL_VERSION, 			       (int)PERL_SUBVERSION, ARCHNAME); 		if (PerlLIO_stat(SvPVX(subdir),&tmpstatbuf)>=
literal|0
argument|&& 		      S_ISDIR(tmpstatbuf.st_mode)) 		    av_push(GvAVn(PL_incgv), newSVsv(subdir));
comment|/* .../version if -d .../version */
argument|Perl_sv_setpvf(aTHX_ subdir,
literal|"%"
argument|SVf PERL_ARCH_FMT_PATH, libdir, 			       (int)PERL_REVISION, (int)PERL_VERSION, 			       (int)PERL_SUBVERSION); 		if (PerlLIO_stat(SvPVX(subdir),&tmpstatbuf)>=
literal|0
argument|&& 		      S_ISDIR(tmpstatbuf.st_mode)) 		    av_push(GvAVn(PL_incgv), newSVsv(subdir));
comment|/* .../archname if -d .../archname */
argument|Perl_sv_setpvf(aTHX_ subdir,
literal|"%"
argument|SVf PERL_ARCH_FMT, libdir, ARCHNAME); 		if (PerlLIO_stat(SvPVX(subdir),&tmpstatbuf)>=
literal|0
argument|&& 		      S_ISDIR(tmpstatbuf.st_mode)) 		    av_push(GvAVn(PL_incgv), newSVsv(subdir)); 	    }
ifdef|#
directive|ifdef
name|PERL_INC_VERSION_LIST
argument|if (addoldvers) { 		for (incver = incverlist; *incver; incver++) {
comment|/* .../xxx if -d .../xxx */
argument|Perl_sv_setpvf(aTHX_ subdir,
literal|"%"
argument|SVf PERL_ARCH_FMT, libdir, *incver); 		    if (PerlLIO_stat(SvPVX(subdir),&tmpstatbuf)>=
literal|0
argument|&& 			  S_ISDIR(tmpstatbuf.st_mode)) 			av_push(GvAVn(PL_incgv), newSVsv(subdir)); 		} 	    }
endif|#
directive|endif
argument|}
comment|/* finally push this lib directory on the end of @INC */
argument|av_push(GvAVn(PL_incgv), libdir);     } }
ifdef|#
directive|ifdef
name|USE_THREADS
argument|STATIC struct perl_thread * S_init_main_thread(pTHX) {
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PERL_IMPLICIT_CONTEXT
argument_list|)
argument|struct perl_thread *thr;
endif|#
directive|endif
argument|XPV *xpv;      Newz(
literal|53
argument|, thr,
literal|1
argument|, struct perl_thread);     PL_curcop =&PL_compiling;     thr->interp = PERL_GET_INTERP;     thr->cvcache = newHV();     thr->threadsv = newAV();
comment|/* thr->threadsvp is set when find_threadsv is called */
argument|thr->specific = newAV();     thr->flags = THRf_R_JOINABLE;     MUTEX_INIT(&thr->mutex);
comment|/* Handcraft thrsv similarly to mess_sv */
argument|New(
literal|53
argument|, PL_thrsv,
literal|1
argument|, SV);     Newz(
literal|53
argument|, xpv,
literal|1
argument|, XPV);     SvFLAGS(PL_thrsv) = SVt_PV;     SvANY(PL_thrsv) = (void*)xpv;     SvREFCNT(PL_thrsv) =
literal|1
argument|<<
literal|30
argument|;
comment|/* practically infinite */
argument|SvPVX(PL_thrsv) = (char*)thr;     SvCUR_set(PL_thrsv, sizeof(thr));     SvLEN_set(PL_thrsv, sizeof(thr));     *SvEND(PL_thrsv) =
literal|'\0'
argument|;
comment|/* in the trailing_nul field */
argument|thr->oursv = PL_thrsv;     PL_chopset =
literal|" \n-"
argument|;     PL_dumpindent =
literal|4
argument|;      MUTEX_LOCK(&PL_threads_mutex);     PL_nthreads++;     thr->tid =
literal|0
argument|;     thr->next = thr;     thr->prev = thr;     MUTEX_UNLOCK(&PL_threads_mutex);
ifdef|#
directive|ifdef
name|HAVE_THREAD_INTERN
argument|Perl_init_thread_intern(thr);
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SET_THREAD_SELF
argument|SET_THREAD_SELF(thr);
else|#
directive|else
argument|thr->self = pthread_self();
endif|#
directive|endif
comment|/* SET_THREAD_SELF */
argument|PERL_SET_THX(thr);
comment|/*      * These must come after the thread self setting      * because sv_setpvn does SvTAINT and the taint      * fields thread selfness being set.      */
argument|PL_toptarget = NEWSV(
literal|0
argument|,
literal|0
argument|);     sv_upgrade(PL_toptarget, SVt_PVFM);     sv_setpvn(PL_toptarget,
literal|""
argument|,
literal|0
argument|);     PL_bodytarget = NEWSV(
literal|0
argument|,
literal|0
argument|);     sv_upgrade(PL_bodytarget, SVt_PVFM);     sv_setpvn(PL_bodytarget,
literal|""
argument|,
literal|0
argument|);     PL_formtarget = PL_bodytarget;     thr->errsv = newSVpvn(
literal|""
argument|,
literal|0
argument|);     (void) find_threadsv(
literal|"@"
argument|);
comment|/* Ensure $@ is initialised early */
argument|PL_maxscream = -
literal|1
argument|;     PL_regcompp = MEMBER_TO_FPTR(Perl_pregcomp);     PL_regexecp = MEMBER_TO_FPTR(Perl_regexec_flags);     PL_regint_start = MEMBER_TO_FPTR(Perl_re_intuit_start);     PL_regint_string = MEMBER_TO_FPTR(Perl_re_intuit_string);     PL_regfree = MEMBER_TO_FPTR(Perl_pregfree);     PL_regindent =
literal|0
argument|;     PL_reginterp_cnt =
literal|0
argument|;      return thr; }
endif|#
directive|endif
comment|/* USE_THREADS */
argument|void Perl_call_list(pTHX_ I32 oldscope, AV *paramList) {     SV *atsv;     line_t oldline = CopLINE(PL_curcop);     CV *cv;     STRLEN len;     int ret;     dJMPENV;      while (AvFILL(paramList)>=
literal|0
argument|) { 	cv = (CV*)av_shift(paramList); 	if ((PL_minus_c&
literal|0x10
argument|)&& (paramList == PL_beginav)) {
comment|/* save PL_beginav for compiler */
argument|if (! PL_beginav_save) 		PL_beginav_save = newAV(); 	    av_push(PL_beginav_save, (SV*)cv); 	} else { 	    SAVEFREESV(cv); 	}
ifdef|#
directive|ifdef
name|PERL_FLEXIBLE_EXCEPTIONS
argument|CALLPROTECT(aTHX_ pcur_env,&ret, MEMBER_TO_FPTR(S_vcall_list_body), cv);
else|#
directive|else
argument|JMPENV_PUSH(ret);
endif|#
directive|endif
argument|switch (ret) { 	case
literal|0
argument|:
ifndef|#
directive|ifndef
name|PERL_FLEXIBLE_EXCEPTIONS
argument|call_list_body(cv);
endif|#
directive|endif
argument|atsv = ERRSV; 	    (void)SvPV(atsv, len); 	    if (len) { 		STRLEN n_a; 		PL_curcop =&PL_compiling; 		CopLINE_set(PL_curcop, oldline); 		if (paramList == PL_beginav) 		    sv_catpv(atsv,
literal|"BEGIN failed--compilation aborted"
argument|); 		else 		    Perl_sv_catpvf(aTHX_ atsv,
literal|"%s failed--call queue aborted"
argument|, 				   paramList == PL_checkav ?
literal|"CHECK"
argument|: paramList == PL_initav ?
literal|"INIT"
argument|:
literal|"END"
argument|); 		while (PL_scopestack_ix> oldscope) 		    LEAVE; 		JMPENV_POP; 		Perl_croak(aTHX_
literal|"%s"
argument|, SvPVx(atsv, n_a)); 	    } 	    break; 	case
literal|1
argument|: 	    STATUS_ALL_FAILURE;
comment|/* FALL THROUGH */
argument|case
literal|2
argument|:
comment|/* my_exit() was called */
argument|while (PL_scopestack_ix> oldscope) 		LEAVE; 	    FREETMPS; 	    PL_curstash = PL_defstash; 	    PL_curcop =&PL_compiling; 	    CopLINE_set(PL_curcop, oldline); 	    JMPENV_POP; 	    if (PL_statusvalue&& !(PL_exit_flags& PERL_EXIT_EXPECTED)) { 		if (paramList == PL_beginav) 		    Perl_croak(aTHX_
literal|"BEGIN failed--compilation aborted"
argument|); 		else 		    Perl_croak(aTHX_
literal|"%s failed--call queue aborted"
argument|, 			       paramList == PL_checkav ?
literal|"CHECK"
argument|: paramList == PL_initav ?
literal|"INIT"
argument|:
literal|"END"
argument|); 	    } 	    my_exit_jump();
comment|/* NOTREACHED */
argument|case
literal|3
argument|: 	    if (PL_restartop) { 		PL_curcop =&PL_compiling; 		CopLINE_set(PL_curcop, oldline); 		JMPENV_JUMP(
literal|3
argument|); 	    } 	    PerlIO_printf(Perl_error_log,
literal|"panic: restartop\n"
argument|); 	    FREETMPS; 	    break; 	} 	JMPENV_POP;     } }
ifdef|#
directive|ifdef
name|PERL_FLEXIBLE_EXCEPTIONS
argument|STATIC void * S_vcall_list_body(pTHX_ va_list args) {     CV *cv = va_arg(args, CV*);     return call_list_body(cv); }
endif|#
directive|endif
argument|STATIC void * S_call_list_body(pTHX_ CV *cv) {     PUSHMARK(PL_stack_sp);     call_sv((SV*)cv, G_EVAL|G_DISCARD);     return NULL; }  void Perl_my_exit(pTHX_ U32 status) {     DEBUG_S(PerlIO_printf(Perl_debug_log,
literal|"my_exit: thread %p, status %lu\n"
argument|, 			  thr, (unsigned long) status));     switch (status) {     case
literal|0
argument|: 	STATUS_ALL_SUCCESS; 	break;     case
literal|1
argument|: 	STATUS_ALL_FAILURE; 	break;     default: 	STATUS_NATIVE_SET(status); 	break;     }     my_exit_jump(); }  void Perl_my_failure_exit(pTHX) {
ifdef|#
directive|ifdef
name|VMS
argument|if (vaxc$errno&
literal|1
argument|) { 	if (STATUS_NATIVE&
literal|1
argument|)
comment|/* fortuitiously includes "-1" */
argument|STATUS_NATIVE_SET(
literal|44
argument|);     }     else { 	if (!vaxc$errno&& errno)
comment|/* unlikely */
argument|STATUS_NATIVE_SET(
literal|44
argument|); 	else 	    STATUS_NATIVE_SET(vaxc$errno);     }
else|#
directive|else
argument|int exitstatus;     if (errno&
literal|255
argument|) 	STATUS_POSIX_SET(errno);     else { 	exitstatus = STATUS_POSIX>>
literal|8
argument|;  	if (exitstatus&
literal|255
argument|) 	    STATUS_POSIX_SET(exitstatus); 	else 	    STATUS_POSIX_SET(
literal|255
argument|);     }
endif|#
directive|endif
argument|my_exit_jump(); }  STATIC void S_my_exit_jump(pTHX) {     register PERL_CONTEXT *cx;     I32 gimme;     SV **newsp;      if (PL_e_script) { 	SvREFCNT_dec(PL_e_script); 	PL_e_script = Nullsv;     }      POPSTACK_TO(PL_mainstack);     if (cxstack_ix>=
literal|0
argument|) { 	if (cxstack_ix>
literal|0
argument|) 	    dounwind(
literal|0
argument|); 	POPBLOCK(cx,PL_curpm); 	LEAVE;     }      JMPENV_JUMP(
literal|2
argument|); }
ifdef|#
directive|ifdef
name|PERL_OBJECT
include|#
directive|include
file|"XSUB.h"
endif|#
directive|endif
argument|static I32 read_e_script(pTHXo_ int idx, SV *buf_sv, int maxlen) {     char *p, *nl;     p  = SvPVX(PL_e_script);     nl = strchr(p,
literal|'\n'
argument|);     nl = (nl) ? nl+
literal|1
argument|: SvEND(PL_e_script);     if (nl-p ==
literal|0
argument|) { 	filter_del(read_e_script); 	return
literal|0
argument|;     }     sv_catpvn(buf_sv, p, nl-p);     sv_chop(PL_e_script, nl);     return
literal|1
argument|; }
end_function

end_unit

