begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    sv.c  *  *    Copyright (c) 1991-1999, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  */
end_comment

begin_comment
comment|/*  * "I wonder what the Entish is for 'yes' and 'no'," he thought.  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OVR_DBL_DIG
end_ifdef

begin_comment
comment|/* Use an overridden DBL_DIG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DBL_DIG
end_ifdef

begin_undef
undef|#
directive|undef
name|DBL_DIG
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DBL_DIG
value|OVR_DBL_DIG
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* The following is all to get DBL_DIG, in order to pick a nice    default value for printing floating point numbers in Gconvert.    (see config.h) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|I_LIMITS
end_ifdef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_FLOAT
end_ifdef

begin_include
include|#
directive|include
file|<float.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAS_DBL_DIG
end_ifndef

begin_define
define|#
directive|define
name|DBL_DIG
value|15
end_define

begin_comment
comment|/* A guess that works lots of places */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_STDIO_PTR
argument_list|)
operator|&&
name|defined
argument_list|(
name|STDIO_PTR_LVALUE
argument_list|)
operator|&&
name|defined
argument_list|(
name|STDIO_CNT_LVALUE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__QNX__
argument_list|)
end_if

begin_define
define|#
directive|define
name|FAST_SV_GETS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_OBJECT
end_ifdef

begin_define
define|#
directive|define
name|FCALL
value|this->*f
end_define

begin_define
define|#
directive|define
name|VTBL
value|this->*vtbl
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !PERL_OBJECT */
end_comment

begin_decl_stmt
specifier|static
name|IV
name|asIV
name|_
argument_list|(
operator|(
name|SV
operator|*
name|sv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|UV
name|asUV
name|_
argument_list|(
operator|(
name|SV
operator|*
name|sv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SV
modifier|*
name|more_sv
name|_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|more_xiv
name|_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|more_xnv
name|_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|more_xpv
name|_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|more_xrv
name|_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|XPVIV
modifier|*
name|new_xiv
name|_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|XPVNV
modifier|*
name|new_xnv
name|_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|XPV
modifier|*
name|new_xpv
name|_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|XRV
modifier|*
name|new_xrv
name|_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|del_xiv
name|_
argument_list|(
operator|(
name|XPVIV
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|del_xnv
name|_
argument_list|(
operator|(
name|XPVNV
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|del_xpv
name|_
argument_list|(
operator|(
name|XPV
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|del_xrv
name|_
argument_list|(
operator|(
name|XRV
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sv_mortalgrow
name|_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sv_unglob
name|_
argument_list|(
operator|(
name|SV
operator|*
name|sv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sv_check_thinkfirst
name|_
argument_list|(
operator|(
name|SV
operator|*
name|sv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|PURIFY
end_ifndef

begin_function_decl
specifier|static
name|void
modifier|*
name|my_safemalloc
parameter_list|(
name|MEM_SIZE
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|void
argument_list|(
argument|*SVFUNC
argument_list|)
name|_
argument_list|(
operator|(
name|SV
operator|*
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_define
define|#
directive|define
name|VTBL
value|*vtbl
end_define

begin_define
define|#
directive|define
name|FCALL
value|*f
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PERL_OBJECT */
end_comment

begin_define
define|#
directive|define
name|SV_CHECK_THINKFIRST
parameter_list|(
name|sv
parameter_list|)
value|if (SvTHINKFIRST(sv)) sv_check_thinkfirst(sv)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|PURIFY
end_ifdef

begin_define
define|#
directive|define
name|new_SV
parameter_list|(
name|p
parameter_list|)
define|\
value|do {				\ 	LOCK_SV_MUTEX;			\ 	(p) = (SV*)safemalloc(sizeof(SV)); \ 	reg_add(p);			\ 	UNLOCK_SV_MUTEX;		\     } while (0)
end_define

begin_define
define|#
directive|define
name|del_SV
parameter_list|(
name|p
parameter_list|)
define|\
value|do {				\ 	LOCK_SV_MUTEX;			\ 	reg_remove(p);			\         Safefree((char*)(p));		\ 	UNLOCK_SV_MUTEX;		\     } while (0)
end_define

begin_decl_stmt
specifier|static
name|SV
modifier|*
modifier|*
name|registry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|I32
name|registry_size
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|REGHASH
parameter_list|(
name|sv
parameter_list|,
name|size
parameter_list|)
value|((((U32)(sv))>> 2) % (size))
end_define

begin_define
define|#
directive|define
name|REG_REPLACE
parameter_list|(
name|sv
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
define|\
value|do {				\ 	void* p = sv->sv_any;		\ 	I32 h = REGHASH(sv, registry_size);	\ 	I32 i = h;			\ 	while (registry[i] != (a)) {	\ 	    if (++i>= registry_size)	\ 		i = 0;			\ 	    if (i == h)			\ 		die("SV registry bug");	\ 	}				\ 	registry[i] = (b);		\     } while (0)
end_define

begin_define
define|#
directive|define
name|REG_ADD
parameter_list|(
name|sv
parameter_list|)
value|REG_REPLACE(sv,Nullsv,sv)
end_define

begin_define
define|#
directive|define
name|REG_REMOVE
parameter_list|(
name|sv
parameter_list|)
value|REG_REPLACE(sv,sv,Nullsv)
end_define

begin_function
specifier|static
name|void
name|reg_add
parameter_list|(
name|sv
parameter_list|)
name|SV
modifier|*
name|sv
decl_stmt|;
block|{
if|if
condition|(
name|PL_sv_count
operator|>=
operator|(
name|registry_size
operator|>>
literal|1
operator|)
condition|)
block|{
name|SV
modifier|*
modifier|*
name|oldreg
init|=
name|registry
decl_stmt|;
name|I32
name|oldsize
init|=
name|registry_size
decl_stmt|;
name|registry_size
operator|=
name|registry_size
condition|?
operator|(
operator|(
name|registry_size
operator|<<
literal|2
operator|)
operator|+
literal|1
operator|)
else|:
literal|2037
expr_stmt|;
name|Newz
argument_list|(
literal|707
argument_list|,
name|registry
argument_list|,
name|registry_size
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldreg
condition|)
block|{
name|I32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldsize
condition|;
operator|++
name|i
control|)
block|{
name|SV
modifier|*
name|oldsv
init|=
name|oldreg
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|oldsv
condition|)
name|REG_ADD
argument_list|(
name|oldsv
argument_list|)
expr_stmt|;
block|}
name|Safefree
argument_list|(
name|oldreg
argument_list|)
expr_stmt|;
block|}
block|}
name|REG_ADD
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|++
name|PL_sv_count
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|reg_remove
parameter_list|(
name|sv
parameter_list|)
name|SV
modifier|*
name|sv
decl_stmt|;
block|{
name|REG_REMOVE
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|--
name|PL_sv_count
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|visit
parameter_list|(
name|f
parameter_list|)
name|SVFUNC
name|f
decl_stmt|;
block|{
name|I32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|registry_size
condition|;
operator|++
name|i
control|)
block|{
name|SV
modifier|*
name|sv
init|=
name|registry
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|sv
operator|&&
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|!=
name|SVTYPEMASK
condition|)
call|(
modifier|*
name|f
call|)
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sv_add_arena
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|U32
name|size
decl_stmt|;
name|U32
name|flags
decl_stmt|;
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SVf_FAKE
operator|)
condition|)
name|Safefree
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! PURIFY */
end_comment

begin_comment
comment|/*  * "A time to plant, and a time to uproot what was planted..."  */
end_comment

begin_define
define|#
directive|define
name|plant_SV
parameter_list|(
name|p
parameter_list|)
define|\
value|do {				\ 	SvANY(p) = (void *)PL_sv_root;	\ 	SvFLAGS(p) = SVTYPEMASK;	\ 	PL_sv_root = (p);			\ 	--PL_sv_count;			\     } while (0)
end_define

begin_comment
comment|/* sv_mutex must be held while calling uproot_SV() */
end_comment

begin_define
define|#
directive|define
name|uproot_SV
parameter_list|(
name|p
parameter_list|)
define|\
value|do {				\ 	(p) = PL_sv_root;			\ 	PL_sv_root = (SV*)SvANY(p);	\ 	++PL_sv_count;			\     } while (0)
end_define

begin_define
define|#
directive|define
name|new_SV
parameter_list|(
name|p
parameter_list|)
value|do {	\ 	LOCK_SV_MUTEX;		\ 	if (PL_sv_root)		\ 	    uproot_SV(p);	\ 	else			\ 	    (p) = more_sv();	\ 	UNLOCK_SV_MUTEX;	\     } while (0)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGGING
end_ifdef

begin_define
define|#
directive|define
name|del_SV
parameter_list|(
name|p
parameter_list|)
value|do {	\ 	LOCK_SV_MUTEX;		\ 	if (PL_debug& 32768)	\ 	    del_sv(p);		\ 	else			\ 	    plant_SV(p);	\ 	UNLOCK_SV_MUTEX;	\     } while (0)
end_define

begin_function
name|STATIC
name|void
name|del_sv
parameter_list|(
name|SV
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|PL_debug
operator|&
literal|32768
condition|)
block|{
name|SV
modifier|*
name|sva
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|SV
modifier|*
name|svend
decl_stmt|;
name|int
name|ok
init|=
literal|0
decl_stmt|;
for|for
control|(
name|sva
operator|=
name|PL_sv_arenaroot
init|;
name|sva
condition|;
name|sva
operator|=
operator|(
name|SV
operator|*
operator|)
name|SvANY
argument_list|(
name|sva
argument_list|)
control|)
block|{
name|sv
operator|=
name|sva
operator|+
literal|1
expr_stmt|;
name|svend
operator|=
operator|&
name|sva
index|[
name|SvREFCNT
argument_list|(
name|sva
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|sv
operator|&&
name|p
operator|<
name|svend
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|warn
argument_list|(
literal|"Attempt to free non-arena SV: 0x%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|plant_SV
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! DEBUGGING */
end_comment

begin_define
define|#
directive|define
name|del_SV
parameter_list|(
name|p
parameter_list|)
value|plant_SV(p)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUGGING */
end_comment

begin_function
name|void
name|sv_add_arena
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|U32
name|size
parameter_list|,
name|U32
name|flags
parameter_list|)
block|{
name|SV
modifier|*
name|sva
init|=
operator|(
name|SV
operator|*
operator|)
name|ptr
decl_stmt|;
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
specifier|register
name|SV
modifier|*
name|svend
decl_stmt|;
name|Zero
argument_list|(
name|sva
argument_list|,
name|size
argument_list|,
name|char
argument_list|)
expr_stmt|;
comment|/* The first SV in an arena isn't an SV. */
name|SvANY
argument_list|(
name|sva
argument_list|)
operator|=
operator|(
name|void
operator|*
operator|)
name|PL_sv_arenaroot
expr_stmt|;
comment|/* ptr to next arena */
name|SvREFCNT
argument_list|(
name|sva
argument_list|)
operator|=
name|size
operator|/
sizeof|sizeof
argument_list|(
name|SV
argument_list|)
expr_stmt|;
comment|/* number of SV slots */
name|SvFLAGS
argument_list|(
name|sva
argument_list|)
operator|=
name|flags
expr_stmt|;
comment|/* FAKE if not to be freed */
name|PL_sv_arenaroot
operator|=
name|sva
expr_stmt|;
name|PL_sv_root
operator|=
name|sva
operator|+
literal|1
expr_stmt|;
name|svend
operator|=
operator|&
name|sva
index|[
name|SvREFCNT
argument_list|(
name|sva
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
name|sv
operator|=
name|sva
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|sv
operator|<
name|svend
condition|)
block|{
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|SV
operator|*
operator|)
operator|(
name|sv
operator|+
literal|1
operator|)
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|=
name|SVTYPEMASK
expr_stmt|;
name|sv
operator|++
expr_stmt|;
block|}
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|=
name|SVTYPEMASK
expr_stmt|;
block|}
end_function

begin_comment
comment|/* sv_mutex must be held while calling more_sv() */
end_comment

begin_function
name|STATIC
name|SV
modifier|*
name|more_sv
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
name|PL_nice_chunk
condition|)
block|{
name|sv_add_arena
argument_list|(
name|PL_nice_chunk
argument_list|,
name|PL_nice_chunk_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PL_nice_chunk
operator|=
name|Nullch
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|chunk
decl_stmt|;
comment|/* must use New here to match call to */
name|New
argument_list|(
literal|704
argument_list|,
name|chunk
argument_list|,
literal|1008
argument_list|,
name|char
argument_list|)
expr_stmt|;
comment|/* Safefree() in sv_free_arenas()     */
name|sv_add_arena
argument_list|(
name|chunk
argument_list|,
literal|1008
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|uproot_SV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|visit
parameter_list|(
name|SVFUNC
name|f
parameter_list|)
block|{
name|SV
modifier|*
name|sva
decl_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
specifier|register
name|SV
modifier|*
name|svend
decl_stmt|;
for|for
control|(
name|sva
operator|=
name|PL_sv_arenaroot
init|;
name|sva
condition|;
name|sva
operator|=
operator|(
name|SV
operator|*
operator|)
name|SvANY
argument_list|(
name|sva
argument_list|)
control|)
block|{
name|svend
operator|=
operator|&
name|sva
index|[
name|SvREFCNT
argument_list|(
name|sva
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|sv
operator|=
name|sva
operator|+
literal|1
init|;
name|sv
operator|<
name|svend
condition|;
operator|++
name|sv
control|)
block|{
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|!=
name|SVTYPEMASK
condition|)
call|(
name|FCALL
call|)
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PURIFY */
end_comment

begin_function
name|STATIC
name|void
name|do_report_used
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|!=
name|SVTYPEMASK
condition|)
block|{
comment|/* XXX Perhaps this ought to go to Perl_debug_log, if DEBUGGING. */
name|PerlIO_printf
argument_list|(
name|PerlIO_stderr
argument_list|()
argument_list|,
literal|"****\n"
argument_list|)
expr_stmt|;
name|sv_dump
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sv_report_used
parameter_list|(
name|void
parameter_list|)
block|{
name|visit
argument_list|(
name|FUNC_NAME_TO_PTR
argument_list|(
name|do_report_used
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|do_clean_objs
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|SV
modifier|*
name|rv
decl_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvOBJECT
argument_list|(
name|rv
operator|=
name|SvRV
argument_list|(
name|sv
argument_list|)
argument_list|)
condition|)
block|{
name|DEBUG_D
argument_list|(
argument|(PerlIO_printf(Perl_debug_log,
literal|"Cleaning object ref:\n "
argument|), sv_dump(sv));
argument_list|)
name|SvROK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvRV
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|rv
argument_list|)
expr_stmt|;
block|}
comment|/* XXX Might want to check arrays, etc. */
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|DISABLE_DESTRUCTOR_KLUDGE
end_ifndef

begin_function
name|STATIC
name|void
name|do_clean_named_objs
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_PVGV
condition|)
block|{
if|if
condition|(
name|SvOBJECT
argument_list|(
name|GvSV
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|||
name|GvAV
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvOBJECT
argument_list|(
name|GvAV
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|||
name|GvHV
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvOBJECT
argument_list|(
name|GvHV
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|||
name|GvIO
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvOBJECT
argument_list|(
name|GvIO
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|||
name|GvCV
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvOBJECT
argument_list|(
name|GvCV
argument_list|(
name|sv
argument_list|)
argument_list|)
condition|)
block|{
name|DEBUG_D
argument_list|(
argument|(PerlIO_printf(Perl_debug_log,
literal|"Cleaning named glob object:\n "
argument|), sv_dump(sv));
argument_list|)
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|sv_clean_objs
parameter_list|(
name|void
parameter_list|)
block|{
name|PL_in_clean_objs
operator|=
name|TRUE
expr_stmt|;
name|visit
argument_list|(
name|FUNC_NAME_TO_PTR
argument_list|(
name|do_clean_objs
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DISABLE_DESTRUCTOR_KLUDGE
comment|/* some barnacles may yet remain, clinging to typeglobs */
name|visit
argument_list|(
name|FUNC_NAME_TO_PTR
argument_list|(
name|do_clean_named_objs
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PL_in_clean_objs
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|do_clean_all
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|DEBUG_D
argument_list|(
argument|(PerlIO_printf(Perl_debug_log,
literal|"Cleaning loops: SV at 0x%lx\n"
argument|, sv) );
argument_list|)
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator||=
name|SVf_BREAK
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_clean_all
parameter_list|(
name|void
parameter_list|)
block|{
name|PL_in_clean_all
operator|=
name|TRUE
expr_stmt|;
name|visit
argument_list|(
name|FUNC_NAME_TO_PTR
argument_list|(
name|do_clean_all
argument_list|)
argument_list|)
expr_stmt|;
name|PL_in_clean_all
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_free_arenas
parameter_list|(
name|void
parameter_list|)
block|{
name|SV
modifier|*
name|sva
decl_stmt|;
name|SV
modifier|*
name|svanext
decl_stmt|;
comment|/* Free arenas here, but be careful about fake ones.  (We assume        contiguity of the fake ones with the corresponding real ones.) */
for|for
control|(
name|sva
operator|=
name|PL_sv_arenaroot
init|;
name|sva
condition|;
name|sva
operator|=
name|svanext
control|)
block|{
name|svanext
operator|=
operator|(
name|SV
operator|*
operator|)
name|SvANY
argument_list|(
name|sva
argument_list|)
expr_stmt|;
while|while
condition|(
name|svanext
operator|&&
name|SvFAKE
argument_list|(
name|svanext
argument_list|)
condition|)
name|svanext
operator|=
operator|(
name|SV
operator|*
operator|)
name|SvANY
argument_list|(
name|svanext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvFAKE
argument_list|(
name|sva
argument_list|)
condition|)
name|Safefree
argument_list|(
operator|(
name|void
operator|*
operator|)
name|sva
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PL_nice_chunk
condition|)
name|Safefree
argument_list|(
name|PL_nice_chunk
argument_list|)
expr_stmt|;
name|PL_nice_chunk
operator|=
name|Nullch
expr_stmt|;
name|PL_nice_chunk_size
operator|=
literal|0
expr_stmt|;
name|PL_sv_arenaroot
operator|=
literal|0
expr_stmt|;
name|PL_sv_root
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|XPVIV
modifier|*
name|new_xiv
parameter_list|(
name|void
parameter_list|)
block|{
name|IV
modifier|*
name|xiv
decl_stmt|;
name|LOCK_SV_MUTEX
expr_stmt|;
if|if
condition|(
operator|!
name|PL_xiv_root
condition|)
name|more_xiv
argument_list|()
expr_stmt|;
name|xiv
operator|=
name|PL_xiv_root
expr_stmt|;
comment|/*      * See comment in more_xiv() -- RAM.      */
name|PL_xiv_root
operator|=
operator|*
operator|(
name|IV
operator|*
operator|*
operator|)
name|xiv
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
return|return
operator|(
name|XPVIV
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|xiv
operator|-
name|STRUCT_OFFSET
argument_list|(
name|XPVIV
argument_list|,
name|xiv_iv
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|del_xiv
parameter_list|(
name|XPVIV
modifier|*
name|p
parameter_list|)
block|{
name|IV
modifier|*
name|xiv
init|=
operator|(
name|IV
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|)
operator|+
name|STRUCT_OFFSET
argument_list|(
name|XPVIV
argument_list|,
name|xiv_iv
argument_list|)
operator|)
decl_stmt|;
name|LOCK_SV_MUTEX
expr_stmt|;
operator|*
operator|(
name|IV
operator|*
operator|*
operator|)
name|xiv
operator|=
name|PL_xiv_root
expr_stmt|;
name|PL_xiv_root
operator|=
name|xiv
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|more_xiv
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|IV
modifier|*
name|xiv
decl_stmt|;
specifier|register
name|IV
modifier|*
name|xivend
decl_stmt|;
name|XPV
modifier|*
name|ptr
decl_stmt|;
name|New
argument_list|(
literal|705
argument_list|,
name|ptr
argument_list|,
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|XPV
argument_list|)
argument_list|,
name|XPV
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|xpv_pv
operator|=
operator|(
name|char
operator|*
operator|)
name|PL_xiv_arenaroot
expr_stmt|;
comment|/* linked list of xiv arenas */
name|PL_xiv_arenaroot
operator|=
name|ptr
expr_stmt|;
comment|/* to keep Purify happy */
name|xiv
operator|=
operator|(
name|IV
operator|*
operator|)
name|ptr
expr_stmt|;
name|xivend
operator|=
operator|&
name|xiv
index|[
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|IV
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
name|xiv
operator|+=
operator|(
sizeof|sizeof
argument_list|(
name|XPV
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|IV
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* fudge by size of XPV */
name|PL_xiv_root
operator|=
name|xiv
expr_stmt|;
while|while
condition|(
name|xiv
operator|<
name|xivend
condition|)
block|{
operator|*
operator|(
name|IV
operator|*
operator|*
operator|)
name|xiv
operator|=
operator|(
name|IV
operator|*
operator|)
operator|(
name|xiv
operator|+
literal|1
operator|)
expr_stmt|;
name|xiv
operator|++
expr_stmt|;
block|}
operator|*
operator|(
name|IV
operator|*
operator|*
operator|)
name|xiv
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|XPVNV
modifier|*
name|new_xnv
parameter_list|(
name|void
parameter_list|)
block|{
name|double
modifier|*
name|xnv
decl_stmt|;
name|LOCK_SV_MUTEX
expr_stmt|;
if|if
condition|(
operator|!
name|PL_xnv_root
condition|)
name|more_xnv
argument_list|()
expr_stmt|;
name|xnv
operator|=
name|PL_xnv_root
expr_stmt|;
name|PL_xnv_root
operator|=
operator|*
operator|(
name|double
operator|*
operator|*
operator|)
name|xnv
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
return|return
operator|(
name|XPVNV
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|xnv
operator|-
name|STRUCT_OFFSET
argument_list|(
name|XPVNV
argument_list|,
name|xnv_nv
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|del_xnv
parameter_list|(
name|XPVNV
modifier|*
name|p
parameter_list|)
block|{
name|double
modifier|*
name|xnv
init|=
operator|(
name|double
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|)
operator|+
name|STRUCT_OFFSET
argument_list|(
name|XPVNV
argument_list|,
name|xnv_nv
argument_list|)
operator|)
decl_stmt|;
name|LOCK_SV_MUTEX
expr_stmt|;
operator|*
operator|(
name|double
operator|*
operator|*
operator|)
name|xnv
operator|=
name|PL_xnv_root
expr_stmt|;
name|PL_xnv_root
operator|=
name|xnv
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|more_xnv
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|double
modifier|*
name|xnv
decl_stmt|;
specifier|register
name|double
modifier|*
name|xnvend
decl_stmt|;
name|New
argument_list|(
literal|711
argument_list|,
name|xnv
argument_list|,
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|,
name|double
argument_list|)
expr_stmt|;
name|xnvend
operator|=
operator|&
name|xnv
index|[
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
name|xnv
operator|+=
operator|(
sizeof|sizeof
argument_list|(
name|XPVIV
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* fudge by sizeof XPVIV */
name|PL_xnv_root
operator|=
name|xnv
expr_stmt|;
while|while
condition|(
name|xnv
operator|<
name|xnvend
condition|)
block|{
operator|*
operator|(
name|double
operator|*
operator|*
operator|)
name|xnv
operator|=
operator|(
name|double
operator|*
operator|)
operator|(
name|xnv
operator|+
literal|1
operator|)
expr_stmt|;
name|xnv
operator|++
expr_stmt|;
block|}
operator|*
operator|(
name|double
operator|*
operator|*
operator|)
name|xnv
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|XRV
modifier|*
name|new_xrv
parameter_list|(
name|void
parameter_list|)
block|{
name|XRV
modifier|*
name|xrv
decl_stmt|;
name|LOCK_SV_MUTEX
expr_stmt|;
if|if
condition|(
operator|!
name|PL_xrv_root
condition|)
name|more_xrv
argument_list|()
expr_stmt|;
name|xrv
operator|=
name|PL_xrv_root
expr_stmt|;
name|PL_xrv_root
operator|=
operator|(
name|XRV
operator|*
operator|)
name|xrv
operator|->
name|xrv_rv
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
return|return
name|xrv
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|del_xrv
parameter_list|(
name|XRV
modifier|*
name|p
parameter_list|)
block|{
name|LOCK_SV_MUTEX
expr_stmt|;
name|p
operator|->
name|xrv_rv
operator|=
operator|(
name|SV
operator|*
operator|)
name|PL_xrv_root
expr_stmt|;
name|PL_xrv_root
operator|=
name|p
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|more_xrv
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|XRV
modifier|*
name|xrv
decl_stmt|;
specifier|register
name|XRV
modifier|*
name|xrvend
decl_stmt|;
name|New
argument_list|(
literal|712
argument_list|,
name|PL_xrv_root
argument_list|,
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|XRV
argument_list|)
argument_list|,
name|XRV
argument_list|)
expr_stmt|;
name|xrv
operator|=
name|PL_xrv_root
expr_stmt|;
name|xrvend
operator|=
operator|&
name|xrv
index|[
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|XRV
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|xrv
operator|<
name|xrvend
condition|)
block|{
name|xrv
operator|->
name|xrv_rv
operator|=
operator|(
name|SV
operator|*
operator|)
operator|(
name|xrv
operator|+
literal|1
operator|)
expr_stmt|;
name|xrv
operator|++
expr_stmt|;
block|}
name|xrv
operator|->
name|xrv_rv
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|XPV
modifier|*
name|new_xpv
parameter_list|(
name|void
parameter_list|)
block|{
name|XPV
modifier|*
name|xpv
decl_stmt|;
name|LOCK_SV_MUTEX
expr_stmt|;
if|if
condition|(
operator|!
name|PL_xpv_root
condition|)
name|more_xpv
argument_list|()
expr_stmt|;
name|xpv
operator|=
name|PL_xpv_root
expr_stmt|;
name|PL_xpv_root
operator|=
operator|(
name|XPV
operator|*
operator|)
name|xpv
operator|->
name|xpv_pv
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
return|return
name|xpv
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|del_xpv
parameter_list|(
name|XPV
modifier|*
name|p
parameter_list|)
block|{
name|LOCK_SV_MUTEX
expr_stmt|;
name|p
operator|->
name|xpv_pv
operator|=
operator|(
name|char
operator|*
operator|)
name|PL_xpv_root
expr_stmt|;
name|PL_xpv_root
operator|=
name|p
expr_stmt|;
name|UNLOCK_SV_MUTEX
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|more_xpv
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|XPV
modifier|*
name|xpv
decl_stmt|;
specifier|register
name|XPV
modifier|*
name|xpvend
decl_stmt|;
name|New
argument_list|(
literal|713
argument_list|,
name|PL_xpv_root
argument_list|,
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|XPV
argument_list|)
argument_list|,
name|XPV
argument_list|)
expr_stmt|;
name|xpv
operator|=
name|PL_xpv_root
expr_stmt|;
name|xpvend
operator|=
operator|&
name|xpv
index|[
literal|1008
operator|/
sizeof|sizeof
argument_list|(
name|XPV
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|xpv
operator|<
name|xpvend
condition|)
block|{
name|xpv
operator|->
name|xpv_pv
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|xpv
operator|+
literal|1
operator|)
expr_stmt|;
name|xpv
operator|++
expr_stmt|;
block|}
name|xpv
operator|->
name|xpv_pv
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PURIFY
end_ifdef

begin_define
define|#
directive|define
name|new_XIV
parameter_list|()
value|(void*)safemalloc(sizeof(XPVIV))
end_define

begin_define
define|#
directive|define
name|del_XIV
parameter_list|(
name|p
parameter_list|)
value|Safefree((char*)p)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|new_XIV
parameter_list|()
value|(void*)new_xiv()
end_define

begin_define
define|#
directive|define
name|del_XIV
parameter_list|(
name|p
parameter_list|)
value|del_xiv((XPVIV*) p)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PURIFY
end_ifdef

begin_define
define|#
directive|define
name|new_XNV
parameter_list|()
value|(void*)safemalloc(sizeof(XPVNV))
end_define

begin_define
define|#
directive|define
name|del_XNV
parameter_list|(
name|p
parameter_list|)
value|Safefree((char*)p)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|new_XNV
parameter_list|()
value|(void*)new_xnv()
end_define

begin_define
define|#
directive|define
name|del_XNV
parameter_list|(
name|p
parameter_list|)
value|del_xnv((XPVNV*) p)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PURIFY
end_ifdef

begin_define
define|#
directive|define
name|new_XRV
parameter_list|()
value|(void*)safemalloc(sizeof(XRV))
end_define

begin_define
define|#
directive|define
name|del_XRV
parameter_list|(
name|p
parameter_list|)
value|Safefree((char*)p)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|new_XRV
parameter_list|()
value|(void*)new_xrv()
end_define

begin_define
define|#
directive|define
name|del_XRV
parameter_list|(
name|p
parameter_list|)
value|del_xrv((XRV*) p)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PURIFY
end_ifdef

begin_define
define|#
directive|define
name|new_XPV
parameter_list|()
value|(void*)safemalloc(sizeof(XPV))
end_define

begin_define
define|#
directive|define
name|del_XPV
parameter_list|(
name|p
parameter_list|)
value|Safefree((char*)p)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|new_XPV
parameter_list|()
value|(void*)new_xpv()
end_define

begin_define
define|#
directive|define
name|del_XPV
parameter_list|(
name|p
parameter_list|)
value|del_xpv((XPV *)p)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PURIFY
end_ifdef

begin_define
define|#
directive|define
name|my_safemalloc
parameter_list|(
name|s
parameter_list|)
value|safemalloc(s)
end_define

begin_define
define|#
directive|define
name|my_safefree
parameter_list|(
name|s
parameter_list|)
value|free(s)
end_define

begin_else
else|#
directive|else
end_else

begin_function
name|STATIC
name|void
modifier|*
name|my_safemalloc
parameter_list|(
name|MEM_SIZE
name|size
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|New
argument_list|(
literal|717
argument_list|,
name|p
argument_list|,
name|size
argument_list|,
name|char
argument_list|)
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
name|p
return|;
block|}
end_function

begin_define
define|#
directive|define
name|my_safefree
parameter_list|(
name|s
parameter_list|)
value|Safefree(s)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|new_XPVIV
parameter_list|()
value|(void*)my_safemalloc(sizeof(XPVIV))
end_define

begin_define
define|#
directive|define
name|del_XPVIV
parameter_list|(
name|p
parameter_list|)
value|my_safefree((char*)p)
end_define

begin_define
define|#
directive|define
name|new_XPVNV
parameter_list|()
value|(void*)my_safemalloc(sizeof(XPVNV))
end_define

begin_define
define|#
directive|define
name|del_XPVNV
parameter_list|(
name|p
parameter_list|)
value|my_safefree((char*)p)
end_define

begin_define
define|#
directive|define
name|new_XPVMG
parameter_list|()
value|(void*)my_safemalloc(sizeof(XPVMG))
end_define

begin_define
define|#
directive|define
name|del_XPVMG
parameter_list|(
name|p
parameter_list|)
value|my_safefree((char*)p)
end_define

begin_define
define|#
directive|define
name|new_XPVLV
parameter_list|()
value|(void*)my_safemalloc(sizeof(XPVLV))
end_define

begin_define
define|#
directive|define
name|del_XPVLV
parameter_list|(
name|p
parameter_list|)
value|my_safefree((char*)p)
end_define

begin_define
define|#
directive|define
name|new_XPVAV
parameter_list|()
value|(void*)my_safemalloc(sizeof(XPVAV))
end_define

begin_define
define|#
directive|define
name|del_XPVAV
parameter_list|(
name|p
parameter_list|)
value|my_safefree((char*)p)
end_define

begin_define
define|#
directive|define
name|new_XPVHV
parameter_list|()
value|(void*)my_safemalloc(sizeof(XPVHV))
end_define

begin_define
define|#
directive|define
name|del_XPVHV
parameter_list|(
name|p
parameter_list|)
value|my_safefree((char*)p)
end_define

begin_define
define|#
directive|define
name|new_XPVCV
parameter_list|()
value|(void*)my_safemalloc(sizeof(XPVCV))
end_define

begin_define
define|#
directive|define
name|del_XPVCV
parameter_list|(
name|p
parameter_list|)
value|my_safefree((char*)p)
end_define

begin_define
define|#
directive|define
name|new_XPVGV
parameter_list|()
value|(void*)my_safemalloc(sizeof(XPVGV))
end_define

begin_define
define|#
directive|define
name|del_XPVGV
parameter_list|(
name|p
parameter_list|)
value|my_safefree((char*)p)
end_define

begin_define
define|#
directive|define
name|new_XPVBM
parameter_list|()
value|(void*)my_safemalloc(sizeof(XPVBM))
end_define

begin_define
define|#
directive|define
name|del_XPVBM
parameter_list|(
name|p
parameter_list|)
value|my_safefree((char*)p)
end_define

begin_define
define|#
directive|define
name|new_XPVFM
parameter_list|()
value|(void*)my_safemalloc(sizeof(XPVFM))
end_define

begin_define
define|#
directive|define
name|del_XPVFM
parameter_list|(
name|p
parameter_list|)
value|my_safefree((char*)p)
end_define

begin_define
define|#
directive|define
name|new_XPVIO
parameter_list|()
value|(void*)my_safemalloc(sizeof(XPVIO))
end_define

begin_define
define|#
directive|define
name|del_XPVIO
parameter_list|(
name|p
parameter_list|)
value|my_safefree((char*)p)
end_define

begin_function
name|bool
name|sv_upgrade
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
name|U32
name|mt
parameter_list|)
block|{
name|char
modifier|*
name|pv
decl_stmt|;
name|U32
name|cur
decl_stmt|;
name|U32
name|len
decl_stmt|;
name|IV
name|iv
decl_stmt|;
name|double
name|nv
decl_stmt|;
name|MAGIC
modifier|*
name|magic
decl_stmt|;
name|HV
modifier|*
name|stash
decl_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|mt
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|mt
operator|<
name|SVt_PVIV
condition|)
operator|(
name|void
operator|)
name|SvOOK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
case|case
name|SVt_NULL
case|:
name|pv
operator|=
literal|0
expr_stmt|;
name|cur
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|iv
operator|=
literal|0
expr_stmt|;
name|nv
operator|=
literal|0.0
expr_stmt|;
name|magic
operator|=
literal|0
expr_stmt|;
name|stash
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SVt_IV
case|:
name|pv
operator|=
literal|0
expr_stmt|;
name|cur
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|iv
operator|=
name|SvIVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|nv
operator|=
operator|(
name|double
operator|)
name|SvIVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|del_XIV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|magic
operator|=
literal|0
expr_stmt|;
name|stash
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mt
operator|==
name|SVt_NV
condition|)
name|mt
operator|=
name|SVt_PVNV
expr_stmt|;
elseif|else
if|if
condition|(
name|mt
operator|<
name|SVt_PVIV
condition|)
name|mt
operator|=
name|SVt_PVIV
expr_stmt|;
break|break;
case|case
name|SVt_NV
case|:
name|pv
operator|=
literal|0
expr_stmt|;
name|cur
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|nv
operator|=
name|SvNVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|iv
operator|=
name|I_32
argument_list|(
name|nv
argument_list|)
expr_stmt|;
name|magic
operator|=
literal|0
expr_stmt|;
name|stash
operator|=
literal|0
expr_stmt|;
name|del_XNV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mt
operator|<
name|SVt_PVNV
condition|)
name|mt
operator|=
name|SVt_PVNV
expr_stmt|;
break|break;
case|case
name|SVt_RV
case|:
name|pv
operator|=
operator|(
name|char
operator|*
operator|)
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|cur
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|iv
operator|=
operator|(
name|IV
operator|)
name|pv
expr_stmt|;
name|nv
operator|=
operator|(
name|double
operator|)
operator|(
name|unsigned
name|long
operator|)
name|pv
expr_stmt|;
name|del_XRV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|magic
operator|=
literal|0
expr_stmt|;
name|stash
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SVt_PV
case|:
name|pv
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|cur
operator|=
name|SvCUR
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|len
operator|=
name|SvLEN
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|iv
operator|=
literal|0
expr_stmt|;
name|nv
operator|=
literal|0.0
expr_stmt|;
name|magic
operator|=
literal|0
expr_stmt|;
name|stash
operator|=
literal|0
expr_stmt|;
name|del_XPV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mt
operator|<=
name|SVt_IV
condition|)
name|mt
operator|=
name|SVt_PVIV
expr_stmt|;
elseif|else
if|if
condition|(
name|mt
operator|==
name|SVt_NV
condition|)
name|mt
operator|=
name|SVt_PVNV
expr_stmt|;
break|break;
case|case
name|SVt_PVIV
case|:
name|pv
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|cur
operator|=
name|SvCUR
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|len
operator|=
name|SvLEN
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|iv
operator|=
name|SvIVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|nv
operator|=
literal|0.0
expr_stmt|;
name|magic
operator|=
literal|0
expr_stmt|;
name|stash
operator|=
literal|0
expr_stmt|;
name|del_XPVIV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVNV
case|:
name|pv
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|cur
operator|=
name|SvCUR
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|len
operator|=
name|SvLEN
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|iv
operator|=
name|SvIVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|nv
operator|=
name|SvNVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|magic
operator|=
literal|0
expr_stmt|;
name|stash
operator|=
literal|0
expr_stmt|;
name|del_XPVNV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVMG
case|:
name|pv
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|cur
operator|=
name|SvCUR
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|len
operator|=
name|SvLEN
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|iv
operator|=
name|SvIVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|nv
operator|=
name|SvNVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|magic
operator|=
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|stash
operator|=
name|SvSTASH
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|del_XPVMG
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|croak
argument_list|(
literal|"Can't upgrade that kind of scalar"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|mt
condition|)
block|{
case|case
name|SVt_NULL
case|:
name|croak
argument_list|(
literal|"Can't upgrade to undef"
argument_list|)
expr_stmt|;
case|case
name|SVt_IV
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XIV
argument_list|()
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|iv
expr_stmt|;
break|break;
case|case
name|SVt_NV
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XNV
argument_list|()
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
name|nv
expr_stmt|;
break|break;
case|case
name|SVt_RV
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XRV
argument_list|()
expr_stmt|;
name|SvRV
argument_list|(
name|sv
argument_list|)
operator|=
operator|(
name|SV
operator|*
operator|)
name|pv
expr_stmt|;
break|break;
case|case
name|SVt_PV
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XPV
argument_list|()
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
name|pv
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|cur
expr_stmt|;
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|=
name|len
expr_stmt|;
break|break;
case|case
name|SVt_PVIV
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XPVIV
argument_list|()
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
name|pv
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|cur
expr_stmt|;
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|=
name|len
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|iv
expr_stmt|;
if|if
condition|(
name|SvNIOK
argument_list|(
name|sv
argument_list|)
condition|)
operator|(
name|void
operator|)
name|SvIOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvNOK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVNV
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XPVNV
argument_list|()
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
name|pv
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|cur
expr_stmt|;
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|=
name|len
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|iv
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
name|nv
expr_stmt|;
break|break;
case|case
name|SVt_PVMG
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XPVMG
argument_list|()
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
name|pv
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|cur
expr_stmt|;
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|=
name|len
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|iv
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
name|nv
expr_stmt|;
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
operator|=
name|magic
expr_stmt|;
name|SvSTASH
argument_list|(
name|sv
argument_list|)
operator|=
name|stash
expr_stmt|;
break|break;
case|case
name|SVt_PVLV
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XPVLV
argument_list|()
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
name|pv
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|cur
expr_stmt|;
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|=
name|len
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|iv
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
name|nv
expr_stmt|;
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
operator|=
name|magic
expr_stmt|;
name|SvSTASH
argument_list|(
name|sv
argument_list|)
operator|=
name|stash
expr_stmt|;
name|LvTARGOFF
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|LvTARGLEN
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|LvTARG
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|LvTYPE
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SVt_PVAV
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XPVAV
argument_list|()
expr_stmt|;
if|if
condition|(
name|pv
condition|)
name|Safefree
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|AvMAX
argument_list|(
name|sv
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|AvFILLp
argument_list|(
name|sv
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
literal|0.0
expr_stmt|;
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
operator|=
name|magic
expr_stmt|;
name|SvSTASH
argument_list|(
name|sv
argument_list|)
operator|=
name|stash
expr_stmt|;
name|AvALLOC
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|AvARYLEN
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|AvFLAGS
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SVt_PVHV
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XPVHV
argument_list|()
expr_stmt|;
if|if
condition|(
name|pv
condition|)
name|Safefree
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|HvFILL
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|HvMAX
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|HvKEYS
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
literal|0.0
expr_stmt|;
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
operator|=
name|magic
expr_stmt|;
name|SvSTASH
argument_list|(
name|sv
argument_list|)
operator|=
name|stash
expr_stmt|;
name|HvRITER
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|HvEITER
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|HvPMROOT
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|HvNAME
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SVt_PVCV
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XPVCV
argument_list|()
expr_stmt|;
name|Zero
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|,
literal|1
argument_list|,
name|XPVCV
argument_list|)
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
name|pv
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|cur
expr_stmt|;
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|=
name|len
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|iv
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
name|nv
expr_stmt|;
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
operator|=
name|magic
expr_stmt|;
name|SvSTASH
argument_list|(
name|sv
argument_list|)
operator|=
name|stash
expr_stmt|;
break|break;
case|case
name|SVt_PVGV
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XPVGV
argument_list|()
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
name|pv
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|cur
expr_stmt|;
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|=
name|len
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|iv
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
name|nv
expr_stmt|;
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
operator|=
name|magic
expr_stmt|;
name|SvSTASH
argument_list|(
name|sv
argument_list|)
operator|=
name|stash
expr_stmt|;
name|GvGP
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|GvNAME
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|GvNAMELEN
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|GvSTASH
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|GvFLAGS
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SVt_PVBM
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XPVBM
argument_list|()
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
name|pv
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|cur
expr_stmt|;
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|=
name|len
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|iv
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
name|nv
expr_stmt|;
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
operator|=
name|magic
expr_stmt|;
name|SvSTASH
argument_list|(
name|sv
argument_list|)
operator|=
name|stash
expr_stmt|;
name|BmRARE
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|BmUSEFUL
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|BmPREVIOUS
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SVt_PVFM
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XPVFM
argument_list|()
expr_stmt|;
name|Zero
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|,
literal|1
argument_list|,
name|XPVFM
argument_list|)
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
name|pv
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|cur
expr_stmt|;
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|=
name|len
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|iv
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
name|nv
expr_stmt|;
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
operator|=
name|magic
expr_stmt|;
name|SvSTASH
argument_list|(
name|sv
argument_list|)
operator|=
name|stash
expr_stmt|;
break|break;
case|case
name|SVt_PVIO
case|:
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
name|new_XPVIO
argument_list|()
expr_stmt|;
name|Zero
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|,
literal|1
argument_list|,
name|XPVIO
argument_list|)
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
name|pv
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|cur
expr_stmt|;
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|=
name|len
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|iv
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
name|nv
expr_stmt|;
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
operator|=
name|magic
expr_stmt|;
name|SvSTASH
argument_list|(
name|sv
argument_list|)
operator|=
name|stash
expr_stmt|;
name|IoPAGE_LEN
argument_list|(
name|sv
argument_list|)
operator|=
literal|60
expr_stmt|;
break|break;
block|}
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&=
operator|~
name|SVTYPEMASK
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator||=
name|mt
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|sv_peek
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
name|SV
modifier|*
name|t
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
name|STRLEN
name|prevlen
decl_stmt|;
name|int
name|unref
init|=
literal|0
decl_stmt|;
name|sv_setpvn
argument_list|(
name|t
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|retry
label|:
if|if
condition|(
operator|!
name|sv
condition|)
block|{
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|"VOID"
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
elseif|else
if|if
condition|(
name|sv
operator|==
operator|(
name|SV
operator|*
operator|)
literal|0x55555555
operator|||
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
literal|'U'
condition|)
block|{
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|"WILD"
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
elseif|else
if|if
condition|(
name|sv
operator|==
operator|&
name|PL_sv_undef
operator|||
name|sv
operator|==
operator|&
name|PL_sv_no
operator|||
name|sv
operator|==
operator|&
name|PL_sv_yes
condition|)
block|{
if|if
condition|(
name|sv
operator|==
operator|&
name|PL_sv_undef
condition|)
block|{
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|"SV_UNDEF"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
operator|(
name|SVf_OK
operator||
name|SVf_OOK
operator||
name|SVs_OBJECT
operator||
name|SVs_GMG
operator||
name|SVs_SMG
operator||
name|SVs_RMG
operator|)
operator|)
operator|&&
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
condition|)
goto|goto
name|finish
goto|;
block|}
elseif|else
if|if
condition|(
name|sv
operator|==
operator|&
name|PL_sv_no
condition|)
block|{
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|"SV_NO"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
operator|(
name|SVf_ROK
operator||
name|SVf_OOK
operator||
name|SVs_OBJECT
operator||
name|SVs_GMG
operator||
name|SVs_SMG
operator||
name|SVs_RMG
operator|)
operator|)
operator|&&
operator|!
operator|(
operator|~
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
operator|(
name|SVf_POK
operator||
name|SVf_NOK
operator||
name|SVf_READONLY
operator||
name|SVp_POK
operator||
name|SVp_NOK
operator|)
operator|)
operator|&&
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|==
literal|0
operator|&&
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|==
literal|0.0
condition|)
goto|goto
name|finish
goto|;
block|}
else|else
block|{
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|"SV_YES"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
operator|(
name|SVf_ROK
operator||
name|SVf_OOK
operator||
name|SVs_OBJECT
operator||
name|SVs_GMG
operator||
name|SVs_SMG
operator||
name|SVs_RMG
operator|)
operator|)
operator|&&
operator|!
operator|(
operator|~
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
operator|(
name|SVf_POK
operator||
name|SVf_NOK
operator||
name|SVf_READONLY
operator||
name|SVp_POK
operator||
name|SVp_NOK
operator|)
operator|)
operator|&&
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|==
literal|1
operator|&&
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|&&
operator|*
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|==
literal|'1'
operator|&&
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|==
literal|1.0
condition|)
goto|goto
name|finish
goto|;
block|}
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|unref
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|"\\"
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvCUR
argument_list|(
name|t
argument_list|)
operator|+
name|unref
operator|>
literal|10
condition|)
block|{
name|SvCUR
argument_list|(
name|t
argument_list|)
operator|=
name|unref
operator|+
literal|3
expr_stmt|;
operator|*
name|SvEND
argument_list|(
name|t
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
default|default:
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|"FREED"
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
case|case
name|SVt_NULL
case|:
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|"UNDEF"
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
case|case
name|SVt_IV
case|:
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|"IV"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_NV
case|:
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|"NV"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_RV
case|:
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|"RV"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PV
case|:
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|"PV"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVIV
case|:
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|"PVIV"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVNV
case|:
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|"PVNV"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVMG
case|:
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|"PVMG"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVLV
case|:
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|"PVLV"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVAV
case|:
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|"AV"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVHV
case|:
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|"HV"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVCV
case|:
if|if
condition|(
name|CvGV
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_catpvf
argument_list|(
name|t
argument_list|,
literal|"CV(%s)"
argument_list|,
name|GvNAME
argument_list|(
name|CvGV
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|"CV()"
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
case|case
name|SVt_PVGV
case|:
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|"GV"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVBM
case|:
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|"BM"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVFM
case|:
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|"FM"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVIO
case|:
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|"IO"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|SvPOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|SvPVX
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|"(null)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvOOK
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_catpvf
argument_list|(
name|t
argument_list|,
literal|"(%ld+\"%.127s\")"
argument_list|,
operator|(
name|long
operator|)
name|SvIVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sv_catpvf
argument_list|(
name|t
argument_list|,
literal|"(\"%.127s\")"
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SvNOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SET_NUMERIC_STANDARD
argument_list|()
expr_stmt|;
name|sv_catpvf
argument_list|(
name|t
argument_list|,
literal|"(%g)"
argument_list|,
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SvIOKp
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_catpvf
argument_list|(
name|t
argument_list|,
literal|"(%ld)"
argument_list|,
operator|(
name|long
operator|)
name|SvIVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|"()"
argument_list|)
expr_stmt|;
name|finish
label|:
if|if
condition|(
name|unref
condition|)
block|{
while|while
condition|(
name|unref
operator|--
condition|)
name|sv_catpv
argument_list|(
name|t
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
return|return
name|SvPV
argument_list|(
name|t
argument_list|,
name|prevlen
argument_list|)
return|;
else|#
directive|else
comment|/* DEBUGGING */
return|return
literal|""
return|;
endif|#
directive|endif
comment|/* DEBUGGING */
block|}
end_function

begin_function
name|int
name|sv_backoff
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|assert
argument_list|(
name|SvOOK
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvIVX
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
decl_stmt|;
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|+=
name|SvIVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|-=
name|SvIVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvIV_set
argument_list|(
name|sv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Move
argument_list|(
name|s
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&=
operator|~
name|SVf_OOK
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
ifndef|#
directive|ifndef
name|DOSISH
name|sv_grow
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
name|I32
name|newlen
parameter_list|)
else|#
directive|else
function|sv_grow
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
name|unsigned
name|long
name|newlen
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_64K_LIMIT
if|if
condition|(
name|newlen
operator|>=
literal|0x10000
condition|)
block|{
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Allocation too large: %lx\n"
argument_list|,
name|newlen
argument_list|)
expr_stmt|;
name|my_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAS_64K_LIMIT */
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_unref
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|<
name|SVt_PV
condition|)
block|{
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
name|s
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SvOOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
comment|/* pv is offset? */
name|sv_backoff
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|s
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|newlen
operator|>
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
name|newlen
operator|+=
literal|10
operator|*
operator|(
name|newlen
operator|-
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|)
expr_stmt|;
comment|/* avoid copy each time */
ifdef|#
directive|ifdef
name|HAS_64K_LIMIT
if|if
condition|(
name|newlen
operator|>=
literal|0x10000
condition|)
name|newlen
operator|=
literal|0xFFFF
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|s
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|newlen
operator|>
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
block|{
comment|/* need more room? */
if|if
condition|(
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|&&
name|s
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|MYMALLOC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PURIFY
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|LEAKTEST
argument_list|)
name|STRLEN
name|l
init|=
name|malloced_size
argument_list|(
operator|(
name|void
operator|*
operator|)
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|newlen
operator|<=
name|l
condition|)
block|{
name|SvLEN_set
argument_list|(
name|sv
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
else|else
endif|#
directive|endif
name|Renew
argument_list|(
name|s
argument_list|,
name|newlen
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
else|else
name|New
argument_list|(
literal|703
argument_list|,
name|s
argument_list|,
name|newlen
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|SvPV_set
argument_list|(
name|sv
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|SvLEN_set
argument_list|(
name|sv
argument_list|,
name|newlen
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
name|void
name|sv_setiv
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
name|IV
name|i
parameter_list|)
block|{
name|SV_CHECK_THINKFIRST
argument_list|(
name|sv
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
case|case
name|SVt_NULL
case|:
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_IV
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_NV
case|:
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_RV
case|:
case|case
name|SVt_PV
case|:
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVIV
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVGV
case|:
if|if
condition|(
name|SvFAKE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|sv_unglob
argument_list|(
name|sv
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALL THROUGH */
case|case
name|SVt_PVAV
case|:
case|case
name|SVt_PVHV
case|:
case|case
name|SVt_PVCV
case|:
case|case
name|SVt_PVFM
case|:
case|case
name|SVt_PVIO
case|:
block|{
name|dTHR
expr_stmt|;
name|croak
argument_list|(
literal|"Can't coerce %s to integer in %s"
argument_list|,
name|sv_reftype
argument_list|(
name|sv
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op_desc
index|[
name|PL_op
operator|->
name|op_type
index|]
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|SvIOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* validate number */
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|i
expr_stmt|;
name|SvTAINT
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_setiv_mg
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
name|IV
name|i
parameter_list|)
block|{
name|sv_setiv
argument_list|(
name|sv
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_setuv
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
name|UV
name|u
parameter_list|)
block|{
if|if
condition|(
name|u
operator|<=
name|IV_MAX
condition|)
name|sv_setiv
argument_list|(
name|sv
argument_list|,
name|u
argument_list|)
expr_stmt|;
else|else
name|sv_setnv
argument_list|(
name|sv
argument_list|,
operator|(
name|double
operator|)
name|u
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_setuv_mg
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
name|UV
name|u
parameter_list|)
block|{
name|sv_setuv
argument_list|(
name|sv
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_setnv
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
name|double
name|num
parameter_list|)
block|{
name|SV_CHECK_THINKFIRST
argument_list|(
name|sv
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
case|case
name|SVt_NULL
case|:
case|case
name|SVt_IV
case|:
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_NV
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_RV
case|:
case|case
name|SVt_PV
case|:
case|case
name|SVt_PVIV
case|:
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVGV
case|:
if|if
condition|(
name|SvFAKE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|sv_unglob
argument_list|(
name|sv
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALL THROUGH */
case|case
name|SVt_PVAV
case|:
case|case
name|SVt_PVHV
case|:
case|case
name|SVt_PVCV
case|:
case|case
name|SVt_PVFM
case|:
case|case
name|SVt_PVIO
case|:
block|{
name|dTHR
expr_stmt|;
name|croak
argument_list|(
literal|"Can't coerce %s to number in %s"
argument_list|,
name|sv_reftype
argument_list|(
name|sv
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op_name
index|[
name|PL_op
operator|->
name|op_type
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
name|num
expr_stmt|;
operator|(
name|void
operator|)
name|SvNOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* validate number */
name|SvTAINT
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_setnv_mg
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
name|double
name|num
parameter_list|)
block|{
name|sv_setnv
argument_list|(
name|sv
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|not_a_number
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|char
name|tmpbuf
index|[
literal|64
index|]
decl_stmt|;
name|char
modifier|*
name|d
init|=
name|tmpbuf
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|limit
init|=
name|tmpbuf
operator|+
sizeof|sizeof
argument_list|(
name|tmpbuf
argument_list|)
operator|-
literal|8
decl_stmt|;
comment|/* each *s can expand to 4 chars + "...\0",                      i.e. need room for 8 chars */
for|for
control|(
name|s
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
init|;
operator|*
name|s
operator|&&
name|d
operator|<
name|limit
condition|;
name|s
operator|++
control|)
block|{
name|int
name|ch
init|=
operator|*
name|s
operator|&
literal|0xFF
decl_stmt|;
if|if
condition|(
name|ch
operator|&
literal|128
operator|&&
operator|!
name|isPRINT_LC
argument_list|(
name|ch
argument_list|)
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|'M'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|'-'
expr_stmt|;
name|ch
operator|&=
literal|127
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|'n'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\r'
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|'r'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\f'
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|'f'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|'\\'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isPRINT_LC
argument_list|(
name|ch
argument_list|)
condition|)
operator|*
name|d
operator|++
operator|=
name|ch
expr_stmt|;
else|else
block|{
operator|*
name|d
operator|++
operator|=
literal|'^'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|toCTRL
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|s
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|PL_op
condition|)
name|warn
argument_list|(
literal|"Argument \"%s\" isn't numeric in %s"
argument_list|,
name|tmpbuf
argument_list|,
name|op_name
index|[
name|PL_op
operator|->
name|op_type
index|]
argument_list|)
expr_stmt|;
else|else
name|warn
argument_list|(
literal|"Argument \"%s\" isn't numeric"
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|IV
name|sv_2iv
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sv
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvIOKp
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|SvIVX
argument_list|(
name|sv
argument_list|)
return|;
if|if
condition|(
name|SvNOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|<
literal|0.0
condition|)
return|return
name|I_V
argument_list|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
return|;
else|else
return|return
operator|(
name|IV
operator|)
name|U_V
argument_list|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|SvPOKp
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|asIV
argument_list|(
name|sv
argument_list|)
return|;
if|if
condition|(
operator|!
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_dowarn
operator|&&
operator|!
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
name|SVs_PADTMP
operator|)
condition|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
operator|!
name|PL_localizing
condition|)
name|warn
argument_list|(
name|warn_uninit
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|SvTHINKFIRST
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|OVERLOAD
name|SV
modifier|*
name|tmpstr
decl_stmt|;
if|if
condition|(
name|SvAMAGIC
argument_list|(
name|sv
argument_list|)
operator|&&
operator|(
name|tmpstr
operator|=
name|AMG_CALLun
argument_list|(
name|sv
argument_list|,
name|numer
argument_list|)
operator|)
condition|)
return|return
name|SvIV
argument_list|(
name|tmpstr
argument_list|)
return|;
endif|#
directive|endif
comment|/* OVERLOAD */
return|return
operator|(
name|IV
operator|)
name|SvRV
argument_list|(
name|sv
argument_list|)
return|;
block|}
if|if
condition|(
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvNOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|<
literal|0.0
condition|)
return|return
name|I_V
argument_list|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
return|;
else|else
return|return
operator|(
name|IV
operator|)
name|U_V
argument_list|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|SvPOKp
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|asIV
argument_list|(
name|sv
argument_list|)
return|;
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
name|warn_uninit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
case|case
name|SVt_NULL
case|:
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_IV
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PV
case|:
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVIV
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_NV
case|:
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|SvNOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|SvIOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|<
literal|0.0
condition|)
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|I_V
argument_list|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SvUVX
argument_list|(
name|sv
argument_list|)
operator|=
name|U_V
argument_list|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SvPOKp
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|SvIOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|asIV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
name|PL_dowarn
operator|&&
operator|!
name|PL_localizing
operator|&&
operator|!
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
name|SVs_PADTMP
operator|)
condition|)
name|warn
argument_list|(
name|warn_uninit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DEBUG_c
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%lx 2iv(%ld)\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sv
argument_list|,
operator|(
name|long
operator|)
name|SvIVX
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SvIVX
argument_list|(
name|sv
argument_list|)
return|;
block|}
end_function

begin_function
name|UV
name|sv_2uv
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sv
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvIOKp
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|SvUVX
argument_list|(
name|sv
argument_list|)
return|;
if|if
condition|(
name|SvNOKp
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|U_V
argument_list|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|SvPOKp
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|asUV
argument_list|(
name|sv
argument_list|)
return|;
if|if
condition|(
operator|!
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_dowarn
operator|&&
operator|!
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
name|SVs_PADTMP
operator|)
condition|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
operator|!
name|PL_localizing
condition|)
name|warn
argument_list|(
name|warn_uninit
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|SvTHINKFIRST
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|OVERLOAD
name|SV
modifier|*
name|tmpstr
decl_stmt|;
if|if
condition|(
name|SvAMAGIC
argument_list|(
name|sv
argument_list|)
operator|&&
operator|(
name|tmpstr
operator|=
name|AMG_CALLun
argument_list|(
name|sv
argument_list|,
name|numer
argument_list|)
operator|)
condition|)
return|return
name|SvUV
argument_list|(
name|tmpstr
argument_list|)
return|;
endif|#
directive|endif
comment|/* OVERLOAD */
return|return
operator|(
name|UV
operator|)
name|SvRV
argument_list|(
name|sv
argument_list|)
return|;
block|}
if|if
condition|(
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvNOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
return|return
name|U_V
argument_list|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|SvPOKp
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|asUV
argument_list|(
name|sv
argument_list|)
return|;
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
name|warn_uninit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
case|case
name|SVt_NULL
case|:
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_IV
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PV
case|:
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVIV
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_NV
case|:
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|SvNOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|SvIOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvUVX
argument_list|(
name|sv
argument_list|)
operator|=
name|U_V
argument_list|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SvPOKp
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|SvIOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvUVX
argument_list|(
name|sv
argument_list|)
operator|=
name|asUV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|PL_dowarn
operator|&&
operator|!
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
name|SVs_PADTMP
operator|)
condition|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
operator|!
name|PL_localizing
condition|)
name|warn
argument_list|(
name|warn_uninit
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|DEBUG_c
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%lx 2uv(%lu)\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sv
argument_list|,
name|SvUVX
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SvUVX
argument_list|(
name|sv
argument_list|)
return|;
block|}
end_function

begin_function
name|double
name|sv_2nv
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sv
condition|)
return|return
literal|0.0
return|;
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvNOKp
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|SvNVX
argument_list|(
name|sv
argument_list|)
return|;
if|if
condition|(
name|SvPOKp
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_dowarn
operator|&&
operator|!
name|SvIOKp
argument_list|(
name|sv
argument_list|)
operator|&&
operator|!
name|looks_like_number
argument_list|(
name|sv
argument_list|)
condition|)
name|not_a_number
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SET_NUMERIC_STANDARD
argument_list|()
expr_stmt|;
return|return
name|atof
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|SvIOKp
argument_list|(
name|sv
argument_list|)
condition|)
return|return
operator|(
name|double
operator|)
name|SvIVX
argument_list|(
name|sv
argument_list|)
return|;
if|if
condition|(
operator|!
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_dowarn
operator|&&
operator|!
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
name|SVs_PADTMP
operator|)
condition|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
operator|!
name|PL_localizing
condition|)
name|warn
argument_list|(
name|warn_uninit
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|SvTHINKFIRST
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|OVERLOAD
name|SV
modifier|*
name|tmpstr
decl_stmt|;
if|if
condition|(
name|SvAMAGIC
argument_list|(
name|sv
argument_list|)
operator|&&
operator|(
name|tmpstr
operator|=
name|AMG_CALLun
argument_list|(
name|sv
argument_list|,
name|numer
argument_list|)
operator|)
condition|)
return|return
name|SvNV
argument_list|(
name|tmpstr
argument_list|)
return|;
endif|#
directive|endif
comment|/* OVERLOAD */
return|return
operator|(
name|double
operator|)
operator|(
name|unsigned
name|long
operator|)
name|SvRV
argument_list|(
name|sv
argument_list|)
return|;
block|}
if|if
condition|(
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvPOKp
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_dowarn
operator|&&
operator|!
name|SvIOKp
argument_list|(
name|sv
argument_list|)
operator|&&
operator|!
name|looks_like_number
argument_list|(
name|sv
argument_list|)
condition|)
name|not_a_number
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SET_NUMERIC_STANDARD
argument_list|()
expr_stmt|;
return|return
name|atof
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|SvIOKp
argument_list|(
name|sv
argument_list|)
condition|)
return|return
operator|(
name|double
operator|)
name|SvIVX
argument_list|(
name|sv
argument_list|)
return|;
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
name|warn_uninit
argument_list|)
expr_stmt|;
return|return
literal|0.0
return|;
block|}
block|}
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|<
name|SVt_NV
condition|)
block|{
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_IV
condition|)
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
else|else
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_NV
argument_list|)
expr_stmt|;
name|DEBUG_c
argument_list|(
name|SET_NUMERIC_STANDARD
argument_list|()
argument_list|)
expr_stmt|;
name|DEBUG_c
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%lx num(%g)\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sv
argument_list|,
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|<
name|SVt_PVNV
condition|)
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvIOKp
argument_list|(
name|sv
argument_list|)
operator|&&
operator|(
operator|!
name|SvPOKp
argument_list|(
name|sv
argument_list|)
operator|||
operator|!
name|strchr
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
literal|'.'
argument_list|)
operator|||
operator|!
name|looks_like_number
argument_list|(
name|sv
argument_list|)
operator|)
condition|)
block|{
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
operator|(
name|double
operator|)
name|SvIVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SvPOKp
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_dowarn
operator|&&
operator|!
name|SvIOKp
argument_list|(
name|sv
argument_list|)
operator|&&
operator|!
name|looks_like_number
argument_list|(
name|sv
argument_list|)
condition|)
name|not_a_number
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SET_NUMERIC_STANDARD
argument_list|()
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
name|atof
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
name|PL_dowarn
operator|&&
operator|!
name|PL_localizing
operator|&&
operator|!
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
name|SVs_PADTMP
operator|)
condition|)
name|warn
argument_list|(
name|warn_uninit
argument_list|)
expr_stmt|;
return|return
literal|0.0
return|;
block|}
name|SvNOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|DEBUG_c
argument_list|(
name|SET_NUMERIC_STANDARD
argument_list|()
argument_list|)
expr_stmt|;
name|DEBUG_c
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%lx 2nv(%g)\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sv
argument_list|,
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SvNVX
argument_list|(
name|sv
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|IV
name|asIV
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|I32
name|numtype
init|=
name|looks_like_number
argument_list|(
name|sv
argument_list|)
decl_stmt|;
name|double
name|d
decl_stmt|;
if|if
condition|(
name|numtype
operator|==
literal|1
condition|)
return|return
name|atol
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|numtype
operator|&&
name|PL_dowarn
condition|)
name|not_a_number
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SET_NUMERIC_STANDARD
argument_list|()
expr_stmt|;
name|d
operator|=
name|atof
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0.0
condition|)
return|return
name|I_V
argument_list|(
name|d
argument_list|)
return|;
else|else
return|return
operator|(
name|IV
operator|)
name|U_V
argument_list|(
name|d
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|UV
name|asUV
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|I32
name|numtype
init|=
name|looks_like_number
argument_list|(
name|sv
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_STRTOUL
if|if
condition|(
name|numtype
operator|==
literal|1
condition|)
return|return
name|strtoul
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|Null
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|,
literal|10
argument_list|)
return|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|numtype
operator|&&
name|PL_dowarn
condition|)
name|not_a_number
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SET_NUMERIC_STANDARD
argument_list|()
expr_stmt|;
return|return
name|U_V
argument_list|(
name|atof
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|I32
name|looks_like_number
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|send
decl_stmt|;
specifier|register
name|char
modifier|*
name|sbegin
decl_stmt|;
name|I32
name|numtype
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
if|if
condition|(
name|SvPOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|sbegin
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|len
operator|=
name|SvCUR
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SvPOKp
argument_list|(
name|sv
argument_list|)
condition|)
name|sbegin
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
return|return
literal|1
return|;
name|send
operator|=
name|sbegin
operator|+
name|len
expr_stmt|;
name|s
operator|=
name|sbegin
expr_stmt|;
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
operator|||
operator|*
name|s
operator|==
literal|'-'
condition|)
name|s
operator|++
expr_stmt|;
comment|/* next must be digit or '.' */
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
do|do
block|{
name|s
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
block|{
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
comment|/* optional digits after "." */
name|s
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
block|{
name|s
operator|++
expr_stmt|;
comment|/* no digits before '.' means we need digits after it */
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
do|do
block|{
name|s
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
block|}
else|else
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
comment|/*      * we return 1 if the number can be converted to _integer_ with atol()      * and 2 if you need (int)atof().      */
name|numtype
operator|=
literal|1
expr_stmt|;
comment|/* we can have an optional exponent part */
if|if
condition|(
operator|*
name|s
operator|==
literal|'e'
operator|||
operator|*
name|s
operator|==
literal|'E'
condition|)
block|{
name|numtype
operator|=
literal|2
expr_stmt|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
operator|||
operator|*
name|s
operator|==
literal|'-'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
do|do
block|{
name|s
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
block|}
else|else
return|return
literal|0
return|;
block|}
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|>=
name|send
condition|)
return|return
name|numtype
return|;
if|if
condition|(
name|len
operator|==
literal|10
operator|&&
name|memEQ
argument_list|(
name|sbegin
argument_list|,
literal|"0 but true"
argument_list|,
literal|10
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|sv_2pv
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
name|STRLEN
modifier|*
name|lp
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|olderrno
decl_stmt|;
name|SV
modifier|*
name|tsv
decl_stmt|;
name|char
name|tmpbuf
index|[
literal|64
index|]
decl_stmt|;
comment|/* Must fit sprintf/Gconvert of longest IV/NV */
if|if
condition|(
operator|!
name|sv
condition|)
block|{
operator|*
name|lp
operator|=
literal|0
expr_stmt|;
return|return
literal|""
return|;
block|}
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvPOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
operator|*
name|lp
operator|=
name|SvCUR
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|SvPVX
argument_list|(
name|sv
argument_list|)
return|;
block|}
if|if
condition|(
name|SvIOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|SvIVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|tsv
operator|=
name|Nullsv
expr_stmt|;
goto|goto
name|tokensave
goto|;
block|}
if|if
condition|(
name|SvNOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SET_NUMERIC_STANDARD
argument_list|()
expr_stmt|;
name|Gconvert
argument_list|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|DBL_DIG
argument_list|,
literal|0
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
name|tsv
operator|=
name|Nullsv
expr_stmt|;
goto|goto
name|tokensave
goto|;
block|}
if|if
condition|(
operator|!
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_dowarn
operator|&&
operator|!
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
name|SVs_PADTMP
operator|)
condition|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
operator|!
name|PL_localizing
condition|)
name|warn
argument_list|(
name|warn_uninit
argument_list|)
expr_stmt|;
block|}
operator|*
name|lp
operator|=
literal|0
expr_stmt|;
return|return
literal|""
return|;
block|}
block|}
if|if
condition|(
name|SvTHINKFIRST
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|OVERLOAD
name|SV
modifier|*
name|tmpstr
decl_stmt|;
if|if
condition|(
name|SvAMAGIC
argument_list|(
name|sv
argument_list|)
operator|&&
operator|(
name|tmpstr
operator|=
name|AMG_CALLun
argument_list|(
name|sv
argument_list|,
name|string
argument_list|)
operator|)
condition|)
return|return
name|SvPV
argument_list|(
name|tmpstr
argument_list|,
operator|*
name|lp
argument_list|)
return|;
endif|#
directive|endif
comment|/* OVERLOAD */
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
name|s
operator|=
literal|"NULLREF"
expr_stmt|;
else|else
block|{
name|MAGIC
modifier|*
name|mg
decl_stmt|;
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
case|case
name|SVt_PVMG
case|:
if|if
condition|(
operator|(
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
operator|(
name|SVs_OBJECT
operator||
name|SVf_OK
operator||
name|SVs_GMG
operator||
name|SVs_SMG
operator||
name|SVs_RMG
operator|)
operator|)
operator|==
operator|(
name|SVs_OBJECT
operator||
name|SVs_RMG
operator|)
operator|)
operator|&&
name|strEQ
argument_list|(
name|s
operator|=
name|HvNAME
argument_list|(
name|SvSTASH
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|,
literal|"Regexp"
argument_list|)
operator|&&
operator|(
name|mg
operator|=
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'r'
argument_list|)
operator|)
condition|)
block|{
name|dTHR
expr_stmt|;
name|regexp
modifier|*
name|re
init|=
operator|(
name|regexp
operator|*
operator|)
name|mg
operator|->
name|mg_obj
decl_stmt|;
if|if
condition|(
operator|!
name|mg
operator|->
name|mg_ptr
condition|)
block|{
name|char
modifier|*
name|fptr
init|=
literal|"msix"
decl_stmt|;
name|char
name|reflags
index|[
literal|6
index|]
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|int
name|left
init|=
literal|0
decl_stmt|;
name|int
name|right
init|=
literal|4
decl_stmt|;
name|U16
name|reganch
init|=
operator|(
name|re
operator|->
name|reganch
operator|&
name|PMf_COMPILETIME
operator|)
operator|>>
literal|12
decl_stmt|;
while|while
condition|(
name|ch
operator|=
operator|*
name|fptr
operator|++
condition|)
block|{
if|if
condition|(
name|reganch
operator|&
literal|1
condition|)
block|{
name|reflags
index|[
name|left
operator|++
index|]
operator|=
name|ch
expr_stmt|;
block|}
else|else
block|{
name|reflags
index|[
name|right
operator|--
index|]
operator|=
name|ch
expr_stmt|;
block|}
name|reganch
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|left
operator|!=
literal|4
condition|)
block|{
name|reflags
index|[
name|left
index|]
operator|=
literal|'-'
expr_stmt|;
name|left
operator|=
literal|5
expr_stmt|;
block|}
name|mg
operator|->
name|mg_len
operator|=
name|re
operator|->
name|prelen
operator|+
literal|4
operator|+
name|left
expr_stmt|;
name|New
argument_list|(
literal|616
argument_list|,
name|mg
operator|->
name|mg_ptr
argument_list|,
name|mg
operator|->
name|mg_len
operator|+
literal|1
operator|+
name|left
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
literal|"(?"
argument_list|,
name|mg
operator|->
name|mg_ptr
argument_list|,
literal|2
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|reflags
argument_list|,
name|mg
operator|->
name|mg_ptr
operator|+
literal|2
argument_list|,
name|left
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
literal|":"
argument_list|,
name|mg
operator|->
name|mg_ptr
operator|+
name|left
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|re
operator|->
name|precomp
argument_list|,
name|mg
operator|->
name|mg_ptr
operator|+
literal|3
operator|+
name|left
argument_list|,
name|re
operator|->
name|prelen
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|mg
operator|->
name|mg_ptr
index|[
name|mg
operator|->
name|mg_len
operator|-
literal|1
index|]
operator|=
literal|')'
expr_stmt|;
name|mg
operator|->
name|mg_ptr
index|[
name|mg
operator|->
name|mg_len
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|PL_reginterp_cnt
operator|+=
name|re
operator|->
name|program
index|[
literal|0
index|]
operator|.
name|next_off
expr_stmt|;
operator|*
name|lp
operator|=
name|mg
operator|->
name|mg_len
expr_stmt|;
return|return
name|mg
operator|->
name|mg_ptr
return|;
block|}
comment|/* Fall through */
case|case
name|SVt_NULL
case|:
case|case
name|SVt_IV
case|:
case|case
name|SVt_NV
case|:
case|case
name|SVt_RV
case|:
case|case
name|SVt_PV
case|:
case|case
name|SVt_PVIV
case|:
case|case
name|SVt_PVNV
case|:
case|case
name|SVt_PVBM
case|:
name|s
operator|=
literal|"SCALAR"
expr_stmt|;
break|break;
case|case
name|SVt_PVLV
case|:
name|s
operator|=
literal|"LVALUE"
expr_stmt|;
break|break;
case|case
name|SVt_PVAV
case|:
name|s
operator|=
literal|"ARRAY"
expr_stmt|;
break|break;
case|case
name|SVt_PVHV
case|:
name|s
operator|=
literal|"HASH"
expr_stmt|;
break|break;
case|case
name|SVt_PVCV
case|:
name|s
operator|=
literal|"CODE"
expr_stmt|;
break|break;
case|case
name|SVt_PVGV
case|:
name|s
operator|=
literal|"GLOB"
expr_stmt|;
break|break;
case|case
name|SVt_PVFM
case|:
name|s
operator|=
literal|"FORMAT"
expr_stmt|;
break|break;
case|case
name|SVt_PVIO
case|:
name|s
operator|=
literal|"IO"
expr_stmt|;
break|break;
default|default:
name|s
operator|=
literal|"UNKNOWN"
expr_stmt|;
break|break;
block|}
name|tsv
operator|=
name|NEWSV
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvOBJECT
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_setpvf
argument_list|(
name|tsv
argument_list|,
literal|"%s=%s"
argument_list|,
name|HvNAME
argument_list|(
name|SvSTASH
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|sv_setpv
argument_list|(
name|tsv
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|sv_catpvf
argument_list|(
name|tsv
argument_list|,
literal|"(0x%lx)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sv
argument_list|)
expr_stmt|;
goto|goto
name|tokensaveref
goto|;
block|}
operator|*
name|lp
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
if|if
condition|(
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvNOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SET_NUMERIC_STANDARD
argument_list|()
expr_stmt|;
name|Gconvert
argument_list|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|DBL_DIG
argument_list|,
literal|0
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
name|tsv
operator|=
name|Nullsv
expr_stmt|;
goto|goto
name|tokensave
goto|;
block|}
if|if
condition|(
name|SvIOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|SvIVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|tsv
operator|=
name|Nullsv
expr_stmt|;
goto|goto
name|tokensave
goto|;
block|}
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
name|warn_uninit
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|=
literal|0
expr_stmt|;
return|return
literal|""
return|;
block|}
block|}
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvNOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|<
name|SVt_PVNV
condition|)
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|sv
argument_list|,
literal|28
argument_list|)
expr_stmt|;
name|s
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|olderrno
operator|=
name|errno
expr_stmt|;
comment|/* some Xenix systems wipe out errno here */
ifdef|#
directive|ifdef
name|apollo
if|if
condition|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|==
literal|0.0
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|s
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/*apollo*/
block|{
name|SET_NUMERIC_STANDARD
argument_list|()
expr_stmt|;
name|Gconvert
argument_list|(
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|DBL_DIG
argument_list|,
literal|0
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
name|olderrno
expr_stmt|;
ifdef|#
directive|ifdef
name|FIXNEGATIVEZERO
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'0'
operator|&&
operator|!
name|s
index|[
literal|2
index|]
condition|)
name|strcpy
argument_list|(
name|s
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|hcx
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
operator|*
operator|--
name|s
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|SvIOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|U32
name|oldIOK
init|=
name|SvIOK
argument_list|(
name|sv
argument_list|)
decl_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|<
name|SVt_PVIV
condition|)
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVIV
argument_list|)
expr_stmt|;
name|olderrno
operator|=
name|errno
expr_stmt|;
comment|/* some Xenix systems wipe out errno here */
name|sv_setpviv
argument_list|(
name|sv
argument_list|,
name|SvIVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|errno
operator|=
name|olderrno
expr_stmt|;
name|s
operator|=
name|SvEND
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldIOK
condition|)
name|SvIOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
else|else
name|SvIOKp_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
name|PL_dowarn
operator|&&
operator|!
name|PL_localizing
operator|&&
operator|!
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
name|SVs_PADTMP
operator|)
condition|)
name|warn
argument_list|(
name|warn_uninit
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|=
literal|0
expr_stmt|;
return|return
literal|""
return|;
block|}
operator|*
name|lp
operator|=
name|s
operator|-
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
operator|*
name|lp
argument_list|)
expr_stmt|;
name|SvPOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|DEBUG_c
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%lx 2pv(%s)\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sv
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SvPVX
argument_list|(
name|sv
argument_list|)
return|;
name|tokensave
label|:
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
comment|/* XXX Skip this when sv_pvn_force calls */
comment|/* Sneaky stuff here */
name|tokensaveref
label|:
if|if
condition|(
operator|!
name|tsv
condition|)
name|tsv
operator|=
name|newSVpv
argument_list|(
name|tmpbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_2mortal
argument_list|(
name|tsv
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|=
name|SvCUR
argument_list|(
name|tsv
argument_list|)
expr_stmt|;
return|return
name|SvPVX
argument_list|(
name|tsv
argument_list|)
return|;
block|}
else|else
block|{
name|STRLEN
name|len
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|tsv
condition|)
block|{
name|sv_2mortal
argument_list|(
name|tsv
argument_list|)
expr_stmt|;
name|t
operator|=
name|SvPVX
argument_list|(
name|tsv
argument_list|)
expr_stmt|;
name|len
operator|=
name|SvCUR
argument_list|(
name|tsv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|tmpbuf
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FIXNEGATIVEZERO
if|if
condition|(
name|len
operator|==
literal|2
operator|&&
name|t
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|t
index|[
literal|1
index|]
operator|==
literal|'0'
condition|)
block|{
name|t
operator|=
literal|"0"
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|=
name|len
expr_stmt|;
name|s
operator|=
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|SvPOKp_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
end_function

begin_comment
comment|/* This function is only called on magical items */
end_comment

begin_function
name|bool
name|sv_2bool
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvOK
argument_list|(
name|sv
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|OVERLOAD
block|{
name|dTHR
expr_stmt|;
name|SV
modifier|*
name|tmpsv
decl_stmt|;
if|if
condition|(
name|SvAMAGIC
argument_list|(
name|sv
argument_list|)
operator|&&
operator|(
name|tmpsv
operator|=
name|AMG_CALLun
argument_list|(
name|sv
argument_list|,
name|bool_
argument_list|)
operator|)
condition|)
return|return
name|SvTRUE
argument_list|(
name|tmpsv
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* OVERLOAD */
return|return
name|SvRV
argument_list|(
name|sv
argument_list|)
operator|!=
literal|0
return|;
block|}
if|if
condition|(
name|SvPOKp
argument_list|(
name|sv
argument_list|)
condition|)
block|{
specifier|register
name|XPV
modifier|*
name|Xpvtmp
decl_stmt|;
if|if
condition|(
operator|(
name|Xpvtmp
operator|=
operator|(
name|XPV
operator|*
operator|)
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|)
operator|&&
operator|(
operator|*
name|Xpvtmp
operator|->
name|xpv_pv
operator|>
literal|'0'
operator|||
name|Xpvtmp
operator|->
name|xpv_cur
operator|>
literal|1
operator|||
operator|(
name|Xpvtmp
operator|->
name|xpv_cur
operator|&&
operator|*
name|Xpvtmp
operator|->
name|xpv_pv
operator|!=
literal|'0'
operator|)
operator|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|SvIOKp
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|!=
literal|0
return|;
else|else
block|{
if|if
condition|(
name|SvNOKp
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|!=
literal|0.0
return|;
else|else
return|return
name|FALSE
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Note: sv_setsv() should not be called with a source string that needs  * to be reused, since it may destroy the source string if it is marked  * as temporary.  */
end_comment

begin_function
name|void
name|sv_setsv
parameter_list|(
name|SV
modifier|*
name|dstr
parameter_list|,
specifier|register
name|SV
modifier|*
name|sstr
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|U32
name|sflags
decl_stmt|;
specifier|register
name|int
name|dtype
decl_stmt|;
specifier|register
name|int
name|stype
decl_stmt|;
if|if
condition|(
name|sstr
operator|==
name|dstr
condition|)
return|return;
name|SV_CHECK_THINKFIRST
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sstr
condition|)
name|sstr
operator|=
operator|&
name|PL_sv_undef
expr_stmt|;
name|stype
operator|=
name|SvTYPE
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|dtype
operator|=
name|SvTYPE
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtype
operator|==
name|SVt_PVGV
operator|&&
operator|(
name|SvFLAGS
argument_list|(
name|dstr
argument_list|)
operator|&
name|SVf_FAKE
operator|)
condition|)
block|{
name|sv_unglob
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
comment|/* so fake GLOB won't perpetuate */
name|sv_setpvn
argument_list|(
name|dstr
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|dtype
operator|=
name|SvTYPE
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OVERLOAD
name|SvAMAGIC_off
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OVERLOAD */
comment|/* There's a lot of redundancy below but we're going for speed here */
switch|switch
condition|(
name|stype
condition|)
block|{
case|case
name|SVt_NULL
case|:
name|undef_sstr
label|:
if|if
condition|(
name|dtype
operator|!=
name|SVt_PVGV
condition|)
block|{
operator|(
name|void
operator|)
name|SvOK_off
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|SVt_IV
case|:
if|if
condition|(
name|SvIOK
argument_list|(
name|sstr
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|dtype
condition|)
block|{
case|case
name|SVt_NULL
case|:
name|sv_upgrade
argument_list|(
name|dstr
argument_list|,
name|SVt_IV
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_NV
case|:
name|sv_upgrade
argument_list|(
name|dstr
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_RV
case|:
case|case
name|SVt_PV
case|:
name|sv_upgrade
argument_list|(
name|dstr
argument_list|,
name|SVt_PVIV
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|SvIOK_only
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvIVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvTAINT
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
return|return;
block|}
goto|goto
name|undef_sstr
goto|;
case|case
name|SVt_NV
case|:
if|if
condition|(
name|SvNOK
argument_list|(
name|sstr
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|dtype
condition|)
block|{
case|case
name|SVt_NULL
case|:
case|case
name|SVt_IV
case|:
name|sv_upgrade
argument_list|(
name|dstr
argument_list|,
name|SVt_NV
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_RV
case|:
case|case
name|SVt_PV
case|:
case|case
name|SVt_PVIV
case|:
name|sv_upgrade
argument_list|(
name|dstr
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
break|break;
block|}
name|SvNVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvNVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvNOK_only
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|SvTAINT
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
return|return;
block|}
goto|goto
name|undef_sstr
goto|;
case|case
name|SVt_RV
case|:
if|if
condition|(
name|dtype
operator|<
name|SVt_RV
condition|)
name|sv_upgrade
argument_list|(
name|dstr
argument_list|,
name|SVt_RV
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dtype
operator|==
name|SVt_PVGV
operator|&&
name|SvTYPE
argument_list|(
name|SvRV
argument_list|(
name|sstr
argument_list|)
argument_list|)
operator|==
name|SVt_PVGV
condition|)
block|{
name|sstr
operator|=
name|SvRV
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sstr
operator|==
name|dstr
condition|)
block|{
if|if
condition|(
name|PL_curcop
operator|->
name|cop_stash
operator|!=
name|GvSTASH
argument_list|(
name|dstr
argument_list|)
condition|)
name|GvIMPORTED_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|GvMULTI_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
return|return;
block|}
goto|goto
name|glob_assign
goto|;
block|}
break|break;
case|case
name|SVt_PV
case|:
case|case
name|SVt_PVFM
case|:
if|if
condition|(
name|dtype
operator|<
name|SVt_PV
condition|)
name|sv_upgrade
argument_list|(
name|dstr
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVIV
case|:
if|if
condition|(
name|dtype
operator|<
name|SVt_PVIV
condition|)
name|sv_upgrade
argument_list|(
name|dstr
argument_list|,
name|SVt_PVIV
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVNV
case|:
if|if
condition|(
name|dtype
operator|<
name|SVt_PVNV
condition|)
name|sv_upgrade
argument_list|(
name|dstr
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVAV
case|:
case|case
name|SVt_PVHV
case|:
case|case
name|SVt_PVCV
case|:
case|case
name|SVt_PVIO
case|:
if|if
condition|(
name|PL_op
condition|)
name|croak
argument_list|(
literal|"Bizarre copy of %s in %s"
argument_list|,
name|sv_reftype
argument_list|(
name|sstr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op_name
index|[
name|PL_op
operator|->
name|op_type
index|]
argument_list|)
expr_stmt|;
else|else
name|croak
argument_list|(
literal|"Bizarre copy of %s"
argument_list|,
name|sv_reftype
argument_list|(
name|sstr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVGV
case|:
if|if
condition|(
name|dtype
operator|<=
name|SVt_PVGV
condition|)
block|{
name|glob_assign
label|:
if|if
condition|(
name|dtype
operator|!=
name|SVt_PVGV
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|GvNAME
argument_list|(
name|sstr
argument_list|)
decl_stmt|;
name|STRLEN
name|len
init|=
name|GvNAMELEN
argument_list|(
name|sstr
argument_list|)
decl_stmt|;
name|sv_upgrade
argument_list|(
name|dstr
argument_list|,
name|SVt_PVGV
argument_list|)
expr_stmt|;
name|sv_magic
argument_list|(
name|dstr
argument_list|,
name|dstr
argument_list|,
literal|'*'
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|GvSTASH
argument_list|(
name|dstr
argument_list|)
operator|=
operator|(
name|HV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|GvSTASH
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|GvNAME
argument_list|(
name|dstr
argument_list|)
operator|=
name|savepvn
argument_list|(
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|GvNAMELEN
argument_list|(
name|dstr
argument_list|)
operator|=
name|len
expr_stmt|;
name|SvFAKE_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
comment|/* can coerce to non-glob */
block|}
comment|/* ahem, death to those who redefine active sort subs */
elseif|else
if|if
condition|(
name|PL_curstackinfo
operator|->
name|si_type
operator|==
name|PERLSI_SORT
operator|&&
name|GvCV
argument_list|(
name|dstr
argument_list|)
operator|&&
name|PL_sortcop
operator|==
name|CvSTART
argument_list|(
name|GvCV
argument_list|(
name|dstr
argument_list|)
argument_list|)
condition|)
name|croak
argument_list|(
literal|"Can't redefine active sort subroutine %s"
argument_list|,
name|GvNAME
argument_list|(
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvOK_off
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|GvINTRO_off
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
comment|/* one-shot flag */
name|gp_free
argument_list|(
operator|(
name|GV
operator|*
operator|)
name|dstr
argument_list|)
expr_stmt|;
name|GvGP
argument_list|(
name|dstr
argument_list|)
operator|=
name|gp_ref
argument_list|(
name|GvGP
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|SvTAINT
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_curcop
operator|->
name|cop_stash
operator|!=
name|GvSTASH
argument_list|(
name|dstr
argument_list|)
condition|)
name|GvIMPORTED_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|GvMULTI_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* FALL THROUGH */
default|default:
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sstr
argument_list|)
condition|)
block|{
name|mg_get
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sstr
argument_list|)
operator|!=
name|stype
condition|)
block|{
name|stype
operator|=
name|SvTYPE
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|stype
operator|==
name|SVt_PVGV
operator|&&
name|dtype
operator|<=
name|SVt_PVGV
condition|)
goto|goto
name|glob_assign
goto|;
block|}
block|}
if|if
condition|(
name|stype
operator|==
name|SVt_PVLV
condition|)
name|SvUPGRADE
argument_list|(
name|dstr
argument_list|,
name|SVt_PVNV
argument_list|)
expr_stmt|;
else|else
name|SvUPGRADE
argument_list|(
name|dstr
argument_list|,
name|stype
argument_list|)
expr_stmt|;
block|}
name|sflags
operator|=
name|SvFLAGS
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sflags
operator|&
name|SVf_ROK
condition|)
block|{
if|if
condition|(
name|dtype
operator|>=
name|SVt_PV
condition|)
block|{
if|if
condition|(
name|dtype
operator|==
name|SVt_PVGV
condition|)
block|{
name|SV
modifier|*
name|sref
init|=
name|SvREFCNT_inc
argument_list|(
name|SvRV
argument_list|(
name|sstr
argument_list|)
argument_list|)
decl_stmt|;
name|SV
modifier|*
name|dref
init|=
literal|0
decl_stmt|;
name|int
name|intro
init|=
name|GvINTRO
argument_list|(
name|dstr
argument_list|)
decl_stmt|;
if|if
condition|(
name|intro
condition|)
block|{
name|GP
modifier|*
name|gp
decl_stmt|;
name|GvGP
argument_list|(
name|dstr
argument_list|)
operator|->
name|gp_refcnt
operator|--
expr_stmt|;
name|GvINTRO_off
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
comment|/* one-shot flag */
name|Newz
argument_list|(
literal|602
argument_list|,
name|gp
argument_list|,
literal|1
argument_list|,
name|GP
argument_list|)
expr_stmt|;
name|GvGP
argument_list|(
name|dstr
argument_list|)
operator|=
name|gp_ref
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|GvSV
argument_list|(
name|dstr
argument_list|)
operator|=
name|NEWSV
argument_list|(
literal|72
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GvLINE
argument_list|(
name|dstr
argument_list|)
operator|=
name|PL_curcop
operator|->
name|cop_line
expr_stmt|;
name|GvEGV
argument_list|(
name|dstr
argument_list|)
operator|=
operator|(
name|GV
operator|*
operator|)
name|dstr
expr_stmt|;
block|}
name|GvMULTI_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sref
argument_list|)
condition|)
block|{
case|case
name|SVt_PVAV
case|:
if|if
condition|(
name|intro
condition|)
name|SAVESPTR
argument_list|(
name|GvAV
argument_list|(
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dref
operator|=
operator|(
name|SV
operator|*
operator|)
name|GvAV
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|GvAV
argument_list|(
name|dstr
argument_list|)
operator|=
operator|(
name|AV
operator|*
operator|)
name|sref
expr_stmt|;
if|if
condition|(
name|PL_curcop
operator|->
name|cop_stash
operator|!=
name|GvSTASH
argument_list|(
name|dstr
argument_list|)
condition|)
name|GvIMPORTED_AV_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVHV
case|:
if|if
condition|(
name|intro
condition|)
name|SAVESPTR
argument_list|(
name|GvHV
argument_list|(
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dref
operator|=
operator|(
name|SV
operator|*
operator|)
name|GvHV
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|GvHV
argument_list|(
name|dstr
argument_list|)
operator|=
operator|(
name|HV
operator|*
operator|)
name|sref
expr_stmt|;
if|if
condition|(
name|PL_curcop
operator|->
name|cop_stash
operator|!=
name|GvSTASH
argument_list|(
name|dstr
argument_list|)
condition|)
name|GvIMPORTED_HV_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVCV
case|:
if|if
condition|(
name|intro
condition|)
block|{
if|if
condition|(
name|GvCVGEN
argument_list|(
name|dstr
argument_list|)
operator|&&
name|GvCV
argument_list|(
name|dstr
argument_list|)
operator|!=
operator|(
name|CV
operator|*
operator|)
name|sref
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|GvCV
argument_list|(
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
name|GvCV
argument_list|(
name|dstr
argument_list|)
operator|=
name|Nullcv
expr_stmt|;
name|GvCVGEN
argument_list|(
name|dstr
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Switch off cacheness. */
name|PL_sub_generation
operator|++
expr_stmt|;
block|}
name|SAVESPTR
argument_list|(
name|GvCV
argument_list|(
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|dref
operator|=
operator|(
name|SV
operator|*
operator|)
name|GvCV
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|GvCV
argument_list|(
name|dstr
argument_list|)
operator|!=
operator|(
name|CV
operator|*
operator|)
name|sref
condition|)
block|{
name|CV
modifier|*
name|cv
init|=
name|GvCV
argument_list|(
name|dstr
argument_list|)
decl_stmt|;
if|if
condition|(
name|cv
condition|)
block|{
if|if
condition|(
operator|!
name|GvCVGEN
argument_list|(
operator|(
name|GV
operator|*
operator|)
name|dstr
argument_list|)
operator|&&
operator|(
name|CvROOT
argument_list|(
name|cv
argument_list|)
operator|||
name|CvXSUB
argument_list|(
name|cv
argument_list|)
operator|)
condition|)
block|{
name|SV
modifier|*
name|const_sv
init|=
name|cv_const_sv
argument_list|(
name|cv
argument_list|)
decl_stmt|;
name|bool
name|const_changed
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
name|const_sv
condition|)
name|const_changed
operator|=
name|sv_cmp
argument_list|(
name|const_sv
argument_list|,
name|op_const_sv
argument_list|(
name|CvSTART
argument_list|(
operator|(
name|CV
operator|*
operator|)
name|sref
argument_list|)
argument_list|,
name|Nullcv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ahem, death to those who redefine 				 * active sort subs */
if|if
condition|(
name|PL_curstackinfo
operator|->
name|si_type
operator|==
name|PERLSI_SORT
operator|&&
name|PL_sortcop
operator|==
name|CvSTART
argument_list|(
name|cv
argument_list|)
condition|)
name|croak
argument_list|(
literal|"Can't redefine active sort subroutine %s"
argument_list|,
name|GvENAME
argument_list|(
operator|(
name|GV
operator|*
operator|)
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PL_dowarn
operator|||
operator|(
name|const_changed
operator|&&
name|const_sv
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|CvGV
argument_list|(
name|cv
argument_list|)
operator|&&
name|GvSTASH
argument_list|(
name|CvGV
argument_list|(
name|cv
argument_list|)
argument_list|)
operator|&&
name|HvNAME
argument_list|(
name|GvSTASH
argument_list|(
name|CvGV
argument_list|(
name|cv
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|strEQ
argument_list|(
name|HvNAME
argument_list|(
name|GvSTASH
argument_list|(
name|CvGV
argument_list|(
name|cv
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"autouse"
argument_list|)
operator|)
condition|)
name|warn
argument_list|(
name|const_sv
condition|?
literal|"Constant subroutine %s redefined"
else|:
literal|"Subroutine %s redefined"
argument_list|,
name|GvENAME
argument_list|(
operator|(
name|GV
operator|*
operator|)
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|cv_ckproto
argument_list|(
name|cv
argument_list|,
operator|(
name|GV
operator|*
operator|)
name|dstr
argument_list|,
name|SvPOK
argument_list|(
name|sref
argument_list|)
condition|?
name|SvPVX
argument_list|(
name|sref
argument_list|)
else|:
name|Nullch
argument_list|)
expr_stmt|;
block|}
name|GvCV
argument_list|(
name|dstr
argument_list|)
operator|=
operator|(
name|CV
operator|*
operator|)
name|sref
expr_stmt|;
name|GvCVGEN
argument_list|(
name|dstr
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Switch off cacheness. */
name|GvASSUMECV_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|PL_sub_generation
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|PL_curcop
operator|->
name|cop_stash
operator|!=
name|GvSTASH
argument_list|(
name|dstr
argument_list|)
condition|)
name|GvIMPORTED_CV_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVIO
case|:
if|if
condition|(
name|intro
condition|)
name|SAVESPTR
argument_list|(
name|GvIOp
argument_list|(
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dref
operator|=
operator|(
name|SV
operator|*
operator|)
name|GvIOp
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|GvIOp
argument_list|(
name|dstr
argument_list|)
operator|=
operator|(
name|IO
operator|*
operator|)
name|sref
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|intro
condition|)
name|SAVESPTR
argument_list|(
name|GvSV
argument_list|(
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dref
operator|=
operator|(
name|SV
operator|*
operator|)
name|GvSV
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|GvSV
argument_list|(
name|dstr
argument_list|)
operator|=
name|sref
expr_stmt|;
if|if
condition|(
name|PL_curcop
operator|->
name|cop_stash
operator|!=
name|GvSTASH
argument_list|(
name|dstr
argument_list|)
condition|)
name|GvIMPORTED_SV_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dref
condition|)
name|SvREFCNT_dec
argument_list|(
name|dref
argument_list|)
expr_stmt|;
if|if
condition|(
name|intro
condition|)
name|SAVEFREESV
argument_list|(
name|sref
argument_list|)
expr_stmt|;
name|SvTAINT
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|SvPVX
argument_list|(
name|dstr
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|SvOOK_off
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
comment|/* backoff */
name|Safefree
argument_list|(
name|SvPVX
argument_list|(
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
name|SvLEN
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvCUR
argument_list|(
name|dstr
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|SvOK_off
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|SvRV
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvREFCNT_inc
argument_list|(
name|SvRV
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|SvROK_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sflags
operator|&
name|SVp_NOK
condition|)
block|{
name|SvNOK_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvNVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sflags
operator|&
name|SVp_IOK
condition|)
block|{
operator|(
name|void
operator|)
name|SvIOK_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvIVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OVERLOAD
if|if
condition|(
name|SvAMAGIC
argument_list|(
name|sstr
argument_list|)
condition|)
block|{
name|SvAMAGIC_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OVERLOAD */
block|}
elseif|else
if|if
condition|(
name|sflags
operator|&
name|SVp_POK
condition|)
block|{
comment|/* 	 * Check to see if we can just swipe the string.  If so, it's a 	 * possible small lose on short strings, but a big win on long ones. 	 * It might even be a win on short strings if SvPVX(dstr) 	 * has to be allocated and SvPVX(sstr) has to be freed. 	 */
if|if
condition|(
name|SvTEMP
argument_list|(
name|sstr
argument_list|)
operator|&&
comment|/* slated for free anyway? */
name|SvREFCNT
argument_list|(
name|sstr
argument_list|)
operator|==
literal|1
operator|&&
comment|/* and no other references to it? */
operator|!
operator|(
name|sflags
operator|&
name|SVf_OOK
operator|)
condition|)
comment|/* and not involved in OOK hack? */
block|{
if|if
condition|(
name|SvPVX
argument_list|(
name|dstr
argument_list|)
condition|)
block|{
comment|/* we know that dtype>= SVt_PV */
if|if
condition|(
name|SvOOK
argument_list|(
name|dstr
argument_list|)
condition|)
block|{
name|SvFLAGS
argument_list|(
name|dstr
argument_list|)
operator|&=
operator|~
name|SVf_OOK
expr_stmt|;
name|Safefree
argument_list|(
name|SvPVX
argument_list|(
name|dstr
argument_list|)
operator|-
name|SvIVX
argument_list|(
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|Safefree
argument_list|(
name|SvPVX
argument_list|(
name|dstr
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|SvPV_set
argument_list|(
name|dstr
argument_list|,
name|SvPVX
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|SvLEN_set
argument_list|(
name|dstr
argument_list|,
name|SvLEN
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|dstr
argument_list|,
name|SvCUR
argument_list|(
name|sstr
argument_list|)
argument_list|)
expr_stmt|;
name|SvTEMP_off
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvOK_off
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
name|SvPV_set
argument_list|(
name|sstr
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
name|SvLEN_set
argument_list|(
name|sstr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sstr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SvTEMP_off
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* have to copy actual string */
name|STRLEN
name|len
init|=
name|SvCUR
argument_list|(
name|sstr
argument_list|)
decl_stmt|;
name|SvGROW
argument_list|(
name|dstr
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* inlined from sv_setpvn */
name|Move
argument_list|(
name|SvPVX
argument_list|(
name|sstr
argument_list|)
argument_list|,
name|SvPVX
argument_list|(
name|dstr
argument_list|)
argument_list|,
name|len
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|dstr
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|SvEND
argument_list|(
name|dstr
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
block|}
comment|/*SUPPRESS 560*/
if|if
condition|(
name|sflags
operator|&
name|SVp_NOK
condition|)
block|{
name|SvNOK_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvNVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sflags
operator|&
name|SVp_IOK
condition|)
block|{
operator|(
name|void
operator|)
name|SvIOK_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvIVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sflags
operator|&
name|SVp_NOK
condition|)
block|{
name|SvNVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvNVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvNOK_only
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvIOK
argument_list|(
name|sstr
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|SvIOK_on
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvIVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sflags
operator|&
name|SVp_IOK
condition|)
block|{
operator|(
name|void
operator|)
name|SvIOK_only
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|dstr
argument_list|)
operator|=
name|SvIVX
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dtype
operator|==
name|SVt_PVGV
condition|)
block|{
if|if
condition|(
name|PL_dowarn
condition|)
name|warn
argument_list|(
literal|"Undefined value assigned to typeglob"
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|SvOK_off
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
block|}
name|SvTAINT
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_setsv_mg
parameter_list|(
name|SV
modifier|*
name|dstr
parameter_list|,
specifier|register
name|SV
modifier|*
name|sstr
parameter_list|)
block|{
name|sv_setsv
argument_list|(
name|dstr
argument_list|,
name|sstr
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_setpvn
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|register
name|STRLEN
name|len
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|dptr
decl_stmt|;
name|assert
argument_list|(
name|len
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* STRLEN is probably unsigned, so this may 			  elicit a warning, but it won't hurt. */
name|SV_CHECK_THINKFIRST
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
block|{
operator|(
name|void
operator|)
name|SvOK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|>=
name|SVt_PV
condition|)
block|{
if|if
condition|(
name|SvFAKE
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_PVGV
condition|)
name|sv_unglob
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
else|else
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dptr
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|Move
argument_list|(
name|ptr
argument_list|,
name|dptr
argument_list|,
name|len
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|dptr
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* validate pointer */
name|SvTAINT
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_setpvn_mg
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|register
name|STRLEN
name|len
parameter_list|)
block|{
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_setpv
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|ptr
parameter_list|)
block|{
specifier|register
name|STRLEN
name|len
decl_stmt|;
name|SV_CHECK_THINKFIRST
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
block|{
operator|(
name|void
operator|)
name|SvOK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|>=
name|SVt_PV
condition|)
block|{
if|if
condition|(
name|SvFAKE
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_PVGV
condition|)
name|sv_unglob
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
else|else
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Move
argument_list|(
name|ptr
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* validate pointer */
name|SvTAINT
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_setpv_mg
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|ptr
parameter_list|)
block|{
name|sv_setpv
argument_list|(
name|sv
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_usepvn
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
name|char
modifier|*
name|ptr
parameter_list|,
specifier|register
name|STRLEN
name|len
parameter_list|)
block|{
name|SV_CHECK_THINKFIRST
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
block|{
operator|(
name|void
operator|)
name|SvOK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
condition|)
name|Safefree
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|Renew
argument_list|(
name|ptr
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
name|ptr
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SvLEN_set
argument_list|(
name|sv
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|SvEND
argument_list|(
name|sv
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* validate pointer */
name|SvTAINT
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_usepvn_mg
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
name|char
modifier|*
name|ptr
parameter_list|,
specifier|register
name|STRLEN
name|len
parameter_list|)
block|{
name|sv_usepvn
argument_list|(
name|sv
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|sv_check_thinkfirst
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
name|PL_curcop
operator|!=
operator|&
name|PL_compiling
condition|)
name|croak
argument_list|(
name|no_modify
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_unref
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_chop
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
name|char
modifier|*
name|ptr
parameter_list|)
comment|/* like set but assuming ptr is in sv */
block|{
specifier|register
name|STRLEN
name|delta
decl_stmt|;
if|if
condition|(
operator|!
name|ptr
operator|||
operator|!
name|SvPOKp
argument_list|(
name|sv
argument_list|)
condition|)
return|return;
name|SV_CHECK_THINKFIRST
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|<
name|SVt_PVIV
condition|)
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVIV
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvOOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator||=
name|SVf_OOK
expr_stmt|;
block|}
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&=
operator|~
operator|(
name|SVf_IOK
operator||
name|SVf_NOK
operator||
name|SVp_IOK
operator||
name|SVp_NOK
operator|)
expr_stmt|;
name|delta
operator|=
name|ptr
operator|-
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|-=
name|delta
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|-=
name|delta
expr_stmt|;
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+=
name|delta
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|+=
name|delta
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_catpvn
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
name|char
modifier|*
name|ptr
parameter_list|,
specifier|register
name|STRLEN
name|len
parameter_list|)
block|{
name|STRLEN
name|tlen
decl_stmt|;
name|char
modifier|*
name|junk
decl_stmt|;
name|junk
operator|=
name|SvPV_force
argument_list|(
name|sv
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|tlen
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|junk
condition|)
name|ptr
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|Move
argument_list|(
name|ptr
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|tlen
argument_list|,
name|len
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+=
name|len
expr_stmt|;
operator|*
name|SvEND
argument_list|(
name|sv
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* validate pointer */
name|SvTAINT
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_catpvn_mg
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
name|char
modifier|*
name|ptr
parameter_list|,
specifier|register
name|STRLEN
name|len
parameter_list|)
block|{
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_catsv
parameter_list|(
name|SV
modifier|*
name|dstr
parameter_list|,
specifier|register
name|SV
modifier|*
name|sstr
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|sstr
condition|)
return|return;
if|if
condition|(
name|s
operator|=
name|SvPV
argument_list|(
name|sstr
argument_list|,
name|len
argument_list|)
condition|)
name|sv_catpvn
argument_list|(
name|dstr
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_catsv_mg
parameter_list|(
name|SV
modifier|*
name|dstr
parameter_list|,
specifier|register
name|SV
modifier|*
name|sstr
parameter_list|)
block|{
name|sv_catsv
argument_list|(
name|dstr
argument_list|,
name|sstr
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_catpv
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
name|char
modifier|*
name|ptr
parameter_list|)
block|{
specifier|register
name|STRLEN
name|len
decl_stmt|;
name|STRLEN
name|tlen
decl_stmt|;
name|char
modifier|*
name|junk
decl_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
return|return;
name|junk
operator|=
name|SvPV_force
argument_list|(
name|sv
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|tlen
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|junk
condition|)
name|ptr
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|Move
argument_list|(
name|ptr
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|tlen
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+=
name|len
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* validate pointer */
name|SvTAINT
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_catpv_mg
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
name|char
modifier|*
name|ptr
parameter_list|)
block|{
name|sv_catpv
argument_list|(
name|sv
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|SV
modifier|*
name|newSV
parameter_list|(
name|STRLEN
name|len
parameter_list|)
block|{
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|new_SV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|sv
return|;
block|}
end_function

begin_comment
comment|/* name is assumed to contain an SV* if (name&& namelen == HEf_SVKEY) */
end_comment

begin_function
name|void
name|sv_magic
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
name|SV
modifier|*
name|obj
parameter_list|,
name|int
name|how
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|I32
name|namlen
parameter_list|)
block|{
name|MAGIC
modifier|*
name|mg
decl_stmt|;
if|if
condition|(
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
name|PL_curcop
operator|!=
operator|&
name|PL_compiling
operator|&&
operator|!
name|strchr
argument_list|(
literal|"gBf"
argument_list|,
name|how
argument_list|)
condition|)
name|croak
argument_list|(
name|no_modify
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SvMAGICAL
argument_list|(
name|sv
argument_list|)
operator|||
operator|(
name|how
operator|==
literal|'t'
operator|&&
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|>=
name|SVt_PVMG
operator|)
condition|)
block|{
if|if
condition|(
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
operator|&&
operator|(
name|mg
operator|=
name|mg_find
argument_list|(
name|sv
argument_list|,
name|how
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|how
operator|==
literal|'t'
condition|)
name|mg
operator|->
name|mg_len
operator||=
literal|1
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_PVMG
argument_list|)
expr_stmt|;
block|}
name|Newz
argument_list|(
literal|702
argument_list|,
name|mg
argument_list|,
literal|1
argument_list|,
name|MAGIC
argument_list|)
expr_stmt|;
name|mg
operator|->
name|mg_moremagic
operator|=
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
operator|=
name|mg
expr_stmt|;
if|if
condition|(
operator|!
name|obj
operator|||
name|obj
operator|==
name|sv
operator|||
name|how
operator|==
literal|'#'
operator|||
name|how
operator|==
literal|'r'
condition|)
name|mg
operator|->
name|mg_obj
operator|=
name|obj
expr_stmt|;
else|else
block|{
name|dTHR
expr_stmt|;
name|mg
operator|->
name|mg_obj
operator|=
name|SvREFCNT_inc
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|mg
operator|->
name|mg_flags
operator||=
name|MGf_REFCOUNTED
expr_stmt|;
block|}
name|mg
operator|->
name|mg_type
operator|=
name|how
expr_stmt|;
name|mg
operator|->
name|mg_len
operator|=
name|namlen
expr_stmt|;
if|if
condition|(
name|name
condition|)
if|if
condition|(
name|namlen
operator|>=
literal|0
condition|)
name|mg
operator|->
name|mg_ptr
operator|=
name|savepvn
argument_list|(
name|name
argument_list|,
name|namlen
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|namlen
operator|==
name|HEf_SVKEY
condition|)
name|mg
operator|->
name|mg_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
literal|0
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|vtbl_sv
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|OVERLOAD
case|case
literal|'A'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|vtbl_amagic
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|vtbl_amagicelem
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* OVERLOAD */
case|case
literal|'B'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|vtbl_bm
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|vtbl_env
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|vtbl_fm
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|vtbl_envelem
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|vtbl_mglob
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|vtbl_isa
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|vtbl_isaelem
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|vtbl_nkeys
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|SvRMAGICAL_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|mg
operator|->
name|mg_virtual
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|vtbl_dbline
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|USE_THREADS
case|case
literal|'m'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|vtbl_mutex
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* USE_THREADS */
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
case|case
literal|'o'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|vtbl_collxfrm
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* USE_LOCALE_COLLATE */
case|case
literal|'P'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|vtbl_pack
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|vtbl_packelem
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|vtbl_regexp
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|vtbl_sig
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|vtbl_sigelem
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|vtbl_taint
expr_stmt|;
name|mg
operator|->
name|mg_len
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|vtbl_uvar
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|vtbl_vec
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|vtbl_substr
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|vtbl_defelem
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|vtbl_glob
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|vtbl_arylen
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|mg
operator|->
name|mg_virtual
operator|=
operator|&
name|vtbl_pos
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
comment|/* Reserved for use by extensions not perl internals.	*/
comment|/* Useful for attaching extension internal data to perl vars.	*/
comment|/* Note that multiple extensions may clash if magical scalars	*/
comment|/* etc holding private data from one are passed to another.	*/
name|SvRMAGICAL_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
break|break;
default|default:
name|croak
argument_list|(
literal|"Don't know how to handle magic of type '%c'"
argument_list|,
name|how
argument_list|)
expr_stmt|;
block|}
name|mg_magical
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&=
operator|~
operator|(
name|SVf_IOK
operator||
name|SVf_NOK
operator||
name|SVf_POK
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sv_unmagic
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|MAGIC
modifier|*
name|mg
decl_stmt|;
name|MAGIC
modifier|*
modifier|*
name|mgp
decl_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|<
name|SVt_PVMG
operator|||
operator|!
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
condition|)
return|return
literal|0
return|;
name|mgp
operator|=
operator|&
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
for|for
control|(
name|mg
operator|=
operator|*
name|mgp
init|;
name|mg
condition|;
name|mg
operator|=
operator|*
name|mgp
control|)
block|{
if|if
condition|(
name|mg
operator|->
name|mg_type
operator|==
name|type
condition|)
block|{
name|MGVTBL
modifier|*
name|vtbl
init|=
name|mg
operator|->
name|mg_virtual
decl_stmt|;
operator|*
name|mgp
operator|=
name|mg
operator|->
name|mg_moremagic
expr_stmt|;
if|if
condition|(
name|vtbl
operator|&&
operator|(
name|vtbl
operator|->
name|svt_free
operator|!=
name|NULL
operator|)
condition|)
call|(
name|VTBL
operator|->
name|svt_free
call|)
argument_list|(
name|sv
argument_list|,
name|mg
argument_list|)
expr_stmt|;
if|if
condition|(
name|mg
operator|->
name|mg_ptr
operator|&&
name|mg
operator|->
name|mg_type
operator|!=
literal|'g'
condition|)
if|if
condition|(
name|mg
operator|->
name|mg_len
operator|>=
literal|0
condition|)
name|Safefree
argument_list|(
name|mg
operator|->
name|mg_ptr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mg
operator|->
name|mg_len
operator|==
name|HEf_SVKEY
condition|)
name|SvREFCNT_dec
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|mg
operator|->
name|mg_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mg
operator|->
name|mg_flags
operator|&
name|MGf_REFCOUNTED
condition|)
name|SvREFCNT_dec
argument_list|(
name|mg
operator|->
name|mg_obj
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|mg
argument_list|)
expr_stmt|;
block|}
else|else
name|mgp
operator|=
operator|&
name|mg
operator|->
name|mg_moremagic
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SvMAGICAL_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator||=
operator|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
operator|(
name|SVp_IOK
operator||
name|SVp_NOK
operator||
name|SVp_POK
operator|)
operator|)
operator|>>
name|PRIVSHIFT
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|sv_insert
parameter_list|(
name|SV
modifier|*
name|bigstr
parameter_list|,
name|STRLEN
name|offset
parameter_list|,
name|STRLEN
name|len
parameter_list|,
name|char
modifier|*
name|little
parameter_list|,
name|STRLEN
name|littlelen
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|big
decl_stmt|;
specifier|register
name|char
modifier|*
name|mid
decl_stmt|;
specifier|register
name|char
modifier|*
name|midend
decl_stmt|;
specifier|register
name|char
modifier|*
name|bigend
decl_stmt|;
specifier|register
name|I32
name|i
decl_stmt|;
name|STRLEN
name|curlen
decl_stmt|;
if|if
condition|(
operator|!
name|bigstr
condition|)
name|croak
argument_list|(
literal|"Can't modify non-existent substring"
argument_list|)
expr_stmt|;
name|SvPV_force
argument_list|(
name|bigstr
argument_list|,
name|curlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|+
name|len
operator|>
name|curlen
condition|)
block|{
name|SvGROW
argument_list|(
name|bigstr
argument_list|,
name|offset
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Zero
argument_list|(
name|SvPVX
argument_list|(
name|bigstr
argument_list|)
operator|+
name|curlen
argument_list|,
name|offset
operator|+
name|len
operator|-
name|curlen
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|bigstr
argument_list|,
name|offset
operator|+
name|len
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|littlelen
operator|-
name|len
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
comment|/* string might grow */
name|big
operator|=
name|SvGROW
argument_list|(
name|bigstr
argument_list|,
name|SvCUR
argument_list|(
name|bigstr
argument_list|)
operator|+
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mid
operator|=
name|big
operator|+
name|offset
operator|+
name|len
expr_stmt|;
name|midend
operator|=
name|bigend
operator|=
name|big
operator|+
name|SvCUR
argument_list|(
name|bigstr
argument_list|)
expr_stmt|;
name|bigend
operator|+=
name|i
expr_stmt|;
operator|*
name|bigend
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|midend
operator|>
name|mid
condition|)
comment|/* shove everything down */
operator|*
operator|--
name|bigend
operator|=
operator|*
operator|--
name|midend
expr_stmt|;
name|Move
argument_list|(
name|little
argument_list|,
name|big
operator|+
name|offset
argument_list|,
name|littlelen
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|SvCUR
argument_list|(
name|bigstr
argument_list|)
operator|+=
name|i
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|bigstr
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|Move
argument_list|(
name|little
argument_list|,
name|SvPVX
argument_list|(
name|bigstr
argument_list|)
operator|+
name|offset
argument_list|,
name|len
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|bigstr
argument_list|)
expr_stmt|;
return|return;
block|}
name|big
operator|=
name|SvPVX
argument_list|(
name|bigstr
argument_list|)
expr_stmt|;
name|mid
operator|=
name|big
operator|+
name|offset
expr_stmt|;
name|midend
operator|=
name|mid
operator|+
name|len
expr_stmt|;
name|bigend
operator|=
name|big
operator|+
name|SvCUR
argument_list|(
name|bigstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|midend
operator|>
name|bigend
condition|)
name|croak
argument_list|(
literal|"panic: sv_insert"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|-
name|big
operator|>
name|bigend
operator|-
name|midend
condition|)
block|{
comment|/* faster to shorten from end */
if|if
condition|(
name|littlelen
condition|)
block|{
name|Move
argument_list|(
name|little
argument_list|,
name|mid
argument_list|,
name|littlelen
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|mid
operator|+=
name|littlelen
expr_stmt|;
block|}
name|i
operator|=
name|bigend
operator|-
name|midend
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|Move
argument_list|(
name|midend
argument_list|,
name|mid
argument_list|,
name|i
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|mid
operator|+=
name|i
expr_stmt|;
block|}
operator|*
name|mid
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR_set
argument_list|(
name|bigstr
argument_list|,
name|mid
operator|-
name|big
argument_list|)
expr_stmt|;
block|}
comment|/*SUPPRESS 560*/
elseif|else
if|if
condition|(
name|i
operator|=
name|mid
operator|-
name|big
condition|)
block|{
comment|/* faster from front */
name|midend
operator|-=
name|littlelen
expr_stmt|;
name|mid
operator|=
name|midend
expr_stmt|;
name|sv_chop
argument_list|(
name|bigstr
argument_list|,
name|midend
operator|-
name|i
argument_list|)
expr_stmt|;
name|big
operator|+=
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
operator|*
operator|--
name|midend
operator|=
operator|*
operator|--
name|big
expr_stmt|;
if|if
condition|(
name|littlelen
condition|)
name|Move
argument_list|(
name|little
argument_list|,
name|mid
argument_list|,
name|littlelen
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|littlelen
condition|)
block|{
name|midend
operator|-=
name|littlelen
expr_stmt|;
name|sv_chop
argument_list|(
name|bigstr
argument_list|,
name|midend
argument_list|)
expr_stmt|;
name|Move
argument_list|(
name|little
argument_list|,
name|midend
argument_list|,
name|littlelen
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sv_chop
argument_list|(
name|bigstr
argument_list|,
name|midend
argument_list|)
expr_stmt|;
block|}
name|SvSETMAGIC
argument_list|(
name|bigstr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* make sv point to what nstr did */
end_comment

begin_function
name|void
name|sv_replace
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
name|SV
modifier|*
name|nsv
parameter_list|)
block|{
name|U32
name|refcnt
init|=
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
decl_stmt|;
name|SV_CHECK_THINKFIRST
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvREFCNT
argument_list|(
name|nsv
argument_list|)
operator|!=
literal|1
condition|)
name|warn
argument_list|(
literal|"Reference miscount in sv_replace()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvMAGICAL
argument_list|(
name|nsv
argument_list|)
condition|)
name|mg_free
argument_list|(
name|nsv
argument_list|)
expr_stmt|;
else|else
name|sv_upgrade
argument_list|(
name|nsv
argument_list|,
name|SVt_PVMG
argument_list|)
expr_stmt|;
name|SvMAGIC
argument_list|(
name|nsv
argument_list|)
operator|=
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvFLAGS
argument_list|(
name|nsv
argument_list|)
operator||=
name|SvMAGICAL
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvMAGICAL_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|sv_clear
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|StructCopy
argument_list|(
name|nsv
argument_list|,
name|sv
argument_list|,
name|SV
argument_list|)
expr_stmt|;
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|=
name|refcnt
expr_stmt|;
name|SvFLAGS
argument_list|(
name|nsv
argument_list|)
operator||=
name|SVTYPEMASK
expr_stmt|;
comment|/* Mark as freed */
name|del_SV
argument_list|(
name|nsv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_clear
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|HV
modifier|*
name|stash
decl_stmt|;
name|assert
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvOBJECT
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
name|PL_defstash
condition|)
block|{
comment|/* Still have a symbol table? */
name|djSP
expr_stmt|;
name|GV
modifier|*
name|destructor
decl_stmt|;
name|SV
name|tmpref
decl_stmt|;
name|Zero
argument_list|(
operator|&
name|tmpref
argument_list|,
literal|1
argument_list|,
name|SV
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
operator|&
name|tmpref
argument_list|,
name|SVt_RV
argument_list|)
expr_stmt|;
name|SvROK_on
argument_list|(
operator|&
name|tmpref
argument_list|)
expr_stmt|;
name|SvREADONLY_on
argument_list|(
operator|&
name|tmpref
argument_list|)
expr_stmt|;
comment|/* DESTROY() could be naughty */
name|SvREFCNT
argument_list|(
operator|&
name|tmpref
argument_list|)
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|stash
operator|=
name|SvSTASH
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|destructor
operator|=
name|gv_fetchmethod
argument_list|(
name|SvSTASH
argument_list|(
name|sv
argument_list|)
argument_list|,
literal|"DESTROY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|destructor
condition|)
block|{
name|ENTER
expr_stmt|;
name|PUSHSTACKi
argument_list|(
name|PERLSI_DESTROY
argument_list|)
expr_stmt|;
name|SvRV
argument_list|(
operator|&
name|tmpref
argument_list|)
operator|=
name|SvREFCNT_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|EXTEND
argument_list|(
name|SP
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|PUSHMARK
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|PUSHs
argument_list|(
operator|&
name|tmpref
argument_list|)
expr_stmt|;
name|PUTBACK
expr_stmt|;
name|perl_call_sv
argument_list|(
operator|(
name|SV
operator|*
operator|)
name|GvCV
argument_list|(
name|destructor
argument_list|)
argument_list|,
name|G_DISCARD
operator||
name|G_EVAL
operator||
name|G_KEEPERR
argument_list|)
expr_stmt|;
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|--
expr_stmt|;
name|POPSTACK
expr_stmt|;
name|LEAVE
expr_stmt|;
block|}
block|}
do|while
condition|(
name|SvOBJECT
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvSTASH
argument_list|(
name|sv
argument_list|)
operator|!=
name|stash
condition|)
do|;
name|del_XRV
argument_list|(
name|SvANY
argument_list|(
operator|&
name|tmpref
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SvOBJECT
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|SvSTASH
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* possibly of changed persuasion */
name|SvOBJECT_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* Curse the object. */
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|!=
name|SVt_PVIO
condition|)
operator|--
name|PL_sv_objcount
expr_stmt|;
comment|/* XXX Might want something more general */
block|}
if|if
condition|(
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|PL_in_clean_objs
condition|)
name|croak
argument_list|(
literal|"DESTROY created new reference to dead object"
argument_list|)
expr_stmt|;
comment|/* DESTROY gave object new lease on life */
return|return;
block|}
block|}
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|>=
name|SVt_PVMG
operator|&&
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_free
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|stash
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
case|case
name|SVt_PVIO
case|:
if|if
condition|(
name|IoIFP
argument_list|(
name|sv
argument_list|)
operator|&&
name|IoIFP
argument_list|(
name|sv
argument_list|)
operator|!=
name|PerlIO_stdin
argument_list|()
operator|&&
name|IoIFP
argument_list|(
name|sv
argument_list|)
operator|!=
name|PerlIO_stdout
argument_list|()
operator|&&
name|IoIFP
argument_list|(
name|sv
argument_list|)
operator|!=
name|PerlIO_stderr
argument_list|()
condition|)
name|io_close
argument_list|(
operator|(
name|IO
operator|*
operator|)
name|sv
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|IoTOP_NAME
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|IoFMT_NAME
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|IoBOTTOM_NAME
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|SVt_PVBM
case|:
goto|goto
name|freescalar
goto|;
case|case
name|SVt_PVCV
case|:
case|case
name|SVt_PVFM
case|:
name|cv_undef
argument_list|(
operator|(
name|CV
operator|*
operator|)
name|sv
argument_list|)
expr_stmt|;
goto|goto
name|freescalar
goto|;
case|case
name|SVt_PVHV
case|:
name|hv_undef
argument_list|(
operator|(
name|HV
operator|*
operator|)
name|sv
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVAV
case|:
name|av_undef
argument_list|(
operator|(
name|AV
operator|*
operator|)
name|sv
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVLV
case|:
name|SvREFCNT_dec
argument_list|(
name|LvTARG
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|freescalar
goto|;
case|case
name|SVt_PVGV
case|:
name|gp_free
argument_list|(
operator|(
name|GV
operator|*
operator|)
name|sv
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|GvNAME
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* cannot decrease stash refcount yet, as we might recursively delete 	   ourselves when the refcnt drops to zero. Delay SvREFCNT_dec 	   of stash until current sv is completely gone. 	   -- JohnPC, 27 Mar 1998 */
name|stash
operator|=
name|GvSTASH
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|SVt_PVMG
case|:
case|case
name|SVt_PVNV
case|:
case|case
name|SVt_PVIV
case|:
name|freescalar
label|:
operator|(
name|void
operator|)
name|SvOOK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|SVt_PV
case|:
case|case
name|SVt_RV
case|:
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
name|SvREFCNT_dec
argument_list|(
name|SvRV
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvLEN
argument_list|(
name|sv
argument_list|)
condition|)
name|Safefree
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/*     case SVt_NV:     case SVt_IV:     case SVt_NULL: 	break; */
block|}
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
case|case
name|SVt_NULL
case|:
break|break;
case|case
name|SVt_IV
case|:
name|del_XIV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_NV
case|:
name|del_XNV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_RV
case|:
name|del_XRV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PV
case|:
name|del_XPV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVIV
case|:
name|del_XPVIV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVNV
case|:
name|del_XPVNV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVMG
case|:
name|del_XPVMG
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVLV
case|:
name|del_XPVLV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVAV
case|:
name|del_XPVAV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVHV
case|:
name|del_XPVHV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVCV
case|:
name|del_XPVCV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVGV
case|:
name|del_XPVGV
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* code duplication for increased performance. */
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&=
name|SVf_BREAK
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator||=
name|SVTYPEMASK
expr_stmt|;
comment|/* decrease refcount of the stash that owns this GV, if any */
if|if
condition|(
name|stash
condition|)
name|SvREFCNT_dec
argument_list|(
name|stash
argument_list|)
expr_stmt|;
return|return;
comment|/* not break, SvFLAGS reset already happened */
case|case
name|SVt_PVBM
case|:
name|del_XPVBM
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVFM
case|:
name|del_XPVFM
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVIO
case|:
name|del_XPVIO
argument_list|(
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&=
name|SVf_BREAK
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator||=
name|SVTYPEMASK
expr_stmt|;
block|}
end_function

begin_function
name|SV
modifier|*
name|sv_newref
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
name|sv
condition|)
name|ATOMIC_INC
argument_list|(
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_function
name|void
name|sv_free
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|int
name|refcount_is_zero
decl_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
return|return;
if|if
condition|(
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&
name|SVf_BREAK
condition|)
return|return;
if|if
condition|(
name|PL_in_clean_all
condition|)
comment|/* All is fair */
return|return;
if|if
condition|(
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvIMMORTAL
argument_list|(
name|sv
argument_list|)
condition|)
block|{
comment|/* make sure SvREFCNT(sv)==0 happens very seldom */
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|=
operator|(
operator|~
operator|(
name|U32
operator|)
literal|0
operator|)
operator|/
literal|2
expr_stmt|;
return|return;
block|}
name|warn
argument_list|(
literal|"Attempt to free unreferenced scalar"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ATOMIC_DEC_AND_TEST
argument_list|(
name|refcount_is_zero
argument_list|,
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|refcount_is_zero
condition|)
return|return;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|SvTEMP
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"Attempt to free temp prematurely: SV 0x%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sv
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvIMMORTAL
argument_list|(
name|sv
argument_list|)
condition|)
block|{
comment|/* make sure SvREFCNT(sv)==0 happens very seldom */
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|=
operator|(
operator|~
operator|(
name|U32
operator|)
literal|0
operator|)
operator|/
literal|2
expr_stmt|;
return|return;
block|}
name|sv_clear
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
condition|)
name|del_SV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STRLEN
name|sv_len
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|char
modifier|*
name|junk
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|len
operator|=
name|mg_length
argument_list|(
name|sv
argument_list|)
expr_stmt|;
else|else
name|junk
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_function
name|I32
name|sv_eq
parameter_list|(
specifier|register
name|SV
modifier|*
name|str1
parameter_list|,
specifier|register
name|SV
modifier|*
name|str2
parameter_list|)
block|{
name|char
modifier|*
name|pv1
decl_stmt|;
name|STRLEN
name|cur1
decl_stmt|;
name|char
modifier|*
name|pv2
decl_stmt|;
name|STRLEN
name|cur2
decl_stmt|;
if|if
condition|(
operator|!
name|str1
condition|)
block|{
name|pv1
operator|=
literal|""
expr_stmt|;
name|cur1
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|pv1
operator|=
name|SvPV
argument_list|(
name|str1
argument_list|,
name|cur1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str2
condition|)
return|return
operator|!
name|cur1
return|;
else|else
name|pv2
operator|=
name|SvPV
argument_list|(
name|str2
argument_list|,
name|cur2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur1
operator|!=
name|cur2
condition|)
return|return
literal|0
return|;
return|return
name|memEQ
argument_list|(
name|pv1
argument_list|,
name|pv2
argument_list|,
name|cur1
argument_list|)
return|;
block|}
end_function

begin_function
name|I32
name|sv_cmp
parameter_list|(
specifier|register
name|SV
modifier|*
name|str1
parameter_list|,
specifier|register
name|SV
modifier|*
name|str2
parameter_list|)
block|{
name|STRLEN
name|cur1
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|pv1
init|=
name|str1
condition|?
name|SvPV
argument_list|(
name|str1
argument_list|,
name|cur1
argument_list|)
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|STRLEN
name|cur2
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|pv2
init|=
name|str2
condition|?
name|SvPV
argument_list|(
name|str2
argument_list|,
name|cur2
argument_list|)
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|I32
name|retval
decl_stmt|;
if|if
condition|(
operator|!
name|cur1
condition|)
return|return
name|cur2
condition|?
operator|-
literal|1
else|:
literal|0
return|;
if|if
condition|(
operator|!
name|cur2
condition|)
return|return
literal|1
return|;
name|retval
operator|=
name|memcmp
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pv1
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pv2
argument_list|,
name|cur1
operator|<
name|cur2
condition|?
name|cur1
else|:
name|cur2
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
return|return
name|retval
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|1
return|;
if|if
condition|(
name|cur1
operator|==
name|cur2
condition|)
return|return
literal|0
return|;
else|else
return|return
name|cur1
operator|<
name|cur2
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
end_function

begin_function
name|I32
name|sv_cmp_locale
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv1
parameter_list|,
specifier|register
name|SV
modifier|*
name|sv2
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
name|char
modifier|*
name|pv1
decl_stmt|,
modifier|*
name|pv2
decl_stmt|;
name|STRLEN
name|len1
decl_stmt|,
name|len2
decl_stmt|;
name|I32
name|retval
decl_stmt|;
if|if
condition|(
name|PL_collation_standard
condition|)
goto|goto
name|raw_compare
goto|;
name|len1
operator|=
literal|0
expr_stmt|;
name|pv1
operator|=
name|sv1
condition|?
name|sv_collxfrm
argument_list|(
name|sv1
argument_list|,
operator|&
name|len1
argument_list|)
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|len2
operator|=
literal|0
expr_stmt|;
name|pv2
operator|=
name|sv2
condition|?
name|sv_collxfrm
argument_list|(
name|sv2
argument_list|,
operator|&
name|len2
argument_list|)
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|pv1
operator|||
operator|!
name|len1
condition|)
block|{
if|if
condition|(
name|pv2
operator|&&
name|len2
condition|)
return|return
operator|-
literal|1
return|;
else|else
goto|goto
name|raw_compare
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|pv2
operator|||
operator|!
name|len2
condition|)
return|return
literal|1
return|;
block|}
name|retval
operator|=
name|memcmp
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pv1
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pv2
argument_list|,
name|len1
operator|<
name|len2
condition|?
name|len1
else|:
name|len2
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
return|return
name|retval
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|1
return|;
comment|/*      * When the result of collation is equality, that doesn't mean      * that there are no differences -- some locales exclude some      * characters from consideration.  So to avoid false equalities,      * we use the raw string as a tiebreaker.      */
name|raw_compare
label|:
comment|/* FALL THROUGH */
endif|#
directive|endif
comment|/* USE_LOCALE_COLLATE */
return|return
name|sv_cmp
argument_list|(
name|sv1
argument_list|,
name|sv2
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LOCALE_COLLATE
end_ifdef

begin_comment
comment|/*  * Any scalar variable may carry an 'o' magic that contains the  * scalar data of the variable transformed to such a format that  * a normal memory comparison can be used to compare the data  * according to the locale settings.  */
end_comment

begin_function
name|char
modifier|*
name|sv_collxfrm
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
name|STRLEN
modifier|*
name|nxp
parameter_list|)
block|{
name|MAGIC
modifier|*
name|mg
decl_stmt|;
name|mg
operator|=
name|SvMAGICAL
argument_list|(
name|sv
argument_list|)
condition|?
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'o'
argument_list|)
else|:
operator|(
name|MAGIC
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|mg
operator|||
operator|!
name|mg
operator|->
name|mg_ptr
operator|||
operator|*
operator|(
name|U32
operator|*
operator|)
name|mg
operator|->
name|mg_ptr
operator|!=
name|PL_collation_ix
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|xf
decl_stmt|;
name|STRLEN
name|len
decl_stmt|,
name|xlen
decl_stmt|;
if|if
condition|(
name|mg
condition|)
name|Safefree
argument_list|(
name|mg
operator|->
name|mg_ptr
argument_list|)
expr_stmt|;
name|s
operator|=
name|SvPV
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|xf
operator|=
name|mem_collxfrm
argument_list|(
name|s
argument_list|,
name|len
argument_list|,
operator|&
name|xlen
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SAVEFREEPV
argument_list|(
name|xf
argument_list|)
expr_stmt|;
operator|*
name|nxp
operator|=
name|xlen
expr_stmt|;
return|return
name|xf
operator|+
sizeof|sizeof
argument_list|(
name|PL_collation_ix
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|mg
condition|)
block|{
name|sv_magic
argument_list|(
name|sv
argument_list|,
literal|0
argument_list|,
literal|'o'
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mg
operator|=
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'o'
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|mg
argument_list|)
expr_stmt|;
block|}
name|mg
operator|->
name|mg_ptr
operator|=
name|xf
expr_stmt|;
name|mg
operator|->
name|mg_len
operator|=
name|xlen
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mg
condition|)
block|{
name|mg
operator|->
name|mg_ptr
operator|=
name|NULL
expr_stmt|;
name|mg
operator|->
name|mg_len
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|mg
operator|&&
name|mg
operator|->
name|mg_ptr
condition|)
block|{
operator|*
name|nxp
operator|=
name|mg
operator|->
name|mg_len
expr_stmt|;
return|return
name|mg
operator|->
name|mg_ptr
operator|+
sizeof|sizeof
argument_list|(
name|PL_collation_ix
argument_list|)
return|;
block|}
else|else
block|{
operator|*
name|nxp
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_LOCALE_COLLATE */
end_comment

begin_function
name|char
modifier|*
name|sv_gets
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|,
specifier|register
name|PerlIO
modifier|*
name|fp
parameter_list|,
name|I32
name|append
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|char
modifier|*
name|rsptr
decl_stmt|;
name|STRLEN
name|rslen
decl_stmt|;
specifier|register
name|STDCHAR
name|rslast
decl_stmt|;
specifier|register
name|STDCHAR
modifier|*
name|bp
decl_stmt|;
specifier|register
name|I32
name|cnt
decl_stmt|;
name|I32
name|i
decl_stmt|;
name|SV_CHECK_THINKFIRST
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
name|SvSCREAM_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|RsSNARF
argument_list|(
name|PL_rs
argument_list|)
condition|)
block|{
name|rsptr
operator|=
name|NULL
expr_stmt|;
name|rslen
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RsRECORD
argument_list|(
name|PL_rs
argument_list|)
condition|)
block|{
name|I32
name|recsize
decl_stmt|,
name|bytesread
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* Grab the size of the record we're getting */
name|recsize
operator|=
name|SvIV
argument_list|(
name|SvRV
argument_list|(
name|PL_rs
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* Validate pointer */
name|buffer
operator|=
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|recsize
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Go yank in */
ifdef|#
directive|ifdef
name|VMS
comment|/* VMS wants read instead of fread, because fread doesn't respect */
comment|/* RMS record boundaries. This is not necessarily a good thing to be */
comment|/* doing, but we've got no other real choice */
name|bytesread
operator|=
name|PerlLIO_read
argument_list|(
name|PerlIO_fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|recsize
argument_list|)
expr_stmt|;
else|#
directive|else
name|bytesread
operator|=
name|PerlIO_read
argument_list|(
name|fp
argument_list|,
name|buffer
argument_list|,
name|recsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|bytesread
argument_list|)
expr_stmt|;
name|buffer
index|[
name|bytesread
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|SvCUR
argument_list|(
name|sv
argument_list|)
condition|?
name|SvPVX
argument_list|(
name|sv
argument_list|)
else|:
name|Nullch
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|RsPARA
argument_list|(
name|PL_rs
argument_list|)
condition|)
block|{
name|rsptr
operator|=
literal|"\n\n"
expr_stmt|;
name|rslen
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|rsptr
operator|=
name|SvPV
argument_list|(
name|PL_rs
argument_list|,
name|rslen
argument_list|)
expr_stmt|;
name|rslast
operator|=
name|rslen
condition|?
name|rsptr
index|[
name|rslen
operator|-
literal|1
index|]
else|:
literal|'\0'
expr_stmt|;
if|if
condition|(
name|RsPARA
argument_list|(
name|PL_rs
argument_list|)
condition|)
block|{
comment|/* have to do this both before and after */
do|do
block|{
comment|/* to make sure file boundaries work right */
if|if
condition|(
name|PerlIO_eof
argument_list|(
name|fp
argument_list|)
condition|)
return|return
literal|0
return|;
name|i
operator|=
name|PerlIO_getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|PerlIO_ungetc
argument_list|(
name|fp
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|i
operator|!=
name|EOF
condition|)
do|;
block|}
comment|/* See if we know enough about I/O mechanism to cheat it ! */
comment|/* This used to be #ifdef test - it is made run-time test for ease        of abstracting out stdio interface. One call should be cheap         enough here - and may even be a macro allowing compile        time optimization.      */
if|if
condition|(
name|PerlIO_fast_gets
argument_list|(
name|fp
argument_list|)
condition|)
block|{
comment|/*      * We're going to steal some values from the stdio struct      * and put EVERYTHING in the innermost loop into registers.      */
specifier|register
name|STDCHAR
modifier|*
name|ptr
decl_stmt|;
name|STRLEN
name|bpx
decl_stmt|;
name|I32
name|shortbuffered
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
operator|&&
name|defined
argument_list|(
name|PERLIO_IS_STDIO
argument_list|)
comment|/* An ungetc()d char is handled separately from the regular      * buffer, so we getc() it back out and stuff it in the buffer.      */
name|i
operator|=
name|PerlIO_getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|EOF
condition|)
return|return
literal|0
return|;
operator|*
operator|(
operator|--
operator|(
operator|(
operator|*
name|fp
operator|)
operator|->
name|_ptr
operator|)
operator|)
operator|=
operator|(
name|unsigned
name|char
operator|)
name|i
expr_stmt|;
operator|(
operator|*
name|fp
operator|)
operator|->
name|_cnt
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* Here is some breathtakingly efficient cheating */
name|cnt
operator|=
name|PerlIO_get_cnt
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* get count into register */
operator|(
name|void
operator|)
name|SvPOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* validate pointer */
if|if
condition|(
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|-
name|append
operator|<=
name|cnt
operator|+
literal|1
condition|)
block|{
comment|/* make sure we have the room */
if|if
condition|(
name|cnt
operator|>
literal|80
operator|&&
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|>
name|append
condition|)
block|{
name|shortbuffered
operator|=
name|cnt
operator|-
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|+
name|append
operator|+
literal|1
expr_stmt|;
name|cnt
operator|-=
name|shortbuffered
expr_stmt|;
block|}
else|else
block|{
name|shortbuffered
operator|=
literal|0
expr_stmt|;
comment|/* remember that cnt can be negative */
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|append
operator|+
operator|(
name|cnt
operator|<=
literal|0
condition|?
literal|2
else|:
operator|(
name|cnt
operator|+
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|shortbuffered
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
operator|(
name|STDCHAR
operator|*
operator|)
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|append
expr_stmt|;
comment|/* move these two too to registers */
name|ptr
operator|=
operator|(
name|STDCHAR
operator|*
operator|)
name|PerlIO_get_ptr
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|DEBUG_P
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Screamer: entering, ptr=%ld, cnt=%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ptr
argument_list|,
operator|(
name|long
operator|)
name|cnt
argument_list|)
argument_list|)
expr_stmt|;
name|DEBUG_P
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Screamer: entering: FILE * thinks ptr=%ld, cnt=%ld, base=%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|PerlIO_get_ptr
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|PerlIO_get_cnt
argument_list|(
name|fp
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|PerlIO_has_base
argument_list|(
name|fp
argument_list|)
condition|?
name|PerlIO_get_base
argument_list|(
name|fp
argument_list|)
else|:
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|screamer
label|:
if|if
condition|(
name|cnt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|rslen
condition|)
block|{
while|while
condition|(
name|cnt
operator|>
literal|0
condition|)
block|{
comment|/* this     |  eat */
name|cnt
operator|--
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|bp
operator|++
operator|=
operator|*
name|ptr
operator|++
operator|)
operator|==
name|rslast
condition|)
comment|/* really   |  dust */
goto|goto
name|thats_all_folks
goto|;
comment|/* screams  |  sed :-) */
block|}
block|}
else|else
block|{
name|Copy
argument_list|(
name|ptr
argument_list|,
name|bp
argument_list|,
name|cnt
argument_list|,
name|char
argument_list|)
expr_stmt|;
comment|/* this     |  eat */
name|bp
operator|+=
name|cnt
expr_stmt|;
comment|/* screams  |  dust */
name|ptr
operator|+=
name|cnt
expr_stmt|;
comment|/* louder   |  sed :-) */
name|cnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|shortbuffered
condition|)
block|{
comment|/* oh well, must extend */
name|cnt
operator|=
name|shortbuffered
expr_stmt|;
name|shortbuffered
operator|=
literal|0
expr_stmt|;
name|bpx
operator|=
name|bp
operator|-
operator|(
name|STDCHAR
operator|*
operator|)
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* box up before relocation */
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|bpx
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|SvLEN
argument_list|(
name|sv
argument_list|)
operator|+
name|append
operator|+
name|cnt
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|(
name|STDCHAR
operator|*
operator|)
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|bpx
expr_stmt|;
comment|/* unbox after relocation */
continue|continue;
block|}
name|DEBUG_P
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Screamer: going to getc, ptr=%ld, cnt=%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ptr
argument_list|,
operator|(
name|long
operator|)
name|cnt
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_set_ptrcnt
argument_list|(
name|fp
argument_list|,
name|ptr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
comment|/* deregisterize cnt and ptr */
name|DEBUG_P
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Screamer: pre: FILE * thinks ptr=%ld, cnt=%ld, base=%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|PerlIO_get_ptr
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|PerlIO_get_cnt
argument_list|(
name|fp
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|PerlIO_has_base
argument_list|(
name|fp
argument_list|)
condition|?
name|PerlIO_get_base
argument_list|(
name|fp
argument_list|)
else|:
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This used to call 'filbuf' in stdio form, but as that behaves like  	   getc when cnt<= 0 we use PerlIO_getc here to avoid introducing 	   another abstraction.  */
name|i
operator|=
name|PerlIO_getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* get more characters */
name|DEBUG_P
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Screamer: post: FILE * thinks ptr=%ld, cnt=%ld, base=%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|PerlIO_get_ptr
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|PerlIO_get_cnt
argument_list|(
name|fp
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|PerlIO_has_base
argument_list|(
name|fp
argument_list|)
condition|?
name|PerlIO_get_base
argument_list|(
name|fp
argument_list|)
else|:
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|PerlIO_get_cnt
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|STDCHAR
operator|*
operator|)
name|PerlIO_get_ptr
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* reregisterize cnt and ptr */
name|DEBUG_P
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Screamer: after getc, ptr=%ld, cnt=%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ptr
argument_list|,
operator|(
name|long
operator|)
name|cnt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|EOF
condition|)
comment|/* all done for ever? */
goto|goto
name|thats_really_all_folks
goto|;
name|bpx
operator|=
name|bp
operator|-
operator|(
name|STDCHAR
operator|*
operator|)
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* box up before relocation */
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|bpx
argument_list|)
expr_stmt|;
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|bpx
operator|+
name|cnt
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|(
name|STDCHAR
operator|*
operator|)
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|bpx
expr_stmt|;
comment|/* unbox after relocation */
operator|*
name|bp
operator|++
operator|=
name|i
expr_stmt|;
comment|/* store character from PerlIO_getc */
if|if
condition|(
name|rslen
operator|&&
operator|(
name|STDCHAR
operator|)
name|i
operator|==
name|rslast
condition|)
comment|/* all done for now? */
goto|goto
name|thats_all_folks
goto|;
block|}
name|thats_all_folks
label|:
if|if
condition|(
operator|(
name|rslen
operator|>
literal|1
operator|&&
operator|(
name|bp
operator|-
operator|(
name|STDCHAR
operator|*
operator|)
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|<
name|rslen
operator|)
operator|)
operator|||
name|memNE
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
operator|-
name|rslen
argument_list|,
name|rsptr
argument_list|,
name|rslen
argument_list|)
condition|)
goto|goto
name|screamer
goto|;
comment|/* go back to the fray */
name|thats_really_all_folks
label|:
if|if
condition|(
name|shortbuffered
condition|)
name|cnt
operator|+=
name|shortbuffered
expr_stmt|;
name|DEBUG_P
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Screamer: quitting, ptr=%ld, cnt=%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ptr
argument_list|,
operator|(
name|long
operator|)
name|cnt
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_set_ptrcnt
argument_list|(
name|fp
argument_list|,
name|ptr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
comment|/* put these back or we're in trouble */
name|DEBUG_P
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Screamer: end: FILE * thinks ptr=%ld, cnt=%ld, base=%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|PerlIO_get_ptr
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|PerlIO_get_cnt
argument_list|(
name|fp
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|PerlIO_has_base
argument_list|(
name|fp
argument_list|)
condition|?
name|PerlIO_get_base
argument_list|(
name|fp
argument_list|)
else|:
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|bp
operator|-
operator|(
name|STDCHAR
operator|*
operator|)
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set length */
name|DEBUG_P
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"Screamer: done, len=%ld, string=|%.*s|\n"
argument_list|,
operator|(
name|long
operator|)
name|SvCUR
argument_list|(
name|sv
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|SvCUR
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*The big, slow, and stupid way */
name|STDCHAR
name|buf
index|[
literal|8192
index|]
decl_stmt|;
name|screamer2
label|:
if|if
condition|(
name|rslen
condition|)
block|{
specifier|register
name|STDCHAR
modifier|*
name|bpe
init|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|PerlIO_getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
operator|(
operator|*
name|bp
operator|++
operator|=
name|i
operator|)
operator|!=
name|rslast
operator|&&
name|bp
operator|<
name|bpe
condition|)
empty_stmt|;
comment|/* keep reading */
name|cnt
operator|=
name|bp
operator|-
name|buf
expr_stmt|;
block|}
else|else
block|{
name|cnt
operator|=
name|PerlIO_read
argument_list|(
name|fp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Accomodate broken VAXC compiler, which applies U8 cast to 	     * both args of ?: operator, causing EOF to change into 255 	     */
if|if
condition|(
name|cnt
condition|)
block|{
name|i
operator|=
operator|(
name|U8
operator|)
name|buf
index|[
name|cnt
operator|-
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|EOF
expr_stmt|;
block|}
block|}
if|if
condition|(
name|append
condition|)
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
else|else
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|EOF
operator|&&
comment|/* joy */
operator|(
operator|!
name|rslen
operator|||
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|<
name|rslen
operator|||
name|memNE
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|-
name|rslen
argument_list|,
name|rsptr
argument_list|,
name|rslen
argument_list|)
operator|)
condition|)
block|{
name|append
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	     * If we're reading from a TTY and we get a short read, 	     * indicating that the user hit his EOF character, we need 	     * to notice it now, because if we try to read from the TTY 	     * again, the EOF condition will disappear. 	     * 	     * The comparison of cnt to sizeof(buf) is an optimization 	     * that prevents unnecessary calls to feof(). 	     * 	     * - jik 9/25/96 	     */
if|if
condition|(
operator|!
operator|(
name|cnt
operator|<
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|&&
name|PerlIO_eof
argument_list|(
name|fp
argument_list|)
operator|)
condition|)
goto|goto
name|screamer2
goto|;
block|}
block|}
if|if
condition|(
name|RsPARA
argument_list|(
name|PL_rs
argument_list|)
condition|)
block|{
comment|/* have to do this both before and after */
while|while
condition|(
name|i
operator|!=
name|EOF
condition|)
block|{
comment|/* to make sure file boundaries work right */
name|i
operator|=
name|PerlIO_getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|'\n'
condition|)
block|{
name|PerlIO_ungetc
argument_list|(
name|fp
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|WIN32
name|win32_strip_return
argument_list|(
name|sv
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|-
name|append
operator|)
condition|?
name|SvPVX
argument_list|(
name|sv
argument_list|)
else|:
name|Nullch
return|;
block|}
end_function

begin_function
name|void
name|sv_inc
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
name|int
name|flags
decl_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
return|return;
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTHINKFIRST
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
name|PL_curcop
operator|!=
operator|&
name|PL_compiling
condition|)
name|croak
argument_list|(
name|no_modify
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|IV
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|OVERLOAD
if|if
condition|(
name|SvAMAGIC
argument_list|(
name|sv
argument_list|)
operator|&&
name|AMG_CALLun
argument_list|(
name|sv
argument_list|,
name|inc
argument_list|)
condition|)
return|return;
endif|#
directive|endif
comment|/* OVERLOAD */
name|i
operator|=
operator|(
name|IV
operator|)
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv_unref
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv_setiv
argument_list|(
name|sv
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|flags
operator|=
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SVp_NOK
condition|)
block|{
operator|(
name|void
operator|)
name|SvNOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|+=
literal|1.0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|flags
operator|&
name|SVp_IOK
condition|)
block|{
if|if
condition|(
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|==
name|IV_MAX
condition|)
name|sv_setnv
argument_list|(
name|sv
argument_list|,
operator|(
name|double
operator|)
name|IV_MAX
operator|+
literal|1.0
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|SvIOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|++
name|SvIVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SVp_POK
operator|)
operator|||
operator|!
operator|*
name|SvPVX
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|SVTYPEMASK
operator|)
operator|<
name|SVt_PVNV
condition|)
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_NV
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
literal|1.0
expr_stmt|;
operator|(
name|void
operator|)
name|SvNOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
while|while
condition|(
name|isALPHA
argument_list|(
operator|*
name|d
argument_list|)
condition|)
name|d
operator|++
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|d
argument_list|)
condition|)
name|d
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|d
condition|)
block|{
name|SET_NUMERIC_STANDARD
argument_list|()
expr_stmt|;
name|sv_setnv
argument_list|(
name|sv
argument_list|,
name|atof
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|+
literal|1.0
argument_list|)
expr_stmt|;
comment|/* punt */
return|return;
block|}
name|d
operator|--
expr_stmt|;
while|while
condition|(
name|d
operator|>=
name|SvPVX
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|d
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
operator|*
name|d
operator|<=
literal|'9'
condition|)
return|return;
operator|*
operator|(
name|d
operator|--
operator|)
operator|=
literal|'0'
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|EBCDIC
comment|/* MKS: The original code here died if letters weren't consecutive. 	     * at least it didn't have to worry about non-C locales.  The 	     * new code assumes that ('z'-'a')==('Z'-'A'), letters are 	     * arranged in order (although not consecutively) and that only  	     * [A-Za-z] are accepted by isALPHA in the C locale. 	     */
if|if
condition|(
operator|*
name|d
operator|!=
literal|'z'
operator|&&
operator|*
name|d
operator|!=
literal|'Z'
condition|)
block|{
do|do
block|{
operator|++
operator|*
name|d
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|isALPHA
argument_list|(
operator|*
name|d
argument_list|)
condition|)
do|;
return|return;
block|}
operator|*
operator|(
name|d
operator|--
operator|)
operator|-=
literal|'z'
operator|-
literal|'a'
expr_stmt|;
else|#
directive|else
operator|++
operator|*
name|d
expr_stmt|;
if|if
condition|(
name|isALPHA
argument_list|(
operator|*
name|d
argument_list|)
condition|)
return|return;
operator|*
operator|(
name|d
operator|--
operator|)
operator|-=
literal|'z'
operator|-
literal|'a'
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* oh,oh, the number grew */
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|++
expr_stmt|;
for|for
control|(
name|d
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|+
name|SvCUR
argument_list|(
name|sv
argument_list|)
init|;
name|d
operator|>
name|SvPVX
argument_list|(
name|sv
argument_list|)
condition|;
name|d
operator|--
control|)
operator|*
name|d
operator|=
name|d
index|[
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|isDIGIT
argument_list|(
name|d
index|[
literal|1
index|]
argument_list|)
condition|)
operator|*
name|d
operator|=
literal|'1'
expr_stmt|;
else|else
operator|*
name|d
operator|=
name|d
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_dec
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|int
name|flags
decl_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
return|return;
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTHINKFIRST
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
name|PL_curcop
operator|!=
operator|&
name|PL_compiling
condition|)
name|croak
argument_list|(
name|no_modify
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|IV
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|OVERLOAD
if|if
condition|(
name|SvAMAGIC
argument_list|(
name|sv
argument_list|)
operator|&&
name|AMG_CALLun
argument_list|(
name|sv
argument_list|,
name|dec
argument_list|)
condition|)
return|return;
endif|#
directive|endif
comment|/* OVERLOAD */
name|i
operator|=
operator|(
name|IV
operator|)
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv_unref
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv_setiv
argument_list|(
name|sv
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|flags
operator|=
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SVp_NOK
condition|)
block|{
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|-=
literal|1.0
expr_stmt|;
operator|(
name|void
operator|)
name|SvNOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|flags
operator|&
name|SVp_IOK
condition|)
block|{
if|if
condition|(
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|==
name|IV_MIN
condition|)
name|sv_setnv
argument_list|(
name|sv
argument_list|,
operator|(
name|double
operator|)
name|IV_MIN
operator|-
literal|1.0
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|SvIOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|--
name|SvIVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SVp_POK
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|SVTYPEMASK
operator|)
operator|<
name|SVt_PVNV
condition|)
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_NV
argument_list|)
expr_stmt|;
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|=
operator|-
literal|1.0
expr_stmt|;
operator|(
name|void
operator|)
name|SvNOK_only
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return;
block|}
name|SET_NUMERIC_STANDARD
argument_list|()
expr_stmt|;
name|sv_setnv
argument_list|(
name|sv
argument_list|,
name|atof
argument_list|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|-
literal|1.0
argument_list|)
expr_stmt|;
comment|/* punt */
block|}
end_function

begin_comment
comment|/* Make a string that will exist for the duration of the expression  * evaluation.  Actually, it may have to last longer than that, but  * hopefully we won't free it until it has been assigned to a  * permanent location. */
end_comment

begin_function
name|STATIC
name|void
name|sv_mortalgrow
parameter_list|(
name|void
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|PL_tmps_max
operator|+=
operator|(
name|PL_tmps_max
operator|<
literal|512
operator|)
condition|?
literal|128
else|:
literal|512
expr_stmt|;
name|Renew
argument_list|(
name|PL_tmps_stack
argument_list|,
name|PL_tmps_max
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|SV
modifier|*
name|sv_mortalcopy
parameter_list|(
name|SV
modifier|*
name|oldstr
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|new_SV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|sv_setsv
argument_list|(
name|sv
argument_list|,
name|oldstr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|PL_tmps_ix
operator|>=
name|PL_tmps_max
condition|)
name|sv_mortalgrow
argument_list|()
expr_stmt|;
name|PL_tmps_stack
index|[
name|PL_tmps_ix
index|]
operator|=
name|sv
expr_stmt|;
name|SvTEMP_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_function
name|SV
modifier|*
name|sv_newmortal
parameter_list|(
name|void
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|new_SV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|=
name|SVs_TEMP
expr_stmt|;
if|if
condition|(
operator|++
name|PL_tmps_ix
operator|>=
name|PL_tmps_max
condition|)
name|sv_mortalgrow
argument_list|()
expr_stmt|;
name|PL_tmps_stack
index|[
name|PL_tmps_ix
index|]
operator|=
name|sv
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_comment
comment|/* same thing without the copying */
end_comment

begin_function
name|SV
modifier|*
name|sv_2mortal
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
return|return
name|sv
return|;
if|if
condition|(
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvIMMORTAL
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|sv
return|;
if|if
condition|(
operator|++
name|PL_tmps_ix
operator|>=
name|PL_tmps_max
condition|)
name|sv_mortalgrow
argument_list|()
expr_stmt|;
name|PL_tmps_stack
index|[
name|PL_tmps_ix
index|]
operator|=
name|sv
expr_stmt|;
name|SvTEMP_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_function
name|SV
modifier|*
name|newSVpv
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|STRLEN
name|len
parameter_list|)
block|{
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|new_SV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_function
name|SV
modifier|*
name|newSVpvn
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|STRLEN
name|len
parameter_list|)
block|{
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|new_SV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_function
name|SV
modifier|*
name|newSVpvf
parameter_list|(
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|new_SV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|sv_vsetpvfn
argument_list|(
name|sv
argument_list|,
name|pat
argument_list|,
name|strlen
argument_list|(
name|pat
argument_list|)
argument_list|,
operator|&
name|args
argument_list|,
name|Null
argument_list|(
name|SV
operator|*
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Null
argument_list|(
name|bool
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_function
name|SV
modifier|*
name|newSVnv
parameter_list|(
name|double
name|n
parameter_list|)
block|{
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|new_SV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|sv_setnv
argument_list|(
name|sv
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_function
name|SV
modifier|*
name|newSViv
parameter_list|(
name|IV
name|i
parameter_list|)
block|{
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|new_SV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|sv_setiv
argument_list|(
name|sv
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_function
name|SV
modifier|*
name|newRV_noinc
parameter_list|(
name|SV
modifier|*
name|tmpRef
parameter_list|)
block|{
name|dTHR
expr_stmt|;
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
name|new_SV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_RV
argument_list|)
expr_stmt|;
name|SvTEMP_off
argument_list|(
name|tmpRef
argument_list|)
expr_stmt|;
name|SvRV
argument_list|(
name|sv
argument_list|)
operator|=
name|tmpRef
expr_stmt|;
name|SvROK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_function
name|SV
modifier|*
name|newRV
parameter_list|(
name|SV
modifier|*
name|tmpRef
parameter_list|)
block|{
return|return
name|newRV_noinc
argument_list|(
name|SvREFCNT_inc
argument_list|(
name|tmpRef
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* make an exact duplicate of old */
end_comment

begin_function
name|SV
modifier|*
name|newSVsv
parameter_list|(
specifier|register
name|SV
modifier|*
name|old
parameter_list|)
block|{
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
operator|!
name|old
condition|)
return|return
name|Nullsv
return|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|old
argument_list|)
operator|==
name|SVTYPEMASK
condition|)
block|{
name|warn
argument_list|(
literal|"semi-panic: attempt to dup freed string"
argument_list|)
expr_stmt|;
return|return
name|Nullsv
return|;
block|}
name|new_SV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SvTEMP
argument_list|(
name|old
argument_list|)
condition|)
block|{
name|SvTEMP_off
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|sv_setsv
argument_list|(
name|sv
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|SvTEMP_on
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
else|else
name|sv_setsv
argument_list|(
name|sv
argument_list|,
name|old
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_function
name|void
name|sv_reset
parameter_list|(
specifier|register
name|char
modifier|*
name|s
parameter_list|,
name|HV
modifier|*
name|stash
parameter_list|)
block|{
specifier|register
name|HE
modifier|*
name|entry
decl_stmt|;
specifier|register
name|GV
modifier|*
name|gv
decl_stmt|;
specifier|register
name|SV
modifier|*
name|sv
decl_stmt|;
specifier|register
name|I32
name|i
decl_stmt|;
specifier|register
name|PMOP
modifier|*
name|pm
decl_stmt|;
specifier|register
name|I32
name|max
decl_stmt|;
name|char
name|todo
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|stash
condition|)
return|return;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
block|{
comment|/* reset ?? searches */
for|for
control|(
name|pm
operator|=
name|HvPMROOT
argument_list|(
name|stash
argument_list|)
init|;
name|pm
condition|;
name|pm
operator|=
name|pm
operator|->
name|op_pmnext
control|)
block|{
name|pm
operator|->
name|op_pmdynflags
operator|&=
operator|~
name|PMdf_USED
expr_stmt|;
block|}
return|return;
block|}
comment|/* reset variables */
if|if
condition|(
operator|!
name|HvARRAY
argument_list|(
name|stash
argument_list|)
condition|)
return|return;
name|Zero
argument_list|(
name|todo
argument_list|,
literal|256
argument_list|,
name|char
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|i
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|s
operator|+=
literal|2
expr_stmt|;
block|}
name|max
operator|=
operator|*
name|s
operator|++
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
block|{
name|todo
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
operator|(
name|I32
operator|)
name|HvMAX
argument_list|(
name|stash
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|entry
operator|=
name|HvARRAY
argument_list|(
name|stash
argument_list|)
index|[
name|i
index|]
init|;
name|entry
condition|;
name|entry
operator|=
name|HeNEXT
argument_list|(
name|entry
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|todo
index|[
operator|(
name|U8
operator|)
operator|*
name|HeKEY
argument_list|(
name|entry
argument_list|)
index|]
condition|)
continue|continue;
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|HeVAL
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|sv
operator|=
name|GvSV
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTHINKFIRST
argument_list|(
name|sv
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_unref
argument_list|(
name|sv
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|SvOK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|>=
name|SVt_PV
condition|)
block|{
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|!=
name|Nullch
condition|)
operator|*
name|SvPVX
argument_list|(
name|sv
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
name|SvTAINT
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GvAV
argument_list|(
name|gv
argument_list|)
condition|)
block|{
name|av_clear
argument_list|(
name|GvAV
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GvHV
argument_list|(
name|gv
argument_list|)
operator|&&
operator|!
name|HvNAME
argument_list|(
name|GvHV
argument_list|(
name|gv
argument_list|)
argument_list|)
condition|)
block|{
name|hv_clear
argument_list|(
name|GvHV
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|VMS
comment|/* VMS has no environ array */
if|if
condition|(
name|gv
operator|==
name|PL_envgv
condition|)
name|environ
index|[
literal|0
index|]
operator|=
name|Nullch
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
name|IO
modifier|*
name|sv_2io
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|IO
modifier|*
name|io
decl_stmt|;
name|GV
modifier|*
name|gv
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
case|case
name|SVt_PVIO
case|:
name|io
operator|=
operator|(
name|IO
operator|*
operator|)
name|sv
expr_stmt|;
break|break;
case|case
name|SVt_PVGV
case|:
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|sv
expr_stmt|;
name|io
operator|=
name|GvIO
argument_list|(
name|gv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|io
condition|)
name|croak
argument_list|(
literal|"Bad filehandle: %s"
argument_list|,
name|GvNAME
argument_list|(
name|gv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|SvOK
argument_list|(
name|sv
argument_list|)
condition|)
name|croak
argument_list|(
name|no_usym
argument_list|,
literal|"filehandle"
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|sv_2io
argument_list|(
name|SvRV
argument_list|(
name|sv
argument_list|)
argument_list|)
return|;
name|gv
operator|=
name|gv_fetchpv
argument_list|(
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|SVt_PVIO
argument_list|)
expr_stmt|;
if|if
condition|(
name|gv
condition|)
name|io
operator|=
name|GvIO
argument_list|(
name|gv
argument_list|)
expr_stmt|;
else|else
name|io
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|io
condition|)
name|croak
argument_list|(
literal|"Bad filehandle: %s"
argument_list|,
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|io
return|;
block|}
end_function

begin_function
name|CV
modifier|*
name|sv_2cv
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
name|HV
modifier|*
modifier|*
name|st
parameter_list|,
name|GV
modifier|*
modifier|*
name|gvp
parameter_list|,
name|I32
name|lref
parameter_list|)
block|{
name|GV
modifier|*
name|gv
decl_stmt|;
name|CV
modifier|*
name|cv
decl_stmt|;
name|STRLEN
name|n_a
decl_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
return|return
operator|*
name|gvp
operator|=
name|Nullgv
operator|,
name|Nullcv
return|;
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
case|case
name|SVt_PVCV
case|:
operator|*
name|st
operator|=
name|CvSTASH
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|*
name|gvp
operator|=
name|Nullgv
expr_stmt|;
return|return
operator|(
name|CV
operator|*
operator|)
name|sv
return|;
case|case
name|SVt_PVHV
case|:
case|case
name|SVt_PVAV
case|:
operator|*
name|gvp
operator|=
name|Nullgv
expr_stmt|;
return|return
name|Nullcv
return|;
case|case
name|SVt_PVGV
case|:
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|sv
expr_stmt|;
operator|*
name|gvp
operator|=
name|gv
expr_stmt|;
operator|*
name|st
operator|=
name|GvESTASH
argument_list|(
name|gv
argument_list|)
expr_stmt|;
goto|goto
name|fix_gv
goto|;
default|default:
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|sv
operator|=
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_PVCV
condition|)
block|{
name|cv
operator|=
operator|(
name|CV
operator|*
operator|)
name|sv
expr_stmt|;
operator|*
name|gvp
operator|=
name|Nullgv
expr_stmt|;
operator|*
name|st
operator|=
name|CvSTASH
argument_list|(
name|cv
argument_list|)
expr_stmt|;
return|return
name|cv
return|;
block|}
elseif|else
if|if
condition|(
name|isGV
argument_list|(
name|sv
argument_list|)
condition|)
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|sv
expr_stmt|;
else|else
name|croak
argument_list|(
literal|"Not a subroutine reference"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isGV
argument_list|(
name|sv
argument_list|)
condition|)
name|gv
operator|=
operator|(
name|GV
operator|*
operator|)
name|sv
expr_stmt|;
else|else
name|gv
operator|=
name|gv_fetchpv
argument_list|(
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
argument_list|,
name|lref
argument_list|,
name|SVt_PVCV
argument_list|)
expr_stmt|;
operator|*
name|gvp
operator|=
name|gv
expr_stmt|;
if|if
condition|(
operator|!
name|gv
condition|)
return|return
name|Nullcv
return|;
operator|*
name|st
operator|=
name|GvESTASH
argument_list|(
name|gv
argument_list|)
expr_stmt|;
name|fix_gv
label|:
if|if
condition|(
name|lref
operator|&&
operator|!
name|GvCVu
argument_list|(
name|gv
argument_list|)
condition|)
block|{
name|SV
modifier|*
name|tmpsv
decl_stmt|;
name|ENTER
expr_stmt|;
name|tmpsv
operator|=
name|NEWSV
argument_list|(
literal|704
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gv_efullname3
argument_list|(
name|tmpsv
argument_list|,
name|gv
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
name|newSUB
argument_list|(
name|start_subparse
argument_list|(
name|FALSE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|tmpsv
argument_list|)
argument_list|,
name|Nullop
argument_list|,
name|Nullop
argument_list|)
expr_stmt|;
name|LEAVE
expr_stmt|;
if|if
condition|(
operator|!
name|GvCVu
argument_list|(
name|gv
argument_list|)
condition|)
name|croak
argument_list|(
literal|"Unable to create sub named \"%s\""
argument_list|,
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|GvCVu
argument_list|(
name|gv
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|I32
name|sv_true
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|SvPOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
specifier|register
name|XPV
modifier|*
name|tXpv
decl_stmt|;
if|if
condition|(
operator|(
name|tXpv
operator|=
operator|(
name|XPV
operator|*
operator|)
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|)
operator|&&
operator|(
operator|*
name|tXpv
operator|->
name|xpv_pv
operator|>
literal|'0'
operator|||
name|tXpv
operator|->
name|xpv_cur
operator|>
literal|1
operator|||
operator|(
name|tXpv
operator|->
name|xpv_cur
operator|&&
operator|*
name|tXpv
operator|->
name|xpv_pv
operator|!=
literal|'0'
operator|)
operator|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|SvIOK
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|!=
literal|0
return|;
else|else
block|{
if|if
condition|(
name|SvNOK
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|SvNVX
argument_list|(
name|sv
argument_list|)
operator|!=
literal|0.0
return|;
else|else
return|return
name|sv_2bool
argument_list|(
name|sv
argument_list|)
return|;
block|}
block|}
block|}
end_function

begin_function
name|IV
name|sv_iv
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
name|SvIOK
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|SvIVX
argument_list|(
name|sv
argument_list|)
return|;
return|return
name|sv_2iv
argument_list|(
name|sv
argument_list|)
return|;
block|}
end_function

begin_function
name|UV
name|sv_uv
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
name|SvIOK
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|SvUVX
argument_list|(
name|sv
argument_list|)
return|;
return|return
name|sv_2uv
argument_list|(
name|sv
argument_list|)
return|;
block|}
end_function

begin_function
name|double
name|sv_nv
parameter_list|(
specifier|register
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
name|SvNOK
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|SvNVX
argument_list|(
name|sv
argument_list|)
return|;
return|return
name|sv_2nv
argument_list|(
name|sv
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|sv_pvn
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
name|STRLEN
modifier|*
name|lp
parameter_list|)
block|{
if|if
condition|(
name|SvPOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
operator|*
name|lp
operator|=
name|SvCUR
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|SvPVX
argument_list|(
name|sv
argument_list|)
return|;
block|}
return|return
name|sv_2pv
argument_list|(
name|sv
argument_list|,
name|lp
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|sv_pvn_force
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
name|STRLEN
modifier|*
name|lp
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|SvREADONLY
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|dTHR
expr_stmt|;
if|if
condition|(
name|PL_curcop
operator|!=
operator|&
name|PL_compiling
condition|)
name|croak
argument_list|(
name|no_modify
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SvPOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
operator|*
name|lp
operator|=
name|SvCUR
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|>
name|SVt_PVLV
operator|&&
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|!=
name|SVt_PVFM
condition|)
block|{
if|if
condition|(
name|SvFAKE
argument_list|(
name|sv
argument_list|)
operator|&&
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_PVGV
condition|)
block|{
name|sv_unglob
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|s
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|=
name|SvCUR
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dTHR
expr_stmt|;
name|croak
argument_list|(
literal|"Can't coerce %s to string in %s"
argument_list|,
name|sv_reftype
argument_list|(
name|sv
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op_name
index|[
name|PL_op
operator|->
name|op_type
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|s
operator|=
name|sv_2pv
argument_list|(
name|sv
argument_list|,
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|SvPVX
argument_list|(
name|sv
argument_list|)
condition|)
block|{
comment|/* Almost, but not quite, sv_setpvn() */
name|STRLEN
name|len
init|=
operator|*
name|lp
decl_stmt|;
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_unref
argument_list|(
name|sv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|sv
argument_list|,
name|SVt_PV
argument_list|)
expr_stmt|;
comment|/* Never FALSE */
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Move
argument_list|(
name|s
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|len
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|SvCUR_set
argument_list|(
name|sv
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|SvEND
argument_list|(
name|sv
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SvPOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SvPOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
comment|/* validate pointer */
name|SvTAINT
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|DEBUG_c
argument_list|(
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"0x%lx 2pv(%s)\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sv
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SvPVX
argument_list|(
name|sv
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|sv_reftype
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
name|int
name|ob
parameter_list|)
block|{
if|if
condition|(
name|ob
operator|&&
name|SvOBJECT
argument_list|(
name|sv
argument_list|)
condition|)
return|return
name|HvNAME
argument_list|(
name|SvSTASH
argument_list|(
name|sv
argument_list|)
argument_list|)
return|;
else|else
block|{
switch|switch
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
condition|)
block|{
case|case
name|SVt_NULL
case|:
case|case
name|SVt_IV
case|:
case|case
name|SVt_NV
case|:
case|case
name|SVt_RV
case|:
case|case
name|SVt_PV
case|:
case|case
name|SVt_PVIV
case|:
case|case
name|SVt_PVNV
case|:
case|case
name|SVt_PVMG
case|:
case|case
name|SVt_PVBM
case|:
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
return|return
literal|"REF"
return|;
else|else
return|return
literal|"SCALAR"
return|;
case|case
name|SVt_PVLV
case|:
return|return
literal|"LVALUE"
return|;
case|case
name|SVt_PVAV
case|:
return|return
literal|"ARRAY"
return|;
case|case
name|SVt_PVHV
case|:
return|return
literal|"HASH"
return|;
case|case
name|SVt_PVCV
case|:
return|return
literal|"CODE"
return|;
case|case
name|SVt_PVGV
case|:
return|return
literal|"GLOB"
return|;
case|case
name|SVt_PVFM
case|:
return|return
literal|"FORMAT"
return|;
default|default:
return|return
literal|"UNKNOWN"
return|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|sv_isobject
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sv
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
return|return
literal|0
return|;
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvOBJECT
argument_list|(
name|sv
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|sv_isa
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sv
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|SvGMAGICAL
argument_list|(
name|sv
argument_list|)
condition|)
name|mg_get
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
return|return
literal|0
return|;
name|sv
operator|=
operator|(
name|SV
operator|*
operator|)
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SvOBJECT
argument_list|(
name|sv
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|strEQ
argument_list|(
name|HvNAME
argument_list|(
name|SvSTASH
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|SV
modifier|*
name|newSVrv
parameter_list|(
name|SV
modifier|*
name|rv
parameter_list|,
name|char
modifier|*
name|classname
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|SV
modifier|*
name|sv
decl_stmt|;
name|new_SV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvANY
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SV_CHECK_THINKFIRST
argument_list|(
name|rv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OVERLOAD
name|SvAMAGIC_off
argument_list|(
name|rv
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OVERLOAD */
if|if
condition|(
name|SvTYPE
argument_list|(
name|rv
argument_list|)
operator|<
name|SVt_RV
condition|)
name|sv_upgrade
argument_list|(
name|rv
argument_list|,
name|SVt_RV
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SvOK_off
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|SvRV
argument_list|(
name|rv
argument_list|)
operator|=
name|SvREFCNT_inc
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvROK_on
argument_list|(
name|rv
argument_list|)
expr_stmt|;
if|if
condition|(
name|classname
condition|)
block|{
name|HV
modifier|*
name|stash
init|=
name|gv_stashpv
argument_list|(
name|classname
argument_list|,
name|TRUE
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|sv_bless
argument_list|(
name|rv
argument_list|,
name|stash
argument_list|)
expr_stmt|;
block|}
return|return
name|sv
return|;
block|}
end_function

begin_function
name|SV
modifier|*
name|sv_setref_pv
parameter_list|(
name|SV
modifier|*
name|rv
parameter_list|,
name|char
modifier|*
name|classname
parameter_list|,
name|void
modifier|*
name|pv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pv
condition|)
block|{
name|sv_setsv
argument_list|(
name|rv
argument_list|,
operator|&
name|PL_sv_undef
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|rv
argument_list|)
expr_stmt|;
block|}
else|else
name|sv_setiv
argument_list|(
name|newSVrv
argument_list|(
name|rv
argument_list|,
name|classname
argument_list|)
argument_list|,
operator|(
name|IV
operator|)
name|pv
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
name|SV
modifier|*
name|sv_setref_iv
parameter_list|(
name|SV
modifier|*
name|rv
parameter_list|,
name|char
modifier|*
name|classname
parameter_list|,
name|IV
name|iv
parameter_list|)
block|{
name|sv_setiv
argument_list|(
name|newSVrv
argument_list|(
name|rv
argument_list|,
name|classname
argument_list|)
argument_list|,
name|iv
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
name|SV
modifier|*
name|sv_setref_nv
parameter_list|(
name|SV
modifier|*
name|rv
parameter_list|,
name|char
modifier|*
name|classname
parameter_list|,
name|double
name|nv
parameter_list|)
block|{
name|sv_setnv
argument_list|(
name|newSVrv
argument_list|(
name|rv
argument_list|,
name|classname
argument_list|)
argument_list|,
name|nv
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
name|SV
modifier|*
name|sv_setref_pvn
parameter_list|(
name|SV
modifier|*
name|rv
parameter_list|,
name|char
modifier|*
name|classname
parameter_list|,
name|char
modifier|*
name|pv
parameter_list|,
name|I32
name|n
parameter_list|)
block|{
name|sv_setpvn
argument_list|(
name|newSVrv
argument_list|(
name|rv
argument_list|,
name|classname
argument_list|)
argument_list|,
name|pv
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
name|SV
modifier|*
name|sv_bless
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
name|HV
modifier|*
name|stash
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|SV
modifier|*
name|tmpRef
decl_stmt|;
if|if
condition|(
operator|!
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
name|croak
argument_list|(
literal|"Can't bless non-reference value"
argument_list|)
expr_stmt|;
name|tmpRef
operator|=
name|SvRV
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvFLAGS
argument_list|(
name|tmpRef
argument_list|)
operator|&
operator|(
name|SVs_OBJECT
operator||
name|SVf_READONLY
operator|)
condition|)
block|{
if|if
condition|(
name|SvREADONLY
argument_list|(
name|tmpRef
argument_list|)
condition|)
name|croak
argument_list|(
name|no_modify
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvOBJECT
argument_list|(
name|tmpRef
argument_list|)
condition|)
block|{
if|if
condition|(
name|SvTYPE
argument_list|(
name|tmpRef
argument_list|)
operator|!=
name|SVt_PVIO
condition|)
operator|--
name|PL_sv_objcount
expr_stmt|;
name|SvREFCNT_dec
argument_list|(
name|SvSTASH
argument_list|(
name|tmpRef
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|SvOBJECT_on
argument_list|(
name|tmpRef
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvTYPE
argument_list|(
name|tmpRef
argument_list|)
operator|!=
name|SVt_PVIO
condition|)
operator|++
name|PL_sv_objcount
expr_stmt|;
operator|(
name|void
operator|)
name|SvUPGRADE
argument_list|(
name|tmpRef
argument_list|,
name|SVt_PVMG
argument_list|)
expr_stmt|;
name|SvSTASH
argument_list|(
name|tmpRef
argument_list|)
operator|=
operator|(
name|HV
operator|*
operator|)
name|SvREFCNT_inc
argument_list|(
name|stash
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OVERLOAD
if|if
condition|(
name|Gv_AMG
argument_list|(
name|stash
argument_list|)
condition|)
name|SvAMAGIC_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
else|else
name|SvAMAGIC_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OVERLOAD */
return|return
name|sv
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|sv_unglob
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|assert
argument_list|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|==
name|SVt_PVGV
argument_list|)
expr_stmt|;
name|SvFAKE_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|GvGP
argument_list|(
name|sv
argument_list|)
condition|)
name|gp_free
argument_list|(
operator|(
name|GV
operator|*
operator|)
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|GvSTASH
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|SvREFCNT_dec
argument_list|(
name|GvSTASH
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|GvSTASH
argument_list|(
name|sv
argument_list|)
operator|=
name|Nullhv
expr_stmt|;
block|}
name|sv_unmagic
argument_list|(
name|sv
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|GvNAME
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|GvMULTI_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator|&=
operator|~
name|SVTYPEMASK
expr_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator||=
name|SVt_PVMG
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_unref
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|SV
modifier|*
name|rv
init|=
name|SvRV
argument_list|(
name|sv
argument_list|)
decl_stmt|;
name|SvRV
argument_list|(
name|sv
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SvROK_off
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvREFCNT
argument_list|(
name|rv
argument_list|)
operator|!=
literal|1
operator|||
name|SvREADONLY
argument_list|(
name|rv
argument_list|)
condition|)
name|SvREFCNT_dec
argument_list|(
name|rv
argument_list|)
expr_stmt|;
else|else
name|sv_2mortal
argument_list|(
name|rv
argument_list|)
expr_stmt|;
comment|/* Schedule for freeing later */
block|}
end_function

begin_function
name|void
name|sv_taint
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|sv_magic
argument_list|(
operator|(
name|sv
operator|)
argument_list|,
name|Nullsv
argument_list|,
literal|'t'
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_untaint
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|>=
name|SVt_PVMG
operator|&&
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|MAGIC
modifier|*
name|mg
init|=
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'t'
argument_list|)
decl_stmt|;
if|if
condition|(
name|mg
condition|)
name|mg
operator|->
name|mg_len
operator|&=
operator|~
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|bool
name|sv_tainted
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|)
block|{
if|if
condition|(
name|SvTYPE
argument_list|(
name|sv
argument_list|)
operator|>=
name|SVt_PVMG
operator|&&
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|MAGIC
modifier|*
name|mg
init|=
name|mg_find
argument_list|(
name|sv
argument_list|,
literal|'t'
argument_list|)
decl_stmt|;
if|if
condition|(
name|mg
operator|&&
operator|(
operator|(
name|mg
operator|->
name|mg_len
operator|&
literal|1
operator|)
operator|||
operator|(
name|mg
operator|->
name|mg_len
operator|&
literal|2
operator|)
operator|&&
name|mg
operator|->
name|mg_obj
operator|==
name|sv
operator|)
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|void
name|sv_setpviv
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
name|IV
name|iv
parameter_list|)
block|{
name|STRLEN
name|len
decl_stmt|;
name|char
name|buf
index|[
name|TYPE_DIGITS
argument_list|(
name|UV
argument_list|)
index|]
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|int
name|sign
decl_stmt|;
name|UV
name|uv
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|iv
operator|>=
literal|0
condition|)
block|{
name|uv
operator|=
name|iv
expr_stmt|;
name|sign
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|uv
operator|=
operator|-
name|iv
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
block|}
do|do
block|{
operator|*
operator|--
name|ptr
operator|=
literal|'0'
operator|+
operator|(
name|uv
operator|%
literal|10
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|uv
operator|/=
literal|10
condition|)
do|;
name|len
operator|=
operator|(
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|)
operator|-
name|ptr
expr_stmt|;
comment|/* taking advantage of SvCUR(sv) == 0 */
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|sign
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|sign
condition|)
operator|*
name|p
operator|++
operator|=
literal|'-'
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|p
operator|-
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_setpviv_mg
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
name|IV
name|iv
parameter_list|)
block|{
name|sv_setpviv
argument_list|(
name|sv
argument_list|,
name|iv
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_setpvf
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|sv_vsetpvfn
argument_list|(
name|sv
argument_list|,
name|pat
argument_list|,
name|strlen
argument_list|(
name|pat
argument_list|)
argument_list|,
operator|&
name|args
argument_list|,
name|Null
argument_list|(
name|SV
operator|*
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Null
argument_list|(
name|bool
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_setpvf_mg
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|sv_vsetpvfn
argument_list|(
name|sv
argument_list|,
name|pat
argument_list|,
name|strlen
argument_list|(
name|pat
argument_list|)
argument_list|,
operator|&
name|args
argument_list|,
name|Null
argument_list|(
name|SV
operator|*
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Null
argument_list|(
name|bool
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_catpvf
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|sv_vcatpvfn
argument_list|(
name|sv
argument_list|,
name|pat
argument_list|,
name|strlen
argument_list|(
name|pat
argument_list|)
argument_list|,
operator|&
name|args
argument_list|,
name|Null
argument_list|(
name|SV
operator|*
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Null
argument_list|(
name|bool
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_catpvf_mg
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|sv_vcatpvfn
argument_list|(
name|sv
argument_list|,
name|pat
argument_list|,
name|strlen
argument_list|(
name|pat
argument_list|)
argument_list|,
operator|&
name|args
argument_list|,
name|Null
argument_list|(
name|SV
operator|*
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Null
argument_list|(
name|bool
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_vsetpvfn
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
name|STRLEN
name|patlen
parameter_list|,
name|va_list
modifier|*
name|args
parameter_list|,
name|SV
modifier|*
modifier|*
name|svargs
parameter_list|,
name|I32
name|svmax
parameter_list|,
name|bool
modifier|*
name|used_locale
parameter_list|)
block|{
name|sv_setpvn
argument_list|(
name|sv
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sv_vcatpvfn
argument_list|(
name|sv
argument_list|,
name|pat
argument_list|,
name|patlen
argument_list|,
name|args
argument_list|,
name|svargs
argument_list|,
name|svmax
argument_list|,
name|used_locale
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sv_vcatpvfn
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
name|STRLEN
name|patlen
parameter_list|,
name|va_list
modifier|*
name|args
parameter_list|,
name|SV
modifier|*
modifier|*
name|svargs
parameter_list|,
name|I32
name|svmax
parameter_list|,
name|bool
modifier|*
name|used_locale
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|patend
decl_stmt|;
name|STRLEN
name|origlen
decl_stmt|;
name|I32
name|svix
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|nullstr
index|[]
init|=
literal|"(null)"
decl_stmt|;
comment|/* no matter what, this is a string now */
operator|(
name|void
operator|)
name|SvPV_force
argument_list|(
name|sv
argument_list|,
name|origlen
argument_list|)
expr_stmt|;
comment|/* special-case "", "%s", and "%_" */
if|if
condition|(
name|patlen
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|patlen
operator|==
literal|2
operator|&&
name|pat
index|[
literal|0
index|]
operator|==
literal|'%'
condition|)
block|{
switch|switch
condition|(
name|pat
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'s'
case|:
if|if
condition|(
name|args
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|char
operator|*
argument_list|)
decl_stmt|;
name|sv_catpv
argument_list|(
name|sv
argument_list|,
name|s
condition|?
name|s
else|:
name|nullstr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|svix
operator|<
name|svmax
condition|)
name|sv_catsv
argument_list|(
name|sv
argument_list|,
operator|*
name|svargs
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'_'
case|:
if|if
condition|(
name|args
condition|)
block|{
name|sv_catsv
argument_list|(
name|sv
argument_list|,
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|SV
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* See comment on '_' below */
break|break;
block|}
block|}
name|patend
operator|=
operator|(
name|char
operator|*
operator|)
name|pat
operator|+
name|patlen
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|pat
init|;
name|p
operator|<
name|patend
condition|;
name|p
operator|=
name|q
control|)
block|{
name|bool
name|alt
init|=
name|FALSE
decl_stmt|;
name|bool
name|left
init|=
name|FALSE
decl_stmt|;
name|char
name|fill
init|=
literal|' '
decl_stmt|;
name|char
name|plus
init|=
literal|0
decl_stmt|;
name|char
name|intsize
init|=
literal|0
decl_stmt|;
name|STRLEN
name|width
init|=
literal|0
decl_stmt|;
name|STRLEN
name|zeros
init|=
literal|0
decl_stmt|;
name|bool
name|has_precis
init|=
name|FALSE
decl_stmt|;
name|STRLEN
name|precis
init|=
literal|0
decl_stmt|;
name|char
name|esignbuf
index|[
literal|4
index|]
decl_stmt|;
name|STRLEN
name|esignlen
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|eptr
init|=
name|Nullch
decl_stmt|;
name|STRLEN
name|elen
init|=
literal|0
decl_stmt|;
name|char
name|ebuf
index|[
name|TYPE_DIGITS
argument_list|(
name|int
argument_list|)
operator|*
literal|2
operator|+
literal|16
index|]
decl_stmt|;
comment|/* large enough for "%#.#f" */
ifndef|#
directive|ifndef
name|PERL_OBJECT
specifier|static
name|char
modifier|*
name|efloatbuf
init|=
name|Nullch
decl_stmt|;
specifier|static
name|STRLEN
name|efloatsize
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|char
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|base
decl_stmt|;
name|IV
name|iv
decl_stmt|;
name|UV
name|uv
decl_stmt|;
name|double
name|nv
decl_stmt|;
name|STRLEN
name|have
decl_stmt|;
name|STRLEN
name|need
decl_stmt|;
name|STRLEN
name|gap
decl_stmt|;
for|for
control|(
name|q
operator|=
name|p
init|;
name|q
operator|<
name|patend
operator|&&
operator|*
name|q
operator|!=
literal|'%'
condition|;
operator|++
name|q
control|)
empty_stmt|;
if|if
condition|(
name|q
operator|>
name|p
condition|)
block|{
name|sv_catpvn
argument_list|(
name|sv
argument_list|,
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|++
operator|>=
name|patend
condition|)
break|break;
comment|/* FLAGS */
while|while
condition|(
operator|*
name|q
condition|)
block|{
switch|switch
condition|(
operator|*
name|q
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'+'
case|:
name|plus
operator|=
operator|*
name|q
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'-'
case|:
name|left
operator|=
name|TRUE
expr_stmt|;
name|q
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'0'
case|:
name|fill
operator|=
operator|*
name|q
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'#'
case|:
name|alt
operator|=
name|TRUE
expr_stmt|;
name|q
operator|++
expr_stmt|;
continue|continue;
default|default:
break|break;
block|}
break|break;
block|}
comment|/* WIDTH */
switch|switch
condition|(
operator|*
name|q
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|width
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|q
argument_list|)
condition|)
name|width
operator|=
name|width
operator|*
literal|10
operator|+
operator|(
operator|*
name|q
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
name|args
condition|)
name|i
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
operator|(
name|svix
operator|<
name|svmax
operator|)
condition|?
name|SvIVx
argument_list|(
name|svargs
index|[
name|svix
operator|++
index|]
argument_list|)
else|:
literal|0
expr_stmt|;
name|left
operator||=
operator|(
name|i
operator|<
literal|0
operator|)
expr_stmt|;
name|width
operator|=
operator|(
name|i
operator|<
literal|0
operator|)
condition|?
operator|-
name|i
else|:
name|i
expr_stmt|;
name|q
operator|++
expr_stmt|;
break|break;
block|}
comment|/* PRECISION */
if|if
condition|(
operator|*
name|q
operator|==
literal|'.'
condition|)
block|{
name|q
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|args
condition|)
name|i
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
operator|(
name|svix
operator|<
name|svmax
operator|)
condition|?
name|SvIVx
argument_list|(
name|svargs
index|[
name|svix
operator|++
index|]
argument_list|)
else|:
literal|0
expr_stmt|;
name|precis
operator|=
operator|(
name|i
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
name|i
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
else|else
block|{
name|precis
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|q
argument_list|)
condition|)
name|precis
operator|=
name|precis
operator|*
literal|10
operator|+
operator|(
operator|*
name|q
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
name|has_precis
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* SIZE */
switch|switch
condition|(
operator|*
name|q
condition|)
block|{
case|case
literal|'l'
case|:
if|#
directive|if
literal|0
comment|/* when quads have better support within Perl */
block|if (*(q + 1) == 'l') { 		intsize = 'q'; 		q += 2; 		break; 	    }
endif|#
directive|endif
comment|/* FALL THROUGH */
case|case
literal|'h'
case|:
case|case
literal|'V'
case|:
name|intsize
operator|=
operator|*
name|q
operator|++
expr_stmt|;
break|break;
block|}
comment|/* CONVERSION */
switch|switch
condition|(
name|c
operator|=
operator|*
name|q
operator|++
condition|)
block|{
comment|/* STRINGS */
case|case
literal|'%'
case|:
name|eptr
operator|=
name|q
operator|-
literal|1
expr_stmt|;
name|elen
operator|=
literal|1
expr_stmt|;
goto|goto
name|string
goto|;
case|case
literal|'c'
case|:
if|if
condition|(
name|args
condition|)
name|c
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
else|else
name|c
operator|=
operator|(
name|svix
operator|<
name|svmax
operator|)
condition|?
name|SvIVx
argument_list|(
name|svargs
index|[
name|svix
operator|++
index|]
argument_list|)
else|:
literal|0
expr_stmt|;
name|eptr
operator|=
operator|&
name|c
expr_stmt|;
name|elen
operator|=
literal|1
expr_stmt|;
goto|goto
name|string
goto|;
case|case
literal|'s'
case|:
if|if
condition|(
name|args
condition|)
block|{
name|eptr
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
condition|)
name|elen
operator|=
name|strlen
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
else|else
block|{
name|eptr
operator|=
name|nullstr
expr_stmt|;
name|elen
operator|=
sizeof|sizeof
name|nullstr
operator|-
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|svix
operator|<
name|svmax
condition|)
name|eptr
operator|=
name|SvPVx
argument_list|(
name|svargs
index|[
name|svix
operator|++
index|]
argument_list|,
name|elen
argument_list|)
expr_stmt|;
goto|goto
name|string
goto|;
case|case
literal|'_'
case|:
comment|/* 	     * The "%_" hack might have to be changed someday, 	     * if ISO or ANSI decide to use '_' for something. 	     * So we keep it hidden from users' code. 	     */
if|if
condition|(
operator|!
name|args
condition|)
goto|goto
name|unknown
goto|;
name|eptr
operator|=
name|SvPVx
argument_list|(
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|SV
operator|*
argument_list|)
argument_list|,
name|elen
argument_list|)
expr_stmt|;
name|string
label|:
if|if
condition|(
name|has_precis
operator|&&
name|elen
operator|>
name|precis
condition|)
name|elen
operator|=
name|precis
expr_stmt|;
break|break;
comment|/* INTEGERS */
case|case
literal|'p'
case|:
if|if
condition|(
name|args
condition|)
name|uv
operator|=
operator|(
name|UV
operator|)
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
else|else
name|uv
operator|=
operator|(
name|svix
operator|<
name|svmax
operator|)
condition|?
operator|(
name|UV
operator|)
name|svargs
index|[
name|svix
operator|++
index|]
else|:
literal|0
expr_stmt|;
name|base
operator|=
literal|16
expr_stmt|;
goto|goto
name|integer
goto|;
case|case
literal|'D'
case|:
name|intsize
operator|=
literal|'l'
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
if|if
condition|(
name|args
condition|)
block|{
switch|switch
condition|(
name|intsize
condition|)
block|{
case|case
literal|'h'
case|:
name|iv
operator|=
operator|(
name|short
operator|)
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
default|default:
name|iv
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|iv
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|iv
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|IV
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|iv
operator|=
operator|(
name|svix
operator|<
name|svmax
operator|)
condition|?
name|SvIVx
argument_list|(
name|svargs
index|[
name|svix
operator|++
index|]
argument_list|)
else|:
literal|0
expr_stmt|;
switch|switch
condition|(
name|intsize
condition|)
block|{
case|case
literal|'h'
case|:
name|iv
operator|=
operator|(
name|short
operator|)
name|iv
expr_stmt|;
break|break;
default|default:
name|iv
operator|=
operator|(
name|int
operator|)
name|iv
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|iv
operator|=
operator|(
name|long
operator|)
name|iv
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
break|break;
block|}
block|}
if|if
condition|(
name|iv
operator|>=
literal|0
condition|)
block|{
name|uv
operator|=
name|iv
expr_stmt|;
if|if
condition|(
name|plus
condition|)
name|esignbuf
index|[
name|esignlen
operator|++
index|]
operator|=
name|plus
expr_stmt|;
block|}
else|else
block|{
name|uv
operator|=
operator|-
name|iv
expr_stmt|;
name|esignbuf
index|[
name|esignlen
operator|++
index|]
operator|=
literal|'-'
expr_stmt|;
block|}
name|base
operator|=
literal|10
expr_stmt|;
goto|goto
name|integer
goto|;
case|case
literal|'U'
case|:
name|intsize
operator|=
literal|'l'
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'u'
case|:
name|base
operator|=
literal|10
expr_stmt|;
goto|goto
name|uns_integer
goto|;
case|case
literal|'O'
case|:
name|intsize
operator|=
literal|'l'
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'o'
case|:
name|base
operator|=
literal|8
expr_stmt|;
goto|goto
name|uns_integer
goto|;
case|case
literal|'X'
case|:
case|case
literal|'x'
case|:
name|base
operator|=
literal|16
expr_stmt|;
name|uns_integer
label|:
if|if
condition|(
name|args
condition|)
block|{
switch|switch
condition|(
name|intsize
condition|)
block|{
case|case
literal|'h'
case|:
name|uv
operator|=
operator|(
name|unsigned
name|short
operator|)
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|unsigned
argument_list|)
expr_stmt|;
break|break;
default|default:
name|uv
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|unsigned
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|uv
operator|=
name|va_arg
argument_list|(
argument|*args
argument_list|,
argument|unsigned long
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|uv
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|UV
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|uv
operator|=
operator|(
name|svix
operator|<
name|svmax
operator|)
condition|?
name|SvUVx
argument_list|(
name|svargs
index|[
name|svix
operator|++
index|]
argument_list|)
else|:
literal|0
expr_stmt|;
switch|switch
condition|(
name|intsize
condition|)
block|{
case|case
literal|'h'
case|:
name|uv
operator|=
operator|(
name|unsigned
name|short
operator|)
name|uv
expr_stmt|;
break|break;
default|default:
name|uv
operator|=
operator|(
name|unsigned
operator|)
name|uv
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|uv
operator|=
operator|(
name|unsigned
name|long
operator|)
name|uv
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
break|break;
block|}
block|}
name|integer
label|:
name|eptr
operator|=
name|ebuf
operator|+
sizeof|sizeof
name|ebuf
expr_stmt|;
switch|switch
condition|(
name|base
condition|)
block|{
name|unsigned
name|dig
decl_stmt|;
case|case
literal|16
case|:
if|if
condition|(
operator|!
name|uv
condition|)
name|alt
operator|=
name|FALSE
expr_stmt|;
name|p
operator|=
operator|(
name|c
operator|==
literal|'X'
operator|)
condition|?
literal|"0123456789ABCDEF"
else|:
literal|"0123456789abcdef"
expr_stmt|;
do|do
block|{
name|dig
operator|=
name|uv
operator|&
literal|15
expr_stmt|;
operator|*
operator|--
name|eptr
operator|=
name|p
index|[
name|dig
index|]
expr_stmt|;
block|}
do|while
condition|(
name|uv
operator|>>=
literal|4
condition|)
do|;
if|if
condition|(
name|alt
condition|)
block|{
name|esignbuf
index|[
name|esignlen
operator|++
index|]
operator|=
literal|'0'
expr_stmt|;
name|esignbuf
index|[
name|esignlen
operator|++
index|]
operator|=
name|c
expr_stmt|;
comment|/* 'x' or 'X' */
block|}
break|break;
case|case
literal|8
case|:
do|do
block|{
name|dig
operator|=
name|uv
operator|&
literal|7
expr_stmt|;
operator|*
operator|--
name|eptr
operator|=
literal|'0'
operator|+
name|dig
expr_stmt|;
block|}
do|while
condition|(
name|uv
operator|>>=
literal|3
condition|)
do|;
if|if
condition|(
name|alt
operator|&&
operator|*
name|eptr
operator|!=
literal|'0'
condition|)
operator|*
operator|--
name|eptr
operator|=
literal|'0'
expr_stmt|;
break|break;
default|default:
comment|/* it had better be ten or less */
do|do
block|{
name|dig
operator|=
name|uv
operator|%
name|base
expr_stmt|;
operator|*
operator|--
name|eptr
operator|=
literal|'0'
operator|+
name|dig
expr_stmt|;
block|}
do|while
condition|(
name|uv
operator|/=
name|base
condition|)
do|;
break|break;
block|}
name|elen
operator|=
operator|(
name|ebuf
operator|+
sizeof|sizeof
name|ebuf
operator|)
operator|-
name|eptr
expr_stmt|;
if|if
condition|(
name|has_precis
condition|)
block|{
if|if
condition|(
name|precis
operator|>
name|elen
condition|)
name|zeros
operator|=
name|precis
operator|-
name|elen
expr_stmt|;
elseif|else
if|if
condition|(
name|precis
operator|==
literal|0
operator|&&
name|elen
operator|==
literal|1
operator|&&
operator|*
name|eptr
operator|==
literal|'0'
condition|)
name|elen
operator|=
literal|0
expr_stmt|;
block|}
break|break;
comment|/* FLOATING POINT */
case|case
literal|'F'
case|:
name|c
operator|=
literal|'f'
expr_stmt|;
comment|/* maybe %F isn't supported here */
comment|/* FALL THROUGH */
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
comment|/* This is evil, but floating point is even more evil */
if|if
condition|(
name|args
condition|)
name|nv
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|double
argument_list|)
expr_stmt|;
else|else
name|nv
operator|=
operator|(
name|svix
operator|<
name|svmax
operator|)
condition|?
name|SvNVx
argument_list|(
name|svargs
index|[
name|svix
operator|++
index|]
argument_list|)
else|:
literal|0.0
expr_stmt|;
name|need
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'e'
operator|&&
name|c
operator|!=
literal|'E'
condition|)
block|{
name|i
operator|=
name|PERL_INT_MIN
expr_stmt|;
operator|(
name|void
operator|)
name|frexp
argument_list|(
name|nv
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|PERL_INT_MIN
condition|)
name|die
argument_list|(
literal|"panic: frexp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|need
operator|=
name|BIT_DIGITS
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|need
operator|+=
name|has_precis
condition|?
name|precis
else|:
literal|6
expr_stmt|;
comment|/* known default */
if|if
condition|(
name|need
operator|<
name|width
condition|)
name|need
operator|=
name|width
expr_stmt|;
name|need
operator|+=
literal|20
expr_stmt|;
comment|/* fudge factor */
if|if
condition|(
name|efloatsize
operator|<
name|need
condition|)
block|{
name|Safefree
argument_list|(
name|efloatbuf
argument_list|)
expr_stmt|;
name|efloatsize
operator|=
name|need
operator|+
literal|20
expr_stmt|;
comment|/* more fudge */
name|New
argument_list|(
literal|906
argument_list|,
name|efloatbuf
argument_list|,
name|efloatsize
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
name|eptr
operator|=
name|ebuf
operator|+
sizeof|sizeof
name|ebuf
expr_stmt|;
operator|*
operator|--
name|eptr
operator|=
literal|'\0'
expr_stmt|;
operator|*
operator|--
name|eptr
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|has_precis
condition|)
block|{
name|base
operator|=
name|precis
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|eptr
operator|=
literal|'0'
operator|+
operator|(
name|base
operator|%
literal|10
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|base
operator|/=
literal|10
condition|)
do|;
operator|*
operator|--
name|eptr
operator|=
literal|'.'
expr_stmt|;
block|}
if|if
condition|(
name|width
condition|)
block|{
name|base
operator|=
name|width
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|eptr
operator|=
literal|'0'
operator|+
operator|(
name|base
operator|%
literal|10
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|base
operator|/=
literal|10
condition|)
do|;
block|}
if|if
condition|(
name|fill
operator|==
literal|'0'
condition|)
operator|*
operator|--
name|eptr
operator|=
name|fill
expr_stmt|;
if|if
condition|(
name|left
condition|)
operator|*
operator|--
name|eptr
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|plus
condition|)
operator|*
operator|--
name|eptr
operator|=
name|plus
expr_stmt|;
if|if
condition|(
name|alt
condition|)
operator|*
operator|--
name|eptr
operator|=
literal|'#'
expr_stmt|;
operator|*
operator|--
name|eptr
operator|=
literal|'%'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|efloatbuf
argument_list|,
name|eptr
argument_list|,
name|nv
argument_list|)
expr_stmt|;
name|eptr
operator|=
name|efloatbuf
expr_stmt|;
name|elen
operator|=
name|strlen
argument_list|(
name|efloatbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LC_NUMERIC
comment|/* 	     * User-defined locales may include arbitrary characters. 	     * And, unfortunately, some system may alloc the "C" locale 	     * to be overridden by a malicious user. 	     */
if|if
condition|(
name|used_locale
condition|)
operator|*
name|used_locale
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
comment|/* LC_NUMERIC */
break|break;
comment|/* SPECIAL */
case|case
literal|'n'
case|:
name|i
operator|=
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|-
name|origlen
expr_stmt|;
if|if
condition|(
name|args
condition|)
block|{
switch|switch
condition|(
name|intsize
condition|)
block|{
case|case
literal|'h'
case|:
operator|*
operator|(
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|short
operator|*
argument_list|)
operator|)
operator|=
name|i
expr_stmt|;
break|break;
default|default:
operator|*
operator|(
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|int
operator|*
argument_list|)
operator|)
operator|=
name|i
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
operator|*
operator|(
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|long
operator|*
argument_list|)
operator|)
operator|=
name|i
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
operator|*
operator|(
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|IV
operator|*
argument_list|)
operator|)
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|svix
operator|<
name|svmax
condition|)
name|sv_setuv
argument_list|(
name|svargs
index|[
name|svix
operator|++
index|]
argument_list|,
operator|(
name|UV
operator|)
name|i
argument_list|)
expr_stmt|;
continue|continue;
comment|/* not "break" */
comment|/* UNKNOWN */
default|default:
name|unknown
label|:
if|if
condition|(
operator|!
name|args
operator|&&
name|PL_dowarn
operator|&&
operator|(
name|PL_op
operator|->
name|op_type
operator|==
name|OP_PRTF
operator|||
name|PL_op
operator|->
name|op_type
operator|==
name|OP_SPRINTF
operator|)
condition|)
block|{
name|SV
modifier|*
name|msg
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
name|sv_setpvf
argument_list|(
name|msg
argument_list|,
literal|"Invalid conversion in %s: "
argument_list|,
operator|(
name|PL_op
operator|->
name|op_type
operator|==
name|OP_PRTF
operator|)
condition|?
literal|"printf"
else|:
literal|"sprintf"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
name|sv_catpvf
argument_list|(
name|msg
argument_list|,
name|isPRINT
argument_list|(
name|c
argument_list|)
condition|?
literal|"\"%%%c\""
else|:
literal|"\"%%\\%03o\""
argument_list|,
name|c
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
else|else
name|sv_catpv
argument_list|(
name|msg
argument_list|,
literal|"end of string"
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"%_"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* yes, this is reentrant */
block|}
comment|/* output mangled stuff ... */
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
operator|--
name|q
expr_stmt|;
name|eptr
operator|=
name|p
expr_stmt|;
name|elen
operator|=
name|q
operator|-
name|p
expr_stmt|;
comment|/* ... right here, because formatting flags should not apply */
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+
name|elen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|SvEND
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|eptr
argument_list|,
name|elen
argument_list|)
expr_stmt|;
name|p
operator|+=
name|elen
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|p
operator|-
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
continue|continue;
comment|/* not "break" */
block|}
name|have
operator|=
name|esignlen
operator|+
name|zeros
operator|+
name|elen
expr_stmt|;
name|need
operator|=
operator|(
name|have
operator|>
name|width
condition|?
name|have
else|:
name|width
operator|)
expr_stmt|;
name|gap
operator|=
name|need
operator|-
name|have
expr_stmt|;
name|SvGROW
argument_list|(
name|sv
argument_list|,
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|+
name|need
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|SvEND
argument_list|(
name|sv
argument_list|)
expr_stmt|;
if|if
condition|(
name|esignlen
operator|&&
name|fill
operator|==
literal|'0'
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|esignlen
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|esignbuf
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|gap
operator|&&
operator|!
name|left
condition|)
block|{
name|memset
argument_list|(
name|p
argument_list|,
name|fill
argument_list|,
name|gap
argument_list|)
expr_stmt|;
name|p
operator|+=
name|gap
expr_stmt|;
block|}
if|if
condition|(
name|esignlen
operator|&&
name|fill
operator|!=
literal|'0'
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|esignlen
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|esignbuf
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|zeros
condition|)
block|{
for|for
control|(
name|i
operator|=
name|zeros
init|;
name|i
condition|;
name|i
operator|--
control|)
operator|*
name|p
operator|++
operator|=
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
name|elen
condition|)
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
name|eptr
argument_list|,
name|elen
argument_list|)
expr_stmt|;
name|p
operator|+=
name|elen
expr_stmt|;
block|}
if|if
condition|(
name|gap
operator|&&
name|left
condition|)
block|{
name|memset
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|,
name|gap
argument_list|)
expr_stmt|;
name|p
operator|+=
name|gap
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|SvCUR
argument_list|(
name|sv
argument_list|)
operator|=
name|p
operator|-
name|SvPVX
argument_list|(
name|sv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sv_dump
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
name|SV
modifier|*
name|d
init|=
name|sv_newmortal
argument_list|()
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|U32
name|flags
decl_stmt|;
name|U32
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|sv
condition|)
block|{
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"SV = 0\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|flags
operator|=
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|type
operator|=
name|SvTYPE
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv_setpvf
argument_list|(
name|d
argument_list|,
literal|"(0x%lx)\n  REFCNT = %ld\n  FLAGS = ("
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|SvANY
argument_list|(
name|sv
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|SvREFCNT
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SVs_PADBUSY
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"PADBUSY,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SVs_PADTMP
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"PADTMP,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SVs_PADMY
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"PADMY,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SVs_TEMP
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"TEMP,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SVs_OBJECT
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"OBJECT,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SVs_GMG
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"GMG,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SVs_SMG
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"SMG,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SVs_RMG
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"RMG,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SVf_IOK
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"IOK,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SVf_NOK
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"NOK,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SVf_POK
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"POK,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SVf_ROK
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"ROK,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SVf_OOK
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"OOK,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SVf_FAKE
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"FAKE,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SVf_READONLY
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"READONLY,"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OVERLOAD
if|if
condition|(
name|flags
operator|&
name|SVf_AMAGIC
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"OVERLOAD,"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OVERLOAD */
if|if
condition|(
name|flags
operator|&
name|SVp_IOK
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"pIOK,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SVp_NOK
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"pNOK,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SVp_POK
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"pPOK,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SVp_SCREAM
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"SCREAM,"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SVt_PVCV
case|:
case|case
name|SVt_PVFM
case|:
if|if
condition|(
name|CvANON
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"ANON,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CvUNIQUE
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"UNIQUE,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CvCLONE
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"CLONE,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CvCLONED
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"CLONED,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CvNODEBUG
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"NODEBUG,"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVHV
case|:
if|if
condition|(
name|HvSHAREKEYS
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"SHAREKEYS,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HvLAZYDEL
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"LAZYDEL,"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVGV
case|:
if|if
condition|(
name|GvINTRO
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"INTRO,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GvMULTI
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"MULTI,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GvASSUMECV
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"ASSUMECV,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GvIMPORTED
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"IMPORT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GvIMPORTED
argument_list|(
name|sv
argument_list|)
operator|==
name|GVf_IMPORTED
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"ALL,"
argument_list|)
expr_stmt|;
else|else
block|{
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
if|if
condition|(
name|GvIMPORTED_SV
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|" SV"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GvIMPORTED_AV
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|" AV"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GvIMPORTED_HV
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|" HV"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GvIMPORTED_CV
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|" CV"
argument_list|)
expr_stmt|;
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|" ),"
argument_list|)
expr_stmt|;
block|}
block|}
case|case
name|SVt_PVBM
case|:
if|if
condition|(
name|SvTAIL
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"TAIL,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|SvCOMPILED
argument_list|(
name|sv
argument_list|)
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|"COMPILED,"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
operator|(
name|SvEND
argument_list|(
name|d
argument_list|)
operator|-
literal|1
operator|)
operator|==
literal|','
condition|)
name|SvPVX
argument_list|(
name|d
argument_list|)
index|[
operator|--
name|SvCUR
argument_list|(
name|d
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|s
operator|=
name|SvPVX
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"SV = "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SVt_NULL
case|:
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"NULL%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return;
case|case
name|SVt_IV
case|:
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"IV%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_NV
case|:
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"NV%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_RV
case|:
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"RV%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PV
case|:
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"PV%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVIV
case|:
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"PVIV%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVNV
case|:
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"PVNV%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVBM
case|:
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"PVBM%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVMG
case|:
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"PVMG%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVLV
case|:
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"PVLV%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVAV
case|:
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"PVAV%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVHV
case|:
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"PVHV%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVCV
case|:
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"PVCV%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVGV
case|:
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"PVGV%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVFM
case|:
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"PVFM%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVIO
case|:
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"PVIO%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"UNKNOWN%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|type
operator|>=
name|SVt_PVIV
operator|||
name|type
operator|==
name|SVt_IV
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  IV = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|SvIVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|>=
name|SVt_PVNV
operator|||
name|type
operator|==
name|SVt_NV
condition|)
block|{
name|SET_NUMERIC_STANDARD
argument_list|()
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  NV = %.*g\n"
argument_list|,
name|DBL_DIG
argument_list|,
name|SvNVX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SvROK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  RV = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|SvRV
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|sv_dump
argument_list|(
name|SvRV
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|type
operator|<
name|SVt_PV
condition|)
return|return;
if|if
condition|(
name|type
operator|<=
name|SVt_PVLV
condition|)
block|{
if|if
condition|(
name|SvPVX
argument_list|(
name|sv
argument_list|)
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  PV = 0x%lx \"%s\"\n  CUR = %ld\n  LEN = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
name|SvPVX
argument_list|(
name|sv
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|SvCUR
argument_list|(
name|sv
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|SvLEN
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  PV = 0\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|>=
name|SVt_PVMG
condition|)
block|{
if|if
condition|(
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  MAGIC = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|SvMAGIC
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SvSTASH
argument_list|(
name|sv
argument_list|)
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  STASH = \"%s\"\n"
argument_list|,
name|HvNAME
argument_list|(
name|SvSTASH
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SVt_PVLV
case|:
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  TYPE = %c\n"
argument_list|,
name|LvTYPE
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  TARGOFF = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|LvTARGOFF
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  TARGLEN = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|LvTARGLEN
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  TARG = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|LvTARG
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|sv_dump
argument_list|(
name|LvTARG
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVAV
case|:
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  ARRAY = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|AvARRAY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  ALLOC = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|AvALLOC
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  FILL = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|AvFILLp
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  MAX = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|AvMAX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  ARYLEN = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|AvARYLEN
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|=
name|AvFLAGS
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|sv_setpv
argument_list|(
name|d
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|AVf_REAL
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|",REAL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|AVf_REIFY
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|",REIFY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|AVf_REUSED
condition|)
name|sv_catpv
argument_list|(
name|d
argument_list|,
literal|",REUSED"
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  FLAGS = (%s)\n"
argument_list|,
name|SvCUR
argument_list|(
name|d
argument_list|)
condition|?
name|SvPVX
argument_list|(
name|d
argument_list|)
operator|+
literal|1
else|:
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVHV
case|:
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  ARRAY = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|HvARRAY
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  KEYS = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|HvKEYS
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  FILL = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|HvFILL
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  MAX = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|HvMAX
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  RITER = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|HvRITER
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  EITER = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|HvEITER
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HvPMROOT
argument_list|(
name|sv
argument_list|)
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  PMROOT = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|HvPMROOT
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|HvNAME
argument_list|(
name|sv
argument_list|)
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  NAME = \"%s\"\n"
argument_list|,
name|HvNAME
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVCV
case|:
if|if
condition|(
name|SvPOK
argument_list|(
name|sv
argument_list|)
condition|)
block|{
name|STRLEN
name|n_a
decl_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  PROTOTYPE = \"%s\"\n"
argument_list|,
name|SvPV
argument_list|(
name|sv
argument_list|,
name|n_a
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* FALL THROUGH */
case|case
name|SVt_PVFM
case|:
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  STASH = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|CvSTASH
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  START = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|CvSTART
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  ROOT = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|CvROOT
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  XSUB = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|CvXSUB
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  XSUBANY = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|CvXSUBANY
argument_list|(
name|sv
argument_list|)
operator|.
name|any_i32
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  GV = 0x%lx"
argument_list|,
operator|(
name|long
operator|)
name|CvGV
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CvGV
argument_list|(
name|sv
argument_list|)
operator|&&
name|GvNAME
argument_list|(
name|CvGV
argument_list|(
name|sv
argument_list|)
argument_list|)
condition|)
block|{
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  \"%s\"\n"
argument_list|,
name|GvNAME
argument_list|(
name|CvGV
argument_list|(
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  FILEGV = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|CvFILEGV
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  DEPTH = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|CvDEPTH
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  PADLIST = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|CvPADLIST
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  OUTSIDE = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|CvOUTSIDE
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_THREADS
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  MUTEXP = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|CvMUTEXP
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  OWNER = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|CvOWNER
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_THREADS */
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  FLAGS = 0x%lx\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|CvFLAGS
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SVt_PVFM
condition|)
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  LINES = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|FmLINES
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVGV
case|:
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  NAME = \"%s\"\n"
argument_list|,
name|GvNAME
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  NAMELEN = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|GvNAMELEN
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  STASH = \"%s\"\n"
argument_list|,
name|SvTYPE
argument_list|(
name|GvSTASH
argument_list|(
name|sv
argument_list|)
argument_list|)
operator|==
name|SVt_PVHV
condition|?
name|HvNAME
argument_list|(
name|GvSTASH
argument_list|(
name|sv
argument_list|)
argument_list|)
else|:
literal|"(deleted)"
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  GP = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|GvGP
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"    SV = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|GvSV
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"    REFCNT = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|GvREFCNT
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"    IO = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|GvIOp
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"    FORM = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|GvFORM
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"    AV = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|GvAV
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"    HV = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|GvHV
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"    CV = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|GvCV
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"    CVGEN = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|GvCVGEN
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"    LASTEXPR = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|GvLASTEXPR
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"    LINE = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|GvLINE
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"    FILEGV = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|GvFILEGV
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"    EGV = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|GvEGV
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVt_PVIO
case|:
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  IFP = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|IoIFP
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  OFP = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|IoOFP
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  DIRP = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|IoDIRP
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  LINES = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|IoLINES
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  PAGE = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|IoPAGE
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  PAGE_LEN = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|IoPAGE_LEN
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  LINES_LEFT = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|IoLINES_LEFT
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  TOP_NAME = \"%s\"\n"
argument_list|,
name|IoTOP_NAME
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  TOP_GV = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|IoTOP_GV
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  FMT_NAME = \"%s\"\n"
argument_list|,
name|IoFMT_NAME
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  FMT_GV = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|IoFMT_GV
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  BOTTOM_NAME = \"%s\"\n"
argument_list|,
name|IoBOTTOM_NAME
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  BOTTOM_GV = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|IoBOTTOM_GV
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  SUBPROCESS = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|IoSUBPROCESS
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  TYPE = %c\n"
argument_list|,
name|IoTYPE
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|PerlIO_printf
argument_list|(
name|Perl_debug_log
argument_list|,
literal|"  FLAGS = 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|IoFLAGS
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* DEBUGGING */
block|}
end_function

end_unit

